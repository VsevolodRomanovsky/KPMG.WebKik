/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	(function webpackMissingModule() { throw new Error("Cannot find module \"—config\""); }());
	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, __dirname) {var isDevBuild = process.argv.indexOf('--env.prod') < 0;
	var path = __webpack_require__(4);
	var webpack = __webpack_require__(5);
	var ExtractTextPlugin = __webpack_require__(340);
	
	
	module.exports = {
	    resolve: {
	        extensions: [ '', '.js' ]
	    },
	    module: {
	        loaders: [
	            { test: /\.(png|woff|woff2|eot|ttf|svg)(\?|$)/, loader: 'url-loader?limit=100000' }         
	        ]
	    },
	    entry: {
	        vendor: [
	            '@angular/common',
	            '@angular/compiler',
	            '@angular/core',
	            '@angular/http',
	            '@angular/platform-browser',
	            '@angular/platform-browser-dynamic',
	            '@angular/router',
	            '@angular/platform-server',
	            'angular2-universal',
	            'angular2-universal-polyfills',
	            'bootstrap-loader/extractStyles',
	            'es6-shim',
	            'es6-promise',
	            'event-source-polyfill',            
	            'zone.js',
	            'rxjs',
	            'ng2-uploader',
	            'bootstrap',
	            'd3',
	            'bootstrap-datepicker',
				'primeng/primeng',
				'@swimlane/ngx-datatable'
	        ]
	    },
	    output: {
	        path: path.join(__dirname, 'wwwroot', 'dist'),
	        filename: '[name].js',
	        library: '[name]_[hash]',
	    },
	    plugins: [
	        new ExtractTextPlugin('vendor.css', { allChunks: true }),
	        new webpack.ProvidePlugin({ $: 'jquery', jQuery: 'jquery' }), // Maps these identifiers to the jQuery package (because Bootstrap expects it to be a global variable)
	        new webpack.optimize.OccurenceOrderPlugin(),
	        new webpack.DllPlugin({
	            path: path.join(__dirname, 'wwwroot', 'dist', '[name]-manifest.json'),
	            name: '[name]_[hash]'
	        })
	    ].concat(isDevBuild ? [] : [
	        new webpack.optimize.UglifyJsPlugin({ compress: { warnings: false } })
	    ])
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), "/"))

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(3))(18);

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = vendor_ae97ba1cb2412c1a8644;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }
	
	  return parts;
	}
	
	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};
	
	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;
	
	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : process.cwd();
	
	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }
	
	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }
	
	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)
	
	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');
	
	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	};
	
	// path.normalize(path)
	// posix version
	exports.normalize = function(path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';
	
	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isAbsolute).join('/');
	
	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }
	
	  return (isAbsolute ? '/' : '') + path;
	};
	
	// posix version
	exports.isAbsolute = function(path) {
	  return path.charAt(0) === '/';
	};
	
	// posix version
	exports.join = function() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};
	
	
	// path.relative(from, to)
	// posix version
	exports.relative = function(from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);
	
	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }
	
	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }
	
	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }
	
	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));
	
	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }
	
	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }
	
	  outputParts = outputParts.concat(toParts.slice(samePartsLength));
	
	  return outputParts.join('/');
	};
	
	exports.sep = '/';
	exports.delimiter = ':';
	
	exports.dirname = function(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];
	
	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }
	
	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }
	
	  return root + dir;
	};
	
	
	exports.basename = function(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};
	
	
	exports.extname = function(path) {
	  return splitPath(path)[3];
	};
	
	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}
	
	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b'
	    ? function (str, start, len) { return str.substr(start, len) }
	    : function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Compiler = __webpack_require__(6);
	var WebEnvironmentPlugin = __webpack_require__(84);
	var WebpackOptionsApply = __webpack_require__(85);
	var WebpackOptionsDefaulter = __webpack_require__(338);
	
	function webpack(options, callback) {
		new WebpackOptionsDefaulter().process(options);
	
		var compiler = new Compiler();
		compiler.options = options;
		compiler.options = new WebpackOptionsApply().process(options, compiler);
		new WebEnvironmentPlugin(options.inputFileSystem, options.outputFileSystem).apply(compiler);
		if(callback) {
			compiler.run(callback);
		}
		return compiler;
	}
	module.exports = webpack;
	
	webpack.WebpackOptionsDefaulter = WebpackOptionsDefaulter;
	webpack.WebpackOptionsApply = WebpackOptionsApply;
	webpack.Compiler = Compiler;
	webpack.WebEnvironmentPlugin = WebEnvironmentPlugin;


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var path = __webpack_require__(4);
	var Tapable = __webpack_require__(8);
	
	var Compilation = __webpack_require__(9);
	var Parser = __webpack_require__(60);
	var Resolver = __webpack_require__(63);
	
	var NormalModuleFactory = __webpack_require__(67);
	var ContextModuleFactory = __webpack_require__(80);
	
	function Watching(compiler, watchOptions, handler) {
		this.startTime = null;
		this.invalid = false;
		this.error = null;
		this.stats = null;
		this.handler = handler;
		if(typeof watchOptions === "number") {
			this.watchOptions = {
				aggregateTimeout: watchOptions
			};
		} else if(watchOptions && typeof watchOptions === "object") {
			this.watchOptions = Object.create(watchOptions);
		} else {
			this.watchOptions = {};
		}
		this.watchOptions.aggregateTimeout = this.watchOptions.aggregateTimeout || 200;
		this.compiler = compiler;
		this.running = true;
		this.compiler.readRecords(function(err) {
			if(err) return this._done(err);
	
			this._go();
		}.bind(this));
	}
	
	Watching.prototype._go = function() {
		this.startTime = new Date().getTime();
		this.running = true;
		this.invalid = false;
		this.compiler.applyPluginsAsync("watch-run", this, function(err) {
			if(err) return this._done(err);
			this.compiler.compile(function(err, compilation) {
				if(err) return this._done(err);
				if(this.invalid) return this._done();
	
				if(this.compiler.applyPluginsBailResult("should-emit", compilation) === false) {
					return this._done(null, compilation);
				}
	
				this.compiler.emitAssets(compilation, function(err) {
					if(err) return this._done(err);
					if(this.invalid) return this._done();
	
					this.compiler.emitRecords(function(err) {
						if(err) return this._done(err);
	
						return this._done(null, compilation);
					}.bind(this));
				}.bind(this));
			}.bind(this));
		}.bind(this));
	};
	
	Watching.prototype._done = function(err, compilation) {
		this.running = false;
		if(this.invalid) return this._go();
		this.error = err || null;
		this.stats = compilation ? compilation.getStats() : null;
		if(this.stats) {
			this.stats.startTime = this.startTime;
			this.stats.endTime = new Date().getTime();
		}
		if(this.stats)
			this.compiler.applyPlugins("done", this.stats);
		else
			this.compiler.applyPlugins("failed", this.error);
		this.handler(this.error, this.stats);
		if(!this.error)
			this.watch(compilation.fileDependencies, compilation.contextDependencies, compilation.missingDependencies);
	};
	
	Watching.prototype.watch = function(files, dirs, missing) {
		this.watcher = this.compiler.watchFileSystem.watch(files, dirs, missing, this.startTime, this.watchOptions, function(err, filesModified, contextModified, missingModified, fileTimestamps, contextTimestamps) {
			this.watcher = null;
			if(err) return this.handler(err);
	
			this.compiler.fileTimestamps = fileTimestamps;
			this.compiler.contextTimestamps = contextTimestamps;
			this.invalidate();
		}.bind(this), function() {
			this.compiler.applyPlugins("invalid");
		}.bind(this));
	};
	
	Watching.prototype.invalidate = function() {
		if(this.watcher) {
			this.watcher.pause();
			this.watcher = null;
		}
		if(this.running) {
			this.invalid = true;
			return false;
		} else {
			this._go();
		}
	};
	
	Watching.prototype.close = function(callback) {
		if(callback === undefined) callback = function() {};
	
		if(this.watcher) {
			this.watcher.close();
			this.watcher = null;
		}
		if(this.running) {
			this.invalid = true;
			this._done = function() {
				callback();
			};
		} else {
			callback();
		}
	};
	
	function Compiler() {
		Tapable.call(this);
	
		this.outputPath = "";
		this.outputFileSystem = null;
		this.inputFileSystem = null;
	
		this.recordsInputPath = null;
		this.recordsOutputPath = null;
		this.records = {};
	
		this.fileTimestamps = {};
		this.contextTimestamps = {};
	
		this.resolvers = {
			normal: new Resolver(null),
			loader: new Resolver(null),
			context: new Resolver(null)
		};
		this.parser = new Parser();
	
		this.options = {};
	}
	module.exports = Compiler;
	
	Compiler.prototype = Object.create(Tapable.prototype);
	Compiler.prototype.constructor = Compiler;
	
	Compiler.Watching = Watching;
	Compiler.prototype.watch = function(watchOptions, handler) {
		this.fileTimestamps = {};
		this.contextTimestamps = {};
		var watching = new Watching(this, watchOptions, handler);
		return watching;
	};
	
	Compiler.prototype.run = function(callback) {
		var startTime = new Date().getTime();
		this.applyPluginsAsync("run", this, function(err) {
			if(err) return callback(err);
	
			this.readRecords(function(err) {
				if(err) return callback(err);
	
				this.compile(function(err, compilation) {
					if(err) return callback(err);
	
					if(this.applyPluginsBailResult("should-emit", compilation) === false) {
						var stats = compilation.getStats();
						stats.startTime = startTime;
						stats.endTime = new Date().getTime();
						this.applyPlugins("done", stats);
						return callback(null, stats);
					}
	
					this.emitAssets(compilation, function(err) {
						if(err) return callback(err);
	
						this.emitRecords(function(err) {
							if(err) return callback(err);
	
							var stats = compilation.getStats();
							stats.startTime = startTime;
							stats.endTime = new Date().getTime();
							this.applyPlugins("done", stats);
							return callback(null, stats);
						}.bind(this));
					}.bind(this));
				}.bind(this));
			}.bind(this));
		}.bind(this));
	};
	
	Compiler.prototype.runAsChild = function(callback) {
		this.compile(function(err, compilation) {
			if(err) return callback(err);
	
			this.parentCompilation.children.push(compilation);
			Object.keys(compilation.assets).forEach(function(name) {
				this.parentCompilation.assets[name] = compilation.assets[name];
			}.bind(this));
	
			var entries = compilation.chunks.filter(function(chunk) {
				return chunk.entry;
			});
			return callback(null, entries, compilation);
		}.bind(this));
	};
	
	Compiler.prototype.purgeInputFileSystem = function() {
		if(this.inputFileSystem && this.inputFileSystem.purge)
			this.inputFileSystem.purge();
	};
	
	Compiler.prototype.emitAssets = function(compilation, callback) {
		var outputPath;
	
		this.applyPluginsAsync("emit", compilation, function(err) {
			if(err) return callback(err);
			outputPath = compilation.getPath(this.outputPath);
			this.outputFileSystem.mkdirp(outputPath, emitFiles.bind(this));
		}.bind(this));
	
		function emitFiles(err) {
			if(err) return callback(err);
	
			__webpack_require__(10).forEach(Object.keys(compilation.assets), function(file, callback) {
	
				var targetFile = file;
				var queryStringIdx = targetFile.indexOf("?");
				if(queryStringIdx >= 0) {
					targetFile = targetFile.substr(0, queryStringIdx);
				}
	
				if(targetFile.match(/\/|\\/)) {
					var dir = path.dirname(targetFile);
					this.outputFileSystem.mkdirp(this.outputFileSystem.join(outputPath, dir), writeOut.bind(this));
				} else writeOut.call(this);
	
				function writeOut(err) {
					if(err) return callback(err);
					var targetPath = this.outputFileSystem.join(outputPath, targetFile);
					var source = compilation.assets[file];
					if(source.existsAt === targetPath) {
						source.emitted = false;
						return callback();
					}
					var content = source.source();
					if(!Buffer.isBuffer(content))
						content = new Buffer(content, "utf-8");
					source.existsAt = targetPath;
					source.emitted = true;
					this.outputFileSystem.writeFile(targetPath, content, callback);
				}
	
			}.bind(this), function(err) {
				if(err) return callback(err);
	
				afterEmit.call(this);
			}.bind(this));
		}
	
		function afterEmit() {
			this.applyPluginsAsync("after-emit", compilation, function(err) {
				if(err) return callback(err);
	
				return callback();
			});
		}
	
	};
	
	Compiler.prototype.emitRecords = function emitRecords(callback) {
		if(!this.recordsOutputPath) return callback();
		var idx1 = this.recordsOutputPath.lastIndexOf("/");
		var idx2 = this.recordsOutputPath.lastIndexOf("\\");
		var recordsOutputPathDirectory = null;
		if(idx1 > idx2) recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx1);
		if(idx1 < idx2) recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx2);
		if(!recordsOutputPathDirectory) return writeFile.call(this);
		this.outputFileSystem.mkdirp(recordsOutputPathDirectory, function(err) {
			if(err) return callback(err);
			writeFile.call(this);
		}.bind(this));
	
		function writeFile() {
			this.outputFileSystem.writeFile(this.recordsOutputPath, JSON.stringify(this.records, undefined, 2), callback);
		}
	};
	
	Compiler.prototype.readRecords = function readRecords(callback) {
		if(!this.recordsInputPath) {
			this.records = {};
			return callback();
		}
		this.inputFileSystem.stat(this.recordsInputPath, function(err) {
			// It doesn't exist
			// We can ignore this.
			if(err) return callback();
	
			this.inputFileSystem.readFile(this.recordsInputPath, function(err, content) {
				if(err) return callback(err);
	
				try {
					this.records = JSON.parse(content);
				} catch(e) {
					e.message = "Cannot parse records: " + e.message;
					return callback(e);
				}
	
				return callback();
			}.bind(this));
		}.bind(this));
	};
	
	Compiler.prototype.createChildCompiler = function(compilation, compilerName, outputOptions) {
		var childCompiler = new Compiler();
		for(var name in this._plugins) {
			if(["make", "compile", "emit", "after-emit", "invalid", "done", "this-compilation"].indexOf(name) < 0)
				childCompiler._plugins[name] = this._plugins[name].slice();
		}
		childCompiler.name = compilerName;
		childCompiler.outputPath = this.outputPath;
		childCompiler.inputFileSystem = this.inputFileSystem;
		childCompiler.outputFileSystem = null;
		childCompiler.resolvers = this.resolvers;
		childCompiler.parser = this.parser;
		childCompiler.fileTimestamps = this.fileTimestamps;
		childCompiler.contextTimestamps = this.contextTimestamps;
		if(!this.records[compilerName]) this.records[compilerName] = [];
		this.records[compilerName].push(childCompiler.records = {});
		childCompiler.options = Object.create(this.options);
		childCompiler.options.output = Object.create(childCompiler.options.output);
		for(name in outputOptions) {
			childCompiler.options.output[name] = outputOptions[name];
		}
		childCompiler.parentCompilation = compilation;
		return childCompiler;
	};
	
	Compiler.prototype.isChild = function() {
		return !!this.parentCompilation;
	};
	
	Compiler.prototype.createCompilation = function() {
		return new Compilation(this);
	};
	
	Compiler.prototype.newCompilation = function(params) {
		var compilation = this.createCompilation();
		compilation.fileTimestamps = this.fileTimestamps;
		compilation.contextTimestamps = this.contextTimestamps;
		compilation.name = this.name;
		compilation.records = this.records;
		this.applyPlugins("this-compilation", compilation, params);
		this.applyPlugins("compilation", compilation, params);
		return compilation;
	};
	
	Compiler.prototype.createNormalModuleFactory = function() {
		var normalModuleFactory = new NormalModuleFactory(this.options.context, this.resolvers, this.parser, this.options.module || {});
		this.applyPlugins("normal-module-factory", normalModuleFactory);
		return normalModuleFactory;
	};
	
	Compiler.prototype.createContextModuleFactory = function() {
		var contextModuleFactory = new ContextModuleFactory(this.resolvers, this.inputFileSystem);
		this.applyPlugins("context-module-factory", contextModuleFactory);
		return contextModuleFactory;
	};
	
	Compiler.prototype.newCompilationParams = function() {
		var params = {
			normalModuleFactory: this.createNormalModuleFactory(),
			contextModuleFactory: this.createContextModuleFactory()
		};
		return params;
	};
	
	Compiler.prototype.compile = function(callback) {
		var params = this.newCompilationParams();
		this.applyPlugins("compile", params);
	
		var compilation = this.newCompilation(params);
	
		this.applyPluginsParallel("make", compilation, function(err) {
			if(err) return callback(err);
	
			compilation.seal(function(err) {
				if(err) return callback(err);
	
				this.applyPluginsAsync("after-compile", compilation, function(err) {
					if(err) return callback(err);
	
					return callback(null, compilation);
				});
			}.bind(this));
		}.bind(this));
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7).Buffer))

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(3))(14);

/***/ },
/* 8 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function Tapable() {
		this._plugins = {};
	}
	module.exports = Tapable;
	
	function copyProperties(from, to) {
		for(var key in from)
			to[key] = from[key];
		return to;
	}
	
	Tapable.mixin = function mixinTapable(pt) {
		copyProperties(Tapable.prototype, pt);
	}
	
	Tapable.prototype.applyPlugins = function applyPlugins(name) {
		if(!this._plugins[name]) return;
		var args = Array.prototype.slice.call(arguments, 1);
		var plugins = this._plugins[name];
		var old = this._currentPluginApply;
		for(this._currentPluginApply = 0; this._currentPluginApply < plugins.length; this._currentPluginApply++)
			plugins[this._currentPluginApply].apply(this, args);
		this._currentPluginApply = old;
	};
	
	Tapable.prototype.applyPluginsWaterfall = function applyPlugins(name, init) {
		if(!this._plugins[name]) return init;
		var args = Array.prototype.slice.call(arguments, 2);
		var plugins = this._plugins[name];
		var current = init;
		var old = this._currentPluginApply;
		for(this._currentPluginApply = 0; this._currentPluginApply < plugins.length; this._currentPluginApply++)
			current = plugins[this._currentPluginApply].apply(this, [current].concat(args));
		this._currentPluginApply = old;
		return current;
	};
	
	Tapable.prototype.applyPluginsBailResult = function applyPluginsBailResult(name) {
		if(!this._plugins[name]) return;
		var args = Array.prototype.slice.call(arguments, 1);
		var plugins = this._plugins[name];
		var old = this._currentPluginApply
		for(this._currentPluginApply = 0; this._currentPluginApply < plugins.length; this._currentPluginApply++) {
			var result = plugins[this._currentPluginApply].apply(this, args);
			if(typeof result !== "undefined") {
				this._currentPluginApply = old;
				return result;
			}
		}
		this._currentPluginApply = old;
	};
	
	Tapable.prototype.applyPluginsAsyncSeries = Tapable.prototype.applyPluginsAsync = function applyPluginsAsync(name) {
		var args = Array.prototype.slice.call(arguments, 1);
		var callback = args.pop();
		if(!this._plugins[name] || this._plugins[name].length == 0) return callback();
		var plugins = this._plugins[name];
		var i = 0;
		args.push(copyProperties(callback, function next(err) {
			if(err) return callback(err);
			i++;
			if(i >= plugins.length) {
				return callback();
			}
			plugins[i].apply(this, args);
		}.bind(this)));
		plugins[0].apply(this, args);
	};
	
	Tapable.prototype.applyPluginsAsyncWaterfall = function applyPluginsAsyncWaterfall(name, init, callback) {
		if(!this._plugins[name] || this._plugins[name].length == 0) return callback(null, init);
		var plugins = this._plugins[name];
		var i = 0;
		var next = copyProperties(callback, function(err, value) {
			if(err) return callback(err);
			i++;
			if(i >= plugins.length) {
				return callback(null, value);
			}
			plugins[i].call(this, value, next);
		}.bind(this));
		plugins[0].call(this, init, next);
	};
	
	Tapable.prototype.applyPluginsParallel = function applyPluginsParallel(name) {
		var args = Array.prototype.slice.call(arguments, 1);
		var callback = args.pop();
		if(!this._plugins[name] || this._plugins[name].length == 0) return callback();
		var plugins = this._plugins[name];
		var remaining = plugins.length;
		args.push(copyProperties(callback, function(err) {
			if(remaining < 0) return; // ignore
			if(err) {
				remaining = -1;
				return callback(err);
			}
			remaining--;
			if(remaining == 0) {
				return callback();
			}
		}));
		for(var i = 0; i < plugins.length; i++) {
			plugins[i].apply(this, args);
			if(remaining < 0) return;
		}
	};
	
	Tapable.prototype.applyPluginsParallelBailResult = function applyPluginsParallelBailResult(name) {
		var args = Array.prototype.slice.call(arguments, 1);
		var callback = args[args.length-1];
		if(!this._plugins[name] || this._plugins[name].length == 0) return callback();
		var plugins = this._plugins[name];
		var currentPos = plugins.length;
		var currentError, currentResult;
		var done = [];
		for(var i = 0; i < plugins.length; i++) {
			args[args.length-1] = (function(i) {
				return copyProperties(callback, function(err, result) {
					if(i >= currentPos) return; // ignore
					done.push(i);
					if(err || result) {
						currentPos = i + 1;
						done = done.filter(function(item) {
							return item <= i;
						});
						currentError = err;
						currentResult = result;
					}
					if(done.length == currentPos) {
						callback(currentError, currentResult);
						currentPos = 0;
					}
				});
			}(i));
			plugins[i].apply(this, args);
		}
	};
	
	
	Tapable.prototype.restartApplyPlugins = function restartApplyPlugins() {
		if(typeof this._currentPluginApply !== "number")
			throw new Error("Tapable.prototype.restartApplyPlugins can only be used inside of any sync plugins application");
		this._currentPluginApply = -1;
	};
	
	
	Tapable.prototype.plugin = function plugin(name, fn) {
		if(Array.isArray(name)) {
			name.forEach(function(name) {
				this.plugin(name, fn);
			}, this);
			return;
		}
		if(!this._plugins[name]) this._plugins[name] = [fn];
		else this._plugins[name].push(fn);
	};
	
	Tapable.prototype.apply = function apply() {
		for(var i = 0; i < arguments.length; i++) {
			arguments[i].apply(this);
		}
	};


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var async = __webpack_require__(10);
	
	var Tapable = __webpack_require__(8);
	var EntryModuleNotFoundError = __webpack_require__(12);
	var ModuleNotFoundError = __webpack_require__(13);
	var CriticalDependenciesWarning = __webpack_require__(14);
	var Module = __webpack_require__(15);
	var ArrayMap = __webpack_require__(43);
	var Chunk = __webpack_require__(44);
	var Stats = __webpack_require__(45);
	var MainTemplate = __webpack_require__(48);
	var ChunkTemplate = __webpack_require__(53);
	var HotUpdateChunkTemplate = __webpack_require__(54);
	var ModuleTemplate = __webpack_require__(55);
	var Dependency = __webpack_require__(56);
	var ChunkRenderError = __webpack_require__(57);
	var CachedSource = __webpack_require__(58);
	
	function Compilation(compiler) {
		Tapable.call(this);
		this.compiler = compiler;
		this.resolvers = compiler.resolvers;
		this.inputFileSystem = compiler.inputFileSystem;
	
		var options = this.options = compiler.options;
		this.outputOptions = options && options.output;
		this.bail = options && options.bail;
		this.profile = options && options.profile;
	
		this.mainTemplate = new MainTemplate(this.outputOptions);
		this.chunkTemplate = new ChunkTemplate(this.outputOptions, this.mainTemplate);
		this.hotUpdateChunkTemplate = new HotUpdateChunkTemplate(this.outputOptions);
		this.moduleTemplate = new ModuleTemplate(this.outputOptions);
	
		this.entries = [];
		this.preparedChunks = [];
		this.chunks = [];
		this.namedChunks = {};
		this.modules = [];
		this._modules = {};
		this.cache = null;
		this.records = null;
		this.nextFreeModuleId = 1;
		this.nextFreeChunkId = 0;
		this.nextFreeModuleIndex = 0;
		this.nextFreeModuleIndex2 = 0;
		this.additionalChunkAssets = [];
		this.assets = {};
		this.errors = [];
		this.warnings = [];
		this.children = [];
		this.dependencyFactories = new ArrayMap();
		this.dependencyTemplates = new ArrayMap();
	}
	module.exports = Compilation;
	
	Compilation.prototype = Object.create(Tapable.prototype);
	Compilation.prototype.constructor = Compilation;
	
	Compilation.prototype.templatesPlugin = function(name, fn) {
		this.mainTemplate.plugin(name, fn);
		this.chunkTemplate.plugin(name, fn);
	};
	
	Compilation.prototype.addModule = function(module, cacheGroup) {
		cacheGroup = cacheGroup || "m";
		var identifier = module.identifier();
		if(this._modules[identifier]) {
			return false;
		}
		if(this.cache && this.cache[cacheGroup + identifier]) {
			var cacheModule = this.cache[cacheGroup + identifier];
	
			var rebuild = true;
			if(!cacheModule.error && cacheModule.cacheable && this.fileTimestamps && this.contextTimestamps) {
				rebuild = cacheModule.needRebuild(this.fileTimestamps, this.contextTimestamps);
			}
	
			if(!rebuild) {
				cacheModule.disconnect();
				this._modules[identifier] = cacheModule;
				this.modules.push(cacheModule);
				cacheModule.errors.forEach(function(err) {
					this.errors.push(err);
				}, this);
				cacheModule.warnings.forEach(function(err) {
					this.warnings.push(err);
				}, this);
				return cacheModule;
			} else {
				module.lastId = cacheModule.id;
			}
		}
		this._modules[identifier] = module;
		if(this.cache) {
			this.cache[cacheGroup + identifier] = module;
		}
		this.modules.push(module);
		return true;
	};
	
	Compilation.prototype.getModule = function(module) {
		var identifier = module.identifier();
		return this._modules[identifier];
	};
	
	Compilation.prototype.findModule = function(identifier) {
		return this._modules[identifier];
	};
	
	Compilation.prototype.buildModule = function(module, thisCallback) {
		this.applyPlugins("build-module", module);
		if(module.building) return module.building.push(thisCallback);
		var building = module.building = [thisCallback];
	
		function callback(err) {
			module.building = undefined;
			building.forEach(function(cb) {
				cb(err);
			});
		}
		module.build(this.options, this, this.resolvers.normal, this.inputFileSystem, function(err) {
			module.errors.forEach(function(err) {
				this.errors.push(err);
			}, this);
			module.warnings.forEach(function(err) {
				this.warnings.push(err);
			}, this);
			module.dependencies.sort(Dependency.compare);
			if(err) {
				module.error = err;
				this.applyPlugins("failed-module", module);
				return callback(err);
			}
			this.applyPlugins("succeed-module", module);
			return callback();
		}.bind(this));
	};
	
	Compilation.prototype.processModuleDependencies = function(module, callback) {
		var dependencies = [];
	
		function addDependency(dep) {
			for(var i = 0; i < dependencies.length; i++) {
				if(dep.isEqualResource(dependencies[i][0])) {
					return dependencies[i].push(dep);
				}
			}
			dependencies.push([dep]);
		}
	
		function addDependenciesBlock(block) {
			if(block.dependencies) {
				block.dependencies.forEach(addDependency);
			}
			if(block.blocks) {
				block.blocks.forEach(addDependenciesBlock);
			}
			if(block.variables) {
				block.variables.forEach(function(v) {
					v.dependencies.forEach(addDependency);
				});
			}
		}
		addDependenciesBlock(module);
		this.addModuleDependencies(module, dependencies, this.bail, null, true, callback);
	};
	
	Compilation.prototype.addModuleDependencies = function(module, dependencies, bail, cacheGroup, recursive, callback) {
		var _this = this;
		var start = _this.profile && +new Date();
	
		var factories = [];
		for(var i = 0; i < dependencies.length; i++) {
			var factory = _this.dependencyFactories.get(dependencies[i][0].constructor);
			if(!factory) {
				return callback(new Error("No module factory available for dependency type: " + dependencies[i][0].constructor.name));
			}
			factories[i] = [factory, dependencies[i]];
		}
		async.forEach(factories, function(item, callback) {
			var dependencies = item[1];
			var criticalDependencies = dependencies.filter(function(d) {
				return !!d.critical;
			});
			if(criticalDependencies.length > 0) {
				_this.warnings.push(new CriticalDependenciesWarning(module, criticalDependencies));
			}
	
			var errorAndCallback = function errorAndCallback(err) {
				err.dependencies = dependencies;
				err.origin = module;
				module.dependenciesErrors.push(err);
				_this.errors.push(err);
				if(bail) {
					callback(err);
				} else {
					callback();
				}
			};
			var warningAndCallback = function warningAndCallback(err) {
				err.dependencies = dependencies;
				err.origin = module;
				module.dependenciesWarnings.push(err);
				_this.warnings.push(err);
				callback();
			};
	
			var factory = item[0];
			factory.create(module.context, dependencies[0], function(err, dependantModule) {
				function isOptional() {
					return dependencies.filter(function(d) {
						return !d.optional;
					}).length === 0;
				}
	
				function errorOrWarningAndCallback(err) {
					if(isOptional()) {
						return warningAndCallback(err);
					} else {
						return errorAndCallback(err);
					}
				}
				if(err) {
					return errorOrWarningAndCallback(new ModuleNotFoundError(module, err));
				}
				if(!dependantModule) {
					return process.nextTick(callback);
				}
				if(_this.profile) {
					if(!dependantModule.profile) {
						dependantModule.profile = {};
					}
					var afterFactory = +new Date();
					dependantModule.profile.factory = afterFactory - start;
				}
	
				dependantModule.issuer = module.identifier();
				var newModule = _this.addModule(dependantModule, cacheGroup);
	
				if(!newModule) { // from cache
					dependantModule = _this.getModule(dependantModule);
	
					if(dependantModule.optional) {
						dependantModule.optional = isOptional();
					}
	
					if(dependantModule.id === 0) {
						return errorOrWarningAndCallback(
							new ModuleNotFoundError(module, new Error("a dependency to an entry point is not allowed"))
						);
					}
	
					dependencies.forEach(function(dep) {
						dep.module = dependantModule;
						dependantModule.addReason(module, dep);
					});
	
					if(_this.profile) {
						if(!module.profile) {
							module.profile = {};
						}
						var time = +new Date() - start;
						if(!module.profile.dependencies || time > module.profile.dependencies) {
							module.profile.dependencies = time;
						}
					}
	
					return process.nextTick(callback);
				}
	
				if(newModule instanceof Module) {
					if(_this.profile) {
						newModule.profile = dependantModule.profile;
					}
	
					newModule.optional = isOptional();
					newModule.issuer = dependantModule.issuer;
					dependantModule = newModule;
	
					dependencies.forEach(function(dep) {
						dep.module = dependantModule;
						dependantModule.addReason(module, dep);
					});
	
					if(_this.profile) {
						var afterBuilding = +new Date();
						module.profile.building = afterBuilding - afterFactory;
					}
	
					if(recursive) {
						return process.nextTick(_this.processModuleDependencies.bind(_this, dependantModule, callback));
					} else {
						return process.nextTick(callback);
					}
				}
	
				dependantModule.optional = isOptional();
	
				dependencies.forEach(function(dep) {
					dep.module = dependantModule;
					dependantModule.addReason(module, dep);
				});
	
				_this.buildModule(dependantModule, function(err) {
					if(err) {
						return errorOrWarningAndCallback(err);
					}
	
					if(_this.profile) {
						var afterBuilding = +new Date();
						dependantModule.profile.building = afterBuilding - afterFactory;
					}
	
					if(recursive) {
						_this.processModuleDependencies(dependantModule, callback);
					} else {
						return callback();
					}
				});
	
			});
		}, function(err) {
			if(err) {
				return callback(err);
			}
	
			return callback();
		});
	};
	
	Compilation.prototype._addModuleChain = function process(context, dependency, onModule, callback) {
		var start = this.profile && +new Date();
	
		var errorAndCallback = this.bail ? function errorAndCallback(err) {
			callback(err);
		} : function errorAndCallback(err) {
			err.dependencies = [dependency];
			this.errors.push(err);
			callback();
		}.bind(this);
	
		if(typeof dependency !== "object" || dependency === null || !dependency.constructor) {
			throw new Error("Parameter 'dependency' must be a Dependency");
		}
	
		var moduleFactory = this.dependencyFactories.get(dependency.constructor);
		if(!moduleFactory) {
			throw new Error("No dependency factory available for this dependency type: " + dependency.constructor.name);
		}
	
		moduleFactory.create(context, dependency, function(err, module) {
			if(err) {
				return errorAndCallback(new EntryModuleNotFoundError(err));
			}
	
			if(this.profile) {
				if(!module.profile) {
					module.profile = {};
				}
				var afterFactory = +new Date();
				module.profile.factory = afterFactory - start;
			}
	
			var result = this.addModule(module);
			if(!result) {
				module = this.getModule(module);
	
				onModule(module);
	
				if(this.profile) {
					var afterBuilding = +new Date();
					module.profile.building = afterBuilding - afterFactory;
				}
	
				return callback(null, module);
			}
	
			if(result instanceof Module) {
				if(this.profile) {
					result.profile = module.profile;
				}
	
				module = result;
	
				onModule(module);
	
				moduleReady.call(this);
				return;
			}
	
			onModule(module);
	
			this.buildModule(module, function(err) {
				if(err) {
					return errorAndCallback(err);
				}
	
				if(this.profile) {
					var afterBuilding = +new Date();
					module.profile.building = afterBuilding - afterFactory;
				}
	
				moduleReady.call(this);
			}.bind(this));
	
			function moduleReady() {
				this.processModuleDependencies(module, function(err) {
					if(err) {
						return callback(err);
					}
	
					return callback(null, module);
				});
			}
		}.bind(this));
	};
	
	Compilation.prototype.addEntry = function process(context, entry, name, callback) {
		this._addModuleChain(context, entry, function(module) {
	
			entry.module = module;
			this.entries.push(module);
			module.issuer = null;
			module.id = 0;
	
		}.bind(this), function(err, module) {
			if(err) {
				return callback(err);
			}
	
			if(module) {
				if(module.reasons.length > 0) {
					return callback(new Error("module cannot be added as entry point, because it's already in the bundle"));
				}
				this.preparedChunks.push({
					name: name,
					module: module
				});
			}
			return callback();
		}.bind(this));
	};
	
	Compilation.prototype.prefetch = function process(context, dependency, callback) {
		this._addModuleChain(context, dependency, function(module) {
	
			module.prefetched = true;
			module.issuer = null;
	
		}, callback);
	};
	
	Compilation.prototype.rebuildModule = function(module, thisCallback) {
		if(module.variables.length || module.blocks.length)
			throw new Error("Cannot rebuild a complex module with variables or blocks");
		if(module.rebuilding) {
			return module.rebuilding.push(thisCallback);
		}
		var rebuilding = module.rebuilding = [thisCallback];
	
		function callback(err) {
			module.rebuilding = undefined;
			rebuilding.forEach(function(cb) {
				cb(err);
			});
		}
		var deps = module.dependencies.slice();
		this.buildModule(module, function(err) {
			if(err) return callback(err);
	
			this.processModuleDependencies(module, function(err) {
				if(err) return callback(err);
				deps.forEach(function(d) {
					if(d.module && d.module.removeReason(module, d)) {
						module.chunks.forEach(function(chunk) {
							if(!d.module.hasReasonForChunk(chunk)) {
								if(d.module.removeChunk(chunk)) {
									this.removeChunkFromDependencies(d.module, chunk);
								}
							}
						}, this);
					}
				}, this);
				callback();
			}.bind(this));
	
		}.bind(this));
	};
	
	Compilation.prototype.seal = function seal(callback) {
		this.applyPlugins("seal");
		this.preparedChunks.sort(function(a, b) {
			if(a.name < b.name) return -1;
			if(a.name > b.name) return 1;
			return 0;
		});
		this.preparedChunks.forEach(function(preparedChunk) {
			var module = preparedChunk.module;
			var chunk = this.addChunk(preparedChunk.name, module);
			chunk.initial = chunk.entry = true;
			chunk.addModule(module);
			module.addChunk(chunk);
			if(typeof module.index !== "number") {
				module.index = this.nextFreeModuleIndex++;
			}
			this.processDependenciesBlockForChunk(module, chunk);
			if(typeof module.index2 !== "number") {
				module.index2 = this.nextFreeModuleIndex2++;
			}
		}, this);
		this.sortModules(this.modules);
		this.applyPlugins("optimize");
	
		this.applyPlugins("optimize-modules", this.modules);
		this.applyPlugins("after-optimize-modules", this.modules);
	
		this.applyPlugins("optimize-chunks", this.chunks);
		this.applyPlugins("after-optimize-chunks", this.chunks);
	
		this.applyPluginsAsync("optimize-tree", this.chunks, this.modules, function(err) {
			if(err) {
				return callback(err);
			}
	
			this.applyPlugins("after-optimize-tree", this.chunks, this.modules);
	
			var shouldRecord = this.applyPluginsBailResult("should-record") !== false;
	
			this.applyPlugins("revive-modules", this.modules, this.records);
			this.applyPlugins("optimize-module-order", this.modules);
			this.applyPlugins("before-module-ids", this.modules);
			this.applyModuleIds();
			this.applyPlugins("optimize-module-ids", this.modules);
			this.applyPlugins("after-optimize-module-ids", this.modules);
			if(shouldRecord)
				this.applyPlugins("record-modules", this.modules, this.records);
	
			this.applyPlugins("revive-chunks", this.chunks, this.records);
			this.applyPlugins("optimize-chunk-order", this.chunks);
			this.applyPlugins("before-chunk-ids", this.chunks);
			this.applyChunkIds();
			this.applyPlugins("optimize-chunk-ids", this.chunks);
			this.applyPlugins("after-optimize-chunk-ids", this.chunks);
			if(shouldRecord)
				this.applyPlugins("record-chunks", this.chunks, this.records);
	
			this.sortItems();
			this.applyPlugins("before-hash");
			this.createHash();
			this.applyPlugins("after-hash");
			this.applyPlugins("before-chunk-assets");
			this.createChunkAssets();
			this.applyPlugins("additional-chunk-assets", this.chunks);
			this.summarizeDependencies();
			if(shouldRecord)
				this.applyPlugins("record", this, this.records);
	
			this.applyPluginsAsync("additional-assets", function(err) {
				if(err) {
					return callback(err);
				}
				this.applyPluginsAsync("optimize-chunk-assets", this.chunks, function(err) {
					if(err) {
						return callback(err);
					}
					this.applyPlugins("after-optimize-chunk-assets", this.chunks);
					this.applyPluginsAsync("optimize-assets", this.assets, function(err) {
						if(err) {
							return callback(err);
						}
						this.applyPlugins("after-optimize-assets", this.assets);
						return callback();
					}.bind(this));
				}.bind(this));
			}.bind(this));
		}.bind(this));
	};
	
	Compilation.prototype.sortModules = function sortModules(modules) {
		modules.sort(function(a, b) {
			if(a.index < b.index) return -1;
			if(a.index > b.index) return 1;
			return 0;
		});
	};
	
	Compilation.prototype.addChunk = function addChunk(name, module, loc) {
		var chunk;
		if(name) {
			if(Object.prototype.hasOwnProperty.call(this.namedChunks, name)) {
				chunk = this.namedChunks[name];
				if(module) {
					chunk.addOrigin(module, loc);
				}
				return chunk;
			}
		}
		chunk = new Chunk(name, module, loc);
		this.chunks.push(chunk);
		if(name) {
			this.namedChunks[name] = chunk;
		}
		return chunk;
	};
	
	Compilation.prototype.processDependenciesBlockForChunk = function processDependenciesBlockForChunk(block, chunk) {
		if(block.variables) {
			block.variables.forEach(function(v) {
				v.dependencies.forEach(iteratorDependency, this);
			}, this);
		}
		if(block.dependencies) {
			block.dependencies.forEach(iteratorDependency, this);
		}
		if(block.blocks) {
			block.blocks.forEach(function(b) {
				var c;
				if(!b.chunks) {
					c = this.addChunk(b.chunkName, b.module, b.loc);
					b.chunks = [c];
					c.addBlock(b);
				} else {
					c = b.chunks[0];
				}
				chunk.addChunk(c);
				c.addParent(chunk);
				this.processDependenciesBlockForChunk(b, c);
			}, this);
		}
	
		function iteratorDependency(d) {
			if(!d.module) {
				return;
			}
			if(typeof d.module.index !== "number") {
				d.module.index = this.nextFreeModuleIndex++;
			}
			if(d.weak) {
				return;
			}
			if(d.module.error) {
				d.module = null;
				return;
			}
			if(chunk.addModule(d.module)) {
				d.module.addChunk(chunk);
				this.processDependenciesBlockForChunk(d.module, chunk);
			}
			if(typeof d.module.index2 !== "number") {
				d.module.index2 = this.nextFreeModuleIndex2++;
			}
		}
	};
	
	Compilation.prototype.removeChunkFromDependencies = function removeChunkFromDependencies(block, chunk) {
		block.blocks.forEach(function(b) {
			b.chunks.forEach(function(c) {
				chunk.removeChunk(c);
				c.removeParent(chunk);
				this.removeChunkFromDependencies(b, c);
			}, this);
		}, this);
	
		function iteratorDependency(d) {
			if(!d.module) {
				return;
			}
			if(!d.module.hasReasonForChunk(chunk)) {
				if(d.module.removeChunk(chunk)) {
					this.removeChunkFromDependencies(d.module, chunk);
				}
			}
		}
		block.dependencies.forEach(iteratorDependency, this);
		block.variables.forEach(function(v) {
			v.dependencies.forEach(iteratorDependency, this);
		}, this);
	
	};
	
	Compilation.prototype.applyModuleIds = function applyModuleIds() {
		this.modules.forEach(function(module) {
			if(module.id === null) {
				module.id = this.nextFreeModuleId++;
			}
		}, this);
	};
	
	Compilation.prototype.applyChunkIds = function applyChunkIds() {
		this.chunks.forEach(function(chunk) {
			if(chunk.id === null) {
				chunk.id = this.nextFreeChunkId++;
			}
			if(!chunk.ids) {
				chunk.ids = [chunk.id];
			}
		}, this);
	};
	
	Compilation.prototype.sortItems = function sortItems() {
		function byId(a, b) {
			return a.id - b.id;
		}
		this.chunks.sort(byId);
		this.modules.sort(byId);
		this.modules.forEach(function(module) {
			module.chunks.sort(byId);
			module.reasons.sort(function(a, b) {
				return byId(a.module, b.module);
			});
		});
		this.chunks.forEach(function(chunk) {
			chunk.modules.sort(byId);
		});
	};
	
	Compilation.prototype.summarizeDependencies = function summarizeDependencies() {
		function filterDups(array) {
			var newArray = [];
			for(var i = 0; i < array.length; i++) {
				if(i === 0 || array[i - 1] !== array[i])
					newArray.push(array[i]);
			}
			return newArray;
		}
		this.fileDependencies = [];
		this.contextDependencies = [];
		this.missingDependencies = [];
		this.children.forEach(function(child) {
			this.fileDependencies = this.fileDependencies.concat(child.fileDependencies);
			this.contextDependencies = this.contextDependencies.concat(child.contextDependencies);
			this.missingDependencies = this.missingDependencies.concat(child.missingDependencies);
		}.bind(this));
		this.modules.forEach(function(module) {
			if(module.fileDependencies) {
				module.fileDependencies.forEach(function(item) {
					this.fileDependencies.push(item);
				}, this);
			}
			if(module.contextDependencies) {
				module.contextDependencies.forEach(function(item) {
					this.contextDependencies.push(item);
				}, this);
			}
		}, this);
		this.errors.forEach(function(error) {
			if(Array.isArray(error.missing)) {
				error.missing.forEach(function(item) {
					this.missingDependencies.push(item);
				}, this);
			}
		}, this);
		this.fileDependencies.sort();
		this.fileDependencies = filterDups(this.fileDependencies);
		this.contextDependencies.sort();
		this.contextDependencies = filterDups(this.contextDependencies);
		this.missingDependencies.sort();
		this.missingDependencies = filterDups(this.missingDependencies);
	};
	
	Compilation.prototype.createHash = function createHash() {
		var outputOptions = this.outputOptions;
		var hashFunction = outputOptions.hashFunction;
		var hashDigest = outputOptions.hashDigest;
		var hashDigestLength = outputOptions.hashDigestLength;
		var hash = __webpack_require__(59).createHash(hashFunction);
		this.mainTemplate.updateHash(hash);
		this.chunkTemplate.updateHash(hash);
		this.moduleTemplate.updateHash(hash);
		var i, chunk;
		var chunks = this.chunks.slice();
		chunks.sort(function(a, b) {
			if(a.entry && !b.entry) return 1;
			if(!a.entry && b.entry) return -1;
			return 0;
		});
		for(i = 0; i < chunks.length; i++) {
			chunk = chunks[i];
			var chunkHash = __webpack_require__(59).createHash(hashFunction);
			chunk.updateHash(chunkHash);
			if(chunk.entry) {
				this.mainTemplate.updateHashForChunk(chunkHash, chunk);
			} else {
				this.chunkTemplate.updateHashForChunk(chunkHash);
			}
			this.applyPlugins("chunk-hash", chunk, chunkHash);
			chunk.hash = chunkHash.digest(hashDigest);
			hash.update(chunk.hash);
			chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);
		}
		this.fullHash = hash.digest(hashDigest);
		this.hash = this.fullHash.substr(0, hashDigestLength);
	};
	
	Compilation.prototype.modifyHash = function modifyHash(update) {
		var outputOptions = this.outputOptions;
		var hashFunction = outputOptions.hashFunction;
		var hashDigest = outputOptions.hashDigest;
		var hashDigestLength = outputOptions.hashDigestLength;
		var hash = __webpack_require__(59).createHash(hashFunction);
		hash.update(this.fullHash);
		hash.update(update);
		this.fullHash = hash.digest(hashDigest);
		this.hash = this.fullHash.substr(0, hashDigestLength);
	};
	
	Compilation.prototype.createChunkAssets = function createChunkAssets() {
		var outputOptions = this.outputOptions;
		var filename = outputOptions.filename || "bundle.js";
		var chunkFilename = outputOptions.chunkFilename || "[id]." + filename;
		var namedChunkFilename = outputOptions.namedChunkFilename || null;
		for(var i = 0; i < this.modules.length; i++) {
			var module = this.modules[i];
			if(module.assets) {
				Object.keys(module.assets).forEach(function(name) {
					var file = this.getPath(name);
					this.assets[file] = module.assets[name];
					this.applyPlugins("module-asset", module, file);
				}, this);
			}
		}
		for(i = 0; i < this.chunks.length; i++) {
			var chunk = this.chunks[i];
			chunk.files = [];
			var chunkHash = chunk.hash;
			var source;
			var file;
			var filenameTemplate = chunk.filenameTemplate ? chunk.filenameTemplate :
				chunk.initial ? filename :
				chunkFilename;
			try {
				var useChunkHash = !chunk.entry || (this.mainTemplate.useChunkHash && this.mainTemplate.useChunkHash(chunk));
				var usedHash = useChunkHash ? chunkHash : this.fullHash;
				if(this.cache && this.cache["c" + chunk.id] && this.cache["c" + chunk.id].hash === usedHash) {
					source = this.cache["c" + chunk.id].source;
				} else {
					if(chunk.entry) {
						source = this.mainTemplate.render(this.hash, chunk, this.moduleTemplate, this.dependencyTemplates);
					} else {
						source = this.chunkTemplate.render(chunk, this.moduleTemplate, this.dependencyTemplates);
					}
					if(this.cache) {
						this.cache["c" + chunk.id] = {
							hash: usedHash,
							source: source = (source instanceof CachedSource ? source : new CachedSource(source))
						};
					}
				}
				this.assets[
					file = this.getPath(filenameTemplate, {
						noChunkHash: !useChunkHash,
						chunk: chunk
					})
				] = source;
				chunk.files.push(file);
				this.applyPlugins("chunk-asset", chunk, file);
				file = undefined;
				if(chunk.id !== 0 && namedChunkFilename && chunk.name) {
					this.assets[
						file = this.getPath(namedChunkFilename, {
							noChunkHash: !useChunkHash,
							chunk: chunk
						})
					] = source;
					chunk.files.push(file);
					this.applyPlugins("chunk-asset", chunk, file);
				}
			} catch(err) {
				this.errors.push(new ChunkRenderError(chunk, file || filenameTemplate, err));
			}
		}
	};
	
	Compilation.prototype.getPath = function(filename, data) {
		data = data || {};
		data.hash = data.hash || this.hash;
		return this.mainTemplate.applyPluginsWaterfall("asset-path", filename, data);
	};
	
	Compilation.prototype.getStats = function() {
		return new Stats(this);
	};
	
	Compilation.prototype.createChildCompiler = function(name, outputOptions) {
		return this.compiler.createChildCompiler(this, name, outputOptions);
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, setImmediate, process) {/*!
	 * async
	 * https://github.com/caolan/async
	 *
	 * Copyright 2010-2014 Caolan McMahon
	 * Released under the MIT license
	 */
	(function () {
	
	    var async = {};
	    function noop() {}
	    function identity(v) {
	        return v;
	    }
	    function toBool(v) {
	        return !!v;
	    }
	    function notId(v) {
	        return !v;
	    }
	
	    // global on the server, window in the browser
	    var previous_async;
	
	    // Establish the root object, `window` (`self`) in the browser, `global`
	    // on the server, or `this` in some virtual machines. We use `self`
	    // instead of `window` for `WebWorker` support.
	    var root = typeof self === 'object' && self.self === self && self ||
	            typeof global === 'object' && global.global === global && global ||
	            this;
	
	    if (root != null) {
	        previous_async = root.async;
	    }
	
	    async.noConflict = function () {
	        root.async = previous_async;
	        return async;
	    };
	
	    function only_once(fn) {
	        return function() {
	            if (fn === null) throw new Error("Callback was already called.");
	            fn.apply(this, arguments);
	            fn = null;
	        };
	    }
	
	    function _once(fn) {
	        return function() {
	            if (fn === null) return;
	            fn.apply(this, arguments);
	            fn = null;
	        };
	    }
	
	    //// cross-browser compatiblity functions ////
	
	    var _toString = Object.prototype.toString;
	
	    var _isArray = Array.isArray || function (obj) {
	        return _toString.call(obj) === '[object Array]';
	    };
	
	    // Ported from underscore.js isObject
	    var _isObject = function(obj) {
	        var type = typeof obj;
	        return type === 'function' || type === 'object' && !!obj;
	    };
	
	    function _isArrayLike(arr) {
	        return _isArray(arr) || (
	            // has a positive integer length property
	            typeof arr.length === "number" &&
	            arr.length >= 0 &&
	            arr.length % 1 === 0
	        );
	    }
	
	    function _arrayEach(arr, iterator) {
	        var index = -1,
	            length = arr.length;
	
	        while (++index < length) {
	            iterator(arr[index], index, arr);
	        }
	    }
	
	    function _map(arr, iterator) {
	        var index = -1,
	            length = arr.length,
	            result = Array(length);
	
	        while (++index < length) {
	            result[index] = iterator(arr[index], index, arr);
	        }
	        return result;
	    }
	
	    function _range(count) {
	        return _map(Array(count), function (v, i) { return i; });
	    }
	
	    function _reduce(arr, iterator, memo) {
	        _arrayEach(arr, function (x, i, a) {
	            memo = iterator(memo, x, i, a);
	        });
	        return memo;
	    }
	
	    function _forEachOf(object, iterator) {
	        _arrayEach(_keys(object), function (key) {
	            iterator(object[key], key);
	        });
	    }
	
	    function _indexOf(arr, item) {
	        for (var i = 0; i < arr.length; i++) {
	            if (arr[i] === item) return i;
	        }
	        return -1;
	    }
	
	    var _keys = Object.keys || function (obj) {
	        var keys = [];
	        for (var k in obj) {
	            if (obj.hasOwnProperty(k)) {
	                keys.push(k);
	            }
	        }
	        return keys;
	    };
	
	    function _keyIterator(coll) {
	        var i = -1;
	        var len;
	        var keys;
	        if (_isArrayLike(coll)) {
	            len = coll.length;
	            return function next() {
	                i++;
	                return i < len ? i : null;
	            };
	        } else {
	            keys = _keys(coll);
	            len = keys.length;
	            return function next() {
	                i++;
	                return i < len ? keys[i] : null;
	            };
	        }
	    }
	
	    // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)
	    // This accumulates the arguments passed into an array, after a given index.
	    // From underscore.js (https://github.com/jashkenas/underscore/pull/2140).
	    function _restParam(func, startIndex) {
	        startIndex = startIndex == null ? func.length - 1 : +startIndex;
	        return function() {
	            var length = Math.max(arguments.length - startIndex, 0);
	            var rest = Array(length);
	            for (var index = 0; index < length; index++) {
	                rest[index] = arguments[index + startIndex];
	            }
	            switch (startIndex) {
	                case 0: return func.call(this, rest);
	                case 1: return func.call(this, arguments[0], rest);
	            }
	            // Currently unused but handle cases outside of the switch statement:
	            // var args = Array(startIndex + 1);
	            // for (index = 0; index < startIndex; index++) {
	            //     args[index] = arguments[index];
	            // }
	            // args[startIndex] = rest;
	            // return func.apply(this, args);
	        };
	    }
	
	    function _withoutIndex(iterator) {
	        return function (value, index, callback) {
	            return iterator(value, callback);
	        };
	    }
	
	    //// exported async module functions ////
	
	    //// nextTick implementation with browser-compatible fallback ////
	
	    // capture the global reference to guard against fakeTimer mocks
	    var _setImmediate = typeof setImmediate === 'function' && setImmediate;
	
	    var _delay = _setImmediate ? function(fn) {
	        // not a direct alias for IE10 compatibility
	        _setImmediate(fn);
	    } : function(fn) {
	        setTimeout(fn, 0);
	    };
	
	    if (typeof process === 'object' && typeof process.nextTick === 'function') {
	        async.nextTick = process.nextTick;
	    } else {
	        async.nextTick = _delay;
	    }
	    async.setImmediate = _setImmediate ? _delay : async.nextTick;
	
	
	    async.forEach =
	    async.each = function (arr, iterator, callback) {
	        return async.eachOf(arr, _withoutIndex(iterator), callback);
	    };
	
	    async.forEachSeries =
	    async.eachSeries = function (arr, iterator, callback) {
	        return async.eachOfSeries(arr, _withoutIndex(iterator), callback);
	    };
	
	
	    async.forEachLimit =
	    async.eachLimit = function (arr, limit, iterator, callback) {
	        return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);
	    };
	
	    async.forEachOf =
	    async.eachOf = function (object, iterator, callback) {
	        callback = _once(callback || noop);
	        object = object || [];
	
	        var iter = _keyIterator(object);
	        var key, completed = 0;
	
	        while ((key = iter()) != null) {
	            completed += 1;
	            iterator(object[key], key, only_once(done));
	        }
	
	        if (completed === 0) callback(null);
	
	        function done(err) {
	            completed--;
	            if (err) {
	                callback(err);
	            }
	            // Check key is null in case iterator isn't exhausted
	            // and done resolved synchronously.
	            else if (key === null && completed <= 0) {
	                callback(null);
	            }
	        }
	    };
	
	    async.forEachOfSeries =
	    async.eachOfSeries = function (obj, iterator, callback) {
	        callback = _once(callback || noop);
	        obj = obj || [];
	        var nextKey = _keyIterator(obj);
	        var key = nextKey();
	        function iterate() {
	            var sync = true;
	            if (key === null) {
	                return callback(null);
	            }
	            iterator(obj[key], key, only_once(function (err) {
	                if (err) {
	                    callback(err);
	                }
	                else {
	                    key = nextKey();
	                    if (key === null) {
	                        return callback(null);
	                    } else {
	                        if (sync) {
	                            async.setImmediate(iterate);
	                        } else {
	                            iterate();
	                        }
	                    }
	                }
	            }));
	            sync = false;
	        }
	        iterate();
	    };
	
	
	
	    async.forEachOfLimit =
	    async.eachOfLimit = function (obj, limit, iterator, callback) {
	        _eachOfLimit(limit)(obj, iterator, callback);
	    };
	
	    function _eachOfLimit(limit) {
	
	        return function (obj, iterator, callback) {
	            callback = _once(callback || noop);
	            obj = obj || [];
	            var nextKey = _keyIterator(obj);
	            if (limit <= 0) {
	                return callback(null);
	            }
	            var done = false;
	            var running = 0;
	            var errored = false;
	
	            (function replenish () {
	                if (done && running <= 0) {
	                    return callback(null);
	                }
	
	                while (running < limit && !errored) {
	                    var key = nextKey();
	                    if (key === null) {
	                        done = true;
	                        if (running <= 0) {
	                            callback(null);
	                        }
	                        return;
	                    }
	                    running += 1;
	                    iterator(obj[key], key, only_once(function (err) {
	                        running -= 1;
	                        if (err) {
	                            callback(err);
	                            errored = true;
	                        }
	                        else {
	                            replenish();
	                        }
	                    }));
	                }
	            })();
	        };
	    }
	
	
	    function doParallel(fn) {
	        return function (obj, iterator, callback) {
	            return fn(async.eachOf, obj, iterator, callback);
	        };
	    }
	    function doParallelLimit(fn) {
	        return function (obj, limit, iterator, callback) {
	            return fn(_eachOfLimit(limit), obj, iterator, callback);
	        };
	    }
	    function doSeries(fn) {
	        return function (obj, iterator, callback) {
	            return fn(async.eachOfSeries, obj, iterator, callback);
	        };
	    }
	
	    function _asyncMap(eachfn, arr, iterator, callback) {
	        callback = _once(callback || noop);
	        arr = arr || [];
	        var results = _isArrayLike(arr) ? [] : {};
	        eachfn(arr, function (value, index, callback) {
	            iterator(value, function (err, v) {
	                results[index] = v;
	                callback(err);
	            });
	        }, function (err) {
	            callback(err, results);
	        });
	    }
	
	    async.map = doParallel(_asyncMap);
	    async.mapSeries = doSeries(_asyncMap);
	    async.mapLimit = doParallelLimit(_asyncMap);
	
	    // reduce only has a series version, as doing reduce in parallel won't
	    // work in many situations.
	    async.inject =
	    async.foldl =
	    async.reduce = function (arr, memo, iterator, callback) {
	        async.eachOfSeries(arr, function (x, i, callback) {
	            iterator(memo, x, function (err, v) {
	                memo = v;
	                callback(err);
	            });
	        }, function (err) {
	            callback(err, memo);
	        });
	    };
	
	    async.foldr =
	    async.reduceRight = function (arr, memo, iterator, callback) {
	        var reversed = _map(arr, identity).reverse();
	        async.reduce(reversed, memo, iterator, callback);
	    };
	
	    async.transform = function (arr, memo, iterator, callback) {
	        if (arguments.length === 3) {
	            callback = iterator;
	            iterator = memo;
	            memo = _isArray(arr) ? [] : {};
	        }
	
	        async.eachOf(arr, function(v, k, cb) {
	            iterator(memo, v, k, cb);
	        }, function(err) {
	            callback(err, memo);
	        });
	    };
	
	    function _filter(eachfn, arr, iterator, callback) {
	        var results = [];
	        eachfn(arr, function (x, index, callback) {
	            iterator(x, function (v) {
	                if (v) {
	                    results.push({index: index, value: x});
	                }
	                callback();
	            });
	        }, function () {
	            callback(_map(results.sort(function (a, b) {
	                return a.index - b.index;
	            }), function (x) {
	                return x.value;
	            }));
	        });
	    }
	
	    async.select =
	    async.filter = doParallel(_filter);
	
	    async.selectLimit =
	    async.filterLimit = doParallelLimit(_filter);
	
	    async.selectSeries =
	    async.filterSeries = doSeries(_filter);
	
	    function _reject(eachfn, arr, iterator, callback) {
	        _filter(eachfn, arr, function(value, cb) {
	            iterator(value, function(v) {
	                cb(!v);
	            });
	        }, callback);
	    }
	    async.reject = doParallel(_reject);
	    async.rejectLimit = doParallelLimit(_reject);
	    async.rejectSeries = doSeries(_reject);
	
	    function _createTester(eachfn, check, getResult) {
	        return function(arr, limit, iterator, cb) {
	            function done() {
	                if (cb) cb(getResult(false, void 0));
	            }
	            function iteratee(x, _, callback) {
	                if (!cb) return callback();
	                iterator(x, function (v) {
	                    if (cb && check(v)) {
	                        cb(getResult(true, x));
	                        cb = iterator = false;
	                    }
	                    callback();
	                });
	            }
	            if (arguments.length > 3) {
	                eachfn(arr, limit, iteratee, done);
	            } else {
	                cb = iterator;
	                iterator = limit;
	                eachfn(arr, iteratee, done);
	            }
	        };
	    }
	
	    async.any =
	    async.some = _createTester(async.eachOf, toBool, identity);
	
	    async.someLimit = _createTester(async.eachOfLimit, toBool, identity);
	
	    async.all =
	    async.every = _createTester(async.eachOf, notId, notId);
	
	    async.everyLimit = _createTester(async.eachOfLimit, notId, notId);
	
	    function _findGetResult(v, x) {
	        return x;
	    }
	    async.detect = _createTester(async.eachOf, identity, _findGetResult);
	    async.detectSeries = _createTester(async.eachOfSeries, identity, _findGetResult);
	    async.detectLimit = _createTester(async.eachOfLimit, identity, _findGetResult);
	
	    async.sortBy = function (arr, iterator, callback) {
	        async.map(arr, function (x, callback) {
	            iterator(x, function (err, criteria) {
	                if (err) {
	                    callback(err);
	                }
	                else {
	                    callback(null, {value: x, criteria: criteria});
	                }
	            });
	        }, function (err, results) {
	            if (err) {
	                return callback(err);
	            }
	            else {
	                callback(null, _map(results.sort(comparator), function (x) {
	                    return x.value;
	                }));
	            }
	
	        });
	
	        function comparator(left, right) {
	            var a = left.criteria, b = right.criteria;
	            return a < b ? -1 : a > b ? 1 : 0;
	        }
	    };
	
	    async.auto = function (tasks, concurrency, callback) {
	        if (typeof arguments[1] === 'function') {
	            // concurrency is optional, shift the args.
	            callback = concurrency;
	            concurrency = null;
	        }
	        callback = _once(callback || noop);
	        var keys = _keys(tasks);
	        var remainingTasks = keys.length;
	        if (!remainingTasks) {
	            return callback(null);
	        }
	        if (!concurrency) {
	            concurrency = remainingTasks;
	        }
	
	        var results = {};
	        var runningTasks = 0;
	
	        var hasError = false;
	
	        var listeners = [];
	        function addListener(fn) {
	            listeners.unshift(fn);
	        }
	        function removeListener(fn) {
	            var idx = _indexOf(listeners, fn);
	            if (idx >= 0) listeners.splice(idx, 1);
	        }
	        function taskComplete() {
	            remainingTasks--;
	            _arrayEach(listeners.slice(0), function (fn) {
	                fn();
	            });
	        }
	
	        addListener(function () {
	            if (!remainingTasks) {
	                callback(null, results);
	            }
	        });
	
	        _arrayEach(keys, function (k) {
	            if (hasError) return;
	            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
	            var taskCallback = _restParam(function(err, args) {
	                runningTasks--;
	                if (args.length <= 1) {
	                    args = args[0];
	                }
	                if (err) {
	                    var safeResults = {};
	                    _forEachOf(results, function(val, rkey) {
	                        safeResults[rkey] = val;
	                    });
	                    safeResults[k] = args;
	                    hasError = true;
	
	                    callback(err, safeResults);
	                }
	                else {
	                    results[k] = args;
	                    async.setImmediate(taskComplete);
	                }
	            });
	            var requires = task.slice(0, task.length - 1);
	            // prevent dead-locks
	            var len = requires.length;
	            var dep;
	            while (len--) {
	                if (!(dep = tasks[requires[len]])) {
	                    throw new Error('Has nonexistent dependency in ' + requires.join(', '));
	                }
	                if (_isArray(dep) && _indexOf(dep, k) >= 0) {
	                    throw new Error('Has cyclic dependencies');
	                }
	            }
	            function ready() {
	                return runningTasks < concurrency && _reduce(requires, function (a, x) {
	                    return (a && results.hasOwnProperty(x));
	                }, true) && !results.hasOwnProperty(k);
	            }
	            if (ready()) {
	                runningTasks++;
	                task[task.length - 1](taskCallback, results);
	            }
	            else {
	                addListener(listener);
	            }
	            function listener() {
	                if (ready()) {
	                    runningTasks++;
	                    removeListener(listener);
	                    task[task.length - 1](taskCallback, results);
	                }
	            }
	        });
	    };
	
	
	
	    async.retry = function(times, task, callback) {
	        var DEFAULT_TIMES = 5;
	        var DEFAULT_INTERVAL = 0;
	
	        var attempts = [];
	
	        var opts = {
	            times: DEFAULT_TIMES,
	            interval: DEFAULT_INTERVAL
	        };
	
	        function parseTimes(acc, t){
	            if(typeof t === 'number'){
	                acc.times = parseInt(t, 10) || DEFAULT_TIMES;
	            } else if(typeof t === 'object'){
	                acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;
	                acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;
	            } else {
	                throw new Error('Unsupported argument type for \'times\': ' + typeof t);
	            }
	        }
	
	        var length = arguments.length;
	        if (length < 1 || length > 3) {
	            throw new Error('Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)');
	        } else if (length <= 2 && typeof times === 'function') {
	            callback = task;
	            task = times;
	        }
	        if (typeof times !== 'function') {
	            parseTimes(opts, times);
	        }
	        opts.callback = callback;
	        opts.task = task;
	
	        function wrappedTask(wrappedCallback, wrappedResults) {
	            function retryAttempt(task, finalAttempt) {
	                return function(seriesCallback) {
	                    task(function(err, result){
	                        seriesCallback(!err || finalAttempt, {err: err, result: result});
	                    }, wrappedResults);
	                };
	            }
	
	            function retryInterval(interval){
	                return function(seriesCallback){
	                    setTimeout(function(){
	                        seriesCallback(null);
	                    }, interval);
	                };
	            }
	
	            while (opts.times) {
	
	                var finalAttempt = !(opts.times-=1);
	                attempts.push(retryAttempt(opts.task, finalAttempt));
	                if(!finalAttempt && opts.interval > 0){
	                    attempts.push(retryInterval(opts.interval));
	                }
	            }
	
	            async.series(attempts, function(done, data){
	                data = data[data.length - 1];
	                (wrappedCallback || opts.callback)(data.err, data.result);
	            });
	        }
	
	        // If a callback is passed, run this as a controll flow
	        return opts.callback ? wrappedTask() : wrappedTask;
	    };
	
	    async.waterfall = function (tasks, callback) {
	        callback = _once(callback || noop);
	        if (!_isArray(tasks)) {
	            var err = new Error('First argument to waterfall must be an array of functions');
	            return callback(err);
	        }
	        if (!tasks.length) {
	            return callback();
	        }
	        function wrapIterator(iterator) {
	            return _restParam(function (err, args) {
	                if (err) {
	                    callback.apply(null, [err].concat(args));
	                }
	                else {
	                    var next = iterator.next();
	                    if (next) {
	                        args.push(wrapIterator(next));
	                    }
	                    else {
	                        args.push(callback);
	                    }
	                    ensureAsync(iterator).apply(null, args);
	                }
	            });
	        }
	        wrapIterator(async.iterator(tasks))();
	    };
	
	    function _parallel(eachfn, tasks, callback) {
	        callback = callback || noop;
	        var results = _isArrayLike(tasks) ? [] : {};
	
	        eachfn(tasks, function (task, key, callback) {
	            task(_restParam(function (err, args) {
	                if (args.length <= 1) {
	                    args = args[0];
	                }
	                results[key] = args;
	                callback(err);
	            }));
	        }, function (err) {
	            callback(err, results);
	        });
	    }
	
	    async.parallel = function (tasks, callback) {
	        _parallel(async.eachOf, tasks, callback);
	    };
	
	    async.parallelLimit = function(tasks, limit, callback) {
	        _parallel(_eachOfLimit(limit), tasks, callback);
	    };
	
	    async.series = function(tasks, callback) {
	        _parallel(async.eachOfSeries, tasks, callback);
	    };
	
	    async.iterator = function (tasks) {
	        function makeCallback(index) {
	            function fn() {
	                if (tasks.length) {
	                    tasks[index].apply(null, arguments);
	                }
	                return fn.next();
	            }
	            fn.next = function () {
	                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
	            };
	            return fn;
	        }
	        return makeCallback(0);
	    };
	
	    async.apply = _restParam(function (fn, args) {
	        return _restParam(function (callArgs) {
	            return fn.apply(
	                null, args.concat(callArgs)
	            );
	        });
	    });
	
	    function _concat(eachfn, arr, fn, callback) {
	        var result = [];
	        eachfn(arr, function (x, index, cb) {
	            fn(x, function (err, y) {
	                result = result.concat(y || []);
	                cb(err);
	            });
	        }, function (err) {
	            callback(err, result);
	        });
	    }
	    async.concat = doParallel(_concat);
	    async.concatSeries = doSeries(_concat);
	
	    async.whilst = function (test, iterator, callback) {
	        callback = callback || noop;
	        if (test()) {
	            var next = _restParam(function(err, args) {
	                if (err) {
	                    callback(err);
	                } else if (test.apply(this, args)) {
	                    iterator(next);
	                } else {
	                    callback.apply(null, [null].concat(args));
	                }
	            });
	            iterator(next);
	        } else {
	            callback(null);
	        }
	    };
	
	    async.doWhilst = function (iterator, test, callback) {
	        var calls = 0;
	        return async.whilst(function() {
	            return ++calls <= 1 || test.apply(this, arguments);
	        }, iterator, callback);
	    };
	
	    async.until = function (test, iterator, callback) {
	        return async.whilst(function() {
	            return !test.apply(this, arguments);
	        }, iterator, callback);
	    };
	
	    async.doUntil = function (iterator, test, callback) {
	        return async.doWhilst(iterator, function() {
	            return !test.apply(this, arguments);
	        }, callback);
	    };
	
	    async.during = function (test, iterator, callback) {
	        callback = callback || noop;
	
	        var next = _restParam(function(err, args) {
	            if (err) {
	                callback(err);
	            } else {
	                args.push(check);
	                test.apply(this, args);
	            }
	        });
	
	        var check = function(err, truth) {
	            if (err) {
	                callback(err);
	            } else if (truth) {
	                iterator(next);
	            } else {
	                callback(null);
	            }
	        };
	
	        test(check);
	    };
	
	    async.doDuring = function (iterator, test, callback) {
	        var calls = 0;
	        async.during(function(next) {
	            if (calls++ < 1) {
	                next(null, true);
	            } else {
	                test.apply(this, arguments);
	            }
	        }, iterator, callback);
	    };
	
	    function _queue(worker, concurrency, payload) {
	        if (concurrency == null) {
	            concurrency = 1;
	        }
	        else if(concurrency === 0) {
	            throw new Error('Concurrency must not be zero');
	        }
	        function _insert(q, data, pos, callback) {
	            if (callback != null && typeof callback !== "function") {
	                throw new Error("task callback must be a function");
	            }
	            q.started = true;
	            if (!_isArray(data)) {
	                data = [data];
	            }
	            if(data.length === 0 && q.idle()) {
	                // call drain immediately if there are no tasks
	                return async.setImmediate(function() {
	                    q.drain();
	                });
	            }
	            _arrayEach(data, function(task) {
	                var item = {
	                    data: task,
	                    callback: callback || noop
	                };
	
	                if (pos) {
	                    q.tasks.unshift(item);
	                } else {
	                    q.tasks.push(item);
	                }
	
	                if (q.tasks.length === q.concurrency) {
	                    q.saturated();
	                }
	            });
	            async.setImmediate(q.process);
	        }
	        function _next(q, tasks) {
	            return function(){
	                workers -= 1;
	
	                var removed = false;
	                var args = arguments;
	                _arrayEach(tasks, function (task) {
	                    _arrayEach(workersList, function (worker, index) {
	                        if (worker === task && !removed) {
	                            workersList.splice(index, 1);
	                            removed = true;
	                        }
	                    });
	
	                    task.callback.apply(task, args);
	                });
	                if (q.tasks.length + workers === 0) {
	                    q.drain();
	                }
	                q.process();
	            };
	        }
	
	        var workers = 0;
	        var workersList = [];
	        var q = {
	            tasks: [],
	            concurrency: concurrency,
	            payload: payload,
	            saturated: noop,
	            empty: noop,
	            drain: noop,
	            started: false,
	            paused: false,
	            push: function (data, callback) {
	                _insert(q, data, false, callback);
	            },
	            kill: function () {
	                q.drain = noop;
	                q.tasks = [];
	            },
	            unshift: function (data, callback) {
	                _insert(q, data, true, callback);
	            },
	            process: function () {
	                while(!q.paused && workers < q.concurrency && q.tasks.length){
	
	                    var tasks = q.payload ?
	                        q.tasks.splice(0, q.payload) :
	                        q.tasks.splice(0, q.tasks.length);
	
	                    var data = _map(tasks, function (task) {
	                        return task.data;
	                    });
	
	                    if (q.tasks.length === 0) {
	                        q.empty();
	                    }
	                    workers += 1;
	                    workersList.push(tasks[0]);
	                    var cb = only_once(_next(q, tasks));
	                    worker(data, cb);
	                }
	            },
	            length: function () {
	                return q.tasks.length;
	            },
	            running: function () {
	                return workers;
	            },
	            workersList: function () {
	                return workersList;
	            },
	            idle: function() {
	                return q.tasks.length + workers === 0;
	            },
	            pause: function () {
	                q.paused = true;
	            },
	            resume: function () {
	                if (q.paused === false) { return; }
	                q.paused = false;
	                var resumeCount = Math.min(q.concurrency, q.tasks.length);
	                // Need to call q.process once per concurrent
	                // worker to preserve full concurrency after pause
	                for (var w = 1; w <= resumeCount; w++) {
	                    async.setImmediate(q.process);
	                }
	            }
	        };
	        return q;
	    }
	
	    async.queue = function (worker, concurrency) {
	        var q = _queue(function (items, cb) {
	            worker(items[0], cb);
	        }, concurrency, 1);
	
	        return q;
	    };
	
	    async.priorityQueue = function (worker, concurrency) {
	
	        function _compareTasks(a, b){
	            return a.priority - b.priority;
	        }
	
	        function _binarySearch(sequence, item, compare) {
	            var beg = -1,
	                end = sequence.length - 1;
	            while (beg < end) {
	                var mid = beg + ((end - beg + 1) >>> 1);
	                if (compare(item, sequence[mid]) >= 0) {
	                    beg = mid;
	                } else {
	                    end = mid - 1;
	                }
	            }
	            return beg;
	        }
	
	        function _insert(q, data, priority, callback) {
	            if (callback != null && typeof callback !== "function") {
	                throw new Error("task callback must be a function");
	            }
	            q.started = true;
	            if (!_isArray(data)) {
	                data = [data];
	            }
	            if(data.length === 0) {
	                // call drain immediately if there are no tasks
	                return async.setImmediate(function() {
	                    q.drain();
	                });
	            }
	            _arrayEach(data, function(task) {
	                var item = {
	                    data: task,
	                    priority: priority,
	                    callback: typeof callback === 'function' ? callback : noop
	                };
	
	                q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);
	
	                if (q.tasks.length === q.concurrency) {
	                    q.saturated();
	                }
	                async.setImmediate(q.process);
	            });
	        }
	
	        // Start with a normal queue
	        var q = async.queue(worker, concurrency);
	
	        // Override push to accept second parameter representing priority
	        q.push = function (data, priority, callback) {
	            _insert(q, data, priority, callback);
	        };
	
	        // Remove unshift function
	        delete q.unshift;
	
	        return q;
	    };
	
	    async.cargo = function (worker, payload) {
	        return _queue(worker, 1, payload);
	    };
	
	    function _console_fn(name) {
	        return _restParam(function (fn, args) {
	            fn.apply(null, args.concat([_restParam(function (err, args) {
	                if (typeof console === 'object') {
	                    if (err) {
	                        if (console.error) {
	                            console.error(err);
	                        }
	                    }
	                    else if (console[name]) {
	                        _arrayEach(args, function (x) {
	                            console[name](x);
	                        });
	                    }
	                }
	            })]));
	        });
	    }
	    async.log = _console_fn('log');
	    async.dir = _console_fn('dir');
	    /*async.info = _console_fn('info');
	    async.warn = _console_fn('warn');
	    async.error = _console_fn('error');*/
	
	    async.memoize = function (fn, hasher) {
	        var memo = {};
	        var queues = {};
	        var has = Object.prototype.hasOwnProperty;
	        hasher = hasher || identity;
	        var memoized = _restParam(function memoized(args) {
	            var callback = args.pop();
	            var key = hasher.apply(null, args);
	            if (has.call(memo, key)) {   
	                async.setImmediate(function () {
	                    callback.apply(null, memo[key]);
	                });
	            }
	            else if (has.call(queues, key)) {
	                queues[key].push(callback);
	            }
	            else {
	                queues[key] = [callback];
	                fn.apply(null, args.concat([_restParam(function (args) {
	                    memo[key] = args;
	                    var q = queues[key];
	                    delete queues[key];
	                    for (var i = 0, l = q.length; i < l; i++) {
	                        q[i].apply(null, args);
	                    }
	                })]));
	            }
	        });
	        memoized.memo = memo;
	        memoized.unmemoized = fn;
	        return memoized;
	    };
	
	    async.unmemoize = function (fn) {
	        return function () {
	            return (fn.unmemoized || fn).apply(null, arguments);
	        };
	    };
	
	    function _times(mapper) {
	        return function (count, iterator, callback) {
	            mapper(_range(count), iterator, callback);
	        };
	    }
	
	    async.times = _times(async.map);
	    async.timesSeries = _times(async.mapSeries);
	    async.timesLimit = function (count, limit, iterator, callback) {
	        return async.mapLimit(_range(count), limit, iterator, callback);
	    };
	
	    async.seq = function (/* functions... */) {
	        var fns = arguments;
	        return _restParam(function (args) {
	            var that = this;
	
	            var callback = args[args.length - 1];
	            if (typeof callback == 'function') {
	                args.pop();
	            } else {
	                callback = noop;
	            }
	
	            async.reduce(fns, args, function (newargs, fn, cb) {
	                fn.apply(that, newargs.concat([_restParam(function (err, nextargs) {
	                    cb(err, nextargs);
	                })]));
	            },
	            function (err, results) {
	                callback.apply(that, [err].concat(results));
	            });
	        });
	    };
	
	    async.compose = function (/* functions... */) {
	        return async.seq.apply(null, Array.prototype.reverse.call(arguments));
	    };
	
	
	    function _applyEach(eachfn) {
	        return _restParam(function(fns, args) {
	            var go = _restParam(function(args) {
	                var that = this;
	                var callback = args.pop();
	                return eachfn(fns, function (fn, _, cb) {
	                    fn.apply(that, args.concat([cb]));
	                },
	                callback);
	            });
	            if (args.length) {
	                return go.apply(this, args);
	            }
	            else {
	                return go;
	            }
	        });
	    }
	
	    async.applyEach = _applyEach(async.eachOf);
	    async.applyEachSeries = _applyEach(async.eachOfSeries);
	
	
	    async.forever = function (fn, callback) {
	        var done = only_once(callback || noop);
	        var task = ensureAsync(fn);
	        function next(err) {
	            if (err) {
	                return done(err);
	            }
	            task(next);
	        }
	        next();
	    };
	
	    function ensureAsync(fn) {
	        return _restParam(function (args) {
	            var callback = args.pop();
	            args.push(function () {
	                var innerArgs = arguments;
	                if (sync) {
	                    async.setImmediate(function () {
	                        callback.apply(null, innerArgs);
	                    });
	                } else {
	                    callback.apply(null, innerArgs);
	                }
	            });
	            var sync = true;
	            fn.apply(this, args);
	            sync = false;
	        });
	    }
	
	    async.ensureAsync = ensureAsync;
	
	    async.constant = _restParam(function(values) {
	        var args = [null].concat(values);
	        return function (callback) {
	            return callback.apply(this, args);
	        };
	    });
	
	    async.wrapSync =
	    async.asyncify = function asyncify(func) {
	        return _restParam(function (args) {
	            var callback = args.pop();
	            var result;
	            try {
	                result = func.apply(this, args);
	            } catch (e) {
	                return callback(e);
	            }
	            // if result is Promise object
	            if (_isObject(result) && typeof result.then === "function") {
	                result.then(function(value) {
	                    callback(null, value);
	                })["catch"](function(err) {
	                    callback(err.message ? err : new Error(err));
	                });
	            } else {
	                callback(null, result);
	            }
	        });
	    };
	
	    // Node.js
	    if (typeof module === 'object' && module.exports) {
	        module.exports = async;
	    }
	    // AMD / RequireJS
	    else if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return async;
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    }
	    // included directly via <script> tag
	    else {
	        root.async = async;
	    }
	
	}());
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(11).setImmediate, __webpack_require__(2)))

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(3))(39);

/***/ },
/* 12 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function EntryModuleNotFoundError(err) {
		Error.call(this);
		Error.captureStackTrace(this, EntryModuleNotFoundError);
		this.name = "EntryModuleNotFoundError";
		this.message = "Entry module not found: " + err;
		this.details = err.details;
		this.error = err;
	}
	module.exports = EntryModuleNotFoundError;
	
	EntryModuleNotFoundError.prototype = Object.create(Error.prototype);


/***/ },
/* 13 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function ModuleNotFoundError(module, err) {
		Error.call(this);
		Error.captureStackTrace(this, ModuleNotFoundError);
		this.name = "ModuleNotFoundError";
		this.message = "Module not found: " + err;
		this.details = err.details;
		this.missing = err.missing;
		this.module = module;
		this.error = err;
	}
	module.exports = ModuleNotFoundError;
	
	ModuleNotFoundError.prototype = Object.create(Error.prototype);


/***/ },
/* 14 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function CriticalDependenciesWarning(module, dependencies) {
		Error.call(this);
		Error.captureStackTrace(this, CriticalDependenciesWarning);
		this.name = "CriticalDependenciesWarning";
		this.message = "Critical dependencies:";
		this.message += dependencies.filter(function(d) {
			return typeof d.critical === "string" || d.loc;
		}).map(function(dep) {
			var line = [];
			if(dep.loc) line.push(dep.loc.start.line + ":" + dep.loc.start.column + "-" +
				(dep.loc.start.line !== dep.loc.end.line ? dep.loc.end.line + ":" : "") + dep.loc.end.column);
			if(typeof dep.critical === "string") line.push(dep.critical);
			return "\n" + line.join(" ");
		}).join("");
		this.dependencies = dependencies;
		this.origin = this.module = module;
	}
	module.exports = CriticalDependenciesWarning;
	
	CriticalDependenciesWarning.prototype = Object.create(Error.prototype);


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var DependenciesBlock = __webpack_require__(16);
	var ModuleReason = __webpack_require__(41);
	
	var debugId = 1000;
	
	function Module() {
		DependenciesBlock.call(this);
		this.context = null;
		this.reasons = [];
		this.debugId = debugId++;
		this.lastId = -1;
		this.id = null;
		this.index = null;
		this.index2 = null;
		this.chunks = [];
		this.warnings = [];
		this.dependenciesWarnings = [];
		this.errors = [];
		this.dependenciesErrors = [];
	}
	module.exports = Module;
	
	Module.prototype = Object.create(DependenciesBlock.prototype);
	
	Module.prototype.disconnect = function() {
		this.reasons.length = 0;
		this.lastId = this.id;
		this.id = null;
		this.index = null;
		this.index2 = null;
		this.chunks.length = 0;
		DependenciesBlock.prototype.disconnect.call(this);
	};
	
	Module.prototype.addChunk = function(chunk) {
		var idx = this.chunks.indexOf(chunk);
		if(idx < 0)
			this.chunks.push(chunk);
	};
	
	Module.prototype._removeAndDo = __webpack_require__(42);
	
	Module.prototype.removeChunk = function(chunk) {
		return this._removeAndDo("chunks", chunk, "removeModule");
	};
	
	Module.prototype.addReason = function(module, dependency) {
		this.reasons.push(new ModuleReason(module, dependency));
	};
	
	Module.prototype.removeReason = function(module, dependency) {
		for(var i = 0; i < this.reasons.length; i++) {
			var r = this.reasons[i];
			if(r.module === module && r.dependency === dependency) {
				this.reasons.splice(i, 1);
				return true;
			}
		}
		return false;
	};
	
	Module.prototype.hasReasonForChunk = function(chunk) {
		for(var i = 0; i < this.reasons.length; i++) {
			var r = this.reasons[i];
			if(r.chunks) {
				if(r.chunks.indexOf(chunk) >= 0)
					return true;
			} else if(r.module.chunks.indexOf(chunk) >= 0)
				return true;
		}
		return false;
	};
	
	function addToSet(set, items) {
		items.forEach(function(item) {
			if(set.indexOf(item) < 0)
				set.push(item);
		});
	}
	
	Module.prototype.rewriteChunkInReasons = function(oldChunk, newChunks) {
		this.reasons.forEach(function(r) {
			if(!r.chunks) {
				if(r.module.chunks.indexOf(oldChunk) < 0)
					return;
				r.chunks = r.module.chunks;
			}
			r.chunks = r.chunks.reduce(function(arr, c) {
				addToSet(arr, c !== oldChunk ? [c] : newChunks);
				return arr;
			}, []);
		});
	};
	
	Module.prototype.toString = function() {
		return "Module[" + (this.id || this.debugId) + "]";
	};
	
	Module.prototype.needRebuild = function( /* fileTimestamps, contextTimestamps */ ) {
		return true;
	};
	
	Module.prototype.updateHash = function(hash) {
		hash.update(this.id + "");
		DependenciesBlock.prototype.updateHash.call(this, hash);
	};
	
	Module.prototype.identifier = null;
	Module.prototype.readableIdentifier = null;
	Module.prototype.build = null;
	Module.prototype.source = null;
	Module.prototype.size = null;


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var DependenciesBlockVariable = __webpack_require__(17);
	
	function DependenciesBlock() {
		this.dependencies = [];
		this.blocks = [];
		this.variables = [];
	}
	module.exports = DependenciesBlock;
	
	DependenciesBlock.prototype.addBlock = function(block) {
		this.blocks.push(block);
		block.parent = this;
	};
	
	DependenciesBlock.prototype.addVariable = function(name, expression, dependencies) {
		for(var i = 0; i < this.variables.length; i++) {
			var v = this.variables[i];
			if(v.name === name && v.expression === expression) return;
		}
		this.variables.push(new DependenciesBlockVariable(name, expression, dependencies));
	};
	
	DependenciesBlock.prototype.addDependency = function(dependency) {
		this.dependencies.push(dependency);
	};
	
	DependenciesBlock.prototype.updateHash = function(hash) {
		this.dependencies.forEach(function(d) {
			d.updateHash(hash);
		});
		this.blocks.forEach(function(b) {
			b.updateHash(hash);
		});
		this.variables.forEach(function(v) {
			v.updateHash(hash);
		});
	};
	
	DependenciesBlock.prototype.disconnect = function() {
		function disconnect(i) {
			i.disconnect();
		}
		this.dependencies.forEach(disconnect);
		this.blocks.forEach(disconnect);
		this.variables.forEach(disconnect);
	};
	
	DependenciesBlock.prototype.hasDependencies = function() {
		return this.dependencies.length > 0 ||
			this.blocks.concat(this.variables).some(function(item) {
				return item.hasDependencies();
			});
	};


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ReplaceSource = __webpack_require__(18);
	var RawSource = __webpack_require__(40);
	
	function DependenciesBlockVariable(name, expression, dependencies) {
		this.name = name;
		this.expression = expression;
		this.dependencies = dependencies || [];
	}
	module.exports = DependenciesBlockVariable;
	
	DependenciesBlockVariable.prototype.updateHash = function(hash) {
		hash.update(this.name);
		hash.update(this.expression);
		this.dependencies.forEach(function(d) {
			d.updateHash(hash);
		});
	};
	
	DependenciesBlockVariable.prototype.expressionSource = function(dependencyTemplates, outputOptions, requestShortener) {
		var source = new ReplaceSource(new RawSource(this.expression));
		this.dependencies.forEach(function(dep) {
			var template = dependencyTemplates.get(dep.constructor);
			if(!template) throw new Error("No template for dependency: " + dep.constructor.name);
			template.apply(dep, source, outputOptions, requestShortener, dependencyTemplates);
		});
		return source;
	};
	
	DependenciesBlockVariable.prototype.disconnect = function() {
		this.dependencies.forEach(function(d) {
			d.disconnect();
		});
	};
	
	DependenciesBlockVariable.prototype.hasDependencies = function() {
		return this.dependencies.length > 0;
	};


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Source = __webpack_require__(19);
	var SourceNode = __webpack_require__(20).SourceNode;
	var SourceListMap = __webpack_require__(31).SourceListMap;
	var fromStringWithSourceMap = __webpack_require__(31).fromStringWithSourceMap;
	var SourceMapConsumer = __webpack_require__(20).SourceMapConsumer;
	
	function ReplaceSource(source, name) {
		Source.call(this);
		this._source = source;
		this._name = name;
		this.replacements = [];
	}
	module.exports = ReplaceSource;
	
	ReplaceSource.prototype = Object.create(Source.prototype);
	ReplaceSource.prototype.constructor = ReplaceSource;
	
	ReplaceSource.prototype.replace = function(start, end, newValue) {
		this.replacements.push([start, end, newValue]);
	};
	
	ReplaceSource.prototype.insert = function(pos, newValue) {
		this.replacements.push([pos, pos-1, newValue]);
	};
	
	ReplaceSource.prototype.source = function(options) {
		return this._replaceString(this._source.source());
	};
	
	ReplaceSource.prototype._sortReplacements = function() {
		this.replacements.forEach(function(item, idx) {
			item[3] = idx;
		});
		this.replacements.sort(function(a, b) {
			var diff = b[1] - a[1];
			if(diff !== 0)
				return diff;
			return b[3] - a[3];
		});
	
	};
	
	ReplaceSource.prototype._replaceString = function(str) {
		this._sortReplacements();
		var result = [str];
		this.replacements.forEach(function(repl) {
			var remSource = result.pop();
			var splitted1 = this._splitString(remSource, Math.floor(repl[1]+1));
			var splitted2 = this._splitString(splitted1[0], Math.floor(repl[0]));
			result.push(splitted1[1], repl[2], splitted2[0]);
		}, this);
		result = result.reverse();
		return result.join("");
	};
	
	__webpack_require__(39)(ReplaceSource.prototype);
	
	ReplaceSource.prototype.node = function(options) {
		this._sortReplacements();
		var result = [this._source.node(options)];
		this.replacements.forEach(function(repl) {
			var remSource = result.pop();
			var splitted1 = this._splitSourceNode(remSource, Math.floor(repl[1]+1));
			if(Array.isArray(splitted1)) {
				var splitted2 = this._splitSourceNode(splitted1[0], Math.floor(repl[0]));
				if(Array.isArray(splitted2)) {
					result.push(splitted1[1], this._replacementToSourceNode(splitted2[1], repl[2]), splitted2[0]);
				} else {
					result.push(splitted1[1], this._replacementToSourceNode(splitted1[1], repl[2]), splitted1[0]);
				}
			} else {
				var splitted2 = this._splitSourceNode(remSource, Math.floor(repl[0]));
				if(Array.isArray(splitted2)) {
					result.push(this._replacementToSourceNode(splitted2[1], repl[2]), splitted2[0]);
				} else {
					result.push(repl[2], remSource);
				}
			}
		}, this);
		result = result.reverse();
		return new SourceNode(null, null, null, result);
	};
	
	ReplaceSource.prototype.listMap = function(options) {
		var map = this._source.listMap(options);
		if(map.children.length !== 1) {
			var code = map.toString();
			code = this._replaceString(code).split("\n");
			var currentIndex = 0;
			map.mapGeneratedCode(function(str) {
				var idx = -1;
				var count = -1;
				do {
					count++;
					idx = str.indexOf("\n", idx + 1);
				} while(idx >= 0);
				if(!count) return "";
				var result = code.slice(currentIndex, currentIndex + count).join("\n") + "\n";
				currentIndex += count;
				return result;
			});
			map.add(code.slice(currentIndex).join("\n"));
		} else {
			map.mapGeneratedCode(this._replaceString.bind(this));
		}
		return map;
	};
	
	ReplaceSource.prototype._replacementToSourceNode = function(oldNode, newString) {
		var map = oldNode.toStringWithSourceMap({ file: "?" }).map;
		var original = new SourceMapConsumer(map.toJSON()).originalPositionFor({ line: 1, column: 0 });
		if(original) {
			return new SourceNode(original.line, original.column, original.source, newString);
		} else {
			return newString;
		}
	};
	
	ReplaceSource.prototype._splitSourceNode = function(node, position) {
		if(typeof node === "string") {
			if(node.length <= position) return position - node.length;
			return [node.substr(0, position), node.substr(position)];
		} else {
			for(var i = 0; i < node.children.length; i++) {
				position = this._splitSourceNode(node.children[i], position);
				if(Array.isArray(position)) {
					var leftNode = new SourceNode(
						node.line,
						node.column,
						node.source,
						node.children.slice(0, i).concat([position[0]]),
						node.name
					);
					var rightNode = new SourceNode(
						node.line,
						node.column,
						node.source,
						[position[1]].concat(node.children.slice(i+1)),
						node.name
					);
					leftNode.sourceContents = node.sourceContents;
					return [leftNode, rightNode];
				}
			}
			return position;
		}
	};
	
	ReplaceSource.prototype._splitString = function(str, position) {
		return [str.substr(0, position), str.substr(position)];
	};


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var SourceNode = __webpack_require__(20).SourceNode;
	var SourceMapConsumer = __webpack_require__(20).SourceMapConsumer;
	
	function Source() {}
	
	module.exports = Source;
	
	Source.prototype.source = null;
	
	Source.prototype.size = function() {
		return this.source().length;
	};
	
	Source.prototype.map = function(options) {
		return null;
	};
	
	Source.prototype.sourceAndMap = function(options) {
		return {
			source: this.source(),
			map: this.map()
		};
	};
	
	Source.prototype.node = null;
	
	Source.prototype.listNode = null;
	
	Source.prototype.updateHash = function(hash) {
		var source = this.source();
		hash.update(source || "");
	};


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2009-2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE.txt or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	exports.SourceMapGenerator = __webpack_require__(21).SourceMapGenerator;
	exports.SourceMapConsumer = __webpack_require__(27).SourceMapConsumer;
	exports.SourceNode = __webpack_require__(30).SourceNode;


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  var base64VLQ = __webpack_require__(22);
	  var util = __webpack_require__(24);
	  var ArraySet = __webpack_require__(25).ArraySet;
	  var MappingList = __webpack_require__(26).MappingList;
	
	  /**
	   * An instance of the SourceMapGenerator represents a source map which is
	   * being built incrementally. You may pass an object with the following
	   * properties:
	   *
	   *   - file: The filename of the generated source.
	   *   - sourceRoot: A root for all relative URLs in this source map.
	   */
	  function SourceMapGenerator(aArgs) {
	    if (!aArgs) {
	      aArgs = {};
	    }
	    this._file = util.getArg(aArgs, 'file', null);
	    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	    this._sources = new ArraySet();
	    this._names = new ArraySet();
	    this._mappings = new MappingList();
	    this._sourcesContents = null;
	  }
	
	  SourceMapGenerator.prototype._version = 3;
	
	  /**
	   * Creates a new SourceMapGenerator based on a SourceMapConsumer
	   *
	   * @param aSourceMapConsumer The SourceMap.
	   */
	  SourceMapGenerator.fromSourceMap =
	    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	      var sourceRoot = aSourceMapConsumer.sourceRoot;
	      var generator = new SourceMapGenerator({
	        file: aSourceMapConsumer.file,
	        sourceRoot: sourceRoot
	      });
	      aSourceMapConsumer.eachMapping(function (mapping) {
	        var newMapping = {
	          generated: {
	            line: mapping.generatedLine,
	            column: mapping.generatedColumn
	          }
	        };
	
	        if (mapping.source != null) {
	          newMapping.source = mapping.source;
	          if (sourceRoot != null) {
	            newMapping.source = util.relative(sourceRoot, newMapping.source);
	          }
	
	          newMapping.original = {
	            line: mapping.originalLine,
	            column: mapping.originalColumn
	          };
	
	          if (mapping.name != null) {
	            newMapping.name = mapping.name;
	          }
	        }
	
	        generator.addMapping(newMapping);
	      });
	      aSourceMapConsumer.sources.forEach(function (sourceFile) {
	        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	        if (content != null) {
	          generator.setSourceContent(sourceFile, content);
	        }
	      });
	      return generator;
	    };
	
	  /**
	   * Add a single mapping from original source line and column to the generated
	   * source's line and column for this source map being created. The mapping
	   * object should have the following properties:
	   *
	   *   - generated: An object with the generated line and column positions.
	   *   - original: An object with the original line and column positions.
	   *   - source: The original source file (relative to the sourceRoot).
	   *   - name: An optional original token name for this mapping.
	   */
	  SourceMapGenerator.prototype.addMapping =
	    function SourceMapGenerator_addMapping(aArgs) {
	      var generated = util.getArg(aArgs, 'generated');
	      var original = util.getArg(aArgs, 'original', null);
	      var source = util.getArg(aArgs, 'source', null);
	      var name = util.getArg(aArgs, 'name', null);
	
	      if (!this._skipValidation) {
	        this._validateMapping(generated, original, source, name);
	      }
	
	      if (source != null && !this._sources.has(source)) {
	        this._sources.add(source);
	      }
	
	      if (name != null && !this._names.has(name)) {
	        this._names.add(name);
	      }
	
	      this._mappings.add({
	        generatedLine: generated.line,
	        generatedColumn: generated.column,
	        originalLine: original != null && original.line,
	        originalColumn: original != null && original.column,
	        source: source,
	        name: name
	      });
	    };
	
	  /**
	   * Set the source content for a source file.
	   */
	  SourceMapGenerator.prototype.setSourceContent =
	    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	      var source = aSourceFile;
	      if (this._sourceRoot != null) {
	        source = util.relative(this._sourceRoot, source);
	      }
	
	      if (aSourceContent != null) {
	        // Add the source content to the _sourcesContents map.
	        // Create a new _sourcesContents map if the property is null.
	        if (!this._sourcesContents) {
	          this._sourcesContents = {};
	        }
	        this._sourcesContents[util.toSetString(source)] = aSourceContent;
	      } else if (this._sourcesContents) {
	        // Remove the source file from the _sourcesContents map.
	        // If the _sourcesContents map is empty, set the property to null.
	        delete this._sourcesContents[util.toSetString(source)];
	        if (Object.keys(this._sourcesContents).length === 0) {
	          this._sourcesContents = null;
	        }
	      }
	    };
	
	  /**
	   * Applies the mappings of a sub-source-map for a specific source file to the
	   * source map being generated. Each mapping to the supplied source file is
	   * rewritten using the supplied source map. Note: The resolution for the
	   * resulting mappings is the minimium of this map and the supplied map.
	   *
	   * @param aSourceMapConsumer The source map to be applied.
	   * @param aSourceFile Optional. The filename of the source file.
	   *        If omitted, SourceMapConsumer's file property will be used.
	   * @param aSourceMapPath Optional. The dirname of the path to the source map
	   *        to be applied. If relative, it is relative to the SourceMapConsumer.
	   *        This parameter is needed when the two source maps aren't in the same
	   *        directory, and the source map to be applied contains relative source
	   *        paths. If so, those relative source paths need to be rewritten
	   *        relative to the SourceMapGenerator.
	   */
	  SourceMapGenerator.prototype.applySourceMap =
	    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	      var sourceFile = aSourceFile;
	      // If aSourceFile is omitted, we will use the file property of the SourceMap
	      if (aSourceFile == null) {
	        if (aSourceMapConsumer.file == null) {
	          throw new Error(
	            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	            'or the source map\'s "file" property. Both were omitted.'
	          );
	        }
	        sourceFile = aSourceMapConsumer.file;
	      }
	      var sourceRoot = this._sourceRoot;
	      // Make "sourceFile" relative if an absolute Url is passed.
	      if (sourceRoot != null) {
	        sourceFile = util.relative(sourceRoot, sourceFile);
	      }
	      // Applying the SourceMap can add and remove items from the sources and
	      // the names array.
	      var newSources = new ArraySet();
	      var newNames = new ArraySet();
	
	      // Find mappings for the "sourceFile"
	      this._mappings.unsortedForEach(function (mapping) {
	        if (mapping.source === sourceFile && mapping.originalLine != null) {
	          // Check if it can be mapped by the source map, then update the mapping.
	          var original = aSourceMapConsumer.originalPositionFor({
	            line: mapping.originalLine,
	            column: mapping.originalColumn
	          });
	          if (original.source != null) {
	            // Copy mapping
	            mapping.source = original.source;
	            if (aSourceMapPath != null) {
	              mapping.source = util.join(aSourceMapPath, mapping.source)
	            }
	            if (sourceRoot != null) {
	              mapping.source = util.relative(sourceRoot, mapping.source);
	            }
	            mapping.originalLine = original.line;
	            mapping.originalColumn = original.column;
	            if (original.name != null) {
	              mapping.name = original.name;
	            }
	          }
	        }
	
	        var source = mapping.source;
	        if (source != null && !newSources.has(source)) {
	          newSources.add(source);
	        }
	
	        var name = mapping.name;
	        if (name != null && !newNames.has(name)) {
	          newNames.add(name);
	        }
	
	      }, this);
	      this._sources = newSources;
	      this._names = newNames;
	
	      // Copy sourcesContents of applied map.
	      aSourceMapConsumer.sources.forEach(function (sourceFile) {
	        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	        if (content != null) {
	          if (aSourceMapPath != null) {
	            sourceFile = util.join(aSourceMapPath, sourceFile);
	          }
	          if (sourceRoot != null) {
	            sourceFile = util.relative(sourceRoot, sourceFile);
	          }
	          this.setSourceContent(sourceFile, content);
	        }
	      }, this);
	    };
	
	  /**
	   * A mapping can have one of the three levels of data:
	   *
	   *   1. Just the generated position.
	   *   2. The Generated position, original position, and original source.
	   *   3. Generated and original position, original source, as well as a name
	   *      token.
	   *
	   * To maintain consistency, we validate that any new mapping being added falls
	   * in to one of these categories.
	   */
	  SourceMapGenerator.prototype._validateMapping =
	    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                                aName) {
	      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	          && aGenerated.line > 0 && aGenerated.column >= 0
	          && !aOriginal && !aSource && !aName) {
	        // Case 1.
	        return;
	      }
	      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	               && aGenerated.line > 0 && aGenerated.column >= 0
	               && aOriginal.line > 0 && aOriginal.column >= 0
	               && aSource) {
	        // Cases 2 and 3.
	        return;
	      }
	      else {
	        throw new Error('Invalid mapping: ' + JSON.stringify({
	          generated: aGenerated,
	          source: aSource,
	          original: aOriginal,
	          name: aName
	        }));
	      }
	    };
	
	  /**
	   * Serialize the accumulated mappings in to the stream of base 64 VLQs
	   * specified by the source map format.
	   */
	  SourceMapGenerator.prototype._serializeMappings =
	    function SourceMapGenerator_serializeMappings() {
	      var previousGeneratedColumn = 0;
	      var previousGeneratedLine = 1;
	      var previousOriginalColumn = 0;
	      var previousOriginalLine = 0;
	      var previousName = 0;
	      var previousSource = 0;
	      var result = '';
	      var mapping;
	
	      var mappings = this._mappings.toArray();
	      for (var i = 0, len = mappings.length; i < len; i++) {
	        mapping = mappings[i];
	
	        if (mapping.generatedLine !== previousGeneratedLine) {
	          previousGeneratedColumn = 0;
	          while (mapping.generatedLine !== previousGeneratedLine) {
	            result += ';';
	            previousGeneratedLine++;
	          }
	        }
	        else {
	          if (i > 0) {
	            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	              continue;
	            }
	            result += ',';
	          }
	        }
	
	        result += base64VLQ.encode(mapping.generatedColumn
	                                   - previousGeneratedColumn);
	        previousGeneratedColumn = mapping.generatedColumn;
	
	        if (mapping.source != null) {
	          result += base64VLQ.encode(this._sources.indexOf(mapping.source)
	                                     - previousSource);
	          previousSource = this._sources.indexOf(mapping.source);
	
	          // lines are stored 0-based in SourceMap spec version 3
	          result += base64VLQ.encode(mapping.originalLine - 1
	                                     - previousOriginalLine);
	          previousOriginalLine = mapping.originalLine - 1;
	
	          result += base64VLQ.encode(mapping.originalColumn
	                                     - previousOriginalColumn);
	          previousOriginalColumn = mapping.originalColumn;
	
	          if (mapping.name != null) {
	            result += base64VLQ.encode(this._names.indexOf(mapping.name)
	                                       - previousName);
	            previousName = this._names.indexOf(mapping.name);
	          }
	        }
	      }
	
	      return result;
	    };
	
	  SourceMapGenerator.prototype._generateSourcesContent =
	    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	      return aSources.map(function (source) {
	        if (!this._sourcesContents) {
	          return null;
	        }
	        if (aSourceRoot != null) {
	          source = util.relative(aSourceRoot, source);
	        }
	        var key = util.toSetString(source);
	        return Object.prototype.hasOwnProperty.call(this._sourcesContents,
	                                                    key)
	          ? this._sourcesContents[key]
	          : null;
	      }, this);
	    };
	
	  /**
	   * Externalize the source map.
	   */
	  SourceMapGenerator.prototype.toJSON =
	    function SourceMapGenerator_toJSON() {
	      var map = {
	        version: this._version,
	        sources: this._sources.toArray(),
	        names: this._names.toArray(),
	        mappings: this._serializeMappings()
	      };
	      if (this._file != null) {
	        map.file = this._file;
	      }
	      if (this._sourceRoot != null) {
	        map.sourceRoot = this._sourceRoot;
	      }
	      if (this._sourcesContents) {
	        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	      }
	
	      return map;
	    };
	
	  /**
	   * Render the source map being generated to a string.
	   */
	  SourceMapGenerator.prototype.toString =
	    function SourceMapGenerator_toString() {
	      return JSON.stringify(this.toJSON());
	    };
	
	  exports.SourceMapGenerator = SourceMapGenerator;
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  var base64 = __webpack_require__(23);
	
	  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
	  // length quantities we use in the source map spec, the first bit is the sign,
	  // the next four bits are the actual value, and the 6th bit is the
	  // continuation bit. The continuation bit tells us whether there are more
	  // digits in this value following this digit.
	  //
	  //   Continuation
	  //   |    Sign
	  //   |    |
	  //   V    V
	  //   101011
	
	  var VLQ_BASE_SHIFT = 5;
	
	  // binary: 100000
	  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
	
	  // binary: 011111
	  var VLQ_BASE_MASK = VLQ_BASE - 1;
	
	  // binary: 100000
	  var VLQ_CONTINUATION_BIT = VLQ_BASE;
	
	  /**
	   * Converts from a two-complement value to a value where the sign bit is
	   * placed in the least significant bit.  For example, as decimals:
	   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	   */
	  function toVLQSigned(aValue) {
	    return aValue < 0
	      ? ((-aValue) << 1) + 1
	      : (aValue << 1) + 0;
	  }
	
	  /**
	   * Converts to a two-complement value from a value where the sign bit is
	   * placed in the least significant bit.  For example, as decimals:
	   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	   */
	  function fromVLQSigned(aValue) {
	    var isNegative = (aValue & 1) === 1;
	    var shifted = aValue >> 1;
	    return isNegative
	      ? -shifted
	      : shifted;
	  }
	
	  /**
	   * Returns the base 64 VLQ encoded value.
	   */
	  exports.encode = function base64VLQ_encode(aValue) {
	    var encoded = "";
	    var digit;
	
	    var vlq = toVLQSigned(aValue);
	
	    do {
	      digit = vlq & VLQ_BASE_MASK;
	      vlq >>>= VLQ_BASE_SHIFT;
	      if (vlq > 0) {
	        // There are still more digits in this value, so we must make sure the
	        // continuation bit is marked.
	        digit |= VLQ_CONTINUATION_BIT;
	      }
	      encoded += base64.encode(digit);
	    } while (vlq > 0);
	
	    return encoded;
	  };
	
	  /**
	   * Decodes the next base 64 VLQ value from the given string and returns the
	   * value and the rest of the string via the out parameter.
	   */
	  exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	    var strLen = aStr.length;
	    var result = 0;
	    var shift = 0;
	    var continuation, digit;
	
	    do {
	      if (aIndex >= strLen) {
	        throw new Error("Expected more digits in base 64 VLQ value.");
	      }
	
	      digit = base64.decode(aStr.charCodeAt(aIndex++));
	      if (digit === -1) {
	        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	      }
	
	      continuation = !!(digit & VLQ_CONTINUATION_BIT);
	      digit &= VLQ_BASE_MASK;
	      result = result + (digit << shift);
	      shift += VLQ_BASE_SHIFT;
	    } while (continuation);
	
	    aOutParam.value = fromVLQSigned(result);
	    aOutParam.rest = aIndex;
	  };
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
	
	  /**
	   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	   */
	  exports.encode = function (number) {
	    if (0 <= number && number < intToCharMap.length) {
	      return intToCharMap[number];
	    }
	    throw new TypeError("Must be between 0 and 63: " + aNumber);
	  };
	
	  /**
	   * Decode a single base 64 character code digit to an integer. Returns -1 on
	   * failure.
	   */
	  exports.decode = function (charCode) {
	    var bigA = 65;     // 'A'
	    var bigZ = 90;     // 'Z'
	
	    var littleA = 97;  // 'a'
	    var littleZ = 122; // 'z'
	
	    var zero = 48;     // '0'
	    var nine = 57;     // '9'
	
	    var plus = 43;     // '+'
	    var slash = 47;    // '/'
	
	    var littleOffset = 26;
	    var numberOffset = 52;
	
	    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	    if (bigA <= charCode && charCode <= bigZ) {
	      return (charCode - bigA);
	    }
	
	    // 26 - 51: abcdefghijklmnopqrstuvwxyz
	    if (littleA <= charCode && charCode <= littleZ) {
	      return (charCode - littleA + littleOffset);
	    }
	
	    // 52 - 61: 0123456789
	    if (zero <= charCode && charCode <= nine) {
	      return (charCode - zero + numberOffset);
	    }
	
	    // 62: +
	    if (charCode == plus) {
	      return 62;
	    }
	
	    // 63: /
	    if (charCode == slash) {
	      return 63;
	    }
	
	    // Invalid base64 digit.
	    return -1;
	  };
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  /**
	   * This is a helper function for getting values from parameter/options
	   * objects.
	   *
	   * @param args The object we are extracting values from
	   * @param name The name of the property we are getting.
	   * @param defaultValue An optional value to return if the property is missing
	   * from the object. If this is not specified and the property is missing, an
	   * error will be thrown.
	   */
	  function getArg(aArgs, aName, aDefaultValue) {
	    if (aName in aArgs) {
	      return aArgs[aName];
	    } else if (arguments.length === 3) {
	      return aDefaultValue;
	    } else {
	      throw new Error('"' + aName + '" is a required argument.');
	    }
	  }
	  exports.getArg = getArg;
	
	  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
	  var dataUrlRegexp = /^data:.+\,.+$/;
	
	  function urlParse(aUrl) {
	    var match = aUrl.match(urlRegexp);
	    if (!match) {
	      return null;
	    }
	    return {
	      scheme: match[1],
	      auth: match[2],
	      host: match[3],
	      port: match[4],
	      path: match[5]
	    };
	  }
	  exports.urlParse = urlParse;
	
	  function urlGenerate(aParsedUrl) {
	    var url = '';
	    if (aParsedUrl.scheme) {
	      url += aParsedUrl.scheme + ':';
	    }
	    url += '//';
	    if (aParsedUrl.auth) {
	      url += aParsedUrl.auth + '@';
	    }
	    if (aParsedUrl.host) {
	      url += aParsedUrl.host;
	    }
	    if (aParsedUrl.port) {
	      url += ":" + aParsedUrl.port
	    }
	    if (aParsedUrl.path) {
	      url += aParsedUrl.path;
	    }
	    return url;
	  }
	  exports.urlGenerate = urlGenerate;
	
	  /**
	   * Normalizes a path, or the path portion of a URL:
	   *
	   * - Replaces consequtive slashes with one slash.
	   * - Removes unnecessary '.' parts.
	   * - Removes unnecessary '<dir>/..' parts.
	   *
	   * Based on code in the Node.js 'path' core module.
	   *
	   * @param aPath The path or url to normalize.
	   */
	  function normalize(aPath) {
	    var path = aPath;
	    var url = urlParse(aPath);
	    if (url) {
	      if (!url.path) {
	        return aPath;
	      }
	      path = url.path;
	    }
	    var isAbsolute = (path.charAt(0) === '/');
	
	    var parts = path.split(/\/+/);
	    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	      part = parts[i];
	      if (part === '.') {
	        parts.splice(i, 1);
	      } else if (part === '..') {
	        up++;
	      } else if (up > 0) {
	        if (part === '') {
	          // The first part is blank if the path is absolute. Trying to go
	          // above the root is a no-op. Therefore we can remove all '..' parts
	          // directly after the root.
	          parts.splice(i + 1, up);
	          up = 0;
	        } else {
	          parts.splice(i, 2);
	          up--;
	        }
	      }
	    }
	    path = parts.join('/');
	
	    if (path === '') {
	      path = isAbsolute ? '/' : '.';
	    }
	
	    if (url) {
	      url.path = path;
	      return urlGenerate(url);
	    }
	    return path;
	  }
	  exports.normalize = normalize;
	
	  /**
	   * Joins two paths/URLs.
	   *
	   * @param aRoot The root path or URL.
	   * @param aPath The path or URL to be joined with the root.
	   *
	   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	   *   first.
	   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	   *   is updated with the result and aRoot is returned. Otherwise the result
	   *   is returned.
	   *   - If aPath is absolute, the result is aPath.
	   *   - Otherwise the two paths are joined with a slash.
	   * - Joining for example 'http://' and 'www.example.com' is also supported.
	   */
	  function join(aRoot, aPath) {
	    if (aRoot === "") {
	      aRoot = ".";
	    }
	    if (aPath === "") {
	      aPath = ".";
	    }
	    var aPathUrl = urlParse(aPath);
	    var aRootUrl = urlParse(aRoot);
	    if (aRootUrl) {
	      aRoot = aRootUrl.path || '/';
	    }
	
	    // `join(foo, '//www.example.org')`
	    if (aPathUrl && !aPathUrl.scheme) {
	      if (aRootUrl) {
	        aPathUrl.scheme = aRootUrl.scheme;
	      }
	      return urlGenerate(aPathUrl);
	    }
	
	    if (aPathUrl || aPath.match(dataUrlRegexp)) {
	      return aPath;
	    }
	
	    // `join('http://', 'www.example.com')`
	    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	      aRootUrl.host = aPath;
	      return urlGenerate(aRootUrl);
	    }
	
	    var joined = aPath.charAt(0) === '/'
	      ? aPath
	      : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
	
	    if (aRootUrl) {
	      aRootUrl.path = joined;
	      return urlGenerate(aRootUrl);
	    }
	    return joined;
	  }
	  exports.join = join;
	
	  /**
	   * Make a path relative to a URL or another path.
	   *
	   * @param aRoot The root path or URL.
	   * @param aPath The path or URL to be made relative to aRoot.
	   */
	  function relative(aRoot, aPath) {
	    if (aRoot === "") {
	      aRoot = ".";
	    }
	
	    aRoot = aRoot.replace(/\/$/, '');
	
	    // It is possible for the path to be above the root. In this case, simply
	    // checking whether the root is a prefix of the path won't work. Instead, we
	    // need to remove components from the root one by one, until either we find
	    // a prefix that fits, or we run out of components to remove.
	    var level = 0;
	    while (aPath.indexOf(aRoot + '/') !== 0) {
	      var index = aRoot.lastIndexOf("/");
	      if (index < 0) {
	        return aPath;
	      }
	
	      // If the only part of the root that is left is the scheme (i.e. http://,
	      // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	      // have exhausted all components, so the path is not relative to the root.
	      aRoot = aRoot.slice(0, index);
	      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	        return aPath;
	      }
	
	      ++level;
	    }
	
	    // Make sure we add a "../" for each component we removed from the root.
	    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	  }
	  exports.relative = relative;
	
	  /**
	   * Because behavior goes wacky when you set `__proto__` on objects, we
	   * have to prefix all the strings in our set with an arbitrary character.
	   *
	   * See https://github.com/mozilla/source-map/pull/31 and
	   * https://github.com/mozilla/source-map/issues/30
	   *
	   * @param String aStr
	   */
	  function toSetString(aStr) {
	    return '$' + aStr;
	  }
	  exports.toSetString = toSetString;
	
	  function fromSetString(aStr) {
	    return aStr.substr(1);
	  }
	  exports.fromSetString = fromSetString;
	
	  /**
	   * Comparator between two mappings where the original positions are compared.
	   *
	   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	   * mappings with the same original source/line/column, but different generated
	   * line and column the same. Useful when searching for a mapping with a
	   * stubbed out mapping.
	   */
	  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	    var cmp = mappingA.source - mappingB.source;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalLine - mappingB.originalLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalColumn - mappingB.originalColumn;
	    if (cmp !== 0 || onlyCompareOriginal) {
	      return cmp;
	    }
	
	    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.generatedLine - mappingB.generatedLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    return mappingA.name - mappingB.name;
	  };
	  exports.compareByOriginalPositions = compareByOriginalPositions;
	
	  /**
	   * Comparator between two mappings with deflated source and name indices where
	   * the generated positions are compared.
	   *
	   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	   * mappings with the same generated line and column, but different
	   * source/name/original line and column the same. Useful when searching for a
	   * mapping with a stubbed out mapping.
	   */
	  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	    var cmp = mappingA.generatedLine - mappingB.generatedLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	    if (cmp !== 0 || onlyCompareGenerated) {
	      return cmp;
	    }
	
	    cmp = mappingA.source - mappingB.source;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalLine - mappingB.originalLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalColumn - mappingB.originalColumn;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    return mappingA.name - mappingB.name;
	  };
	  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
	
	  function strcmp(aStr1, aStr2) {
	    if (aStr1 === aStr2) {
	      return 0;
	    }
	
	    if (aStr1 > aStr2) {
	      return 1;
	    }
	
	    return -1;
	  }
	
	  /**
	   * Comparator between two mappings with inflated source and name strings where
	   * the generated positions are compared.
	   */
	  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	    var cmp = mappingA.generatedLine - mappingB.generatedLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = strcmp(mappingA.source, mappingB.source);
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalLine - mappingB.originalLine;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    cmp = mappingA.originalColumn - mappingB.originalColumn;
	    if (cmp !== 0) {
	      return cmp;
	    }
	
	    return strcmp(mappingA.name, mappingB.name);
	  };
	  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  var util = __webpack_require__(24);
	
	  /**
	   * A data structure which is a combination of an array and a set. Adding a new
	   * member is O(1), testing for membership is O(1), and finding the index of an
	   * element is O(1). Removing elements from the set is not supported. Only
	   * strings are supported for membership.
	   */
	  function ArraySet() {
	    this._array = [];
	    this._set = {};
	  }
	
	  /**
	   * Static method for creating ArraySet instances from an existing array.
	   */
	  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	    var set = new ArraySet();
	    for (var i = 0, len = aArray.length; i < len; i++) {
	      set.add(aArray[i], aAllowDuplicates);
	    }
	    return set;
	  };
	
	  /**
	   * Return how many unique items are in this ArraySet. If duplicates have been
	   * added, than those do not count towards the size.
	   *
	   * @returns Number
	   */
	  ArraySet.prototype.size = function ArraySet_size() {
	    return Object.getOwnPropertyNames(this._set).length;
	  };
	
	  /**
	   * Add the given string to this set.
	   *
	   * @param String aStr
	   */
	  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	    var isDuplicate = this.has(aStr);
	    var idx = this._array.length;
	    if (!isDuplicate || aAllowDuplicates) {
	      this._array.push(aStr);
	    }
	    if (!isDuplicate) {
	      this._set[util.toSetString(aStr)] = idx;
	    }
	  };
	
	  /**
	   * Is the given string a member of this set?
	   *
	   * @param String aStr
	   */
	  ArraySet.prototype.has = function ArraySet_has(aStr) {
	    return Object.prototype.hasOwnProperty.call(this._set,
	                                                util.toSetString(aStr));
	  };
	
	  /**
	   * What is the index of the given string in the array?
	   *
	   * @param String aStr
	   */
	  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	    if (this.has(aStr)) {
	      return this._set[util.toSetString(aStr)];
	    }
	    throw new Error('"' + aStr + '" is not in the set.');
	  };
	
	  /**
	   * What is the element at the given index?
	   *
	   * @param Number aIdx
	   */
	  ArraySet.prototype.at = function ArraySet_at(aIdx) {
	    if (aIdx >= 0 && aIdx < this._array.length) {
	      return this._array[aIdx];
	    }
	    throw new Error('No element indexed by ' + aIdx);
	  };
	
	  /**
	   * Returns the array representation of this set (which has the proper indices
	   * indicated by indexOf). Note that this is a copy of the internal array used
	   * for storing the members so that no one can mess with internal state.
	   */
	  ArraySet.prototype.toArray = function ArraySet_toArray() {
	    return this._array.slice();
	  };
	
	  exports.ArraySet = ArraySet;
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  var util = __webpack_require__(24);
	
	  /**
	   * Determine whether mappingB is after mappingA with respect to generated
	   * position.
	   */
	  function generatedPositionAfter(mappingA, mappingB) {
	    // Optimized for most common case
	    var lineA = mappingA.generatedLine;
	    var lineB = mappingB.generatedLine;
	    var columnA = mappingA.generatedColumn;
	    var columnB = mappingB.generatedColumn;
	    return lineB > lineA || lineB == lineA && columnB >= columnA ||
	           util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	  }
	
	  /**
	   * A data structure to provide a sorted view of accumulated mappings in a
	   * performance conscious manner. It trades a neglibable overhead in general
	   * case for a large speedup in case of mappings being added in order.
	   */
	  function MappingList() {
	    this._array = [];
	    this._sorted = true;
	    // Serves as infimum
	    this._last = {generatedLine: -1, generatedColumn: 0};
	  }
	
	  /**
	   * Iterate through internal items. This method takes the same arguments that
	   * `Array.prototype.forEach` takes.
	   *
	   * NOTE: The order of the mappings is NOT guaranteed.
	   */
	  MappingList.prototype.unsortedForEach =
	    function MappingList_forEach(aCallback, aThisArg) {
	      this._array.forEach(aCallback, aThisArg);
	    };
	
	  /**
	   * Add the given source mapping.
	   *
	   * @param Object aMapping
	   */
	  MappingList.prototype.add = function MappingList_add(aMapping) {
	    var mapping;
	    if (generatedPositionAfter(this._last, aMapping)) {
	      this._last = aMapping;
	      this._array.push(aMapping);
	    } else {
	      this._sorted = false;
	      this._array.push(aMapping);
	    }
	  };
	
	  /**
	   * Returns the flat, sorted array of mappings. The mappings are sorted by
	   * generated position.
	   *
	   * WARNING: This method returns internal data without copying, for
	   * performance. The return value must NOT be mutated, and should be treated as
	   * an immutable borrow. If you want to take ownership, you must make your own
	   * copy.
	   */
	  MappingList.prototype.toArray = function MappingList_toArray() {
	    if (!this._sorted) {
	      this._array.sort(util.compareByGeneratedPositionsInflated);
	      this._sorted = true;
	    }
	    return this._array;
	  };
	
	  exports.MappingList = MappingList;
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  var util = __webpack_require__(24);
	  var binarySearch = __webpack_require__(28);
	  var ArraySet = __webpack_require__(25).ArraySet;
	  var base64VLQ = __webpack_require__(22);
	  var quickSort = __webpack_require__(29).quickSort;
	
	  function SourceMapConsumer(aSourceMap) {
	    var sourceMap = aSourceMap;
	    if (typeof aSourceMap === 'string') {
	      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	    }
	
	    return sourceMap.sections != null
	      ? new IndexedSourceMapConsumer(sourceMap)
	      : new BasicSourceMapConsumer(sourceMap);
	  }
	
	  SourceMapConsumer.fromSourceMap = function(aSourceMap) {
	    return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
	  }
	
	  /**
	   * The version of the source mapping spec that we are consuming.
	   */
	  SourceMapConsumer.prototype._version = 3;
	
	  // `__generatedMappings` and `__originalMappings` are arrays that hold the
	  // parsed mapping coordinates from the source map's "mappings" attribute. They
	  // are lazily instantiated, accessed via the `_generatedMappings` and
	  // `_originalMappings` getters respectively, and we only parse the mappings
	  // and create these arrays once queried for a source location. We jump through
	  // these hoops because there can be many thousands of mappings, and parsing
	  // them is expensive, so we only want to do it if we must.
	  //
	  // Each object in the arrays is of the form:
	  //
	  //     {
	  //       generatedLine: The line number in the generated code,
	  //       generatedColumn: The column number in the generated code,
	  //       source: The path to the original source file that generated this
	  //               chunk of code,
	  //       originalLine: The line number in the original source that
	  //                     corresponds to this chunk of generated code,
	  //       originalColumn: The column number in the original source that
	  //                       corresponds to this chunk of generated code,
	  //       name: The name of the original symbol which generated this chunk of
	  //             code.
	  //     }
	  //
	  // All properties except for `generatedLine` and `generatedColumn` can be
	  // `null`.
	  //
	  // `_generatedMappings` is ordered by the generated positions.
	  //
	  // `_originalMappings` is ordered by the original positions.
	
	  SourceMapConsumer.prototype.__generatedMappings = null;
	  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	    get: function () {
	      if (!this.__generatedMappings) {
	        this._parseMappings(this._mappings, this.sourceRoot);
	      }
	
	      return this.__generatedMappings;
	    }
	  });
	
	  SourceMapConsumer.prototype.__originalMappings = null;
	  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	    get: function () {
	      if (!this.__originalMappings) {
	        this._parseMappings(this._mappings, this.sourceRoot);
	      }
	
	      return this.__originalMappings;
	    }
	  });
	
	  SourceMapConsumer.prototype._charIsMappingSeparator =
	    function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
	      var c = aStr.charAt(index);
	      return c === ";" || c === ",";
	    };
	
	  /**
	   * Parse the mappings in a string in to a data structure which we can easily
	   * query (the ordered arrays in the `this.__generatedMappings` and
	   * `this.__originalMappings` properties).
	   */
	  SourceMapConsumer.prototype._parseMappings =
	    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	      throw new Error("Subclasses must implement _parseMappings");
	    };
	
	  SourceMapConsumer.GENERATED_ORDER = 1;
	  SourceMapConsumer.ORIGINAL_ORDER = 2;
	
	  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
	  SourceMapConsumer.LEAST_UPPER_BOUND = 2;
	
	  /**
	   * Iterate over each mapping between an original source/line/column and a
	   * generated line/column in this source map.
	   *
	   * @param Function aCallback
	   *        The function that is called with each mapping.
	   * @param Object aContext
	   *        Optional. If specified, this object will be the value of `this` every
	   *        time that `aCallback` is called.
	   * @param aOrder
	   *        Either `SourceMapConsumer.GENERATED_ORDER` or
	   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
	   *        iterate over the mappings sorted by the generated file's line/column
	   *        order or the original's source/line/column order, respectively. Defaults to
	   *        `SourceMapConsumer.GENERATED_ORDER`.
	   */
	  SourceMapConsumer.prototype.eachMapping =
	    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	      var context = aContext || null;
	      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
	
	      var mappings;
	      switch (order) {
	      case SourceMapConsumer.GENERATED_ORDER:
	        mappings = this._generatedMappings;
	        break;
	      case SourceMapConsumer.ORIGINAL_ORDER:
	        mappings = this._originalMappings;
	        break;
	      default:
	        throw new Error("Unknown order of iteration.");
	      }
	
	      var sourceRoot = this.sourceRoot;
	      mappings.map(function (mapping) {
	        var source = mapping.source === null ? null : this._sources.at(mapping.source);
	        if (source != null && sourceRoot != null) {
	          source = util.join(sourceRoot, source);
	        }
	        return {
	          source: source,
	          generatedLine: mapping.generatedLine,
	          generatedColumn: mapping.generatedColumn,
	          originalLine: mapping.originalLine,
	          originalColumn: mapping.originalColumn,
	          name: mapping.name === null ? null : this._names.at(mapping.name)
	        };
	      }, this).forEach(aCallback, context);
	    };
	
	  /**
	   * Returns all generated line and column information for the original source,
	   * line, and column provided. If no column is provided, returns all mappings
	   * corresponding to a either the line we are searching for or the next
	   * closest line that has any mappings. Otherwise, returns all mappings
	   * corresponding to the given line and either the column we are searching for
	   * or the next closest column that has any offsets.
	   *
	   * The only argument is an object with the following properties:
	   *
	   *   - source: The filename of the original source.
	   *   - line: The line number in the original source.
	   *   - column: Optional. the column number in the original source.
	   *
	   * and an array of objects is returned, each with the following properties:
	   *
	   *   - line: The line number in the generated source, or null.
	   *   - column: The column number in the generated source, or null.
	   */
	  SourceMapConsumer.prototype.allGeneratedPositionsFor =
	    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
	      var line = util.getArg(aArgs, 'line');
	
	      // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
	      // returns the index of the closest mapping less than the needle. By
	      // setting needle.originalColumn to 0, we thus find the last mapping for
	      // the given line, provided such a mapping exists.
	      var needle = {
	        source: util.getArg(aArgs, 'source'),
	        originalLine: line,
	        originalColumn: util.getArg(aArgs, 'column', 0)
	      };
	
	      if (this.sourceRoot != null) {
	        needle.source = util.relative(this.sourceRoot, needle.source);
	      }
	      if (!this._sources.has(needle.source)) {
	        return [];
	      }
	      needle.source = this._sources.indexOf(needle.source);
	
	      var mappings = [];
	
	      var index = this._findMapping(needle,
	                                    this._originalMappings,
	                                    "originalLine",
	                                    "originalColumn",
	                                    util.compareByOriginalPositions,
	                                    binarySearch.LEAST_UPPER_BOUND);
	      if (index >= 0) {
	        var mapping = this._originalMappings[index];
	
	        if (aArgs.column === undefined) {
	          var originalLine = mapping.originalLine;
	
	          // Iterate until either we run out of mappings, or we run into
	          // a mapping for a different line than the one we found. Since
	          // mappings are sorted, this is guaranteed to find all mappings for
	          // the line we found.
	          while (mapping && mapping.originalLine === originalLine) {
	            mappings.push({
	              line: util.getArg(mapping, 'generatedLine', null),
	              column: util.getArg(mapping, 'generatedColumn', null),
	              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	            });
	
	            mapping = this._originalMappings[++index];
	          }
	        } else {
	          var originalColumn = mapping.originalColumn;
	
	          // Iterate until either we run out of mappings, or we run into
	          // a mapping for a different line than the one we were searching for.
	          // Since mappings are sorted, this is guaranteed to find all mappings for
	          // the line we are searching for.
	          while (mapping &&
	                 mapping.originalLine === line &&
	                 mapping.originalColumn == originalColumn) {
	            mappings.push({
	              line: util.getArg(mapping, 'generatedLine', null),
	              column: util.getArg(mapping, 'generatedColumn', null),
	              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	            });
	
	            mapping = this._originalMappings[++index];
	          }
	        }
	      }
	
	      return mappings;
	    };
	
	  exports.SourceMapConsumer = SourceMapConsumer;
	
	  /**
	   * A BasicSourceMapConsumer instance represents a parsed source map which we can
	   * query for information about the original file positions by giving it a file
	   * position in the generated source.
	   *
	   * The only parameter is the raw source map (either as a JSON string, or
	   * already parsed to an object). According to the spec, source maps have the
	   * following attributes:
	   *
	   *   - version: Which version of the source map spec this map is following.
	   *   - sources: An array of URLs to the original source files.
	   *   - names: An array of identifiers which can be referrenced by individual mappings.
	   *   - sourceRoot: Optional. The URL root from which all sources are relative.
	   *   - sourcesContent: Optional. An array of contents of the original source files.
	   *   - mappings: A string of base64 VLQs which contain the actual mappings.
	   *   - file: Optional. The generated file this source map is associated with.
	   *
	   * Here is an example source map, taken from the source map spec[0]:
	   *
	   *     {
	   *       version : 3,
	   *       file: "out.js",
	   *       sourceRoot : "",
	   *       sources: ["foo.js", "bar.js"],
	   *       names: ["src", "maps", "are", "fun"],
	   *       mappings: "AA,AB;;ABCDE;"
	   *     }
	   *
	   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
	   */
	  function BasicSourceMapConsumer(aSourceMap) {
	    var sourceMap = aSourceMap;
	    if (typeof aSourceMap === 'string') {
	      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	    }
	
	    var version = util.getArg(sourceMap, 'version');
	    var sources = util.getArg(sourceMap, 'sources');
	    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
	    // requires the array) to play nice here.
	    var names = util.getArg(sourceMap, 'names', []);
	    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	    var mappings = util.getArg(sourceMap, 'mappings');
	    var file = util.getArg(sourceMap, 'file', null);
	
	    // Once again, Sass deviates from the spec and supplies the version as a
	    // string rather than a number, so we use loose equality checking here.
	    if (version != this._version) {
	      throw new Error('Unsupported version: ' + version);
	    }
	
	    // Some source maps produce relative source paths like "./foo.js" instead of
	    // "foo.js".  Normalize these first so that future comparisons will succeed.
	    // See bugzil.la/1090768.
	    sources = sources.map(util.normalize);
	
	    // Pass `true` below to allow duplicate names and sources. While source maps
	    // are intended to be compressed and deduplicated, the TypeScript compiler
	    // sometimes generates source maps with duplicates in them. See Github issue
	    // #72 and bugzil.la/889492.
	    this._names = ArraySet.fromArray(names, true);
	    this._sources = ArraySet.fromArray(sources, true);
	
	    this.sourceRoot = sourceRoot;
	    this.sourcesContent = sourcesContent;
	    this._mappings = mappings;
	    this.file = file;
	  }
	
	  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
	
	  /**
	   * Create a BasicSourceMapConsumer from a SourceMapGenerator.
	   *
	   * @param SourceMapGenerator aSourceMap
	   *        The source map that will be consumed.
	   * @returns BasicSourceMapConsumer
	   */
	  BasicSourceMapConsumer.fromSourceMap =
	    function SourceMapConsumer_fromSourceMap(aSourceMap) {
	      var smc = Object.create(BasicSourceMapConsumer.prototype);
	
	      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
	      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
	      smc.sourceRoot = aSourceMap._sourceRoot;
	      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
	                                                              smc.sourceRoot);
	      smc.file = aSourceMap._file;
	
	      // Because we are modifying the entries (by converting string sources and
	      // names to indices into the sources and names ArraySets), we have to make
	      // a copy of the entry or else bad things happen. Shared mutable state
	      // strikes again! See github issue #191.
	
	      var generatedMappings = aSourceMap._mappings.toArray().slice();
	      var destGeneratedMappings = smc.__generatedMappings = [];
	      var destOriginalMappings = smc.__originalMappings = [];
	
	      for (var i = 0, length = generatedMappings.length; i < length; i++) {
	        var srcMapping = generatedMappings[i];
	        var destMapping = new Mapping;
	        destMapping.generatedLine = srcMapping.generatedLine;
	        destMapping.generatedColumn = srcMapping.generatedColumn;
	
	        if (srcMapping.source) {
	          destMapping.source = sources.indexOf(srcMapping.source);
	          destMapping.originalLine = srcMapping.originalLine;
	          destMapping.originalColumn = srcMapping.originalColumn;
	
	          if (srcMapping.name) {
	            destMapping.name = names.indexOf(srcMapping.name);
	          }
	
	          destOriginalMappings.push(destMapping);
	        }
	
	        destGeneratedMappings.push(destMapping);
	      }
	
	      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
	
	      return smc;
	    };
	
	  /**
	   * The version of the source mapping spec that we are consuming.
	   */
	  BasicSourceMapConsumer.prototype._version = 3;
	
	  /**
	   * The list of original sources.
	   */
	  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
	    get: function () {
	      return this._sources.toArray().map(function (s) {
	        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
	      }, this);
	    }
	  });
	
	  /**
	   * Provide the JIT with a nice shape / hidden class.
	   */
	  function Mapping() {
	    this.generatedLine = 0;
	    this.generatedColumn = 0;
	    this.source = null;
	    this.originalLine = null;
	    this.originalColumn = null;
	    this.name = null;
	  }
	
	  /**
	   * Parse the mappings in a string in to a data structure which we can easily
	   * query (the ordered arrays in the `this.__generatedMappings` and
	   * `this.__originalMappings` properties).
	   */
	  BasicSourceMapConsumer.prototype._parseMappings =
	    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	      var generatedLine = 1;
	      var previousGeneratedColumn = 0;
	      var previousOriginalLine = 0;
	      var previousOriginalColumn = 0;
	      var previousSource = 0;
	      var previousName = 0;
	      var length = aStr.length;
	      var index = 0;
	      var cachedSegments = {};
	      var temp = {};
	      var originalMappings = [];
	      var generatedMappings = [];
	      var mapping, str, segment, end, value;
	
	      while (index < length) {
	        if (aStr.charAt(index) === ';') {
	          generatedLine++;
	          index++;
	          previousGeneratedColumn = 0;
	        }
	        else if (aStr.charAt(index) === ',') {
	          index++;
	        }
	        else {
	          mapping = new Mapping();
	          mapping.generatedLine = generatedLine;
	
	          // Because each offset is encoded relative to the previous one,
	          // many segments often have the same encoding. We can exploit this
	          // fact by caching the parsed variable length fields of each segment,
	          // allowing us to avoid a second parse if we encounter the same
	          // segment again.
	          for (end = index; end < length; end++) {
	            if (this._charIsMappingSeparator(aStr, end)) {
	              break;
	            }
	          }
	          str = aStr.slice(index, end);
	
	          segment = cachedSegments[str];
	          if (segment) {
	            index += str.length;
	          } else {
	            segment = [];
	            while (index < end) {
	              base64VLQ.decode(aStr, index, temp);
	              value = temp.value;
	              index = temp.rest;
	              segment.push(value);
	            }
	
	            if (segment.length === 2) {
	              throw new Error('Found a source, but no line and column');
	            }
	
	            if (segment.length === 3) {
	              throw new Error('Found a source and line, but no column');
	            }
	
	            cachedSegments[str] = segment;
	          }
	
	          // Generated column.
	          mapping.generatedColumn = previousGeneratedColumn + segment[0];
	          previousGeneratedColumn = mapping.generatedColumn;
	
	          if (segment.length > 1) {
	            // Original source.
	            mapping.source = previousSource + segment[1];
	            previousSource += segment[1];
	
	            // Original line.
	            mapping.originalLine = previousOriginalLine + segment[2];
	            previousOriginalLine = mapping.originalLine;
	            // Lines are stored 0-based
	            mapping.originalLine += 1;
	
	            // Original column.
	            mapping.originalColumn = previousOriginalColumn + segment[3];
	            previousOriginalColumn = mapping.originalColumn;
	
	            if (segment.length > 4) {
	              // Original name.
	              mapping.name = previousName + segment[4];
	              previousName += segment[4];
	            }
	          }
	
	          generatedMappings.push(mapping);
	          if (typeof mapping.originalLine === 'number') {
	            originalMappings.push(mapping);
	          }
	        }
	      }
	
	      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
	      this.__generatedMappings = generatedMappings;
	
	      quickSort(originalMappings, util.compareByOriginalPositions);
	      this.__originalMappings = originalMappings;
	    };
	
	  /**
	   * Find the mapping that best matches the hypothetical "needle" mapping that
	   * we are searching for in the given "haystack" of mappings.
	   */
	  BasicSourceMapConsumer.prototype._findMapping =
	    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
	                                           aColumnName, aComparator, aBias) {
	      // To return the position we are searching for, we must first find the
	      // mapping for the given position and then return the opposite position it
	      // points to. Because the mappings are sorted, we can use binary search to
	      // find the best mapping.
	
	      if (aNeedle[aLineName] <= 0) {
	        throw new TypeError('Line must be greater than or equal to 1, got '
	                            + aNeedle[aLineName]);
	      }
	      if (aNeedle[aColumnName] < 0) {
	        throw new TypeError('Column must be greater than or equal to 0, got '
	                            + aNeedle[aColumnName]);
	      }
	
	      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	    };
	
	  /**
	   * Compute the last column for each generated mapping. The last column is
	   * inclusive.
	   */
	  BasicSourceMapConsumer.prototype.computeColumnSpans =
	    function SourceMapConsumer_computeColumnSpans() {
	      for (var index = 0; index < this._generatedMappings.length; ++index) {
	        var mapping = this._generatedMappings[index];
	
	        // Mappings do not contain a field for the last generated columnt. We
	        // can come up with an optimistic estimate, however, by assuming that
	        // mappings are contiguous (i.e. given two consecutive mappings, the
	        // first mapping ends where the second one starts).
	        if (index + 1 < this._generatedMappings.length) {
	          var nextMapping = this._generatedMappings[index + 1];
	
	          if (mapping.generatedLine === nextMapping.generatedLine) {
	            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
	            continue;
	          }
	        }
	
	        // The last mapping for each line spans the entire line.
	        mapping.lastGeneratedColumn = Infinity;
	      }
	    };
	
	  /**
	   * Returns the original source, line, and column information for the generated
	   * source's line and column positions provided. The only argument is an object
	   * with the following properties:
	   *
	   *   - line: The line number in the generated source.
	   *   - column: The column number in the generated source.
	   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	   *     closest element that is smaller than or greater than the one we are
	   *     searching for, respectively, if the exact element cannot be found.
	   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - source: The original source file, or null.
	   *   - line: The line number in the original source, or null.
	   *   - column: The column number in the original source, or null.
	   *   - name: The original identifier, or null.
	   */
	  BasicSourceMapConsumer.prototype.originalPositionFor =
	    function SourceMapConsumer_originalPositionFor(aArgs) {
	      var needle = {
	        generatedLine: util.getArg(aArgs, 'line'),
	        generatedColumn: util.getArg(aArgs, 'column')
	      };
	
	      var index = this._findMapping(
	        needle,
	        this._generatedMappings,
	        "generatedLine",
	        "generatedColumn",
	        util.compareByGeneratedPositionsDeflated,
	        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	      );
	
	      if (index >= 0) {
	        var mapping = this._generatedMappings[index];
	
	        if (mapping.generatedLine === needle.generatedLine) {
	          var source = util.getArg(mapping, 'source', null);
	          if (source !== null) {
	            source = this._sources.at(source);
	            if (this.sourceRoot != null) {
	              source = util.join(this.sourceRoot, source);
	            }
	          }
	          var name = util.getArg(mapping, 'name', null);
	          if (name !== null) {
	            name = this._names.at(name);
	          }
	          return {
	            source: source,
	            line: util.getArg(mapping, 'originalLine', null),
	            column: util.getArg(mapping, 'originalColumn', null),
	            name: name
	          };
	        }
	      }
	
	      return {
	        source: null,
	        line: null,
	        column: null,
	        name: null
	      };
	    };
	
	  /**
	   * Return true if we have the source content for every source in the source
	   * map, false otherwise.
	   */
	  BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
	    function BasicSourceMapConsumer_hasContentsOfAllSources() {
	      if (!this.sourcesContent) {
	        return false;
	      }
	      return this.sourcesContent.length >= this._sources.size() &&
	        !this.sourcesContent.some(function (sc) { return sc == null; });
	    };
	
	  /**
	   * Returns the original source content. The only argument is the url of the
	   * original source file. Returns null if no original source content is
	   * availible.
	   */
	  BasicSourceMapConsumer.prototype.sourceContentFor =
	    function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	      if (!this.sourcesContent) {
	        return null;
	      }
	
	      if (this.sourceRoot != null) {
	        aSource = util.relative(this.sourceRoot, aSource);
	      }
	
	      if (this._sources.has(aSource)) {
	        return this.sourcesContent[this._sources.indexOf(aSource)];
	      }
	
	      var url;
	      if (this.sourceRoot != null
	          && (url = util.urlParse(this.sourceRoot))) {
	        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
	        // many users. We can help them out when they expect file:// URIs to
	        // behave like it would if they were running a local HTTP server. See
	        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
	        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
	        if (url.scheme == "file"
	            && this._sources.has(fileUriAbsPath)) {
	          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
	        }
	
	        if ((!url.path || url.path == "/")
	            && this._sources.has("/" + aSource)) {
	          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
	        }
	      }
	
	      // This function is used recursively from
	      // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
	      // don't want to throw if we can't find the source - we just want to
	      // return null, so we provide a flag to exit gracefully.
	      if (nullOnMissing) {
	        return null;
	      }
	      else {
	        throw new Error('"' + aSource + '" is not in the SourceMap.');
	      }
	    };
	
	  /**
	   * Returns the generated line and column information for the original source,
	   * line, and column positions provided. The only argument is an object with
	   * the following properties:
	   *
	   *   - source: The filename of the original source.
	   *   - line: The line number in the original source.
	   *   - column: The column number in the original source.
	   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	   *     closest element that is smaller than or greater than the one we are
	   *     searching for, respectively, if the exact element cannot be found.
	   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - line: The line number in the generated source, or null.
	   *   - column: The column number in the generated source, or null.
	   */
	  BasicSourceMapConsumer.prototype.generatedPositionFor =
	    function SourceMapConsumer_generatedPositionFor(aArgs) {
	      var source = util.getArg(aArgs, 'source');
	      if (this.sourceRoot != null) {
	        source = util.relative(this.sourceRoot, source);
	      }
	      if (!this._sources.has(source)) {
	        return {
	          line: null,
	          column: null,
	          lastColumn: null
	        };
	      }
	      source = this._sources.indexOf(source);
	
	      var needle = {
	        source: source,
	        originalLine: util.getArg(aArgs, 'line'),
	        originalColumn: util.getArg(aArgs, 'column')
	      };
	
	      var index = this._findMapping(
	        needle,
	        this._originalMappings,
	        "originalLine",
	        "originalColumn",
	        util.compareByOriginalPositions,
	        util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	      );
	
	      if (index >= 0) {
	        var mapping = this._originalMappings[index];
	
	        if (mapping.source === needle.source) {
	          return {
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          };
	        }
	      }
	
	      return {
	        line: null,
	        column: null,
	        lastColumn: null
	      };
	    };
	
	  exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
	
	  /**
	   * An IndexedSourceMapConsumer instance represents a parsed source map which
	   * we can query for information. It differs from BasicSourceMapConsumer in
	   * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
	   * input.
	   *
	   * The only parameter is a raw source map (either as a JSON string, or already
	   * parsed to an object). According to the spec for indexed source maps, they
	   * have the following attributes:
	   *
	   *   - version: Which version of the source map spec this map is following.
	   *   - file: Optional. The generated file this source map is associated with.
	   *   - sections: A list of section definitions.
	   *
	   * Each value under the "sections" field has two fields:
	   *   - offset: The offset into the original specified at which this section
	   *       begins to apply, defined as an object with a "line" and "column"
	   *       field.
	   *   - map: A source map definition. This source map could also be indexed,
	   *       but doesn't have to be.
	   *
	   * Instead of the "map" field, it's also possible to have a "url" field
	   * specifying a URL to retrieve a source map from, but that's currently
	   * unsupported.
	   *
	   * Here's an example source map, taken from the source map spec[0], but
	   * modified to omit a section which uses the "url" field.
	   *
	   *  {
	   *    version : 3,
	   *    file: "app.js",
	   *    sections: [{
	   *      offset: {line:100, column:10},
	   *      map: {
	   *        version : 3,
	   *        file: "section.js",
	   *        sources: ["foo.js", "bar.js"],
	   *        names: ["src", "maps", "are", "fun"],
	   *        mappings: "AAAA,E;;ABCDE;"
	   *      }
	   *    }],
	   *  }
	   *
	   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
	   */
	  function IndexedSourceMapConsumer(aSourceMap) {
	    var sourceMap = aSourceMap;
	    if (typeof aSourceMap === 'string') {
	      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	    }
	
	    var version = util.getArg(sourceMap, 'version');
	    var sections = util.getArg(sourceMap, 'sections');
	
	    if (version != this._version) {
	      throw new Error('Unsupported version: ' + version);
	    }
	
	    this._sources = new ArraySet();
	    this._names = new ArraySet();
	
	    var lastOffset = {
	      line: -1,
	      column: 0
	    };
	    this._sections = sections.map(function (s) {
	      if (s.url) {
	        // The url field will require support for asynchronicity.
	        // See https://github.com/mozilla/source-map/issues/16
	        throw new Error('Support for url field in sections not implemented.');
	      }
	      var offset = util.getArg(s, 'offset');
	      var offsetLine = util.getArg(offset, 'line');
	      var offsetColumn = util.getArg(offset, 'column');
	
	      if (offsetLine < lastOffset.line ||
	          (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
	        throw new Error('Section offsets must be ordered and non-overlapping.');
	      }
	      lastOffset = offset;
	
	      return {
	        generatedOffset: {
	          // The offset fields are 0-based, but we use 1-based indices when
	          // encoding/decoding from VLQ.
	          generatedLine: offsetLine + 1,
	          generatedColumn: offsetColumn + 1
	        },
	        consumer: new SourceMapConsumer(util.getArg(s, 'map'))
	      }
	    });
	  }
	
	  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
	
	  /**
	   * The version of the source mapping spec that we are consuming.
	   */
	  IndexedSourceMapConsumer.prototype._version = 3;
	
	  /**
	   * The list of original sources.
	   */
	  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
	    get: function () {
	      var sources = [];
	      for (var i = 0; i < this._sections.length; i++) {
	        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
	          sources.push(this._sections[i].consumer.sources[j]);
	        }
	      };
	      return sources;
	    }
	  });
	
	  /**
	   * Returns the original source, line, and column information for the generated
	   * source's line and column positions provided. The only argument is an object
	   * with the following properties:
	   *
	   *   - line: The line number in the generated source.
	   *   - column: The column number in the generated source.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - source: The original source file, or null.
	   *   - line: The line number in the original source, or null.
	   *   - column: The column number in the original source, or null.
	   *   - name: The original identifier, or null.
	   */
	  IndexedSourceMapConsumer.prototype.originalPositionFor =
	    function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
	      var needle = {
	        generatedLine: util.getArg(aArgs, 'line'),
	        generatedColumn: util.getArg(aArgs, 'column')
	      };
	
	      // Find the section containing the generated position we're trying to map
	      // to an original position.
	      var sectionIndex = binarySearch.search(needle, this._sections,
	        function(needle, section) {
	          var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
	          if (cmp) {
	            return cmp;
	          }
	
	          return (needle.generatedColumn -
	                  section.generatedOffset.generatedColumn);
	        });
	      var section = this._sections[sectionIndex];
	
	      if (!section) {
	        return {
	          source: null,
	          line: null,
	          column: null,
	          name: null
	        };
	      }
	
	      return section.consumer.originalPositionFor({
	        line: needle.generatedLine -
	          (section.generatedOffset.generatedLine - 1),
	        column: needle.generatedColumn -
	          (section.generatedOffset.generatedLine === needle.generatedLine
	           ? section.generatedOffset.generatedColumn - 1
	           : 0),
	        bias: aArgs.bias
	      });
	    };
	
	  /**
	   * Return true if we have the source content for every source in the source
	   * map, false otherwise.
	   */
	  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
	    function IndexedSourceMapConsumer_hasContentsOfAllSources() {
	      return this._sections.every(function (s) {
	        return s.consumer.hasContentsOfAllSources();
	      });
	    };
	
	  /**
	   * Returns the original source content. The only argument is the url of the
	   * original source file. Returns null if no original source content is
	   * available.
	   */
	  IndexedSourceMapConsumer.prototype.sourceContentFor =
	    function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	      for (var i = 0; i < this._sections.length; i++) {
	        var section = this._sections[i];
	
	        var content = section.consumer.sourceContentFor(aSource, true);
	        if (content) {
	          return content;
	        }
	      }
	      if (nullOnMissing) {
	        return null;
	      }
	      else {
	        throw new Error('"' + aSource + '" is not in the SourceMap.');
	      }
	    };
	
	  /**
	   * Returns the generated line and column information for the original source,
	   * line, and column positions provided. The only argument is an object with
	   * the following properties:
	   *
	   *   - source: The filename of the original source.
	   *   - line: The line number in the original source.
	   *   - column: The column number in the original source.
	   *
	   * and an object is returned with the following properties:
	   *
	   *   - line: The line number in the generated source, or null.
	   *   - column: The column number in the generated source, or null.
	   */
	  IndexedSourceMapConsumer.prototype.generatedPositionFor =
	    function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
	      for (var i = 0; i < this._sections.length; i++) {
	        var section = this._sections[i];
	
	        // Only consider this section if the requested source is in the list of
	        // sources of the consumer.
	        if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
	          continue;
	        }
	        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
	        if (generatedPosition) {
	          var ret = {
	            line: generatedPosition.line +
	              (section.generatedOffset.generatedLine - 1),
	            column: generatedPosition.column +
	              (section.generatedOffset.generatedLine === generatedPosition.line
	               ? section.generatedOffset.generatedColumn - 1
	               : 0)
	          };
	          return ret;
	        }
	      }
	
	      return {
	        line: null,
	        column: null
	      };
	    };
	
	  /**
	   * Parse the mappings in a string in to a data structure which we can easily
	   * query (the ordered arrays in the `this.__generatedMappings` and
	   * `this.__originalMappings` properties).
	   */
	  IndexedSourceMapConsumer.prototype._parseMappings =
	    function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	      this.__generatedMappings = [];
	      this.__originalMappings = [];
	      for (var i = 0; i < this._sections.length; i++) {
	        var section = this._sections[i];
	        var sectionMappings = section.consumer._generatedMappings;
	        for (var j = 0; j < sectionMappings.length; j++) {
	          var mapping = sectionMappings[i];
	
	          var source = section.consumer._sources.at(mapping.source);
	          if (section.consumer.sourceRoot !== null) {
	            source = util.join(section.consumer.sourceRoot, source);
	          }
	          this._sources.add(source);
	          source = this._sources.indexOf(source);
	
	          var name = section.consumer._names.at(mapping.name);
	          this._names.add(name);
	          name = this._names.indexOf(name);
	
	          // The mappings coming from the consumer for the section have
	          // generated positions relative to the start of the section, so we
	          // need to offset them to be relative to the start of the concatenated
	          // generated file.
	          var adjustedMapping = {
	            source: source,
	            generatedLine: mapping.generatedLine +
	              (section.generatedOffset.generatedLine - 1),
	            generatedColumn: mapping.column +
	              (section.generatedOffset.generatedLine === mapping.generatedLine)
	              ? section.generatedOffset.generatedColumn - 1
	              : 0,
	            originalLine: mapping.originalLine,
	            originalColumn: mapping.originalColumn,
	            name: name
	          };
	
	          this.__generatedMappings.push(adjustedMapping);
	          if (typeof adjustedMapping.originalLine === 'number') {
	            this.__originalMappings.push(adjustedMapping);
	          }
	        };
	      };
	
	      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
	      quickSort(this.__originalMappings, util.compareByOriginalPositions);
	    };
	
	  exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  exports.GREATEST_LOWER_BOUND = 1;
	  exports.LEAST_UPPER_BOUND = 2;
	
	  /**
	   * Recursive implementation of binary search.
	   *
	   * @param aLow Indices here and lower do not contain the needle.
	   * @param aHigh Indices here and higher do not contain the needle.
	   * @param aNeedle The element being searched for.
	   * @param aHaystack The non-empty array being searched.
	   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
	   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	   *     closest element that is smaller than or greater than the one we are
	   *     searching for, respectively, if the exact element cannot be found.
	   */
	  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
	    // This function terminates when one of the following is true:
	    //
	    //   1. We find the exact element we are looking for.
	    //
	    //   2. We did not find the exact element, but we can return the index of
	    //      the next-closest element.
	    //
	    //   3. We did not find the exact element, and there is no next-closest
	    //      element than the one we are searching for, so we return -1.
	    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
	    var cmp = aCompare(aNeedle, aHaystack[mid], true);
	    if (cmp === 0) {
	      // Found the element we are looking for.
	      return mid;
	    }
	    else if (cmp > 0) {
	      // Our needle is greater than aHaystack[mid].
	      if (aHigh - mid > 1) {
	        // The element is in the upper half.
	        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
	      }
	
	      // The exact needle element was not found in this haystack. Determine if
	      // we are in termination case (3) or (2) and return the appropriate thing.
	      if (aBias == exports.LEAST_UPPER_BOUND) {
	        return aHigh < aHaystack.length ? aHigh : -1;
	      } else {
	        return mid;
	      }
	    }
	    else {
	      // Our needle is less than aHaystack[mid].
	      if (mid - aLow > 1) {
	        // The element is in the lower half.
	        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
	      }
	
	      // we are in termination case (3) or (2) and return the appropriate thing.
	      if (aBias == exports.LEAST_UPPER_BOUND) {
	        return mid;
	      } else {
	        return aLow < 0 ? -1 : aLow;
	      }
	    }
	  }
	
	  /**
	   * This is an implementation of binary search which will always try and return
	   * the index of the closest element if there is no exact hit. This is because
	   * mappings between original and generated line/col pairs are single points,
	   * and there is an implicit region between each of them, so a miss just means
	   * that you aren't on the very start of a region.
	   *
	   * @param aNeedle The element you are looking for.
	   * @param aHaystack The array that is being searched.
	   * @param aCompare A function which takes the needle and an element in the
	   *     array and returns -1, 0, or 1 depending on whether the needle is less
	   *     than, equal to, or greater than the element, respectively.
	   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	   *     closest element that is smaller than or greater than the one we are
	   *     searching for, respectively, if the exact element cannot be found.
	   *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
	   */
	  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
	    if (aHaystack.length === 0) {
	      return -1;
	    }
	
	    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
	                                aCompare, aBias || exports.GREATEST_LOWER_BOUND);
	    if (index < 0) {
	      return -1;
	    }
	
	    // We have found either the exact element, or the next-closest element than
	    // the one we are searching for. However, there may be more than one such
	    // element. Make sure we always return the smallest of these.
	    while (index - 1 >= 0) {
	      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
	        break;
	      }
	      --index;
	    }
	
	    return index;
	  };
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  // It turns out that some (most?) JavaScript engines don't self-host
	  // `Array.prototype.sort`. This makes sense because C++ will likely remain
	  // faster than JS when doing raw CPU-intensive sorting. However, when using a
	  // custom comparator function, calling back and forth between the VM's C++ and
	  // JIT'd JS is rather slow *and* loses JIT type information, resulting in
	  // worse generated code for the comparator function than would be optimal. In
	  // fact, when sorting with a comparator, these costs outweigh the benefits of
	  // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
	  // a ~3500ms mean speed-up in `bench/bench.html`.
	
	  /**
	   * Swap the elements indexed by `x` and `y` in the array `ary`.
	   *
	   * @param {Array} ary
	   *        The array.
	   * @param {Number} x
	   *        The index of the first item.
	   * @param {Number} y
	   *        The index of the second item.
	   */
	  function swap(ary, x, y) {
	    var temp = ary[x];
	    ary[x] = ary[y];
	    ary[y] = temp;
	  }
	
	  /**
	   * Returns a random integer within the range `low .. high` inclusive.
	   *
	   * @param {Number} low
	   *        The lower bound on the range.
	   * @param {Number} high
	   *        The upper bound on the range.
	   */
	  function randomIntInRange(low, high) {
	    return Math.round(low + (Math.random() * (high - low)));
	  }
	
	  /**
	   * The Quick Sort algorithm.
	   *
	   * @param {Array} ary
	   *        An array to sort.
	   * @param {function} comparator
	   *        Function to use to compare two items.
	   * @param {Number} p
	   *        Start index of the array
	   * @param {Number} r
	   *        End index of the array
	   */
	  function doQuickSort(ary, comparator, p, r) {
	    // If our lower bound is less than our upper bound, we (1) partition the
	    // array into two pieces and (2) recurse on each half. If it is not, this is
	    // the empty array and our base case.
	
	    if (p < r) {
	      // (1) Partitioning.
	      //
	      // The partitioning chooses a pivot between `p` and `r` and moves all
	      // elements that are less than or equal to the pivot to the before it, and
	      // all the elements that are greater than it after it. The effect is that
	      // once partition is done, the pivot is in the exact place it will be when
	      // the array is put in sorted order, and it will not need to be moved
	      // again. This runs in O(n) time.
	
	      // Always choose a random pivot so that an input array which is reverse
	      // sorted does not cause O(n^2) running time.
	      var pivotIndex = randomIntInRange(p, r);
	      var i = p - 1;
	
	      swap(ary, pivotIndex, r);
	      var pivot = ary[r];
	
	      // Immediately after `j` is incremented in this loop, the following hold
	      // true:
	      //
	      //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
	      //
	      //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
	      for (var j = p; j < r; j++) {
	        if (comparator(ary[j], pivot) <= 0) {
	          i += 1;
	          swap(ary, i, j);
	        }
	      }
	
	      swap(ary, i + 1, j);
	      var q = i + 1;
	
	      // (2) Recurse on each half.
	
	      doQuickSort(ary, comparator, p, q - 1);
	      doQuickSort(ary, comparator, q + 1, r);
	    }
	  }
	
	  /**
	   * Sort the given array in-place with the given comparator function.
	   *
	   * @param {Array} ary
	   *        An array to sort.
	   * @param {function} comparator
	   *        Function to use to compare two items.
	   */
	  exports.quickSort = function (ary, comparator) {
	    doQuickSort(ary, comparator, 0, ary.length - 1);
	  };
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	if (false) {
	    var define = require('amdefine')(module, require);
	}
	!(__WEBPACK_AMD_DEFINE_RESULT__ = function (require, exports, module) {
	
	  var SourceMapGenerator = __webpack_require__(21).SourceMapGenerator;
	  var util = __webpack_require__(24);
	
	  // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
	  // operating systems these days (capturing the result).
	  var REGEX_NEWLINE = /(\r?\n)/;
	
	  // Newline character code for charCodeAt() comparisons
	  var NEWLINE_CODE = 10;
	
	  // Private symbol for identifying `SourceNode`s when multiple versions of
	  // the source-map library are loaded. This MUST NOT CHANGE across
	  // versions!
	  var isSourceNode = "$$$isSourceNode$$$";
	
	  /**
	   * SourceNodes provide a way to abstract over interpolating/concatenating
	   * snippets of generated JavaScript source code while maintaining the line and
	   * column information associated with the original source code.
	   *
	   * @param aLine The original line number.
	   * @param aColumn The original column number.
	   * @param aSource The original source's filename.
	   * @param aChunks Optional. An array of strings which are snippets of
	   *        generated JS, or other SourceNodes.
	   * @param aName The original identifier.
	   */
	  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
	    this.children = [];
	    this.sourceContents = {};
	    this.line = aLine == null ? null : aLine;
	    this.column = aColumn == null ? null : aColumn;
	    this.source = aSource == null ? null : aSource;
	    this.name = aName == null ? null : aName;
	    this[isSourceNode] = true;
	    if (aChunks != null) this.add(aChunks);
	  }
	
	  /**
	   * Creates a SourceNode from generated code and a SourceMapConsumer.
	   *
	   * @param aGeneratedCode The generated code
	   * @param aSourceMapConsumer The SourceMap for the generated code
	   * @param aRelativePath Optional. The path that relative sources in the
	   *        SourceMapConsumer should be relative to.
	   */
	  SourceNode.fromStringWithSourceMap =
	    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
	      // The SourceNode we want to fill with the generated code
	      // and the SourceMap
	      var node = new SourceNode();
	
	      // All even indices of this array are one line of the generated code,
	      // while all odd indices are the newlines between two adjacent lines
	      // (since `REGEX_NEWLINE` captures its match).
	      // Processed fragments are removed from this array, by calling `shiftNextLine`.
	      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
	      var shiftNextLine = function() {
	        var lineContents = remainingLines.shift();
	        // The last line of a file might not have a newline.
	        var newLine = remainingLines.shift() || "";
	        return lineContents + newLine;
	      };
	
	      // We need to remember the position of "remainingLines"
	      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
	
	      // The generate SourceNodes we need a code range.
	      // To extract it current and last mapping is used.
	      // Here we store the last mapping.
	      var lastMapping = null;
	
	      aSourceMapConsumer.eachMapping(function (mapping) {
	        if (lastMapping !== null) {
	          // We add the code from "lastMapping" to "mapping":
	          // First check if there is a new line in between.
	          if (lastGeneratedLine < mapping.generatedLine) {
	            var code = "";
	            // Associate first line with "lastMapping"
	            addMappingWithCode(lastMapping, shiftNextLine());
	            lastGeneratedLine++;
	            lastGeneratedColumn = 0;
	            // The remaining code is added without mapping
	          } else {
	            // There is no new line in between.
	            // Associate the code between "lastGeneratedColumn" and
	            // "mapping.generatedColumn" with "lastMapping"
	            var nextLine = remainingLines[0];
	            var code = nextLine.substr(0, mapping.generatedColumn -
	                                          lastGeneratedColumn);
	            remainingLines[0] = nextLine.substr(mapping.generatedColumn -
	                                                lastGeneratedColumn);
	            lastGeneratedColumn = mapping.generatedColumn;
	            addMappingWithCode(lastMapping, code);
	            // No more remaining code, continue
	            lastMapping = mapping;
	            return;
	          }
	        }
	        // We add the generated code until the first mapping
	        // to the SourceNode without any mapping.
	        // Each line is added as separate string.
	        while (lastGeneratedLine < mapping.generatedLine) {
	          node.add(shiftNextLine());
	          lastGeneratedLine++;
	        }
	        if (lastGeneratedColumn < mapping.generatedColumn) {
	          var nextLine = remainingLines[0];
	          node.add(nextLine.substr(0, mapping.generatedColumn));
	          remainingLines[0] = nextLine.substr(mapping.generatedColumn);
	          lastGeneratedColumn = mapping.generatedColumn;
	        }
	        lastMapping = mapping;
	      }, this);
	      // We have processed all mappings.
	      if (remainingLines.length > 0) {
	        if (lastMapping) {
	          // Associate the remaining code in the current line with "lastMapping"
	          addMappingWithCode(lastMapping, shiftNextLine());
	        }
	        // and add the remaining lines without any mapping
	        node.add(remainingLines.join(""));
	      }
	
	      // Copy sourcesContent into SourceNode
	      aSourceMapConsumer.sources.forEach(function (sourceFile) {
	        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	        if (content != null) {
	          if (aRelativePath != null) {
	            sourceFile = util.join(aRelativePath, sourceFile);
	          }
	          node.setSourceContent(sourceFile, content);
	        }
	      });
	
	      return node;
	
	      function addMappingWithCode(mapping, code) {
	        if (mapping === null || mapping.source === undefined) {
	          node.add(code);
	        } else {
	          var source = aRelativePath
	            ? util.join(aRelativePath, mapping.source)
	            : mapping.source;
	          node.add(new SourceNode(mapping.originalLine,
	                                  mapping.originalColumn,
	                                  source,
	                                  code,
	                                  mapping.name));
	        }
	      }
	    };
	
	  /**
	   * Add a chunk of generated JS to this source node.
	   *
	   * @param aChunk A string snippet of generated JS code, another instance of
	   *        SourceNode, or an array where each member is one of those things.
	   */
	  SourceNode.prototype.add = function SourceNode_add(aChunk) {
	    if (Array.isArray(aChunk)) {
	      aChunk.forEach(function (chunk) {
	        this.add(chunk);
	      }, this);
	    }
	    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	      if (aChunk) {
	        this.children.push(aChunk);
	      }
	    }
	    else {
	      throw new TypeError(
	        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	      );
	    }
	    return this;
	  };
	
	  /**
	   * Add a chunk of generated JS to the beginning of this source node.
	   *
	   * @param aChunk A string snippet of generated JS code, another instance of
	   *        SourceNode, or an array where each member is one of those things.
	   */
	  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
	    if (Array.isArray(aChunk)) {
	      for (var i = aChunk.length-1; i >= 0; i--) {
	        this.prepend(aChunk[i]);
	      }
	    }
	    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	      this.children.unshift(aChunk);
	    }
	    else {
	      throw new TypeError(
	        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	      );
	    }
	    return this;
	  };
	
	  /**
	   * Walk over the tree of JS snippets in this node and its children. The
	   * walking function is called once for each snippet of JS and is passed that
	   * snippet and the its original associated source's line/column location.
	   *
	   * @param aFn The traversal function.
	   */
	  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
	    var chunk;
	    for (var i = 0, len = this.children.length; i < len; i++) {
	      chunk = this.children[i];
	      if (chunk[isSourceNode]) {
	        chunk.walk(aFn);
	      }
	      else {
	        if (chunk !== '') {
	          aFn(chunk, { source: this.source,
	                       line: this.line,
	                       column: this.column,
	                       name: this.name });
	        }
	      }
	    }
	  };
	
	  /**
	   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
	   * each of `this.children`.
	   *
	   * @param aSep The separator.
	   */
	  SourceNode.prototype.join = function SourceNode_join(aSep) {
	    var newChildren;
	    var i;
	    var len = this.children.length;
	    if (len > 0) {
	      newChildren = [];
	      for (i = 0; i < len-1; i++) {
	        newChildren.push(this.children[i]);
	        newChildren.push(aSep);
	      }
	      newChildren.push(this.children[i]);
	      this.children = newChildren;
	    }
	    return this;
	  };
	
	  /**
	   * Call String.prototype.replace on the very right-most source snippet. Useful
	   * for trimming whitespace from the end of a source node, etc.
	   *
	   * @param aPattern The pattern to replace.
	   * @param aReplacement The thing to replace the pattern with.
	   */
	  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
	    var lastChild = this.children[this.children.length - 1];
	    if (lastChild[isSourceNode]) {
	      lastChild.replaceRight(aPattern, aReplacement);
	    }
	    else if (typeof lastChild === 'string') {
	      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
	    }
	    else {
	      this.children.push(''.replace(aPattern, aReplacement));
	    }
	    return this;
	  };
	
	  /**
	   * Set the source content for a source file. This will be added to the SourceMapGenerator
	   * in the sourcesContent field.
	   *
	   * @param aSourceFile The filename of the source file
	   * @param aSourceContent The content of the source file
	   */
	  SourceNode.prototype.setSourceContent =
	    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
	      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	    };
	
	  /**
	   * Walk over the tree of SourceNodes. The walking function is called for each
	   * source file content and is passed the filename and source content.
	   *
	   * @param aFn The traversal function.
	   */
	  SourceNode.prototype.walkSourceContents =
	    function SourceNode_walkSourceContents(aFn) {
	      for (var i = 0, len = this.children.length; i < len; i++) {
	        if (this.children[i][isSourceNode]) {
	          this.children[i].walkSourceContents(aFn);
	        }
	      }
	
	      var sources = Object.keys(this.sourceContents);
	      for (var i = 0, len = sources.length; i < len; i++) {
	        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
	      }
	    };
	
	  /**
	   * Return the string representation of this source node. Walks over the tree
	   * and concatenates all the various snippets together to one string.
	   */
	  SourceNode.prototype.toString = function SourceNode_toString() {
	    var str = "";
	    this.walk(function (chunk) {
	      str += chunk;
	    });
	    return str;
	  };
	
	  /**
	   * Returns the string representation of this source node along with a source
	   * map.
	   */
	  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
	    var generated = {
	      code: "",
	      line: 1,
	      column: 0
	    };
	    var map = new SourceMapGenerator(aArgs);
	    var sourceMappingActive = false;
	    var lastOriginalSource = null;
	    var lastOriginalLine = null;
	    var lastOriginalColumn = null;
	    var lastOriginalName = null;
	    this.walk(function (chunk, original) {
	      generated.code += chunk;
	      if (original.source !== null
	          && original.line !== null
	          && original.column !== null) {
	        if(lastOriginalSource !== original.source
	           || lastOriginalLine !== original.line
	           || lastOriginalColumn !== original.column
	           || lastOriginalName !== original.name) {
	          map.addMapping({
	            source: original.source,
	            original: {
	              line: original.line,
	              column: original.column
	            },
	            generated: {
	              line: generated.line,
	              column: generated.column
	            },
	            name: original.name
	          });
	        }
	        lastOriginalSource = original.source;
	        lastOriginalLine = original.line;
	        lastOriginalColumn = original.column;
	        lastOriginalName = original.name;
	        sourceMappingActive = true;
	      } else if (sourceMappingActive) {
	        map.addMapping({
	          generated: {
	            line: generated.line,
	            column: generated.column
	          }
	        });
	        lastOriginalSource = null;
	        sourceMappingActive = false;
	      }
	      for (var idx = 0, length = chunk.length; idx < length; idx++) {
	        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
	          generated.line++;
	          generated.column = 0;
	          // Mappings end at eol
	          if (idx + 1 === length) {
	            lastOriginalSource = null;
	            sourceMappingActive = false;
	          } else if (sourceMappingActive) {
	            map.addMapping({
	              source: original.source,
	              original: {
	                line: original.line,
	                column: original.column
	              },
	              generated: {
	                line: generated.line,
	                column: generated.column
	              },
	              name: original.name
	            });
	          }
	        } else {
	          generated.column++;
	        }
	      }
	    });
	    this.walkSourceContents(function (sourceFile, sourceContent) {
	      map.setSourceContent(sourceFile, sourceContent);
	    });
	
	    return { code: generated.code, map: map };
	  };
	
	  exports.SourceNode = SourceNode;
	
	}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	exports.SourceListMap = __webpack_require__(32);
	exports.SourceNode = __webpack_require__(35);
	exports.CodeNode = __webpack_require__(33);
	exports.MappingsContext = __webpack_require__(37);
	exports.fromStringWithSourceMap = __webpack_require__(38);


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var CodeNode = __webpack_require__(33);
	var SourceNode = __webpack_require__(35);
	var MappingsContext = __webpack_require__(37);
	
	function SourceListMap(generatedCode, source, originalSource) {
		if(Array.isArray(generatedCode)) {
			this.children = generatedCode;
		} else {
			this.children = [];
			if(generatedCode || source)
				this.add(generatedCode, source, originalSource);
		}
	}
	module.exports = SourceListMap;
	
	SourceListMap.prototype.add = function(generatedCode, source, originalSource) {
		if(typeof generatedCode === "string") {
			if(source) {
				this.children.push(new SourceNode(generatedCode, source, originalSource));
			} else if(this.children.length > 0 && this.children[this.children.length - 1].addGeneratedCode) {
				this.children[this.children.length - 1].addGeneratedCode(generatedCode);
			} else {
				this.children.push(new CodeNode(generatedCode));
			}
		} else if(generatedCode.getMappings && generatedCode.getGeneratedCode) {
			this.children.push(generatedCode);
		} else if(generatedCode.children) {
			generatedCode.children.forEach(function(sln) {
				this.children.push(sln);
			}, this);
		} else {
			throw new Error("Invalid arguments to SourceListMap.prototype.add: Expected string, Node or SourceListMap");
		}
	};
	
	SourceListMap.prototype.preprend = function(source) {
		if(typeof generatedCode === "string") {
			if(source) {
				this.children.unshift(new SourceNode(generatedCode, source, originalSource));
			} else if(this.children.length > 0 && this.children[this.children.length - 1].preprendGeneratedCode) {
				this.children[this.children.length - 1].preprendGeneratedCode(generatedCode);
			} else {
				this.children.unshift(new CodeNode(generatedCode));
			}
		} else if(generatedCode.getMappings && generatedCode.getGeneratedCode) {
			this.children.unshift(generatedCode);
		} else if(generatedCode.children) {
			generatedCode.children.slice().reverse().forEach(function(sln) {
				this.children.unshift(sln);
			}, this);
		} else {
			throw new Error("Invalid arguments to SourceListMap.prototype.prerend: Expected string, Node or SourceListMap");
		}
	};
	
	SourceListMap.prototype.mapGeneratedCode = function(fn) {
		this.children.forEach(function(sln) {
			sln.mapGeneratedCode(fn);
		});
	};
	
	SourceListMap.prototype.toString = function() {
		return this.children.map(function(sln) {
			return sln.getGeneratedCode();
		}).join("");
	};
	
	SourceListMap.prototype.toStringWithSourceMap = function(options) {
		var mappingsContext = new MappingsContext();
		var source = this.children.map(function(sln) {
			return sln.generatedCode;
		}).join("");
		var mappings = this.children.map(function(sln) {
			return sln.getMappings(mappingsContext);
		}).join("");
		return {
			source: source,
			map: {
				version: 3,
				file: options && options.file,
				sources: mappingsContext.sources,
				sourcesContent: mappingsContext.hasSourceContent ? mappingsContext.sourcesContent : undefined,
				mappings: mappings
			}
		};
	}


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var getNumberOfLines = __webpack_require__(34).getNumberOfLines;
	
	function CodeNode(generatedCode) {
		this.generatedCode = generatedCode;
	}
	module.exports = CodeNode;
	
	CodeNode.prototype.clone = function() {
		return new CodeNode(this.generatedCode);
	}
	
	CodeNode.prototype.getGeneratedCode = function() {
		return this.generatedCode;
	};
	
	CodeNode.prototype.getMappings = function(mappingsContext) {
		var lines = getNumberOfLines(this.generatedCode);
		return Array(lines+1).join(";");
	};
	
	CodeNode.prototype.addGeneratedCode = function(generatedCode) {
		this.generatedCode += generatedCode;
	};
	
	CodeNode.prototype.mapGeneratedCode = function(fn) {
		this.generatedCode = fn(this.generatedCode);
	};


/***/ },
/* 34 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	exports.getNumberOfLines = function getNumberOfLines(str) {
		var nr = -1;
		var idx = -1;
		do {
			nr++
			idx = str.indexOf("\n", idx + 1);
		} while(idx >= 0);
		return nr;
	};


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var base64VLQ = __webpack_require__(36);
	var getNumberOfLines = __webpack_require__(34).getNumberOfLines;
	
	function SourceNode(generatedCode, source, originalSource, startingLine) {
		this.generatedCode = generatedCode;
		this.originalSource = originalSource;
		this.source = source;
		this.startingLine = startingLine || 1;
	}
	module.exports = SourceNode;
	
	SourceNode.prototype.clone = function() {
		return new SourceNode(this.generatedCode, this.source, this.originalSource, this.startingLine);
	}
	
	var LINE_MAPPING = "AACA;";
	var LAST_LINE_MAPPING = "AACA";
	
	SourceNode.prototype.getGeneratedCode = function() {
		return this.generatedCode;
	};
	
	SourceNode.prototype.getMappings = function(mappingsContext) {
		var lines = getNumberOfLines(this.generatedCode);
		var sourceIdx = mappingsContext.ensureSource(this.source, this.originalSource);
		var mappings = "A"; // generated column 0
		mappings += base64VLQ.encode(sourceIdx - mappingsContext.currentSource); // source index
		mappings += base64VLQ.encode(this.startingLine - mappingsContext.currentOriginalLine); // original line index
		mappings += "A"; // original column 0
		if(lines !== 0)
			mappings += ";"
		mappingsContext.currentSource = sourceIdx;
		mappingsContext.currentOriginalLine = (lines || 1) + this.startingLine - 1;
		mappings += Array(lines).join(LINE_MAPPING);
		if(lines !== 0 && this.generatedCode[this.generatedCode.length - 1] !== "\n") {
			mappings += LAST_LINE_MAPPING;
			mappingsContext.currentOriginalLine++;
		}
		return mappings;
	};
	
	SourceNode.prototype.mapGeneratedCode = function(fn) {
		this.generatedCode = fn(this.generatedCode);
	};


/***/ },
/* 36 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
	
	/*eslint no-bitwise:0,quotes:0,global-strict:0*/
	
	var charToIntMap = {};
	var intToCharMap = {};
	
	'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	  .split('')
	  .forEach(function (ch, index) {
	    charToIntMap[ch] = index;
	    intToCharMap[index] = ch;
	  });
	
	var base64 = {};
	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	base64.encode = function base64_encode(aNumber) {
	  if (aNumber in intToCharMap) {
	    return intToCharMap[aNumber];
	  }
	  throw new TypeError("Must be between 0 and 63: " + aNumber);
	};
	
	/**
	 * Decode a single base 64 digit to an integer.
	 */
	base64.decode = function base64_decode(aChar) {
	  if (aChar in charToIntMap) {
	    return charToIntMap[aChar];
	  }
	  throw new TypeError("Not a valid base 64 digit: " + aChar);
	};
	
	
	
	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011
	
	var VLQ_BASE_SHIFT = 5;
	
	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
	
	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;
	
	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;
	
	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}
	
	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}
	
	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	exports.encode = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;
	
	  var vlq = toVLQSigned(aValue);
	
	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);
	
	  return encoded;
	};
	
	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	exports.decode = function base64VLQ_decode(aStr, aOutParam) {
	  var i = 0;
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;
	
	  do {
	    if (i >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }
	    digit = base64.decode(aStr.charAt(i++));
	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);
	
	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aStr.slice(i);
	};


/***/ },
/* 37 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function MappingsContext() {
		this.sources = [];
		this.sourcesContent = [];
		this.hasSourceContent = false;
		this.currentOriginalLine = 1;
		this.currentSource = 0;
	}
	module.exports = MappingsContext;
	
	MappingsContext.prototype.ensureSource = function(source, originalSource) {
		var idx = this.sources.indexOf(source);
		if(idx >= 0)
			return idx;
		idx = this.sources.length;
		this.sources.push(source);
		this.sourcesContent.push(originalSource);
		if(typeof originalSource === "string")
			this.hasSourceContent = true;
		return idx;
	};


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var base64VLQ = __webpack_require__(36);
	var SourceNode = __webpack_require__(35);
	var CodeNode = __webpack_require__(33);
	var SourceListMap = __webpack_require__(32);
	
	module.exports = function fromStringWithSourceMap(code, map) {
		var sources = map.sources;
		var sourcesContent = map.sourcesContent;
		var mappings = map.mappings.split(";");
		var lines = code.split("\n");
		var nodes = [];
		var currentNode = null;
		var currentLine = 1;
		var currentSourceIdx = 0;
		var currentSourceNodeLine;
		mappings.forEach(function(mapping, idx) {
			var line = lines[idx];
			if(typeof line === 'undefined') return;
			if(idx !== lines.length - 1) line += "\n";
			if(!mapping)
				return addCode(line);
			mapping = { value: 0, rest: mapping };
			var lineAdded = false;
			while(mapping.rest)
				lineAdded = processMapping(mapping, line, lineAdded) || lineAdded;
			if(!lineAdded)
				addCode(line);
		});
		if(mappings.length < lines.length) {
			var idx = mappings.length;
			while(!lines[idx].trim() && idx < lines.length-1) {
				addCode(lines[idx] + "\n");
				idx++;
			}
			addCode(lines.slice(idx).join("\n"));
		}
		return new SourceListMap(nodes);
		function processMapping(mapping, line, ignore) {
			if(mapping.rest && mapping.rest[0] !== ",") {
				base64VLQ.decode(mapping.rest, mapping);
			}
			if(!mapping.rest)
				return false;
			if(mapping.rest[0] === ",") {
				mapping.rest = mapping.rest.substr(1);
				return false;
			}
	
			base64VLQ.decode(mapping.rest, mapping);
			var sourceIdx = mapping.value + currentSourceIdx;
			currentSourceIdx = sourceIdx;
	
			if(mapping.rest && mapping.rest[0] !== ",") {
				base64VLQ.decode(mapping.rest, mapping);
				var linePosition = mapping.value + currentLine;
				currentLine = linePosition;
			} else {
				var linePosition = currentLine;
			}
	
			if(mapping.rest) {
				var next = mapping.rest.indexOf(",");
				mapping.rest = next === -1 ? "" : mapping.rest.substr(next);
			}
	
			if(!ignore) {
				addSource(line, sources ? sources[sourceIdx] : null, sourcesContent ? sourcesContent[sourceIdx] : null, linePosition)
				return true;
			}
		}
		function addCode(generatedCode) {
			if(currentNode && currentNode instanceof CodeNode) {
				currentNode.addGeneratedCode(generatedCode);
			} else if(currentNode && currentNode instanceof SourceNode && !generatedCode.trim()) {
				currentNode.generatedCode += generatedCode;
				currentSourceNodeLine++;
			} else {
				currentNode = new CodeNode(generatedCode);
				nodes.push(currentNode);
			}
		}
		function addSource(generatedCode, source, originalSource, linePosition) {
			if(currentNode && currentNode instanceof SourceNode &&
				currentNode.source === source &&
				currentSourceNodeLine === linePosition
			) {
				currentNode.generatedCode += generatedCode;
				currentSourceNodeLine++;
			} else {
				currentNode = new SourceNode(generatedCode, source, originalSource, linePosition);
				currentSourceNodeLine = linePosition + 1;
				nodes.push(currentNode);
			}
		}
	};


/***/ },
/* 39 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function mixinSourceAndMap(proto) {
		proto.map = function(options) {
			options = options || {};
			if(options.columns === false) {
				return this.listMap(options).toStringWithSourceMap().map;
			}
	
			return this.node(options).toStringWithSourceMap({file:"x"}).map.toJSON();
		};
	
		proto.sourceAndMap = function(options) {
			options = options || {};
			if(options.columns === false) {
				//console.log(this.listMap(options).debugInfo());
				return this.listMap(options).toStringWithSourceMap();
			}
	
			var res = this.node(options).toStringWithSourceMap({file:"x"});
			return {
				source: res.code,
				map: res.map.toJSON()
			};
		};
	}


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Source = __webpack_require__(19);
	var SourceNode = __webpack_require__(20).SourceNode;
	var SourceListMap = __webpack_require__(31).SourceListMap;
	
	function RawSource(value) {
		Source.call(this);
		this._value = value;
	}
	module.exports = RawSource;
	
	RawSource.prototype = Object.create(Source.prototype);
	RawSource.prototype.constructor = RawSource;
	
	RawSource.prototype.source = function() {
		return this._value;
	};
	
	RawSource.prototype.map = function(options) {
		return null;
	};
	
	RawSource.prototype.node = function(options) {
		return new SourceNode(null, null, null, this._value);
	};
	
	RawSource.prototype.listMap = function(options) {
		return new SourceListMap(this._value);
	};
	
	RawSource.prototype.updateHash = function(hash) {
		hash.update(this._value);
	};


/***/ },
/* 41 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function ModuleReason(module, dependency) {
		this.module = module;
		this.dependency = dependency;
	}
	module.exports = ModuleReason;


/***/ },
/* 42 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function removeAndDo(collection, thing, action) {
		var idx = this[collection].indexOf(thing);
		if(idx >= 0) {
			this[collection].splice(idx, 1);
			thing[action](this);
			return true;
		}
		return false;
	};


/***/ },
/* 43 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function ArrayMap() {
		this.keys = [];
		this.values = [];
	}
	module.exports = ArrayMap;
	
	ArrayMap.prototype.get = function(key) {
		for(var i = 0; i < this.keys.length; i++) {
			if(this.keys[i] === key) {
				return this.values[i];
			}
		}
		return;
	};
	
	ArrayMap.prototype.set = function(key, value) {
		for(var i = 0; i < this.keys.length; i++) {
			if(this.keys[i] === key) {
				this.values[i] = value;
				return this;
			}
		}
		this.keys.push(key);
		this.values.push(value);
		return this;
	};
	
	ArrayMap.prototype.remove = function(key) {
		for(var i = 0; i < this.keys.length; i++) {
			if(this.keys[i] === key) {
				this.keys.splice(i, 1);
				this.values.splice(i, 1);
				return true;
			}
		}
		return false;
	};
	
	ArrayMap.prototype.clone = function() {
		var newMap = new ArrayMap();
		for(var i = 0; i < this.keys.length; i++) {
			newMap.keys.push(this.keys[i]);
			newMap.values.push(this.values[i]);
		}
		return newMap;
	};


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function Chunk(name, module, loc) {
		this.id = null;
		this.ids = null;
		this.name = name;
		this.modules = [];
		this.chunks = [];
		this.parents = [];
		this.blocks = [];
		this.origins = [];
		this.files = [];
		this.rendered = false;
		this.entry = false;
		this.initial = false;
		if(module) {
			this.origins.push({
				module: module,
				loc: loc,
				name: name
			});
		}
	}
	module.exports = Chunk;
	
	Chunk.prototype.addModule = function(module) {
		if(this.modules.indexOf(module) >= 0) {
			return false;
		}
		this.modules.push(module);
		return true;
	};
	
	Chunk.prototype._removeAndDo = __webpack_require__(42);
	
	Chunk.prototype.removeModule = function(module) {
		this._removeAndDo("modules", module, "removeChunk");
	};
	
	Chunk.prototype.removeChunk = function(chunk) {
		this._removeAndDo("chunks", chunk, "removeParent");
	};
	
	Chunk.prototype.removeParent = function(chunk) {
		this._removeAndDo("parents", chunk, "removeChunk");
	};
	
	function createAdder(collection) {
		return function(chunk) {
			if(chunk === this) {
				return false;
			}
			if(this[collection].indexOf(chunk) >= 0) {
				return false;
			}
			this[collection].push(chunk);
			return true;
		};
	}
	
	Chunk.prototype.addChunk = createAdder("chunks");
	
	Chunk.prototype.addParent = createAdder("parents");
	
	Chunk.prototype.addBlock = function(block) {
		if(this.blocks.indexOf(block) >= 0) {
			return false;
		}
		this.blocks.push(block);
		return true;
	};
	
	Chunk.prototype.addOrigin = function(module, loc) {
		this.origins.push({
			module: module,
			loc: loc,
			name: this.name
		});
	};
	
	Chunk.prototype.remove = function(reason) {
		this.modules.slice().forEach(function(m) {
			m.removeChunk(this);
		}, this);
		this.parents.forEach(function(c) {
			var idx = c.chunks.indexOf(this);
			if(idx >= 0) {
				c.chunks.splice(idx, 1);
			}
			this.chunks.forEach(function(cc) {
				cc.addParent(c);
			});
		}, this);
		this.chunks.forEach(function(c) {
			var idx = c.parents.indexOf(this);
			if(idx >= 0) {
				c.parents.splice(idx, 1);
			}
			this.parents.forEach(function(cc) {
				cc.addChunk(c);
			});
		}, this);
		this.blocks.forEach(function(b) {
			var idx = b.chunks.indexOf(this);
			if(idx >= 0) {
				b.chunks.splice(idx, 1);
				if(b.chunks.length === 0) {
					b.chunks = null;
					b.chunkReason = reason;
				}
			}
		}, this);
	};
	
	Chunk.prototype.integrate = function(other, reason) {
		if(!this.canBeIntegrated(other)) {
			return false;
		}
	
		var otherModules = other.modules.slice();
		otherModules.forEach(function(m) {
			m.removeChunk(other);
			m.addChunk(this);
			this.addModule(m);
			m.rewriteChunkInReasons(other, [this]);
		}, this);
		other.modules.length = 0;
	
		function moveChunks(chunks, kind, onChunk) {
			chunks.forEach(function(c) {
				var idx = c[kind].indexOf(other);
				if(idx >= 0) {
					c[kind].splice(idx, 1);
				}
				onChunk(c);
			});
		}
		moveChunks(other.parents, "chunks", function(c) {
			if(c !== this && this.addParent(c)) {
				c.addChunk(this);
			}
		}.bind(this));
		other.parents.length = 0;
		moveChunks(other.chunks, "parents", function(c) {
			if(c !== this && this.addChunk(c)) {
				c.addParent(this);
			}
		}.bind(this));
		other.chunks.length = 0;
		other.blocks.forEach(function(b) {
			b.chunks = (b.chunks || [this]).map(function(c) {
				return c === other ? this : c;
			}, this);
			b.chunkReason = reason;
			this.addBlock(b);
		}, this);
		other.blocks.length = 0;
		other.origins.forEach(function(origin) {
			if(!origin.reasons) {
				origin.reasons = [reason];
			} else if(origin.reasons[0] !== reason) {
				origin.reasons.unshift(reason);
			}
			this.origins.push(origin);
		}, this);
		return true;
	};
	
	Chunk.prototype.isEmpty = function() {
		return this.modules.length === 0;
	};
	
	Chunk.prototype.updateHash = function(hash) {
		hash.update(this.id + " ");
		hash.update(this.ids ? this.ids.join(",") : "");
		hash.update(this.name + "");
		this.modules.forEach(function(m) {
			m.updateHash(hash);
		});
	};
	
	Chunk.prototype.size = function(options) {
		var CHUNK_OVERHEAD = options.chunkOverhead || 10000;
		var ENTRY_CHUNK_MULTIPLICATOR = options.entryChunkMultiplicator || 10;
	
		var modulesSize = this.modules.reduce(function(a, b) {
			return a + b.size();
		}, 0);
		return modulesSize * (this.initial ? ENTRY_CHUNK_MULTIPLICATOR : 1) + CHUNK_OVERHEAD;
	};
	
	Chunk.prototype.canBeIntegrated = function(other) {
		if(other.initial) {
			return false;
		}
		if(this.initial) {
			if(other.parents.length !== 1 || other.parents[0] !== this) {
				return false;
			}
		}
		return true;
	};
	
	Chunk.prototype.integratedSize = function(other, options) {
		// Chunk if it's possible to integrate this chunk
		if(!this.canBeIntegrated(other)) {
			return false;
		}
	
		var CHUNK_OVERHEAD = options.chunkOverhead || 10000;
		var ENTRY_CHUNK_MULTIPLICATOR = options.entryChunkMultiplicator || 10;
	
		var mergedModules = this.modules.slice();
		other.modules.forEach(function(m) {
			if(this.modules.indexOf(m) < 0) {
				mergedModules.push(m);
			}
		}, this);
	
		var modulesSize = mergedModules.map(function(m) {
			return m.size();
		}).reduce(function(a, b) {
			return a + b;
		}, 0);
		return modulesSize * (this.initial || other.initial ? ENTRY_CHUNK_MULTIPLICATOR : 1) + CHUNK_OVERHEAD;
	};
	
	Chunk.prototype.getChunkMaps = function(includeEntries, realHash) {
		var chunksProcessed = [];
		var chunkHashMap = {};
		var chunkNameMap = {};
		(function addChunk(c) {
			if(chunksProcessed.indexOf(c) >= 0) return;
			chunksProcessed.push(c);
			if(!c.entry || includeEntries) {
				chunkHashMap[c.id] = realHash ? c.hash : c.renderedHash;
				if(c.name)
					chunkNameMap[c.id] = c.name;
			}
			c.chunks.forEach(addChunk);
		}(this));
		return {
			hash: chunkHashMap,
			name: chunkNameMap
		};
	};
	
	Chunk.prototype.toString = function() {
		return "Chunk[" + this.modules.join() + "]";
	};


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var RequestShortener = __webpack_require__(46);
	
	function Stats(compilation) {
		this.compilation = compilation;
		this.hash = compilation.hash;
	}
	module.exports = Stats;
	
	Stats.prototype.hasWarnings = function() {
		return this.compilation.warnings.length > 0;
	};
	
	Stats.prototype.hasErrors = function() {
		return this.compilation.errors.length > 0;
	};
	
	Stats.prototype.toJson = function toJson(options, forToString) {
		if(typeof options === "boolean" || typeof options === "string") {
			options = Stats.presetToOptions(options);
		} else if(!options) {
			options = {};
		}
	
		function d(v, def) {
			return v === undefined ? def : v;
		}
		var compilation = this.compilation;
		var requestShortener = new RequestShortener(d(options.context, process.cwd()));
		var showHash = d(options.hash, true);
		var showVersion = d(options.version, true);
		var showTimings = d(options.timings, true);
		var showAssets = d(options.assets, true);
		var showChunks = d(options.chunks, true);
		var showChunkModules = d(options.chunkModules, !!forToString);
		var showChunkOrigins = d(options.chunkOrigins, !forToString);
		var showModules = d(options.modules, !forToString);
		var showCachedModules = d(options.cached, true);
		var showCachedAssets = d(options.cachedAssets, true);
		var showReasons = d(options.reasons, !forToString);
		var showChildren = d(options.children, true);
		var showSource = d(options.source, !forToString);
		var showErrors = d(options.errors, true);
		var showErrorDetails = d(options.errorDetails, !forToString);
		var showWarnings = d(options.warnings, true);
		var showPublicPath = d(options.publicPath, !forToString);
		var excludeModules = [].concat(d(options.exclude, [])).map(function(str) {
			if(typeof str !== "string") return str;
			return new RegExp("[\\\\/]" + str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&") + "([\\\\/]|$|!|\\?)");
		});
		var sortModules = d(options.modulesSort, "id");
		var sortChunks = d(options.chunksSort, "id");
		var sortAssets = d(options.assetsSort, "");
	
		function moduleFilter(module) {
			if(!showCachedModules && !module.built) {
				return false;
			}
			if(excludeModules.length === 0)
				return true;
			var ident = module.identifier();
			return !excludeModules.some(function(regExp) {
				return regExp.test(ident);
			});
		}
	
		function sortByField(field) {
			if(!field) return function() {
				return 0;
			};
			if(field[0] === "!") {
				field = field.substr(1);
				return function(a, b) {
					if(a[field] === b[field]) return 0;
					return a[field] < b[field] ? 1 : -1;
				};
			}
			return function(a, b) {
				if(a[field] === b[field]) return 0;
				return a[field] < b[field] ? -1 : 1;
			};
		}
	
		function formatError(e) {
			var text = "";
			if(typeof e === "string")
				e = {
					message: e
				};
			if(e.chunk) {
				text += "chunk " + (e.chunk.name || e.chunk.id) +
					(e.chunk.entry ? " [entry]" : e.chunk.initial ? " [initial]" : "") + "\n";
			}
			if(e.file) {
				text += e.file + "\n";
			}
			if(e.module && e.module.readableIdentifier && typeof e.module.readableIdentifier === "function") {
				text += e.module.readableIdentifier(requestShortener) + "\n";
			}
			text += e.message;
			if(showErrorDetails && e.details) text += "\n" + e.details;
			if(showErrorDetails && e.missing) text += e.missing.map(function(item) {
				return "\n[" + item + "]";
			}).join("");
			if(e.dependencies && e.origin) {
				text += "\n @ " + e.origin.readableIdentifier(requestShortener);
				e.dependencies.forEach(function(dep) {
					if(!dep.loc) return;
					if(typeof dep.loc === "string") return;
					if(!dep.loc.start) return;
					if(!dep.loc.end) return;
					text += " " + dep.loc.start.line + ":" + dep.loc.start.column + "-" +
						(dep.loc.start.line !== dep.loc.end.line ? dep.loc.end.line + ":" : "") + dep.loc.end.column;
				});
			}
			return text;
		}
	
		var obj = {
			errors: compilation.errors.map(formatError),
			warnings: compilation.warnings.map(formatError)
		};
	
		//We just hint other renderers since actually omitting
		//errors/warnings from the JSON would be kind of weird.
		Object.defineProperty(obj, "_showWarnings", {
			value: showWarnings,
			enumerable: false
		});
		Object.defineProperty(obj, "_showErrors", {
			value: showErrors,
			enumerable: false
		});
	
		if(showVersion) {
			obj.version = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"../package.json\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).version;
		}
	
		if(showHash) obj.hash = this.hash;
		if(showTimings && this.startTime && this.endTime) {
			obj.time = this.endTime - this.startTime;
		}
		if(showPublicPath) {
			obj.publicPath = this.compilation.mainTemplate.getPublicPath({
				hash: this.compilation.hash
			});
		}
		if(showAssets) {
			var assetsByFile = {};
			obj.assetsByChunkName = {};
			obj.assets = Object.keys(compilation.assets).map(function(asset) {
				var obj = {
					name: asset,
					size: compilation.assets[asset].size(),
					chunks: [],
					chunkNames: [],
					emitted: compilation.assets[asset].emitted
				};
				assetsByFile[asset] = obj;
				return obj;
			}).filter(function(asset) {
				return showCachedAssets || asset.emitted;
			});
			compilation.chunks.forEach(function(chunk) {
				chunk.files.forEach(function(asset) {
					if(assetsByFile[asset]) {
						chunk.ids.forEach(function(id) {
							assetsByFile[asset].chunks.push(id);
						});
						if(chunk.name) {
							assetsByFile[asset].chunkNames.push(chunk.name);
							if(obj.assetsByChunkName[chunk.name])
								obj.assetsByChunkName[chunk.name] = [].concat(obj.assetsByChunkName[chunk.name]).concat([asset]);
							else
								obj.assetsByChunkName[chunk.name] = asset;
						}
					}
				});
			});
			obj.assets.sort(sortByField(sortAssets));
		}
	
		function fnModule(module) {
			var obj = {
				id: module.id,
				identifier: module.identifier(),
				name: module.readableIdentifier(requestShortener),
				index: module.index,
				index2: module.index2,
				size: module.size(),
				cacheable: !!module.cacheable,
				built: !!module.built,
				optional: !!module.optional,
				prefetched: !!module.prefetched,
				chunks: module.chunks.map(function(chunk) {
					return chunk.id;
				}),
				assets: Object.keys(module.assets || {}),
				issuer: module.issuer,
				profile: module.profile,
				failed: !!module.error,
				errors: module.errors && module.dependenciesErrors && (module.errors.length + module.dependenciesErrors.length),
				warnings: module.errors && module.dependenciesErrors && (module.warnings.length + module.dependenciesWarnings.length)
			};
			if(showReasons) {
				obj.reasons = module.reasons.filter(function(reason) {
					return reason.dependency && reason.module;
				}).map(function(reason) {
					var obj = {
						moduleId: reason.module.id,
						moduleIdentifier: reason.module.identifier(),
						module: reason.module.readableIdentifier(requestShortener),
						moduleName: reason.module.readableIdentifier(requestShortener),
						type: reason.dependency.type,
						userRequest: reason.dependency.userRequest
					};
					var dep = reason.dependency;
					if(dep.templateModules) obj.templateModules = dep.templateModules.map(function(module) {
						return module.id;
					});
					if(typeof dep.loc === "object") obj.loc = dep.loc.start.line + ":" + dep.loc.start.column + "-" +
						(dep.loc.start.line !== dep.loc.end.line ? dep.loc.end.line + ":" : "") + dep.loc.end.column;
					return obj;
				}).sort(function(a, b) {
					return a.moduleId - b.moduleId;
				});
			}
			if(showSource && module._source) {
				obj.source = module._source.source();
			}
			return obj;
		}
		if(showChunks) {
			obj.chunks = compilation.chunks.map(function(chunk) {
				var obj = {
					id: chunk.id,
					rendered: chunk.rendered,
					initial: !!chunk.initial,
					entry: !!chunk.entry,
					extraAsync: !!chunk.extraAsync,
					size: chunk.modules.reduce(function(size, module) {
						return size + module.size();
					}, 0),
					names: chunk.name ? [chunk.name] : [],
					files: chunk.files.slice(),
					hash: chunk.renderedHash,
					parents: chunk.parents.map(function(c) {
						return c.id;
					})
				};
				if(showChunkModules) {
					obj.modules = chunk.modules.filter(moduleFilter).map(fnModule);
					obj.filteredModules = chunk.modules.length - obj.modules.length;
					obj.modules.sort(sortByField(sortModules));
				}
				if(showChunkOrigins) {
					obj.origins = chunk.origins.map(function(origin) {
						return {
							moduleId: origin.module ? origin.module.id : undefined,
							module: origin.module ? origin.module.identifier() : "",
							moduleIdentifier: origin.module ? origin.module.identifier() : "",
							moduleName: origin.module ? origin.module.readableIdentifier(requestShortener) : "",
							loc: typeof origin.loc === "object" ? obj.loc = origin.loc.start.line + ":" + origin.loc.start.column + "-" +
								(origin.loc.start.line !== origin.loc.end.line ? origin.loc.end.line + ":" : "") + origin.loc.end.column : "",
							name: origin.name,
							reasons: origin.reasons || []
						};
					});
				}
				return obj;
			});
			obj.chunks.sort(sortByField(sortChunks));
		}
		if(showModules) {
			obj.modules = compilation.modules.filter(moduleFilter).map(fnModule);
			obj.filteredModules = compilation.modules.length - obj.modules.length;
			obj.modules.sort(sortByField(sortModules));
		}
		if(showChildren) {
			obj.children = compilation.children.map(function(child) {
				var obj = new Stats(child).toJson(options, forToString);
				delete obj.hash;
				delete obj.version;
				obj.name = child.name;
				return obj;
			});
		}
		return obj;
	};
	
	Stats.prototype.toString = function toString(options) {
		if(typeof options === "boolean" || typeof options === "string") {
			options = Stats.presetToOptions(options);
		} else if(!options) options = {};
	
		function d(v, def) {
			return v === undefined ? def : v;
		}
		var useColors = d(options.colors, false);
	
		var obj = this.toJson(options, true);
	
		return Stats.jsonToString(obj, useColors);
	};
	
	Stats.jsonToString = function jsonToString(obj, useColors) {
		var buf = [];
	
		function normal(str) {
			buf.push(str);
		}
	
		function bold(str) {
			if(useColors) buf.push("\u001b[1m");
			buf.push(str);
			if(useColors) buf.push("\u001b[22m");
		}
	
		function yellow(str) {
			if(useColors) buf.push("\u001b[1m\u001b[33m");
			buf.push(str);
			if(useColors) buf.push("\u001b[39m\u001b[22m");
		}
	
		function red(str) {
			if(useColors) buf.push("\u001b[1m\u001b[31m");
			buf.push(str);
			if(useColors) buf.push("\u001b[39m\u001b[22m");
		}
	
		function green(str) {
			if(useColors) buf.push("\u001b[1m\u001b[32m");
			buf.push(str);
			if(useColors) buf.push("\u001b[39m\u001b[22m");
		}
	
		function cyan(str) {
			if(useColors) buf.push("\u001b[1m\u001b[36m");
			buf.push(str);
			if(useColors) buf.push("\u001b[39m\u001b[22m");
		}
	
		function magenta(str) {
			if(useColors) buf.push("\u001b[1m\u001b[35m");
			buf.push(str);
			if(useColors) buf.push("\u001b[39m\u001b[22m");
		}
	
		function coloredTime(time) {
			var times = [800, 400, 200, 100];
			if(obj.time) {
				times = [obj.time / 2, obj.time / 4, obj.time / 8, obj.time / 16];
			}
			if(time < times[3])
				normal(time + "ms");
			else if(time < times[2])
				bold(time + "ms");
			else if(time < times[1])
				green(time + "ms");
			else if(time < times[0])
				yellow(time + "ms");
			else
				red(time + "ms");
		}
	
		function newline() {
			buf.push("\n");
		}
	
		function table(array, formats, align, splitter) {
			var rows = array.length;
			var cols = array[0].length;
			var colSizes = new Array(cols);
			for(var col = 0; col < cols; col++)
				colSizes[col] = 3;
			for(var row = 0; row < rows; row++) {
				for(var col = 0; col < cols; col++) {
					var value = array[row][col] + "";
					if(value.length > colSizes[col]) {
						colSizes[col] = value.length;
					}
				}
			}
			for(var row = 0; row < rows; row++) {
				for(var col = 0; col < cols; col++) {
					var format = row === 0 ? bold : formats[col];
					var value = array[row][col] + "";
					var l = value.length;
					if(align[col] === "l")
						format(value);
					for(; l < colSizes[col] && col !== cols - 1; l++)
						normal(" ");
					if(align[col] === "r")
						format(value);
					if(col + 1 < cols)
						normal(splitter || "  ");
				}
				newline();
			}
		}
	
		function formatSize(size) {
			if(size <= 0) return "0 bytes";
	
			var abbreviations = ["bytes", "kB", "MB", "GB"];
			var index = Math.floor(Math.log(size) / Math.log(1000));
	
			return +(size / Math.pow(1000, index))
				.toPrecision(3) + " " + abbreviations[index];
		}
	
		if(obj.hash) {
			normal("Hash: ");
			bold(obj.hash);
			newline();
		}
		if(obj.version) {
			normal("Version: webpack ");
			bold(obj.version);
			newline();
		}
		if(typeof obj.time === "number") {
			normal("Time: ");
			bold(obj.time);
			normal("ms");
			newline();
		}
		if(obj.publicPath) {
			normal("PublicPath: ");
			bold(obj.publicPath);
			newline();
		}
		if(obj.assets && obj.assets.length > 0) {
			var t = [
				["Asset", "Size", "Chunks", "", "Chunk Names"]
			];
			obj.assets.forEach(function(asset) {
				t.push([
					asset.name,
					formatSize(asset.size),
					asset.chunks.join(", "),
					asset.emitted ? "[emitted]" : "",
					asset.chunkNames.join(", ")
				]);
			});
			table(t, [green, normal, bold, green, normal], "rrrll");
		}
		var modulesByIdentifier = {};
		if(obj.modules) {
			obj.modules.forEach(function(module) {
				modulesByIdentifier["$" + module.identifier] = module;
			});
		} else if(obj.chunks) {
			obj.chunks.forEach(function(chunk) {
				if(chunk.modules) {
					chunk.modules.forEach(function(module) {
						modulesByIdentifier["$" + module.identifier] = module;
					});
				}
			});
		}
	
		function processProfile(module) {
			if(module.profile) {
				normal("      ");
				var sum = 0,
					allowSum = true;
				var path = [];
				var current = module;
				while(current.issuer) {
					if(!modulesByIdentifier["$" + current.issuer]) {
						normal(" ... ->");
						allowSum = false;
						break;
					}
					path.unshift(current = modulesByIdentifier["$" + current.issuer]);
				}
				path.forEach(function(module) {
					normal(" [");
					normal(module.id);
					normal("] ");
					if(module.profile) {
						var time = (module.profile.factory || 0) + (module.profile.building || 0);
						coloredTime(time);
						sum += time;
						normal(" ");
					}
					normal("->");
				});
				Object.keys(module.profile).forEach(function(key) {
					normal(" " + key + ":");
					var time = module.profile[key];
					coloredTime(time);
					sum += time;
				});
				if(allowSum) {
					normal(" = ");
					coloredTime(sum);
				}
				newline();
			}
		}
	
		function processModuleAttributes(module) {
			normal(" ");
			normal(formatSize(module.size));
			if(module.chunks) {
				module.chunks.forEach(function(chunk) {
					normal(" {");
					yellow(chunk);
					normal("}");
				});
			}
			if(!module.cacheable) {
				red(" [not cacheable]");
			}
			if(module.optional) {
				yellow(" [optional]");
			}
			if(module.built) {
				green(" [built]");
			}
			if(module.prefetched) {
				magenta(" [prefetched]");
			}
			if(module.failed)
				red(" [failed]");
			if(module.warnings)
				yellow(" [" + module.warnings + " warning" + (module.warnings === 1 ? "" : "s") + "]");
			if(module.errors)
				red(" [" + module.errors + " error" + (module.errors === 1 ? "" : "s") + "]");
		}
		if(obj.chunks) {
			obj.chunks.forEach(function(chunk) {
				normal("chunk ");
				if(chunk.id < 1000) normal(" ");
				if(chunk.id < 100) normal(" ");
				if(chunk.id < 10) normal(" ");
				normal("{");
				yellow(chunk.id);
				normal("} ");
				green(chunk.files.join(", "));
				if(chunk.names && chunk.names.length > 0) {
					normal(" (");
					normal(chunk.names.join(", "));
					normal(")");
				}
				normal(" ");
				normal(formatSize(chunk.size));
				chunk.parents.forEach(function(id) {
					normal(" {");
					yellow(id);
					normal("}");
				});
				if(chunk.rendered) {
					green(" [rendered]");
				}
				newline();
				if(chunk.origins) {
					chunk.origins.forEach(function(origin) {
						normal("    > ");
						if(origin.reasons && origin.reasons.length) {
							yellow(origin.reasons.join(" "));
							normal(" ");
						}
						if(origin.name) {
							normal(origin.name);
							normal(" ");
						}
						if(origin.module) {
							normal("[");
							normal(origin.moduleId);
							normal("] ");
							var module = modulesByIdentifier["$" + origin.module];
							if(module) {
								bold(module.name);
								normal(" ");
							}
							if(origin.loc) {
								normal(origin.loc);
							}
						}
						newline();
					});
				}
				if(chunk.modules) {
					chunk.modules.forEach(function(module) {
						normal(" ");
						if(module.id < 1000) normal(" ");
						if(module.id < 100) normal(" ");
						if(module.id < 10) normal(" ");
						normal("[");
						normal(module.id);
						normal("] ");
						bold(module.name);
						processModuleAttributes(module);
						newline();
						if(module.reasons) {
							module.reasons.forEach(function(reason) {
								normal("        ");
								normal(reason.type);
								normal(" ");
								cyan(reason.userRequest);
								if(reason.templateModules) cyan(reason.templateModules.join(" "));
								normal(" [");
								normal(reason.moduleId);
								normal("] ");
								magenta(reason.module);
								if(reason.loc) {
									normal(" ");
									normal(reason.loc);
								}
								newline();
							});
						}
						processProfile(module);
					});
					if(chunk.filteredModules > 0) {
						normal("     + " + chunk.filteredModules + " hidden modules");
						newline();
					}
				}
			});
		}
		if(obj.modules) {
			obj.modules.forEach(function(module) {
				if(module.id < 1000) normal(" ");
				if(module.id < 100) normal(" ");
				if(module.id < 10) normal(" ");
				normal("[");
				normal(module.id);
				normal("] ");
				bold(module.name || module.identifier);
				processModuleAttributes(module);
				newline();
				if(module.reasons) {
					module.reasons.forEach(function(reason) {
						normal("       ");
						normal(reason.type);
						normal(" ");
						cyan(reason.userRequest);
						if(reason.templateModules) cyan(reason.templateModules.join(" "));
						normal(" [");
						normal(reason.moduleId);
						normal("] ");
						magenta(reason.module);
						if(reason.loc) {
							normal(" ");
							normal(reason.loc);
						}
						newline();
					});
				}
				processProfile(module);
			});
			if(obj.filteredModules > 0) {
				normal("    + " + obj.filteredModules + " hidden modules");
				newline();
			}
		}
		if(obj._showWarnings && obj.warnings) {
			obj.warnings.forEach(function(warning) {
				newline();
				yellow("WARNING in " + warning);
				newline();
			});
		}
		if(obj._showErrors && obj.errors) {
			obj.errors.forEach(function(error) {
				newline();
				red("ERROR in " + error);
				newline();
			});
		}
		if(obj.children) {
			obj.children.forEach(function(child) {
				if(child.name) {
					normal("Child ");
					bold(child.name);
					normal(":");
				} else {
					normal("Child");
				}
				newline();
				buf.push("    ");
				buf.push(Stats.jsonToString(child, useColors).replace(/\n/g, "\n    "));
				newline();
			});
		}
	
		while(buf[buf.length - 1] === "\n") buf.pop();
		return buf.join("");
	};
	
	Stats.presetToOptions = function(name) {
		//Accepted values: none, errors-only, minimal, normal, verbose
		//Any other falsy value will behave as 'none', truthy values as 'normal'
		var pn = (typeof name === "string") && name.toLowerCase() || name;
		if(pn === "none" || !pn) {
			return {
				hash: false,
				version: false,
				timings: false,
				assets: false,
				chunks: false,
				modules: false,
				reasons: false,
				children: false,
				source: false,
				errors: false,
				errorDetails: false,
				warnings: false,
				publicPath: false
			};
		} else {
			return {
				assets: pn === "verbose",
				version: pn === "verbose",
				timings: pn !== "errors-only" && pn !== "minimal",
				hash: pn !== "errors-only" && pn !== "minimal",
				chunks: pn !== "errors-only",
				chunkModules: pn === "verbose",
				//warnings: pn !== "errors-only",
				errorDetails: pn !== "errors-only" && pn !== "minimal",
				reasons: pn === "verbose",
				colors: true
			};
		}
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var path = __webpack_require__(4);
	
	function RequestShortener(directory) {
		directory = directory.replace(/\\/g, "/");
		var parentDirectory = path.dirname(directory);
		if(/[\/\\]$/.test(directory)) directory = directory.substr(0, directory.length - 1);
		if(directory) {
			var currentDirectoryRegExp = directory.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
			currentDirectoryRegExp = new RegExp("^" + currentDirectoryRegExp + "|(!)" + currentDirectoryRegExp, "g");
	
			this.currentDirectoryRegExp = currentDirectoryRegExp;
		}
	
		if(/[\/\\]$/.test(parentDirectory)) parentDirectory = parentDirectory.substr(0, parentDirectory.length - 1);
		if(parentDirectory && parentDirectory !== directory) {
			var parentDirectoryRegExp = parentDirectory.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
			parentDirectoryRegExp = new RegExp("^" + parentDirectoryRegExp + "|(!)" + parentDirectoryRegExp, "g");
	
			this.parentDirectoryRegExp = parentDirectoryRegExp;
		}
	
		if(__dirname.length >= 2) {
			var buildins = path.join(__dirname, "..").replace(/\\/g, "/");
			var buildinsAsModule = currentDirectoryRegExp && currentDirectoryRegExp.test(buildins);
			var buildinsRegExp = buildins.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
			buildinsRegExp = new RegExp("^" + buildinsRegExp + "|(!)" + buildinsRegExp, "g");
	
			this.buildinsAsModule = buildinsAsModule;
			this.buildinsRegExp = buildinsRegExp;
		}
	
		this.nodeModulesRegExp = /\/node_modules\//g;
		this.indexJsRegExp = /\/index.js(!|\?|\(query\))/g;
	}
	module.exports = RequestShortener;
	
	RequestShortener.prototype.shorten = function(request) {
		if(!request)
			return request;
		request = request.replace(/\\/g, "/");
		if(this.buildinsAsModule && this.buildinsRegExp)
			request = request.replace(this.buildinsRegExp, "!(webpack)");
		if(this.currentDirectoryRegExp)
			request = request.replace(this.currentDirectoryRegExp, "!.");
		if(this.parentDirectoryRegExp)
			request = request.replace(this.parentDirectoryRegExp, "!..");
		if(!this.buildinsAsModule && this.buildinsRegExp)
			request = request.replace(this.buildinsRegExp, "!(webpack)");
		request = request.replace(this.nodeModulesRegExp, "/~/");
		request = request.replace(this.indexJsRegExp, "$1");
		return request.replace(/^!|!$/, "");
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ },
/* 47 */,
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConcatSource = __webpack_require__(49);
	var OriginalSource = __webpack_require__(50);
	var PrefixSource = __webpack_require__(51);
	var Template = __webpack_require__(52);
	
	function MainTemplate(outputOptions) {
		Template.call(this, outputOptions);
		this.plugin("startup", function(source, chunk, hash) {
			var buf = [];
			if(chunk.modules.some(function(m) {
					return m.id === 0;
				})) {
				buf.push("");
				buf.push("// Load entry module and return exports");
				buf.push("return " + this.renderRequireFunctionForModule(hash, chunk, "0") + "(0);");
			}
			return this.asString(buf);
		});
		this.plugin("render", function(bootstrapSource, chunk, hash, moduleTemplate, dependencyTemplates) {
			var source = new ConcatSource();
			source.add("/******/ (function(modules) { // webpackBootstrap\n");
			source.add(new PrefixSource("/******/", bootstrapSource));
			source.add("/******/ })\n");
			source.add("/************************************************************************/\n");
			source.add("/******/ (");
			var modules = this.renderChunkModules(chunk, moduleTemplate, dependencyTemplates, "/******/ ");
			source.add(this.applyPluginsWaterfall("modules", modules, chunk, hash, moduleTemplate, dependencyTemplates));
			source.add(")");
			return source;
		});
		this.plugin("local-vars", function(source /*, chunk, hash*/ ) {
			return this.asString([
				source,
				"// The module cache",
				"var installedModules = {};"
			]);
		});
		this.plugin("require", function(source, chunk, hash) {
			return this.asString([
				source,
				"// Check if module is in cache",
				"if(installedModules[moduleId])",
				this.indent("return installedModules[moduleId].exports;"),
				"",
				"// Create a new module (and put it into the cache)",
				"var module = installedModules[moduleId] = {",
				this.indent(this.applyPluginsWaterfall("module-obj", "", chunk, hash, "moduleId")),
				"};",
				"",
				"// Execute the module function",
				"modules[moduleId].call(module.exports, module, module.exports, " + this.renderRequireFunctionForModule(hash, chunk, "moduleId") + ");",
				"",
				"// Flag the module as loaded",
				"module.loaded = true;",
				"",
				"// Return the exports of the module",
				"return module.exports;"
			]);
		});
		this.plugin("module-obj", function( /*source, chunk, hash, varModuleId*/ ) {
			return this.asString([
				"exports: {},",
				"id: moduleId,",
				"loaded: false"
			]);
		});
		this.plugin("require-extensions", function(source, chunk, hash) {
			var buf = [];
			if(chunk.chunks.length > 0) {
				buf.push("// This file contains only the entry chunk.");
				buf.push("// The chunk loading function for additional chunks");
				buf.push(this.requireFn + ".e = function requireEnsure(chunkId, callback) {");
				buf.push(this.indent(this.applyPluginsWaterfall("require-ensure", "throw new Error('Not chunk loading available');", chunk, hash, "chunkId")));
				buf.push("};");
			}
			buf.push("");
			buf.push("// expose the modules object (__webpack_modules__)");
			buf.push(this.requireFn + ".m = modules;");
	
			buf.push("");
			buf.push("// expose the module cache");
			buf.push(this.requireFn + ".c = installedModules;");
	
			var publicPath = this.getPublicPath({
				hash: hash
			});
			buf.push("");
			buf.push("// __webpack_public_path__");
			buf.push(this.requireFn + ".p = " + JSON.stringify(publicPath) + ";");
			return this.asString(buf);
		});
	}
	module.exports = MainTemplate;
	
	MainTemplate.prototype = Object.create(Template.prototype);
	MainTemplate.prototype.requireFn = "__webpack_require__";
	MainTemplate.prototype.render = function(hash, chunk, moduleTemplate, dependencyTemplates) {
		var buf = [];
		buf.push(this.applyPluginsWaterfall("bootstrap", "", chunk, hash, moduleTemplate, dependencyTemplates));
		buf.push(this.applyPluginsWaterfall("local-vars", "", chunk, hash));
		buf.push("");
		buf.push("// The require function");
		buf.push("function " + this.requireFn + "(moduleId) {");
		buf.push(this.indent(this.applyPluginsWaterfall("require", "", chunk, hash)));
		buf.push("}");
		buf.push("");
		buf.push(this.asString(this.applyPluginsWaterfall("require-extensions", "", chunk, hash)));
		buf.push(this.asString(this.applyPluginsWaterfall("startup", "", chunk, hash)));
		var source = this.applyPluginsWaterfall("render", new OriginalSource(this.prefix(buf, " \t") + "\n", "webpack/bootstrap " + hash), chunk, hash, moduleTemplate, dependencyTemplates);
		if(chunk.modules.some(function(module) {
				return module.id === 0;
			})) {
			source = this.applyPluginsWaterfall("render-with-entry", source, chunk, hash);
		}
		if(!source) throw new Error("Compiler error: MainTemplate plugin 'render' should return something");
		chunk.rendered = true;
		return new ConcatSource(source, ";");
	};
	
	MainTemplate.prototype.renderRequireFunctionForModule = function(hash, chunk, varModuleId) {
		return this.applyPluginsWaterfall("module-require", this.requireFn, chunk, hash, varModuleId);
	};
	
	MainTemplate.prototype.renderAddModule = function(hash, chunk, varModuleId, varModule) {
		return this.applyPluginsWaterfall("add-module", "modules[" + varModuleId + "] = " + varModule + ";", chunk, hash, varModuleId, varModule);
	};
	
	MainTemplate.prototype.renderCurrentHashCode = function(hash, length) {
		length = length || Infinity;
		return this.applyPluginsWaterfall("current-hash", JSON.stringify(hash.substr(0, length)), length);
	};
	
	MainTemplate.prototype.entryPointInChildren = function(chunk) {
		function checkChildren(chunk, alreadyCheckedChunks) {
			return chunk.chunks.some(function(child) {
				if(alreadyCheckedChunks.indexOf(child) >= 0) return;
				alreadyCheckedChunks.push(child);
				return child.modules.some(function(module) {
					return module.id === 0;
				}) || checkChildren(child, alreadyCheckedChunks);
			});
		}
		return checkChildren(chunk, []);
	};
	
	MainTemplate.prototype.getPublicPath = function(options) {
		return this.applyPluginsWaterfall("asset-path", this.outputOptions.publicPath || "", options);
	};
	
	MainTemplate.prototype.updateHash = function(hash) {
		hash.update("maintemplate");
		hash.update("3");
		hash.update(this.outputOptions.publicPath + "");
		this.applyPlugins("hash", hash);
	};
	
	MainTemplate.prototype.updateHashForChunk = function(hash, chunk) {
		this.updateHash(hash);
		this.applyPlugins("hash-for-chunk", hash, chunk);
	};
	
	MainTemplate.prototype.useChunkHash = function(chunk) {
		var paths = this.applyPluginsWaterfall("global-hash-paths", []);
		return !this.applyPluginsBailResult("global-hash", chunk, paths);
	};


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var SourceNode = __webpack_require__(20).SourceNode;
	var SourceListMap = __webpack_require__(31).SourceListMap;
	var Source = __webpack_require__(19);
	
	function ConcatSource() {
		Source.call(this);
		this.children = Array.prototype.slice.call(arguments);
	}
	module.exports = ConcatSource;
	
	ConcatSource.prototype = Object.create(Source.prototype);
	ConcatSource.prototype.constructor = ConcatSource;
	
	ConcatSource.prototype.add = function(item) {
		this.children.push(item);
	};
	
	ConcatSource.prototype.source = function() {
		return this.children.map(function(item) {
			return typeof item === "string" ? item : item.source();
		}).join("");
	};
	
	ConcatSource.prototype.size = function() {
		return this.children.map(function(item) {
			return typeof item === "string" ? item.length : item.size();
		}).reduce(function(sum, s) { return sum + s; }, 0);
	};
	
	__webpack_require__(39)(ConcatSource.prototype);
	
	ConcatSource.prototype.node = function(options) {
		var node = new SourceNode(null, null, null, this.children.map(function(item) {
			return typeof item === "string" ? item : item.node(options);
		}));
		return node;
	};
	
	ConcatSource.prototype.listMap = function(options) {
		var map = new SourceListMap();
		this.children.forEach(function(item) {
			if(typeof item === "string")
				map.add(item);
			else
				map.add(item.listMap(options));
		});
		return map;
	};
	
	ConcatSource.prototype.updateHash = function(hash) {
		this.children.forEach(function(item) {
			if (typeof item === "string") {
				hash.update(item)
			} else {
				item.updateHash(hash);
			}
		});
	};


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var SourceNode = __webpack_require__(20).SourceNode;
	var SourceMapConsumer = __webpack_require__(20).SourceMapConsumer;
	var SourceListMap = __webpack_require__(31).SourceListMap;
	var Source = __webpack_require__(19);
	
	function isSplitter(c) {
		switch(c) {
		case 10: // \n
		case 13: // \r
		case 59: // ;
		case 123: // {
		case 125: // }
		return true;
		}
		return false;
	}
	function _splitCode(code) {
		var result = [];
		var i = 0, j = 0;
		for(; i < code.length; i++) {
			if(isSplitter(code.charCodeAt(i))) {
				while(isSplitter(code.charCodeAt(++i)));
				result.push(code.substring(j, i));
				j = i;
			}
		}
		if(j < code.length)
			result.push(code.substr(j));
		return result;
	}
	
	function OriginalSource(value, name) {
		Source.call(this);
		this._value = value;
		this._name = name;
	}
	
	module.exports = OriginalSource;
	
	OriginalSource.prototype = Object.create(Source.prototype);
	OriginalSource.prototype.constructor = OriginalSource;
	
	OriginalSource.prototype.source = function() {
		return this._value;
	};
	
	__webpack_require__(39)(OriginalSource.prototype);
	
	OriginalSource.prototype.node = function(options) {
		options = options || {};
		var sourceMap = this._sourceMap;
		var value = this._value;
		var name = this._name;
		var lines = value.split("\n");
		var node = new SourceNode(null, null, null,
			lines.map(function(line, idx) {
				var pos = 0;
				if(options.columns === false) {
					return new SourceNode(idx+1, 0, name,
						(line + (idx != lines.length-1 ? "\n" : ""))
					);
				}
				return new SourceNode(null, null, null,
					_splitCode(line + (idx != lines.length-1 ? "\n" : "")).map(function(item) {
						if(/^\s*$/.test(item)) return item;
						var res = new SourceNode(idx+1, pos, name, item);
						pos += item.length;
						return res;
					})
				);
			})
		);
		node.setSourceContent(name, value);
		return node;
	};
	
	OriginalSource.prototype.listMap = function(options) {
		return new SourceListMap(this._value, this._name, this._value)
	};
	
	OriginalSource.prototype.updateHash = function(hash) {
		hash.update(this._value);
	};


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Source = __webpack_require__(19);
	var SourceNode = __webpack_require__(20).SourceNode;
	
	function PrefixSource(prefix, source) {
		Source.call(this);
		this._source = source;
		this._prefix = prefix;
	}
	module.exports = PrefixSource;
	
	PrefixSource.prototype = Object.create(Source.prototype);
	PrefixSource.prototype.constructor = PrefixSource;
	
	PrefixSource.prototype.source = function() {
		var node = typeof this._source === "string" ? this._source : this._source.source();
		var prefix = this._prefix;
		return prefix + node.replace(/\n(.)/g, "\n" + prefix + "$1");
	};
	
	__webpack_require__(39)(PrefixSource.prototype);
	
	PrefixSource.prototype.node = function(options) {
		var node = this._source.node(options);
		var append = [this._prefix];
		return new SourceNode(null, null, null, [
			cloneAndPrefix(node, this._prefix, append)
		]);
	};
	
	PrefixSource.prototype.listMap = function(options) {
		var prefix = this._prefix;
		var map = this._source.listMap(options);
		map.mapGeneratedCode(function(code) {
			return prefix + code.replace(/\n(.)/g, "\n" + prefix + "$1");
		});
		return map;
	};
	
	PrefixSource.prototype.updateHash = function(hash) {
		if(typeof this._source === "string")
			hash.update(this._source);
		else
			this._source.updateHash(hash);
		if(typeof this._prefix === "string")
			hash.update(this._prefix);
		else
			this._prefix.updateHash(hash);
	};
	
	function cloneAndPrefix(node, prefix, append) {
		if(typeof node === "string") {
			var result = node.replace(/\n(.)/g, "\n" + prefix + "$1");
			if(append.length > 0) result = append.pop() + result;
			if(/\n$/.test(node)) append.push(prefix);
			return result;
		} else {
			var newNode = new SourceNode(
				node.line,
				node.column,
				node.source,
				node.children.map(function(node) {
					return cloneAndPrefix(node, prefix, append);
				}),
				node.name
			);
			newNode.sourceContents = node.sourceContents;
			return newNode;
		}
	};


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Tapable = __webpack_require__(8);
	var ConcatSource = __webpack_require__(49);
	
	function Template(outputOptions) {
		Tapable.call(this);
		this.outputOptions = outputOptions || {};
	}
	module.exports = Template;
	
	Template.getFunctionContent = function(fn) {
		return fn.toString().replace(/^function\s?\(\)\s?\{\n?|\n?\}$/g, "").replace(/^\t/mg, "");
	};
	
	Template.toIdentifier = function(str) {
		if(typeof str !== "string") return "";
		return str.replace(/^[^a-zA-Z$_]/, "_").replace(/[^a-zA-Z0-9$_]/g, "_");
	};
	
	Template.prototype = Object.create(Tapable.prototype);
	Template.prototype.constructor = Template;
	
	Template.prototype.indent = function indent(str) {
		if(Array.isArray(str)) {
			return str.map(indent).join("\n");
		} else {
			str = str.trimRight();
			if(!str) return "";
			var ind = (str[0] === "\n" ? "" : "\t");
			return ind + str.replace(/\n([^\n])/g, "\n\t$1");
		}
	};
	
	Template.prototype.prefix = function(str, prefix) {
		if(Array.isArray(str)) {
			str = str.join("\n");
		}
		str = str.trim();
		if(!str) return "";
		var ind = (str[0] === "\n" ? "" : prefix);
		return ind + str.replace(/\n([^\n])/g, "\n" + prefix + "$1");
	};
	
	Template.prototype.asString = function(str) {
		if(Array.isArray(str)) {
			return str.join("\n");
		}
		return str;
	};
	
	Template.prototype.getModulesArrayBounds = function(modules) {
		if(modules.some(function(module) {
				return typeof module.id !== "number";
			}))
			return false;
		var maxId = -Infinity;
		var minId = Infinity;
		modules.forEach(function(module) {
			if(maxId < module.id) maxId = module.id;
			if(minId > module.id) minId = module.id;
		});
		if(minId < 16 + ("" + minId).length) {
			// add minId x ',' instead of 'Array(minId).concat(...)'
			minId = 0;
		}
		var objectOverhead = modules.map(function(module) {
			var idLength = (module.id + "").length;
			return idLength + 2;
		}).reduce(function(a, b) {
			return a + b;
		}, -1);
		var arrayOverhead = minId === 0 ? maxId : 16 + ("" + minId).length + maxId;
		return arrayOverhead < objectOverhead ? [minId, maxId] : false;
	};
	
	Template.prototype.renderChunkModules = function(chunk, moduleTemplate, dependencyTemplates, prefix) {
		if(!prefix) prefix = "";
		var source = new ConcatSource();
		if(chunk.modules.length === 0) {
			source.add("[]");
			return source;
		}
		var bounds = this.getModulesArrayBounds(chunk.modules);
		if(bounds) {
			// Render a spare array
			var minId = bounds[0];
			var maxId = bounds[1];
			if(minId !== 0) source.add("Array(" + minId + ").concat(");
			source.add("[\n");
			var modules = {};
			chunk.modules.forEach(function(module) {
				modules[module.id] = module;
			});
			for(var idx = minId; idx <= maxId; idx++) {
				var module = modules[idx];
				if(idx !== minId) source.add(",\n");
				source.add("/* " + idx + " */");
				if(module) {
					source.add("\n");
					source.add(moduleTemplate.render(module, dependencyTemplates, chunk));
				}
			}
			source.add("\n" + prefix + "]");
			if(minId !== 0) source.add(")");
		} else {
			// Render an object
			source.add("{\n");
			chunk.modules.forEach(function(module, idx) {
				if(idx !== 0) source.add(",\n");
				source.add("\n/***/ " + JSON.stringify(module.id) + ":\n");
				source.add(moduleTemplate.render(module, dependencyTemplates, chunk));
			});
			source.add("\n\n" + prefix + "}");
		}
		return source;
	};


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConcatSource = __webpack_require__(49);
	var Template = __webpack_require__(52);
	
	function ChunkTemplate(outputOptions) {
		Template.call(this, outputOptions);
	}
	
	module.exports = ChunkTemplate;
	
	ChunkTemplate.prototype = Object.create(Template.prototype);
	ChunkTemplate.prototype.render = function(chunk, moduleTemplate, dependencyTemplates) {
		var modules = this.renderChunkModules(chunk, moduleTemplate, dependencyTemplates);
		var core = this.applyPluginsWaterfall("modules", modules, chunk, moduleTemplate, dependencyTemplates);
		var source = this.applyPluginsWaterfall("render", core, chunk, moduleTemplate, dependencyTemplates);
		if(chunk.modules.some(function(module) {
				return module.id === 0;
			})) {
			source = this.applyPluginsWaterfall("render-with-entry", source, chunk);
		}
		chunk.rendered = true;
		return new ConcatSource(source, ";");
	};
	
	ChunkTemplate.prototype.updateHash = function(hash) {
		hash.update("ChunkTemplate");
		hash.update("2");
		this.applyPlugins("hash", hash);
	};
	
	ChunkTemplate.prototype.updateHashForChunk = function(hash, chunk) {
		this.updateHash(hash);
		this.applyPlugins("hash-for-chunk", hash, chunk);
	};


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Template = __webpack_require__(52);
	
	function HotUpdateChunkTemplate(outputOptions) {
		Template.call(this, outputOptions);
	}
	
	module.exports = HotUpdateChunkTemplate;
	
	HotUpdateChunkTemplate.prototype = Object.create(Template.prototype);
	HotUpdateChunkTemplate.prototype.render = function(id, modules, hash, moduleTemplate, dependencyTemplates) {
		var modulesSource = this.renderChunkModules({
			id: id,
			modules: modules
		}, moduleTemplate, dependencyTemplates);
		var core = this.applyPluginsWaterfall("modules", modulesSource, modules, moduleTemplate, dependencyTemplates);
		var source = this.applyPluginsWaterfall("render", core, modules, hash, id, moduleTemplate, dependencyTemplates);
		return source;
	};
	
	HotUpdateChunkTemplate.prototype.updateHash = function(hash) {
		hash.update("HotUpdateChunkTemplate");
		hash.update("1");
		this.applyPlugins("hash", hash);
	};


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Template = __webpack_require__(52);
	
	function ModuleTemplate(outputOptions) {
		Template.call(this, outputOptions);
	}
	module.exports = ModuleTemplate;
	
	ModuleTemplate.prototype = Object.create(Template.prototype);
	ModuleTemplate.prototype.render = function(module, dependencyTemplates, chunk) {
		var moduleSource = module.source(dependencyTemplates, this.outputOptions, this.requestShortener);
		moduleSource = this.applyPluginsWaterfall("module", moduleSource, module, chunk, dependencyTemplates);
		moduleSource = this.applyPluginsWaterfall("render", moduleSource, module, chunk, dependencyTemplates);
		return this.applyPluginsWaterfall("package", moduleSource, module, chunk, dependencyTemplates);
	};
	
	ModuleTemplate.prototype.updateHash = function(hash) {
		hash.update("1");
		this.applyPlugins("hash", hash);
	};


/***/ },
/* 56 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function Dependency() {
		this.module = null;
	}
	module.exports = Dependency;
	
	Dependency.prototype.isEqualResource = function( /* other */ ) {
		return false;
	};
	
	Dependency.prototype.updateHash = function(hash) {
		hash.update((this.module && this.module.id) + "");
	};
	
	Dependency.prototype.disconnect = function() {
		this.module = null;
	};
	
	Dependency.compare = function(a, b) {
		return Dependency.compareLocations(a.loc, b.loc);
	};
	
	Dependency.compareLocations = function(a, b) {
		if(typeof a === "string") {
			if(typeof b === "string") {
				if(a < b) return -1;
				if(a > b) return 1;
				return 0;
			} else if(typeof b === "object") {
				return 1;
			} else {
				return 0;
			}
		} else if(typeof a === "object") {
			if(typeof b === "string") {
				return -1;
			} else if(typeof b === "object") {
				if(a.start) a = a.start;
				if(b.start) b = b.start;
				if(a.line < b.line) return -1;
				if(a.line > b.line) return 1;
				if(a.column < b.column) return -1;
				if(a.column > b.column) return 1;
				if(a.index < b.index) return -1;
				if(a.index > b.index) return 1;
				return 0;
			} else {
				return 0;
			}
		}
	};


/***/ },
/* 57 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function ChunkRenderError(chunk, file, error) {
		Error.call(this);
		Error.captureStackTrace(this, ChunkRenderError);
		this.name = "ChunkRenderError";
		this.error = error;
		this.message = error.message;
		this.details = error.stack;
		this.file = file;
		this.chunk = chunk;
	}
	module.exports = ChunkRenderError;
	
	ChunkRenderError.prototype = Object.create(Error.prototype);


/***/ },
/* 58 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function CachedSource(source) {
		this._source = source;
		this._cachedSource = undefined;
		this._cachedSize = undefined;
		this._cachedMaps = {};
	}
	module.exports = CachedSource;
	
	CachedSource.prototype.source = function() {
		if(typeof this._cachedSource !== "undefined") return this._cachedSource;
		return this._cachedSource = this._source.source();
	};
	
	CachedSource.prototype.size = function() {
		if(typeof this._cachedSize !== "undefined") return this._cachedSize;
		if(typeof this._cachedSource !== "undefined")
			return this._cachedSize = this._cachedSource.length;
		return this._cachedSize = this._source.size();
	};
	
	CachedSource.prototype.sourceAndMap = function(options) {
		var key = JSON.stringify(options);
		if(typeof this._cachedSource !== "undefined" && key in this._cachedMaps)
			return { source: this._cachedSource, map: this._cachedMaps[key] };
		else if(typeof this._cachedSource !== "undefined") {
			return { source: this._cachedSource, map: this._cachedMaps[key] = this._source.map(options) };
		} else if(key in this._cachedMaps) {
			return { source: this._cachedSource = this._source.source(), map: this._cachedMaps[key] };
		}
		var result = this._source.sourceAndMap(options);
		this._cachedSource = result.source;
		this._cachedMaps[key] = result.map;
		return { source: this._cachedSource, map: this._cachedMaps[key] };
	};
	
	CachedSource.prototype.node = function(options) {
		return this._source.node(options);
	};
	
	CachedSource.prototype.listMap = function(options) {
		return this._source.listMap(options);
	}
	
	CachedSource.prototype.map = function(options) {
		if(!options) options = {};
		var key = JSON.stringify(options);
		if(key in this._cachedMaps)
			return this._cachedMaps[key];
		return this._cachedMaps[key] = this._source.map();
	};
	
	CachedSource.prototype.updateHash = function(hash) {
		this._source.updateHash(hash);
	};


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(3))(137);

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var acorn = __webpack_require__(61);
	var Tapable = __webpack_require__(8);
	var BasicEvaluatedExpression = __webpack_require__(62);
	
	function Parser(options) {
		Tapable.call(this);
		this.options = options;
		this.initializeEvaluating();
	}
	module.exports = Parser;
	
	// Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API
	
	Parser.prototype = Object.create(Tapable.prototype);
	Parser.prototype.constructor = Parser;
	
	Parser.prototype.initializeEvaluating = function() {
		function joinRanges(startRange, endRange) {
			if(!endRange) return startRange;
			if(!startRange) return endRange;
			return [startRange[0], endRange[1]];
		}
		this.plugin("evaluate Literal", function(expr) {
			switch(typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression().setNumber(expr.value).setRange(expr.range);
				case "string":
					return new BasicEvaluatedExpression().setString(expr.value).setRange(expr.range);
				case "boolean":
					return new BasicEvaluatedExpression().setBoolean(expr.value).setRange(expr.range);
			}
			if(expr.value === null)
				return new BasicEvaluatedExpression().setNull().setRange(expr.range);
			if(expr.value instanceof RegExp)
				return new BasicEvaluatedExpression().setRegExp(expr.value).setRange(expr.range);
		});
		this.plugin("evaluate LogicalExpression", function(expr) {
			var left;
			var leftAsBool;
			var right;
			if(expr.operator === "&&") {
				left = this.evaluateExpression(expr.left);
				leftAsBool = left && left.asBool();
				if(leftAsBool === false) return left.setRange(expr.range);
				if(leftAsBool !== true) return;
				right = this.evaluateExpression(expr.right);
				return right.setRange(expr.range);
			} else if(expr.operator === "||") {
				left = this.evaluateExpression(expr.left);
				leftAsBool = left && left.asBool();
				if(leftAsBool === true) return left.setRange(expr.range);
				if(leftAsBool !== false) return;
				right = this.evaluateExpression(expr.right);
				return right.setRange(expr.range);
			}
		});
		this.plugin("evaluate BinaryExpression", function(expr) {
			var left;
			var right;
			var res;
			if(expr.operator === "+") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if(!left || !right) return;
				res = new BasicEvaluatedExpression();
				if(left.isString()) {
					if(right.isString()) {
						res.setString(left.string + right.string);
					} else if(right.isNumber()) {
						res.setString(left.string + right.number);
					} else if(right.isWrapped() && right.prefix && right.prefix.isString()) {
						res.setWrapped(
							new BasicEvaluatedExpression()
							.setString(left.string + right.prefix.string)
							.setRange(joinRanges(left.range, right.prefix.range)),
							right.postfix);
					} else {
						res.setWrapped(left, null);
					}
				} else if(left.isNumber()) {
					if(right.isString()) {
						res.setString(left.number + right.string);
					} else if(right.isNumber()) {
						res.setNumber(left.number + right.number);
					}
				} else if(left.isWrapped()) {
					if(left.postfix && left.postfix.isString() && right.isString()) {
						res.setWrapped(left.prefix,
							new BasicEvaluatedExpression()
							.setString(left.postfix.string + right.string)
							.setRange(joinRanges(left.postfix.range, right.range))
						);
					} else if(left.postfix && left.postfix.isString() && right.isNumber()) {
						res.setWrapped(left.prefix,
							new BasicEvaluatedExpression()
							.setString(left.postfix.string + right.number)
							.setRange(joinRanges(left.postfix.range, right.range))
						);
					} else if(right.isString()) {
						res.setWrapped(left.prefix, right);
					} else if(right.isNumber()) {
						res.setWrapped(left.prefix,
							new BasicEvaluatedExpression()
							.setString(right.number + "")
							.setRange(right.range));
					} else {
						res.setWrapped(left.prefix, new BasicEvaluatedExpression());
					}
				} else {
					if(right.isString()) {
						res.setWrapped(null, right);
					}
				}
				res.setRange(expr.range);
				return res;
			} else if(expr.operator === "-") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if(!left || !right) return;
				if(!left.isNumber() || !right.isNumber()) return;
				res = new BasicEvaluatedExpression();
				res.setNumber(left.number - right.number);
				res.setRange(expr.range);
				return res;
			} else if(expr.operator === "*") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if(!left || !right) return;
				if(!left.isNumber() || !right.isNumber()) return;
				res = new BasicEvaluatedExpression();
				res.setNumber(left.number * right.number);
				res.setRange(expr.range);
				return res;
			} else if(expr.operator === "/") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if(!left || !right) return;
				if(!left.isNumber() || !right.isNumber()) return;
				res = new BasicEvaluatedExpression();
				res.setNumber(left.number / right.number);
				res.setRange(expr.range);
				return res;
			} else if(expr.operator === "==" || expr.operator === "===") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if(!left || !right) return;
				res = new BasicEvaluatedExpression();
				res.setRange(expr.range);
				if(left.isString() && right.isString()) {
					return res.setBoolean(left.string === right.string);
				} else if(left.isNumber() && right.isNumber()) {
					return res.setBoolean(left.number === right.number);
				} else if(left.isBoolean() && right.isBoolean()) {
					return res.setBoolean(left.bool === right.bool);
				}
			} else if(expr.operator === "!=" || expr.operator === "!==") {
				left = this.evaluateExpression(expr.left);
				right = this.evaluateExpression(expr.right);
				if(!left || !right) return;
				res = new BasicEvaluatedExpression();
				res.setRange(expr.range);
				if(left.isString() && right.isString()) {
					return res.setBoolean(left.string !== right.string);
				} else if(left.isNumber() && right.isNumber()) {
					return res.setBoolean(left.number !== right.number);
				} else if(left.isBoolean() && right.isBoolean()) {
					return res.setBoolean(left.bool !== right.bool);
				}
			}
		});
		this.plugin("evaluate UnaryExpression", function(expr) {
			if(expr.operator === "typeof") {
				var res;
				if(expr.argument.type === "Identifier") {
					var name = this.scope.renames["$" + expr.argument.name] || expr.argument.name;
					if(this.scope.definitions.indexOf(name) === -1) {
						res = this.applyPluginsBailResult("evaluate typeof " + name, expr);
						if(res !== undefined) return res;
					}
				}
				if(expr.argument.type === "MemberExpression") {
					var expression = expr.argument;
					var exprName = [];
					while(expression.type === "MemberExpression" && !expression.computed) {
						exprName.unshift(this.scope.renames["$" + expression.property.name] || expression.property.name);
						expression = expression.object;
					}
					if(expression.type === "Identifier") {
						exprName.unshift(this.scope.renames["$" + expression.name] || expression.name);
						if(this.scope.definitions.indexOf(name) === -1) {
							exprName = exprName.join(".");
							res = this.applyPluginsBailResult("evaluate typeof " + exprName, expr);
							if(res !== undefined) return res;
						}
					}
				}
				if(expr.argument.type === "FunctionExpression") {
					return new BasicEvaluatedExpression().setString("function").setRange(expr.range);
				}
				var arg = this.evaluateExpression(expr.argument);
				if(arg.isString() || arg.isWrapped()) return new BasicEvaluatedExpression().setString("string").setRange(expr.range);
				else if(arg.isNumber()) return new BasicEvaluatedExpression().setString("number").setRange(expr.range);
				else if(arg.isBoolean()) return new BasicEvaluatedExpression().setString("boolean").setRange(expr.range);
				else if(arg.isArray() || arg.isConstArray() || arg.isRegExp()) return new BasicEvaluatedExpression().setString("object").setRange(expr.range);
			} else if(expr.operator === "!") {
				var argument = this.evaluateExpression(expr.argument);
				if(!argument) return;
				if(argument.isBoolean()) {
					return new BasicEvaluatedExpression().setBoolean(!argument.bool).setRange(expr.range);
				} else if(argument.isString()) {
					return new BasicEvaluatedExpression().setBoolean(!argument.string).setRange(expr.range);
				} else if(argument.isNumber()) {
					return new BasicEvaluatedExpression().setBoolean(!argument.number).setRange(expr.range);
				}
			}
		});
		this.plugin("evaluate typeof undefined", function(expr) {
			return new BasicEvaluatedExpression().setString("undefined").setRange(expr.range);
		});
		this.plugin("evaluate Identifier", function(expr) {
			var name = this.scope.renames["$" + expr.name] || expr.name;
			if(this.scope.definitions.indexOf(expr.name) === -1) {
				var result = this.applyPluginsBailResult("evaluate Identifier " + name, expr);
				if(result) return result;
				return new BasicEvaluatedExpression().setIdentifier(name).setRange(expr.range);
			} else {
				return this.applyPluginsBailResult("evaluate defined Identifier " + name, expr);
			}
		});
		this.plugin("evaluate MemberExpression", function(expression) {
			var expr = expression;
			var exprName = [];
			while(expr.type === "MemberExpression" && !expr.computed) {
				exprName.unshift(expr.property.name);
				expr = expr.object;
			}
			if(expr.type === "Identifier") {
				var name = this.scope.renames["$" + expr.name] || expr.name;
				if(this.scope.definitions.indexOf(name) === -1) {
					exprName.unshift(name);
					exprName = exprName.join(".");
					if(this.scope.definitions.indexOf(expr.name) === -1) {
						var result = this.applyPluginsBailResult("evaluate Identifier " + exprName, expression);
						if(result) return result;
						return new BasicEvaluatedExpression().setIdentifier(exprName).setRange(expression.range);
					} else {
						return this.applyPluginsBailResult("evaluate defined Identifier " + exprName, expression);
					}
				}
			}
		});
		this.plugin("evaluate CallExpression", function(expr) {
			if(expr.callee.type !== "MemberExpression") return;
			if(expr.callee.computed) return;
			var param = this.evaluateExpression(expr.callee.object);
			if(!param) return;
			return this.applyPluginsBailResult("evaluate CallExpression ." + expr.callee.property.name, expr, param);
		});
		this.plugin("evaluate CallExpression .replace", function(expr, param) {
			if(!param.isString()) return;
			if(expr.arguments.length !== 2) return;
			var arg1 = this.evaluateExpression(expr.arguments[0]);
			var arg2 = this.evaluateExpression(expr.arguments[1]);
			if(!arg1.isString() && !arg1.isRegExp()) return;
			arg1 = arg1.regExp || arg1.string;
			if(!arg2.isString()) return;
			arg2 = arg2.string;
			return new BasicEvaluatedExpression().setString(param.string.replace(arg1, arg2)).setRange(expr.range);
		});
		["substr", "substring"].forEach(function(fn) {
			this.plugin("evaluate CallExpression ." + fn, function(expr, param) {
				if(!param.isString()) return;
				var arg1;
				var result, str = param.string;
				switch(expr.arguments.length) {
					case 1:
						arg1 = this.evaluateExpression(expr.arguments[0]);
						if(!arg1.isNumber()) return;
						result = str[fn](arg1.number);
						break;
					case 2:
						arg1 = this.evaluateExpression(expr.arguments[0]);
						var arg2 = this.evaluateExpression(expr.arguments[1]);
						if(!arg1.isNumber()) return;
						if(!arg2.isNumber()) return;
						result = str[fn](arg1.number, arg2.number);
						break;
					default:
						return;
				}
				return new BasicEvaluatedExpression().setString(result).setRange(expr.range);
			});
		}, this);
		this.plugin("evaluate CallExpression .split", function(expr, param) {
			if(!param.isString()) return;
			if(expr.arguments.length !== 1) return;
			var result;
			var arg = this.evaluateExpression(expr.arguments[0]);
			if(arg.isString()) {
				result = param.string.split(arg.string);
			} else if(arg.isRegExp()) {
				result = param.string.split(arg.regExp);
			} else return;
			return new BasicEvaluatedExpression().setArray(result).setRange(expr.range);
		});
		this.plugin("evaluate ConditionalExpression", function(expr) {
			var condition = this.evaluateExpression(expr.test);
			var conditionValue = condition.asBool();
			var res;
			if(conditionValue === undefined) {
				var consequent = this.evaluateExpression(expr.consequent);
				var alternate = this.evaluateExpression(expr.alternate);
				if(!consequent || !alternate) return;
				res = new BasicEvaluatedExpression();
				if(consequent.isConditional())
					res.setOptions(consequent.options);
				else
					res.setOptions([consequent]);
				if(alternate.isConditional())
					res.addOptions(alternate.options);
				else
					res.addOptions([alternate]);
			} else {
				res = this.evaluateExpression(conditionValue ? expr.consequent : expr.alternate);
			}
			res.setRange(expr.range);
			return res;
		});
		this.plugin("evaluate ArrayExpression", function(expr) {
			var items = expr.elements.map(function(element) {
				return element !== null && this.evaluateExpression(element);
			}, this);
			if(items.filter(function(i) {
					return !i;
				}).length > 0) return;
			return new BasicEvaluatedExpression().setItems(items).setRange(expr.range);
		});
	};
	
	Parser.prototype.getRenameIdentifier = function getRenameIdentifier(expr) {
		var result = this.evaluateExpression(expr);
		if(!result) return;
		if(result.isIdentifier()) return result.identifier;
		return;
	};
	
	Parser.prototype.walkClass = function walkClass(classy) {
		if(classy.superClass)
			this.walkExpression(classy.superClass);
		if(classy.body && classy.body.type === "ClassBody") {
			classy.body.body.forEach(function(methodDefinition) {
				if(methodDefinition.type === "MethodDefinition")
					this.walkMethodDefinition(methodDefinition);
			}, this);
		}
	};
	
	Parser.prototype.walkMethodDefinition = function walkMethodDefinition(methodDefinition) {
		if(methodDefinition.computed && methodDefinition.key)
			this.walkExpression(methodDefinition.key);
		if(methodDefinition.value)
			this.walkExpression(methodDefinition.value);
	};
	
	Parser.prototype.walkStatements = function walkStatements(statements) {
		statements.forEach(function(statement) {
			this.walkStatement(statement);
		}, this);
	};
	
	Parser.prototype.walkStatement = function walkStatement(statement) {
		if(this.applyPluginsBailResult("statement", statement) !== undefined) return;
		if(this["walk" + statement.type])
			this["walk" + statement.type](statement);
	};
	
	// Real Statements
	Parser.prototype.walkBlockStatement = function walkBlockStatement(statement) {
		this.walkStatements(statement.body);
	};
	
	Parser.prototype.walkExpressionStatement = function walkExpressionStatement(statement) {
		this.walkExpression(statement.expression);
	};
	
	Parser.prototype.walkIfStatement = function walkIfStatement(statement) {
		var result = this.applyPluginsBailResult("statement if", statement);
		if(result === undefined) {
			this.walkExpression(statement.test);
			this.walkStatement(statement.consequent);
			if(statement.alternate)
				this.walkStatement(statement.alternate);
		} else {
			if(result)
				this.walkStatement(statement.consequent);
			else if(statement.alternate)
				this.walkStatement(statement.alternate);
		}
	};
	
	Parser.prototype.walkLabeledStatement = function walkLabeledStatement(statement) {
		var result = this.applyPluginsBailResult("label " + statement.label.name, statement);
		if(result !== true)
			this.walkStatement(statement.body);
	};
	
	Parser.prototype.walkWithStatement = function walkWithStatement(statement) {
		this.walkExpression(statement.object);
		this.walkStatement(statement.body);
	};
	
	Parser.prototype.walkSwitchStatement = function walkSwitchStatement(statement) {
		this.walkExpression(statement.discriminant);
		this.walkSwitchCases(statement.cases);
	};
	
	Parser.prototype.walkReturnStatement =
		Parser.prototype.walkThrowStatement = function walkArgumentStatement(statement) {
			if(statement.argument)
				this.walkExpression(statement.argument);
		};
	
	Parser.prototype.walkTryStatement = function walkTryStatement(statement) {
		if(this.scope.inTry) {
			this.walkStatement(statement.block);
		} else {
			this.scope.inTry = true;
			this.walkStatement(statement.block);
			this.scope.inTry = false;
		}
		if(statement.handler)
			this.walkCatchClause(statement.handler);
		if(statement.finalizer)
			this.walkStatement(statement.finalizer);
	};
	
	Parser.prototype.walkWhileStatement =
		Parser.prototype.walkDoWhileStatement = function walkLoopStatement(statement) {
			this.walkExpression(statement.test);
			this.walkStatement(statement.body);
		};
	
	Parser.prototype.walkForStatement = function walkForStatement(statement) {
		if(statement.init) {
			if(statement.init.type === "VariableDeclaration")
				this.walkStatement(statement.init);
			else
				this.walkExpression(statement.init);
		}
		if(statement.test)
			this.walkExpression(statement.test);
		if(statement.update)
			this.walkExpression(statement.update);
		this.walkStatement(statement.body);
	};
	
	Parser.prototype.walkForInStatement = function walkForInStatement(statement) {
		if(statement.left.type === "VariableDeclaration")
			this.walkStatement(statement.left);
		else
			this.walkExpression(statement.left);
		this.walkExpression(statement.right);
		this.walkStatement(statement.body);
	};
	
	Parser.prototype.walkForOfStatement = function walkForOfStatement(statement) {
		if(statement.left.type === "VariableDeclaration")
			this.walkStatement(statement.left);
		else
			this.walkExpression(statement.left);
		this.walkExpression(statement.right);
		this.walkStatement(statement.body);
	};
	
	// Declarations
	Parser.prototype.walkFunctionDeclaration = function walkFunctionDeclaration(statement) {
		this.scope.renames["$" + statement.id.name] = undefined;
		this.scope.definitions.push(statement.id.name);
		this.inScope(statement.params, function() {
			if(statement.body.type === "BlockStatement")
				this.walkStatement(statement.body);
			else
				this.walkExpression(statement.body);
		}.bind(this));
	};
	
	Parser.prototype.walkVariableDeclaration = function walkVariableDeclaration(statement) {
		if(statement.declarations)
			this.walkVariableDeclarators(statement.declarations);
	};
	
	Parser.prototype.walkClassDeclaration = function walkClassDeclaration(statement) {
		this.walkClass(statement);
	};
	
	Parser.prototype.walkSwitchCases = function walkSwitchCases(switchCases) {
		switchCases.forEach(function(switchCase) {
			if(switchCase.test)
				this.walkExpression(switchCase.test);
			this.walkStatements(switchCase.consequent);
		}, this);
	};
	
	Parser.prototype.walkCatchClause = function walkCatchClause(catchClause) {
		if(catchClause.guard)
			this.walkExpression(catchClause.guard);
		this.inScope([catchClause.param], function() {
			this.walkStatement(catchClause.body);
		}.bind(this));
	};
	
	Parser.prototype.walkVariableDeclarators = function walkVariableDeclarators(declarators) {
		declarators.forEach(function(declarator) {
			switch(declarator.type) {
				case "VariableDeclarator":
					var renameIdentifier = declarator.init && this.getRenameIdentifier(declarator.init);
					if(renameIdentifier && declarator.id.type === "Identifier" && this.applyPluginsBailResult("can-rename " + renameIdentifier, declarator.init)) {
						// renaming with "var a = b;"
						if(!this.applyPluginsBailResult("rename " + renameIdentifier, declarator.init)) {
							this.scope.renames["$" + declarator.id.name] = this.scope.renames["$" + renameIdentifier] || renameIdentifier;
							var idx = this.scope.definitions.indexOf(declarator.id.name);
							if(idx >= 0) this.scope.definitions.splice(idx, 1);
						}
					} else if(declarator.id.type === "Identifier" && !this.applyPluginsBailResult("var " + declarator.id.name, declarator)) {
						this.scope.renames["$" + declarator.id.name] = undefined;
						this.scope.definitions.push(declarator.id.name);
						if(declarator.init)
							this.walkExpression(declarator.init);
					} else {
						this.walkExpression(declarator.id);
						if(declarator.init)
							this.walkExpression(declarator.init);
					}
					break;
			}
		}, this);
	};
	
	Parser.prototype.walkExpressions = function walkExpressions(expressions) {
		expressions.forEach(function(expression) {
			if(expression)
				this.walkExpression(expression);
		}, this);
	};
	
	Parser.prototype.walkExpression = function walkExpression(expression) {
		if(this["walk" + expression.type])
			return this["walk" + expression.type](expression);
	};
	
	Parser.prototype.walkArrayExpression = function walkArrayExpression(expression) {
		if(expression.elements)
			this.walkExpressions(expression.elements);
	};
	
	Parser.prototype.walkSpreadElement = function walkSpreadElement(expression) {
		if(expression.argument)
			this.walkExpression(expression.argument);
	};
	
	Parser.prototype.walkObjectExpression = function walkObjectExpression(expression) {
		expression.properties.forEach(function(prop) {
			if(prop.computed)
				this.walkExpression(prop.key)
			this.walkExpression(prop.value);
		}, this);
	};
	
	Parser.prototype.walkFunctionExpression = function walkFunctionExpression(expression) {
		this.inScope(expression.params, function() {
			if(expression.body.type === "BlockStatement")
				this.walkStatement(expression.body);
			else
				this.walkExpression(expression.body);
		}.bind(this));
	};
	
	Parser.prototype.walkArrowFunctionExpression = function walkArrowFunctionExpression(expression) {
		this.inScope(expression.params, function() {
			if(expression.body.type === "BlockStatement")
				this.walkStatement(expression.body);
			else
				this.walkExpression(expression.body);
		}.bind(this));
	};
	
	Parser.prototype.walkSequenceExpression = function walkSequenceExpression(expression) {
		if(expression.expressions)
			this.walkExpressions(expression.expressions);
	};
	
	Parser.prototype.walkUpdateExpression = function walkUpdateExpression(expression) {
		this.walkExpression(expression.argument);
	};
	
	Parser.prototype.walkUnaryExpression = function walkUnaryExpression(expression) {
		if(expression.operator === "typeof") {
			var expr = expression.argument;
			var exprName = [];
			while(expr.type === "MemberExpression" && !expr.computed) {
				exprName.unshift(expr.property.name);
				expr = expr.object;
			}
			if(expr.type === "Identifier" && this.scope.definitions.indexOf(expr.name) === -1) {
				exprName.unshift(this.scope.renames["$" + expr.name] || expr.name);
				exprName = exprName.join(".");
				var result = this.applyPluginsBailResult("typeof " + exprName, expression);
				if(result === true)
					return;
			}
		}
		this.walkExpression(expression.argument);
	};
	
	Parser.prototype.walkBinaryExpression =
		Parser.prototype.walkLogicalExpression = function walkLeftRightExpression(expression) {
			this.walkExpression(expression.left);
			this.walkExpression(expression.right);
		};
	
	Parser.prototype.walkAssignmentExpression = function walkAssignmentExpression(expression) {
		var renameIdentifier = this.getRenameIdentifier(expression.right);
		if(expression.left.type === "Identifier" && renameIdentifier && this.applyPluginsBailResult("can-rename " + renameIdentifier, expression.right)) {
			// renaming "a = b;"
			if(!this.applyPluginsBailResult("rename " + renameIdentifier, expression.right)) {
				this.scope.renames["$" + expression.left.name] = renameIdentifier;
				var idx = this.scope.definitions.indexOf(expression.left.name);
				if(idx >= 0) this.scope.definitions.splice(idx, 1);
			}
		} else if(expression.left.type === "Identifier") {
			if(!this.applyPluginsBailResult("assigned " + expression.left.name, expression)) {
				this.walkExpression(expression.right);
			}
			this.scope.renames["$" + expression.left.name] = undefined;
			if(!this.applyPluginsBailResult("assign " + expression.left.name, expression)) {
				this.walkExpression(expression.left);
			}
		} else {
			this.walkExpression(expression.right);
			this.scope.renames["$" + expression.left.name] = undefined;
			this.walkExpression(expression.left);
		}
	};
	
	Parser.prototype.walkConditionalExpression = function walkConditionalExpression(expression) {
		var result = this.applyPluginsBailResult("expression ?:", expression);
		if(result === undefined) {
			this.walkExpression(expression.test);
			this.walkExpression(expression.consequent);
			if(expression.alternate)
				this.walkExpression(expression.alternate);
		} else {
			if(result)
				this.walkExpression(expression.consequent);
			else if(expression.alternate)
				this.walkExpression(expression.alternate);
		}
	};
	
	Parser.prototype.walkNewExpression = function walkNewExpression(expression) {
		this.walkExpression(expression.callee);
		if(expression.arguments)
			this.walkExpressions(expression.arguments);
	};
	
	Parser.prototype.walkYieldExpression = function walkYieldExpression(expression) {
		if(expression.argument)
			this.walkExpression(expression.argument);
	};
	
	Parser.prototype.walkTemplateLiteral = function walkTemplateLiteral(expression) {
		if(expression.expressions)
			this.walkExpressions(expression.expressions);
	};
	
	Parser.prototype.walkTaggedTemplateExpression = function walkTaggedTemplateExpression(expression) {
		if(expression.tag)
			this.walkExpression(expression.tag);
		if(expression.quasi && expression.quasi.expressions)
			this.walkExpressions(expression.quasi.expressions);
	};
	
	Parser.prototype.walkClassExpression = function walkClassExpression(expression) {
		this.walkClass(expression);
	};
	
	Parser.prototype.walkCallExpression = function walkCallExpression(expression) {
		function walkIIFE(functionExpression, args) {
			var params = functionExpression.params;
			var args = args.map(function(arg) {
				var renameIdentifier = this.getRenameIdentifier(arg);
				if(renameIdentifier && this.applyPluginsBailResult("can-rename " + renameIdentifier, arg)) {
					if(!this.applyPluginsBailResult("rename " + renameIdentifier, arg))
						return renameIdentifier;
				}
				this.walkExpression(arg);
			}, this);
			this.inScope(params.filter(function(identifier, idx) {
				return !args[idx];
			}), function() {
				args.forEach(function(arg, idx) {
					if(!arg) return;
					if(!params[idx] || params[idx].type !== "Identifier") return;
					this.scope.renames["$" + params[idx].name] = arg;
				}, this);
				if(functionExpression.body.type === "BlockStatement")
					this.walkStatement(functionExpression.body);
				else
					this.walkExpression(functionExpression.body);
			}.bind(this));
		}
		if(expression.callee.type === "MemberExpression" && expression.callee.object.type === "FunctionExpression" && !expression.callee.computed && ["call", "bind"].indexOf(expression.callee.property.name) >= 0 && expression.arguments && expression.arguments.length > 1) {
			// (function(...) { }.call/bind(?, ...))
			walkIIFE.call(this, expression.callee.object, expression.arguments.slice(1));
			this.walkExpression(expression.arguments[0]);
		} else if(expression.callee.type === "FunctionExpression" && expression.arguments) {
			// (function(...) { }(...))
			walkIIFE.call(this, expression.callee, expression.arguments);
		} else {
	
			var callee = this.evaluateExpression(expression.callee);
			if(callee.isIdentifier()) {
				var result = this.applyPluginsBailResult("call " + callee.identifier, expression);
				if(result === true)
					return;
			}
	
			if(expression.callee)
				this.walkExpression(expression.callee);
			if(expression.arguments)
				this.walkExpressions(expression.arguments);
		}
	};
	
	Parser.prototype.walkMemberExpression = function walkMemberExpression(expression) {
		var expr = expression;
		var exprName = [];
		while(expr.type === "MemberExpression" && !expr.computed) {
			exprName.unshift(expr.property.name);
			expr = expr.object;
		}
		if(expr.type === "Identifier" && this.scope.definitions.indexOf(expr.name) === -1) {
			exprName.unshift(this.scope.renames["$" + expr.name] || expr.name);
			exprName = exprName.join(".");
			var result = this.applyPluginsBailResult("expression " + exprName, expression);
			if(result === true)
				return;
		}
		this.walkExpression(expression.object);
		if(expression.computed === true)
			this.walkExpression(expression.property);
	};
	
	Parser.prototype.walkIdentifier = function walkIdentifier(expression) {
		if(this.scope.definitions.indexOf(expression.name) === -1) {
			var result = this.applyPluginsBailResult("expression " + (this.scope.renames["$" + expression.name] || expression.name), expression);
			if(result === true)
				return;
		}
	};
	
	Parser.prototype.inScope = function inScope(params, fn) {
		var oldScope = this.scope;
		this.scope = {
			inTry: false,
			definitions: oldScope.definitions.slice(),
			renames: Object.create(oldScope.renames)
		};
		params.forEach(function(param) {
			if(typeof param !== "string") {
				if(param.type !== "Identifier")
					return;
				param = param.name;
			}
			this.scope.renames["$" + param] = undefined;
			this.scope.definitions.push(param);
		}, this);
		fn();
		this.scope = oldScope;
	};
	
	Parser.prototype.evaluateExpression = function evaluateExpression(expression) {
		var result = this.applyPluginsBailResult("evaluate " + expression.type, expression);
		if(result !== undefined)
			return result;
		return new BasicEvaluatedExpression().setRange(expression.range);
	};
	
	Parser.prototype.parseString = function parseString(expression) {
		switch(expression.type) {
			case "BinaryExpression":
				if(expression.operator === "+")
					return this.parseString(expression.left) + this.parseString(expression.right);
				break;
			case "Literal":
				return expression.value + "";
		}
		throw new Error(expression.type + " is not supported as parameter for require");
	};
	
	Parser.prototype.parseCalculatedString = function parseCalculatedString(expression) {
		switch(expression.type) {
			case "BinaryExpression":
				if(expression.operator === "+") {
					var left = this.parseCalculatedString(expression.left);
					var right = this.parseCalculatedString(expression.right);
					if(left.code) {
						return {
							range: left.range,
							value: left.value,
							code: true
						};
					} else if(right.code) {
						return {
							range: [left.range[0], right.range ? right.range[1] : left.range[1]],
							value: left.value + right.value,
							code: true
						};
					} else {
						return {
							range: [left.range[0], right.range[1]],
							value: left.value + right.value
						};
					}
				}
				break;
			case "ConditionalExpression":
				var consequent = this.parseCalculatedString(expression.consequent);
				var alternate = this.parseCalculatedString(expression.alternate);
				var items = [];
				if(consequent.conditional)
					Array.prototype.push.apply(items, consequent.conditional);
				else if(!consequent.code)
					items.push(consequent);
				else break;
				if(alternate.conditional)
					Array.prototype.push.apply(items, alternate.conditional);
				else if(!alternate.code)
					items.push(alternate);
				else break;
				return {
					value: "",
					code: true,
					conditional: items
				};
			case "Literal":
				return {
					range: expression.range,
					value: expression.value + ""
				};
		}
		return {
			value: "",
			code: true
		};
	};
	
	["parseString", "parseCalculatedString"].forEach(function(fn) {
		Parser.prototype[fn + "Array"] = function parseXXXArray(expression) {
			switch(expression.type) {
				case "ArrayExpression":
					var arr = [];
					if(expression.elements)
						expression.elements.forEach(function(expr) {
							arr.push(this[fn](expr));
						}, this);
					return arr;
			}
			return [this[fn](expression)];
		};
	});
	
	var POSSIBLE_AST_OPTIONS = [{
		ranges: true,
		locations: true,
		ecmaVersion: 6,
		sourceType: "module"
	}, {
		ranges: true,
		locations: true,
		ecmaVersion: 6,
		sourceType: "script"
	}]
	
	Parser.prototype.parse = function parse(source, initialState) {
		var ast;
		for(var i = 0; i < POSSIBLE_AST_OPTIONS.length; i++) {
			if(!ast) {
				try {
					ast = acorn.parse(source, POSSIBLE_AST_OPTIONS[i]);
				} catch(e) {
					// ignore the error
				}
			}
		}
		if(!ast) {
			// for the error
			ast = acorn.parse(source, {
				ranges: true,
				locations: true,
				ecmaVersion: 6,
				sourceType: "module"
			});
		}
		if(!ast || typeof ast !== "object")
			throw new Error("Source couldn't be parsed");
		var oldScope = this.scope;
		var oldState = this.state;
		this.scope = {
			inTry: false,
			definitions: [],
			renames: {}
		};
		var state = this.state = initialState || {};
		if(this.applyPluginsBailResult("program", ast) === undefined)
			this.walkStatements(ast.body);
		this.scope = oldScope;
		this.state = oldState;
		return state;
	};
	
	Parser.prototype.evaluate = function evaluate(source) {
		var ast = acorn.parse("(" + source + ")", {
			ranges: true,
			locations: true,
			ecmaVersion: 6,
			sourceType: "module"
		});
		if(!ast || typeof ast !== "object" || ast.type !== "Program")
			throw new Error("evaluate: Source couldn't be parsed");
		if(ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement")
			throw new Error("evaluate: Source is not a expression");
		return this.evaluateExpression(ast.body[0].expression);
	};


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	(function (global, factory) {
	   true ? factory(exports) :
	  typeof define === 'function' && define.amd ? define(['exports'], factory) :
	  (factory((global.acorn = global.acorn || {})));
	}(this, function (exports) { 'use strict';
	
	  // Reserved word lists for various dialects of the language
	
	  var reservedWords = {
	    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
	    5: "class enum extends super const export import",
	    6: "enum",
	    7: "enum",
	    strict: "implements interface let package private protected public static yield",
	    strictBind: "eval arguments"
	  }
	
	  // And the keywords
	
	  var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this"
	
	  var keywords = {
	    5: ecma5AndLessKeywords,
	    6: ecma5AndLessKeywords + " const class extends export import super"
	  }
	
	  // ## Character categories
	
	  // Big ugly regular expressions that match characters in the
	  // whitespace, identifier, and identifier-start categories. These
	  // are only applied when a character is found to actually have a
	  // code point above 128.
	  // Generated by `bin/generate-identifier-regex.js`.
	
	  var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fd5\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ae\ua7b0-\ua7b7\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc"
	  var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d4-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d01-\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1cf8\u1cf9\u1dc0-\u1df5\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f"
	
	  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]")
	  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]")
	
	  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null
	
	  // These are a run-length and offset encoded representation of the
	  // >0xffff code points that are a valid part of identifiers. The
	  // offset starts at 0x10000, and each pair of numbers represents an
	  // offset to the next range, and then a size of the range. They were
	  // generated by bin/generate-identifier-regex.js
	  var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,17,26,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,26,45,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,785,52,76,44,33,24,27,35,42,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,25,391,63,32,0,449,56,264,8,2,36,18,0,50,29,881,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,881,68,12,0,67,12,65,0,32,6124,20,754,9486,1,3071,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,10591,541]
	  var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,1306,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,52,0,13,2,49,13,10,2,4,9,83,11,7,0,161,11,6,9,7,3,57,0,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,87,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,423,9,838,7,2,7,17,9,57,21,2,13,19882,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239]
	
	  // This has a complexity linear to the value of the code. The
	  // assumption is that looking up astral identifier characters is
	  // rare.
	  function isInAstralSet(code, set) {
	    var pos = 0x10000
	    for (var i = 0; i < set.length; i += 2) {
	      pos += set[i]
	      if (pos > code) return false
	      pos += set[i + 1]
	      if (pos >= code) return true
	    }
	  }
	
	  // Test whether a given character code starts an identifier.
	
	  function isIdentifierStart(code, astral) {
	    if (code < 65) return code === 36
	    if (code < 91) return true
	    if (code < 97) return code === 95
	    if (code < 123) return true
	    if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code))
	    if (astral === false) return false
	    return isInAstralSet(code, astralIdentifierStartCodes)
	  }
	
	  // Test whether a given character is part of an identifier.
	
	  function isIdentifierChar(code, astral) {
	    if (code < 48) return code === 36
	    if (code < 58) return true
	    if (code < 65) return false
	    if (code < 91) return true
	    if (code < 97) return code === 95
	    if (code < 123) return true
	    if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code))
	    if (astral === false) return false
	    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
	  }
	
	  // ## Token types
	
	  // The assignment of fine-grained, information-carrying type objects
	  // allows the tokenizer to store the information it has about a
	  // token in a way that is very cheap for the parser to look up.
	
	  // All token type variables start with an underscore, to make them
	  // easy to recognize.
	
	  // The `beforeExpr` property is used to disambiguate between regular
	  // expressions and divisions. It is set on all token types that can
	  // be followed by an expression (thus, a slash after them would be a
	  // regular expression).
	  //
	  // The `startsExpr` property is used to check if the token ends a
	  // `yield` expression. It is set on all token types that either can
	  // directly start an expression (like a quotation mark) or can
	  // continue an expression (like the body of a string).
	  //
	  // `isLoop` marks a keyword as starting a loop, which is important
	  // to know when parsing a label, in order to allow or disallow
	  // continue jumps to that label.
	
	  var TokenType = function TokenType(label, conf) {
	    if ( conf === void 0 ) conf = {};
	
	    this.label = label
	    this.keyword = conf.keyword
	    this.beforeExpr = !!conf.beforeExpr
	    this.startsExpr = !!conf.startsExpr
	    this.isLoop = !!conf.isLoop
	    this.isAssign = !!conf.isAssign
	    this.prefix = !!conf.prefix
	    this.postfix = !!conf.postfix
	    this.binop = conf.binop || null
	    this.updateContext = null
	  };
	
	  function binop(name, prec) {
	    return new TokenType(name, {beforeExpr: true, binop: prec})
	  }
	  var beforeExpr = {beforeExpr: true};
	  var startsExpr = {startsExpr: true};
	  // Map keyword names to token types.
	
	  var keywordTypes = {}
	
	  // Succinct definitions of keyword token types
	  function kw(name, options) {
	    if ( options === void 0 ) options = {};
	
	    options.keyword = name
	    return keywordTypes[name] = new TokenType(name, options)
	  }
	
	  var tt = {
	    num: new TokenType("num", startsExpr),
	    regexp: new TokenType("regexp", startsExpr),
	    string: new TokenType("string", startsExpr),
	    name: new TokenType("name", startsExpr),
	    eof: new TokenType("eof"),
	
	    // Punctuation token types.
	    bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
	    bracketR: new TokenType("]"),
	    braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
	    braceR: new TokenType("}"),
	    parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
	    parenR: new TokenType(")"),
	    comma: new TokenType(",", beforeExpr),
	    semi: new TokenType(";", beforeExpr),
	    colon: new TokenType(":", beforeExpr),
	    dot: new TokenType("."),
	    question: new TokenType("?", beforeExpr),
	    arrow: new TokenType("=>", beforeExpr),
	    template: new TokenType("template"),
	    ellipsis: new TokenType("...", beforeExpr),
	    backQuote: new TokenType("`", startsExpr),
	    dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),
	
	    // Operators. These carry several kinds of properties to help the
	    // parser use them properly (the presence of these properties is
	    // what categorizes them as operators).
	    //
	    // `binop`, when present, specifies that this operator is a binary
	    // operator, and will refer to its precedence.
	    //
	    // `prefix` and `postfix` mark the operator as a prefix or postfix
	    // unary operator.
	    //
	    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
	    // binary operators with a very low precedence, that should result
	    // in AssignmentExpression nodes.
	
	    eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
	    assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
	    incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
	    prefix: new TokenType("prefix", {beforeExpr: true, prefix: true, startsExpr: true}),
	    logicalOR: binop("||", 1),
	    logicalAND: binop("&&", 2),
	    bitwiseOR: binop("|", 3),
	    bitwiseXOR: binop("^", 4),
	    bitwiseAND: binop("&", 5),
	    equality: binop("==/!=", 6),
	    relational: binop("</>", 7),
	    bitShift: binop("<</>>", 8),
	    plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
	    modulo: binop("%", 10),
	    star: binop("*", 10),
	    slash: binop("/", 10),
	    starstar: new TokenType("**", {beforeExpr: true}),
	
	    // Keyword token types.
	    _break: kw("break"),
	    _case: kw("case", beforeExpr),
	    _catch: kw("catch"),
	    _continue: kw("continue"),
	    _debugger: kw("debugger"),
	    _default: kw("default", beforeExpr),
	    _do: kw("do", {isLoop: true, beforeExpr: true}),
	    _else: kw("else", beforeExpr),
	    _finally: kw("finally"),
	    _for: kw("for", {isLoop: true}),
	    _function: kw("function", startsExpr),
	    _if: kw("if"),
	    _return: kw("return", beforeExpr),
	    _switch: kw("switch"),
	    _throw: kw("throw", beforeExpr),
	    _try: kw("try"),
	    _var: kw("var"),
	    _const: kw("const"),
	    _while: kw("while", {isLoop: true}),
	    _with: kw("with"),
	    _new: kw("new", {beforeExpr: true, startsExpr: true}),
	    _this: kw("this", startsExpr),
	    _super: kw("super", startsExpr),
	    _class: kw("class"),
	    _extends: kw("extends", beforeExpr),
	    _export: kw("export"),
	    _import: kw("import"),
	    _null: kw("null", startsExpr),
	    _true: kw("true", startsExpr),
	    _false: kw("false", startsExpr),
	    _in: kw("in", {beforeExpr: true, binop: 7}),
	    _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
	    _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
	    _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
	    _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
	  }
	
	  // Matches a whole line break (where CRLF is considered a single
	  // line break). Used to count lines.
	
	  var lineBreak = /\r\n?|\n|\u2028|\u2029/
	  var lineBreakG = new RegExp(lineBreak.source, "g")
	
	  function isNewLine(code) {
	    return code === 10 || code === 13 || code === 0x2028 || code == 0x2029
	  }
	
	  var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/
	
	  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g
	
	  function isArray(obj) {
	    return Object.prototype.toString.call(obj) === "[object Array]"
	  }
	
	  // Checks if an object has a property.
	
	  function has(obj, propName) {
	    return Object.prototype.hasOwnProperty.call(obj, propName)
	  }
	
	  // These are used when `options.locations` is on, for the
	  // `startLoc` and `endLoc` properties.
	
	  var Position = function Position(line, col) {
	    this.line = line
	    this.column = col
	  };
	
	  Position.prototype.offset = function offset (n) {
	    return new Position(this.line, this.column + n)
	  };
	
	  var SourceLocation = function SourceLocation(p, start, end) {
	    this.start = start
	    this.end = end
	    if (p.sourceFile !== null) this.source = p.sourceFile
	  };
	
	  // The `getLineInfo` function is mostly useful when the
	  // `locations` option is off (for performance reasons) and you
	  // want to find the line/column position for a given character
	  // offset. `input` should be the code string that the offset refers
	  // into.
	
	  function getLineInfo(input, offset) {
	    for (var line = 1, cur = 0;;) {
	      lineBreakG.lastIndex = cur
	      var match = lineBreakG.exec(input)
	      if (match && match.index < offset) {
	        ++line
	        cur = match.index + match[0].length
	      } else {
	        return new Position(line, offset - cur)
	      }
	    }
	  }
	
	  // A second optional argument can be given to further configure
	  // the parser process. These options are recognized:
	
	  var defaultOptions = {
	    // `ecmaVersion` indicates the ECMAScript version to parse. Must
	    // be either 3, or 5, or 6. This influences support for strict
	    // mode, the set of reserved words, support for getters and
	    // setters and other features. The default is 6.
	    ecmaVersion: 6,
	    // Source type ("script" or "module") for different semantics
	    sourceType: "script",
	    // `onInsertedSemicolon` can be a callback that will be called
	    // when a semicolon is automatically inserted. It will be passed
	    // th position of the comma as an offset, and if `locations` is
	    // enabled, it is given the location as a `{line, column}` object
	    // as second argument.
	    onInsertedSemicolon: null,
	    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
	    // trailing commas.
	    onTrailingComma: null,
	    // By default, reserved words are only enforced if ecmaVersion >= 5.
	    // Set `allowReserved` to a boolean value to explicitly turn this on
	    // an off. When this option has the value "never", reserved words
	    // and keywords can also not be used as property names.
	    allowReserved: null,
	    // When enabled, a return at the top level is not considered an
	    // error.
	    allowReturnOutsideFunction: false,
	    // When enabled, import/export statements are not constrained to
	    // appearing at the top of the program.
	    allowImportExportEverywhere: false,
	    // When enabled, hashbang directive in the beginning of file
	    // is allowed and treated as a line comment.
	    allowHashBang: false,
	    // When `locations` is on, `loc` properties holding objects with
	    // `start` and `end` properties in `{line, column}` form (with
	    // line being 1-based and column 0-based) will be attached to the
	    // nodes.
	    locations: false,
	    // A function can be passed as `onToken` option, which will
	    // cause Acorn to call that function with object in the same
	    // format as tokens returned from `tokenizer().getToken()`. Note
	    // that you are not allowed to call the parser from the
	    // callback—that will corrupt its internal state.
	    onToken: null,
	    // A function can be passed as `onComment` option, which will
	    // cause Acorn to call that function with `(block, text, start,
	    // end)` parameters whenever a comment is skipped. `block` is a
	    // boolean indicating whether this is a block (`/* */`) comment,
	    // `text` is the content of the comment, and `start` and `end` are
	    // character offsets that denote the start and end of the comment.
	    // When the `locations` option is on, two more parameters are
	    // passed, the full `{line, column}` locations of the start and
	    // end of the comments. Note that you are not allowed to call the
	    // parser from the callback—that will corrupt its internal state.
	    onComment: null,
	    // Nodes have their start and end characters offsets recorded in
	    // `start` and `end` properties (directly on the node, rather than
	    // the `loc` object, which holds line/column data. To also add a
	    // [semi-standardized][range] `range` property holding a `[start,
	    // end]` array with the same numbers, set the `ranges` option to
	    // `true`.
	    //
	    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
	    ranges: false,
	    // It is possible to parse multiple files into a single AST by
	    // passing the tree produced by parsing the first file as
	    // `program` option in subsequent parses. This will add the
	    // toplevel forms of the parsed file to the `Program` (top) node
	    // of an existing parse tree.
	    program: null,
	    // When `locations` is on, you can pass this to record the source
	    // file in every node's `loc` object.
	    sourceFile: null,
	    // This value, if given, is stored in every node, whether
	    // `locations` is on or off.
	    directSourceFile: null,
	    // When enabled, parenthesized expressions are represented by
	    // (non-standard) ParenthesizedExpression nodes
	    preserveParens: false,
	    plugins: {}
	  }
	
	  // Interpret and default an options object
	
	  function getOptions(opts) {
	    var options = {}
	    for (var opt in defaultOptions)
	      options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]
	    if (options.allowReserved == null)
	      options.allowReserved = options.ecmaVersion < 5
	
	    if (isArray(options.onToken)) {
	      var tokens = options.onToken
	      options.onToken = function (token) { return tokens.push(token); }
	    }
	    if (isArray(options.onComment))
	      options.onComment = pushComment(options, options.onComment)
	
	    return options
	  }
	
	  function pushComment(options, array) {
	    return function (block, text, start, end, startLoc, endLoc) {
	      var comment = {
	        type: block ? 'Block' : 'Line',
	        value: text,
	        start: start,
	        end: end
	      }
	      if (options.locations)
	        comment.loc = new SourceLocation(this, startLoc, endLoc)
	      if (options.ranges)
	        comment.range = [start, end]
	      array.push(comment)
	    }
	  }
	
	  // Registered plugins
	  var plugins = {}
	
	  function keywordRegexp(words) {
	    return new RegExp("^(" + words.replace(/ /g, "|") + ")$")
	  }
	
	  var Parser = function Parser(options, input, startPos) {
	    this.options = options = getOptions(options)
	    this.sourceFile = options.sourceFile
	    this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5])
	    var reserved = options.allowReserved ? "" :
	        reservedWords[options.ecmaVersion] + (options.sourceType == "module" ? " await" : "")
	    this.reservedWords = keywordRegexp(reserved)
	    var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict
	    this.reservedWordsStrict = keywordRegexp(reservedStrict)
	    this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + reservedWords.strictBind)
	    this.input = String(input)
	
	    // Used to signal to callers of `readWord1` whether the word
	    // contained any escape sequences. This is needed because words with
	    // escape sequences must not be interpreted as keywords.
	    this.containsEsc = false
	
	    // Load plugins
	    this.loadPlugins(options.plugins)
	
	    // Set up token state
	
	    // The current position of the tokenizer in the input.
	    if (startPos) {
	      this.pos = startPos
	      this.lineStart = Math.max(0, this.input.lastIndexOf("\n", startPos))
	      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length
	    } else {
	      this.pos = this.lineStart = 0
	      this.curLine = 1
	    }
	
	    // Properties of the current token:
	    // Its type
	    this.type = tt.eof
	    // For tokens that include more information than their type, the value
	    this.value = null
	    // Its start and end offset
	    this.start = this.end = this.pos
	    // And, if locations are used, the {line, column} object
	    // corresponding to those offsets
	    this.startLoc = this.endLoc = this.curPosition()
	
	    // Position information for the previous token
	    this.lastTokEndLoc = this.lastTokStartLoc = null
	    this.lastTokStart = this.lastTokEnd = this.pos
	
	    // The context stack is used to superficially track syntactic
	    // context to predict whether a regular expression is allowed in a
	    // given position.
	    this.context = this.initialContext()
	    this.exprAllowed = true
	
	    // Figure out if it's a module code.
	    this.strict = this.inModule = options.sourceType === "module"
	
	    // Used to signify the start of a potential arrow function
	    this.potentialArrowAt = -1
	
	    // Flags to track whether we are in a function, a generator.
	    this.inFunction = this.inGenerator = false
	    // Labels in scope.
	    this.labels = []
	
	    // If enabled, skip leading hashbang line.
	    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === '#!')
	      this.skipLineComment(2)
	  };
	
	  // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them
	  Parser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };
	  Parser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };
	
	  Parser.prototype.extend = function extend (name, f) {
	    this[name] = f(this[name])
	  };
	
	  Parser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {
	      var this$1 = this;
	
	    for (var name in pluginConfigs) {
	      var plugin = plugins[name]
	      if (!plugin) throw new Error("Plugin '" + name + "' not found")
	      plugin(this$1, pluginConfigs[name])
	    }
	  };
	
	  Parser.prototype.parse = function parse () {
	    var node = this.options.program || this.startNode()
	    this.nextToken()
	    return this.parseTopLevel(node)
	  };
	
	  var pp = Parser.prototype
	
	  // ## Parser utilities
	
	  // Test whether a statement node is the string literal `"use strict"`.
	
	  pp.isUseStrict = function(stmt) {
	    return this.options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" &&
	      stmt.expression.type === "Literal" &&
	      stmt.expression.raw.slice(1, -1) === "use strict"
	  }
	
	  // Predicate that tests whether the next token is of the given
	  // type, and if yes, consumes it as a side effect.
	
	  pp.eat = function(type) {
	    if (this.type === type) {
	      this.next()
	      return true
	    } else {
	      return false
	    }
	  }
	
	  // Tests whether parsed token is a contextual keyword.
	
	  pp.isContextual = function(name) {
	    return this.type === tt.name && this.value === name
	  }
	
	  // Consumes contextual keyword if possible.
	
	  pp.eatContextual = function(name) {
	    return this.value === name && this.eat(tt.name)
	  }
	
	  // Asserts that following token is given contextual keyword.
	
	  pp.expectContextual = function(name) {
	    if (!this.eatContextual(name)) this.unexpected()
	  }
	
	  // Test whether a semicolon can be inserted at the current position.
	
	  pp.canInsertSemicolon = function() {
	    return this.type === tt.eof ||
	      this.type === tt.braceR ||
	      lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
	  }
	
	  pp.insertSemicolon = function() {
	    if (this.canInsertSemicolon()) {
	      if (this.options.onInsertedSemicolon)
	        this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc)
	      return true
	    }
	  }
	
	  // Consume a semicolon, or, failing that, see if we are allowed to
	  // pretend that there is a semicolon at this position.
	
	  pp.semicolon = function() {
	    if (!this.eat(tt.semi) && !this.insertSemicolon()) this.unexpected()
	  }
	
	  pp.afterTrailingComma = function(tokType) {
	    if (this.type == tokType) {
	      if (this.options.onTrailingComma)
	        this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc)
	      this.next()
	      return true
	    }
	  }
	
	  // Expect a token of a given type. If found, consume it, otherwise,
	  // raise an unexpected token error.
	
	  pp.expect = function(type) {
	    this.eat(type) || this.unexpected()
	  }
	
	  // Raise an unexpected token error.
	
	  pp.unexpected = function(pos) {
	    this.raise(pos != null ? pos : this.start, "Unexpected token")
	  }
	
	  var DestructuringErrors = function DestructuringErrors() {
	    this.shorthandAssign = 0
	    this.trailingComma = 0
	  };
	
	  pp.checkPatternErrors = function(refDestructuringErrors, andThrow) {
	    var trailing = refDestructuringErrors && refDestructuringErrors.trailingComma
	    if (!andThrow) return !!trailing
	    if (trailing) this.raise(trailing, "Comma is not permitted after the rest element")
	  }
	
	  pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
	    var pos = refDestructuringErrors && refDestructuringErrors.shorthandAssign
	    if (!andThrow) return !!pos
	    if (pos) this.raise(pos, "Shorthand property assignments are valid only in destructuring patterns")
	  }
	
	  var pp$1 = Parser.prototype
	
	  // ### Statement parsing
	
	  // Parse a program. Initializes the parser, reads any number of
	  // statements, and wraps them in a Program node.  Optionally takes a
	  // `program` argument.  If present, the statements will be appended
	  // to its body instead of creating a new node.
	
	  pp$1.parseTopLevel = function(node) {
	    var this$1 = this;
	
	    var first = true
	    if (!node.body) node.body = []
	    while (this.type !== tt.eof) {
	      var stmt = this$1.parseStatement(true, true)
	      node.body.push(stmt)
	      if (first) {
	        if (this$1.isUseStrict(stmt)) this$1.setStrict(true)
	        first = false
	      }
	    }
	    this.next()
	    if (this.options.ecmaVersion >= 6) {
	      node.sourceType = this.options.sourceType
	    }
	    return this.finishNode(node, "Program")
	  }
	
	  var loopLabel = {kind: "loop"};
	  var switchLabel = {kind: "switch"};
	  pp$1.isLet = function() {
	    if (this.type !== tt.name || this.options.ecmaVersion < 6 || this.value != "let") return false
	    skipWhiteSpace.lastIndex = this.pos
	    var skip = skipWhiteSpace.exec(this.input)
	    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next)
	    if (nextCh === 91 || nextCh == 123) return true // '{' and '['
	    if (isIdentifierStart(nextCh, true)) {
	      for (var pos = next + 1; isIdentifierChar(this.input.charCodeAt(pos), true); ++pos) {}
	      var ident = this.input.slice(next, pos)
	      if (!this.isKeyword(ident)) return true
	    }
	    return false
	  }
	
	  // Parse a single statement.
	  //
	  // If expecting a statement and finding a slash operator, parse a
	  // regular expression literal. This is to handle cases like
	  // `if (foo) /blah/.exec(foo)`, where looking at the previous token
	  // does not help.
	
	  pp$1.parseStatement = function(declaration, topLevel) {
	    var starttype = this.type, node = this.startNode(), kind
	
	    if (this.isLet()) {
	      starttype = tt._var
	      kind = "let"
	    }
	
	    // Most types of statements are recognized by the keyword they
	    // start with. Many are trivial to parse, some require a bit of
	    // complexity.
	
	    switch (starttype) {
	    case tt._break: case tt._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
	    case tt._debugger: return this.parseDebuggerStatement(node)
	    case tt._do: return this.parseDoStatement(node)
	    case tt._for: return this.parseForStatement(node)
	    case tt._function:
	      if (!declaration && this.options.ecmaVersion >= 6) this.unexpected()
	      return this.parseFunctionStatement(node)
	    case tt._class:
	      if (!declaration) this.unexpected()
	      return this.parseClass(node, true)
	    case tt._if: return this.parseIfStatement(node)
	    case tt._return: return this.parseReturnStatement(node)
	    case tt._switch: return this.parseSwitchStatement(node)
	    case tt._throw: return this.parseThrowStatement(node)
	    case tt._try: return this.parseTryStatement(node)
	    case tt._const: case tt._var:
	      kind = kind || this.value
	      if (!declaration && kind != "var") this.unexpected()
	      return this.parseVarStatement(node, kind)
	    case tt._while: return this.parseWhileStatement(node)
	    case tt._with: return this.parseWithStatement(node)
	    case tt.braceL: return this.parseBlock()
	    case tt.semi: return this.parseEmptyStatement(node)
	    case tt._export:
	    case tt._import:
	      if (!this.options.allowImportExportEverywhere) {
	        if (!topLevel)
	          this.raise(this.start, "'import' and 'export' may only appear at the top level")
	        if (!this.inModule)
	          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")
	      }
	      return starttype === tt._import ? this.parseImport(node) : this.parseExport(node)
	
	      // If the statement does not start with a statement keyword or a
	      // brace, it's an ExpressionStatement or LabeledStatement. We
	      // simply start parsing an expression, and afterwards, if the
	      // next token is a colon and the expression was a simple
	      // Identifier node, we switch to interpreting it as a label.
	    default:
	      var maybeName = this.value, expr = this.parseExpression()
	      if (starttype === tt.name && expr.type === "Identifier" && this.eat(tt.colon))
	        return this.parseLabeledStatement(node, maybeName, expr)
	      else return this.parseExpressionStatement(node, expr)
	    }
	  }
	
	  pp$1.parseBreakContinueStatement = function(node, keyword) {
	    var this$1 = this;
	
	    var isBreak = keyword == "break"
	    this.next()
	    if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null
	    else if (this.type !== tt.name) this.unexpected()
	    else {
	      node.label = this.parseIdent()
	      this.semicolon()
	    }
	
	    // Verify that there is an actual destination to break or
	    // continue to.
	    for (var i = 0; i < this.labels.length; ++i) {
	      var lab = this$1.labels[i]
	      if (node.label == null || lab.name === node.label.name) {
	        if (lab.kind != null && (isBreak || lab.kind === "loop")) break
	        if (node.label && isBreak) break
	      }
	    }
	    if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword)
	    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
	  }
	
	  pp$1.parseDebuggerStatement = function(node) {
	    this.next()
	    this.semicolon()
	    return this.finishNode(node, "DebuggerStatement")
	  }
	
	  pp$1.parseDoStatement = function(node) {
	    this.next()
	    this.labels.push(loopLabel)
	    node.body = this.parseStatement(false)
	    this.labels.pop()
	    this.expect(tt._while)
	    node.test = this.parseParenExpression()
	    if (this.options.ecmaVersion >= 6)
	      this.eat(tt.semi)
	    else
	      this.semicolon()
	    return this.finishNode(node, "DoWhileStatement")
	  }
	
	  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
	  // loop is non-trivial. Basically, we have to parse the init `var`
	  // statement or expression, disallowing the `in` operator (see
	  // the second parameter to `parseExpression`), and then check
	  // whether the next token is `in` or `of`. When there is no init
	  // part (semicolon immediately after the opening parenthesis), it
	  // is a regular `for` loop.
	
	  pp$1.parseForStatement = function(node) {
	    this.next()
	    this.labels.push(loopLabel)
	    this.expect(tt.parenL)
	    if (this.type === tt.semi) return this.parseFor(node, null)
	    var isLet = this.isLet()
	    if (this.type === tt._var || this.type === tt._const || isLet) {
	      var init$1 = this.startNode(), kind = isLet ? "let" : this.value
	      this.next()
	      this.parseVar(init$1, true, kind)
	      this.finishNode(init$1, "VariableDeclaration")
	      if ((this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1 &&
	          !(kind !== "var" && init$1.declarations[0].init))
	        return this.parseForIn(node, init$1)
	      return this.parseFor(node, init$1)
	    }
	    var refDestructuringErrors = new DestructuringErrors
	    var init = this.parseExpression(true, refDestructuringErrors)
	    if (this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
	      this.checkPatternErrors(refDestructuringErrors, true)
	      this.toAssignable(init)
	      this.checkLVal(init)
	      return this.parseForIn(node, init)
	    } else {
	      this.checkExpressionErrors(refDestructuringErrors, true)
	    }
	    return this.parseFor(node, init)
	  }
	
	  pp$1.parseFunctionStatement = function(node) {
	    this.next()
	    return this.parseFunction(node, true)
	  }
	
	  pp$1.parseIfStatement = function(node) {
	    this.next()
	    node.test = this.parseParenExpression()
	    node.consequent = this.parseStatement(false)
	    node.alternate = this.eat(tt._else) ? this.parseStatement(false) : null
	    return this.finishNode(node, "IfStatement")
	  }
	
	  pp$1.parseReturnStatement = function(node) {
	    if (!this.inFunction && !this.options.allowReturnOutsideFunction)
	      this.raise(this.start, "'return' outside of function")
	    this.next()
	
	    // In `return` (and `break`/`continue`), the keywords with
	    // optional arguments, we eagerly look for a semicolon or the
	    // possibility to insert one.
	
	    if (this.eat(tt.semi) || this.insertSemicolon()) node.argument = null
	    else { node.argument = this.parseExpression(); this.semicolon() }
	    return this.finishNode(node, "ReturnStatement")
	  }
	
	  pp$1.parseSwitchStatement = function(node) {
	    var this$1 = this;
	
	    this.next()
	    node.discriminant = this.parseParenExpression()
	    node.cases = []
	    this.expect(tt.braceL)
	    this.labels.push(switchLabel)
	
	    // Statements under must be grouped (by label) in SwitchCase
	    // nodes. `cur` is used to keep the node that we are currently
	    // adding statements to.
	
	    for (var cur, sawDefault = false; this.type != tt.braceR;) {
	      if (this$1.type === tt._case || this$1.type === tt._default) {
	        var isCase = this$1.type === tt._case
	        if (cur) this$1.finishNode(cur, "SwitchCase")
	        node.cases.push(cur = this$1.startNode())
	        cur.consequent = []
	        this$1.next()
	        if (isCase) {
	          cur.test = this$1.parseExpression()
	        } else {
	          if (sawDefault) this$1.raiseRecoverable(this$1.lastTokStart, "Multiple default clauses")
	          sawDefault = true
	          cur.test = null
	        }
	        this$1.expect(tt.colon)
	      } else {
	        if (!cur) this$1.unexpected()
	        cur.consequent.push(this$1.parseStatement(true))
	      }
	    }
	    if (cur) this.finishNode(cur, "SwitchCase")
	    this.next() // Closing brace
	    this.labels.pop()
	    return this.finishNode(node, "SwitchStatement")
	  }
	
	  pp$1.parseThrowStatement = function(node) {
	    this.next()
	    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
	      this.raise(this.lastTokEnd, "Illegal newline after throw")
	    node.argument = this.parseExpression()
	    this.semicolon()
	    return this.finishNode(node, "ThrowStatement")
	  }
	
	  // Reused empty array added for node fields that are always empty.
	
	  var empty = []
	
	  pp$1.parseTryStatement = function(node) {
	    this.next()
	    node.block = this.parseBlock()
	    node.handler = null
	    if (this.type === tt._catch) {
	      var clause = this.startNode()
	      this.next()
	      this.expect(tt.parenL)
	      clause.param = this.parseBindingAtom()
	      this.checkLVal(clause.param, true)
	      this.expect(tt.parenR)
	      clause.body = this.parseBlock()
	      node.handler = this.finishNode(clause, "CatchClause")
	    }
	    node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null
	    if (!node.handler && !node.finalizer)
	      this.raise(node.start, "Missing catch or finally clause")
	    return this.finishNode(node, "TryStatement")
	  }
	
	  pp$1.parseVarStatement = function(node, kind) {
	    this.next()
	    this.parseVar(node, false, kind)
	    this.semicolon()
	    return this.finishNode(node, "VariableDeclaration")
	  }
	
	  pp$1.parseWhileStatement = function(node) {
	    this.next()
	    node.test = this.parseParenExpression()
	    this.labels.push(loopLabel)
	    node.body = this.parseStatement(false)
	    this.labels.pop()
	    return this.finishNode(node, "WhileStatement")
	  }
	
	  pp$1.parseWithStatement = function(node) {
	    if (this.strict) this.raise(this.start, "'with' in strict mode")
	    this.next()
	    node.object = this.parseParenExpression()
	    node.body = this.parseStatement(false)
	    return this.finishNode(node, "WithStatement")
	  }
	
	  pp$1.parseEmptyStatement = function(node) {
	    this.next()
	    return this.finishNode(node, "EmptyStatement")
	  }
	
	  pp$1.parseLabeledStatement = function(node, maybeName, expr) {
	    var this$1 = this;
	
	    for (var i = 0; i < this.labels.length; ++i)
	      if (this$1.labels[i].name === maybeName) this$1.raise(expr.start, "Label '" + maybeName + "' is already declared")
	    var kind = this.type.isLoop ? "loop" : this.type === tt._switch ? "switch" : null
	    for (var i$1 = this.labels.length - 1; i$1 >= 0; i$1--) {
	      var label = this$1.labels[i$1]
	      if (label.statementStart == node.start) {
	        label.statementStart = this$1.start
	        label.kind = kind
	      } else break
	    }
	    this.labels.push({name: maybeName, kind: kind, statementStart: this.start})
	    node.body = this.parseStatement(true)
	    this.labels.pop()
	    node.label = expr
	    return this.finishNode(node, "LabeledStatement")
	  }
	
	  pp$1.parseExpressionStatement = function(node, expr) {
	    node.expression = expr
	    this.semicolon()
	    return this.finishNode(node, "ExpressionStatement")
	  }
	
	  // Parse a semicolon-enclosed block of statements, handling `"use
	  // strict"` declarations when `allowStrict` is true (used for
	  // function bodies).
	
	  pp$1.parseBlock = function(allowStrict) {
	    var this$1 = this;
	
	    var node = this.startNode(), first = true, oldStrict
	    node.body = []
	    this.expect(tt.braceL)
	    while (!this.eat(tt.braceR)) {
	      var stmt = this$1.parseStatement(true)
	      node.body.push(stmt)
	      if (first && allowStrict && this$1.isUseStrict(stmt)) {
	        oldStrict = this$1.strict
	        this$1.setStrict(this$1.strict = true)
	      }
	      first = false
	    }
	    if (oldStrict === false) this.setStrict(false)
	    return this.finishNode(node, "BlockStatement")
	  }
	
	  // Parse a regular `for` loop. The disambiguation code in
	  // `parseStatement` will already have parsed the init statement or
	  // expression.
	
	  pp$1.parseFor = function(node, init) {
	    node.init = init
	    this.expect(tt.semi)
	    node.test = this.type === tt.semi ? null : this.parseExpression()
	    this.expect(tt.semi)
	    node.update = this.type === tt.parenR ? null : this.parseExpression()
	    this.expect(tt.parenR)
	    node.body = this.parseStatement(false)
	    this.labels.pop()
	    return this.finishNode(node, "ForStatement")
	  }
	
	  // Parse a `for`/`in` and `for`/`of` loop, which are almost
	  // same from parser's perspective.
	
	  pp$1.parseForIn = function(node, init) {
	    var type = this.type === tt._in ? "ForInStatement" : "ForOfStatement"
	    this.next()
	    node.left = init
	    node.right = this.parseExpression()
	    this.expect(tt.parenR)
	    node.body = this.parseStatement(false)
	    this.labels.pop()
	    return this.finishNode(node, type)
	  }
	
	  // Parse a list of variable declarations.
	
	  pp$1.parseVar = function(node, isFor, kind) {
	    var this$1 = this;
	
	    node.declarations = []
	    node.kind = kind
	    for (;;) {
	      var decl = this$1.startNode()
	      this$1.parseVarId(decl)
	      if (this$1.eat(tt.eq)) {
	        decl.init = this$1.parseMaybeAssign(isFor)
	      } else if (kind === "const" && !(this$1.type === tt._in || (this$1.options.ecmaVersion >= 6 && this$1.isContextual("of")))) {
	        this$1.unexpected()
	      } else if (decl.id.type != "Identifier" && !(isFor && (this$1.type === tt._in || this$1.isContextual("of")))) {
	        this$1.raise(this$1.lastTokEnd, "Complex binding patterns require an initialization value")
	      } else {
	        decl.init = null
	      }
	      node.declarations.push(this$1.finishNode(decl, "VariableDeclarator"))
	      if (!this$1.eat(tt.comma)) break
	    }
	    return node
	  }
	
	  pp$1.parseVarId = function(decl) {
	    decl.id = this.parseBindingAtom()
	    this.checkLVal(decl.id, true)
	  }
	
	  // Parse a function declaration or literal (depending on the
	  // `isStatement` parameter).
	
	  pp$1.parseFunction = function(node, isStatement, allowExpressionBody) {
	    this.initFunction(node)
	    if (this.options.ecmaVersion >= 6)
	      node.generator = this.eat(tt.star)
	    var oldInGen = this.inGenerator
	    this.inGenerator = node.generator
	    if (isStatement || this.type === tt.name)
	      node.id = this.parseIdent()
	    this.parseFunctionParams(node)
	    this.parseFunctionBody(node, allowExpressionBody)
	    this.inGenerator = oldInGen
	    return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression")
	  }
	
	  pp$1.parseFunctionParams = function(node) {
	    this.expect(tt.parenL)
	    node.params = this.parseBindingList(tt.parenR, false, false, true)
	  }
	
	  // Parse a class declaration or literal (depending on the
	  // `isStatement` parameter).
	
	  pp$1.parseClass = function(node, isStatement) {
	    var this$1 = this;
	
	    this.next()
	    this.parseClassId(node, isStatement)
	    this.parseClassSuper(node)
	    var classBody = this.startNode()
	    var hadConstructor = false
	    classBody.body = []
	    this.expect(tt.braceL)
	    while (!this.eat(tt.braceR)) {
	      if (this$1.eat(tt.semi)) continue
	      var method = this$1.startNode()
	      var isGenerator = this$1.eat(tt.star)
	      var isMaybeStatic = this$1.type === tt.name && this$1.value === "static"
	      this$1.parsePropertyName(method)
	      method.static = isMaybeStatic && this$1.type !== tt.parenL
	      if (method.static) {
	        if (isGenerator) this$1.unexpected()
	        isGenerator = this$1.eat(tt.star)
	        this$1.parsePropertyName(method)
	      }
	      method.kind = "method"
	      var isGetSet = false
	      if (!method.computed) {
	        var key = method.key;
	        if (!isGenerator && key.type === "Identifier" && this$1.type !== tt.parenL && (key.name === "get" || key.name === "set")) {
	          isGetSet = true
	          method.kind = key.name
	          key = this$1.parsePropertyName(method)
	        }
	        if (!method.static && (key.type === "Identifier" && key.name === "constructor" ||
	            key.type === "Literal" && key.value === "constructor")) {
	          if (hadConstructor) this$1.raise(key.start, "Duplicate constructor in the same class")
	          if (isGetSet) this$1.raise(key.start, "Constructor can't have get/set modifier")
	          if (isGenerator) this$1.raise(key.start, "Constructor can't be a generator")
	          method.kind = "constructor"
	          hadConstructor = true
	        }
	      }
	      this$1.parseClassMethod(classBody, method, isGenerator)
	      if (isGetSet) {
	        var paramCount = method.kind === "get" ? 0 : 1
	        if (method.value.params.length !== paramCount) {
	          var start = method.value.start
	          if (method.kind === "get")
	            this$1.raiseRecoverable(start, "getter should have no params")
	          else
	            this$1.raiseRecoverable(start, "setter should have exactly one param")
	        }
	        if (method.kind === "set" && method.value.params[0].type === "RestElement")
	          this$1.raise(method.value.params[0].start, "Setter cannot use rest params")
	      }
	    }
	    node.body = this.finishNode(classBody, "ClassBody")
	    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
	  }
	
	  pp$1.parseClassMethod = function(classBody, method, isGenerator) {
	    method.value = this.parseMethod(isGenerator)
	    classBody.body.push(this.finishNode(method, "MethodDefinition"))
	  }
	
	  pp$1.parseClassId = function(node, isStatement) {
	    node.id = this.type === tt.name ? this.parseIdent() : isStatement ? this.unexpected() : null
	  }
	
	  pp$1.parseClassSuper = function(node) {
	    node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null
	  }
	
	  // Parses module export declaration.
	
	  pp$1.parseExport = function(node) {
	    var this$1 = this;
	
	    this.next()
	    // export * from '...'
	    if (this.eat(tt.star)) {
	      this.expectContextual("from")
	      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()
	      this.semicolon()
	      return this.finishNode(node, "ExportAllDeclaration")
	    }
	    if (this.eat(tt._default)) { // export default ...
	      var parens = this.type == tt.parenL
	      var expr = this.parseMaybeAssign()
	      var needsSemi = true
	      if (!parens && (expr.type == "FunctionExpression" ||
	                      expr.type == "ClassExpression")) {
	        needsSemi = false
	        if (expr.id) {
	          expr.type = expr.type == "FunctionExpression"
	            ? "FunctionDeclaration"
	            : "ClassDeclaration"
	        }
	      }
	      node.declaration = expr
	      if (needsSemi) this.semicolon()
	      return this.finishNode(node, "ExportDefaultDeclaration")
	    }
	    // export var|const|let|function|class ...
	    if (this.shouldParseExportStatement()) {
	      node.declaration = this.parseStatement(true)
	      node.specifiers = []
	      node.source = null
	    } else { // export { x, y as z } [from '...']
	      node.declaration = null
	      node.specifiers = this.parseExportSpecifiers()
	      if (this.eatContextual("from")) {
	        node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()
	      } else {
	        // check for keywords used as local names
	        for (var i = 0; i < node.specifiers.length; i++) {
	          if (this$1.keywords.test(node.specifiers[i].local.name) || this$1.reservedWords.test(node.specifiers[i].local.name)) {
	            this$1.unexpected(node.specifiers[i].local.start)
	          }
	        }
	
	        node.source = null
	      }
	      this.semicolon()
	    }
	    return this.finishNode(node, "ExportNamedDeclaration")
	  }
	
	  pp$1.shouldParseExportStatement = function() {
	    return this.type.keyword || this.isLet()
	  }
	
	  // Parses a comma-separated list of module exports.
	
	  pp$1.parseExportSpecifiers = function() {
	    var this$1 = this;
	
	    var nodes = [], first = true
	    // export { x, y as z } [from '...']
	    this.expect(tt.braceL)
	    while (!this.eat(tt.braceR)) {
	      if (!first) {
	        this$1.expect(tt.comma)
	        if (this$1.afterTrailingComma(tt.braceR)) break
	      } else first = false
	
	      var node = this$1.startNode()
	      node.local = this$1.parseIdent(this$1.type === tt._default)
	      node.exported = this$1.eatContextual("as") ? this$1.parseIdent(true) : node.local
	      nodes.push(this$1.finishNode(node, "ExportSpecifier"))
	    }
	    return nodes
	  }
	
	  // Parses import declaration.
	
	  pp$1.parseImport = function(node) {
	    this.next()
	    // import '...'
	    if (this.type === tt.string) {
	      node.specifiers = empty
	      node.source = this.parseExprAtom()
	    } else {
	      node.specifiers = this.parseImportSpecifiers()
	      this.expectContextual("from")
	      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()
	    }
	    this.semicolon()
	    return this.finishNode(node, "ImportDeclaration")
	  }
	
	  // Parses a comma-separated list of module imports.
	
	  pp$1.parseImportSpecifiers = function() {
	    var this$1 = this;
	
	    var nodes = [], first = true
	    if (this.type === tt.name) {
	      // import defaultObj, { x, y as z } from '...'
	      var node = this.startNode()
	      node.local = this.parseIdent()
	      this.checkLVal(node.local, true)
	      nodes.push(this.finishNode(node, "ImportDefaultSpecifier"))
	      if (!this.eat(tt.comma)) return nodes
	    }
	    if (this.type === tt.star) {
	      var node$1 = this.startNode()
	      this.next()
	      this.expectContextual("as")
	      node$1.local = this.parseIdent()
	      this.checkLVal(node$1.local, true)
	      nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"))
	      return nodes
	    }
	    this.expect(tt.braceL)
	    while (!this.eat(tt.braceR)) {
	      if (!first) {
	        this$1.expect(tt.comma)
	        if (this$1.afterTrailingComma(tt.braceR)) break
	      } else first = false
	
	      var node$2 = this$1.startNode()
	      node$2.imported = this$1.parseIdent(true)
	      if (this$1.eatContextual("as")) {
	        node$2.local = this$1.parseIdent()
	      } else {
	        node$2.local = node$2.imported
	        if (this$1.isKeyword(node$2.local.name)) this$1.unexpected(node$2.local.start)
	        if (this$1.reservedWordsStrict.test(node$2.local.name)) this$1.raise(node$2.local.start, "The keyword '" + node$2.local.name + "' is reserved")
	      }
	      this$1.checkLVal(node$2.local, true)
	      nodes.push(this$1.finishNode(node$2, "ImportSpecifier"))
	    }
	    return nodes
	  }
	
	  var pp$2 = Parser.prototype
	
	  // Convert existing expression atom to assignable pattern
	  // if possible.
	
	  pp$2.toAssignable = function(node, isBinding) {
	    var this$1 = this;
	
	    if (this.options.ecmaVersion >= 6 && node) {
	      switch (node.type) {
	      case "Identifier":
	      case "ObjectPattern":
	      case "ArrayPattern":
	        break
	
	      case "ObjectExpression":
	        node.type = "ObjectPattern"
	        for (var i = 0; i < node.properties.length; i++) {
	          var prop = node.properties[i]
	          if (prop.kind !== "init") this$1.raise(prop.key.start, "Object pattern can't contain getter or setter")
	          this$1.toAssignable(prop.value, isBinding)
	        }
	        break
	
	      case "ArrayExpression":
	        node.type = "ArrayPattern"
	        this.toAssignableList(node.elements, isBinding)
	        break
	
	      case "AssignmentExpression":
	        if (node.operator === "=") {
	          node.type = "AssignmentPattern"
	          delete node.operator
	          // falls through to AssignmentPattern
	        } else {
	          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.")
	          break
	        }
	
	      case "AssignmentPattern":
	        if (node.right.type === "YieldExpression")
	          this.raise(node.right.start, "Yield expression cannot be a default value")
	        break
	
	      case "ParenthesizedExpression":
	        node.expression = this.toAssignable(node.expression, isBinding)
	        break
	
	      case "MemberExpression":
	        if (!isBinding) break
	
	      default:
	        this.raise(node.start, "Assigning to rvalue")
	      }
	    }
	    return node
	  }
	
	  // Convert list of expression atoms to binding list.
	
	  pp$2.toAssignableList = function(exprList, isBinding) {
	    var this$1 = this;
	
	    var end = exprList.length
	    if (end) {
	      var last = exprList[end - 1]
	      if (last && last.type == "RestElement") {
	        --end
	      } else if (last && last.type == "SpreadElement") {
	        last.type = "RestElement"
	        var arg = last.argument
	        this.toAssignable(arg, isBinding)
	        if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern")
	          this.unexpected(arg.start)
	        --end
	      }
	
	      if (isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
	        this.unexpected(last.argument.start)
	    }
	    for (var i = 0; i < end; i++) {
	      var elt = exprList[i]
	      if (elt) this$1.toAssignable(elt, isBinding)
	    }
	    return exprList
	  }
	
	  // Parses spread element.
	
	  pp$2.parseSpread = function(refDestructuringErrors) {
	    var node = this.startNode()
	    this.next()
	    node.argument = this.parseMaybeAssign(false, refDestructuringErrors)
	    return this.finishNode(node, "SpreadElement")
	  }
	
	  pp$2.parseRest = function(allowNonIdent) {
	    var node = this.startNode()
	    this.next()
	
	    // RestElement inside of a function parameter must be an identifier
	    if (allowNonIdent) node.argument = this.type === tt.name ? this.parseIdent() : this.unexpected()
	    else node.argument = this.type === tt.name || this.type === tt.bracketL ? this.parseBindingAtom() : this.unexpected()
	
	    return this.finishNode(node, "RestElement")
	  }
	
	  // Parses lvalue (assignable) atom.
	
	  pp$2.parseBindingAtom = function() {
	    if (this.options.ecmaVersion < 6) return this.parseIdent()
	    switch (this.type) {
	    case tt.name:
	      return this.parseIdent()
	
	    case tt.bracketL:
	      var node = this.startNode()
	      this.next()
	      node.elements = this.parseBindingList(tt.bracketR, true, true)
	      return this.finishNode(node, "ArrayPattern")
	
	    case tt.braceL:
	      return this.parseObj(true)
	
	    default:
	      this.unexpected()
	    }
	  }
	
	  pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowNonIdent) {
	    var this$1 = this;
	
	    var elts = [], first = true
	    while (!this.eat(close)) {
	      if (first) first = false
	      else this$1.expect(tt.comma)
	      if (allowEmpty && this$1.type === tt.comma) {
	        elts.push(null)
	      } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {
	        break
	      } else if (this$1.type === tt.ellipsis) {
	        var rest = this$1.parseRest(allowNonIdent)
	        this$1.parseBindingListItem(rest)
	        elts.push(rest)
	        if (this$1.type === tt.comma) this$1.raise(this$1.start, "Comma is not permitted after the rest element")
	        this$1.expect(close)
	        break
	      } else {
	        var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc)
	        this$1.parseBindingListItem(elem)
	        elts.push(elem)
	      }
	    }
	    return elts
	  }
	
	  pp$2.parseBindingListItem = function(param) {
	    return param
	  }
	
	  // Parses assignment pattern around given atom if possible.
	
	  pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
	    left = left || this.parseBindingAtom()
	    if (this.options.ecmaVersion < 6 || !this.eat(tt.eq)) return left
	    var node = this.startNodeAt(startPos, startLoc)
	    node.left = left
	    node.right = this.parseMaybeAssign()
	    return this.finishNode(node, "AssignmentPattern")
	  }
	
	  // Verify that a node is an lval — something that can be assigned
	  // to.
	
	  pp$2.checkLVal = function(expr, isBinding, checkClashes) {
	    var this$1 = this;
	
	    switch (expr.type) {
	    case "Identifier":
	      if (this.strict && this.reservedWordsStrictBind.test(expr.name))
	        this.raiseRecoverable(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode")
	      if (checkClashes) {
	        if (has(checkClashes, expr.name))
	          this.raiseRecoverable(expr.start, "Argument name clash")
	        checkClashes[expr.name] = true
	      }
	      break
	
	    case "MemberExpression":
	      if (isBinding) this.raiseRecoverable(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression")
	      break
	
	    case "ObjectPattern":
	      for (var i = 0; i < expr.properties.length; i++)
	        this$1.checkLVal(expr.properties[i].value, isBinding, checkClashes)
	      break
	
	    case "ArrayPattern":
	      for (var i$1 = 0; i$1 < expr.elements.length; i$1++) {
	        var elem = expr.elements[i$1]
	        if (elem) this$1.checkLVal(elem, isBinding, checkClashes)
	      }
	      break
	
	    case "AssignmentPattern":
	      this.checkLVal(expr.left, isBinding, checkClashes)
	      break
	
	    case "RestElement":
	      this.checkLVal(expr.argument, isBinding, checkClashes)
	      break
	
	    case "ParenthesizedExpression":
	      this.checkLVal(expr.expression, isBinding, checkClashes)
	      break
	
	    default:
	      this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " rvalue")
	    }
	  }
	
	  var pp$3 = Parser.prototype
	
	  // Check if property name clashes with already added.
	  // Object/class getters and setters are not allowed to clash —
	  // either with each other or with an init property — and in
	  // strict mode, init properties are also not allowed to be repeated.
	
	  pp$3.checkPropClash = function(prop, propHash) {
	    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
	      return
	    var key = prop.key;
	    var name
	    switch (key.type) {
	    case "Identifier": name = key.name; break
	    case "Literal": name = String(key.value); break
	    default: return
	    }
	    var kind = prop.kind;
	    if (this.options.ecmaVersion >= 6) {
	      if (name === "__proto__" && kind === "init") {
	        if (propHash.proto) this.raiseRecoverable(key.start, "Redefinition of __proto__ property")
	        propHash.proto = true
	      }
	      return
	    }
	    name = "$" + name
	    var other = propHash[name]
	    if (other) {
	      var isGetSet = kind !== "init"
	      if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init))
	        this.raiseRecoverable(key.start, "Redefinition of property")
	    } else {
	      other = propHash[name] = {
	        init: false,
	        get: false,
	        set: false
	      }
	    }
	    other[kind] = true
	  }
	
	  // ### Expression parsing
	
	  // These nest, from the most general expression type at the top to
	  // 'atomic', nondivisible expression types at the bottom. Most of
	  // the functions will simply let the function(s) below them parse,
	  // and, *if* the syntactic construct they handle is present, wrap
	  // the AST node that the inner parser gave them in another node.
	
	  // Parse a full expression. The optional arguments are used to
	  // forbid the `in` operator (in for loops initalization expressions)
	  // and provide reference for storing '=' operator inside shorthand
	  // property assignment in contexts where both object expression
	  // and object pattern might appear (so it's possible to raise
	  // delayed syntax error at correct position).
	
	  pp$3.parseExpression = function(noIn, refDestructuringErrors) {
	    var this$1 = this;
	
	    var startPos = this.start, startLoc = this.startLoc
	    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors)
	    if (this.type === tt.comma) {
	      var node = this.startNodeAt(startPos, startLoc)
	      node.expressions = [expr]
	      while (this.eat(tt.comma)) node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors))
	      return this.finishNode(node, "SequenceExpression")
	    }
	    return expr
	  }
	
	  // Parse an assignment expression. This includes applications of
	  // operators like `+=`.
	
	  pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
	    if (this.inGenerator && this.isContextual("yield")) return this.parseYield()
	
	    var ownDestructuringErrors = false
	    if (!refDestructuringErrors) {
	      refDestructuringErrors = new DestructuringErrors
	      ownDestructuringErrors = true
	    }
	    var startPos = this.start, startLoc = this.startLoc
	    if (this.type == tt.parenL || this.type == tt.name)
	      this.potentialArrowAt = this.start
	    var left = this.parseMaybeConditional(noIn, refDestructuringErrors)
	    if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc)
	    if (this.type.isAssign) {
	      this.checkPatternErrors(refDestructuringErrors, true)
	      if (!ownDestructuringErrors) DestructuringErrors.call(refDestructuringErrors)
	      var node = this.startNodeAt(startPos, startLoc)
	      node.operator = this.value
	      node.left = this.type === tt.eq ? this.toAssignable(left) : left
	      refDestructuringErrors.shorthandAssign = 0 // reset because shorthand default was used correctly
	      this.checkLVal(left)
	      this.next()
	      node.right = this.parseMaybeAssign(noIn)
	      return this.finishNode(node, "AssignmentExpression")
	    } else {
	      if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true)
	    }
	    return left
	  }
	
	  // Parse a ternary conditional (`?:`) operator.
	
	  pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
	    var startPos = this.start, startLoc = this.startLoc
	    var expr = this.parseExprOps(noIn, refDestructuringErrors)
	    if (this.checkExpressionErrors(refDestructuringErrors)) return expr
	    if (this.eat(tt.question)) {
	      var node = this.startNodeAt(startPos, startLoc)
	      node.test = expr
	      node.consequent = this.parseMaybeAssign()
	      this.expect(tt.colon)
	      node.alternate = this.parseMaybeAssign(noIn)
	      return this.finishNode(node, "ConditionalExpression")
	    }
	    return expr
	  }
	
	  // Start the precedence parser.
	
	  pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
	    var startPos = this.start, startLoc = this.startLoc
	    var expr = this.parseMaybeUnary(refDestructuringErrors, false)
	    if (this.checkExpressionErrors(refDestructuringErrors)) return expr
	    return this.parseExprOp(expr, startPos, startLoc, -1, noIn)
	  }
	
	  // Parse binary operators with the operator precedence parsing
	  // algorithm. `left` is the left-hand side of the operator.
	  // `minPrec` provides context that allows the function to stop and
	  // defer further parser to one of its callers when it encounters an
	  // operator that has a lower precedence than the set it is parsing.
	
	  pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
	    var prec = this.type.binop
	    if (prec != null && (!noIn || this.type !== tt._in)) {
	      if (prec > minPrec) {
	        var logical = this.type === tt.logicalOR || this.type === tt.logicalAND
	        var op = this.value
	        this.next()
	        var startPos = this.start, startLoc = this.startLoc
	        var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn)
	        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical)
	        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
	      }
	    }
	    return left
	  }
	
	  pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
	    var node = this.startNodeAt(startPos, startLoc)
	    node.left = left
	    node.operator = op
	    node.right = right
	    return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
	  }
	
	  // Parse unary operators, both prefix and postfix.
	
	  pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
	    var this$1 = this;
	
	    var startPos = this.start, startLoc = this.startLoc, expr
	    if (this.type.prefix) {
	      var node = this.startNode(), update = this.type === tt.incDec
	      node.operator = this.value
	      node.prefix = true
	      this.next()
	      node.argument = this.parseMaybeUnary(null, true)
	      this.checkExpressionErrors(refDestructuringErrors, true)
	      if (update) this.checkLVal(node.argument)
	      else if (this.strict && node.operator === "delete" &&
	               node.argument.type === "Identifier")
	        this.raiseRecoverable(node.start, "Deleting local variable in strict mode")
	      else sawUnary = true
	      expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression")
	    } else {
	      expr = this.parseExprSubscripts(refDestructuringErrors)
	      if (this.checkExpressionErrors(refDestructuringErrors)) return expr
	      while (this.type.postfix && !this.canInsertSemicolon()) {
	        var node$1 = this$1.startNodeAt(startPos, startLoc)
	        node$1.operator = this$1.value
	        node$1.prefix = false
	        node$1.argument = expr
	        this$1.checkLVal(expr)
	        this$1.next()
	        expr = this$1.finishNode(node$1, "UpdateExpression")
	      }
	    }
	
	    if (!sawUnary && this.eat(tt.starstar))
	      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false)
	    else
	      return expr
	  }
	
	  // Parse call, dot, and `[]`-subscript expressions.
	
	  pp$3.parseExprSubscripts = function(refDestructuringErrors) {
	    var startPos = this.start, startLoc = this.startLoc
	    var expr = this.parseExprAtom(refDestructuringErrors)
	    var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")"
	    if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr
	    return this.parseSubscripts(expr, startPos, startLoc)
	  }
	
	  pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
	    var this$1 = this;
	
	    for (;;) {
	      if (this$1.eat(tt.dot)) {
	        var node = this$1.startNodeAt(startPos, startLoc)
	        node.object = base
	        node.property = this$1.parseIdent(true)
	        node.computed = false
	        base = this$1.finishNode(node, "MemberExpression")
	      } else if (this$1.eat(tt.bracketL)) {
	        var node$1 = this$1.startNodeAt(startPos, startLoc)
	        node$1.object = base
	        node$1.property = this$1.parseExpression()
	        node$1.computed = true
	        this$1.expect(tt.bracketR)
	        base = this$1.finishNode(node$1, "MemberExpression")
	      } else if (!noCalls && this$1.eat(tt.parenL)) {
	        var node$2 = this$1.startNodeAt(startPos, startLoc)
	        node$2.callee = base
	        node$2.arguments = this$1.parseExprList(tt.parenR, false)
	        base = this$1.finishNode(node$2, "CallExpression")
	      } else if (this$1.type === tt.backQuote) {
	        var node$3 = this$1.startNodeAt(startPos, startLoc)
	        node$3.tag = base
	        node$3.quasi = this$1.parseTemplate()
	        base = this$1.finishNode(node$3, "TaggedTemplateExpression")
	      } else {
	        return base
	      }
	    }
	  }
	
	  // Parse an atomic expression — either a single token that is an
	  // expression, an expression started by a keyword like `function` or
	  // `new`, or an expression wrapped in punctuation like `()`, `[]`,
	  // or `{}`.
	
	  pp$3.parseExprAtom = function(refDestructuringErrors) {
	    var node, canBeArrow = this.potentialArrowAt == this.start
	    switch (this.type) {
	    case tt._super:
	      if (!this.inFunction)
	        this.raise(this.start, "'super' outside of function or class")
	
	    case tt._this:
	      var type = this.type === tt._this ? "ThisExpression" : "Super"
	      node = this.startNode()
	      this.next()
	      return this.finishNode(node, type)
	
	    case tt.name:
	      var startPos = this.start, startLoc = this.startLoc
	      var id = this.parseIdent(this.type !== tt.name)
	      if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow))
	        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id])
	      return id
	
	    case tt.regexp:
	      var value = this.value
	      node = this.parseLiteral(value.value)
	      node.regex = {pattern: value.pattern, flags: value.flags}
	      return node
	
	    case tt.num: case tt.string:
	      return this.parseLiteral(this.value)
	
	    case tt._null: case tt._true: case tt._false:
	      node = this.startNode()
	      node.value = this.type === tt._null ? null : this.type === tt._true
	      node.raw = this.type.keyword
	      this.next()
	      return this.finishNode(node, "Literal")
	
	    case tt.parenL:
	      return this.parseParenAndDistinguishExpression(canBeArrow)
	
	    case tt.bracketL:
	      node = this.startNode()
	      this.next()
	      node.elements = this.parseExprList(tt.bracketR, true, true, refDestructuringErrors)
	      return this.finishNode(node, "ArrayExpression")
	
	    case tt.braceL:
	      return this.parseObj(false, refDestructuringErrors)
	
	    case tt._function:
	      node = this.startNode()
	      this.next()
	      return this.parseFunction(node, false)
	
	    case tt._class:
	      return this.parseClass(this.startNode(), false)
	
	    case tt._new:
	      return this.parseNew()
	
	    case tt.backQuote:
	      return this.parseTemplate()
	
	    default:
	      this.unexpected()
	    }
	  }
	
	  pp$3.parseLiteral = function(value) {
	    var node = this.startNode()
	    node.value = value
	    node.raw = this.input.slice(this.start, this.end)
	    this.next()
	    return this.finishNode(node, "Literal")
	  }
	
	  pp$3.parseParenExpression = function() {
	    this.expect(tt.parenL)
	    var val = this.parseExpression()
	    this.expect(tt.parenR)
	    return val
	  }
	
	  pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
	    var this$1 = this;
	
	    var startPos = this.start, startLoc = this.startLoc, val
	    if (this.options.ecmaVersion >= 6) {
	      this.next()
	
	      var innerStartPos = this.start, innerStartLoc = this.startLoc
	      var exprList = [], first = true
	      var refDestructuringErrors = new DestructuringErrors, spreadStart, innerParenStart
	      while (this.type !== tt.parenR) {
	        first ? first = false : this$1.expect(tt.comma)
	        if (this$1.type === tt.ellipsis) {
	          spreadStart = this$1.start
	          exprList.push(this$1.parseParenItem(this$1.parseRest()))
	          break
	        } else {
	          if (this$1.type === tt.parenL && !innerParenStart) {
	            innerParenStart = this$1.start
	          }
	          exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem))
	        }
	      }
	      var innerEndPos = this.start, innerEndLoc = this.startLoc
	      this.expect(tt.parenR)
	
	      if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) {
	        this.checkPatternErrors(refDestructuringErrors, true)
	        if (innerParenStart) this.unexpected(innerParenStart)
	        return this.parseParenArrowList(startPos, startLoc, exprList)
	      }
	
	      if (!exprList.length) this.unexpected(this.lastTokStart)
	      if (spreadStart) this.unexpected(spreadStart)
	      this.checkExpressionErrors(refDestructuringErrors, true)
	
	      if (exprList.length > 1) {
	        val = this.startNodeAt(innerStartPos, innerStartLoc)
	        val.expressions = exprList
	        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc)
	      } else {
	        val = exprList[0]
	      }
	    } else {
	      val = this.parseParenExpression()
	    }
	
	    if (this.options.preserveParens) {
	      var par = this.startNodeAt(startPos, startLoc)
	      par.expression = val
	      return this.finishNode(par, "ParenthesizedExpression")
	    } else {
	      return val
	    }
	  }
	
	  pp$3.parseParenItem = function(item) {
	    return item
	  }
	
	  pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
	    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
	  }
	
	  // New's precedence is slightly tricky. It must allow its argument to
	  // be a `[]` or dot subscript expression, but not a call — at least,
	  // not without wrapping it in parentheses. Thus, it uses the noCalls
	  // argument to parseSubscripts to prevent it from consuming the
	  // argument list.
	
	  var empty$1 = []
	
	  pp$3.parseNew = function() {
	    var node = this.startNode()
	    var meta = this.parseIdent(true)
	    if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {
	      node.meta = meta
	      node.property = this.parseIdent(true)
	      if (node.property.name !== "target")
	        this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target")
	      if (!this.inFunction)
	        this.raiseRecoverable(node.start, "new.target can only be used in functions")
	      return this.finishNode(node, "MetaProperty")
	    }
	    var startPos = this.start, startLoc = this.startLoc
	    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true)
	    if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, false)
	    else node.arguments = empty$1
	    return this.finishNode(node, "NewExpression")
	  }
	
	  // Parse template expression.
	
	  pp$3.parseTemplateElement = function() {
	    var elem = this.startNode()
	    elem.value = {
	      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, '\n'),
	      cooked: this.value
	    }
	    this.next()
	    elem.tail = this.type === tt.backQuote
	    return this.finishNode(elem, "TemplateElement")
	  }
	
	  pp$3.parseTemplate = function() {
	    var this$1 = this;
	
	    var node = this.startNode()
	    this.next()
	    node.expressions = []
	    var curElt = this.parseTemplateElement()
	    node.quasis = [curElt]
	    while (!curElt.tail) {
	      this$1.expect(tt.dollarBraceL)
	      node.expressions.push(this$1.parseExpression())
	      this$1.expect(tt.braceR)
	      node.quasis.push(curElt = this$1.parseTemplateElement())
	    }
	    this.next()
	    return this.finishNode(node, "TemplateLiteral")
	  }
	
	  // Parse an object literal or binding pattern.
	
	  pp$3.parseObj = function(isPattern, refDestructuringErrors) {
	    var this$1 = this;
	
	    var node = this.startNode(), first = true, propHash = {}
	    node.properties = []
	    this.next()
	    while (!this.eat(tt.braceR)) {
	      if (!first) {
	        this$1.expect(tt.comma)
	        if (this$1.afterTrailingComma(tt.braceR)) break
	      } else first = false
	
	      var prop = this$1.startNode(), isGenerator, startPos, startLoc
	      if (this$1.options.ecmaVersion >= 6) {
	        prop.method = false
	        prop.shorthand = false
	        if (isPattern || refDestructuringErrors) {
	          startPos = this$1.start
	          startLoc = this$1.startLoc
	        }
	        if (!isPattern)
	          isGenerator = this$1.eat(tt.star)
	      }
	      this$1.parsePropertyName(prop)
	      this$1.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors)
	      this$1.checkPropClash(prop, propHash)
	      node.properties.push(this$1.finishNode(prop, "Property"))
	    }
	    return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
	  }
	
	  pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors) {
	    if (this.eat(tt.colon)) {
	      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors)
	      prop.kind = "init"
	    } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {
	      if (isPattern) this.unexpected()
	      prop.kind = "init"
	      prop.method = true
	      prop.value = this.parseMethod(isGenerator)
	    } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
	               (prop.key.name === "get" || prop.key.name === "set") &&
	               (this.type != tt.comma && this.type != tt.braceR)) {
	      if (isGenerator || isPattern) this.unexpected()
	      prop.kind = prop.key.name
	      this.parsePropertyName(prop)
	      prop.value = this.parseMethod(false)
	      var paramCount = prop.kind === "get" ? 0 : 1
	      if (prop.value.params.length !== paramCount) {
	        var start = prop.value.start
	        if (prop.kind === "get")
	          this.raiseRecoverable(start, "getter should have no params")
	        else
	          this.raiseRecoverable(start, "setter should have exactly one param")
	      }
	      if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
	        this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params")
	    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
	      if (this.keywords.test(prop.key.name) ||
	          (this.strict ? this.reservedWordsStrictBind : this.reservedWords).test(prop.key.name) ||
	          (this.inGenerator && prop.key.name == "yield"))
	        this.raiseRecoverable(prop.key.start, "'" + prop.key.name + "' can not be used as shorthand property")
	      prop.kind = "init"
	      if (isPattern) {
	        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)
	      } else if (this.type === tt.eq && refDestructuringErrors) {
	        if (!refDestructuringErrors.shorthandAssign)
	          refDestructuringErrors.shorthandAssign = this.start
	        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)
	      } else {
	        prop.value = prop.key
	      }
	      prop.shorthand = true
	    } else this.unexpected()
	  }
	
	  pp$3.parsePropertyName = function(prop) {
	    if (this.options.ecmaVersion >= 6) {
	      if (this.eat(tt.bracketL)) {
	        prop.computed = true
	        prop.key = this.parseMaybeAssign()
	        this.expect(tt.bracketR)
	        return prop.key
	      } else {
	        prop.computed = false
	      }
	    }
	    return prop.key = this.type === tt.num || this.type === tt.string ? this.parseExprAtom() : this.parseIdent(true)
	  }
	
	  // Initialize empty function node.
	
	  pp$3.initFunction = function(node) {
	    node.id = null
	    if (this.options.ecmaVersion >= 6) {
	      node.generator = false
	      node.expression = false
	    }
	  }
	
	  // Parse object or class method.
	
	  pp$3.parseMethod = function(isGenerator) {
	    var node = this.startNode(), oldInGen = this.inGenerator
	    this.inGenerator = isGenerator
	    this.initFunction(node)
	    this.expect(tt.parenL)
	    node.params = this.parseBindingList(tt.parenR, false, false)
	    if (this.options.ecmaVersion >= 6)
	      node.generator = isGenerator
	    this.parseFunctionBody(node, false)
	    this.inGenerator = oldInGen
	    return this.finishNode(node, "FunctionExpression")
	  }
	
	  // Parse arrow function expression with given parameters.
	
	  pp$3.parseArrowExpression = function(node, params) {
	    var oldInGen = this.inGenerator
	    this.inGenerator = false
	    this.initFunction(node)
	    node.params = this.toAssignableList(params, true)
	    this.parseFunctionBody(node, true)
	    this.inGenerator = oldInGen
	    return this.finishNode(node, "ArrowFunctionExpression")
	  }
	
	  // Parse function body and check parameters.
	
	  pp$3.parseFunctionBody = function(node, isArrowFunction) {
	    var isExpression = isArrowFunction && this.type !== tt.braceL
	
	    if (isExpression) {
	      node.body = this.parseMaybeAssign()
	      node.expression = true
	    } else {
	      // Start a new scope with regard to labels and the `inFunction`
	      // flag (restore them to their old value afterwards).
	      var oldInFunc = this.inFunction, oldLabels = this.labels
	      this.inFunction = true; this.labels = []
	      node.body = this.parseBlock(true)
	      node.expression = false
	      this.inFunction = oldInFunc; this.labels = oldLabels
	    }
	
	    // If this is a strict mode function, verify that argument names
	    // are not repeated, and it does not try to bind the words `eval`
	    // or `arguments`.
	    var useStrict = (!isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) ? node.body.body[0] : null;
	    if (this.strict || useStrict) {
	      var oldStrict = this.strict
	      this.strict = true
	      if (node.id)
	        this.checkLVal(node.id, true)
	      this.checkParams(node, useStrict)
	      this.strict = oldStrict
	    } else if (isArrowFunction) {
	      this.checkParams(node, useStrict)
	    }
	  }
	
	  // Checks function params for various disallowed patterns such as using "eval"
	  // or "arguments" and duplicate parameters.
	
	  pp$3.checkParams = function(node, useStrict) {
	      var this$1 = this;
	
	      var nameHash = {}
	      for (var i = 0; i < node.params.length; i++) {
	        if (useStrict && this$1.options.ecmaVersion >= 7 && node.params[i].type !== "Identifier")
	          this$1.raiseRecoverable(useStrict.start, "Illegal 'use strict' directive in function with non-simple parameter list");
	        this$1.checkLVal(node.params[i], true, nameHash)
	      }
	  }
	
	  // Parses a comma-separated list of expressions, and returns them as
	  // an array. `close` is the token type that ends the list, and
	  // `allowEmpty` can be turned on to allow subsequent commas with
	  // nothing in between them to be parsed as `null` (which is needed
	  // for array literals).
	
	  pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
	    var this$1 = this;
	
	    var elts = [], first = true
	    while (!this.eat(close)) {
	      if (!first) {
	        this$1.expect(tt.comma)
	        if (allowTrailingComma && this$1.afterTrailingComma(close)) break
	      } else first = false
	
	      var elt
	      if (allowEmpty && this$1.type === tt.comma)
	        elt = null
	      else if (this$1.type === tt.ellipsis) {
	        elt = this$1.parseSpread(refDestructuringErrors)
	        if (this$1.type === tt.comma && refDestructuringErrors && !refDestructuringErrors.trailingComma) {
	          refDestructuringErrors.trailingComma = this$1.lastTokStart
	        }
	      } else
	        elt = this$1.parseMaybeAssign(false, refDestructuringErrors)
	      elts.push(elt)
	    }
	    return elts
	  }
	
	  // Parse the next token as an identifier. If `liberal` is true (used
	  // when parsing properties), it will also convert keywords into
	  // identifiers.
	
	  pp$3.parseIdent = function(liberal) {
	    var node = this.startNode()
	    if (liberal && this.options.allowReserved == "never") liberal = false
	    if (this.type === tt.name) {
	      if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) &&
	          (this.options.ecmaVersion >= 6 ||
	           this.input.slice(this.start, this.end).indexOf("\\") == -1))
	        this.raiseRecoverable(this.start, "The keyword '" + this.value + "' is reserved")
	      if (!liberal && this.inGenerator && this.value === "yield")
	        this.raiseRecoverable(this.start, "Can not use 'yield' as identifier inside a generator")
	      node.name = this.value
	    } else if (liberal && this.type.keyword) {
	      node.name = this.type.keyword
	    } else {
	      this.unexpected()
	    }
	    this.next()
	    return this.finishNode(node, "Identifier")
	  }
	
	  // Parses yield expression inside generator.
	
	  pp$3.parseYield = function() {
	    var node = this.startNode()
	    this.next()
	    if (this.type == tt.semi || this.canInsertSemicolon() || (this.type != tt.star && !this.type.startsExpr)) {
	      node.delegate = false
	      node.argument = null
	    } else {
	      node.delegate = this.eat(tt.star)
	      node.argument = this.parseMaybeAssign()
	    }
	    return this.finishNode(node, "YieldExpression")
	  }
	
	  var pp$4 = Parser.prototype
	
	  // This function is used to raise exceptions on parse errors. It
	  // takes an offset integer (into the current `input`) to indicate
	  // the location of the error, attaches the position to the end
	  // of the error message, and then raises a `SyntaxError` with that
	  // message.
	
	  pp$4.raise = function(pos, message) {
	    var loc = getLineInfo(this.input, pos)
	    message += " (" + loc.line + ":" + loc.column + ")"
	    var err = new SyntaxError(message)
	    err.pos = pos; err.loc = loc; err.raisedAt = this.pos
	    throw err
	  }
	
	  pp$4.raiseRecoverable = pp$4.raise
	
	  pp$4.curPosition = function() {
	    if (this.options.locations) {
	      return new Position(this.curLine, this.pos - this.lineStart)
	    }
	  }
	
	  var Node = function Node(parser, pos, loc) {
	    this.type = ""
	    this.start = pos
	    this.end = 0
	    if (parser.options.locations)
	      this.loc = new SourceLocation(parser, loc)
	    if (parser.options.directSourceFile)
	      this.sourceFile = parser.options.directSourceFile
	    if (parser.options.ranges)
	      this.range = [pos, 0]
	  };
	
	  // Start an AST node, attaching a start offset.
	
	  var pp$5 = Parser.prototype
	
	  pp$5.startNode = function() {
	    return new Node(this, this.start, this.startLoc)
	  }
	
	  pp$5.startNodeAt = function(pos, loc) {
	    return new Node(this, pos, loc)
	  }
	
	  // Finish an AST node, adding `type` and `end` properties.
	
	  function finishNodeAt(node, type, pos, loc) {
	    node.type = type
	    node.end = pos
	    if (this.options.locations)
	      node.loc.end = loc
	    if (this.options.ranges)
	      node.range[1] = pos
	    return node
	  }
	
	  pp$5.finishNode = function(node, type) {
	    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
	  }
	
	  // Finish node at given position
	
	  pp$5.finishNodeAt = function(node, type, pos, loc) {
	    return finishNodeAt.call(this, node, type, pos, loc)
	  }
	
	  var TokContext = function TokContext(token, isExpr, preserveSpace, override) {
	    this.token = token
	    this.isExpr = !!isExpr
	    this.preserveSpace = !!preserveSpace
	    this.override = override
	  };
	
	  var types = {
	    b_stat: new TokContext("{", false),
	    b_expr: new TokContext("{", true),
	    b_tmpl: new TokContext("${", true),
	    p_stat: new TokContext("(", false),
	    p_expr: new TokContext("(", true),
	    q_tmpl: new TokContext("`", true, true, function (p) { return p.readTmplToken(); }),
	    f_expr: new TokContext("function", true)
	  }
	
	  var pp$6 = Parser.prototype
	
	  pp$6.initialContext = function() {
	    return [types.b_stat]
	  }
	
	  pp$6.braceIsBlock = function(prevType) {
	    if (prevType === tt.colon) {
	      var parent = this.curContext()
	      if (parent === types.b_stat || parent === types.b_expr)
	        return !parent.isExpr
	    }
	    if (prevType === tt._return)
	      return lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
	    if (prevType === tt._else || prevType === tt.semi || prevType === tt.eof || prevType === tt.parenR)
	      return true
	    if (prevType == tt.braceL)
	      return this.curContext() === types.b_stat
	    return !this.exprAllowed
	  }
	
	  pp$6.updateContext = function(prevType) {
	    var update, type = this.type
	    if (type.keyword && prevType == tt.dot)
	      this.exprAllowed = false
	    else if (update = type.updateContext)
	      update.call(this, prevType)
	    else
	      this.exprAllowed = type.beforeExpr
	  }
	
	  // Token-specific context update code
	
	  tt.parenR.updateContext = tt.braceR.updateContext = function() {
	    if (this.context.length == 1) {
	      this.exprAllowed = true
	      return
	    }
	    var out = this.context.pop()
	    if (out === types.b_stat && this.curContext() === types.f_expr) {
	      this.context.pop()
	      this.exprAllowed = false
	    } else if (out === types.b_tmpl) {
	      this.exprAllowed = true
	    } else {
	      this.exprAllowed = !out.isExpr
	    }
	  }
	
	  tt.braceL.updateContext = function(prevType) {
	    this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr)
	    this.exprAllowed = true
	  }
	
	  tt.dollarBraceL.updateContext = function() {
	    this.context.push(types.b_tmpl)
	    this.exprAllowed = true
	  }
	
	  tt.parenL.updateContext = function(prevType) {
	    var statementParens = prevType === tt._if || prevType === tt._for || prevType === tt._with || prevType === tt._while
	    this.context.push(statementParens ? types.p_stat : types.p_expr)
	    this.exprAllowed = true
	  }
	
	  tt.incDec.updateContext = function() {
	    // tokExprAllowed stays unchanged
	  }
	
	  tt._function.updateContext = function(prevType) {
	    if (prevType.beforeExpr && prevType !== tt.semi && prevType !== tt._else &&
	        !((prevType === tt.colon || prevType === tt.braceL) && this.curContext() === types.b_stat))
	      this.context.push(types.f_expr)
	    this.exprAllowed = false
	  }
	
	  tt.backQuote.updateContext = function() {
	    if (this.curContext() === types.q_tmpl)
	      this.context.pop()
	    else
	      this.context.push(types.q_tmpl)
	    this.exprAllowed = false
	  }
	
	  // Object type used to represent tokens. Note that normally, tokens
	  // simply exist as properties on the parser object. This is only
	  // used for the onToken callback and the external tokenizer.
	
	  var Token = function Token(p) {
	    this.type = p.type
	    this.value = p.value
	    this.start = p.start
	    this.end = p.end
	    if (p.options.locations)
	      this.loc = new SourceLocation(p, p.startLoc, p.endLoc)
	    if (p.options.ranges)
	      this.range = [p.start, p.end]
	  };
	
	  // ## Tokenizer
	
	  var pp$7 = Parser.prototype
	
	  // Are we running under Rhino?
	  var isRhino = typeof Packages == "object" && Object.prototype.toString.call(Packages) == "[object JavaPackage]"
	
	  // Move to the next token
	
	  pp$7.next = function() {
	    if (this.options.onToken)
	      this.options.onToken(new Token(this))
	
	    this.lastTokEnd = this.end
	    this.lastTokStart = this.start
	    this.lastTokEndLoc = this.endLoc
	    this.lastTokStartLoc = this.startLoc
	    this.nextToken()
	  }
	
	  pp$7.getToken = function() {
	    this.next()
	    return new Token(this)
	  }
	
	  // If we're in an ES6 environment, make parsers iterable
	  if (typeof Symbol !== "undefined")
	    pp$7[Symbol.iterator] = function () {
	      var self = this
	      return {next: function () {
	        var token = self.getToken()
	        return {
	          done: token.type === tt.eof,
	          value: token
	        }
	      }}
	    }
	
	  // Toggle strict mode. Re-reads the next number or string to please
	  // pedantic tests (`"use strict"; 010;` should fail).
	
	  pp$7.setStrict = function(strict) {
	    var this$1 = this;
	
	    this.strict = strict
	    if (this.type !== tt.num && this.type !== tt.string) return
	    this.pos = this.start
	    if (this.options.locations) {
	      while (this.pos < this.lineStart) {
	        this$1.lineStart = this$1.input.lastIndexOf("\n", this$1.lineStart - 2) + 1
	        --this$1.curLine
	      }
	    }
	    this.nextToken()
	  }
	
	  pp$7.curContext = function() {
	    return this.context[this.context.length - 1]
	  }
	
	  // Read a single token, updating the parser object's token-related
	  // properties.
	
	  pp$7.nextToken = function() {
	    var curContext = this.curContext()
	    if (!curContext || !curContext.preserveSpace) this.skipSpace()
	
	    this.start = this.pos
	    if (this.options.locations) this.startLoc = this.curPosition()
	    if (this.pos >= this.input.length) return this.finishToken(tt.eof)
	
	    if (curContext.override) return curContext.override(this)
	    else this.readToken(this.fullCharCodeAtPos())
	  }
	
	  pp$7.readToken = function(code) {
	    // Identifier or keyword. '\uXXXX' sequences are allowed in
	    // identifiers, so '\' also dispatches to that.
	    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
	      return this.readWord()
	
	    return this.getTokenFromCode(code)
	  }
	
	  pp$7.fullCharCodeAtPos = function() {
	    var code = this.input.charCodeAt(this.pos)
	    if (code <= 0xd7ff || code >= 0xe000) return code
	    var next = this.input.charCodeAt(this.pos + 1)
	    return (code << 10) + next - 0x35fdc00
	  }
	
	  pp$7.skipBlockComment = function() {
	    var this$1 = this;
	
	    var startLoc = this.options.onComment && this.curPosition()
	    var start = this.pos, end = this.input.indexOf("*/", this.pos += 2)
	    if (end === -1) this.raise(this.pos - 2, "Unterminated comment")
	    this.pos = end + 2
	    if (this.options.locations) {
	      lineBreakG.lastIndex = start
	      var match
	      while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
	        ++this$1.curLine
	        this$1.lineStart = match.index + match[0].length
	      }
	    }
	    if (this.options.onComment)
	      this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
	                             startLoc, this.curPosition())
	  }
	
	  pp$7.skipLineComment = function(startSkip) {
	    var this$1 = this;
	
	    var start = this.pos
	    var startLoc = this.options.onComment && this.curPosition()
	    var ch = this.input.charCodeAt(this.pos+=startSkip)
	    while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
	      ++this$1.pos
	      ch = this$1.input.charCodeAt(this$1.pos)
	    }
	    if (this.options.onComment)
	      this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
	                             startLoc, this.curPosition())
	  }
	
	  // Called at the start of the parse and after every token. Skips
	  // whitespace and comments, and.
	
	  pp$7.skipSpace = function() {
	    var this$1 = this;
	
	    loop: while (this.pos < this.input.length) {
	      var ch = this$1.input.charCodeAt(this$1.pos)
	      switch (ch) {
	        case 32: case 160: // ' '
	          ++this$1.pos
	          break
	        case 13:
	          if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {
	            ++this$1.pos
	          }
	        case 10: case 8232: case 8233:
	          ++this$1.pos
	          if (this$1.options.locations) {
	            ++this$1.curLine
	            this$1.lineStart = this$1.pos
	          }
	          break
	        case 47: // '/'
	          switch (this$1.input.charCodeAt(this$1.pos + 1)) {
	            case 42: // '*'
	              this$1.skipBlockComment()
	              break
	            case 47:
	              this$1.skipLineComment(2)
	              break
	            default:
	              break loop
	          }
	          break
	        default:
	          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
	            ++this$1.pos
	          } else {
	            break loop
	          }
	      }
	    }
	  }
	
	  // Called at the end of every token. Sets `end`, `val`, and
	  // maintains `context` and `exprAllowed`, and skips the space after
	  // the token, so that the next one's `start` will point at the
	  // right position.
	
	  pp$7.finishToken = function(type, val) {
	    this.end = this.pos
	    if (this.options.locations) this.endLoc = this.curPosition()
	    var prevType = this.type
	    this.type = type
	    this.value = val
	
	    this.updateContext(prevType)
	  }
	
	  // ### Token reading
	
	  // This is the function that is called to fetch the next token. It
	  // is somewhat obscure, because it works in character codes rather
	  // than characters, and because operator parsing has been inlined
	  // into it.
	  //
	  // All in the name of speed.
	  //
	  pp$7.readToken_dot = function() {
	    var next = this.input.charCodeAt(this.pos + 1)
	    if (next >= 48 && next <= 57) return this.readNumber(true)
	    var next2 = this.input.charCodeAt(this.pos + 2)
	    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
	      this.pos += 3
	      return this.finishToken(tt.ellipsis)
	    } else {
	      ++this.pos
	      return this.finishToken(tt.dot)
	    }
	  }
	
	  pp$7.readToken_slash = function() { // '/'
	    var next = this.input.charCodeAt(this.pos + 1)
	    if (this.exprAllowed) {++this.pos; return this.readRegexp()}
	    if (next === 61) return this.finishOp(tt.assign, 2)
	    return this.finishOp(tt.slash, 1)
	  }
	
	  pp$7.readToken_mult_modulo_exp = function(code) { // '%*'
	    var next = this.input.charCodeAt(this.pos + 1)
	    var size = 1
	    var tokentype = code === 42 ? tt.star : tt.modulo
	
	    // exponentiation operator ** and **=
	    if (this.options.ecmaVersion >= 7 && next === 42) {
	      ++size
	      tokentype = tt.starstar
	      next = this.input.charCodeAt(this.pos + 2)
	    }
	
	    if (next === 61) return this.finishOp(tt.assign, size + 1)
	    return this.finishOp(tokentype, size)
	  }
	
	  pp$7.readToken_pipe_amp = function(code) { // '|&'
	    var next = this.input.charCodeAt(this.pos + 1)
	    if (next === code) return this.finishOp(code === 124 ? tt.logicalOR : tt.logicalAND, 2)
	    if (next === 61) return this.finishOp(tt.assign, 2)
	    return this.finishOp(code === 124 ? tt.bitwiseOR : tt.bitwiseAND, 1)
	  }
	
	  pp$7.readToken_caret = function() { // '^'
	    var next = this.input.charCodeAt(this.pos + 1)
	    if (next === 61) return this.finishOp(tt.assign, 2)
	    return this.finishOp(tt.bitwiseXOR, 1)
	  }
	
	  pp$7.readToken_plus_min = function(code) { // '+-'
	    var next = this.input.charCodeAt(this.pos + 1)
	    if (next === code) {
	      if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 &&
	          lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {
	        // A `-->` line comment
	        this.skipLineComment(3)
	        this.skipSpace()
	        return this.nextToken()
	      }
	      return this.finishOp(tt.incDec, 2)
	    }
	    if (next === 61) return this.finishOp(tt.assign, 2)
	    return this.finishOp(tt.plusMin, 1)
	  }
	
	  pp$7.readToken_lt_gt = function(code) { // '<>'
	    var next = this.input.charCodeAt(this.pos + 1)
	    var size = 1
	    if (next === code) {
	      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2
	      if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(tt.assign, size + 1)
	      return this.finishOp(tt.bitShift, size)
	    }
	    if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 &&
	        this.input.charCodeAt(this.pos + 3) == 45) {
	      if (this.inModule) this.unexpected()
	      // `<!--`, an XML-style comment that should be interpreted as a line comment
	      this.skipLineComment(4)
	      this.skipSpace()
	      return this.nextToken()
	    }
	    if (next === 61) size = 2
	    return this.finishOp(tt.relational, size)
	  }
	
	  pp$7.readToken_eq_excl = function(code) { // '=!'
	    var next = this.input.charCodeAt(this.pos + 1)
	    if (next === 61) return this.finishOp(tt.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2)
	    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
	      this.pos += 2
	      return this.finishToken(tt.arrow)
	    }
	    return this.finishOp(code === 61 ? tt.eq : tt.prefix, 1)
	  }
	
	  pp$7.getTokenFromCode = function(code) {
	    switch (code) {
	      // The interpretation of a dot depends on whether it is followed
	      // by a digit or another two dots.
	    case 46: // '.'
	      return this.readToken_dot()
	
	      // Punctuation tokens.
	    case 40: ++this.pos; return this.finishToken(tt.parenL)
	    case 41: ++this.pos; return this.finishToken(tt.parenR)
	    case 59: ++this.pos; return this.finishToken(tt.semi)
	    case 44: ++this.pos; return this.finishToken(tt.comma)
	    case 91: ++this.pos; return this.finishToken(tt.bracketL)
	    case 93: ++this.pos; return this.finishToken(tt.bracketR)
	    case 123: ++this.pos; return this.finishToken(tt.braceL)
	    case 125: ++this.pos; return this.finishToken(tt.braceR)
	    case 58: ++this.pos; return this.finishToken(tt.colon)
	    case 63: ++this.pos; return this.finishToken(tt.question)
	
	    case 96: // '`'
	      if (this.options.ecmaVersion < 6) break
	      ++this.pos
	      return this.finishToken(tt.backQuote)
	
	    case 48: // '0'
	      var next = this.input.charCodeAt(this.pos + 1)
	      if (next === 120 || next === 88) return this.readRadixNumber(16) // '0x', '0X' - hex number
	      if (this.options.ecmaVersion >= 6) {
	        if (next === 111 || next === 79) return this.readRadixNumber(8) // '0o', '0O' - octal number
	        if (next === 98 || next === 66) return this.readRadixNumber(2) // '0b', '0B' - binary number
	      }
	      // Anything else beginning with a digit is an integer, octal
	      // number, or float.
	    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
	      return this.readNumber(false)
	
	      // Quotes produce strings.
	    case 34: case 39: // '"', "'"
	      return this.readString(code)
	
	      // Operators are parsed inline in tiny state machines. '=' (61) is
	      // often referred to. `finishOp` simply skips the amount of
	      // characters it is given as second argument, and returns a token
	      // of the type given by its first argument.
	
	    case 47: // '/'
	      return this.readToken_slash()
	
	    case 37: case 42: // '%*'
	      return this.readToken_mult_modulo_exp(code)
	
	    case 124: case 38: // '|&'
	      return this.readToken_pipe_amp(code)
	
	    case 94: // '^'
	      return this.readToken_caret()
	
	    case 43: case 45: // '+-'
	      return this.readToken_plus_min(code)
	
	    case 60: case 62: // '<>'
	      return this.readToken_lt_gt(code)
	
	    case 61: case 33: // '=!'
	      return this.readToken_eq_excl(code)
	
	    case 126: // '~'
	      return this.finishOp(tt.prefix, 1)
	    }
	
	    this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'")
	  }
	
	  pp$7.finishOp = function(type, size) {
	    var str = this.input.slice(this.pos, this.pos + size)
	    this.pos += size
	    return this.finishToken(type, str)
	  }
	
	  // Parse a regular expression. Some context-awareness is necessary,
	  // since a '/' inside a '[]' set does not end the expression.
	
	  function tryCreateRegexp(src, flags, throwErrorAt, parser) {
	    try {
	      return new RegExp(src, flags)
	    } catch (e) {
	      if (throwErrorAt !== undefined) {
	        if (e instanceof SyntaxError) parser.raise(throwErrorAt, "Error parsing regular expression: " + e.message)
	        throw e
	      }
	    }
	  }
	
	  var regexpUnicodeSupport = !!tryCreateRegexp("\uffff", "u")
	
	  pp$7.readRegexp = function() {
	    var this$1 = this;
	
	    var escaped, inClass, start = this.pos
	    for (;;) {
	      if (this$1.pos >= this$1.input.length) this$1.raise(start, "Unterminated regular expression")
	      var ch = this$1.input.charAt(this$1.pos)
	      if (lineBreak.test(ch)) this$1.raise(start, "Unterminated regular expression")
	      if (!escaped) {
	        if (ch === "[") inClass = true
	        else if (ch === "]" && inClass) inClass = false
	        else if (ch === "/" && !inClass) break
	        escaped = ch === "\\"
	      } else escaped = false
	      ++this$1.pos
	    }
	    var content = this.input.slice(start, this.pos)
	    ++this.pos
	    // Need to use `readWord1` because '\uXXXX' sequences are allowed
	    // here (don't ask).
	    var mods = this.readWord1()
	    var tmp = content, tmpFlags = ""
	    if (mods) {
	      var validFlags = /^[gim]*$/
	      if (this.options.ecmaVersion >= 6) validFlags = /^[gimuy]*$/
	      if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag")
	      if (mods.indexOf("u") >= 0) {
	        if (regexpUnicodeSupport) {
	          tmpFlags = "u"
	        } else {
	          // Replace each astral symbol and every Unicode escape sequence that
	          // possibly represents an astral symbol or a paired surrogate with a
	          // single ASCII symbol to avoid throwing on regular expressions that
	          // are only valid in combination with the `/u` flag.
	          // Note: replacing with the ASCII symbol `x` might cause false
	          // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
	          // perfectly valid pattern that is equivalent to `[a-b]`, but it would
	          // be replaced by `[x-b]` which throws an error.
	          tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function (_match, code, offset) {
	            code = Number("0x" + code)
	            if (code > 0x10FFFF) this$1.raise(start + offset + 3, "Code point out of bounds")
	            return "x"
	          })
	          tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x")
	          tmpFlags = tmpFlags.replace("u", "")
	        }
	      }
	    }
	    // Detect invalid regular expressions.
	    var value = null
	    // Rhino's regular expression parser is flaky and throws uncatchable exceptions,
	    // so don't do detection if we are running under Rhino
	    if (!isRhino) {
	      tryCreateRegexp(tmp, tmpFlags, start, this)
	      // Get a regular expression object for this pattern-flag pair, or `null` in
	      // case the current environment doesn't support the flags it uses.
	      value = tryCreateRegexp(content, mods)
	    }
	    return this.finishToken(tt.regexp, {pattern: content, flags: mods, value: value})
	  }
	
	  // Read an integer in the given radix. Return null if zero digits
	  // were read, the integer value otherwise. When `len` is given, this
	  // will return `null` unless the integer has exactly `len` digits.
	
	  pp$7.readInt = function(radix, len) {
	    var this$1 = this;
	
	    var start = this.pos, total = 0
	    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
	      var code = this$1.input.charCodeAt(this$1.pos), val
	      if (code >= 97) val = code - 97 + 10 // a
	      else if (code >= 65) val = code - 65 + 10 // A
	      else if (code >= 48 && code <= 57) val = code - 48 // 0-9
	      else val = Infinity
	      if (val >= radix) break
	      ++this$1.pos
	      total = total * radix + val
	    }
	    if (this.pos === start || len != null && this.pos - start !== len) return null
	
	    return total
	  }
	
	  pp$7.readRadixNumber = function(radix) {
	    this.pos += 2 // 0x
	    var val = this.readInt(radix)
	    if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix)
	    if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number")
	    return this.finishToken(tt.num, val)
	  }
	
	  // Read an integer, octal integer, or floating-point number.
	
	  pp$7.readNumber = function(startsWithDot) {
	    var start = this.pos, isFloat = false, octal = this.input.charCodeAt(this.pos) === 48
	    if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number")
	    var next = this.input.charCodeAt(this.pos)
	    if (next === 46) { // '.'
	      ++this.pos
	      this.readInt(10)
	      isFloat = true
	      next = this.input.charCodeAt(this.pos)
	    }
	    if (next === 69 || next === 101) { // 'eE'
	      next = this.input.charCodeAt(++this.pos)
	      if (next === 43 || next === 45) ++this.pos // '+-'
	      if (this.readInt(10) === null) this.raise(start, "Invalid number")
	      isFloat = true
	    }
	    if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number")
	
	    var str = this.input.slice(start, this.pos), val
	    if (isFloat) val = parseFloat(str)
	    else if (!octal || str.length === 1) val = parseInt(str, 10)
	    else if (/[89]/.test(str) || this.strict) this.raise(start, "Invalid number")
	    else val = parseInt(str, 8)
	    return this.finishToken(tt.num, val)
	  }
	
	  // Read a string value, interpreting backslash-escapes.
	
	  pp$7.readCodePoint = function() {
	    var ch = this.input.charCodeAt(this.pos), code
	
	    if (ch === 123) {
	      if (this.options.ecmaVersion < 6) this.unexpected()
	      var codePos = ++this.pos
	      code = this.readHexChar(this.input.indexOf('}', this.pos) - this.pos)
	      ++this.pos
	      if (code > 0x10FFFF) this.raise(codePos, "Code point out of bounds")
	    } else {
	      code = this.readHexChar(4)
	    }
	    return code
	  }
	
	  function codePointToString(code) {
	    // UTF-16 Decoding
	    if (code <= 0xFFFF) return String.fromCharCode(code)
	    code -= 0x10000
	    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
	  }
	
	  pp$7.readString = function(quote) {
	    var this$1 = this;
	
	    var out = "", chunkStart = ++this.pos
	    for (;;) {
	      if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, "Unterminated string constant")
	      var ch = this$1.input.charCodeAt(this$1.pos)
	      if (ch === quote) break
	      if (ch === 92) { // '\'
	        out += this$1.input.slice(chunkStart, this$1.pos)
	        out += this$1.readEscapedChar(false)
	        chunkStart = this$1.pos
	      } else {
	        if (isNewLine(ch)) this$1.raise(this$1.start, "Unterminated string constant")
	        ++this$1.pos
	      }
	    }
	    out += this.input.slice(chunkStart, this.pos++)
	    return this.finishToken(tt.string, out)
	  }
	
	  // Reads template string tokens.
	
	  pp$7.readTmplToken = function() {
	    var this$1 = this;
	
	    var out = "", chunkStart = this.pos
	    for (;;) {
	      if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, "Unterminated template")
	      var ch = this$1.input.charCodeAt(this$1.pos)
	      if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) { // '`', '${'
	        if (this$1.pos === this$1.start && this$1.type === tt.template) {
	          if (ch === 36) {
	            this$1.pos += 2
	            return this$1.finishToken(tt.dollarBraceL)
	          } else {
	            ++this$1.pos
	            return this$1.finishToken(tt.backQuote)
	          }
	        }
	        out += this$1.input.slice(chunkStart, this$1.pos)
	        return this$1.finishToken(tt.template, out)
	      }
	      if (ch === 92) { // '\'
	        out += this$1.input.slice(chunkStart, this$1.pos)
	        out += this$1.readEscapedChar(true)
	        chunkStart = this$1.pos
	      } else if (isNewLine(ch)) {
	        out += this$1.input.slice(chunkStart, this$1.pos)
	        ++this$1.pos
	        switch (ch) {
	          case 13:
	            if (this$1.input.charCodeAt(this$1.pos) === 10) ++this$1.pos
	          case 10:
	            out += "\n"
	            break
	          default:
	            out += String.fromCharCode(ch)
	            break
	        }
	        if (this$1.options.locations) {
	          ++this$1.curLine
	          this$1.lineStart = this$1.pos
	        }
	        chunkStart = this$1.pos
	      } else {
	        ++this$1.pos
	      }
	    }
	  }
	
	  // Used to read escaped characters
	
	  pp$7.readEscapedChar = function(inTemplate) {
	    var ch = this.input.charCodeAt(++this.pos)
	    ++this.pos
	    switch (ch) {
	    case 110: return "\n" // 'n' -> '\n'
	    case 114: return "\r" // 'r' -> '\r'
	    case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
	    case 117: return codePointToString(this.readCodePoint()) // 'u'
	    case 116: return "\t" // 't' -> '\t'
	    case 98: return "\b" // 'b' -> '\b'
	    case 118: return "\u000b" // 'v' -> '\u000b'
	    case 102: return "\f" // 'f' -> '\f'
	    case 13: if (this.input.charCodeAt(this.pos) === 10) ++this.pos // '\r\n'
	    case 10: // ' \n'
	      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine }
	      return ""
	    default:
	      if (ch >= 48 && ch <= 55) {
	        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0]
	        var octal = parseInt(octalStr, 8)
	        if (octal > 255) {
	          octalStr = octalStr.slice(0, -1)
	          octal = parseInt(octalStr, 8)
	        }
	        if (octalStr !== "0" && (this.strict || inTemplate)) {
	          this.raise(this.pos - 2, "Octal literal in strict mode")
	        }
	        this.pos += octalStr.length - 1
	        return String.fromCharCode(octal)
	      }
	      return String.fromCharCode(ch)
	    }
	  }
	
	  // Used to read character escape sequences ('\x', '\u', '\U').
	
	  pp$7.readHexChar = function(len) {
	    var codePos = this.pos
	    var n = this.readInt(16, len)
	    if (n === null) this.raise(codePos, "Bad character escape sequence")
	    return n
	  }
	
	  // Read an identifier, and return it as a string. Sets `this.containsEsc`
	  // to whether the word contained a '\u' escape.
	  //
	  // Incrementally adds only escaped chars, adding other chunks as-is
	  // as a micro-optimization.
	
	  pp$7.readWord1 = function() {
	    var this$1 = this;
	
	    this.containsEsc = false
	    var word = "", first = true, chunkStart = this.pos
	    var astral = this.options.ecmaVersion >= 6
	    while (this.pos < this.input.length) {
	      var ch = this$1.fullCharCodeAtPos()
	      if (isIdentifierChar(ch, astral)) {
	        this$1.pos += ch <= 0xffff ? 1 : 2
	      } else if (ch === 92) { // "\"
	        this$1.containsEsc = true
	        word += this$1.input.slice(chunkStart, this$1.pos)
	        var escStart = this$1.pos
	        if (this$1.input.charCodeAt(++this$1.pos) != 117) // "u"
	          this$1.raise(this$1.pos, "Expecting Unicode escape sequence \\uXXXX")
	        ++this$1.pos
	        var esc = this$1.readCodePoint()
	        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
	          this$1.raise(escStart, "Invalid Unicode escape")
	        word += codePointToString(esc)
	        chunkStart = this$1.pos
	      } else {
	        break
	      }
	      first = false
	    }
	    return word + this.input.slice(chunkStart, this.pos)
	  }
	
	  // Read an identifier or keyword token. Will check for reserved
	  // words when necessary.
	
	  pp$7.readWord = function() {
	    var word = this.readWord1()
	    var type = tt.name
	    if ((this.options.ecmaVersion >= 6 || !this.containsEsc) && this.keywords.test(word))
	      type = keywordTypes[word]
	    return this.finishToken(type, word)
	  }
	
	  var version = "3.3.0"
	
	  // The main exported interface (under `self.acorn` when in the
	  // browser) is a `parse` function that takes a code string and
	  // returns an abstract syntax tree as specified by [Mozilla parser
	  // API][api].
	  //
	  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
	
	  function parse(input, options) {
	    return new Parser(options, input).parse()
	  }
	
	  // This function tries to parse a single expression at a given
	  // offset in a string. Useful for parsing mixed-language formats
	  // that embed JavaScript expressions.
	
	  function parseExpressionAt(input, pos, options) {
	    var p = new Parser(options, input, pos)
	    p.nextToken()
	    return p.parseExpression()
	  }
	
	  // Acorn is organized as a tokenizer and a recursive-descent parser.
	  // The `tokenizer` export provides an interface to the tokenizer.
	
	  function tokenizer(input, options) {
	    return new Parser(options, input)
	  }
	
	  exports.version = version;
	  exports.parse = parse;
	  exports.parseExpressionAt = parseExpressionAt;
	  exports.tokenizer = tokenizer;
	  exports.Parser = Parser;
	  exports.plugins = plugins;
	  exports.defaultOptions = defaultOptions;
	  exports.Position = Position;
	  exports.SourceLocation = SourceLocation;
	  exports.getLineInfo = getLineInfo;
	  exports.Node = Node;
	  exports.TokenType = TokenType;
	  exports.tokTypes = tt;
	  exports.TokContext = TokContext;
	  exports.tokContexts = types;
	  exports.isIdentifierChar = isIdentifierChar;
	  exports.isIdentifierStart = isIdentifierStart;
	  exports.Token = Token;
	  exports.isNewLine = isNewLine;
	  exports.lineBreak = lineBreak;
	  exports.lineBreakG = lineBreakG;
	
	  Object.defineProperty(exports, '__esModule', { value: true });
	
	}));

/***/ },
/* 62 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function BasicEvaluatedExpression() {
		this.range = null;
	}
	module.exports = BasicEvaluatedExpression;
	
	BasicEvaluatedExpression.prototype.isNull = function() {
		return !!this.null;
	};
	BasicEvaluatedExpression.prototype.isString = function() {
		return Object.prototype.hasOwnProperty.call(this, "string");
	};
	BasicEvaluatedExpression.prototype.isNumber = function() {
		return Object.prototype.hasOwnProperty.call(this, "number");
	};
	BasicEvaluatedExpression.prototype.isBoolean = function() {
		return Object.prototype.hasOwnProperty.call(this, "bool");
	};
	BasicEvaluatedExpression.prototype.isRegExp = function() {
		return Object.prototype.hasOwnProperty.call(this, "regExp");
	};
	BasicEvaluatedExpression.prototype.isConditional = function() {
		return Object.prototype.hasOwnProperty.call(this, "options");
	};
	BasicEvaluatedExpression.prototype.isArray = function() {
		return Object.prototype.hasOwnProperty.call(this, "items");
	};
	BasicEvaluatedExpression.prototype.isConstArray = function() {
		return Object.prototype.hasOwnProperty.call(this, "array");
	};
	BasicEvaluatedExpression.prototype.isIdentifier = function() {
		return Object.prototype.hasOwnProperty.call(this, "identifier");
	};
	BasicEvaluatedExpression.prototype.isWrapped = function() {
		return Object.prototype.hasOwnProperty.call(this, "prefix") || Object.prototype.hasOwnProperty.call(this, "postfix");
	};
	BasicEvaluatedExpression.prototype.asBool = function() {
		if(this.isBoolean()) return this.bool;
		else if(this.isNull()) return false;
		else if(this.isString()) return !!this.string;
		else if(this.isNumber()) return !!this.number;
		else if(this.isRegExp()) return true;
		else if(this.isArray()) return true;
		else if(this.isConstArray()) return true;
		else if(this.isWrapped()) return this.prefix && this.prefix.asBool() || this.postfix && this.postfix.asBool() ? true : undefined;
		return undefined;
	};
	BasicEvaluatedExpression.prototype.set = function(value) {
		if(typeof value === "string") return this.setString(value);
		if(typeof value === "number") return this.setNumber(value);
		if(typeof value === "boolean") return this.setBoolean(value);
		if(value === null) return this.setNull();
		if(value instanceof RegExp) return this.setRegExp(value);
		if(Array.isArray(value)) return this.setArray(value);
		return this;
	};
	BasicEvaluatedExpression.prototype.setString = function(str) {
		if(str === null)
			delete this.string;
		else
			this.string = str;
		return this;
	};
	BasicEvaluatedExpression.prototype.setNull = function() {
		this.null = true;
		return this;
	};
	BasicEvaluatedExpression.prototype.setNumber = function(num) {
		if(num === null)
			delete this.number;
		else
			this.number = num;
		return this;
	};
	BasicEvaluatedExpression.prototype.setBoolean = function(bool) {
		if(bool === null)
			delete this.bool;
		else
			this.bool = bool;
		return this;
	};
	BasicEvaluatedExpression.prototype.setRegExp = function(regExp) {
		if(regExp === null)
			delete this.regExp;
		else
			this.regExp = regExp;
		return this;
	};
	BasicEvaluatedExpression.prototype.setIdentifier = function(identifier) {
		if(identifier === null)
			delete this.identifier;
		else
			this.identifier = identifier;
		return this;
	};
	BasicEvaluatedExpression.prototype.setWrapped = function(prefix, postfix) {
		this.prefix = prefix;
		this.postfix = postfix;
		return this;
	};
	BasicEvaluatedExpression.prototype.unsetWrapped = function() {
		delete this.prefix;
		delete this.postfix;
		return this;
	};
	BasicEvaluatedExpression.prototype.setOptions = function(options) {
		if(options === null)
			delete this.options;
		else
			this.options = options;
		return this;
	};
	BasicEvaluatedExpression.prototype.setItems = function(items) {
		if(items === null)
			delete this.items;
		else
			this.items = items;
		return this;
	};
	BasicEvaluatedExpression.prototype.setArray = function(array) {
		if(array === null)
			delete this.array;
		else
			this.array = array;
		return this;
	};
	BasicEvaluatedExpression.prototype.addOptions = function(options) {
		if(!this.options) this.options = [];
		options.forEach(function(item) {
			this.options.push(item);
		}, this);
		return this;
	};
	BasicEvaluatedExpression.prototype.setRange = function(range) {
		this.range = range;
		return this;
	};


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Tapable = __webpack_require__(8);
	var createInnerCallback = __webpack_require__(64);
	
	function Resolver(fileSystem) {
		Tapable.call(this);
		this.fileSystem = fileSystem;
	}
	module.exports = Resolver;
	
	Resolver.prototype = Object.create(Tapable.prototype);
	
	Resolver.prototype.resolveSync = function resolveSync(context, request) {
		var err, result, sync = false;
		this.resolve(context, request, function(e, r) {
			err = e;
			result = r;
			sync = true;
		});
		if(!sync) throw new Error("Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!");
		if(err) throw err;
		return result;
	};
	
	Resolver.prototype.resolve = function resolve(context, request, callback) {
		if(typeof request === "string") request = this.parse(request);
		this.applyPlugins("resolve", context, request);
		var obj = {
			path: context,
			request: request.path,
			query: request.query,
			directory: request.directory
		};
		function onResolved(err, result) {
			if(err) return callback(err);
			return callback(null, result.path === false ? false : result.path + (result.query || ""));
		}
		onResolved.log = callback.log;
		onResolved.missing = callback.missing;
		if(request.module) return this.doResolve("module", obj, onResolved);
		if(request.directory) return this.doResolve("directory", obj, onResolved);
		return this.doResolve(["file", "directory"], obj, onResolved);
	};
	
	Resolver.prototype.doResolve = function doResolve(types, request, callback, noError) {
		if(!Array.isArray(types)) types = [types];
		var stackLine = types.join(" or ") + ": (" + request.path + ") " +
			(request.request || "") + (request.query || "") +
			(request.directory ? " directory" : "") +
			(request.module ? " module" : "");
		var newStack = [stackLine];
		if(callback.stack) {
			newStack = callback.stack.concat(newStack);
			if(callback.stack.indexOf(stackLine) >= 0) {
				// Prevent recursion
				var recursionError = new Error("Recursion in resolving\nStack:\n  " + newStack.join("\n  "));
				recursionError.recursion = true;
				if(callback.log) callback.log("abort resolving because of recursion");
				return callback(recursionError);
			}
		}
		this.applyPlugins("resolve-step", types, request);
		var localMissing = [];
		var missing = callback.missing ? {
			push: function(item) {
				callback.missing.push(item);
				localMissing.push(item);
			}
		} : localMissing;
		var log = [];
		function writeLog(msg) {
			log.push(msg);
		}
		function logAsString() {
			return log.join("\n");
		}
		var currentRequestString = request.request ? request.request + " in " + request.path : request.path;
		if(types.length == 1 && !noError) {
			// If only one type, we can pass the error.
			return this.applyPluginsParallelBailResult(types[0], request, createInnerCallback(function innerCallback(err, result) {
				if(callback.log) {
					for(var i = 0; i < log.length; i++)
						callback.log(log[i]);
				}
				if(err) return callback(err);
				if(result) return callback(null, result);
				if(types[0] === "result") return callback(null, request);
				var error = new Error("Cannot resolve " + types[0] + " '" + request.request + "' in " + request.path);
				error.details = logAsString();
				error.missing = localMissing;
				return callback(error);
			}, {
				log: writeLog,
				missing: missing,
				stack: newStack
			}, "resolve " + types[0] + " " + currentRequestString));
		}
		// For multiple type we list the errors in the details although some of them are not important
		this.forEachBail(types, function(type, callback) {
			this.applyPluginsParallelBailResult(type, request, createInnerCallback(function(err, result) {
				if(!err && result) return callback(result);
				if (err) {
					(err.message || "").split("\n").forEach(function(line) {
						log.push("  " + line);
					});
				}
				callback();
			}, {
				log: writeLog,
				missing: missing,
				stack: newStack
			}, "resolve " + type));
		}.bind(this), function(result) {
			if(callback.log) {
				callback.log("resolve '" + types.join("' or '") + "' " + currentRequestString);
				for(var i = 0; i < log.length; i++)
					callback.log("  " + log[i]);
			}
			if(noError && !result) return callback();
			if(result) return callback(null, result);
			var error = new Error("Cannot resolve '" + types.join("' or '") + "' " + currentRequestString);
			error.details = logAsString();
			error.missing = localMissing;
			return callback(error);
		});
	};
	
	Resolver.prototype.parse = function parse(identifier) {
		if(identifier === "") return null;
		var part = {
			path: null,
			query: null,
			module: false,
			directory: false,
			file: false
		};
		var idxQuery = identifier.indexOf("?");
		if(idxQuery == 0) {
			part.query = identifier;
		} else if(idxQuery > 0) {
			part.path = identifier.slice(0, idxQuery);
			part.query = identifier.slice(idxQuery);
		} else {
			part.path = identifier;
		}
		if(part.path) {
			part.module = this.isModule(part.path);
			if(part.directory = this.isDirectory(part.path)) {
				part.path = part.path.substr(0, part.path.length - 1);
			}
		}
		return part;
	};
	
	var notModuleRegExp = /^\.$|^\.[\\\/]|^\.\.$|^\.\.[\/\\]|^\/|^[A-Z]:[\\\/]/i;
	Resolver.prototype.isModule = function isModule(path) {
		return !notModuleRegExp.test(path);
	};
	
	var directoryRegExp = /[\/\\]$/i;
	Resolver.prototype.isDirectory = function isDirectory(path) {
		return directoryRegExp.test(path);
	};
	
	Resolver.prototype.join = __webpack_require__(65);
	
	Resolver.prototype.normalize = __webpack_require__(66);
	
	Resolver.prototype.forEachBail = function(array, iterator, callback) {
		if(array.length == 0) return callback();
		var currentPos = array.length;
		var currentError, currentResult;
		var done = [];
		for(var i = 0; i < array.length; i++) {
			var itCb = (function(i) {
				return function() {
					if(i >= currentPos) return; // ignore
					var args = Array.prototype.slice.call(arguments);
					done.push(i);
					if(args.length > 0) {
						currentPos = i + 1;
						done = done.filter(function(item) {
							return item <= i;
						});
						currentResult = args;
					}
					if(done.length == currentPos) {
						callback.apply(null, currentResult);
						currentPos = 0;
					}
				};
			}(i));
			iterator(array[i], itCb);
			if(currentPos == 0) break;
		}
	};
	


/***/ },
/* 64 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function createInnerCallback(callback, options, message) {
		var log = options.log;
		if(!log) {
			if(options.stack !== callback.stack) {
				function callbackWrapper() {
					return callback.apply(this, arguments);
				}
				callbackWrapper.stack = options.stack;
				callbackWrapper.missing = options.missing;
			}
			return callback;
		}
		function loggingCallbackWrapper() {
			log(message);
			for(var i = 0; i < theLog.length; i++)
				log("  " + theLog[i]);
			return callback.apply(this, arguments);
		}
		var theLog = [];
		loggingCallbackWrapper.log = function writeLog(msg) {
			theLog.push(msg);
		};
		loggingCallbackWrapper.stack = options.stack;
		loggingCallbackWrapper.missing = options.missing;
		return loggingCallbackWrapper;
	}

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	var normalize = __webpack_require__(66);
	
	var absoluteWinRegExp = /^[A-Z]:([\\\/]|$)/i;
	var absoluteNixRegExp = /^\//i;
	
	module.exports = function join(path, request) {
		if(request == "") return normalize(path);
		if(absoluteWinRegExp.test(request)) return normalize(request.replace(/\//g, "\\"));
		if(absoluteNixRegExp.test(request)) return normalize(request);
		if(path == "/") return normalize(path + request);
		if(absoluteWinRegExp.test(path)) return normalize(path + "\\" + request.replace(/\//g, "\\"));
		if(absoluteNixRegExp.test(path)) return normalize(path + "/" + request);
		return normalize(path + "/" + request);
	};

/***/ },
/* 66 */
/***/ function(module, exports) {

	var doubleSlashWinRegExp = /\\+/g;
	var doubleSlashNixRegExp = /\/+/g;
	var currentDirectoryWinMiddleRegExp = /\\(\.\\)+/;
	var currentDirectoryWinEndRegExp = /\\\.$/;
	var parentDirectoryWinMiddleRegExp = /\\+[^\\]+\\+\.\.\\/;
	var parentDirectoryWinEndRegExp1 = /([A-Z]:\\)\\*[^\\]+\\+\.\.$/i;
	var parentDirectoryWinEndRegExp2 = /\\+[^\\]+\\+\.\.$/;
	var currentDirectoryNixMiddleRegExp = /\/+(\.\/)+/;
	var currentDirectoryNixEndRegExp1 = /^\/+\.$/;
	var currentDirectoryNixEndRegExp2 = /\/+\.$/;
	var parentDirectoryNixMiddleRegExp = /(^|\/[^\/]+)\/+\.\.\/+/;
	var parentDirectoryNixEndRegExp1 = /^\/[^\/]+\/+\.\.$/;
	var parentDirectoryNixEndRegExp2 = /\/+[^\/]+\/+\.\.$/;
	var parentDirectoryNixEndRegExp3 = /^\/+\.\.$/;
	
	// RegExp magic :)
	
	module.exports = function normalize(path) {
		while(currentDirectoryWinMiddleRegExp.test(path))
			path = path.replace(currentDirectoryWinMiddleRegExp, "\\");
		path = path.replace(currentDirectoryWinEndRegExp, "");
		while(parentDirectoryWinMiddleRegExp.test(path))
			path = path.replace(parentDirectoryWinMiddleRegExp, "\\");
		path = path.replace(parentDirectoryWinEndRegExp1, "$1");
		path = path.replace(parentDirectoryWinEndRegExp2, "");
	
		while(currentDirectoryNixMiddleRegExp.test(path))
			path = path.replace(currentDirectoryNixMiddleRegExp, "/");
		path = path.replace(currentDirectoryNixEndRegExp1, "/");
		path = path.replace(currentDirectoryNixEndRegExp2, "");
		while(parentDirectoryNixMiddleRegExp.test(path))
			path = path.replace(parentDirectoryNixMiddleRegExp, "/");
		path = path.replace(parentDirectoryNixEndRegExp1, "/");
		path = path.replace(parentDirectoryNixEndRegExp2, "");
		path = path.replace(parentDirectoryNixEndRegExp3, "/");
	
		return path.replace(doubleSlashWinRegExp, "\\").replace(doubleSlashNixRegExp, "/");
	};

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var async = __webpack_require__(10);
	
	var Tapable = __webpack_require__(8);
	var NormalModule = __webpack_require__(68);
	var RawModule = __webpack_require__(78);
	var LoadersList = __webpack_require__(79);
	
	function NormalModuleFactory(context, resolvers, parser, options) {
		Tapable.call(this);
		this.resolvers = resolvers;
		this.parser = parser;
		this.loaders = new LoadersList(options.loaders);
		this.preLoaders = new LoadersList(options.preLoaders);
		this.postLoaders = new LoadersList(options.postLoaders);
		this.context = context || "";
		this.plugin("factory", function() {
			var _this = this;
			return function(result, callback) {
				var resolver = _this.applyPluginsWaterfall("resolver", null);
	
				// Ignored
				if(!resolver) return callback();
	
				resolver(result, function onDoneResolving(err, data) {
					if(err) return callback(err);
	
					// Ignored
					if(!data) return callback();
	
					// direct module
					if(typeof data.source === "function")
						return callback(null, data);
	
					_this.applyPluginsAsyncWaterfall("after-resolve", data, function(err, result) {
						if(err) return callback(err);
	
						// Ignored
						if(!result) return callback();
	
						var createdModule = _this.applyPluginsBailResult("create-module", result);
						if(!createdModule) {
							createdModule = new NormalModule(
								result.request,
								result.userRequest,
								result.rawRequest,
								result.loaders,
								result.resource,
								result.parser
							);
						}
	
						createdModule = _this.applyPluginsWaterfall("module", createdModule);
	
						return callback(null, createdModule);
					});
				});
			};
		});
		this.plugin("resolver", function() {
			var _this = this;
			return function(data, callback) {
				var context = data.context;
				var request = data.request;
	
				var noAutoLoaders = /^-?!/.test(request);
				var noPrePostAutoLoaders = /^!!/.test(request);
				var noPostAutoLoaders = /^-!/.test(request);
				var elements = request.replace(/^-?!+/, "").replace(/!!+/g, "!").split("!");
				var resource = elements.pop();
	
				async.parallel([
					function(callback) {
						_this.resolveRequestArray(context, elements, _this.resolvers.loader, callback);
					},
					function(callback) {
						if(resource === "" || resource[0] === "?")
							return callback(null, resource);
						_this.resolvers.normal.resolve(context, resource, callback);
					}
				], function(err, results) {
					if(err) return callback(err);
					var loaders = results[0];
					resource = results[1];
	
					if(resource === false)
						return callback(null,
							new RawModule("/* (ignored) */",
								"ignored " + context + " " + request,
								request + " (ignored)")); // ignored
	
					var userRequest = loaders.concat([resource]).join("!");
	
					if(noPrePostAutoLoaders)
						return onDoneResolving();
					if(noAutoLoaders) {
						async.parallel([
							_this.resolveRequestArray.bind(_this, context, noPostAutoLoaders ? [] : _this.postLoaders.match(resource), _this.resolvers.loader),
							_this.resolveRequestArray.bind(_this, context, _this.preLoaders.match(resource), _this.resolvers.loader)
						], function(err, results) {
							if(err) return callback(err);
							loaders = results[0].concat(loaders).concat(results[1]);
							onDoneResolving();
						});
					} else {
						async.parallel([
							_this.resolveRequestArray.bind(_this, context, noPostAutoLoaders ? [] : _this.postLoaders.match(resource), _this.resolvers.loader),
							_this.resolveRequestArray.bind(_this, context, _this.loaders.match(resource), _this.resolvers.loader),
							_this.resolveRequestArray.bind(_this, context, _this.preLoaders.match(resource), _this.resolvers.loader)
						], function(err, results) {
							if(err) return callback(err);
							loaders = results[0].concat(loaders).concat(results[1]).concat(results[2]);
							onDoneResolving();
						});
					}
	
					function onDoneResolving() {
						callback(null, {
							context: context,
							request: loaders.concat([resource]).join("!"),
							userRequest: userRequest,
							rawRequest: request,
							loaders: loaders,
							resource: resource,
							parser: _this.parser
						});
					}
				});
			};
		});
	}
	module.exports = NormalModuleFactory;
	
	NormalModuleFactory.prototype = Object.create(Tapable.prototype);
	NormalModuleFactory.prototype.constructor = NormalModuleFactory;
	
	NormalModuleFactory.prototype.create = function(context, dependency, callback) {
		var _this = this;
		context = context || this.context;
		var request = dependency.request;
		_this.applyPluginsAsyncWaterfall("before-resolve", {
			context: context,
			request: request,
			dependency: dependency
		}, function(err, result) {
			if(err) return callback(err);
	
			// Ignored
			if(!result) return callback();
	
			var factory = _this.applyPluginsWaterfall("factory", null);
	
			// Ignored
			if(!factory) return callback();
	
			factory(result, callback);
	
		});
	};
	
	NormalModuleFactory.prototype.resolveRequestArray = function resolveRequestArray(context, array, resolver, callback) {
		if(array.length === 0) return callback(null, []);
		async.map(array, function(item, callback) {
			if(item === "" || item[0] === "?")
				return callback(null, item);
			resolver.resolve(context, item, callback);
		}, callback);
	};


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var path = __webpack_require__(4);
	var Module = __webpack_require__(15);
	var NormalModuleMixin = __webpack_require__(69);
	var SourceMapSource = __webpack_require__(70);
	var OriginalSource = __webpack_require__(50);
	var RawSource = __webpack_require__(40);
	var ReplaceSource = __webpack_require__(18);
	var CachedSource = __webpack_require__(58);
	var ModuleParseError = __webpack_require__(75);
	var TemplateArgumentDependency = __webpack_require__(76);
	var AsyncDependenciesBlock = __webpack_require__(77);
	
	function NormalModule(request, userRequest, rawRequest, loaders, resource, parser) {
		Module.call(this);
		this.request = request;
		this.userRequest = userRequest;
		this.rawRequest = rawRequest;
		this.parser = parser;
		NormalModuleMixin.call(this, loaders, resource);
		this.meta = {};
		this.assets = {};
		this.built = false;
		this._cachedSource = null;
	}
	module.exports = NormalModule;
	
	NormalModule.prototype = Object.create(Module.prototype);
	NormalModuleMixin.mixin(NormalModule.prototype);
	
	NormalModule.prototype.identifier = function() {
		return this.request;
	};
	
	NormalModule.prototype.readableIdentifier = function(requestShortener) {
		return requestShortener.shorten(this.userRequest);
	};
	
	function contextify(options, request) {
		return request.split("!").map(function(r) {
			var rp = path.relative(options.context, r);
			if(path.sep === "\\")
				rp = rp.replace(/\\/g, "/");
			if(rp.indexOf("../") !== 0)
				rp = "./" + rp;
			return rp;
		}).join("!");
	}
	
	NormalModule.prototype.libIdent = function(options) {
		return contextify(options, this.userRequest);
	};
	
	NormalModule.prototype.fillLoaderContext = function fillLoaderContext(loaderContext, options, compilation) {
		loaderContext.webpack = true;
		loaderContext.sourceMap = !!this.useSourceMap;
		loaderContext.emitFile = function(name, content, sourceMap) {
			if(typeof sourceMap === "string") {
				this.assets[name] = new OriginalSource(content, sourceMap);
			} else if(sourceMap) {
				this.assets[name] = new SourceMapSource(content, name, sourceMap);
			} else {
				this.assets[name] = new RawSource(content);
			}
		}.bind(this);
		loaderContext._module = this;
		loaderContext._compilation = compilation;
		loaderContext._compiler = compilation.compiler;
		loaderContext.fs = compilation.compiler.inputFileSystem;
		compilation.applyPlugins("normal-module-loader", loaderContext, this);
	};
	
	NormalModule.prototype.disconnect = function disconnect() {
		this.built = false;
		Module.prototype.disconnect.call(this);
	};
	
	NormalModule.prototype.build = function build(options, compilation, resolver, fs, callback) {
		this.buildTimestamp = new Date().getTime();
		this.built = true;
		return this.doBuild(options, compilation, resolver, fs, function(err) {
			if(err) return callback(err);
			this.dependencies.length = 0;
			this.variables.length = 0;
			this.blocks.length = 0;
			this._cachedSource = null;
			if(options.module && options.module.noParse) {
				if(Array.isArray(options.module.noParse)) {
					if(options.module.noParse.some(function(regExp) {
							return typeof regExp === "string" ?
								this.request.indexOf(regExp) === 0 :
								regExp.test(this.request);
						}, this)) return callback();
				} else if(typeof options.module.noParse === "string" ?
					this.request.indexOf(options.module.noParse) === 0 :
					options.module.noParse.test(this.request)) {
					return callback();
				}
			}
			try {
				this.parser.parse(this._source.source(), {
					current: this,
					module: this,
					compilation: compilation,
					options: options
				});
			} catch(e) {
				var source = this._source.source();
				this._source = null;
				return callback(new ModuleParseError(this, source, e));
			}
			return callback();
		}.bind(this));
	};
	
	NormalModule.prototype.source = function(dependencyTemplates, outputOptions, requestShortener) {
		var hash = __webpack_require__(59).createHash("md5");
		this.updateHash(hash);
		hash = hash.digest("hex");
		if(this._cachedSource && this._cachedSource.hash === hash) {
			return this._cachedSource.source;
		}
		var _source = this._source;
		if(!_source) return new RawSource("throw new Error('No source available');");
		var source = new ReplaceSource(_source);
		this._cachedSource = {
			source: source,
			hash: hash
		};
		var topLevelBlock = this;
	
		function doDep(dep) {
			var template = dependencyTemplates.get(dep.constructor);
			if(!template) throw new Error("No template for dependency: " + dep.constructor.name);
			template.apply(dep, source, outputOptions, requestShortener, dependencyTemplates);
		}
	
		function doVariable(vars, variable) {
			var name = variable.name;
			var expr = variable.expressionSource(dependencyTemplates, outputOptions, requestShortener);
			vars.push({
				name: name,
				expression: expr
			});
		}
	
		function doBlock(block) {
			block.dependencies.forEach(doDep);
			block.blocks.forEach(doBlock);
			if(block.variables.length > 0) {
				var vars = [];
				block.variables.forEach(doVariable.bind(null, vars));
				var varNames = [];
				var varExpressions = [];
				var varStartCode = "";
				var varEndCode = "";
	
				function emitFunction() {
					if(varNames.length === 0) return;
	
					varStartCode += "/* WEBPACK VAR INJECTION */(function(" + varNames.join(", ") + ") {";
					// exports === this in the topLevelBlock, but exports do compress better...
					varEndCode = (topLevelBlock === block ? "}.call(exports, " : "}.call(this, ") +
						varExpressions.map(function(e) {
							return e.source();
						}).join(", ") + "))" + varEndCode;
	
					varNames.length = 0;
					varExpressions.length = 0;
				}
				vars.forEach(function(v) {
					if(varNames.indexOf(v.name) >= 0) emitFunction();
					varNames.push(v.name);
					varExpressions.push(v.expression);
				});
				emitFunction();
				var start = block.range ? block.range[0] : 0;
				var end = block.range ? block.range[1] : _source.size();
				if(varStartCode) source.insert(start + 0.5, varStartCode);
				if(varEndCode) source.insert(end + 0.5, "\n/* WEBPACK VAR INJECTION */" + varEndCode);
			}
		}
		doBlock(this);
		return new CachedSource(source);
	};
	
	NormalModule.prototype.needRebuild = function needRebuild(fileTimestamps, contextTimestamps) {
		var timestamp = 0;
		this.fileDependencies.forEach(function(file) {
			var ts = fileTimestamps[file];
			if(!ts) timestamp = Infinity;
			if(ts > timestamp) timestamp = ts;
		});
		this.contextDependencies.forEach(function(context) {
			var ts = contextTimestamps[context];
			if(!ts) timestamp = Infinity;
			if(ts > timestamp) timestamp = ts;
		});
		return timestamp >= this.buildTimestamp;
	};
	
	NormalModule.prototype.size = function() {
		return this._source ? this._source.size() : -1;
	};
	
	NormalModule.prototype.updateHash = function(hash) {
		if(this._source) {
			hash.update("source");
			this._source.updateHash(hash);
		} else
			hash.update("null");
		hash.update("meta");
		hash.update(JSON.stringify(this.meta));
		Module.prototype.updateHash.call(this, hash);
	};
	
	NormalModule.prototype.getSourceHash = function() {
		if(!this._source) return "";
		var hash = __webpack_require__(59).createHash("md5");
		hash.update(this._source.source());
		return hash.digest("hex");
	};
	
	NormalModule.prototype.getAllModuleDependencies = function() {
		var list = [];
	
		function doDep(dep) {
			if(dep.module && list.indexOf(dep.module) < 0)
				list.push(dep.module);
		}
	
		function doVariable(variable) {
			variable.dependencies.forEach(doDep);
		}
	
		function doBlock(block) {
			block.variables.forEach(doVariable);
			block.dependencies.forEach(doDep);
			block.blocks.forEach(doBlock);
		}
		doBlock(this);
		return list;
	};
	
	NormalModule.prototype.createTemplate = function(keepModules, roots) {
		roots.sort(function(a, b) {
			var ia = a.identifier();
			var ib = b.identifier();
			if(ia < ib) return -1;
			if(ib < ia) return 1;
			return 0;
		});
		var template = new NormalModule("", "", "", [], "", null);
		template._source = this._source;
		template.built = this.built;
		template.templateModules = keepModules;
		template._templateOrigin = this;
		template.readableIdentifier = function() {
			return "template of " + this._templateOrigin.id + " referencing " + keepModules.map(function(m) {
				return m.id;
			}).join(", ");
		};
		template.identifier = function() {
			var array = roots.map(function(m) {
				return m.identifier();
			});
			array.sort();
			return array.join("|");
		};
		var args = template.arguments = [];
	
		function doDeps(deps) {
			return deps.map(function(dep) {
				if(dep.module && keepModules.indexOf(dep.module) < 0) {
					var argName = "__webpack_module_template_argument_" + args.length + "__";
					args.push(argName);
					return new TemplateArgumentDependency(argName, dep);
				} else {
					return dep;
				}
			});
		}
	
		function doBlock(block, newBlock) {
			block.variables.forEach(function(variable) {
				var newDependencies = doDeps(variable.dependencies);
				newBlock.addVariable(variable.name, variable.expression, newDependencies);
			});
			newBlock.dependencies = doDeps(block.dependencies);
			block.blocks.forEach(function(childBlock) {
				var newChildBlock = new AsyncDependenciesBlock(childBlock.name, childBlock.module, childBlock.loc);
				newBlock.addBlock(newChildBlock);
				doBlock(childBlock, newChildBlock);
			});
		}
		doBlock(this, template);
		return template;
	};
	
	NormalModule.prototype.getTemplateArguments = function(keepModules) {
		var list = [];
	
		function doDep(dep) {
			if(dep.module && keepModules.indexOf(dep.module) < 0)
				list.push(dep.module);
		}
	
		function doVariable(variable) {
			variable.dependencies.forEach(doDep);
		}
	
		function doBlock(block) {
			block.variables.forEach(doVariable);
			block.dependencies.forEach(doDep);
			block.blocks.forEach(doBlock);
		}
		doBlock(this);
		return list;
	};


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var RawSource = __webpack_require__(40);
	var OriginalSource = __webpack_require__(50);
	var SourceMapSource = __webpack_require__(70);
	var LineToLineMappedSource = __webpack_require__(71);
	var path = __webpack_require__(4); // TODO refactor
	
	var ModuleBuildError = __webpack_require__(72);
	var ModuleError = __webpack_require__(73);
	var ModuleWarning = __webpack_require__(74);
	
	function utf8BufferToString(buf) {
		var str = buf.toString("utf-8");
		if(str.charCodeAt(0) === 0xFEFF) {
			return str.substr(1);
		} else {
			return str;
		}
	}
	
	function NormalModuleMixin(loaders, resource) {
		this.resource = resource;
		this.loaders = loaders;
		var resourcePath = this.splitQuery(this.resource)[0];
		this.context = resourcePath ? path.dirname(resourcePath) : null;
		this.fileDependencies = [];
		this.contextDependencies = [];
		this.warnings = [];
		this.errors = [];
		this.error = null;
		this._source = null;
	}
	module.exports = NormalModuleMixin;
	
	NormalModuleMixin.mixin = function(pt) {
		for(var name in NormalModuleMixin.prototype)
			pt[name] = NormalModuleMixin.prototype[name];
	};
	
	NormalModuleMixin.prototype.splitQuery = function splitQuery(req) {
		var i = req.indexOf("?");
		if(i < 0) return [req, ""];
		return [req.substr(0, i), req.substr(i)];
	};
	
	NormalModuleMixin.prototype.doBuild = function doBuild(options, moduleContext, resolver, fs, callback) {
		var splitQuery = this.splitQuery.bind(this);
		var module = this;
		this.cacheable = true;
	
		// Prepare context
		var loaders = [];
		function addLoaderToList(loader) {
			var l = splitQuery(loader);
			loaders.push({
				request: loader,
				path: l[0],
				query: l[1],
				module: null
			});
		}
		this.loaders.forEach(addLoaderToList);
		var loaderContextCacheable;
		var loaderContext = {
			version: 1,
			context: this.context,
			loaders: loaders,
			loaderIndex: 0,
			resource: this.resource,
			resourcePath: splitQuery(this.resource)[0],
			resourceQuery: this.resource ? splitQuery(this.resource)[1] || null : undefined,
			emitWarning: function(warning) {
				this.warnings.push(new ModuleWarning(this, warning));
			}.bind(this),
			emitError: function(error) {
				this.errors.push(new ModuleError(this, error));
			}.bind(this),
			exec: function(code, filename) {
				if(false) {
					// TODO: check if in enhanced-require
					var Module = require("module");
					var m = new Module(filename, module);
					m.paths = Module._nodeModulePaths(loaderContext.context);
					m.filename = filename;
					m._compile(code, filename);
					return m.exports;
				} else {
					throw new Error("loaderContext.exec is not supported");
				}
			},
			resolve: function(context, request, callback) {
				resolver.resolve(context, request, callback);
			},
			resolveSync: function(context, request) {
				return resolver.resolveSync(context, request);
			},
			cacheable: function(flag) {
				loaderContextCacheable = flag !== false;
			},
			dependency: function(file) {
				this.fileDependencies.push(file);
			}.bind(this),
			addDependency: function(file) {
				this.fileDependencies.push(file);
			}.bind(this),
			addContextDependency: function(context) {
				this.contextDependencies.push(context);
			}.bind(this),
			clearDependencies: function() {
				this.fileDependencies.length = 0;
				this.contextDependencies.length = 0;
				module.cacheable = true;
			}.bind(this),
			inputValue: undefined,
			value: null,
			options: options,
			debug: options.debug
		};
		this.fillLoaderContext(loaderContext, options, moduleContext);
		if(options.loader) for(var key in options.loader)
			loaderContext[key] = options.loader[key];
	
	
		function runSyncOrAsync(fn, context, args, callback) {
			var isSync = true;
			var isDone = false;
			var isError = false; // internal error
			var reportedError = false;
			if(!context.async) context.async = function async() {
				if(isDone) {
					if(reportedError) return; // ignore
					throw new Error("async(): The callback was already called.");
				}
				isSync = false;
				return context.callback;
			};
			context.callback = function() {
				if(isDone) {
					if(reportedError) return; // ignore
					throw new Error("callback(): The callback was already called.");
				}
				isDone = true;
				isSync = false;
				try {
					callback.apply(null, arguments);
				} catch(e) {
					isError = true;
					throw e;
				}
			};
			try {
				var result = (function WEBPACK_CORE_LOADER_EXECUTION() { return fn.apply(context, args) }());
				if(isSync) {
					isDone = true;
					if(result === undefined)
						return callback();
					return callback(null, result);
				}
			} catch(e) {
				if(isError) throw e;
				if(isDone) {
					// loader is already "done", so we cannot use the callback function
					// for better debugging we print the error on the console
					if(typeof e === "object" && e.stack) console.error(e.stack);
					else console.error(e);
					return;
				}
				isDone = true;
				reportedError = true;
				callback(e);
			}
	
		}
	
		// Load and pitch loaders
		(function loadPitch() {
			var l = loaderContext.loaders[loaderContext.loaderIndex];
			if(!l) {
				return onLoadPitchDone.call(this);
			}
			if(l.module) {
				loaderContext.loaderIndex++;
				return loadPitch.call(this);
			}
			if(false) {
				if(require.supportQuery) {
					l.module = require(l.request);
				} else {
					try {
						l.module = require(l.path);
					} catch (e) {
						// it is possible for node to choke on a require if the FD descriptor
						// limit has been reached. give it a chance to recover.
						if (e instanceof Error && e.code === 'EMFILE') {
							if (typeof setImmediate === 'function') {
								// node >= 0.9.0
								return setImmediate(loadPitch.bind(this));
							} else  {
								// node < 0.9.0
								return process.nextTick(loadPitch.bind(this));
							}
						}
						return callback(e)
					}
				}
			} else if(typeof __webpack_require_loader__ === "function") {
				l.module = __webpack_require_loader__(l.request);
			} else {
				return callback(new Error("Cannot load loader, __webpack_require_loader__ not provided."));
			}
			if(typeof l.module !== "function")
				return callback(new Error("Loader " + l.request + " didn't return a function"));
			var pitchedLoaders = [];
			var remaining = [];
			for(var i = 0; i < loaderContext.loaderIndex; i++)
				pitchedLoaders.push(loaderContext.loaders[i].request);
			for(i = loaderContext.loaderIndex + 1; i < loaderContext.loaders.length; i++)
				remaining.push(loaderContext.loaders[i].request);
			remaining.push(loaderContext.resource);
			if(typeof l.module.pitch !== "function") return loadPitch.call(this);
			loaderContextCacheable = false;
			var privateLoaderContext = Object.create(loaderContext);
			privateLoaderContext.query = l.query;
			runSyncOrAsync(l.module.pitch, privateLoaderContext, [remaining.join("!"), pitchedLoaders.join("!"), l.data = {}], function(err) {
				if(err) return onModuleBuildFailed.call(this, err);
				if(!loaderContextCacheable) this.cacheable = false;
				var args = Array.prototype.slice.call(arguments, 1);
				loaderContext.resourcePath = privateLoaderContext.resourcePath;
				loaderContext.resourceQuery = privateLoaderContext.resourceQuery;
				loaderContext.resource = privateLoaderContext.resource;
				loaderContext.loaderIndex = privateLoaderContext.loaderIndex;
				if(args.length > 0) {
					nextLoader.apply(this, [null].concat(args));
				} else {
					loadPitch.call(this);
				}
			}.bind(this));
		}.call(this));
	
		var resourceBuffer;
		function onLoadPitchDone() {
			loaderContext.loaderIndex = loaderContext.loaders.length;
			var request = [];
			for(var i = 0; i < loaderContext.loaders.length; i++)
				request.push(loaderContext.loaders[i].request);
			request.push(loaderContext.resource);
			loaderContext.request = request.join("!");
			var resourcePath = loaderContext.resourcePath;
			loaderContextCacheable = true;
			if(resourcePath) {
				loaderContext.addDependency(resourcePath);
				fs.readFile(resourcePath, function(err, buffer) {
					if(err) return nextLoader(err);
					if(module.lineToLine)
						resourceBuffer = buffer;
					nextLoader(null, buffer);
				});
			} else
				nextLoader(null, null);
		}
	
		function nextLoader(err/*, paramBuffer1, param2, ...*/) {
			if(!loaderContextCacheable) module.cacheable = false;
			var args = Array.prototype.slice.call(arguments, 1);
			if(err) {
				// a loader emitted an error
				return onModuleBuildFailed.call(module, err);
			}
			if(loaderContext.loaderIndex === 0) {
				if(Buffer.isBuffer(args[0]))
					args[0] = utf8BufferToString(args[0]);
				return onModuleBuild.apply(module, args);
			}
			loaderContext.loaderIndex--;
			var l = loaderContext.loaders[loaderContext.loaderIndex];
			if(!l.module) return nextLoader.apply(null, [null].concat(args));
			var privateLoaderContext = Object.create(loaderContext);
			privateLoaderContext.data = l.data;
			privateLoaderContext.inputValue = loaderContext.inputValue;
			privateLoaderContext.query = l.query;
			if(!l.module.raw && Buffer.isBuffer(args[0])) {
				args[0] = utf8BufferToString(args[0]);
			} else if(l.module.raw && typeof args[0] === "string") {
				args[0] = new Buffer(args[0], "utf-8");
			}
			loaderContextCacheable = false;
			runSyncOrAsync(l.module, privateLoaderContext, args, function() {
				loaderContext.inputValue = privateLoaderContext.value;
				nextLoader.apply(null, arguments);
			});
		}
	
	
		function onModuleBuild(source, sourceMap) {
			if(!Buffer.isBuffer(source) && typeof source !== "string")
				return onModuleBuildFailed.call(this, new Error("Final loader didn't return a Buffer or String"));
			if(this.identifier && this.lineToLine && resourceBuffer) {
				this._source = new LineToLineMappedSource(source, this.identifier(),
					resourceBuffer.toString("utf-8"));
			} else if(this.identifier && this.useSourceMap && sourceMap) {
				this._source = new SourceMapSource(source, this.identifier(), sourceMap);
			} else if(this.identifier) {
				this._source = new OriginalSource(source, this.identifier());
			} else {
				this._source = new RawSource(source);
			}
			return callback();
		}
	
		function onModuleBuildFailed(err) {
			this.error = err;
			return callback(new ModuleBuildError(this, err));
		}
	};
	
	NormalModuleMixin.prototype.fillLoaderContext = function fillLoaderContext() {};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7).Buffer))

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var SourceNode = __webpack_require__(20).SourceNode;
	var SourceMapConsumer = __webpack_require__(20).SourceMapConsumer;
	var SourceMapGenerator = __webpack_require__(20).SourceMapGenerator;
	var SourceListMap = __webpack_require__(31).SourceListMap;
	var fromStringWithSourceMap = __webpack_require__(31).fromStringWithSourceMap;
	var Source = __webpack_require__(19);
	
	function SourceMapSource(value, name, sourceMap, originalSource, innerSourceMap) {
		Source.call(this);
		this._value = value;
		this._name = name;
		this._sourceMap = sourceMap;
		this._originalSource = originalSource;
		this._innerSourceMap = innerSourceMap;
	}
	module.exports = SourceMapSource;
	
	SourceMapSource.prototype = Object.create(Source.prototype);
	SourceMapSource.prototype.constructor = SourceMapSource;
	
	SourceMapSource.prototype.source = function() {
		return this._value;
	};
	
	__webpack_require__(39)(SourceMapSource.prototype);
	
	SourceMapSource.prototype.node = function(options) {
		var innerSourceMap = this._innerSourceMap;
		var sourceMap = this._sourceMap;
		if(innerSourceMap) {
			innerSourceMap = new SourceMapConsumer(innerSourceMap);
			sourceMap = SourceMapGenerator.fromSourceMap(new SourceMapConsumer(sourceMap));
			sourceMap.setSourceContent(this._name, this._originalSource);
			sourceMap.applySourceMap(innerSourceMap, this._name);
			sourceMap = sourceMap.toJSON();
		}
		return SourceNode.fromStringWithSourceMap(this._value, new SourceMapConsumer(sourceMap));
	};
	
	SourceMapSource.prototype.listMap = function(options) {
		if(options.module === false)
			return new SourceListMap(this._value, this._name, this._value);
		return fromStringWithSourceMap(this._value, typeof this._sourceMap === "string" ? JSON.parse(this._sourceMap) : this._sourceMap);
	};
	
	SourceMapSource.prototype.updateHash = function(hash) {
		hash.update(this._value);
		if(this._originalSource)
			hash.update(this._originalSource);
	};


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var SourceNode = __webpack_require__(20).SourceNode;
	var SourceListMap = __webpack_require__(31).SourceListMap;
	var Source = __webpack_require__(19);
	
	function LineToLineMappedSource(value, name, originalSource) {
		Source.call(this);
		this._value = value;
		this._name = name;
		this._originalSource = originalSource;
	}
	
	module.exports = LineToLineMappedSource;
	
	LineToLineMappedSource.prototype = Object.create(Source.prototype);
	LineToLineMappedSource.prototype.constructor = LineToLineMappedSource;
	
	LineToLineMappedSource.prototype.source = function() {
		return this._value;
	};
	
	__webpack_require__(39)(LineToLineMappedSource.prototype);
	
	LineToLineMappedSource.prototype.node = function(options) {
		var value = this._value;
		var name = this._name;
		var lines = value.split("\n");
		var node = new SourceNode(null, null, null,
			lines.map(function(line, idx) {
				return new SourceNode(idx+1, 0, name,
					(line + (idx != lines.length-1 ? "\n" : ""))
				);
			})
		);
		node.setSourceContent(name, this._originalSource);
		return node;
	};
	
	LineToLineMappedSource.prototype.listMap = function(options) {
		return new SourceListMap(this._value, this._name, this._originalSource)
	};
	
	LineToLineMappedSource.prototype.updateHash = function(hash) {
		hash.update(this._value);
		hash.update(this._originalSource);
	};


/***/ },
/* 72 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var loaderFlag = "WEBPACK_CORE_LOADER_EXECUTION";
	function ModuleBuildError(module, err) {
		Error.call(this);
		Error.captureStackTrace(this, ModuleBuildError);
		this.name = "ModuleBuildError";
		this.message = "Module build failed: ";
		if(err !== null && typeof err === "object") {
			if(typeof err.stack === "string" && err.stack) {
				var stack = err.stack.split("\n");
				for(var i = 0; i < stack.length; i++)
					if(stack[i].indexOf(loaderFlag) >= 0)
						stack.length = i;
				stack = stack.join("\n");
				if(!err.hideStack) {
					this.message += stack;
				} else {
					this.details = stack;
					if(typeof err.message === "string" && err.message) {
						this.message += err.message;
					} else {
						this.message += err;
					}
				}
			} else if(typeof err.message === "string" && err.message) {
				this.message += err.message;
			} else {
				this.message += err;
			}
		}
		this.module = module;
		this.error = err;
	}
	module.exports = ModuleBuildError;
	
	ModuleBuildError.prototype = Object.create(Error.prototype);


/***/ },
/* 73 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function ModuleError(module, err) {
		Error.call(this);
		Error.captureStackTrace(this, ModuleError);
		this.name = "ModuleError";
		this.module = module;
		this.message = err;
		this.error = err;
	}
	module.exports = ModuleError;
	
	ModuleError.prototype = Object.create(Error.prototype);


/***/ },
/* 74 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function ModuleWarning(module, warning) {
		Error.call(this);
		Error.captureStackTrace(this, ModuleWarning);
		this.name = "ModuleWarning";
		this.module = module;
		this.message = warning;
		this.warning = warning;
	}
	module.exports = ModuleWarning;
	
	ModuleWarning.prototype = Object.create(Error.prototype);


/***/ },
/* 75 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function ModuleParseError(module, source, err) {
		Error.call(this);
		Error.captureStackTrace(this, ModuleParseError);
		this.name = "ModuleParseError";
		this.message = "Module parse failed: " + module.request + " " + err.message;
		this.message += "\nYou may need an appropriate loader to handle this file type.";
		if(typeof err.lineNumber === "number") {
			if(/[\0\u0001\u0002\u0003\u0004\u0005\u0006\u0007]/.test(source)) { // binary file
				this.message += "\n(Source code omitted for this binary file)";
			} else {
				source = source.split("\n");
				this.message += "\n| " + source.slice(Math.max(0, err.lineNumber - 3), err.lineNumber + 2).join("\n| ");
			}
		} else {
			this.message += "\n" + err.stack;
		}
		this.module = module;
		this.error = err;
	}
	module.exports = ModuleParseError;
	
	ModuleParseError.prototype = Object.create(Error.prototype);


/***/ },
/* 76 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function TemplateArgumentDependency(name, dep) {
		this.name = name;
		this.dep = dep;
	}
	module.exports = TemplateArgumentDependency;
	
	TemplateArgumentDependency.prototype.constructor = TemplateArgumentDependency;
	TemplateArgumentDependency.prototype.type = "template argument";
	
	TemplateArgumentDependency.prototype.updateHash = function(hash) {
		hash.update(this.name);
	};
	
	TemplateArgumentDependency.Template = function TemplateArgumentDependencyTemplate() {};
	
	TemplateArgumentDependency.Template.prototype.apply = function(dep, source, outputOptions, requestShortener, dependencyTemplates) {
		var d = dep.dep;
		var template = dependencyTemplates.get(d.constructor);
		if(!template) throw new Error("No template for dependency: " + d.constructor.name);
		if(!template.applyAsTemplateArgument) throw new Error("Template cannot be applied as TemplateArgument: " + d.constructor.name);
		return template.applyAsTemplateArgument(dep.name, d, source, outputOptions, requestShortener, dependencyTemplates);
	};


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var DependenciesBlock = __webpack_require__(16);
	
	function AsyncDependenciesBlock(name, module, loc) {
		DependenciesBlock.call(this);
		this.chunkName = name;
		this.chunks = null;
		this.module = module;
		this.loc = loc;
	
		Object.defineProperty(this, "chunk", {
			get: function() {
				throw new Error("`chunk` was been renamed to `chunks` and is now an array");
			},
			set: function() {
				throw new Error("`chunk` was been renamed to `chunks` and is now an array");
			}
		});
	
	}
	module.exports = AsyncDependenciesBlock;
	
	AsyncDependenciesBlock.prototype = Object.create(DependenciesBlock.prototype);
	
	AsyncDependenciesBlock.prototype.updateHash = function updateHash(hash) {
		hash.update(this.chunkName || "");
		hash.update(this.chunks && this.chunks.map(function(chunk) {
			return typeof chunk.id === "number" ? chunk.id : "";
		}).join(",") || "");
		DependenciesBlock.prototype.updateHash.call(this, hash);
	};
	
	AsyncDependenciesBlock.prototype.disconnect = function() {
		this.chunks = null;
		DependenciesBlock.prototype.disconnect.call(this);
	};


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Module = __webpack_require__(15);
	var OriginalSource = __webpack_require__(50);
	var RawSource = __webpack_require__(40);
	
	function RawModule(source, identifier, readableIdentifier) {
		Module.call(this);
		this.sourceStr = source;
		this.identifierStr = identifier || this.sourceStr;
		this.readableIdentifierStr = readableIdentifier || this.identifierStr;
		this.cacheable = true;
		this.built = false;
	}
	module.exports = RawModule;
	
	RawModule.prototype = Object.create(Module.prototype);
	
	RawModule.prototype.identifier = function() {
		return this.identifierStr;
	};
	
	RawModule.prototype.readableIdentifier = function(requestShortener) {
		return requestShortener.shorten(this.readableIdentifierStr);
	};
	
	RawModule.prototype.needRebuild = function() {
		return false;
	};
	
	RawModule.prototype.build = function(options, compilation, resolver, fs, callback) {
		this.builtTime = new Date().getTime();
		callback();
	};
	
	RawModule.prototype.source = function() {
		if(this.useSourceMap)
			return new OriginalSource(this.sourceStr, this.identifier());
		else
			return new RawSource(this.sourceStr);
	};
	
	RawModule.prototype.size = function() {
		return this.sourceStr.length;
	};
	
	RawModule.prototype.getSourceHash = function() {
		var hash = __webpack_require__(59).createHash("md5");
		hash.update(this.sourceStr);
		return hash.digest("hex");
	};
	
	RawModule.prototype.getAllModuleDependencies = function() {
		return [];
	};
	
	RawModule.prototype.createTemplate = function() {
		return new RawModule(this.sourceStr, "template of " + this.id);
	};
	
	RawModule.prototype.getTemplateArguments = function() {
		return [];
	};


/***/ },
/* 79 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function LoadersList(list) {
		this.list = list || [];
		this.list.forEach(function(element) {
			if(element === null || typeof element !== "object")
				throw new Error("Each element of the loaders list must be an object or array");
		});
	}
	module.exports = LoadersList;
	
	function regExpAsMatcher(regExp) {
		return function(str) {
			return regExp.test(str);
		}
	}
	
	function asMatcher(test) {
		if(typeof test === "string") {
			return regExpAsMatcher(new RegExp("^"+test.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")));
		} else if(typeof test === "function") {
			return test;
		} else if(test instanceof RegExp) {
			return regExpAsMatcher(test);
		} else if(Array.isArray(test)) {
			var matchers = test.map(function(item) {
				if(Array.isArray(item)) {
					var matchers = item.map(asMatcher);
					return function(str) {
						return matchers.every(function(matcher) {
							return matcher(str);
						});
					};
				} else {
					return asMatcher(item);
				}
			});
			return function(str) {
				for(var i = 0; i < test.length; i++) {
					if(matchers[i](str))
						return true;
				}
				return false;
			};
		} else {
			throw new Error(test + " is not a valid test");
		}
	}
	
	function getLoadersFromObject(element) {
		if(element.query) {
			if(!element.loader || element.loader.indexOf("!") >= 0) throw new Error("Cannot define 'query' and multiple loaders in loaders list");
			if(typeof element.query === "string") return [element.loader + "?" + element.query];
			return [element.loader + "?" + JSON.stringify(element.query)];
		}
		if(element.loader) return element.loader.split("!");
		if(element.loaders) return element.loaders;
		throw new Error("Element from loaders list should have one of the fields 'loader' or 'loaders'");
	}
	
	LoadersList.prototype.matchPart = function matchPart(str, test) {
		if(!test) return true;
		var matcher = asMatcher(test);
		return matcher(str);
	};
	
	LoadersList.prototype.match = function match(str) {
		return this.list.map(function(element) {
			if(Array.isArray(element)) {
				for(var i = 0; i < element.length; i++) {
					if(this.matchObject(str, element[i]))
						return getLoadersFromObject(element[i]);
				}
			} else {
				if(this.matchObject(str, element))
					return getLoadersFromObject(element);
			}
		}, this).filter(Boolean).reduce(function(array, r) {
			r.forEach(function(r) {
				array.push(r);
			});
			return array;
		}, []) || [];
	};
	
	LoadersList.prototype.matchObject = function matchObject(str, obj) {
		if(obj.test)
			if(!this.matchPart(str, obj.test)) return false;
		if(obj.include)
			if(!this.matchPart(str, obj.include)) return false;
		if(obj.exclude)
			if(this.matchPart(str, obj.exclude)) return false;
		return true;
	};

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var async = __webpack_require__(10);
	var path = __webpack_require__(4);
	
	var Tapable = __webpack_require__(8);
	var ContextModule = __webpack_require__(81);
	var ContextElementDependency = __webpack_require__(82);
	
	function ContextModuleFactory(resolvers) {
		Tapable.call(this);
		this.resolvers = resolvers;
	}
	module.exports = ContextModuleFactory;
	
	ContextModuleFactory.prototype = Object.create(Tapable.prototype);
	ContextModuleFactory.prototype.constructor = ContextModuleFactory;
	
	ContextModuleFactory.prototype.create = function(context, dependency, callback) {
		this.applyPluginsAsyncWaterfall("before-resolve", {
			context: context,
			request: dependency.request,
			recursive: dependency.recursive,
			regExp: dependency.regExp
		}, function(err, result) {
			if(err) return callback(err);
	
			// Ignored
			if(!result) return callback();
	
			var context = result.context;
			var request = result.request;
			var recursive = result.recursive;
			var regExp = result.regExp;
	
			var loaders, resource, loadersPrefix = "";
			var idx = request.lastIndexOf("!");
			if(idx >= 0) {
				loaders = request.substr(0, idx + 1);
				for(var i = 0; i < loaders.length && loaders[i] === "!"; i++) {
					loadersPrefix += "!";
				}
				loaders = loaders.substr(i).replace(/!+$/, "").replace(/!!+/g, "!");
				if(loaders === "") loaders = [];
				else loaders = loaders.split("!");
				resource = request.substr(idx + 1);
			} else {
				loaders = [];
				resource = request;
			}
	
			async.parallel([
				this.resolvers.context.resolve.bind(this.resolvers.context, context, resource),
				async.map.bind(async, loaders, this.resolvers.loader.resolve.bind(this.resolvers.loader, context))
			], function(err, result) {
				if(err) return callback(err);
	
				this.applyPluginsAsyncWaterfall("after-resolve", {
					loaders: loadersPrefix + result[1].join("!") + (result[1].length > 0 ? "!" : ""),
					resource: result[0],
					recursive: recursive,
					regExp: regExp,
					resolveDependencies: this.resolveDependencies.bind(this)
				}, function(err, result) {
					if(err) return callback(err);
	
					// Ignored
					if(!result) return callback();
	
					return callback(null, new ContextModule(result.resolveDependencies, result.resource, result.recursive, result.regExp, result.loaders));
				});
			}.bind(this));
		}.bind(this));
	};
	
	ContextModuleFactory.prototype.resolveDependencies = function resolveDependencies(fs, resource, recursive, regExp, callback) {
		(function addDirectory(directory, callback) {
			fs.readdir(directory, function(err, files) {
				if(err) return callback(err);
				if(!files || files.length === 0) return callback(null, []);
				async.map(files.filter(function(p) {
					return p.indexOf(".") !== 0;
				}), function(seqment, callback) {
	
					var subResource = path.join(directory, seqment);
	
					fs.stat(subResource, function(err, stat) {
						if(err) return callback(err);
	
						if(stat.isDirectory()) {
	
							if(!recursive) return callback();
							addDirectory.call(this, subResource, callback);
	
						} else if(stat.isFile()) {
	
							var obj = {
								context: resource,
								request: "." + subResource.substr(resource.length).replace(/\\/g, "/")
							};
							this.applyPluginsAsyncWaterfall("alternatives", [obj], function(err, alternatives) {
								if(err) return callback(err);
								alternatives = alternatives.filter(function(obj) {
									return regExp.test(obj.request);
								}).map(function(obj) {
									var dep = new ContextElementDependency(obj.request);
									dep.optional = true;
									return dep;
								});
								callback(null, alternatives);
							});
	
						} else callback();
	
					}.bind(this));
	
				}.bind(this), function(err, result) {
					if(err) return callback(err);
	
					if(!result) return callback(null, []);
	
					callback(null, result.filter(function(i) {
						return !!i;
					}).reduce(function(a, i) {
						return a.concat(i);
					}, []));
				});
			}.bind(this));
		}.call(this, resource, callback));
	};


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Module = __webpack_require__(15);
	var OriginalSource = __webpack_require__(50);
	var RawSource = __webpack_require__(40);
	
	function ContextModule(resolveDependencies, context, recursive, regExp, addon) {
		Module.call(this);
		this.resolveDependencies = resolveDependencies;
		this.context = context;
		this.recursive = recursive;
		this.regExp = regExp;
		this.addon = addon;
		this.cacheable = true;
		this.contextDependencies = [context];
		this.built = false;
	}
	module.exports = ContextModule;
	
	ContextModule.prototype = Object.create(Module.prototype);
	
	ContextModule.prototype.identifier = function() {
		var identifier = "";
		identifier += this.context + " ";
		if(!this.recursive)
			identifier += "nonrecursive ";
		if(this.addon)
			identifier += this.addon;
		if(this.regExp)
			identifier += this.regExp;
		return identifier.replace(/ $/, "");
	};
	
	function prettyRegExp(str) {
		return str.substring(1, str.length - 1);
	}
	
	ContextModule.prototype.readableIdentifier = function(requestShortener) {
		var identifier = "";
		identifier += requestShortener.shorten(this.context) + " ";
		if(!this.recursive)
			identifier += "nonrecursive ";
		if(this.addon)
			identifier += requestShortener.shorten(this.addon);
		if(this.regExp)
			identifier += prettyRegExp(this.regExp + "");
		return identifier.replace(/ $/, "");
	};
	
	ContextModule.prototype.needRebuild = function(fileTimestamps, contextTimestamps) {
		var ts = contextTimestamps[this.context];
		if(!ts) return true;
		return ts >= this.builtTime;
	};
	
	ContextModule.prototype.disconnect = function disconnect() {
		this.built = false;
		Module.prototype.disconnect.call(this);
	};
	
	ContextModule.prototype.build = function(options, compilation, resolver, fs, callback) {
		this.built = true;
		this.builtTime = new Date().getTime();
		var addon = this.addon;
		this.resolveDependencies(fs, this.context, this.recursive, this.regExp, function(err, dependencies) {
			if(err) return callback(err);
			if(dependencies) {
				dependencies.forEach(function(dep) {
					dep.loc = dep.userRequest;
					dep.request = addon + dep.request;
				});
			}
			this.dependencies = dependencies;
			callback();
		}.bind(this));
	};
	
	ContextModule.prototype.source = function() {
		var str;
		if(this.dependencies && this.dependencies.length > 0) {
			var map = {};
			this.dependencies.slice().sort(function(a, b) {
				if(a.userRequest === b.userRequest) return 0;
				return a.userRequest < b.userRequest ? -1 : 1;
			}).forEach(function(dep) {
				if(dep.module)
					map[dep.userRequest] = dep.module.id;
			});
			str = [
				"var map = ", JSON.stringify(map, null, "\t"), ";\n",
				"function webpackContext(req) {\n",
				"\treturn __webpack_require__(webpackContextResolve(req));\n",
				"};\n",
				"function webpackContextResolve(req) {\n",
				"\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n",
				"};\n",
				"webpackContext.keys = function webpackContextKeys() {\n",
				"\treturn Object.keys(map);\n",
				"};\n",
				"webpackContext.resolve = webpackContextResolve;\n",
				"module.exports = webpackContext;\n",
				"webpackContext.id = " + this.id + ";\n"
			];
		} else {
			str = [
				"function webpackContext(req) {\n",
				"\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n",
				"}\n",
				"webpackContext.keys = function() { return []; };\n",
				"webpackContext.resolve = webpackContext;\n",
				"module.exports = webpackContext;\n",
				"webpackContext.id = " + this.id + ";\n"
			];
		}
		if(this.useSourceMap) {
			return new OriginalSource(str.join(""), this.identifier());
		} else {
			return new RawSource(str.join(""));
		}
	};
	
	ContextModule.prototype.size = function() {
		return this.dependencies.map(function(dep) {
			return dep.userRequest.length + 5;
		}).reduce(function(a, b) {
			return a + b;
		}, 160);
	};


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleDependency = __webpack_require__(83);
	
	function ContextElementDependency(request, userRequest) {
		ModuleDependency.call(this, request);
		if(userRequest) {
			this.userRequest = userRequest;
		}
	}
	module.exports = ContextElementDependency;
	
	ContextElementDependency.prototype = Object.create(ModuleDependency.prototype);
	ContextElementDependency.prototype.constructor = ContextElementDependency;
	ContextElementDependency.prototype.type = "context element";


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Dependency = __webpack_require__(56);
	
	function ModuleDependency(request) {
		Dependency.call(this);
		this.request = request;
		this.userRequest = request;
	}
	module.exports = ModuleDependency;
	
	ModuleDependency.prototype = Object.create(Dependency.prototype);
	ModuleDependency.prototype.constructor = ModuleDependency;
	ModuleDependency.prototype.isEqualResource = function isEqualResource(other) {
		if(!(other instanceof ModuleDependency))
			return false;
		return this.request === other.request;
	};


/***/ },
/* 84 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function WebEnvironmentPlugin(inputFileSystem, outputFileSystem) {
		this.inputFileSystem = inputFileSystem;
		this.outputFileSystem = outputFileSystem;
	}
	module.exports = WebEnvironmentPlugin;
	WebEnvironmentPlugin.prototype.apply = function(compiler) {
		var inputFileSystem = compiler.inputFileSystem = this.inputFileSystem;
		compiler.resolvers.normal.fileSystem = inputFileSystem;
		compiler.resolvers.context.fileSystem = inputFileSystem;
		compiler.resolvers.loader.fileSystem = inputFileSystem;
		compiler.outputFileSystem = this.outputFileSystem;
	};


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var OptionsApply = __webpack_require__(86);
	
	var LoaderTargetPlugin = __webpack_require__(87);
	var FunctionModulePlugin = __webpack_require__(88);
	var EvalDevToolModulePlugin = __webpack_require__(90);
	var SourceMapDevToolPlugin = __webpack_require__(93);
	var EvalSourceMapDevToolPlugin = __webpack_require__(95);
	
	var EntryOptionPlugin = __webpack_require__(97);
	var RecordIdsPlugin = __webpack_require__(104);
	
	var APIPlugin = __webpack_require__(105);
	var ConstPlugin = __webpack_require__(109);
	var RequireJsStuffPlugin = __webpack_require__(110);
	var NodeStuffPlugin = __webpack_require__(111);
	var CompatibilityPlugin = __webpack_require__(114);
	var DefinePlugin = __webpack_require__(116);
	
	var MovedToPluginWarningPlugin = __webpack_require__(117);
	var TemplatedPathPlugin = __webpack_require__(118);
	var WarnCaseSensitiveModulesPlugin = __webpack_require__(119);
	
	var LoaderPlugin = __webpack_require__(121);
	var CommonJsPlugin = __webpack_require__(123);
	var AMDPlugin = __webpack_require__(141);
	var RequireContextPlugin = __webpack_require__(153);
	var RequireEnsurePlugin = __webpack_require__(157);
	var RequireIncludePlugin = __webpack_require__(163);
	
	var RemoveParentModulesPlugin = __webpack_require__(166);
	var RemoveEmptyChunksPlugin = __webpack_require__(167);
	var MergeDuplicateChunksPlugin = __webpack_require__(168);
	var FlagIncludedChunksPlugin = __webpack_require__(169);
	
	var UnsafeCachePlugin = __webpack_require__(170);
	var ModulesInDirectoriesPlugin = __webpack_require__(171);
	var ModulesInRootPlugin = __webpack_require__(173);
	var ModuleTemplatesPlugin = __webpack_require__(174);
	var ModuleAsFilePlugin = __webpack_require__(175);
	var ModuleAsDirectoryPlugin = __webpack_require__(176);
	var ModuleAliasPlugin = __webpack_require__(115);
	var DirectoryDefaultFilePlugin = __webpack_require__(177);
	var DirectoryDescriptionFilePlugin = __webpack_require__(178);
	var DirectoryDescriptionFileFieldAliasPlugin = __webpack_require__(179);
	var FileAppendPlugin = __webpack_require__(180);
	var DirectoryResultPlugin = __webpack_require__(181);
	var ResultSymlinkPlugin = __webpack_require__(182);
	
	function WebpackOptionsApply() {
		OptionsApply.call(this);
	}
	module.exports = WebpackOptionsApply;
	
	WebpackOptionsApply.prototype = Object.create(OptionsApply.prototype);
	WebpackOptionsApply.prototype.process = function(options, compiler) {
		compiler.context = options.context;
		if(options.plugins && Array.isArray(options.plugins)) {
			compiler.apply.apply(compiler, options.plugins);
		}
		compiler.outputPath = options.output.path;
		compiler.recordsInputPath = options.recordsInputPath || options.recordsPath;
		compiler.recordsOutputPath = options.recordsOutputPath || options.recordsPath;
		compiler.name = options.name;
		if(typeof options.target === "string") {
			switch(options.target) {
				case "web":
					var JsonpTemplatePlugin = __webpack_require__(183);
					var NodeSourcePlugin = __webpack_require__(188);
					compiler.apply(
						new JsonpTemplatePlugin(options.output),
						new FunctionModulePlugin(options.output),
						new NodeSourcePlugin(options.node),
						new LoaderTargetPlugin("web")
					);
					break;
				case "webworker":
					var WebWorkerTemplatePlugin = __webpack_require__(200);
					var NodeSourcePlugin = __webpack_require__(188);
					compiler.apply(
						new WebWorkerTemplatePlugin(options.output),
						new FunctionModulePlugin(options.output),
						new NodeSourcePlugin(options.node),
						new LoaderTargetPlugin("webworker")
					);
					break;
				case "node":
				case "async-node":
					var NodeTemplatePlugin = __webpack_require__(203);
					var NodeTargetPlugin = __webpack_require__(303);
					compiler.apply(
						new NodeTemplatePlugin(options.output, options.target === "async-node"),
						new FunctionModulePlugin(options.output),
						new NodeTargetPlugin(),
						new LoaderTargetPlugin("node")
					);
					break;
				case "node-webkit":
					var JsonpTemplatePlugin = __webpack_require__(183);
					var NodeTargetPlugin = __webpack_require__(303);
					var ExternalsPlugin = __webpack_require__(304);
					compiler.apply(
						new JsonpTemplatePlugin(options.output),
						new FunctionModulePlugin(options.output),
						new NodeTargetPlugin(),
						new ExternalsPlugin("commonjs", "nw.gui"),
						new LoaderTargetPlugin("node-webkit")
					);
					break;
				case "atom":
				case "electron":
				case "electron-main":
					var NodeTemplatePlugin = __webpack_require__(203);
					var NodeTargetPlugin = __webpack_require__(303);
					var ExternalsPlugin = __webpack_require__(304);
					compiler.apply(
						new NodeTemplatePlugin(options.output, true),
						new FunctionModulePlugin(options.output),
						new NodeTargetPlugin(),
						new ExternalsPlugin("commonjs", [
							"app",
							"auto-updater",
							"browser-window",
							"content-tracing",
							"dialog",
							"electron",
							"global-shortcut",
							"ipc",
							"ipc-main",
							"menu",
							"menu-item",
							"power-monitor",
							"power-save-blocker",
							"protocol",
							"session",
							"web-contents",
							"tray",
							"clipboard",
							"crash-reporter",
							"native-image",
							"screen",
							"shell"
						]),
						new LoaderTargetPlugin(options.target)
					);
					break;
				case "electron-renderer":
					var JsonpTemplatePlugin = __webpack_require__(183);
					var NodeTargetPlugin = __webpack_require__(303);
					var ExternalsPlugin = __webpack_require__(304);
					compiler.apply(
						new JsonpTemplatePlugin(options.output),
						new FunctionModulePlugin(options.output),
						new NodeTargetPlugin(),
						new ExternalsPlugin("commonjs", [
							"desktop-capturer",
							"electron",
							"ipc",
							"ipc-renderer",
							"remote",
							"web-frame",
							"clipboard",
							"crash-reporter",
							"native-image",
							"screen",
							"shell"
						]),
						new LoaderTargetPlugin(options.target)
					);
					break;
				default:
					throw new Error("Unsupported target '" + options.target + "'.");
			}
		} else if(options.target !== false) {
			options.target(compiler);
		} else {
			throw new Error("Unsupported target '" + options.target + "'.");
		}
		if(options.output.library || options.output.libraryTarget !== "var") {
			var LibraryTemplatePlugin = __webpack_require__(308);
			compiler.apply(new LibraryTemplatePlugin(options.output.library, options.output.libraryTarget, options.output.umdNamedDefine));
		}
		if(options.externals) {
			var ExternalsPlugin = __webpack_require__(304);
			compiler.apply(new ExternalsPlugin(options.output.libraryTarget, options.externals));
		}
	
		if(options.hot) {
			compiler.apply(new MovedToPluginWarningPlugin("hot", "HotModuleReplacementPlugin"));
			var HotModuleReplacementPlugin = __webpack_require__(313);
			compiler.apply(new HotModuleReplacementPlugin(options.output));
		}
	
		if(options.devtool && (options.devtool.indexOf("sourcemap") >= 0 || options.devtool.indexOf("source-map") >= 0)) {
			var hidden = options.devtool.indexOf("hidden") >= 0;
			var inline = options.devtool.indexOf("inline") >= 0;
			var evalWrapped = options.devtool.indexOf("eval") >= 0;
			var cheap = options.devtool.indexOf("cheap") >= 0;
			var moduleMaps = options.devtool.indexOf("module") >= 0;
			var noSources = options.devtool.indexOf("nosources") >= 0;
			var legacy = options.devtool.indexOf("@") >= 0;
			var modern = options.devtool.indexOf("#") >= 0;
			var comment = legacy && modern ? "\n/*\n//@ sourceMappingURL=[url]\n//# sourceMappingURL=[url]\n*/" :
				legacy ? "\n/*\n//@ sourceMappingURL=[url]\n*/" :
				modern ? "\n//# sourceMappingURL=[url]" :
				null;
			var Plugin = evalWrapped ? EvalSourceMapDevToolPlugin : SourceMapDevToolPlugin;
			compiler.apply(new Plugin({
				filename: inline ? null : options.output.sourceMapFilename,
				moduleFilenameTemplate: options.output.devtoolModuleFilenameTemplate,
				fallbackModuleFilenameTemplate: options.output.devtoolFallbackModuleFilenameTemplate,
				append: hidden ? false : comment,
				module: moduleMaps ? true : cheap ? false : true,
				columns: cheap ? false : true,
				lineToLine: options.output.devtoolLineToLine,
				noSources: noSources,
			}));
		} else if(options.devtool && options.devtool.indexOf("eval") >= 0) {
			var legacy = options.devtool.indexOf("@") >= 0;
			var modern = options.devtool.indexOf("#") >= 0;
			var comment = legacy && modern ? "//@ sourceURL=[url]\n//# sourceURL=[url]" :
				legacy ? "//@ sourceURL=[url]" :
				modern ? "//# sourceURL=[url]" :
				null;
			compiler.apply(new EvalDevToolModulePlugin(comment, options.output.devtoolModuleFilenameTemplate));
		}
	
		compiler.apply(new EntryOptionPlugin());
		compiler.applyPluginsBailResult("entry-option", options.context, options.entry);
	
		if(options.prefetch) {
			compiler.apply(new MovedToPluginWarningPlugin("prefetch", "PrefetchPlugin"));
			var PrefetchPlugin = __webpack_require__(317);
			options.prefetch.map(function(request) {
				compiler.apply(new PrefetchPlugin(options.context, request));
			});
		}
		compiler.apply(
			new CompatibilityPlugin(),
			new LoaderPlugin(),
			new NodeStuffPlugin(options.node),
			new RequireJsStuffPlugin(),
			new APIPlugin(),
			new ConstPlugin(),
			new RequireIncludePlugin(),
			new RequireEnsurePlugin(),
			new RequireContextPlugin(options.resolve.modulesDirectories, options.resolve.extensions),
			new AMDPlugin(options.module, options.amd || {}),
			new CommonJsPlugin(options.module)
		);
	
		compiler.apply(
			new RemoveParentModulesPlugin(),
			new RemoveEmptyChunksPlugin(),
			new MergeDuplicateChunksPlugin(),
			new FlagIncludedChunksPlugin()
		);
	
		compiler.apply(new TemplatedPathPlugin());
	
		compiler.apply(new RecordIdsPlugin());
	
		compiler.apply(new WarnCaseSensitiveModulesPlugin());
	
		if(options.optimize && options.optimize.occurenceOrder) {
			compiler.apply(new MovedToPluginWarningPlugin("optimize.occurenceOrder", "optimize.OccurrenceOrderPlugin"));
			var OccurrenceOrderPlugin = __webpack_require__(319);
			compiler.apply(new OccurrenceOrderPlugin(options.optimize.occurenceOrderPreferEntry));
		}
	
		if(options.optimize && options.optimize.minChunkSize) {
			compiler.apply(new MovedToPluginWarningPlugin("optimize.minChunkSize", "optimize.MinChunkSizePlugin"));
			var MinChunkSizePlugin = __webpack_require__(320);
			compiler.apply(new MinChunkSizePlugin(options.optimize));
		}
	
		if(options.optimize && options.optimize.maxChunks) {
			compiler.apply(new MovedToPluginWarningPlugin("optimize.maxChunks", "optimize.LimitChunkCountPlugin"));
			var LimitChunkCountPlugin = __webpack_require__(321);
			compiler.apply(new LimitChunkCountPlugin(options.optimize));
		}
	
		if(options.optimize.minimize) {
			compiler.apply(new MovedToPluginWarningPlugin("optimize.minimize", "optimize.UglifyJsPlugin"));
			var UglifyJsPlugin = __webpack_require__(322);
			if(options.optimize.minimize === true)
				compiler.apply(new UglifyJsPlugin());
			else
				compiler.apply(new UglifyJsPlugin(options.optimize.minimize));
		}
	
		if(options.cache === undefined ? options.watch : options.cache) {
			var CachePlugin = __webpack_require__(336);
			compiler.apply(new CachePlugin(typeof options.cache === "object" ? options.cache : null));
		}
	
		if(typeof options.provide === "object") {
			compiler.apply(new MovedToPluginWarningPlugin("provide", "ProvidePlugin"));
			var ProvidePlugin = __webpack_require__(337);
			compiler.apply(new ProvidePlugin(options.provide));
		}
	
		if(options.define) {
			compiler.apply(new MovedToPluginWarningPlugin("define", "DefinePlugin"));
			var defineObject = {};
			if(typeof options.define === "object") {
				Object.keys(options.define).forEach(function(key) {
					defineObject[key] = options.define[key];
				});
			}
			compiler.apply(new DefinePlugin(defineObject));
		}
		if(options.defineDebug !== false)
			compiler.apply(new DefinePlugin({
				DEBUG: !!options.debug
			}));
	
		compiler.applyPlugins("after-plugins", compiler);
		compiler.resolvers.normal.apply(
			new UnsafeCachePlugin(options.resolve.unsafeCache),
			options.resolve.packageAlias ? new DirectoryDescriptionFileFieldAliasPlugin("package.json", options.resolve.packageAlias) : function() {},
			new ModuleAliasPlugin(options.resolve.alias),
			makeRootPlugin("module", options.resolve.root),
			new ModulesInDirectoriesPlugin("module", options.resolve.modulesDirectories),
			makeRootPlugin("module", options.resolve.fallback),
			new ModuleAsFilePlugin("module"),
			new ModuleAsDirectoryPlugin("module"),
			new DirectoryDescriptionFilePlugin("package.json", options.resolve.packageMains),
			new DirectoryDefaultFilePlugin(["index"]),
			new FileAppendPlugin(options.resolve.extensions),
			new ResultSymlinkPlugin()
		);
		compiler.resolvers.context.apply(
			new UnsafeCachePlugin(options.resolve.unsafeCache),
			new ModuleAliasPlugin(options.resolve.alias),
			makeRootPlugin("module", options.resolve.root),
			new ModulesInDirectoriesPlugin("module", options.resolve.modulesDirectories),
			makeRootPlugin("module", options.resolve.fallback),
			new ModuleAsFilePlugin("module"),
			new ModuleAsDirectoryPlugin("module"),
			new DirectoryResultPlugin(),
			new ResultSymlinkPlugin()
		);
		compiler.resolvers.loader.apply(
			new UnsafeCachePlugin(options.resolve.unsafeCache),
			new ModuleAliasPlugin(options.resolveLoader.alias),
			makeRootPlugin("loader-module", options.resolveLoader.root),
			new ModulesInDirectoriesPlugin("loader-module", options.resolveLoader.modulesDirectories),
			makeRootPlugin("loader-module", options.resolveLoader.fallback),
			new ModuleTemplatesPlugin("loader-module", options.resolveLoader.moduleTemplates, "module"),
			new ModuleAsFilePlugin("module"),
			new ModuleAsDirectoryPlugin("module"),
			new DirectoryDescriptionFilePlugin("package.json", options.resolveLoader.packageMains),
			new DirectoryDefaultFilePlugin(["index"]),
			new FileAppendPlugin(options.resolveLoader.extensions),
			new ResultSymlinkPlugin()
		);
		compiler.applyPlugins("after-resolvers", compiler);
		return options;
	};
	
	function makeRootPlugin(name, root) {
		if(typeof root === "string")
			return new ModulesInRootPlugin(name, root);
		else if(Array.isArray(root)) {
			return function() {
				root.forEach(function(root) {
					this.apply(new ModulesInRootPlugin(name, root));
				}, this);
			};
		}
		return function() {};
	}


/***/ },
/* 86 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function OptionsApply() {}
	module.exports = OptionsApply;
	
	OptionsApply.prototype.process = function( /* options, compiler */ ) {
	
	};


/***/ },
/* 87 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function LoaderTargetPlugin(target) {
		this.target = target;
	}
	module.exports = LoaderTargetPlugin;
	LoaderTargetPlugin.prototype.apply = function(compiler) {
		var target = this.target;
		compiler.plugin("compilation", function(compilation) {
			compilation.plugin("normal-module-loader", function(loaderContext) {
				loaderContext.target = target;
			});
		});
	};


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var FunctionModuleTemplatePlugin = __webpack_require__(89);
	var RequestShortener = __webpack_require__(46);
	
	function FunctionModulePlugin(options, requestShortener) {
		this.options = options;
		this.requestShortener = requestShortener;
	}
	module.exports = FunctionModulePlugin;
	FunctionModulePlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.moduleTemplate.requestShortener = this.requestShortener || new RequestShortener(compiler.context);
			compilation.moduleTemplate.apply(new FunctionModuleTemplatePlugin());
		}.bind(this));
	};


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConcatSource = __webpack_require__(49);
	var PrefixSource = __webpack_require__(51);
	
	function FunctionModuleTemplatePlugin() {}
	module.exports = FunctionModuleTemplatePlugin;
	
	FunctionModuleTemplatePlugin.prototype.apply = function(moduleTemplate) {
		moduleTemplate.plugin("render", function(moduleSource, module) {
			var source = new ConcatSource();
			var defaultArguments = ["module", "exports"];
			if((module.arguments && module.arguments.length !== 0) || module.hasDependencies()) {
				defaultArguments.push("__webpack_require__");
			}
			source.add("/***/ function(" + defaultArguments.concat(module.arguments || []).join(", ") + ") {\n\n");
			source.add(new PrefixSource(this.outputOptions.sourcePrefix, moduleSource));
			source.add("\n\n/***/ }");
			return source;
		});
		moduleTemplate.plugin("package", function(moduleSource, module) {
			if(this.outputOptions.pathinfo) {
				var source = new ConcatSource();
				var req = module.readableIdentifier(this.requestShortener);
				source.add("/*!****" + req.replace(/./g, "*") + "****!*\\\n");
				source.add("  !*** " + req.replace(/\*\//g, "*_/") + " ***!\n");
				source.add("  \\****" + req.replace(/./g, "*") + "****/\n");
				source.add(moduleSource);
				return source;
			}
			return moduleSource;
		});
		moduleTemplate.plugin("hash", function(hash) {
			hash.update("FunctionModuleTemplatePlugin");
			hash.update("2");
		});
	};


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var EvalDevToolModuleTemplatePlugin = __webpack_require__(91);
	
	function EvalDevToolModulePlugin(sourceUrlComment, moduleFilenameTemplate) {
		this.sourceUrlComment = sourceUrlComment;
		this.moduleFilenameTemplate = moduleFilenameTemplate;
	}
	module.exports = EvalDevToolModulePlugin;
	EvalDevToolModulePlugin.prototype.apply = function(compiler) {
		var self = this;
		compiler.plugin("compilation", function(compilation) {
			compilation.moduleTemplate.apply(new EvalDevToolModuleTemplatePlugin(self.sourceUrlComment, self.moduleFilenameTemplate));
		});
	};


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var RawSource = __webpack_require__(40);
	var ModuleFilenameHelpers = __webpack_require__(92);
	
	function EvalDevToolModuleTemplatePlugin(sourceUrlComment, moduleFilenameTemplate) {
		this.sourceUrlComment = sourceUrlComment || "//# sourceURL=[url]";
		this.moduleFilenameTemplate = moduleFilenameTemplate || "webpack:///[resourcePath]?[loaders]";
	}
	module.exports = EvalDevToolModuleTemplatePlugin;
	
	EvalDevToolModuleTemplatePlugin.prototype.apply = function(moduleTemplate) {
		var self = this;
		moduleTemplate.plugin("module", function(source, module) {
			var content = source.source();
			var str = ModuleFilenameHelpers.createFilename(module, self.moduleFilenameTemplate, this.requestShortener);
			var footer = ["\n",
				ModuleFilenameHelpers.createFooter(module, this.requestShortener),
				self.sourceUrlComment.replace(/\[url\]/g, encodeURI(str).replace(/%2F/g, "/").replace(/%20/g, "_").replace(/%5E/g, "^").replace(/%5C/g, "\\").replace(/^\//, ""))
			].join("\n");
			return new RawSource("eval(" + JSON.stringify(content + footer) + ");");
		});
		moduleTemplate.plugin("hash", function(hash) {
			hash.update("EvalDevToolModuleTemplatePlugin");
			hash.update("2");
		});
	};


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleFilenameHelpers = exports;
	
	ModuleFilenameHelpers.ALL_LOADERS_RESOURCE = "[all-loaders][resource]";
	ModuleFilenameHelpers.REGEXP_ALL_LOADERS_RESOURCE = /\[all-?loaders\]\[resource\]/gi;
	ModuleFilenameHelpers.LOADERS_RESOURCE = "[loaders][resource]";
	ModuleFilenameHelpers.REGEXP_LOADERS_RESOURCE = /\[loaders\]\[resource\]/gi;
	ModuleFilenameHelpers.RESOURCE = "[resource]";
	ModuleFilenameHelpers.REGEXP_RESOURCE = /\[resource\]/gi;
	ModuleFilenameHelpers.ABSOLUTE_RESOURCE_PATH = "[absolute-resource-path]";
	ModuleFilenameHelpers.REGEXP_ABSOLUTE_RESOURCE_PATH = /\[abs(olute)?-?resource-?path\]/gi;
	ModuleFilenameHelpers.RESOURCE_PATH = "[resource-path]";
	ModuleFilenameHelpers.REGEXP_RESOURCE_PATH = /\[resource-?path\]/gi;
	ModuleFilenameHelpers.ALL_LOADERS = "[all-loaders]";
	ModuleFilenameHelpers.REGEXP_ALL_LOADERS = /\[all-?loaders\]/gi;
	ModuleFilenameHelpers.LOADERS = "[loaders]";
	ModuleFilenameHelpers.REGEXP_LOADERS = /\[loaders\]/gi;
	ModuleFilenameHelpers.QUERY = "[query]";
	ModuleFilenameHelpers.REGEXP_QUERY = /\[query\]/gi;
	ModuleFilenameHelpers.ID = "[id]";
	ModuleFilenameHelpers.REGEXP_ID = /\[id\]/gi;
	ModuleFilenameHelpers.HASH = "[hash]";
	ModuleFilenameHelpers.REGEXP_HASH = /\[hash\]/gi;
	
	function getAfter(str, token) {
		var idx = str.indexOf(token);
		return idx < 0 ? "" : str.substr(idx);
	}
	
	function getBefore(str, token) {
		var idx = str.lastIndexOf(token);
		return idx < 0 ? "" : str.substr(0, idx);
	}
	
	function getHash(str) {
		var hash = __webpack_require__(59).createHash("md5");
		hash.update(str);
		return hash.digest("hex").substr(0, 4);
	}
	
	function asRegExp(test) {
		if(typeof test === "string") test = new RegExp("^" + test.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"));
		return test;
	}
	
	ModuleFilenameHelpers.createFilename = function createFilename(module, moduleFilenameTemplate, requestShortener) {
		if(!module) module = "";
		if(typeof module === "string") {
			var shortIdentifier = requestShortener.shorten(module);
			var identifier = shortIdentifier;
			var moduleId = "";
			var absoluteResourcePath = module.split("!").pop();
			var hash = getHash(identifier);
		} else {
			var shortIdentifier = module.readableIdentifier(requestShortener);
			var identifier = requestShortener.shorten(module.identifier());
			var moduleId = module.id;
			var absoluteResourcePath = module.resourcePath || module.identifier().split("!").pop();
			var hash = getHash(identifier);
		}
		var resource = shortIdentifier.split("!").pop();
		var loaders = getBefore(shortIdentifier, "!");
		var allLoaders = getBefore(identifier, "!");
		var query = getAfter(resource, "?");
		var resourcePath = resource.substr(0, resource.length - query.length);
		if(typeof moduleFilenameTemplate === "function") {
			return moduleFilenameTemplate({
				identifier: identifier,
				shortIdentifier: shortIdentifier,
				resource: resource,
				resourcePath: resourcePath,
				absoluteResourcePath: absoluteResourcePath,
				allLoaders: allLoaders,
				query: query,
				moduleId: moduleId,
				hash: hash
			});
		}
		return moduleFilenameTemplate
			.replace(ModuleFilenameHelpers.REGEXP_ALL_LOADERS_RESOURCE, identifier)
			.replace(ModuleFilenameHelpers.REGEXP_LOADERS_RESOURCE, shortIdentifier)
			.replace(ModuleFilenameHelpers.REGEXP_RESOURCE, resource)
			.replace(ModuleFilenameHelpers.REGEXP_RESOURCE_PATH, resourcePath)
			.replace(ModuleFilenameHelpers.REGEXP_ABSOLUTE_RESOURCE_PATH, absoluteResourcePath)
			.replace(ModuleFilenameHelpers.REGEXP_ALL_LOADERS, allLoaders)
			.replace(ModuleFilenameHelpers.REGEXP_LOADERS, loaders)
			.replace(ModuleFilenameHelpers.REGEXP_QUERY, query)
			.replace(ModuleFilenameHelpers.REGEXP_ID, moduleId)
			.replace(ModuleFilenameHelpers.REGEXP_HASH, hash);
	};
	
	ModuleFilenameHelpers.createFooter = function createFooter(module, requestShortener) {
		if(!module) module = "";
		if(typeof module === "string") {
			return [
				"// WEBPACK FOOTER //",
				"// " + requestShortener.shorten(module)
			].join("\n");
		} else {
			return [
				"//////////////////",
				"// WEBPACK FOOTER",
				"// " + module.readableIdentifier(requestShortener),
				"// module id = " + module.id,
				"// module chunks = " + module.chunks.map(function(c) {
					return c.id;
				}).join(" ")
			].join("\n");
		}
	};
	
	ModuleFilenameHelpers.replaceDuplicates = function replaceDuplicates(array, fn, comparator) {
		var countMap = {};
		var posMap = {};
		array.forEach(function(item, idx) {
			countMap[item] = (countMap[item] || []);
			countMap[item].push(idx);
			posMap[item] = 0;
		});
		if(comparator) {
			Object.keys(countMap).forEach(function(item) {
				countMap[item].sort(comparator);
			});
		}
		return array.map(function(item, i) {
			if(countMap[item].length > 1) {
				if(comparator && countMap[item][0] === i)
					return item;
				return fn(item, i, posMap[item]++);
			} else return item;
		});
	};
	
	ModuleFilenameHelpers.matchPart = function matchPart(str, test) {
		if(!test) return true;
		test = asRegExp(test);
		if(Array.isArray(test)) {
			return test.map(asRegExp).filter(function(regExp) {
				return regExp.test(str);
			}).length > 0;
		} else {
			return test.test(str);
		}
	};
	
	ModuleFilenameHelpers.matchObject = function matchObject(obj, str) {
		if(obj.test)
			if(!ModuleFilenameHelpers.matchPart(str, obj.test)) return false;
		if(obj.include)
			if(!ModuleFilenameHelpers.matchPart(str, obj.include)) return false;
		if(obj.exclude)
			if(ModuleFilenameHelpers.matchPart(str, obj.exclude)) return false;
		return true;
	};


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var path = __webpack_require__(4);
	var RequestShortener = __webpack_require__(46);
	var ConcatSource = __webpack_require__(49);
	var RawSource = __webpack_require__(40);
	var ModuleFilenameHelpers = __webpack_require__(92);
	var SourceMapDevToolModuleOptionsPlugin = __webpack_require__(94);
	
	function SourceMapDevToolPlugin(options, sourceMappingURLComment, moduleFilenameTemplate, fallbackModuleFilenameTemplate) {
		if(!options || typeof options !== "object") {
			this.sourceMapFilename = options;
			this.sourceMappingURLComment = sourceMappingURLComment === false ? false : sourceMappingURLComment || "\n//# sourceMappingURL=[url]";
			this.moduleFilenameTemplate = moduleFilenameTemplate || "webpack:///[resourcePath]";
			this.fallbackModuleFilenameTemplate = fallbackModuleFilenameTemplate || "webpack:///[resourcePath]?[hash]";
			this.options = {};
		} else {
			this.sourceMapFilename = options.filename;
			this.sourceMappingURLComment = options.append === false ? false : options.append || "\n//# sourceMappingURL=[url]";
			this.moduleFilenameTemplate = options.moduleFilenameTemplate || "webpack:///[resourcePath]";
			this.fallbackModuleFilenameTemplate = options.fallbackModuleFilenameTemplate || "webpack:///[resourcePath]?[hash]";
			this.options = options;
		}
	}
	module.exports = SourceMapDevToolPlugin;
	SourceMapDevToolPlugin.prototype.apply = function(compiler) {
		var sourceMapFilename = this.sourceMapFilename;
		var sourceMappingURLComment = this.sourceMappingURLComment;
		var moduleFilenameTemplate = this.moduleFilenameTemplate;
		var fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate;
		var requestShortener = new RequestShortener(compiler.context);
		var options = this.options;
		options.test = options.test || /\.(js|css)($|\?)/i;
		compiler.plugin("compilation", function(compilation) {
			new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);
			compilation.plugin("after-optimize-chunk-assets", function(chunks) {
				var allModules = [];
				var allModuleFilenames = [];
				var tasks = [];
				chunks.forEach(function(chunk) {
					chunk.files.filter(ModuleFilenameHelpers.matchObject.bind(undefined, options)).map(function(file) {
						var asset = this.assets[file];
						if(asset.__SourceMapDevToolData) {
							var data = asset.__SourceMapDevToolData;
							for(var cachedFile in data) {
								this.assets[cachedFile] = data[cachedFile];
								if(cachedFile !== file)
									chunk.files.push(cachedFile);
							}
							return;
						}
						if(asset.sourceAndMap) {
							var sourceAndMap = asset.sourceAndMap(options);
							var sourceMap = sourceAndMap.map;
							var source = sourceAndMap.source;
						} else {
							var sourceMap = asset.map(options);
							var source = asset.source();
						}
						if(sourceMap) {
							return {
								chunk: chunk,
								file: file,
								asset: asset,
								source: source,
								sourceMap: sourceMap
							};
						}
					}, this).filter(Boolean).map(function(task) {
						var modules = task.sourceMap.sources.map(function(source) {
							var module = compilation.findModule(source);
							return module || source;
						});
						var moduleFilenames = modules.map(function(module) {
							return ModuleFilenameHelpers.createFilename(module, moduleFilenameTemplate, requestShortener);
						});
						task.modules = modules;
						task.moduleFilenames = moduleFilenames;
						return task;
					}, this).forEach(function(task) {
						allModules = allModules.concat(task.modules);
						allModuleFilenames = allModuleFilenames.concat(task.moduleFilenames);
						tasks.push(task);
					}, this);
				}, this);
				allModuleFilenames = ModuleFilenameHelpers.replaceDuplicates(allModuleFilenames, function(filename, i) {
					return ModuleFilenameHelpers.createFilename(allModules[i], fallbackModuleFilenameTemplate, requestShortener);
				}, function(ai, bi) {
					var a = allModules[ai];
					var b = allModules[bi];
					a = !a ? "" : typeof a === "string" ? a : a.identifier();
					b = !b ? "" : typeof b === "string" ? b : b.identifier();
					return a.length - b.length;
				});
				allModuleFilenames = ModuleFilenameHelpers.replaceDuplicates(allModuleFilenames, function(filename, i, n) {
					for(var j = 0; j < n; j++)
						filename += "*";
					return filename;
				});
				tasks.forEach(function(task) {
					task.moduleFilenames = allModuleFilenames.slice(0, task.moduleFilenames.length);
					allModuleFilenames = allModuleFilenames.slice(task.moduleFilenames.length);
				}, this);
				tasks.forEach(function(task) {
					var chunk = task.chunk;
					var file = task.file;
					var asset = task.asset;
					var sourceMap = task.sourceMap;
					var source = task.source;
					var moduleFilenames = task.moduleFilenames;
					var modules = task.modules;
					sourceMap.sources = moduleFilenames;
					if(sourceMap.sourcesContent && !options.noSources) {
						sourceMap.sourcesContent = sourceMap.sourcesContent.map(function(content, i) {
							return content + "\n\n\n" + ModuleFilenameHelpers.createFooter(modules[i], requestShortener);
						});
					} else {
						sourceMap.sourcesContent = undefined;
					}
					sourceMap.sourceRoot = "";
					sourceMap.file = file;
					asset.__SourceMapDevToolData = {};
					var currentSourceMappingURLComment = sourceMappingURLComment;
					if(currentSourceMappingURLComment !== false && /\.css($|\?)/i.test(file)) {
						currentSourceMappingURLComment = currentSourceMappingURLComment.replace(/^\n\/\/(.*)$/, "\n/*$1*/");
					}
					if(sourceMapFilename) {
						var filename = file,
							query = "";
						var idx = filename.indexOf("?");
						if(idx >= 0) {
							query = filename.substr(idx);
							filename = filename.substr(0, idx);
						}
						var sourceMapFile = this.getPath(sourceMapFilename, {
							chunk: chunk,
							filename: filename,
							query: query,
							basename: basename(filename)
						});
						var sourceMapUrl = path.relative(path.dirname(file), sourceMapFile).replace(/\\/g, "/");
						if(currentSourceMappingURLComment !== false) {
							asset.__SourceMapDevToolData[file] = this.assets[file] = new ConcatSource(new RawSource(source), currentSourceMappingURLComment.replace(/\[url\]/g, sourceMapUrl));
						}
						asset.__SourceMapDevToolData[sourceMapFile] = this.assets[sourceMapFile] = new RawSource(JSON.stringify(sourceMap));
						chunk.files.push(sourceMapFile);
					} else {
						asset.__SourceMapDevToolData[file] = this.assets[file] = new ConcatSource(new RawSource(source), currentSourceMappingURLComment
							.replace(/\[map\]/g, function() {
								return JSON.stringify(sourceMap);
							})
							.replace(/\[url\]/g, function() {
								return "data:application/json;charset=utf-8;base64," +
									new Buffer(JSON.stringify(sourceMap)).toString("base64");
							})
						);
					}
				}, this);
			});
		});
	};
	
	function basename(name) {
		if(name.indexOf("/") < 0) return name;
		return name.substr(name.lastIndexOf("/") + 1);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7).Buffer))

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleFilenameHelpers = __webpack_require__(92);
	
	function SourceMapDevToolModuleOptionsPlugin(options) {
		this.options = options;
	}
	
	module.exports = SourceMapDevToolModuleOptionsPlugin;
	
	SourceMapDevToolModuleOptionsPlugin.prototype.apply = function(compilation) {
		var options = this.options;
		if(options.module !== false) {
			compilation.plugin("build-module", function(module) {
				module.useSourceMap = true;
			});
		}
		if(options.lineToLine === true) {
			compilation.plugin("build-module", function(module) {
				module.lineToLine = true;
			});
		} else if(options.lineToLine) {
			compilation.plugin("build-module", function(module) {
				if(!module.resource) return;
				var resourcePath = module.resource;
				var idx = resourcePath.indexOf("?");
				if(idx >= 0) resourcePath = resourcePath.substr(0, idx);
				module.lineToLine = ModuleFilenameHelpers.matchObject(options.lineToLine, resourcePath);
			});
		}
	};


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var EvalSourceMapDevToolModuleTemplatePlugin = __webpack_require__(96);
	var SourceMapDevToolModuleOptionsPlugin = __webpack_require__(94);
	
	function EvalSourceMapDevToolPlugin(options, moduleFilenameTemplate) {
		if(!options || typeof options !== "object") {
			this.options = {
				append: options,
				moduleFilenameTemplate: moduleFilenameTemplate
			};
		} else {
			this.options = options;
		}
	}
	module.exports = EvalSourceMapDevToolPlugin;
	EvalSourceMapDevToolPlugin.prototype.apply = function(compiler) {
		var options = this.options;
		compiler.plugin("compilation", function(compilation) {
			new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);
			compilation.moduleTemplate.apply(new EvalSourceMapDevToolModuleTemplatePlugin(compilation, options, options.append, options.moduleFilenameTemplate));
		});
	};


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var RawSource = __webpack_require__(40);
	var ModuleFilenameHelpers = __webpack_require__(92);
	
	function EvalSourceMapDevToolModuleTemplatePlugin(compilation, options, sourceMapComment, moduleFilenameTemplate) {
		this.compilation = compilation;
		this.sourceMapComment = sourceMapComment || "//# sourceMappingURL=[url]";
		this.moduleFilenameTemplate = moduleFilenameTemplate || "webpack:///[resource-path]?[hash]";
		this.options = options;
	}
	module.exports = EvalSourceMapDevToolModuleTemplatePlugin;
	
	EvalSourceMapDevToolModuleTemplatePlugin.prototype.apply = function(moduleTemplate) {
		var self = this;
		var options = this.options;
		moduleTemplate.plugin("module", function(source, module) {
			if(source.__EvalSourceMapDevToolData)
				return source.__EvalSourceMapDevToolData;
	
			if(source.sourceAndMap) {
				var sourceAndMap = source.sourceAndMap(options);
				var sourceMap = sourceAndMap.map;
				var content = sourceAndMap.source;
			} else {
				var sourceMap = source.map(options);
				var content = source.source();
			}
			if(!sourceMap) {
				return source;
			}
	
			// Clone (flat) the sourcemap to ensure that the mutations below do not persist.
			sourceMap = Object.keys(sourceMap).reduce(function(obj, key) {
				obj[key] = sourceMap[key];
				return obj;
			}, {});
			var modules = sourceMap.sources.map(function(source) {
				var module = self.compilation.findModule(source);
				return module || source;
			});
			var moduleFilenames = modules.map(function(module) {
				return ModuleFilenameHelpers.createFilename(module, self.moduleFilenameTemplate, this.requestShortener);
			}, this);
			moduleFilenames = ModuleFilenameHelpers.replaceDuplicates(moduleFilenames, function(filename, i, n) {
				for(var j = 0; j < n; j++)
					filename += "*";
				return filename;
			});
			sourceMap.sources = moduleFilenames;
			if(sourceMap.sourcesContent) {
				sourceMap.sourcesContent = sourceMap.sourcesContent.map(function(content, i) {
					return content + "\n\n\n" + ModuleFilenameHelpers.createFooter(modules[i], this.requestShortener);
				}, this);
			}
			sourceMap.sourceRoot = "";
			sourceMap.file = module.id + ".js";
			var footer = self.sourceMapComment.replace(/\[url\]/g, "data:application/json;charset=utf-8;base64," + new Buffer(JSON.stringify(sourceMap)).toString("base64"));
			source.__EvalSourceMapDevToolData = new RawSource("eval(" + JSON.stringify(content + footer) + ");");
			return source.__EvalSourceMapDevToolData;
		});
		moduleTemplate.plugin("hash", function(hash) {
			hash.update("eval-source-map");
			hash.update("1");
		});
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7).Buffer))

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var SingleEntryPlugin = __webpack_require__(98);
	var MultiEntryPlugin = __webpack_require__(100);
	
	function EntryOptionPlugin() {}
	module.exports = EntryOptionPlugin;
	
	EntryOptionPlugin.prototype.apply = function(compiler) {
		compiler.plugin("entry-option", function(context, entry) {
			function itemToPlugin(item, name) {
				if(Array.isArray(item))
					return new MultiEntryPlugin(context, item, name);
				else
					return new SingleEntryPlugin(context, item, name);
			}
			if(typeof entry === "string" || Array.isArray(entry)) {
				compiler.apply(itemToPlugin(entry, "main"));
			} else if(typeof entry === "object") {
				Object.keys(entry).forEach(function(name) {
					compiler.apply(itemToPlugin(entry[name], name));
				});
			}
			return true;
		});
	};


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var SingleEntryDependency = __webpack_require__(99);
	
	function SingleEntryPlugin(context, entry, name) {
		this.context = context;
		this.entry = entry;
		this.name = name;
	}
	module.exports = SingleEntryPlugin;
	SingleEntryPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation, params) {
			var normalModuleFactory = params.normalModuleFactory;
	
			compilation.dependencyFactories.set(SingleEntryDependency, normalModuleFactory);
		});
		compiler.plugin("make", function(compilation, callback) {
			var dep = new SingleEntryDependency(this.entry);
			dep.loc = this.name;
			compilation.addEntry(this.context, dep, this.name, callback);
		}.bind(this));
	};


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleDependency = __webpack_require__(83);
	
	function SingleEntryDependency(request) {
		ModuleDependency.call(this, request);
	}
	module.exports = SingleEntryDependency;
	
	SingleEntryDependency.prototype = Object.create(ModuleDependency.prototype);
	SingleEntryDependency.prototype.constructor = SingleEntryDependency;
	SingleEntryDependency.prototype.type = "single entry";


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var MultiEntryDependency = __webpack_require__(101);
	var SingleEntryDependency = __webpack_require__(99);
	var MultiModuleFactory = __webpack_require__(102);
	
	function MultiEntryPlugin(context, entries, name) {
		this.context = context;
		this.entries = entries;
		this.name = name;
	}
	module.exports = MultiEntryPlugin;
	MultiEntryPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation, params) {
			var multiModuleFactory = new MultiModuleFactory();
			var normalModuleFactory = params.normalModuleFactory;
	
			compilation.dependencyFactories.set(MultiEntryDependency, multiModuleFactory);
	
			compilation.dependencyFactories.set(SingleEntryDependency, normalModuleFactory);
		});
		compiler.plugin("make", function(compilation, callback) {
			compilation.addEntry(this.context, new MultiEntryDependency(this.entries.map(function(e, idx) {
				var dep = new SingleEntryDependency(e);
				dep.loc = this.name + ":" + (100000 + idx);
				return dep;
			}, this), this.name), this.name, callback);
		}.bind(this));
	};


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Dependency = __webpack_require__(56);
	
	function MultiEntryDependency(dependencies, name) {
		Dependency.call(this);
		this.dependencies = dependencies;
		this.name = name;
	}
	module.exports = MultiEntryDependency;
	
	MultiEntryDependency.prototype = Object.create(Dependency.prototype);
	MultiEntryDependency.prototype.constructor = MultiEntryDependency;
	MultiEntryDependency.prototype.type = "multi entry";


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Tapable = __webpack_require__(8);
	var MultiModule = __webpack_require__(103);
	
	function MultiModuleFactory() {
		Tapable.call(this);
	}
	module.exports = MultiModuleFactory;
	
	MultiModuleFactory.prototype = Object.create(Tapable.prototype);
	MultiModuleFactory.prototype.constructor = MultiModuleFactory;
	
	MultiModuleFactory.prototype.create = function(context, dependency, callback) {
		callback(null, new MultiModule(context, dependency.dependencies, dependency.name));
	};


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Module = __webpack_require__(15);
	var RawSource = __webpack_require__(40);
	
	function MultiModule(context, dependencies, name) {
		Module.call(this);
		this.context = context;
		this.dependencies = dependencies;
		this.name = name;
		this.built = false;
		this.cacheable = true;
	}
	module.exports = MultiModule;
	
	MultiModule.prototype = Object.create(Module.prototype);
	
	MultiModule.prototype.identifier = function() {
		return "multi " + this.name;
	};
	
	MultiModule.prototype.readableIdentifier = function() {
		return "multi " + this.name;
	};
	
	MultiModule.prototype.disconnect = function disconnect() {
		this.built = false;
		Module.prototype.disconnect.call(this);
	};
	
	MultiModule.prototype.build = function build(options, compilation, resolver, fs, callback) {
		this.built = true;
		return callback();
	};
	
	MultiModule.prototype.source = function(dependencyTemplates, outputOptions) {
		var str = [];
		this.dependencies.forEach(function(dep, idx) {
			if(dep.module) {
				if(idx === this.dependencies.length - 1)
					str.push("module.exports = ");
				str.push("__webpack_require__(");
				if(outputOptions.pathinfo)
					str.push("/*! " + dep.request + " */");
				str.push("" + JSON.stringify(dep.module.id));
				str.push(")");
			} else {
				str.push("(function webpackMissingModule() { throw new Error(");
				str.push(JSON.stringify("Cannot find module \"" + dep.request + "\""));
				str.push("); }())");
			}
			str.push(";\n");
		}, this);
		return new RawSource(str.join(""));
	};
	
	MultiModule.prototype.needRebuild = function needRebuild() {
		return false;
	};
	
	MultiModule.prototype.size = function() {
		return 16 + this.dependencies.length * 12;
	};
	
	MultiModule.prototype.updateHash = function(hash) {
		hash.update("multi module");
		hash.update(this.name || "");
		Module.prototype.updateHash.call(this, hash);
	};


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var path = __webpack_require__(4);
	
	function RecordIdsPlugin() {}
	module.exports = RecordIdsPlugin;
	
	function makeRelative(compiler, identifier) {
		var context = compiler.context;
		return identifier.split("|").map(function(str) {
			return identifier.split("!").map(function(str) {
				return path.relative(context, str);
			}).join("!");
		}).join("|");
	}
	
	RecordIdsPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.plugin("record-modules", function(modules, records) {
				records.nextFreeModuleId = compilation.nextFreeModuleId;
				if(!records.modules) records.modules = {};
				if(!records.modules.byIdentifier) records.modules.byIdentifier = {};
				modules.forEach(function(module) {
					var identifier = makeRelative(compiler, module.identifier());
					records.modules.byIdentifier[identifier] = module.id;
				});
			});
			compilation.plugin("revive-modules", function(modules, records) {
				if(records.nextFreeModuleId)
					compilation.nextFreeModuleId = records.nextFreeModuleId;
				if(!records.modules || !records.modules.byIdentifier) return;
				var usedIds = {
					0: true
				};
				modules.forEach(function(module) {
					if(module.id !== null) return;
					var identifier = makeRelative(compiler, module.identifier());
					var id = records.modules.byIdentifier[identifier];
					if(id === undefined) return;
					if(usedIds[id]) return;
					usedIds[id] = true;
					module.id = id;
				});
			});
	
			function getDepBlockIdent(chunk, block) {
				var ident = [];
				if(block.chunks.length > 1)
					ident.push(block.chunks.indexOf(chunk));
				while(block.parent) {
					var p = block.parent;
					var idx = p.blocks.indexOf(block);
					var l = p.blocks.length - 1;
					ident.unshift(idx + "/" + l);
					block = block.parent;
				}
				if(!block.identifier) return null;
				ident.unshift(makeRelative(compiler, block.identifier()));
				return ident.join(":");
			}
			compilation.plugin("record-chunks", function(chunks, records) {
				records.nextFreeChunkId = compilation.nextFreeChunkId;
				if(!records.chunks) records.chunks = {};
				if(!records.chunks.byName) records.chunks.byName = {};
				if(!records.chunks.byBlocks) records.chunks.byBlocks = {};
				chunks.forEach(function(chunk) {
					var name = chunk.name;
					var blockIdents = chunk.blocks.map(getDepBlockIdent.bind(null, chunk)).filter(Boolean);
					if(name) records.chunks.byName[name] = chunk.id;
					blockIdents.forEach(function(blockIdent) {
						records.chunks.byBlocks[blockIdent] = chunk.id;
					});
				});
			});
			compilation.plugin("revive-chunks", function(chunks, records) {
				if(records.nextFreeChunkId)
					compilation.nextFreeChunkId = records.nextFreeChunkId;
				if(!records.chunks) return;
				var usedIds = {};
				if(records.chunks.byName) {
					chunks.forEach(function(chunk) {
						if(chunk.id !== null) return;
						if(!chunk.name) return;
						var id = records.chunks.byName[chunk.name];
						if(id === undefined) return;
						if(usedIds[id]) return;
						usedIds[id] = true;
						chunk.id = id;
					});
				}
				if(records.chunks.byBlocks) {
					var argumentedChunks = chunks.filter(function(chunk) {
						return chunk.id === null;
					}).map(function(chunk) {
						return {
							chunk: chunk,
							blockIdents: chunk.blocks.map(getDepBlockIdent.bind(null, chunk)).filter(Boolean)
						};
					}).filter(function(arg) {
						return arg.blockIdents.length > 0;
					});
					var blockIdentsCount = {};
					argumentedChunks.forEach(function(arg, idx) {
						arg.blockIdents.forEach(function(blockIdent) {
							var id = records.chunks.byBlocks[blockIdent];
							if(typeof id !== "number") return;
							var accessor = id + ":" + idx;
							blockIdentsCount[accessor] = (blockIdentsCount[accessor] || 0) + 1;
						});
					});
					blockIdentsCount = Object.keys(blockIdentsCount).map(function(accessor) {
						return [blockIdentsCount[accessor]].concat(accessor.split(":").map(Number));
					}).sort(function(a, b) {
						return b[0] - a[0];
					});
					blockIdentsCount.forEach(function(arg) {
						var id = arg[1];
						if(usedIds[id]) return;
						var idx = arg[2];
						var chunk = argumentedChunks[idx].chunk;
						if(chunk.id !== null) return;
						usedIds[id] = true;
						chunk.id = id;
					});
				}
			});
		});
	};


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConstDependency = __webpack_require__(106);
	var BasicEvaluatedExpression = __webpack_require__(62);
	
	var NullFactory = __webpack_require__(108);
	
	function APIPlugin() {}
	module.exports = APIPlugin;
	
	var REPLACEMENTS = {
		__webpack_require__: "__webpack_require__", // eslint-disable-line camelcase
		__webpack_public_path__: "__webpack_require__.p", // eslint-disable-line camelcase
		__webpack_modules__: "__webpack_require__.m", // eslint-disable-line camelcase
		__webpack_chunk_load__: "__webpack_require__.e", // eslint-disable-line camelcase
		__non_webpack_require__: "require", // eslint-disable-line camelcase
		"require.onError": "__webpack_require__.onError" // eslint-disable-line camelcase
	};
	var REPLACEMENT_TYPES = {
		__webpack_public_path__: "string", // eslint-disable-line camelcase
		__webpack_require__: "function", // eslint-disable-line camelcase
		__webpack_modules__: "object", // eslint-disable-line camelcase
		__webpack_chunk_load__: "function" // eslint-disable-line camelcase
	};
	var IGNORES = [];
	APIPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());
		});
		Object.keys(REPLACEMENTS).forEach(function(key) {
			compiler.parser.plugin("expression " + key, function(expr) {
				var dep = new ConstDependency(REPLACEMENTS[key], expr.range);
				dep.loc = expr.loc;
				this.state.current.addDependency(dep);
				return true;
			});
			compiler.parser.plugin("evaluate typeof " + key, function(expr) {
				return new BasicEvaluatedExpression().setString(REPLACEMENT_TYPES[key]).setRange(expr.range);
			});
		});
		IGNORES.forEach(function(key) {
			compiler.parser.plugin(key, function() {
				return true;
			});
		});
	};


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var NullDependency = __webpack_require__(107);
	
	function ConstDependency(expression, range) {
		NullDependency.call(this);
		this.expression = expression;
		this.range = range;
	}
	module.exports = ConstDependency;
	
	ConstDependency.prototype = Object.create(NullDependency.prototype);
	ConstDependency.prototype.constructor = ConstDependency;
	
	ConstDependency.Template = function ConstDependencyTemplate() {};
	
	ConstDependency.Template.prototype.apply = function(dep, source) {
		if(typeof dep.range === "number")
			source.insert(dep.range, dep.expression);
		else
			source.replace(dep.range[0], dep.range[1] - 1, dep.expression);
	};
	
	ConstDependency.prototype.updateHash = function(hash) {
		hash.update(this.range + "");
		hash.update(this.expression + "");
	};


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Dependency = __webpack_require__(56);
	
	function NullDependency() {
		Dependency.call(this);
	}
	module.exports = NullDependency;
	
	NullDependency.prototype = Object.create(Dependency.prototype);
	NullDependency.prototype.constructor = NullDependency;
	NullDependency.prototype.type = "null";
	NullDependency.prototype.isEqualResource = function() {
		return false;
	};


/***/ },
/* 108 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function NullFactory() {}
	module.exports = NullFactory;
	
	NullFactory.prototype.create = function(context, dependency, callback) {
		return callback();
	};


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConstDependency = __webpack_require__(106);
	var BasicEvaluatedExpression = __webpack_require__(62);
	
	var NullFactory = __webpack_require__(108);
	
	function ConstPlugin() {}
	module.exports = ConstPlugin;
	
	ConstPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());
		});
		compiler.parser.plugin("statement if", function(statement) {
			var param = this.evaluateExpression(statement.test);
			var bool = param.asBool();
			if(typeof bool === "boolean") {
				if(statement.test.type !== "Literal") {
					var dep = new ConstDependency(bool + "", param.range);
					dep.loc = statement.loc;
					this.state.current.addDependency(dep);
				}
				return bool;
			}
		});
		compiler.parser.plugin("expression ?:", function(expression) {
			var param = this.evaluateExpression(expression.test);
			var bool = param.asBool();
			if(typeof bool === "boolean") {
				if(expression.test.type !== "Literal") {
					var dep = new ConstDependency(" " + bool + "", param.range);
					dep.loc = expression.loc;
					this.state.current.addDependency(dep);
				}
				return bool;
			}
		});
		compiler.parser.plugin("evaluate Identifier __resourceQuery", function(expr) {
			if(!this.state.module) return;
			var res = new BasicEvaluatedExpression();
			res.setString(this.state.module.splitQuery(this.state.module.resource)[1]);
			res.setRange(expr.range);
			return res;
		});
		compiler.parser.plugin("expression __resourceQuery", function() {
			if(!this.state.module) return;
			this.state.current.addVariable("__resourceQuery", JSON.stringify(this.state.module.splitQuery(this.state.module.resource)[1]));
			return true;
		});
	};


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConstDependency = __webpack_require__(106);
	
	var NullFactory = __webpack_require__(108);
	
	function RequireJsStuffPlugin() {}
	module.exports = RequireJsStuffPlugin;
	RequireJsStuffPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());
		});
	
		function remove(expr) {
			var dep = new ConstDependency(";", expr.range);
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			return true;
		}
		compiler.parser.plugin("call require.config", remove);
		compiler.parser.plugin("call requirejs.config", remove);
	
		compiler.parser.plugin("expression require.version", function(expr) {
			var dep = new ConstDependency(JSON.stringify("0.0.0"), expr.range);
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			return true;
		});
		compiler.parser.plugin("expression requirejs.onError", function(expr) {
			var dep = new ConstDependency(JSON.stringify("__webpack_require__.onError"), expr.range);
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			return true;
		});
	};


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var path = __webpack_require__(4);
	var ModuleParserHelpers = __webpack_require__(112);
	var ConstDependency = __webpack_require__(106);
	var BasicEvaluatedExpression = __webpack_require__(62);
	var UnsupportedFeatureWarning = __webpack_require__(113);
	
	var NullFactory = __webpack_require__(108);
	
	function NodeStuffPlugin(options) {
		this.options = options;
	}
	module.exports = NodeStuffPlugin;
	NodeStuffPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());
		});
	
		function ignore() {
			return true;
		}
	
		function setConstant(expressionName, value) {
			compiler.parser.plugin("expression " + expressionName, function() {
				this.state.current.addVariable(expressionName, JSON.stringify(value));
				return true;
			});
		}
	
		function setModuleConstant(expressionName, fn) {
			compiler.parser.plugin("expression " + expressionName, function() {
				this.state.current.addVariable(expressionName, JSON.stringify(fn(this.state.module)));
				return true;
			});
		}
		var context = compiler.context;
		if(this.options.__filename === "mock") {
			setConstant("__filename", "/index.js");
		} else if(this.options.__filename) {
			setModuleConstant("__filename", function(module) {
				return path.relative(context, module.resource);
			});
		}
		compiler.parser.plugin("evaluate Identifier __filename", function(expr) {
			if(!this.state.module) return;
			var res = new BasicEvaluatedExpression();
			res.setString(this.state.module.splitQuery(this.state.module.resource)[0]);
			res.setRange(expr.range);
			return res;
		});
		if(this.options.__dirname === "mock") {
			setConstant("__dirname", "/");
		} else if(this.options.__dirname) {
			setModuleConstant("__dirname", function(module) {
				return path.relative(context, module.context);
			});
		}
		compiler.parser.plugin("evaluate Identifier __dirname", function(expr) {
			if(!this.state.module) return;
			var res = new BasicEvaluatedExpression();
			res.setString(this.state.module.context);
			res.setRange(expr.range);
			return res;
		});
		compiler.parser.plugin("expression require.main", function(expr) {
			var dep = new ConstDependency("__webpack_require__.c[0]", expr.range);
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			return true;
		});
		compiler.parser.plugin("expression require.extensions", function(expr) {
			var dep = new ConstDependency("(void 0)", expr.range);
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			if(!this.state.module) return;
			this.state.module.warnings.push(new UnsupportedFeatureWarning(this.state.module, "require.extensions is not supported by webpack. Use a loader instead."));
			return true;
		});
		compiler.parser.plugin("expression module.exports", ignore);
		compiler.parser.plugin("expression module.loaded", ignore);
		compiler.parser.plugin("expression module.id", ignore);
		compiler.parser.plugin("evaluate Identifier module.hot", function(expr) {
			return new BasicEvaluatedExpression().setBoolean(false).setRange(expr.range);
		});
		compiler.parser.plugin("expression module", function() {
			var moduleJsPath = path.join(__dirname, "..", "buildin", "module.js");
			if(this.state.module.context) {
				moduleJsPath = path.relative(this.state.module.context, moduleJsPath);
				if(!/^[A-Z]:/i.test(moduleJsPath)) {
					moduleJsPath = "./" + moduleJsPath.replace(/\\/g, "/");
				}
			}
			return ModuleParserHelpers.addParsedVariable(this, "module", "require(" + JSON.stringify(moduleJsPath) + ")(module)");
		});
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ },
/* 112 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleParserHelpers = exports;
	
	ModuleParserHelpers.addParsedVariable = function(parser, name, expression) {
		if(!parser.state.current.addVariable) return false;
		var deps = [];
		parser.parse(expression, {
			current: {
				addDependency: function(dep) {
					dep.userRequest = name;
					deps.push(dep);
				}
			},
			module: parser.state.module
		});
		parser.state.current.addVariable(name, expression, deps);
		return true;
	};


/***/ },
/* 113 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function UnsupportedFeatureWarning(module, message) {
		Error.call(this);
		Error.captureStackTrace(this, UnsupportedFeatureWarning);
		this.name = "UnsupportedFeatureWarning";
		this.message = message;
		this.origin = this.module = module;
	}
	module.exports = UnsupportedFeatureWarning;
	
	UnsupportedFeatureWarning.prototype = Object.create(Error.prototype);


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var path = __webpack_require__(4);
	var ConstDependency = __webpack_require__(106);
	
	var ModuleAliasPlugin = __webpack_require__(115);
	
	var NullFactory = __webpack_require__(108);
	
	function CompatibilityPlugin() {}
	module.exports = CompatibilityPlugin;
	
	CompatibilityPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());
		});
		compiler.resolvers.normal.apply(
			new ModuleAliasPlugin({
				"enhanced-require": path.join(__dirname, "..", "buildin", "return-require.js")
			})
		);
		compiler.parser.plugin("call require", function(expr) {
			// support for browserify style require delegator: "require(o, !0)"
			if(expr.arguments.length !== 2) return;
			var second = this.evaluateExpression(expr.arguments[1]);
			if(!second.isBoolean()) return;
			if(second.asBool() !== true) return;
			var dep = new ConstDependency("require", expr.callee.range);
			dep.loc = expr.loc;
			if(this.state.current.dependencies.length > 1) {
				var last = this.state.current.dependencies[this.state.current.dependencies.length - 1];
				if(last.critical && last.request === "." && last.userRequest === "." && last.recursive)
					this.state.current.dependencies.pop();
			}
			dep.critical = "This seems to be a pre-built javascript file. Though this is possible, it's not recommended. Try to require the original source to get better results.";
			this.state.current.addDependency(dep);
			return true;
		});
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var createInnerCallback = __webpack_require__(64);
	
	function ModuleAliasPlugin(aliasMap) {
		this.aliasMap = aliasMap;
	}
	module.exports = ModuleAliasPlugin;
	
	ModuleAliasPlugin.prototype.apply = function(resolver) {
		var aliasMap = this.aliasMap;
		resolver.plugin("module", function(request, callback) {
			var fs = this.fileSystem;
			var keys = Object.keys(aliasMap);
			var i = 0;
			(function next() {
				for(;i < keys.length; i++) {
					var aliasName = keys[i];
					var onlyModule = /\$$/.test(aliasName);
					if(onlyModule) aliasName = aliasName.substr(0, aliasName.length-1);
					if((!onlyModule && request.request.indexOf(aliasName + "/") === 0) || request.request === aliasName) {
						var aliasValue = aliasMap[keys[i]];
						if(request.request.indexOf(aliasValue + "/") !== 0 && request.request != aliasValue) {
							var newRequestStr = aliasValue + request.request.substr(aliasName.length);
							var newRequest = this.parse(newRequestStr);
							var obj = {
								path: request.path,
								request: newRequest.path,
								query: newRequest.query,
								directory: newRequest.directory
							};
							var newCallback = createInnerCallback(callback, callback, "aliased with mapping " + JSON.stringify(aliasName) + ": " + JSON.stringify(aliasValue) + " to " + newRequestStr);
							if(newRequest.module) return this.doResolve("module", obj, newCallback);
							if(newRequest.directory) return this.doResolve("directory", obj, newCallback);
							return this.doResolve(["file", "directory"], obj, newCallback);
						}
					}
				}
				return callback();
			}.call(this));
		});
	};


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConstDependency = __webpack_require__(106);
	var BasicEvaluatedExpression = __webpack_require__(62);
	
	var NullFactory = __webpack_require__(108);
	
	function DefinePlugin(definitions) {
		this.definitions = definitions;
	}
	module.exports = DefinePlugin;
	DefinePlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());
		});
		(function walkDefinitions(definitions, prefix) {
			Object.keys(definitions).forEach(function(key) {
				var code = definitions[key];
				if(code && typeof code === "object" && !(code instanceof RegExp)) {
					walkDefinitions(code, prefix + key + ".");
					applyObjectDefine(prefix + key, code);
					return;
				}
				applyDefineKey(prefix, key);
				applyDefine(prefix + key, code);
			});
		}(this.definitions, ""));
	
		function stringifyObj(obj) {
			return "{" + Object.keys(obj).map(function(key) {
				var code = obj[key];
				return JSON.stringify(key) + ":" + toCode(code);
			}).join(",") + "}";
		}
	
		function toCode(code) {
			if(code === null) return "null";
			else if(code === undefined) return "undefined";
			else if(code instanceof RegExp && code.toString) return code.toString();
			else if(typeof code === "function" && code.toString) return code.toString();
			else if(typeof code === "object") return stringifyObj(code);
			else return code + "";
		}
	
		function applyDefineKey(prefix, key) {
			var splittedKey = key.split(".");
			splittedKey.slice(1).forEach(function(_, i) {
				var fullKey = prefix + splittedKey.slice(0, i + 1).join(".");
				compiler.parser.plugin("can-rename " + fullKey, function() {
					return true;
				});
			});
		}
	
		function applyDefine(key, code) {
			var isTypeof = /^typeof\s+/.test(key);
			if(isTypeof) key = key.replace(/^typeof\s+/, "");
			var recurse = false;
			var recurseTypeof = false;
			code = toCode(code);
			if(!isTypeof) {
				compiler.parser.plugin("can-rename " + key, function() {
					return true;
				});
				compiler.parser.plugin("evaluate Identifier " + key, function(expr) {
					if(recurse) return;
					recurse = true;
					var res = compiler.parser.evaluate(code);
					recurse = false;
					res.setRange(expr.range);
					return res;
				});
				compiler.parser.plugin("expression " + key, function(expr) {
					var dep = new ConstDependency("(" + code + ")", expr.range);
					dep.loc = expr.loc;
					this.state.current.addDependency(dep);
					return true;
				});
			}
			var typeofCode = isTypeof ? code : "typeof (" + code + ")";
			compiler.parser.plugin("evaluate typeof " + key, function(expr) {
				if(recurseTypeof) return;
				recurseTypeof = true;
				var res = compiler.parser.evaluate(typeofCode);
				recurseTypeof = false;
				res.setRange(expr.range);
				return res;
			});
			compiler.parser.plugin("typeof " + key, function(expr) {
				var res = compiler.parser.evaluate(typeofCode);
				if(!res.isString()) return;
				var dep = new ConstDependency(JSON.stringify(res.string), expr.range);
				dep.loc = expr.loc;
				this.state.current.addDependency(dep);
				return true;
			});
		}
	
		function applyObjectDefine(key, obj) {
			var code = stringifyObj(obj);
			compiler.parser.plugin("can-rename " + key, function() {
				return true;
			});
			compiler.parser.plugin("evaluate Identifier " + key, function(expr) {
				return new BasicEvaluatedExpression().setRange(expr.range);
			});
			compiler.parser.plugin("evaluate typeof " + key, function(expr) {
				return new BasicEvaluatedExpression().setString("object").setRange(expr.range);
			});
			compiler.parser.plugin("expression " + key, function(expr) {
				var dep = new ConstDependency("(" + code + ")", expr.range);
				dep.loc = expr.loc;
				this.state.current.addDependency(dep);
				return true;
			});
			compiler.parser.plugin("typeof " + key, function(expr) {
				var dep = new ConstDependency("\"object\"", expr.range);
				dep.loc = expr.loc;
				this.state.current.addDependency(dep);
				return true;
			});
		}
	};


/***/ },
/* 117 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function MovedToPluginWarningPlugin(optionName, pluginName) {
		this.optionName = optionName;
		this.pluginName = pluginName;
	}
	module.exports = MovedToPluginWarningPlugin;
	
	MovedToPluginWarningPlugin.prototype.apply = function(compiler) {
		var optionName = this.optionName;
		var pluginName = this.pluginName;
		compiler.plugin("compilation", function(compilation) {
			compilation.warnings.push(new Error("webpack options:\nDEPRECATED option '" + optionName + "' will be moved to the " + pluginName + ". Use this instead.\nFor more info about the usage of the " + pluginName + " see https://webpack.github.io/docs/list-of-plugins.html"));
		});
	};


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Jason Anderson @diurnalist
	*/
	
	var REGEXP_HASH = /\[hash(?::(\d+))?\]/gi,
		REGEXP_CHUNKHASH = /\[chunkhash(?::(\d+))?\]/gi,
		REGEXP_NAME = /\[name\]/gi,
		REGEXP_ID = /\[id\]/gi,
		REGEXP_FILE = /\[file\]/gi,
		REGEXP_QUERY = /\[query\]/gi,
		REGEXP_FILEBASE = /\[filebase\]/gi;
	
	// Using global RegExp for .test is dangerous
	// We use a normal RegExp instead of .test
	var REGEXP_HASH_FOR_TEST = new RegExp(REGEXP_HASH.source, "i"),
		REGEXP_CHUNKHASH_FOR_TEST = new RegExp(REGEXP_CHUNKHASH.source, "i"),
		REGEXP_NAME_FOR_TEST = new RegExp(REGEXP_NAME.source, "i");
	
	// Backwards compatibility; expose regexes on Template object
	var Template = __webpack_require__(52);
	Template.REGEXP_HASH = REGEXP_HASH;
	Template.REGEXP_CHUNKHASH = REGEXP_CHUNKHASH;
	Template.REGEXP_NAME = REGEXP_NAME;
	Template.REGEXP_ID = REGEXP_ID;
	Template.REGEXP_FILE = REGEXP_FILE;
	Template.REGEXP_QUERY = REGEXP_QUERY;
	Template.REGEXP_FILEBASE = REGEXP_FILEBASE;
	
	function TemplatedPathPlugin() {}
	
	module.exports = TemplatedPathPlugin;
	
	function withHashLength(replacer, handlerFn) {
		return function(_, hashLength) {
			var length = hashLength && parseInt(hashLength, 10);
			if(length && handlerFn) {
				return handlerFn(length);
			}
			var hash = replacer.apply(this, arguments);
			return length ? hash.slice(0, length) : hash;
		};
	}
	
	function getReplacer(value, allowEmpty) {
		return function(match) {
			// last argument in replacer is the entire input string
			var input = arguments[arguments.length - 1];
			if(value == null) {
				if(!allowEmpty) throw new Error("Path variable " + match + " not implemented in this context: " + input);
				return "";
			} else {
				return "" + value;
			}
		};
	}
	
	function replacePathVariables(path, data) {
		var chunk = data.chunk;
		var chunkId = chunk && chunk.id;
		var chunkName = chunk && (chunk.name || chunk.id);
		var chunkHash = chunk && (chunk.renderedHash || chunk.hash);
		var chunkHashWithLength = chunk && chunk.hashWithLength;
	
		if(data.noChunkHash && REGEXP_CHUNKHASH_FOR_TEST.test(path)) {
			throw new Error("Cannot use [chunkhash] for chunk in '" + path + "' (use [hash] instead)");
		}
	
		return path
			.replace(REGEXP_HASH, withHashLength(getReplacer(data.hash), data.hashWithLength))
			.replace(REGEXP_CHUNKHASH, withHashLength(getReplacer(chunkHash), chunkHashWithLength))
			.replace(REGEXP_ID, getReplacer(chunkId))
			.replace(REGEXP_NAME, getReplacer(chunkName))
			.replace(REGEXP_FILE, getReplacer(data.filename))
			.replace(REGEXP_FILEBASE, getReplacer(data.basename))
			// query is optional, it's OK if it's in a path but there's nothing to replace it with
			.replace(REGEXP_QUERY, getReplacer(data.query, true));
	}
	
	TemplatedPathPlugin.prototype.constructor = TemplatedPathPlugin;
	TemplatedPathPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			var mainTemplate = compilation.mainTemplate;
	
			mainTemplate.plugin("asset-path", replacePathVariables);
	
			mainTemplate.plugin("global-hash", function(chunk, paths) {
				var outputOptions = this.outputOptions;
				var publicPath = outputOptions.publicPath || "";
				var filename = outputOptions.filename || "";
				var chunkFilename = outputOptions.chunkFilename || outputOptions.filename;
				if(REGEXP_HASH_FOR_TEST.test(publicPath) || REGEXP_CHUNKHASH_FOR_TEST.test(publicPath) || REGEXP_NAME_FOR_TEST.test(publicPath))
					return true;
				if(REGEXP_HASH_FOR_TEST.test(filename))
					return true;
				if(REGEXP_HASH_FOR_TEST.test(chunkFilename))
					return true;
				if(REGEXP_HASH_FOR_TEST.test(paths.join("|")))
					return true;
			});
	
			mainTemplate.plugin("hash-for-chunk", function(hash, chunk) {
				var outputOptions = this.outputOptions;
				var chunkFilename = outputOptions.chunkFilename || outputOptions.filename;
				if(REGEXP_CHUNKHASH_FOR_TEST.test(chunkFilename))
					hash.update(JSON.stringify(chunk.getChunkMaps(true, true).hash));
				if(REGEXP_NAME_FOR_TEST.test(chunkFilename))
					hash.update(JSON.stringify(chunk.getChunkMaps(true, true).name));
			});
		});
	};


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var CaseSensitiveModulesWarning = __webpack_require__(120);
	
	function WarnCaseSensitiveModulesPlugin() {}
	module.exports = WarnCaseSensitiveModulesPlugin;
	
	WarnCaseSensitiveModulesPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.plugin("seal", function() {
				var moduleWithoutCase = {};
				this.modules.forEach(function(module) {
					var ident = module.identifier().toLowerCase();
					if(moduleWithoutCase["$" + ident]) {
						if(moduleWithoutCase["$" + ident] !== true)
							this.warnings.push(new CaseSensitiveModulesWarning(moduleWithoutCase["$" + ident]));
						this.warnings.push(new CaseSensitiveModulesWarning(module));
						moduleWithoutCase["$" + ident] = true;
					} else {
						moduleWithoutCase["$" + ident] = module;
					}
				}, this);
			});
		});
	};


/***/ },
/* 120 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function CaseSensitiveModulesWarning(module) {
		Error.call(this);
		Error.captureStackTrace(this, CaseSensitiveModulesWarning);
		this.name = "CaseSensitiveModulesWarning";
		this.message = "There is another module with an equal name when case is ignored.\n" +
			"This can lead to unexpected behavior when compiling on a filesystem with other case-semantic.\n" +
			"Rename module if multiple modules are expected or use equal casing if one module is expected.";
		this.origin = this.module = module;
	}
	module.exports = CaseSensitiveModulesWarning;
	
	CaseSensitiveModulesWarning.prototype = Object.create(Error.prototype);


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var LoaderDependency = __webpack_require__(122);
	
	function LoaderPlugin() {}
	module.exports = LoaderPlugin;
	
	LoaderPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation, params) {
			var normalModuleFactory = params.normalModuleFactory;
	
			compilation.dependencyFactories.set(LoaderDependency, normalModuleFactory);
		});
		compiler.plugin("compilation", function(compilation) {
			compilation.plugin("normal-module-loader", function(loaderContext, module) {
				loaderContext.loadModule = function loadModule(request, callback) {
					var dep = new LoaderDependency(request);
					dep.loc = request;
					compilation.addModuleDependencies(module, [
						[dep]
					], true, "lm", false, function(err) {
						if(err) return callback(err);
	
						if(!dep.module) return callback(new Error("Cannot load the module"));
						if(dep.module.building) dep.module.building.push(next);
						else next();
	
						function next(err) {
							if(err) return callback(err);
	
							if(dep.module.error) return callback(dep.module.error);
							if(!dep.module._source) throw new Error("The module created for a LoaderDependency must have a property _source");
							var source, map;
							var moduleSource = dep.module._source;
							if(moduleSource.sourceAndMap) {
								var sourceAndMap = moduleSource.sourceAndMap();
								map = sourceAndMap.map;
								source = sourceAndMap.source;
							} else {
								map = moduleSource.map();
								source = moduleSource.source();
							}
							if(dep.module.fileDependencies) {
								dep.module.fileDependencies.forEach(function(dep) {
									loaderContext.addDependency(dep);
								});
							}
							if(dep.module.contextDependencies) {
								dep.module.contextDependencies.forEach(function(dep) {
									loaderContext.addContextDependency(dep);
								});
							}
							return callback(null, source, map, dep.module);
						}
					});
				};
			});
		});
	};


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleDependency = __webpack_require__(83);
	
	function LoaderDependency(request) {
		ModuleDependency.call(this, request);
	}
	module.exports = LoaderDependency;
	
	LoaderDependency.prototype = Object.create(ModuleDependency.prototype);
	LoaderDependency.prototype.constructor = LoaderDependency;
	LoaderDependency.prototype.type = "loader";


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConstDependency = __webpack_require__(106);
	var CommonJsRequireDependency = __webpack_require__(124);
	var CommonJsRequireContextDependency = __webpack_require__(127);
	var RequireResolveDependency = __webpack_require__(130);
	var RequireResolveContextDependency = __webpack_require__(131);
	var RequireResolveHeaderDependency = __webpack_require__(133);
	var RequireHeaderDependency = __webpack_require__(134);
	
	var NullFactory = __webpack_require__(108);
	
	var RequireResolveDependencyParserPlugin = __webpack_require__(135);
	var CommonJsRequireDependencyParserPlugin = __webpack_require__(137);
	
	var BasicEvaluatedExpression = __webpack_require__(62);
	
	function CommonJsPlugin(options) {
		this.options = options;
	}
	module.exports = CommonJsPlugin;
	
	CommonJsPlugin.prototype.apply = function(compiler) {
		function setTypeof(expr, value) {
			compiler.parser.plugin("evaluate typeof " + expr, function(expr) {
				return new BasicEvaluatedExpression().setString(value).setRange(expr.range);
			});
			compiler.parser.plugin("typeof " + expr, function(expr) {
				var dep = new ConstDependency(JSON.stringify(value), expr.range);
				dep.loc = expr.loc;
				this.state.current.addDependency(dep);
				return true;
			});
		}
		compiler.plugin("compilation", function(compilation, params) {
			var normalModuleFactory = params.normalModuleFactory;
			var contextModuleFactory = params.contextModuleFactory;
	
			compilation.dependencyFactories.set(CommonJsRequireDependency, normalModuleFactory);
			compilation.dependencyTemplates.set(CommonJsRequireDependency, new CommonJsRequireDependency.Template());
	
			compilation.dependencyFactories.set(CommonJsRequireContextDependency, contextModuleFactory);
			compilation.dependencyTemplates.set(CommonJsRequireContextDependency, new CommonJsRequireContextDependency.Template());
	
			compilation.dependencyFactories.set(RequireResolveDependency, normalModuleFactory);
			compilation.dependencyTemplates.set(RequireResolveDependency, new RequireResolveDependency.Template());
	
			compilation.dependencyFactories.set(RequireResolveContextDependency, contextModuleFactory);
			compilation.dependencyTemplates.set(RequireResolveContextDependency, new RequireResolveContextDependency.Template());
	
			compilation.dependencyFactories.set(RequireResolveHeaderDependency, new NullFactory());
			compilation.dependencyTemplates.set(RequireResolveHeaderDependency, new RequireResolveHeaderDependency.Template());
	
			compilation.dependencyFactories.set(RequireHeaderDependency, new NullFactory());
			compilation.dependencyTemplates.set(RequireHeaderDependency, new RequireHeaderDependency.Template());
		});
		setTypeof("require", "function");
		setTypeof("require.resolve", "function");
		setTypeof("require.resolveWeak", "function");
		compiler.parser.plugin("evaluate typeof module", function(expr) {
			return new BasicEvaluatedExpression().setString("object").setRange(expr.range);
		});
		compiler.parser.plugin("assign require", function(expr) {
			// to not leak to global "require", we need to define a local require here.
			var dep = new ConstDependency("var require;", 0);
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			this.scope.definitions.push("require");
			return true;
		});
		compiler.parser.plugin("can-rename require", function() {
			return true;
		});
		compiler.parser.plugin("rename require", function(expr) {
			// define the require variable. It's still undefined, but not "not defined".
			var dep = new ConstDependency("var require;", 0);
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			return false;
		});
		compiler.parser.plugin("typeof module", function() {
			return true;
		});
		compiler.parser.plugin("evaluate typeof exports", function(expr) {
			return new BasicEvaluatedExpression().setString("object").setRange(expr.range);
		});
		compiler.parser.apply(
			new CommonJsRequireDependencyParserPlugin(this.options),
			new RequireResolveDependencyParserPlugin(this.options)
		);
	};


/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleDependency = __webpack_require__(83);
	
	function CommonJsRequireDependency(request, range) {
		ModuleDependency.call(this, request);
		this.range = range;
	}
	module.exports = CommonJsRequireDependency;
	
	CommonJsRequireDependency.prototype = Object.create(ModuleDependency.prototype);
	CommonJsRequireDependency.prototype.constructor = CommonJsRequireDependency;
	CommonJsRequireDependency.prototype.type = "cjs require";
	
	CommonJsRequireDependency.Template = __webpack_require__(125);


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function ModuleDependencyTemplateAsId() {}
	module.exports = ModuleDependencyTemplateAsId;
	
	ModuleDependencyTemplateAsId.prototype.apply = function(dep, source, outputOptions, requestShortener) {
		if(!dep.range) return;
		var comment = "";
		if(outputOptions.pathinfo) comment = "/*! " + requestShortener.shorten(dep.request) + " */ ";
		if(dep.module)
			var content = comment + JSON.stringify(dep.module.id);
		else
			var content = __webpack_require__(126).module(dep.request);
		source.replace(dep.range[0], dep.range[1] - 1, content);
	};
	
	ModuleDependencyTemplateAsId.prototype.applyAsTemplateArgument = function(name, dep, source) {
		if(!dep.range) return;
		source.replace(dep.range[0], dep.range[1] - 1, name);
	};


/***/ },
/* 126 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	exports.module = function(request) {
		return "!(function webpackMissingModule() { " +
			exports.moduleCode(request) +
			" }())";
	};
	
	exports.moduleCode = function(request) {
		return "var e = new Error(" + JSON.stringify("Cannot find module \"" + request + "\"") + "); " +
			"e.code = 'MODULE_NOT_FOUND'; " +
			"throw e;";
	};
	
	exports.moduleMetaInfo = function(request) {
		return "!(function webpackMissingModuleMetaInfo() { " +
			"var e = new Error(" + JSON.stringify("Module cannot be imported because no meta info about exports is available \"" + request + "\"") + "); " +
			"e.code = 'MODULE_NOT_FOUND'; " +
			"throw e; " +
			"}())";
	};


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ContextDependency = __webpack_require__(128);
	
	function CommonJsRequireContextDependency(request, recursive, regExp, range, valueRange) {
		ContextDependency.call(this, request, recursive, regExp);
		this.range = range;
		this.valueRange = valueRange;
	}
	module.exports = CommonJsRequireContextDependency;
	
	CommonJsRequireContextDependency.prototype = Object.create(ContextDependency.prototype);
	CommonJsRequireContextDependency.prototype.constructor = CommonJsRequireContextDependency;
	CommonJsRequireContextDependency.prototype.type = "cjs require context";
	
	CommonJsRequireContextDependency.Template = __webpack_require__(129);


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Dependency = __webpack_require__(56);
	
	function ContextDependency(request, recursive, regExp) {
		Dependency.call(this);
		this.request = request;
		this.userRequest = request;
		this.recursive = recursive;
		this.regExp = regExp;
	}
	module.exports = ContextDependency;
	
	ContextDependency.prototype = Object.create(Dependency.prototype);
	ContextDependency.prototype.constructor = ContextDependency;
	ContextDependency.prototype.isEqualResource = function(other) {
		if(!(other instanceof ContextDependency))
			return false;
		return this.request === other.request &&
			this.recursive === other.recursive &&
			this.regExp === other.regExp;
	};


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function ContextDependencyTemplateAsRequireCall() {}
	module.exports = ContextDependencyTemplateAsRequireCall;
	
	ContextDependencyTemplateAsRequireCall.prototype.apply = function(dep, source, outputOptions, requestShortener) {
		var comment = "";
		if(outputOptions.pathinfo) comment = "/*! " + requestShortener.shorten(dep.request) + " */ ";
		if(dep.module && dep.module.dependencies && dep.module.dependencies.length > 0) {
			if(dep.valueRange) {
				source.replace(dep.valueRange[1], dep.range[1] - 1, ")");
				source.replace(dep.range[0], dep.valueRange[0] - 1, "__webpack_require__(" + comment + JSON.stringify(dep.module.id) + ")(" + (typeof dep.prepend === "string" ? JSON.stringify(dep.prepend) : "") + "");
			} else {
				source.replace(dep.range[0], dep.range[1] - 1, "__webpack_require__(" + comment + JSON.stringify(dep.module.id) + ")");
			}
		} else {
			var content = __webpack_require__(126).module(dep.request);
			source.replace(dep.range[0], dep.range[1] - 1, content);
		}
	};
	
	ContextDependencyTemplateAsRequireCall.prototype.applyAsTemplateArgument = function(name, dep, source) {
		if(dep.valueRange) {
			source.replace(dep.valueRange[1], dep.range[1] - 1, ")");
			source.replace(dep.range[0], dep.valueRange[0] - 1, "__webpack_require__(" + name + ")(" + (typeof dep.prepend === "string" ? JSON.stringify(dep.prepend) : "") + "");
		} else {
			source.replace(dep.range[0], dep.range[1] - 1, "__webpack_require__(" + name + ")");
		}
	};


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleDependency = __webpack_require__(83);
	
	function RequireResolveDependency(request, range) {
		ModuleDependency.call(this, request);
		this.range = range;
	}
	module.exports = RequireResolveDependency;
	
	RequireResolveDependency.prototype = Object.create(ModuleDependency.prototype);
	RequireResolveDependency.prototype.constructor = RequireResolveDependency;
	RequireResolveDependency.prototype.type = "require.resolve";
	
	RequireResolveDependency.Template = __webpack_require__(125);


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ContextDependency = __webpack_require__(128);
	
	function RequireResolveContextDependency(request, recursive, regExp, range, valueRange) {
		ContextDependency.call(this, request, recursive, regExp);
		this.range = range;
		this.valueRange = valueRange;
	}
	module.exports = RequireResolveContextDependency;
	
	RequireResolveContextDependency.prototype = Object.create(ContextDependency.prototype);
	RequireResolveContextDependency.prototype.constructor = RequireResolveContextDependency;
	RequireResolveContextDependency.prototype.type = "amd require context";
	
	RequireResolveContextDependency.Template = __webpack_require__(132);


/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function ContextDependencyTemplateAsId() {}
	module.exports = ContextDependencyTemplateAsId;
	
	ContextDependencyTemplateAsId.prototype.apply = function(dep, source, outputOptions, requestShortener) {
		var comment = "";
		if(outputOptions.pathinfo) comment = "/*! " + requestShortener.shorten(dep.request) + " */ ";
		if(dep.module && dep.module.dependencies && dep.module.dependencies.length > 0) {
			if(dep.valueRange) {
				source.replace(dep.valueRange[1], dep.range[1] - 1, ")");
				source.replace(dep.range[0], dep.valueRange[0] - 1, "__webpack_require__(" + comment + JSON.stringify(dep.module.id) + ").resolve(" + (typeof dep.prepend === "string" ? JSON.stringify(dep.prepend) : "") + "");
			} else {
				source.replace(dep.range[0], dep.range[1] - 1, "__webpack_require__(" + comment + JSON.stringify(dep.module.id) + ").resolve");
			}
		} else {
			var content = __webpack_require__(126).module(dep.request);
			source.replace(dep.range[0], dep.range[1] - 1, content);
		}
	};


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var NullDependency = __webpack_require__(107);
	
	function RequireResolveHeaderDependency(range) {
		if(!Array.isArray(range)) throw new Error("range must be valid");
		NullDependency.call(this);
		this.range = range;
	}
	module.exports = RequireResolveHeaderDependency;
	
	RequireResolveHeaderDependency.prototype = Object.create(NullDependency.prototype);
	RequireResolveHeaderDependency.prototype.constructor = RequireResolveHeaderDependency;
	
	RequireResolveHeaderDependency.Template = function RequireResolveHeaderDependencyTemplate() {};
	
	RequireResolveHeaderDependency.Template.prototype.apply = function(dep, source) {
		source.replace(dep.range[0], dep.range[1] - 1, "/*require.resolve*/");
	};
	
	RequireResolveHeaderDependency.Template.prototype.applyAsTemplateArgument = function(name, dep, source) {
		source.replace(dep.range[0], dep.range[1] - 1, "/*require.resolve*/");
	};


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var NullDependency = __webpack_require__(107);
	
	function RequireHeaderDependency(range) {
		if(!Array.isArray(range)) throw new Error("range must be valid");
		NullDependency.call(this);
		this.range = range;
	}
	module.exports = RequireHeaderDependency;
	
	RequireHeaderDependency.prototype = Object.create(NullDependency.prototype);
	RequireHeaderDependency.prototype.constructor = RequireHeaderDependency;
	
	RequireHeaderDependency.Template = function RequireHeaderDependencyTemplate() {};
	
	RequireHeaderDependency.Template.prototype.apply = function(dep, source) {
		source.replace(dep.range[0], dep.range[1] - 1, "__webpack_require__");
	};
	
	RequireHeaderDependency.Template.prototype.applyAsTemplateArgument = function(name, dep, source) {
		source.replace(dep.range[0], dep.range[1] - 1, "require");
	};


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var RequireResolveDependency = __webpack_require__(130);
	var RequireResolveContextDependency = __webpack_require__(131);
	var RequireResolveHeaderDependency = __webpack_require__(133);
	var ContextDependencyHelpers = __webpack_require__(136);
	
	function RequireResolveDependencyParserPlugin(options) {
		this.options = options;
	}
	
	module.exports = RequireResolveDependencyParserPlugin;
	
	RequireResolveDependencyParserPlugin.prototype.apply = function(parser) {
		var options = this.options;
		parser.plugin("call require.resolve", function(expr) {
			return this.applyPluginsBailResult("call require.resolve(Weak)", expr, false);
		});
		parser.plugin("call require.resolveWeak", function(expr) {
			return this.applyPluginsBailResult("call require.resolve(Weak)", expr, true);
		});
		parser.plugin("call require.resolve(Weak)", function(expr, weak) {
			if(expr.arguments.length !== 1) return;
			var param = this.evaluateExpression(expr.arguments[0]);
			var dep;
			if(param.isConditional()) {
				param.options.forEach(function(option) {
					var result = this.applyPluginsBailResult("call require.resolve(Weak):item", expr, option, weak);
					if(result === undefined) {
						this.applyPluginsBailResult("call require.resolve(Weak):context", expr, option, weak);
					}
				}, this);
				dep = new RequireResolveHeaderDependency(expr.callee.range);
				dep.loc = expr.loc;
				this.state.current.addDependency(dep);
				return true;
			} else {
				var result = this.applyPluginsBailResult("call require.resolve(Weak):item", expr, param, weak);
				if(result === undefined) {
					this.applyPluginsBailResult("call require.resolve(Weak):context", expr, param, weak);
				}
				dep = new RequireResolveHeaderDependency(expr.callee.range);
				dep.loc = expr.loc;
				this.state.current.addDependency(dep);
				return true;
			}
		});
		parser.plugin("call require.resolve(Weak):item", function(expr, param, weak) {
			if(param.isString()) {
				var dep = new RequireResolveDependency(param.string, param.range);
				dep.loc = expr.loc;
				dep.optional = !!this.scope.inTry;
				dep.weak = weak;
				this.state.current.addDependency(dep);
				return true;
			}
		});
		parser.plugin("call require.resolve(Weak):context", function(expr, param, weak) {
			var dep = ContextDependencyHelpers.create(RequireResolveContextDependency, param.range, param, expr, options);
			if(!dep) return;
			dep.loc = expr.loc;
			dep.optional = !!this.scope.inTry;
			dep.weak = weak;
			this.state.current.addDependency(dep);
			return true;
		});
	};


/***/ },
/* 136 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ContextDependencyHelpers = exports;
	
	ContextDependencyHelpers.create = function(Dep, range, param, expr, options) {
		if(param.isWrapped() && (param.prefix && param.prefix.isString() || param.postfix && param.postfix.isString())) {
			var prefix = param.prefix && param.prefix.isString() ? param.prefix.string : "";
			var postfix = param.postfix && param.postfix.isString() ? param.postfix.string : "";
			var prefixRange = param.prefix && param.prefix.isString() ? param.prefix.range : null;
			var valueRange = [prefixRange ? prefixRange[1] : param.range[0], param.range[1]];
			var idx = prefix.lastIndexOf("/");
			var context = ".";
			if(idx >= 0) {
				context = prefix.substr(0, idx);
				prefix = "." + prefix.substr(idx);
			}
			var regExp = new RegExp("^" +
				prefix.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&") +
				options.wrappedContextRegExp.source +
				postfix.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&") + "$");
			var dep = new Dep(context, options.wrappedContextRecursive, regExp, range, valueRange);
			dep.loc = expr.loc;
			dep.prepend = param.prefix && param.prefix.isString() ? prefix : null;
			dep.critical = options.wrappedContextCritical && "a part of the request of a dependency is an expression";
			return dep;
		} else {
			var dep = new Dep(options.exprContextRequest, options.exprContextRecursive, options.exprContextRegExp, range, param.range);
			dep.loc = expr.loc;
			dep.critical = options.exprContextCritical && "the request of a dependency is an expression";
			return dep;
		}
	};


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConstDependency = __webpack_require__(106);
	var CommonJsRequireDependency = __webpack_require__(124);
	var CommonJsRequireContextDependency = __webpack_require__(127);
	var RequireHeaderDependency = __webpack_require__(134);
	var LocalModuleDependency = __webpack_require__(138);
	var ContextDependencyHelpers = __webpack_require__(136);
	var LocalModulesHelpers = __webpack_require__(139);
	
	function CommonJsRequireDependencyParserPlugin(options) {
		this.options = options;
	}
	
	module.exports = CommonJsRequireDependencyParserPlugin;
	
	CommonJsRequireDependencyParserPlugin.prototype.apply = function(parser) {
		var options = this.options;
		parser.plugin("expression require.cache", function(expr) {
			var dep = new ConstDependency("__webpack_require__.c", expr.range);
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			return true;
		});
		parser.plugin("expression require", function(expr) {
			var dep = new CommonJsRequireContextDependency(options.unknownContextRequest, options.unknownContextRecursive, options.unknownContextRegExp, expr.range);
			dep.critical = options.unknownContextCritical && "require function is used in a way in which dependencies cannot be statically extracted";
			dep.loc = expr.loc;
			dep.optional = !!this.scope.inTry;
			this.state.current.addDependency(dep);
			return true;
		});
		parser.plugin("call require", function(expr) {
			if(expr.arguments.length !== 1) return;
			var localModule, dep;
			var param = this.evaluateExpression(expr.arguments[0]);
			if(param.isConditional()) {
				var isExpression = false;
				var prevLength = this.state.current.dependencies.length;
				dep = new RequireHeaderDependency(expr.callee.range);
				dep.loc = expr.loc;
				this.state.current.addDependency(dep);
				param.options.forEach(function(param) {
					var result = this.applyPluginsBailResult("call require:commonjs:item", expr, param);
					if(result === undefined) {
						isExpression = true;
					}
				}, this);
				if(isExpression) {
					this.state.current.dependencies.length = prevLength;
				} else {
					return true;
				}
			}
			if(param.isString() && (localModule = LocalModulesHelpers.getLocalModule(this.state, param.string))) {
				dep = new LocalModuleDependency(localModule, expr.range);
				dep.loc = expr.loc;
				this.state.current.addDependency(dep);
				return true;
			} else {
				var result = this.applyPluginsBailResult("call require:commonjs:item", expr, param);
				if(result === undefined) {
					this.applyPluginsBailResult("call require:commonjs:context", expr, param);
				} else {
					dep = new RequireHeaderDependency(expr.callee.range);
					dep.loc = expr.loc;
					this.state.current.addDependency(dep);
				}
				return true;
			}
		});
		parser.plugin("call require:commonjs:item", function(expr, param) {
			if(param.isString()) {
				var dep = new CommonJsRequireDependency(param.string, param.range);
				dep.loc = expr.loc;
				dep.optional = !!this.scope.inTry;
				this.state.current.addDependency(dep);
				return true;
			}
		});
		parser.plugin("call require:commonjs:context", function(expr, param) {
			var dep = ContextDependencyHelpers.create(CommonJsRequireContextDependency, expr.range, param, expr, options);
			if(!dep) return;
			dep.loc = expr.loc;
			dep.optional = !!this.scope.inTry;
			this.state.current.addDependency(dep);
			return true;
		});
	};


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var NullDependency = __webpack_require__(107);
	
	function LocalModuleDependency(localModule, range) {
		NullDependency.call(this);
		localModule.flagUsed();
		this.localModule = localModule;
		this.range = range;
	}
	module.exports = LocalModuleDependency;
	
	LocalModuleDependency.prototype = Object.create(NullDependency.prototype);
	LocalModuleDependency.prototype.constructor = LocalModuleDependency;
	
	LocalModuleDependency.Template = function LocalModuleDependencyTemplate() {};
	
	LocalModuleDependency.Template.prototype.apply = function(dep, source) {
		if(!dep.range) return;
		source.replace(dep.range[0], dep.range[1] - 1, dep.localModule.variableName());
	};


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var LocalModule = __webpack_require__(140);
	
	var LocalModulesHelpers = exports;
	
	LocalModulesHelpers.addLocalModule = function(state, name) {
		if(!state.localModules) state.localModules = [];
		var m = new LocalModule(state.module, name, state.localModules.length);
		state.localModules.push(m);
		return m;
	};
	
	LocalModulesHelpers.getLocalModule = function(state, name, namedModule) {
		if(!state.localModules) return null;
		if(namedModule) {
			// resolve dependency name relative to the defining named module
			name = lookup(namedModule, name);
		}
		for(var i = 0; i < state.localModules.length; i++) {
			if(state.localModules[i].name === name)
				return state.localModules[i];
		}
		return null;
	};
	
	function lookup(parent, mod) {
		if(mod.charAt(0) !== ".") return mod;
	
		var path = parent.split("/"),
			segs = mod.split("/");
		path.pop();
	
		for(var i = 0; i < segs.length; i++) {
			var seg = segs[i];
			if(seg === "..") path.pop();
			else if(seg !== ".") path.push(seg);
		}
	
		return path.join("/");
	}


/***/ },
/* 140 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function LocalModule(module, name, idx) {
		this.module = module;
		this.name = name;
		this.idx = idx;
		this.used = false;
	}
	module.exports = LocalModule;
	
	LocalModule.prototype.flagUsed = function() {
		this.used = true;
	};
	
	LocalModule.prototype.variableName = function() {
		return "__WEBPACK_LOCAL_MODULE_" + this.idx + "__";
	};


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var path = __webpack_require__(4);
	var AMDRequireDependency = __webpack_require__(142);
	var AMDRequireItemDependency = __webpack_require__(144);
	var AMDRequireArrayDependency = __webpack_require__(146);
	var AMDRequireContextDependency = __webpack_require__(147);
	var AMDDefineDependency = __webpack_require__(148);
	var LocalModuleDependency = __webpack_require__(138);
	var ConstDependency = __webpack_require__(106);
	
	var NullFactory = __webpack_require__(108);
	
	var AMDRequireDependenciesBlockParserPlugin = __webpack_require__(149);
	var AMDDefineDependencyParserPlugin = __webpack_require__(152);
	
	var ModuleAliasPlugin = __webpack_require__(115);
	
	var BasicEvaluatedExpression = __webpack_require__(62);
	
	function AMDPlugin(options, amdOptions) {
		this.amdOptions = amdOptions;
		this.options = options;
	}
	module.exports = AMDPlugin;
	
	AMDPlugin.prototype.apply = function(compiler) {
		function setTypeof(expr, value) {
			compiler.parser.plugin("evaluate typeof " + expr, function(expr) {
				return new BasicEvaluatedExpression().setString(value).setRange(expr.range);
			});
			compiler.parser.plugin("typeof " + expr, function(expr) {
				var dep = new ConstDependency(JSON.stringify(value), expr.range);
				dep.loc = expr.loc;
				this.state.current.addDependency(dep);
				return true;
			});
		}
	
		function setExpressionToModule(expr, module) {
			compiler.parser.plugin("expression " + expr, function(expr) {
				var dep = new AMDRequireItemDependency(module, expr.range);
				dep.userRequest = expr;
				dep.loc = expr.loc;
				this.state.current.addDependency(dep);
				return true;
			});
		}
		var amdOptions = this.amdOptions;
		compiler.plugin("compilation", function(compilation, params) {
			var normalModuleFactory = params.normalModuleFactory;
			var contextModuleFactory = params.contextModuleFactory;
	
			compilation.dependencyFactories.set(AMDRequireDependency, new NullFactory());
			compilation.dependencyTemplates.set(AMDRequireDependency, new AMDRequireDependency.Template());
	
			compilation.dependencyFactories.set(AMDRequireItemDependency, normalModuleFactory);
			compilation.dependencyTemplates.set(AMDRequireItemDependency, new AMDRequireItemDependency.Template());
	
			compilation.dependencyFactories.set(AMDRequireArrayDependency, new NullFactory());
			compilation.dependencyTemplates.set(AMDRequireArrayDependency, new AMDRequireArrayDependency.Template());
	
			compilation.dependencyFactories.set(AMDRequireContextDependency, contextModuleFactory);
			compilation.dependencyTemplates.set(AMDRequireContextDependency, new AMDRequireContextDependency.Template());
	
			compilation.dependencyFactories.set(AMDDefineDependency, new NullFactory());
			compilation.dependencyTemplates.set(AMDDefineDependency, new AMDDefineDependency.Template());
	
			compilation.dependencyFactories.set(LocalModuleDependency, new NullFactory());
			compilation.dependencyTemplates.set(LocalModuleDependency, new LocalModuleDependency.Template());
		});
		compiler.parser.apply(
			new AMDRequireDependenciesBlockParserPlugin(this.options),
			new AMDDefineDependencyParserPlugin(this.options)
		);
		setExpressionToModule("require.amd", "!!webpack amd options");
		setExpressionToModule("define.amd", "!!webpack amd options");
		setExpressionToModule("define", "!!webpack amd define");
		compiler.parser.plugin("expression __webpack_amd_options__", function() {
			return this.state.current.addVariable("__webpack_amd_options__", JSON.stringify(amdOptions));
		});
		compiler.parser.plugin("evaluate typeof define.amd", function(expr) {
			return new BasicEvaluatedExpression().setString(typeof amdOptions).setRange(expr.range);
		});
		compiler.parser.plugin("evaluate typeof require.amd", function(expr) {
			return new BasicEvaluatedExpression().setString(typeof amdOptions).setRange(expr.range);
		});
		compiler.parser.plugin("evaluate Identifier define.amd", function(expr) {
			return new BasicEvaluatedExpression().setBoolean(true).setRange(expr.range);
		});
		compiler.parser.plugin("evaluate Identifier require.amd", function(expr) {
			return new BasicEvaluatedExpression().setBoolean(true).setRange(expr.range);
		});
		setTypeof("define", "function");
		compiler.parser.plugin("can-rename define", function() {
			return true;
		});
		compiler.parser.plugin("rename define", function(expr) {
			var dep = new AMDRequireItemDependency("!!webpack amd define", expr.range);
			dep.userRequest = "define";
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			return false;
		});
		setTypeof("require", "function");
		compiler.resolvers.normal.apply(
			new ModuleAliasPlugin({
				"amdefine": path.join(__dirname, "..", "..", "buildin", "amd-define.js"),
				"webpack amd options": path.join(__dirname, "..", "..", "buildin", "amd-options.js"),
				"webpack amd define": path.join(__dirname, "..", "..", "buildin", "amd-define.js")
			})
		);
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var NullDependency = __webpack_require__(107);
	var DepBlockHelpers = __webpack_require__(143);
	
	function AMDRequireDependency(block) {
		NullDependency.call(this);
		this.block = block;
	}
	module.exports = AMDRequireDependency;
	
	AMDRequireDependency.prototype = Object.create(NullDependency.prototype);
	AMDRequireDependency.prototype.constructor = AMDRequireDependency;
	
	AMDRequireDependency.Template = function AMDRequireDependencyTemplate() {};
	
	AMDRequireDependency.Template.prototype.apply = function(dep, source, outputOptions, requestShortener) {
		var depBlock = dep.block;
		var wrapper = DepBlockHelpers.getLoadDepBlockWrapper(depBlock, outputOptions, requestShortener, "require");
		if(depBlock.arrayRange && !depBlock.functionRange) {
			if(wrapper) {
				source.replace(depBlock.outerRange[0], depBlock.arrayRange[0] - 1,
					wrapper[0] + "function() {");
				source.replace(depBlock.arrayRange[1], depBlock.outerRange[1] - 1, ";}" + wrapper[1]);
			} else {
				source.replace(depBlock.outerRange[0], depBlock.arrayRange[0] - 1,
					"!/* require */(" + asComment(depBlock.chunkReason));
				source.replace(depBlock.arrayRange[1], depBlock.outerRange[1] - 1, ")");
			}
		} else if(!depBlock.arrayRange && depBlock.functionRange) {
			if(wrapper) {
				source.replace(depBlock.outerRange[0], depBlock.functionRange[0] - 1,
					wrapper[0] + "function(__webpack_require__) {(");
				source.replace(depBlock.functionRange[1], depBlock.outerRange[1] - 1, ".call(exports, __webpack_require__, exports, module));}" + wrapper[1]);
			} else {
				source.replace(depBlock.outerRange[0], depBlock.functionRange[0] - 1,
					"!/* require */(" + asComment(depBlock.chunkReason));
				source.replace(depBlock.functionRange[1], depBlock.outerRange[1] - 1, ".call(exports, __webpack_require__, exports, module))");
			}
		} else if(depBlock.arrayRange && depBlock.functionRange) {
			if(wrapper) {
				source.replace(depBlock.outerRange[0], depBlock.arrayRange[0] - 1,
					wrapper[0] + "function(__webpack_require__) { ");
				source.insert(depBlock.arrayRange[0] + 0.9, "var __WEBPACK_AMD_REQUIRE_ARRAY__ = ");
				source.replace(depBlock.arrayRange[1], depBlock.functionRange[0] - 1, "; (");
				source.insert(depBlock.functionRange[1], ".apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));");
				source.replace(depBlock.functionRange[1], depBlock.outerRange[1] - 1, "}" + (depBlock.bindThis ? ".bind(this)" : "") + wrapper[1]);
			} else {
				source.replace(depBlock.outerRange[0], depBlock.arrayRange[0] - 1,
					"!/* require */(" + asComment(depBlock.chunkReason) + "function() { ");
				source.insert(depBlock.arrayRange[0] + 0.9, "var __WEBPACK_AMD_REQUIRE_ARRAY__ = ");
				source.replace(depBlock.arrayRange[1], depBlock.functionRange[0] - 1, "; (");
				source.insert(depBlock.functionRange[1], ".apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));");
				source.replace(depBlock.functionRange[1], depBlock.outerRange[1] - 1, "}" + (depBlock.bindThis ? ".call(this)" : "()") + ")");
			}
		}
	};
	
	function asComment(str) {
		if(!str) return "";
		return "/* " + str + " */";
	}


/***/ },
/* 143 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var DepBlockHelpers = exports;
	
	DepBlockHelpers.getLoadDepBlockWrapper = function(depBlock, outputOptions, requestShortener, name) {
		if(depBlock.chunks) {
			var chunks = depBlock.chunks.filter(function(chunk) {
				return !chunk.entry && typeof chunk.id === "number";
			});
			if(chunks.length === 1) {
				var chunk = chunks[0];
				return [
					"__webpack_require__.e" + asComment(name) + "(" + chunk.id + "" +
					(outputOptions.pathinfo && depBlock.chunkName ? "/*! " + requestShortener.shorten(depBlock.chunkName) + " */" : "") +
					asComment(depBlock.chunkReason) + ", ",
					")"
				];
			} else if(chunks.length > 0) {
				return [
					"(function(" + asComment(name) + ") {" +
					"var __WEBPACK_REMAINING_CHUNKS__ = " + chunks.length + ";" +
					"var __WEBPACK_CALLBACK__ = function() {" +
					"if(--__WEBPACK_REMAINING_CHUNKS__ < 1) (",
	
					"(__webpack_require__));" +
					"}.bind(this);" +
					chunks.map(function(chunk) {
						return "__webpack_require__.e(" + chunk.id + ", __WEBPACK_CALLBACK__);";
					}).join("") +
					"}).call(this)"
				];
			}
		}
	};
	
	function asComment(str) {
		if(!str) return "";
		return "/* " + str + " */";
	}


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleDependency = __webpack_require__(83);
	
	function AMDRequireItemDependency(request, range) {
		ModuleDependency.call(this, request);
		this.range = range;
	}
	module.exports = AMDRequireItemDependency;
	
	AMDRequireItemDependency.prototype = Object.create(ModuleDependency.prototype);
	AMDRequireItemDependency.prototype.constructor = AMDRequireItemDependency;
	AMDRequireItemDependency.prototype.type = "amd require";
	
	AMDRequireItemDependency.Template = __webpack_require__(145);


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function ModuleDependencyTemplateAsRequireId() {}
	module.exports = ModuleDependencyTemplateAsRequireId;
	
	ModuleDependencyTemplateAsRequireId.prototype.apply = function(dep, source, outputOptions, requestShortener) {
		if(!dep.range) return;
		var comment = "";
		if(outputOptions.pathinfo) comment = "/*! " + requestShortener.shorten(dep.request) + " */ ";
		if(dep.module)
			var content = "__webpack_require__(" + comment + JSON.stringify(dep.module.id) + ")";
		else
			var content = __webpack_require__(126).module(dep.request);
		source.replace(dep.range[0], dep.range[1] - 1, content);
	};
	
	ModuleDependencyTemplateAsRequireId.prototype.applyAsTemplateArgument = function(name, dep, source) {
		if(!dep.range) return;
		source.replace(dep.range[0], dep.range[1] - 1, "(__webpack_require__(" + name + "))");
	};


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Dependency = __webpack_require__(56);
	
	function AMDRequireArrayDependency(depsArray, range) {
		Dependency.call(this);
		this.depsArray = depsArray;
		this.range = range;
	}
	module.exports = AMDRequireArrayDependency;
	
	AMDRequireArrayDependency.prototype = Object.create(Dependency.prototype);
	AMDRequireArrayDependency.prototype.constructor = AMDRequireArrayDependency;
	AMDRequireArrayDependency.prototype.type = "amd require array";
	
	AMDRequireArrayDependency.Template = function AMDRequireArrayDependencyTemplate() {};
	
	AMDRequireArrayDependency.Template.prototype.apply = function(dep, source, outputOptions, requestShortener) {
		var content = "[" + dep.depsArray.map(function(dep) {
			if(typeof dep === "string") {
				return dep;
			} else {
				var comment = "";
				if(outputOptions.pathinfo) comment = "/*! " + requestShortener.shorten(dep.request) + " */ ";
				if(dep.module)
					return "__webpack_require__(" + comment + JSON.stringify(dep.module.id) + ")";
				else
					return __webpack_require__(126).module(dep.request);
			}
		}).join(", ") + "]";
		source.replace(dep.range[0], dep.range[1] - 1, content);
	};


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ContextDependency = __webpack_require__(128);
	
	function AMDRequireContextDependency(request, recursive, regExp, range, valueRange) {
		ContextDependency.call(this, request, recursive, regExp);
		this.range = range;
		this.valueRange = valueRange;
	}
	module.exports = AMDRequireContextDependency;
	
	AMDRequireContextDependency.prototype = Object.create(ContextDependency.prototype);
	AMDRequireContextDependency.prototype.constructor = AMDRequireContextDependency;
	AMDRequireContextDependency.prototype.type = "amd require context";
	
	AMDRequireContextDependency.Template = __webpack_require__(129);


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var NullDependency = __webpack_require__(107);
	
	function AMDDefineDependency(range, arrayRange, functionRange, objectRange) {
		NullDependency.call(this);
		this.range = range;
		this.arrayRange = arrayRange;
		this.functionRange = functionRange;
		this.objectRange = objectRange;
	}
	module.exports = AMDDefineDependency;
	
	AMDDefineDependency.prototype = Object.create(NullDependency.prototype);
	AMDDefineDependency.prototype.constructor = AMDDefineDependency;
	AMDDefineDependency.prototype.type = "amd define";
	
	AMDDefineDependency.Template = function AMDDefineDependencyTemplate() {};
	
	AMDDefineDependency.Template.prototype.apply = function(dep, source) {
		var localModuleVar = dep.localModule && dep.localModule.used && dep.localModule.variableName();
	
		function replace(def, text) {
			if(localModuleVar) text = text.replace(/XXX/g, localModuleVar.replace(/\$/g, "$$$$"));
			if(localModuleVar) def = def.replace(/XXX/g, localModuleVar.replace(/\$/g, "$$$$"));
			var texts = text.split("#");
			if(def)
				source.insert(0, def);
			var current = dep.range[0];
			if(dep.arrayRange) {
				source.replace(current, dep.arrayRange[0] - 1, texts.shift());
				current = dep.arrayRange[1];
			}
			if(dep.objectRange) {
				source.replace(current, dep.objectRange[0] - 1, texts.shift());
				current = dep.objectRange[1];
			} else if(dep.functionRange) {
				source.replace(current, dep.functionRange[0] - 1, texts.shift());
				current = dep.functionRange[1];
			}
			source.replace(current, dep.range[1] - 1, texts.shift());
			if(texts.length > 0)
				throw new Error("Implementation error");
		}
		var branch = (localModuleVar ? "l" : "") + (dep.arrayRange ? "a" : "") + (dep.objectRange ? "o" : "") + (dep.functionRange ? "f" : "");
		var defs = {
			f: ["var __WEBPACK_AMD_DEFINE_RESULT__;", "!(__WEBPACK_AMD_DEFINE_RESULT__ = #.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))"],
			o: ["", "!(module.exports = #)"],
			of: ["var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;", "!(__WEBPACK_AMD_DEFINE_FACTORY__ = (#), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))"],
			af: ["var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;", "!(__WEBPACK_AMD_DEFINE_ARRAY__ = #, __WEBPACK_AMD_DEFINE_RESULT__ = #.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))"],
			ao: ["", "!(#, module.exports = #)"],
			aof: ["var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;", "!(__WEBPACK_AMD_DEFINE_ARRAY__ = #, __WEBPACK_AMD_DEFINE_FACTORY__ = (#), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))"],
			lf: ["var XXX;", "!(XXX = #.call(exports, __webpack_require__, exports, module))"],
			lo: ["var XXX;", "!(XXX = #)"],
			lof: ["var __WEBPACK_AMD_DEFINE_FACTORY__, XXX;", "!(__WEBPACK_AMD_DEFINE_FACTORY__ = (#), XXX = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__))"],
			laf: ["var __WEBPACK_AMD_DEFINE_ARRAY__, XXX;", "!(__WEBPACK_AMD_DEFINE_ARRAY__ = #, XXX = (#.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)))"],
			lao: ["var XXX;", "!(#, XXX = #)"],
			laof: ["var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_FACTORY__, XXX;", "!(__WEBPACK_AMD_DEFINE_ARRAY__ = #, __WEBPACK_AMD_DEFINE_FACTORY__ = (#), XXX = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__))"]
		};
		replace.apply(null, defs[branch]);
	};


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var AMDRequireItemDependency = __webpack_require__(144);
	var AMDRequireArrayDependency = __webpack_require__(146);
	var AMDRequireContextDependency = __webpack_require__(147);
	var AMDRequireDependenciesBlock = __webpack_require__(150);
	var LocalModuleDependency = __webpack_require__(138);
	var ContextDependencyHelpers = __webpack_require__(136);
	var LocalModulesHelpers = __webpack_require__(139);
	var ConstDependency = __webpack_require__(106);
	var getFunctionExpression = __webpack_require__(151);
	
	function AMDRequireDependenciesBlockParserPlugin(options) {
		this.options = options;
	}
	
	module.exports = AMDRequireDependenciesBlockParserPlugin;
	
	AMDRequireDependenciesBlockParserPlugin.prototype.apply = function(parser) {
		var options = this.options;
		parser.plugin("call require", function(expr) {
			switch(expr.arguments.length) {
				case 1:
					var param = this.evaluateExpression(expr.arguments[0]);
					var result;
					var dep = new AMDRequireDependenciesBlock(expr, param.range, null, this.state.module, expr.loc);
					var old = this.state.current;
					this.state.current = dep;
					this.inScope([], function() {
						result = this.applyPluginsBailResult("call require:amd:array", expr, param);
					}.bind(this));
					this.state.current = old;
					if(!result) return;
					this.state.current.addBlock(dep);
					return true;
				case 2:
					var param = this.evaluateExpression(expr.arguments[0]);
					var dep = new AMDRequireDependenciesBlock(expr, param.range, expr.arguments[1].range, this.state.module, expr.loc);
					dep.loc = expr.loc;
					var old = this.state.current;
					this.state.current = dep;
					try {
						var result;
						this.inScope([], function() {
							result = this.applyPluginsBailResult("call require:amd:array", expr, param);
						}.bind(this));
						if(!result) return;
						var fnData = getFunctionExpression(expr.arguments[1]);
						if(fnData) {
							this.inScope(fnData.fn.params.filter(function(i) {
								return ["require", "module", "exports"].indexOf(i.name) < 0;
							}), function() {
								if(fnData.fn.body.type === "BlockStatement")
									this.walkStatement(fnData.fn.body);
								else
									this.walkExpression(fnData.fn.body);
							}.bind(this));
							this.walkExpressions(fnData.expressions);
							if(fnData.needThis === false) {
								// smaller bundles for simple function expression
								dep.bindThis = false;
							}
						} else {
							this.walkExpression(expr.arguments[1]);
						}
					} finally {
						this.state.current = old;
						this.state.current.addBlock(dep);
					}
					return true;
			}
		});
		parser.plugin("call require:amd:array", function(expr, param) {
			if(param.isArray()) {
				param.items.forEach(function(param) {
					var result = this.applyPluginsBailResult("call require:amd:item", expr, param);
					if(result === undefined) {
						this.applyPluginsBailResult("call require:amd:context", expr, param);
					}
				}, this);
				return true;
			} else if(param.isConstArray()) {
				var deps = [];
				param.array.forEach(function(request) {
					var dep, localModule;
					if(request === "require") {
						dep = "__webpack_require__";
					} else if(["exports", "module"].indexOf(request) >= 0) {
						dep = request;
					} else if(localModule = LocalModulesHelpers.getLocalModule(this.state, request)) { // eslint-disable-line no-cond-assign
						dep = new LocalModuleDependency(localModule);
						dep.loc = expr.loc;
						this.state.current.addDependency(dep);
					} else {
						dep = new AMDRequireItemDependency(request);
						dep.loc = expr.loc;
						dep.optional = !!this.scope.inTry;
						this.state.current.addDependency(dep);
					}
					deps.push(dep);
				}, this);
				var dep = new AMDRequireArrayDependency(deps, param.range);
				dep.loc = expr.loc;
				dep.optional = !!this.scope.inTry;
				this.state.current.addDependency(dep);
				return true;
			}
		});
		parser.plugin("call require:amd:item", function(expr, param) {
			if(param.isConditional()) {
				param.options.forEach(function(param) {
					var result = this.applyPluginsBailResult("call require:amd:item", expr, param);
					if(result === undefined) {
						this.applyPluginsBailResult("call require:amd:context", expr, param);
					}
				}, this);
				return true;
			} else if(param.isString()) {
				var dep, localModule;
				if(param.string === "require") {
					dep = new ConstDependency("__webpack_require__", param.string);
				} else if(["exports", "module"].indexOf(param.string) >= 0) {
					dep = new ConstDependency(param.string, param.range);
				} else if(localModule = LocalModulesHelpers.getLocalModule(this.state, param.string)) { // eslint-disable-line no-cond-assign
					dep = new LocalModuleDependency(localModule, param.range);
				} else {
					dep = new AMDRequireItemDependency(param.string, param.range);
				}
				dep.loc = expr.loc;
				dep.optional = !!this.scope.inTry;
				this.state.current.addDependency(dep);
				return true;
			}
		});
		parser.plugin("call require:amd:context", function(expr, param) {
			var dep = ContextDependencyHelpers.create(AMDRequireContextDependency, param.range, param, expr, options);
			if(!dep) return;
			dep.loc = expr.loc;
			dep.optional = !!this.scope.inTry;
			this.state.current.addDependency(dep);
			return true;
		});
	};


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var AsyncDependenciesBlock = __webpack_require__(77);
	var AMDRequireDependency = __webpack_require__(142);
	
	function AMDRequireDependenciesBlock(expr, arrayRange, functionRange, module, loc) {
		AsyncDependenciesBlock.call(this, null, module, loc);
		this.expr = expr;
		this.outerRange = expr.range;
		this.arrayRange = arrayRange;
		this.functionRange = functionRange;
		this.bindThis = true;
		this.range = arrayRange && functionRange ? [arrayRange[0], functionRange[1]] :
			arrayRange ? arrayRange :
			functionRange ? functionRange :
			expr.range;
		var dep = new AMDRequireDependency(this);
		dep.loc = loc;
		this.addDependency(dep);
	}
	module.exports = AMDRequireDependenciesBlock;
	
	AMDRequireDependenciesBlock.prototype = Object.create(AsyncDependenciesBlock.prototype);


/***/ },
/* 151 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function(expr) {
		// <FunctionExpression>
		if(expr.type === "FunctionExpression") {
			return {
				fn: expr,
				expressions: [],
				needThis: false
			};
		}
		// <FunctionExpression>.bind(<Expression>)
		if(expr.type === "CallExpression" &&
			expr.callee.type === "MemberExpression" &&
			expr.callee.object.type === "FunctionExpression" &&
			expr.callee.property.type === "Identifier" &&
			expr.callee.property.name === "bind" &&
			expr.arguments.length === 1) {
			return {
				fn: expr.callee.object,
				expressions: [expr.arguments[0]]
			};
		}
		// (function(_this) {return <FunctionExpression>})(this) (Coffeescript)
		if(expr.type === "CallExpression" &&
			expr.callee.type === "FunctionExpression" &&
			expr.callee.body.type === "BlockStatement" &&
			expr.arguments.length === 1 &&
			expr.arguments[0].type === "ThisExpression" &&
			expr.callee.body.body &&
			expr.callee.body.body.length === 1 &&
			expr.callee.body.body[0].type === "ReturnStatement" &&
			expr.callee.body.body[0].argument &&
			expr.callee.body.body[0].argument.type === "FunctionExpression") {
			return {
				fn: expr.callee.body.body[0].argument,
				expressions: [],
				needThis: true
			};
		}
	};


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var AMDRequireItemDependency = __webpack_require__(144);
	var AMDRequireContextDependency = __webpack_require__(147);
	var ConstDependency = __webpack_require__(106);
	var AMDDefineDependency = __webpack_require__(148);
	var AMDRequireArrayDependency = __webpack_require__(146);
	var LocalModuleDependency = __webpack_require__(138);
	var ContextDependencyHelpers = __webpack_require__(136);
	var LocalModulesHelpers = __webpack_require__(139);
	
	function isBoundFunctionExpression(expr) {
		if(expr.type !== "CallExpression") return false;
		if(expr.callee.type !== "MemberExpression") return false;
		if(expr.callee.computed) return false;
		if(expr.callee.object.type !== "FunctionExpression") return false;
		if(expr.callee.property.type !== "Identifier") return false;
		if(expr.callee.property.name !== "bind") return false;
		return true;
	}
	
	function AMDDefineDependencyParserPlugin(options) {
		this.options = options;
	}
	
	module.exports = AMDDefineDependencyParserPlugin;
	AMDDefineDependencyParserPlugin.prototype.apply = function(parser) {
		var options = this.options;
		parser.plugin("call define", function(expr) {
			var array, fn, obj, namedModule;
			switch(expr.arguments.length) {
				case 1:
					if(expr.arguments[0].type === "FunctionExpression" || isBoundFunctionExpression(expr.arguments[0])) {
						// define(f() {...})
						fn = expr.arguments[0];
					} else if(expr.arguments[0].type === "ObjectExpression") {
						// define({...})
						obj = expr.arguments[0];
					} else {
						// define(expr)
						// unclear if function or object
						obj = fn = expr.arguments[0];
					}
					break;
				case 2:
					if(expr.arguments[0].type === "Literal") {
						namedModule = expr.arguments[0].value;
						// define("...", ...)
						if(expr.arguments[1].type === "FunctionExpression" || isBoundFunctionExpression(expr.arguments[1])) {
							// define("...", f() {...})
							fn = expr.arguments[1];
						} else if(expr.arguments[1].type === "ObjectExpression") {
							// define("...", {...})
							obj = expr.arguments[1];
						} else {
							// define("...", expr)
							// unclear if function or object
							obj = fn = expr.arguments[1];
						}
					} else {
						array = expr.arguments[0];
						if(expr.arguments[1].type === "FunctionExpression" || isBoundFunctionExpression(expr.arguments[1])) {
							// define([...], f() {})
							fn = expr.arguments[1];
						} else if(expr.arguments[1].type === "ObjectExpression") {
							// define([...], {...})
							obj = expr.arguments[1];
						} else {
							// define([...], expr)
							// unclear if function or object
							obj = fn = expr.arguments[1];
						}
					}
					break;
				case 3:
					// define("...", [...], f() {...})
					namedModule = expr.arguments[0].value;
					array = expr.arguments[1];
					if(expr.arguments[2].type === "FunctionExpression" || isBoundFunctionExpression(expr.arguments[2])) {
						// define("...", [...], f() {})
						fn = expr.arguments[2];
					} else if(expr.arguments[2].type === "ObjectExpression") {
						// define("...", [...], {...})
						obj = expr.arguments[2];
					} else {
						// define("...", [...], expr)
						// unclear if function or object
						obj = fn = expr.arguments[2];
					}
					break;
				default:
					return;
			}
			var fnParams = null;
			var fnParamsOffset = 0;
			if(fn) {
				if(fn.type === "FunctionExpression") fnParams = fn.params;
				else if(isBoundFunctionExpression(fn)) {
					fnParams = fn.callee.object.params;
					fnParamsOffset = fn.arguments.length - 1;
					if(fnParamsOffset < 0) fnParamsOffset = 0;
				}
			}
			var fnRenames = Object.create(this.scope.renames);
			var identifiers;
			if(array) {
				identifiers = {};
				var param = this.evaluateExpression(array);
				var result = this.applyPluginsBailResult("call define:amd:array", expr, param, identifiers, namedModule);
				if(!result) return;
				if(fnParams) fnParams = fnParams.slice(fnParamsOffset).filter(function(param, idx) {
					if(identifiers[idx]) {
						fnRenames["$" + param.name] = identifiers[idx];
						return false;
					}
					return true;
				});
			} else {
				identifiers = ["require", "exports", "module"];
				if(fnParams) fnParams = fnParams.slice(fnParamsOffset).filter(function(param, idx) {
					if(identifiers[idx]) {
						fnRenames["$" + param.name] = identifiers[idx];
						return false;
					}
					return true;
				});
			}
			var inTry;
			if(fn && fn.type === "FunctionExpression") {
				inTry = this.scope.inTry;
				this.inScope(fnParams, function() {
					this.scope.renames = fnRenames;
					this.scope.inTry = inTry;
					if(fn.body.type === "BlockStatement")
						this.walkStatement(fn.body);
					else
						this.walkExpression(fn.body);
				}.bind(this));
			} else if(fn && isBoundFunctionExpression(fn)) {
				inTry = this.scope.inTry;
				this.inScope(fn.callee.object.params.filter(function(i) {
					return ["require", "module", "exports"].indexOf(i.name) < 0;
				}), function() {
					this.scope.renames = fnRenames;
					this.scope.inTry = inTry;
					if(fn.callee.object.body.type === "BlockStatement")
						this.walkStatement(fn.callee.object.body);
					else
						this.walkExpression(fn.callee.object.body);
				}.bind(this));
				if(fn.arguments)
					this.walkExpressions(fn.arguments);
			} else if(fn || obj) {
				this.walkExpression(fn || obj);
			}
			var dep = new AMDDefineDependency(expr.range, array ? array.range : null, fn ? fn.range : null, obj ? obj.range : null);
			dep.loc = expr.loc;
			if(namedModule) {
				dep.localModule = LocalModulesHelpers.addLocalModule(this.state, namedModule);
			}
			this.state.current.addDependency(dep);
			return true;
		});
		parser.plugin("call define:amd:array", function(expr, param, identifiers, namedModule) {
			if(param.isArray()) {
				param.items.forEach(function(param, idx) {
					if(param.isString() && ["require", "module", "exports"].indexOf(param.string) >= 0)
						identifiers[idx] = param.string;
					var result = this.applyPluginsBailResult("call define:amd:item", expr, param, namedModule);
					if(result === undefined) {
						this.applyPluginsBailResult("call define:amd:context", expr, param);
					}
				}, this);
				return true;
			} else if(param.isConstArray()) {
				var deps = [];
				param.array.forEach(function(request, idx) {
					var dep, localModule;
					if(request === "require") {
						identifiers[idx] = request;
						dep = "__webpack_require__";
					} else if(["exports", "module"].indexOf(request) >= 0) {
						identifiers[idx] = request;
						dep = request;
					} else if(localModule = LocalModulesHelpers.getLocalModule(this.state, request)) { // eslint-disable-line no-cond-assign
						dep = new LocalModuleDependency(localModule);
						dep.loc = expr.loc;
						this.state.current.addDependency(dep);
					} else {
						dep = new AMDRequireItemDependency(request);
						dep.loc = expr.loc;
						dep.optional = !!this.scope.inTry;
						this.state.current.addDependency(dep);
					}
					deps.push(dep);
				}, this);
				var dep = new AMDRequireArrayDependency(deps, param.range);
				dep.loc = expr.loc;
				dep.optional = !!this.scope.inTry;
				this.state.current.addDependency(dep);
				return true;
			}
		});
		parser.plugin("call define:amd:item", function(expr, param, namedModule) {
			if(param.isConditional()) {
				param.options.forEach(function(param) {
					var result = this.applyPluginsBailResult("call define:amd:item", expr, param);
					if(result === undefined) {
						this.applyPluginsBailResult("call define:amd:context", expr, param);
					}
				}, this);
				return true;
			} else if(param.isString()) {
				var dep, localModule;
				if(param.string === "require") {
					dep = new ConstDependency("__webpack_require__", param.range);
				} else if(["require", "exports", "module"].indexOf(param.string) >= 0) {
					dep = new ConstDependency(param.string, param.range);
				} else if(localModule = LocalModulesHelpers.getLocalModule(this.state, param.string, namedModule)) { // eslint-disable-line no-cond-assign
					dep = new LocalModuleDependency(localModule, param.range);
				} else {
					dep = new AMDRequireItemDependency(param.string, param.range);
				}
				dep.loc = expr.loc;
				dep.optional = !!this.scope.inTry;
				this.state.current.addDependency(dep);
				return true;
			}
		});
		parser.plugin("call define:amd:context", function(expr, param) {
			var dep = ContextDependencyHelpers.create(AMDRequireContextDependency, param.range, param, expr, options);
			if(!dep) return;
			dep.loc = expr.loc;
			dep.optional = !!this.scope.inTry;
			this.state.current.addDependency(dep);
			return true;
		});
	};


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var RequireContextDependency = __webpack_require__(154);
	var ContextElementDependency = __webpack_require__(82);
	
	var RequireContextDependencyParserPlugin = __webpack_require__(155);
	
	function RequireContextPlugin(modulesDirectories, extensions) {
		this.modulesDirectories = modulesDirectories;
		this.extensions = extensions;
	}
	module.exports = RequireContextPlugin;
	
	RequireContextPlugin.prototype.apply = function(compiler) {
		var modulesDirectories = this.modulesDirectories;
		var extensions = this.extensions;
		compiler.plugin("compilation", function(compilation, params) {
			var contextModuleFactory = params.contextModuleFactory;
			var normalModuleFactory = params.normalModuleFactory;
	
			compilation.dependencyFactories.set(RequireContextDependency, contextModuleFactory);
			compilation.dependencyTemplates.set(RequireContextDependency, new RequireContextDependency.Template());
	
			compilation.dependencyFactories.set(ContextElementDependency, normalModuleFactory);
		});
		compiler.plugin("context-module-factory", function(cmf) {
			cmf.plugin("alternatives", function(items, callback) {
				if(items.length === 0) return callback(null, items);
	
				callback(null, items.map(function(obj) {
					return extensions.filter(function(ext) {
						var l = obj.request.length;
						return l > ext.length && obj.request.substr(l - ext.length, l) === ext;
					}).map(function(ext) {
						var l = obj.request.length;
						return {
							context: obj.context,
							request: obj.request.substr(0, l - ext.length)
						};
					});
				}).reduce(function(a, b) {
					return a.concat(b);
				}, []));
			});
			cmf.plugin("alternatives", function(items, callback) {
				if(items.length === 0) return callback(null, items);
	
				callback(null, items.map(function(obj) {
					for(var i = 0; i < modulesDirectories.length; i++) {
						var dir = modulesDirectories[i];
						var idx = obj.request.indexOf("./" + dir + "/");
						if(idx === 0) {
							obj.request = obj.request.slice(dir.length + 3);
							break;
						}
					}
					return obj;
				}));
			});
		});
		new RequireContextDependencyParserPlugin().apply(compiler.parser);
	};


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ContextDependency = __webpack_require__(128);
	
	function RequireContextDependency(request, recursive, regExp, range) {
		ContextDependency.call(this, request, recursive, regExp);
		this.range = range;
	}
	module.exports = RequireContextDependency;
	
	RequireContextDependency.prototype = Object.create(ContextDependency.prototype);
	RequireContextDependency.prototype.constructor = RequireContextDependency;
	RequireContextDependency.prototype.type = "require.context";
	
	RequireContextDependency.Template = __webpack_require__(145);


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var AbstractPlugin = __webpack_require__(156);
	var RequireContextDependency = __webpack_require__(154);
	
	module.exports = AbstractPlugin.create({
		"call require.context": function(expr) {
			var regExp = /^\.\/.*$/;
			var recursive = true;
			switch(expr.arguments.length) {
				case 3:
					var regExpExpr = this.evaluateExpression(expr.arguments[2]);
					if(!regExpExpr.isRegExp()) return;
					regExp = regExpExpr.regExp;
					// falls through
				case 2:
					var recursiveExpr = this.evaluateExpression(expr.arguments[1]);
					if(!recursiveExpr.isBoolean()) return;
					recursive = recursiveExpr.bool;
					// falls through
				case 1:
					var requestExpr = this.evaluateExpression(expr.arguments[0]);
					if(!requestExpr.isString()) return;
					var dep = new RequireContextDependency(requestExpr.string, recursive, regExp, expr.range);
					dep.loc = expr.loc;
					dep.optional = this.scope.inTry;
					this.state.current.addDependency(dep);
					return true;
			}
		}
	});


/***/ },
/* 156 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function AbstractPlugin(plugins) {
		this._plugins = plugins || {};
	}
	module.exports = AbstractPlugin;
	
	AbstractPlugin.create = function(plugins) {
		function Plugin() {
			AbstractPlugin.call(this, plugins);
		}
		Plugin.prototype = Object.create(AbstractPlugin.prototype);
		return Plugin;
	};
	
	AbstractPlugin.prototype.apply = function(object) {
		for(var name in this._plugins) {
			object.plugin(name, this._plugins[name]);
		}
	};


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var RequireEnsureItemDependency = __webpack_require__(158);
	var RequireEnsureDependency = __webpack_require__(160);
	var ConstDependency = __webpack_require__(106);
	
	var NullFactory = __webpack_require__(108);
	
	var RequireEnsureDependenciesBlockParserPlugin = __webpack_require__(161);
	
	var BasicEvaluatedExpression = __webpack_require__(62);
	
	function RequireEnsurePlugin() {}
	module.exports = RequireEnsurePlugin;
	
	RequireEnsurePlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation, params) {
			var normalModuleFactory = params.normalModuleFactory;
	
			compilation.dependencyFactories.set(RequireEnsureItemDependency, normalModuleFactory);
			compilation.dependencyTemplates.set(RequireEnsureItemDependency, new RequireEnsureItemDependency.Template());
	
			compilation.dependencyFactories.set(RequireEnsureDependency, new NullFactory());
			compilation.dependencyTemplates.set(RequireEnsureDependency, new RequireEnsureDependency.Template());
		});
		new RequireEnsureDependenciesBlockParserPlugin().apply(compiler.parser);
		compiler.parser.plugin("evaluate typeof require.ensure", function(expr) {
			return new BasicEvaluatedExpression().setString("function").setRange(expr.range);
		});
		compiler.parser.plugin("typeof require.ensure", function(expr) {
			var dep = new ConstDependency("'function'", expr.range);
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			return true;
		});
	};


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleDependency = __webpack_require__(83);
	
	function RequireEnsureItemDependency(request) {
		ModuleDependency.call(this, request);
	}
	module.exports = RequireEnsureItemDependency;
	
	RequireEnsureItemDependency.prototype = Object.create(ModuleDependency.prototype);
	RequireEnsureItemDependency.prototype.constructor = RequireEnsureItemDependency;
	RequireEnsureItemDependency.prototype.type = "require.ensure item";
	
	RequireEnsureItemDependency.Template = __webpack_require__(159);


/***/ },
/* 159 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function NullDependencyTemplate() {}
	module.exports = NullDependencyTemplate;
	
	NullDependencyTemplate.prototype.apply = function() {};


/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var NullDependency = __webpack_require__(107);
	var DepBlockHelpers = __webpack_require__(143);
	
	function RequireEnsureDependency(block) {
		NullDependency.call(this);
		this.block = block;
	}
	module.exports = RequireEnsureDependency;
	
	RequireEnsureDependency.prototype = Object.create(NullDependency.prototype);
	RequireEnsureDependency.prototype.constructor = RequireEnsureDependency;
	RequireEnsureDependency.prototype.type = "require.ensure";
	
	RequireEnsureDependency.Template = function RequireEnsureDependencyTemplate() {};
	
	RequireEnsureDependency.Template.prototype.apply = function(dep, source, outputOptions, requestShortener) {
		var depBlock = dep.block;
		var wrapper = DepBlockHelpers.getLoadDepBlockWrapper(depBlock, outputOptions, requestShortener, /*require.e*/ "nsure");
		if(!wrapper) wrapper = [
			"!/* require.ensure */(",
			"(__webpack_require__))"
		];
		source.replace(depBlock.expr.range[0], depBlock.expr.arguments[1].range[0] - 1, wrapper[0]);
		source.replace(depBlock.expr.arguments[1].range[1], depBlock.expr.range[1] - 1, wrapper[1]);
	};


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var AbstractPlugin = __webpack_require__(156);
	var RequireEnsureDependenciesBlock = __webpack_require__(162);
	var RequireEnsureItemDependency = __webpack_require__(158);
	var getFunctionExpression = __webpack_require__(151);
	
	module.exports = AbstractPlugin.create({
		"call require.ensure": function(expr) {
			var chunkName = null,
				chunkNameRange = null;
			switch(expr.arguments.length) {
				case 3:
					var chunkNameExpr = this.evaluateExpression(expr.arguments[2]);
					if(!chunkNameExpr.isString()) return;
					chunkNameRange = chunkNameExpr.range;
					chunkName = chunkNameExpr.string;
					// falls through
				case 2:
					var dependenciesExpr = this.evaluateExpression(expr.arguments[0]);
					var dependenciesItems = dependenciesExpr.isArray() ? dependenciesExpr.items : [dependenciesExpr];
					var fnExpressionArg = expr.arguments[1];
					var fnExpression = getFunctionExpression(fnExpressionArg);
	
					if(fnExpression) {
						this.walkExpressions(fnExpression.expressions);
					}
	
					var dep = new RequireEnsureDependenciesBlock(expr, fnExpression ? fnExpression.fn : fnExpressionArg, chunkName, chunkNameRange, this.state.module, expr.loc);
					var old = this.state.current;
					this.state.current = dep;
					try {
						var failed = false;
						this.inScope([], function() {
							dependenciesItems.forEach(function(ee) {
								if(ee.isString()) {
									var edep = new RequireEnsureItemDependency(ee.string, ee.range);
									edep.loc = dep.loc;
									dep.addDependency(edep);
								} else {
									failed = true;
								}
							});
						});
						if(failed) {
							return;
						}
						if(fnExpression) {
							if(fnExpression.fn.body.type === "BlockStatement")
								this.walkStatement(fnExpression.fn.body);
							else
								this.walkExpression(fnExpression.fn.body);
						}
						old.addBlock(dep);
					} finally {
						this.state.current = old;
					}
					if(!fnExpression) {
						this.walkExpression(fnExpressionArg);
					}
					return true;
			}
		}
	});


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var AsyncDependenciesBlock = __webpack_require__(77);
	var RequireEnsureDependency = __webpack_require__(160);
	
	function RequireEnsureDependenciesBlock(expr, fnExpression, chunkName, chunkNameRange, module, loc) {
		AsyncDependenciesBlock.call(this, chunkName, module, loc);
		this.expr = expr;
		var bodyRange = fnExpression && fnExpression.body && fnExpression.body.range;
		this.range = bodyRange && [bodyRange[0] + 1, bodyRange[1] - 1] || null;
		this.chunkNameRange = chunkNameRange;
		var dep = new RequireEnsureDependency(this);
		dep.loc = loc;
		this.addDependency(dep);
	}
	module.exports = RequireEnsureDependenciesBlock;
	
	RequireEnsureDependenciesBlock.prototype = Object.create(AsyncDependenciesBlock.prototype);


/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var RequireIncludeDependency = __webpack_require__(164);
	var RequireIncludeDependencyParserPlugin = __webpack_require__(165);
	var ConstDependency = __webpack_require__(106);
	
	var BasicEvaluatedExpression = __webpack_require__(62);
	
	function RequireIncludePlugin() {}
	module.exports = RequireIncludePlugin;
	
	RequireIncludePlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation, params) {
			var normalModuleFactory = params.normalModuleFactory;
	
			compilation.dependencyFactories.set(RequireIncludeDependency, normalModuleFactory);
			compilation.dependencyTemplates.set(RequireIncludeDependency, new RequireIncludeDependency.Template());
		});
		new RequireIncludeDependencyParserPlugin().apply(compiler.parser);
		compiler.parser.plugin("evaluate typeof require.include", function(expr) {
			return new BasicEvaluatedExpression().setString("function").setRange(expr.range);
		});
		compiler.parser.plugin("typeof require.include", function(expr) {
			var dep = new ConstDependency("'function'", expr.range);
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			return true;
		});
	};


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleDependency = __webpack_require__(83);
	
	function RequireIncludeDependency(request, range) {
		ModuleDependency.call(this, request);
		this.range = range;
	}
	module.exports = RequireIncludeDependency;
	
	RequireIncludeDependency.prototype = Object.create(ModuleDependency.prototype);
	RequireIncludeDependency.prototype.constructor = RequireIncludeDependency;
	RequireIncludeDependency.prototype.type = "require.include";
	
	RequireIncludeDependency.Template = function RequireIncludeDependencyTemplate() {};
	
	RequireIncludeDependency.Template.prototype.apply = function(dep, source, outputOptions, requestShortener) {
		var comment = "";
		if(outputOptions.pathinfo && dep.module)
			comment = "/*! require.include " + requestShortener.shorten(dep.request) + " */";
		source.replace(dep.range[0], dep.range[1] - 1,
			"undefined" + comment);
	};


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var AbstractPlugin = __webpack_require__(156);
	var RequireIncludeDependency = __webpack_require__(164);
	
	module.exports = AbstractPlugin.create({
		"call require.include": function(expr) {
			if(expr.arguments.length !== 1) return;
			var param = this.evaluateExpression(expr.arguments[0]);
			if(!param.isString()) return;
			var dep = new RequireIncludeDependency(param.string, expr.range);
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			return true;
		}
	});


/***/ },
/* 166 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function hasModule(chunk, module, checkedChunks) {
		if(chunk.modules.indexOf(module) >= 0) return [chunk];
		if(chunk.entry) return false;
		return allHaveModule(chunk.parents.filter(function(c) {
			return checkedChunks.indexOf(c) < 0;
		}), module, checkedChunks);
	}
	
	function allHaveModule(someChunks, module, checkedChunks) {
		if(!checkedChunks) checkedChunks = [];
		var chunks = [];
		for(var i = 0; i < someChunks.length; i++) {
			checkedChunks.push(someChunks[i]);
			var subChunks = hasModule(someChunks[i], module, checkedChunks);
			if(!subChunks) return false;
			addToSet(chunks, subChunks);
		}
		return chunks;
	}
	
	function addToSet(set, items) {
		items.forEach(function(item) {
			if(set.indexOf(item) < 0)
				set.push(item);
		});
	}
	
	function RemoveParentModulesPlugin() {}
	module.exports = RemoveParentModulesPlugin;
	
	RemoveParentModulesPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.plugin(["optimize-chunks", "optimize-extracted-chunks"], function(chunks) {
				chunks.forEach(function(chunk) {
					chunk.modules.slice().forEach(function(module) {
						if(chunk.entry) return;
						var parentChunksWithModule = allHaveModule(chunk.parents, module);
						if(parentChunksWithModule) {
							module.rewriteChunkInReasons(chunk, parentChunksWithModule);
							chunk.removeModule(module);
						}
					});
				});
			});
		});
	};


/***/ },
/* 167 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function RemoveEmptyChunksPlugin() {}
	module.exports = RemoveEmptyChunksPlugin;
	
	RemoveEmptyChunksPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.plugin(["optimize-chunks", "optimize-extracted-chunks"], function(chunks) {
				chunks.filter(function(chunk) {
					return chunk.isEmpty() && !chunk.initial;
				}).forEach(function(chunk) {
					chunk.remove("empty");
					chunks.splice(chunks.indexOf(chunk), 1);
				});
			});
		});
	};


/***/ },
/* 168 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function MergeDuplicateChunksPlugin() {}
	module.exports = MergeDuplicateChunksPlugin;
	
	function getChunkIdentifier(chunk) {
		return chunk.modules.map(function(m) {
			return m.identifier();
		}).sort().join(", ");
	}
	
	MergeDuplicateChunksPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.plugin("optimize-chunks", function(chunks) {
				var map = {};
				chunks.slice().forEach(function(chunk) {
					if(chunk.initial) return;
					var ident = getChunkIdentifier(chunk);
					if(map[ident]) {
						if(map[ident].integrate(chunk, "duplicate"))
							chunks.splice(chunks.indexOf(chunk), 1);
						return;
					}
					map[ident] = chunk;
				});
			});
		});
	};


/***/ },
/* 169 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function FlagIncludedChunksPlugin() {}
	module.exports = FlagIncludedChunksPlugin;
	
	FlagIncludedChunksPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.plugin("optimize-chunk-ids", function(chunks) {
				chunks.forEach(function(chunkA) {
					chunks.forEach(function(chunkB) {
						if(chunkA === chunkB) return;
						// is chunkB in chunkA?
						if(chunkA.modules.length < chunkB.modules.length) return;
						for(var i = 0; i < chunkB.modules.length; i++) {
							if(chunkA.modules.indexOf(chunkB.modules[i]) < 0) return;
						}
						chunkA.ids.push(chunkB.id);
					});
				});
			});
		});
	};


/***/ },
/* 170 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function UnsafeCachePlugin(regExps, cache) {
		this.regExps = regExps || [/./];
		if(this.regExps === true) this.regExps = [/./];
		else if(!Array.isArray(this.regExps)) this.regExps = [this.regExps];
		this.cache = cache || {};
	}
	module.exports = UnsafeCachePlugin;
	
	UnsafeCachePlugin.prototype.apply = function(resolver) {
		var oldResolve = resolver.resolve;
		var regExps = this.regExps;
		var cache = this.cache;
		resolver.resolve = function resolve(context, request, callback) {
			var id = context + "->" + request;
			if(cache[id]) {
				// From cache
				return callback(null, cache[id]);
			}
			oldResolve.call(resolver, context, request, function(err, result) {
				if(err) return callback(err);
				var doCache = regExps.some(function(regExp) {
					return regExp.test(result.path);
				});
				if(!doCache) return callback(null, result);
				callback(null, cache[id] = result);
			});
		};
	};


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var createInnerCallback = __webpack_require__(64);
	var popPathSeqment = __webpack_require__(172);
	
	function ModulesInDirectoriesPlugin(moduleType, directories) {
		this.moduleType = moduleType;
		this.directories = directories;
	}
	module.exports = ModulesInDirectoriesPlugin;
	
	ModulesInDirectoriesPlugin.prototype.apply = function(resolver) {
		var moduleType = this.moduleType;
		var directories = this.directories;
		resolver.plugin("module", function(request, callback) {
			var fs = this.fileSystem;
			var paths = [request.path];
			var addr = [request.path];
			var pathSeqment = popPathSeqment(addr);
			var topLevelCallback = callback;
			while(pathSeqment) {
				paths.push(addr[0]);
				pathSeqment = popPathSeqment(addr);
			}
			var addrs = paths.map(function(p) {
				return directories.map(function(d) {
					return this.join(p, d);
				}, this);
			}, this).reduce(function(array, p) {
				array.push.apply(array, p);
				return array;
			}, []);
			this.forEachBail(addrs, function(addr, callback) {
				fs.stat(addr, function(err, stat) {
					if(!err && stat && stat.isDirectory()) {
						this.applyPluginsParallelBailResult("module-" + moduleType, {
							path: addr,
							request: request.request,
							query: request.query,
							directory: request.directory
						}, createInnerCallback(function(err, result) {
							if(err) return callback(err);
							if(!result) return callback();
							return callback(null, result);
						}, topLevelCallback, "looking for modules in " + addr));
						return;
					}
					return callback();
				}.bind(this));
			}.bind(this), function(err, result) {
				if(err) return callback(err);
				if(!result) return callback();
				return callback(null, result);
			});
		});
	};


/***/ },
/* 172 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function popPathSeqment(pathInArray) {
		var i = pathInArray[0].lastIndexOf("/"),
			j = pathInArray[0].lastIndexOf("\\");
		var p = i < 0 ? j : j < 0 ? i : i < j ? j : i;
		if(p < 0) return null;
		var s = pathInArray[0].substr(p+1);
		pathInArray[0] = pathInArray[0].substr(0, p || 1);
		return s;
	};


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var createInnerCallback = __webpack_require__(64);
	
	function ModulesInRootPlugin(moduleType, path) {
		this.moduleType = moduleType;
		this.path = path;
	}
	module.exports = ModulesInRootPlugin;
	
	ModulesInRootPlugin.prototype.apply = function(resolver) {
		var moduleType = this.moduleType;
		var path = this.path;
		resolver.plugin("module", function(request, callback) {
			this.applyPluginsParallelBailResult("module-" + moduleType, {
				path: path,
				request: request.request,
				query: request.query,
				directory: request.directory
			}, createInnerCallback(function innerCallback(err, result) {
				if(err) return callback(err);
				if(!result) return callback();
				return callback(null, result);
			}, callback, "looking for modules in " + path));
		});
	};


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var createInnerCallback = __webpack_require__(64);
	
	function ModuleTemplatesPlugin(moduleType, templates, targetModuleType) {
		this.moduleType = moduleType;
		this.targetModuleType = targetModuleType;
		this.templates = templates;
	}
	module.exports = ModuleTemplatesPlugin;
	
	ModuleTemplatesPlugin.prototype.apply = function(resolver) {
		var templates = this.templates;
		var targetModuleType = this.targetModuleType;
		resolver.plugin("module-" + this.moduleType, function(request, callback) {
			var fs = this.fileSystem;
			var topLevelCallback = callback;
			var i = request.request.indexOf("/"),
				j = request.request.indexOf("\\");
			var p = i < 0 ? j : j < 0 ? i : i < j ? i : j;
			var moduleName, remainingRequest;
			if(p < 0) {
				moduleName = request.request;
				remainingRequest = "";
			} else {
				moduleName = request.request.substr(0, p);
				remainingRequest = request.request.substr(p);
			}
			this.forEachBail(templates, function(template, callback) {
				var moduleFinalName = template.replace(/\*/g, moduleName);
				this.applyPluginsParallelBailResult("module-" + targetModuleType, {
					path: request.path,
					request: moduleFinalName + remainingRequest,
					query: request.query,
					directory: request.directory
				}, createInnerCallback(function(err, result) {
					if(err) return callback(err);
					if(!result) return callback();
					return callback(null, result);
				}, topLevelCallback, "module variation " + moduleFinalName));
			}.bind(this), callback);
		});
	};


/***/ },
/* 175 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function ModuleAsFilePlugin(moduleType) {
		this.moduleType = moduleType;
	}
	module.exports = ModuleAsFilePlugin;
	
	ModuleAsFilePlugin.prototype.apply = function(resolver) {
		resolver.plugin("module-" + this.moduleType, function(request, callback) {
			var fs = this.fileSystem;
			var i = request.request.indexOf("/"),
				j = request.request.indexOf("\\");
			if(i >= 0 || j >= 0 || request.directory) return callback();
			return this.doResolve("file", request, callback, true);
		});
	};


/***/ },
/* 176 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function ModuleAsDirectoryPlugin(moduleType) {
		this.moduleType = moduleType;
	}
	module.exports = ModuleAsDirectoryPlugin;
	
	ModuleAsDirectoryPlugin.prototype.apply = function(resolver) {
		resolver.plugin("module-" + this.moduleType, function(request, callback) {
			var fs = this.fileSystem;
			var i = request.request.indexOf("/"),
				j = request.request.indexOf("\\");
			var p = i < 0 ? j : j < 0 ? i : i < j ? i : j;
			var moduleName, remainingRequest;
			if(p < 0) {
				moduleName = request.request;
				remainingRequest = "";
			} else {
				moduleName = request.request.substr(0, p);
				remainingRequest = request.request.substr(p+1);
			}
			var modulePath = this.join(request.path, moduleName);
			fs.stat(modulePath, function(err, stat) {
				if(err || !stat) {
					if(callback.missing)
						callback.missing.push(modulePath);
					if(callback.log) callback.log(modulePath + " doesn't exist (module as directory)");
					return callback();
				}
				if(stat.isDirectory()) {
					return this.doResolve(request.directory ? "directory" : ["file", "directory"], {
						path: modulePath,
						request: remainingRequest,
						query: request.query
					}, callback, true);
				}
				if(callback.log) callback.log(modulePath + " is not a directory (module as directory)");
				return callback();
			}.bind(this));
		});
	};


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var createInnerCallback = __webpack_require__(64);
	
	function DirectoryDefaultFilePlugin(files) {
		this.files = files;
	}
	module.exports = DirectoryDefaultFilePlugin;
	
	DirectoryDefaultFilePlugin.prototype.apply = function(resolver) {
		var files = this.files;
		resolver.plugin("directory", function(request, callback) {
			var fs = this.fileSystem;
			var topLevelCallback = callback;
			var directory = this.join(request.path, request.request);
			fs.stat(directory, function(err, stat) {
				if(err || !stat) {
					if(callback.log) callback.log(directory + " doesn't exist (directory default file)");
					return callback();
				}
				if(!stat.isDirectory()) {
					if(callback.log) callback.log(directory + " is not a directory (directory default file)");
					return callback();
				}
				this.forEachBail(files, function(file, callback) {
					this.doResolve("file", {
						path: directory,
						query: request.query,
						request: file
					}, createInnerCallback(function(err, result) {
						if(!err && result) return callback(result);
						return callback();
					}, topLevelCallback, "directory default file " + file));
				}.bind(this), function(result) {
					if(!result) return callback();
					return callback(null, result);
				});
			}.bind(this));
		});
	};

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var createInnerCallback = __webpack_require__(64);
	
	function DirectoryDescriptionFilePlugin(filename, fields) {
		this.filename = filename;
		this.fields = fields;
	}
	module.exports = DirectoryDescriptionFilePlugin;
	
	DirectoryDescriptionFilePlugin.prototype.apply = function(resolver) {
		var filename = this.filename;
		var fields = this.fields;
		resolver.plugin("directory", function(request, callback) {
			var fs = this.fileSystem;
			var directory = this.join(request.path, request.request);
			var descriptionFilePath = this.join(directory, filename);
			fs.readFile(descriptionFilePath, function(err, content) {
				if(err) {
					if(callback.log)
						callback.log(descriptionFilePath + " doesn't exist (directory description file)");
					return callback();
				}
				content = content.toString("utf-8");
				try {
					content = JSON.parse(content);
				} catch(e) {
					if(callback.log)
						callback.log(descriptionFilePath + " (directory description file): " + e);
					else
						e.message = descriptionFilePath + " (directory description file): " + e;
					return callback(e);
				}
				var mainModules = [];
				for(var i = 0; i < fields.length; i++) {
					if(Array.isArray(fields[i])) {
						var current = content;
						for(var j = 0; j < fields[i].length; j++) {
							if(current === null || typeof current !== "object") {
								current = null;
								break;
							}
							var field = fields[i][j];
							current = current[field];
						}
						if(typeof current === "string") {
							mainModules.push(current);
							continue;
						}
					} else {
						var field = fields[i];
						if(typeof content[field] === "string") {
							mainModules.push(content[field]);
							continue;
						}
					}
				}
				(function next() {
					if(mainModules.length == 0) return callback();
					var mainModule = mainModules.shift();
					return this.doResolve(["file", "directory"], {
						path: directory,
						query: request.query,
						request: mainModule
					}, createInnerCallback(function(err, result) {
						if(!err && result) return callback(null, result);
						return next.call(this);
					}.bind(this), callback, "use " + mainModule + " from " + filename));
				}.call(this))
			}.bind(this));
		});
	};

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var createInnerCallback = __webpack_require__(64);
	
	function DirectoryDescriptionFileFieldAliasPlugin(filename, field) {
		this.filename = filename;
		this.field = field;
	}
	module.exports = DirectoryDescriptionFileFieldAliasPlugin;
	
	function findDescriptionFileField(resolver, directory, filename, field, callback) {
		(function findDescriptionFile() {
			var descriptionFilePath = resolver.join(directory, filename);
			resolver.fileSystem.readFile(descriptionFilePath, function(err, content) {
				if(err) {
					directory = cdUp(directory);
					if(!directory) {
						return callback();
					} else {
						return findDescriptionFile();
					}
				}
				try {
					content = JSON.parse(content);
				} catch(e) {
					if(callback.log)
						callback.log(descriptionFilePath + " (directory description file): " + e);
					else
						e.message = descriptionFilePath + " (directory description file): " + e;
					return callback(e);
				}
				var fieldData;
				if(Array.isArray(field)) {
					var current = content;
					for(var j = 0; j < field.length; j++) {
						if(current === null || typeof current !== "object") {
							current = null;
							break;
						}
						current = current[field[j]];
					}
					if(typeof current === "object") {
						fieldData = current;
					}
				} else {
					if(typeof content[field] === "object") {
						fieldData = content[field];
					}
				}
				if(!fieldData) return callback();
				callback(null, fieldData, directory);
			});
		}());
	}
	
	function cdUp(directory) {
		if(directory === "/") return null;
		var i = directory.lastIndexOf("/"),
			j = directory.lastIndexOf("\\");
		var p = i < 0 ? j : j < 0 ? i : i < j ? j : i;
		if(p < 0) return null;
		return directory.substr(0, p || 1);
	}
	
	DirectoryDescriptionFileFieldAliasPlugin.prototype.apply = function(resolver) {
		var filename = this.filename;
		var field = this.field;
		resolver.plugin("module", function(request, callback) {
			var directory = request.path;
			var moduleName = request.request;
			findDescriptionFileField(this, directory, filename, field, function(err, fieldData, directory) {
				if(err) return callback(err);
				if(!fieldData) return callback();
				var data = fieldData[moduleName];
				if(data === moduleName) return callback();
				if(data === false) return callback(null, {
					path: false,
					resolved: true
				});
				if(!data) return callback();
				var newRequest = this.parse(data);
				var obj = {
					path: directory,
					request: newRequest.path,
					query: newRequest.query,
					directory: newRequest.directory
				};
				var newCallback = createInnerCallback(callback, callback, "aliased from directory description file " + this.join(directory, filename) + " with mapping " + JSON.stringify(moduleName));
				if(newRequest.module) return this.doResolve("module", obj, newCallback);
				if(newRequest.directory) return this.doResolve("directory", obj, newCallback);
				return this.doResolve(["file", "directory"], obj, newCallback);
			}.bind(this));
		});
		resolver.plugin("result", function(request, callback) {
			var directory = cdUp(request.path);
			var requestPath = request.path;
			findDescriptionFileField(this, directory, filename, field, function(err, fieldData, directory) {
				if(err) return callback(err);
				if(!fieldData) return callback();
				var relative = requestPath.substr(directory.length+1).replace(/\\/g, "/");
				if(typeof fieldData[relative] !== "undefined")
					var data = fieldData[relative];
				else if(typeof fieldData["./" + relative] !== "undefined")
					var data = fieldData["./" + relative];
				if(data === relative || data === "./" + relative) return callback();
				if(data === false) return callback(null, {
					path: false,
					resolved: true
				});
				if(!data) return callback();
				var newRequest = this.parse(data);
				var obj = {
					path: directory,
					request: newRequest.path,
					query: newRequest.query,
					directory: newRequest.directory
				};
				var newCallback = createInnerCallback(callback, callback, "aliased from directory description file " + this.join(directory, filename) + " with mapping " + JSON.stringify(relative));
				if(newRequest.module) return this.doResolve("module", obj, newCallback);
				if(newRequest.directory) return this.doResolve("directory", obj, newCallback);
				return this.doResolve(["file", "directory"], obj, newCallback);
			}.bind(this));
		});
	};


/***/ },
/* 180 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function FileAppendPlugin(appendings) {
		this.appendings = appendings;
	}
	module.exports = FileAppendPlugin;
	
	FileAppendPlugin.prototype.apply = function(resolver) {
		var appendings = this.appendings;
		resolver.plugin("file", function(request, callback) {
			var fs = this.fileSystem;
			var addr = this.join(request.path, request.request);
			var addrs = appendings.map(function(a) { return addr + a });
			var log = callback.log;
			var missing = callback.missing;
			this.forEachBail(addrs, function(addr, callback) {
				fs.stat(addr, function(err, stat) {
					if(!err && stat && stat.isFile())
						return callback(addr);
					if(missing && err)
						missing.push(addr);
					if(log) {
						if(err) log(addr + " doesn't exist");
						else log(addr + " is not a file");
					}
					return callback();
				});
			}, function(validAddr) {
				if(!validAddr) return callback();
				return this.doResolve("result", {
					path: validAddr,
					query: request.query,
					file: true,
					resolved: true
				}, callback);
			}.bind(this));
		});
	};

/***/ },
/* 181 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function DirectoryResultPlugin(files) {
		this.files = files;
	}
	module.exports = DirectoryResultPlugin;
	
	DirectoryResultPlugin.prototype.apply = function(resolver) {
		var files = this.files;
		resolver.plugin("directory", function(request, callback) {
			var fs = this.fileSystem;
			var directory = this.join(request.path, request.request);
			fs.stat(directory, function(err, stat) {
				if(!err && stat && stat.isDirectory()) {
					return this.doResolve("result", {
						path: directory,
						query: request.query,
						directory: true,
						resolved: true
					}, callback);
				}
				if(callback.log) {
					if(err) callback.log(directory + " doesn't exist");
					else callback.log(directory + " is not a directory");
				}
				return callback();
			}.bind(this));
		});
	};

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var popPathSeqment = __webpack_require__(172);
	
	function ResultSymlinkPlugin(appendings) {
	}
	module.exports = ResultSymlinkPlugin;
	
	ResultSymlinkPlugin.prototype.apply = function(resolver) {
		resolver.plugin("result", function pluginMethod(request, callback) {
			var fs = this.fileSystem;
			var paths = [request.path];
			var pathSeqments = [];
			var addr = [request.path];
			var pathSeqment = popPathSeqment(addr);
			while(pathSeqment) {
				pathSeqments.push(pathSeqment);
				paths.push(addr[0]);
				pathSeqment = popPathSeqment(addr);
			}
			pathSeqments.push(paths[paths.length-1]);
			var log = callback.log;
			var missing = callback.missing;
			var containsSymlink = false;
			this.forEachBail(paths.map(function(_, i) { return i; }), function(idx, callback) {
				fs.readlink(paths[idx], function(err, result) {
					if(!err && result) {
						pathSeqments[idx] = result;
						containsSymlink = true;
						// Shortcut when absolute symlink found
						if(/^(\/|[a-zA-z]:($|\\))/.test(result))
							return callback(null, idx);
					}
					callback();
				});
			}, function(err, idx) {
				if(!containsSymlink) return callback();
				var resultSeqments = typeof idx === "number" ? pathSeqments.slice(0, idx+1) : pathSeqments.slice();
				var result = resultSeqments.reverse().reduce(function(a, b) {
					return this.join(a, b);
				}.bind(this));
				log("resolved symlink to " + result);
				request.path = result;
				pluginMethod.call(this, request, callback);
			}.bind(this));
		});
	};

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var JsonpMainTemplatePlugin = __webpack_require__(184);
	var JsonpChunkTemplatePlugin = __webpack_require__(186);
	var JsonpHotUpdateChunkTemplatePlugin = __webpack_require__(187);
	
	function JsonpTemplatePlugin() {}
	module.exports = JsonpTemplatePlugin;
	JsonpTemplatePlugin.prototype.apply = function(compiler) {
		compiler.plugin("this-compilation", function(compilation) {
			compilation.mainTemplate.apply(new JsonpMainTemplatePlugin());
			compilation.chunkTemplate.apply(new JsonpChunkTemplatePlugin());
			compilation.hotUpdateChunkTemplate.apply(new JsonpHotUpdateChunkTemplatePlugin());
		});
	};


/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Template = __webpack_require__(52);
	
	function JsonpMainTemplatePlugin() {}
	module.exports = JsonpMainTemplatePlugin;
	
	JsonpMainTemplatePlugin.prototype.constructor = JsonpMainTemplatePlugin;
	JsonpMainTemplatePlugin.prototype.apply = function(mainTemplate) {
		mainTemplate.plugin("local-vars", function(source, chunk) {
			if(chunk.chunks.length > 0) {
				return this.asString([
					source,
					"",
					"// object to store loaded and loading chunks",
					"// \"0\" means \"already loaded\"",
					"// Array means \"loading\", array contains callbacks",
					"var installedChunks = {",
					this.indent(
						chunk.ids.map(function(id) {
							return id + ":0";
						}).join(",\n")
					),
					"};"
				]);
			}
			return source;
		});
		mainTemplate.plugin("jsonp-script", function(_, chunk, hash) {
			var filename = this.outputOptions.filename || "bundle.js";
			var chunkFilename = this.outputOptions.chunkFilename || "[id]." + filename;
			var chunkMaps = chunk.getChunkMaps();
			var crossOriginLoading = this.outputOptions.crossOriginLoading;
			return this.asString([
				"var script = document.createElement('script');",
				"script.type = 'text/javascript';",
				"script.charset = 'utf-8';",
				"script.async = true;",
				crossOriginLoading ? "script.crossOrigin = '" + crossOriginLoading + "';" : "",
				"script.src = " + this.requireFn + ".p + " +
				this.applyPluginsWaterfall("asset-path", JSON.stringify(chunkFilename), {
					hash: "\" + " + this.renderCurrentHashCode(hash) + " + \"",
					hashWithLength: function(length) {
						return "\" + " + this.renderCurrentHashCode(hash, length) + " + \"";
					}.bind(this),
					chunk: {
						id: "\" + chunkId + \"",
						hash: "\" + " + JSON.stringify(chunkMaps.hash) + "[chunkId] + \"",
						hashWithLength: function(length) {
							var shortChunkHashMap = {};
							Object.keys(chunkMaps.hash).forEach(function(chunkId) {
								if(typeof chunkMaps.hash[chunkId] === "string")
									shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substr(0, length);
							});
							return "\" + " + JSON.stringify(shortChunkHashMap) + "[chunkId] + \"";
						},
						name: "\" + (" + JSON.stringify(chunkMaps.name) + "[chunkId]||chunkId) + \""
					}
				}) + ";"
			]);
		});
		mainTemplate.plugin("require-ensure", function(_, chunk, hash) {
			var filename = this.outputOptions.filename || "bundle.js";
			var chunkFilename = this.outputOptions.chunkFilename || "[id]." + filename;
			return this.asString([
				"// \"0\" is the signal for \"already loaded\"",
				"if(installedChunks[chunkId] === 0)",
				this.indent("return callback.call(null, " + this.requireFn + ");"),
				"",
				"// an array means \"currently loading\".",
				"if(installedChunks[chunkId] !== undefined) {",
				this.indent("installedChunks[chunkId].push(callback);"),
				"} else {",
				this.indent([
					"// start chunk loading",
					"installedChunks[chunkId] = [callback];",
					"var head = document.getElementsByTagName('head')[0];",
					this.applyPluginsWaterfall("jsonp-script", "", chunk, hash),
					"head.appendChild(script);"
				]),
				"}"
			]);
		});
		mainTemplate.plugin("bootstrap", function(source, chunk, hash) {
			if(chunk.chunks.length > 0) {
				var jsonpFunction = this.outputOptions.jsonpFunction || Template.toIdentifier("webpackJsonp" + (this.outputOptions.library || ""));
				return this.asString([
					source,
					"",
					"// install a JSONP callback for chunk loading",
					"var parentJsonpFunction = window[" + JSON.stringify(jsonpFunction) + "];",
					"window[" + JSON.stringify(jsonpFunction) + "] = function webpackJsonpCallback(chunkIds, moreModules) {",
					this.indent([
						"// add \"moreModules\" to the modules object,",
						"// then flag all \"chunkIds\" as loaded and fire callback",
						"var moduleId, chunkId, i = 0, callbacks = [];",
						"for(;i < chunkIds.length; i++) {",
						this.indent([
							"chunkId = chunkIds[i];",
							"if(installedChunks[chunkId])",
							this.indent("callbacks.push.apply(callbacks, installedChunks[chunkId]);"),
							"installedChunks[chunkId] = 0;"
						]),
						"}",
						"for(moduleId in moreModules) {",
						this.indent(this.renderAddModule(hash, chunk, "moduleId", "moreModules[moduleId]")),
						"}",
						"if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);",
						"while(callbacks.length)",
						this.indent("callbacks.shift().call(null, " + this.requireFn + ");"), (this.entryPointInChildren(chunk) ? [
							"if(moreModules[0]) {",
							this.indent([
								"installedModules[0] = 0;",
								"return " + this.requireFn + "(0);"
							]),
							"}"
						] : "")
					]),
					"};"
				]);
			}
			return source;
		});
		mainTemplate.plugin("hot-bootstrap", function(source, chunk, hash) {
			var hotUpdateChunkFilename = this.outputOptions.hotUpdateChunkFilename;
			var hotUpdateMainFilename = this.outputOptions.hotUpdateMainFilename;
			var hotUpdateFunction = this.outputOptions.hotUpdateFunction || Template.toIdentifier("webpackHotUpdate" + (this.outputOptions.library || ""));
			var currentHotUpdateChunkFilename = this.applyPluginsWaterfall("asset-path", JSON.stringify(hotUpdateChunkFilename), {
				hash: "\" + " + this.renderCurrentHashCode(hash) + " + \"",
				hashWithLength: function(length) {
					return "\" + " + this.renderCurrentHashCode(hash, length) + " + \"";
				}.bind(this),
				chunk: {
					id: "\" + chunkId + \""
				}
			});
			var currentHotUpdateMainFilename = this.applyPluginsWaterfall("asset-path", JSON.stringify(hotUpdateMainFilename), {
				hash: "\" + " + this.renderCurrentHashCode(hash) + " + \"",
				hashWithLength: function(length) {
					return "\" + " + this.renderCurrentHashCode(hash, length) + " + \"";
				}.bind(this)
			});
	
			return source + "\n" +
				"var parentHotUpdateCallback = this[" + JSON.stringify(hotUpdateFunction) + "];\n" +
				"this[" + JSON.stringify(hotUpdateFunction) + "] = " + Template.getFunctionContent(__webpack_require__(185))
				.replace(/\$require\$/g, this.requireFn)
				.replace(/\$hotMainFilename\$/g, currentHotUpdateMainFilename)
				.replace(/\$hotChunkFilename\$/g, currentHotUpdateChunkFilename)
				.replace(/\$hash\$/g, JSON.stringify(hash));
		});
		mainTemplate.plugin("hash", function(hash) {
			hash.update("jsonp");
			hash.update("4");
			hash.update(this.outputOptions.filename + "");
			hash.update(this.outputOptions.chunkFilename + "");
			hash.update(this.outputOptions.jsonpFunction + "");
			hash.update(this.outputOptions.library + "");
		});
	};


/***/ },
/* 185 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	/*globals hotAddUpdateChunk parentHotUpdateCallback document XMLHttpRequest $require$ $hotChunkFilename$ $hotMainFilename$ */
	module.exports = function() {
		function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
			hotAddUpdateChunk(chunkId, moreModules);
			if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
		}
	
		function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
			var head = document.getElementsByTagName("head")[0];
			var script = document.createElement("script");
			script.type = "text/javascript";
			script.charset = "utf-8";
			script.src = $require$.p + $hotChunkFilename$;
			head.appendChild(script);
		}
	
		function hotDownloadManifest(callback) { // eslint-disable-line no-unused-vars
			if(typeof XMLHttpRequest === "undefined")
				return callback(new Error("No browser support"));
			try {
				var request = new XMLHttpRequest();
				var requestPath = $require$.p + $hotMainFilename$;
				request.open("GET", requestPath, true);
				request.timeout = 10000;
				request.send(null);
			} catch(err) {
				return callback(err);
			}
			request.onreadystatechange = function() {
				if(request.readyState !== 4) return;
				if(request.status === 0) {
					// timeout
					callback(new Error("Manifest request to " + requestPath + " timed out."));
				} else if(request.status === 404) {
					// no update available
					callback();
				} else if(request.status !== 200 && request.status !== 304) {
					// other failure
					callback(new Error("Manifest request to " + requestPath + " failed."));
				} else {
					// success
					try {
						var update = JSON.parse(request.responseText);
					} catch(e) {
						callback(e);
						return;
					}
					callback(null, update);
				}
			};
		}
	};


/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConcatSource = __webpack_require__(49);
	var Template = __webpack_require__(52);
	
	function JsonpChunkTemplatePlugin() {}
	module.exports = JsonpChunkTemplatePlugin;
	
	JsonpChunkTemplatePlugin.prototype.apply = function(chunkTemplate) {
		chunkTemplate.plugin("render", function(modules, chunk) {
			var jsonpFunction = this.outputOptions.jsonpFunction || Template.toIdentifier("webpackJsonp" + (this.outputOptions.library || ""));
			var source = new ConcatSource();
			source.add(jsonpFunction + "(" + JSON.stringify(chunk.ids) + ",");
			source.add(modules);
			source.add(")");
			return source;
		});
		chunkTemplate.plugin("hash", function(hash) {
			hash.update("JsonpChunkTemplatePlugin");
			hash.update("3");
			hash.update(this.outputOptions.jsonpFunction + "");
			hash.update(this.outputOptions.library + "");
		});
	};


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConcatSource = __webpack_require__(49);
	var Template = __webpack_require__(52);
	
	function JsonpHotUpdateChunkTemplatePlugin() {}
	module.exports = JsonpHotUpdateChunkTemplatePlugin;
	
	JsonpHotUpdateChunkTemplatePlugin.prototype.apply = function(hotUpdateChunkTemplate) {
		hotUpdateChunkTemplate.plugin("render", function(modulesSource, modules, hash, id) {
			var jsonpFunction = this.outputOptions.hotUpdateFunction || Template.toIdentifier("webpackHotUpdate" + (this.outputOptions.library || ""));
			var source = new ConcatSource();
			source.add(jsonpFunction + "(" + JSON.stringify(id) + ",");
			source.add(modulesSource);
			source.add(")");
			return source;
		});
		hotUpdateChunkTemplate.plugin("hash", function(hash) {
			hash.update("JsonpHotUpdateChunkTemplatePlugin");
			hash.update("3");
			hash.update(this.outputOptions.hotUpdateFunction + "");
			hash.update(this.outputOptions.library + "");
		});
	};


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleAliasPlugin = __webpack_require__(115);
	var ModuleParserHelpers = __webpack_require__(112);
	var nodeLibsBrowser = __webpack_require__(189);
	var path = __webpack_require__(4);
	
	function NodeSourcePlugin(options) {
		this.options = options;
	}
	module.exports = NodeSourcePlugin;
	NodeSourcePlugin.prototype.apply = function(compiler) {
		var parser = compiler.parser;
	
		function buildExpression(context, pathToModule) {
			var moduleJsPath = path.relative(context, pathToModule);
			if(!/^[A-Z]:/i.test(moduleJsPath)) {
				moduleJsPath = "./" + moduleJsPath.replace(/\\/g, "/");
			}
			return "require(" + JSON.stringify(moduleJsPath) + ")";
		}
	
		function addExpression(parser, name, module, type, suffix) {
			suffix = suffix || "";
			parser.plugin("expression " + name, function() {
				if(this.state.module && this.state.module.resource === getPathToModule(module, type)) return;
				return ModuleParserHelpers.addParsedVariable(this, name, buildExpression(this.state.module.context, getPathToModule(module, type)) + suffix);
			});
		}
	
		function getPathToModule(module, type) {
			if(type === true || (type === undefined && nodeLibsBrowser[module])) {
				if(!nodeLibsBrowser[module]) throw new Error("No browser version for node.js core module '" + module + "' available");
				return nodeLibsBrowser[module];
			} else if(type === "mock") {
				return /*require.resolve*/(__webpack_require__(190).resolve("./" + module));
			} else if(type === "empty") {
				return /*require.resolve*/(194);
			} else return module;
		}
	
		if(this.options.global) {
			compiler.parser.plugin("expression global", function() {
				this.state.module.addVariable("global", "(function() { return this; }())");
				return true;
			});
		}
		if(this.options.process) {
			var processType = this.options.process;
			addExpression(parser, "process", "process", processType);
		}
		if(this.options.console) {
			var consoleType = this.options.console;
			addExpression(parser, "console", "console", consoleType);
		}
		var bufferType = this.options.Buffer;
		if(typeof bufferType === "undefined") {
			bufferType = this.options.buffer;
			if(typeof bufferType === "undefined")
				bufferType = true;
		}
		if(bufferType) {
			addExpression(parser, "Buffer", "buffer", bufferType, ".Buffer");
		}
		if(this.options.setImmediate) {
			var setImmediateType = this.options.setImmediate;
			addExpression(parser, "setImmediate", "timers", setImmediateType, ".setImmediate");
			addExpression(parser, "clearImmediate", "timers", setImmediateType, ".clearImmediate");
		}
		var options = this.options;
		compiler.plugin("after-resolvers", function(compiler) {
			var alias = {};
			Object.keys(nodeLibsBrowser).forEach(function(lib) {
				if(options[lib] !== false)
					alias[lib + "$"] = getPathToModule(lib, options[lib]);
			});
			if(Object.keys(alias).length > 0) {
				compiler.resolvers.normal.apply(
					new ModuleAliasPlugin(alias)
				);
			}
		});
	};


/***/ },
/* 189 */
/***/ function(module, exports) {



/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./buffer": 191,
		"./buffer.js": 191,
		"./console": 192,
		"./console.js": 192,
		"./dns": 193,
		"./dns.js": 193,
		"./empty": 194,
		"./empty.js": 194,
		"./net": 195,
		"./net.js": 195,
		"./process": 196,
		"./process.js": 196,
		"./punycode": 197,
		"./punycode.js": 197,
		"./tls": 198,
		"./tls.js": 198,
		"./tty": 199,
		"./tty.js": 199
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 190;


/***/ },
/* 191 */
/***/ function(module, exports) {

	function Buffer() {
		throw new Error("Buffer is not included.");
	}
	Buffer.isBuffer = function() {
	  return false;
	};
	
	exports.INSPECT_MAX_BYTES = 50;
	exports.SlowBuffer = Buffer;
	exports.Buffer = Buffer;


/***/ },
/* 192 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {var console;
	if (typeof global !== "undefined" && global.console) {
	    console = global.console
	} else if (typeof window !== "undefined" && window.console) {
	    console = window.console
	} else {
	    console = window.console = {}
	}
	module.exports = console;
	for(var name in {log:1, info:1, error:1, warn:1, dir:1, trace:1, assert:1, time:1, timeEnd: 1})
		if(!console[name])
			console[name] = function() {};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 193 */
/***/ function(module, exports) {

	exports.lookup = exports.resolve4 =
	exports.resolve6 = exports.resolveCname =
	exports.resolveMx = exports.resolveNs =
	exports.resolveTxt = exports.resolveSrv =
	exports.resolveNaptr = exports.reverse =
	exports.resolve =
	function () {
	  if (!arguments.length) return;
	
	  var callback = arguments[arguments.length - 1];
	  if (callback && typeof callback === 'function') {
	    callback(null, '0.0.0.0')
	  }
	}
	


/***/ },
/* 194 */
/***/ function(module, exports) {



/***/ },
/* 195 */
/***/ function(module, exports) {

	exports.createServer =
	exports.createConnection =
	exports.connect =
	function () {};
	
	exports.isIP =
	exports.isIPv4 =
	exports.isIPv6 =
	function () { return true };
	


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	exports.nextTick = function nextTick(fn) {
		setTimeout(fn, 0);
	};
	
	exports.platform = exports.arch = 
	exports.execPath = exports.title = 'browser';
	exports.pid = 1;
	exports.browser = true;
	exports.env = {};
	exports.argv = [];
	
	exports.binding = function (name) {
		throw new Error('No such module. (Possibly not yet loaded)')
	};
	
	(function () {
	    var cwd = '/';
	    var path;
	    exports.cwd = function () { return cwd };
	    exports.chdir = function (dir) {
	        if (!path) path = __webpack_require__(4);
	        cwd = path.resolve(dir, cwd);
	    };
	})();
	
	exports.exit = exports.kill = 
	exports.umask = exports.dlopen = 
	exports.uptime = exports.memoryUsage = 
	exports.uvCounters = function() {};
	exports.features = {};


/***/ },
/* 197 */
/***/ function(module, exports) {

	exports.ucs2 = {};
	exports.encode = exports.decode =
	exports.ucs2.encode = exports.ucs2.decode =
	exports.toUnicode = exports.toASCII =
	function (s) { return s };
	exports.version = "0.0.0";

/***/ },
/* 198 */
/***/ function(module, exports) {

	// todo


/***/ },
/* 199 */
/***/ function(module, exports) {

	exports.isatty = function () {};
	exports.setRawMode = function () {};


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var WebWorkerMainTemplatePlugin = __webpack_require__(201);
	var WebWorkerChunkTemplatePlugin = __webpack_require__(202);
	
	function WebWorkerTemplatePlugin() {}
	module.exports = WebWorkerTemplatePlugin;
	WebWorkerTemplatePlugin.prototype.apply = function(compiler) {
		compiler.plugin("this-compilation", function(compilation) {
			compilation.mainTemplate.apply(new WebWorkerMainTemplatePlugin());
			compilation.chunkTemplate.apply(new WebWorkerChunkTemplatePlugin());
		});
	};


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Template = __webpack_require__(52);
	
	function WebWorkerMainTemplatePlugin() {}
	module.exports = WebWorkerMainTemplatePlugin;
	
	WebWorkerMainTemplatePlugin.prototype.apply = function(mainTemplate) {
		mainTemplate.plugin("local-vars", function(source, chunk) {
			if(chunk.chunks.length > 0) {
				return this.asString([
					source,
					"",
					"// object to store loaded chunks",
					"// \"1\" means \"already loaded\"",
					"var installedChunks = {",
					this.indent(
						chunk.ids.map(function(id) {
							return id + ":1";
						}).join(",\n")
					),
					"};"
				]);
			}
			return source;
		});
		mainTemplate.plugin("require-ensure", function(_, chunk, hash) {
			var filename = this.outputOptions.filename || "bundle.js";
			var chunkFilename = this.outputOptions.chunkFilename || "[id]." + filename;
			return this.asString([
				"// \"1\" is the signal for \"already loaded\"",
				"if(!installedChunks[chunkId]) {",
				this.indent([
					"importScripts(" +
					this.applyPluginsWaterfall("asset-path", JSON.stringify(chunkFilename), {
						hash: "\" + " + this.renderCurrentHashCode(hash) + " + \"",
						hashWithLength: function(length) {
							return "\" + " + this.renderCurrentHashCode(hash, length) + " + \"";
						}.bind(this),
						chunk: {
							id: "\" + chunkId + \""
						}
					}) + ");"
				]),
				"}",
				"callback.call(null, " + this.requireFn + ");"
			]);
		});
		mainTemplate.plugin("bootstrap", function(source, chunk, hash) {
			if(chunk.chunks.length > 0) {
				var chunkCallbackName = this.outputOptions.chunkCallbackName || Template.toIdentifier("webpackChunk" + (this.outputOptions.library || ""));
				return this.asString([
					source,
					"this[" + JSON.stringify(chunkCallbackName) + "] = function webpackChunkCallback(chunkIds, moreModules) {",
					this.indent([
						"for(var moduleId in moreModules) {",
						this.indent(this.renderAddModule(hash, chunk, "moduleId", "moreModules[moduleId]")),
						"}",
						"while(chunkIds.length)",
						this.indent("installedChunks[chunkIds.pop()] = 1;")
					]),
					"};"
				]);
			}
			return source;
		});
		mainTemplate.plugin("hash", function(hash) {
			hash.update("webworker");
			hash.update("3");
			hash.update(this.outputOptions.publicPath + "");
			hash.update(this.outputOptions.filename + "");
			hash.update(this.outputOptions.chunkFilename + "");
			hash.update(this.outputOptions.chunkCallbackName + "");
			hash.update(this.outputOptions.library + "");
		});
	};


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConcatSource = __webpack_require__(49);
	var Template = __webpack_require__(52);
	
	function WebWorkerChunkTemplatePlugin() {}
	module.exports = WebWorkerChunkTemplatePlugin;
	
	WebWorkerChunkTemplatePlugin.prototype.apply = function(chunkTemplate) {
		chunkTemplate.plugin("render", function(modules, chunk) {
			var chunkCallbackName = this.outputOptions.chunkCallbackName || Template.toIdentifier("webpackChunk" + (this.outputOptions.library || ""));
			var source = new ConcatSource();
			source.add(chunkCallbackName + "(" + JSON.stringify(chunk.ids) + ",");
			source.add(modules);
			source.add(")");
			return source;
		});
		chunkTemplate.plugin("hash", function(hash) {
			hash.update("webworker");
			hash.update("3");
			hash.update(this.outputOptions.chunkCallbackName + "");
			hash.update(this.outputOptions.library + "");
		});
	};


/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var NodeMainTemplatePlugin = __webpack_require__(204);
	var NodeChunkTemplatePlugin = __webpack_require__(210);
	var NodeHotUpdateChunkTemplatePlugin = __webpack_require__(302);
	
	function NodeTemplatePlugin(options, asyncChunkLoading) {
		// TODO remove options parameter
		this.options = options;
		this.asyncChunkLoading = asyncChunkLoading;
	}
	module.exports = NodeTemplatePlugin;
	NodeTemplatePlugin.prototype.apply = function(compiler) {
		compiler.plugin("this-compilation", function(compilation) {
			compilation.mainTemplate.apply(new NodeMainTemplatePlugin(this.asyncChunkLoading));
			compilation.chunkTemplate.apply(new NodeChunkTemplatePlugin());
			compilation.hotUpdateChunkTemplate.apply(new NodeHotUpdateChunkTemplatePlugin());
		}.bind(this));
	};


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Template = __webpack_require__(52);
	
	function NodeMainTemplatePlugin(asyncChunkLoading) {
		this.asyncChunkLoading = asyncChunkLoading;
	}
	module.exports = NodeMainTemplatePlugin;
	NodeMainTemplatePlugin.prototype.apply = function(mainTemplate) {
		var self = this;
		mainTemplate.plugin("local-vars", function(source, chunk) {
			if(chunk.chunks.length > 0) {
				return this.asString([
					source,
					"",
					"// object to store loaded chunks",
					"// \"1\" means \"already loaded\"",
					"var installedChunks = {",
					this.indent(
						chunk.ids.map(function(id) {
							return id + ":1";
						}).join(",\n")
					),
					"};"
				]);
			}
			return source;
		});
		mainTemplate.plugin("require-ensure", function(_, chunk, hash) {
			var filename = this.outputOptions.filename || "bundle.js";
			var chunkFilename = this.outputOptions.chunkFilename || "[id]." + filename;
			var chunkMaps = chunk.getChunkMaps();
			var insertMoreModules = [
				"var moreModules = chunk.modules, chunkIds = chunk.ids;",
				"for(var moduleId in moreModules) {",
				this.indent(this.renderAddModule(hash, chunk, "moduleId", "moreModules[moduleId]")),
				"}"
			];
			if(self.asyncChunkLoading) {
				return this.asString([
					"if(installedChunks[chunkId] === 1) callback.call(null, " + this.requireFn + ");",
					"else if(!installedChunks[chunkId]) {",
					this.indent([
						"installedChunks[chunkId] = [callback];",
						"var filename = __dirname + " + this.applyPluginsWaterfall("asset-path", JSON.stringify("/" + chunkFilename), {
							hash: "\" + " + this.renderCurrentHashCode(hash) + " + \"",
							hashWithLength: function(length) {
								return "\" + " + this.renderCurrentHashCode(hash, length) + " + \"";
							}.bind(this),
							chunk: {
								id: "\" + chunkId + \"",
								hash: "\" + " + JSON.stringify(chunkMaps.hash) + "[chunkId] + \"",
								hashWithLength: function(length) {
									var shortChunkHashMap = {};
									Object.keys(chunkMaps.hash).forEach(function(chunkId) {
										if(typeof chunkMaps.hash[chunkId] === "string")
											shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substr(0, length);
									});
									return "\" + " + JSON.stringify(shortChunkHashMap) + "[chunkId] + \"";
								},
								name: "\" + (" + JSON.stringify(chunkMaps.name) + "[chunkId]||chunkId) + \""
							}
						}) + ";",
						"require('fs').readFile(filename, 'utf-8',  function(err, content) {",
						this.indent([
							"if(err) { if(" + this.requireFn + ".onError) return " + this.requireFn + ".onError(err); else throw err; }",
							"var chunk = {};",
							"require('vm').runInThisContext('(function(exports, require, __dirname, __filename) {' + content + '\\n})', filename)" +
							"(chunk, require, require('path').dirname(filename), filename);"
						].concat(insertMoreModules).concat([
							"var callbacks = [];",
							"for(var i = 0; i < chunkIds.length; i++) {",
							this.indent([
								"if(Array.isArray(installedChunks[chunkIds[i]]))",
								this.indent([
									"callbacks = callbacks.concat(installedChunks[chunkIds[i]]);"
								]),
								"installedChunks[chunkIds[i]] = 1;"
							]),
							"}",
							"for(i = 0; i < callbacks.length; i++)",
							this.indent("callbacks[i].call(null, " + this.requireFn + ");")
						])),
						"});"
					]),
					"} else installedChunks[chunkId].push(callback);"
				]);
			} else {
				var request = this.applyPluginsWaterfall("asset-path", JSON.stringify("./" + chunkFilename), {
					hash: "\" + " + this.renderCurrentHashCode(hash) + " + \"",
					hashWithLength: function(length) {
						return "\" + " + this.renderCurrentHashCode(hash, length) + " + \"";
					}.bind(this),
					chunk: {
						id: "\" + chunkId + \"",
						hash: "\" + " + JSON.stringify(chunkMaps.hash) + "[chunkId] + \"",
						hashWithLength: function(length) {
							var shortChunkHashMap = {};
							Object.keys(chunkMaps.hash).forEach(function(chunkId) {
								if(typeof chunkMaps.hash[chunkId] === "string")
									shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substr(0, length);
							});
							return "\" + " + JSON.stringify(shortChunkHashMap) + "[chunkId] + \"";
						},
						name: "\" + (" + JSON.stringify(chunkMaps.name) + "[chunkId]||chunkId) + \""
					}
				});
				return this.asString([
					"// \"1\" is the signal for \"already loaded\"",
					"if(!installedChunks[chunkId]) {",
					this.indent([
						"var chunk = require(" + request + ");"
					].concat(insertMoreModules).concat([
						"for(var i = 0; i < chunkIds.length; i++)",
						this.indent("installedChunks[chunkIds[i]] = 1;")
					])),
					"}",
					"callback.call(null, " + this.requireFn + ");"
				]);
			}
		});
		mainTemplate.plugin("hot-bootstrap", function(source, chunk, hash) {
			var hotUpdateChunkFilename = this.outputOptions.hotUpdateChunkFilename;
			var hotUpdateMainFilename = this.outputOptions.hotUpdateMainFilename;
			var chunkMaps = chunk.getChunkMaps();
			var currentHotUpdateChunkFilename = this.applyPluginsWaterfall("asset-path", JSON.stringify(hotUpdateChunkFilename), {
				hash: "\" + " + this.renderCurrentHashCode(hash) + " + \"",
				hashWithLength: function(length) {
					return "\" + " + this.renderCurrentHashCode(hash, length) + " + \"";
				}.bind(this),
				chunk: {
					id: "\" + chunkId + \"",
					hash: "\" + " + JSON.stringify(chunkMaps.hash) + "[chunkId] + \"",
					hashWithLength: function(length) {
						var shortChunkHashMap = {};
						Object.keys(chunkMaps.hash).forEach(function(chunkId) {
							if(typeof chunkMaps.hash[chunkId] === "string")
								shortChunkHashMap[chunkId] = chunkMaps.hash[chunkId].substr(0, length);
						});
						return "\" + " + JSON.stringify(shortChunkHashMap) + "[chunkId] + \"";
					},
					name: "\" + (" + JSON.stringify(chunkMaps.name) + "[chunkId]||chunkId) + \""
				}
			});
			var currentHotUpdateMainFilename = this.applyPluginsWaterfall("asset-path", JSON.stringify(hotUpdateMainFilename), {
				hash: "\" + " + this.renderCurrentHashCode(hash) + " + \"",
				hashWithLength: function(length) {
					return "\" + " + this.renderCurrentHashCode(hash, length) + " + \"";
				}.bind(this)
			});
			return Template.getFunctionContent(self.asyncChunkLoading ? __webpack_require__(205) : __webpack_require__(208))
				.replace(/\$require\$/g, this.requireFn)
				.replace(/\$hotMainFilename\$/g, currentHotUpdateMainFilename)
				.replace(/\$hotChunkFilename\$/g, currentHotUpdateChunkFilename);
		});
		mainTemplate.plugin("hash", function(hash) {
			hash.update("node");
			hash.update("3");
			hash.update(this.outputOptions.filename + "");
			hash.update(this.outputOptions.chunkFilename + "");
		});
	};


/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	/*global $hotChunkFilename$ $require$ hotAddUpdateChunk $hotMainFilename$ */
	module.exports = function() {
		function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
			var filename = __webpack_require__(4).join(__dirname, $hotChunkFilename$);
			__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).readFile(filename, "utf-8", function(err, content) {
				if(err) {
					if($require$.onError)
						return $require$.onError(err);
					else
						throw err;
				}
				var chunk = {};
				__webpack_require__(206).runInThisContext("(function(exports) {" + content + "\n})", filename)(chunk);
				hotAddUpdateChunk(chunk.id, chunk.modules);
			});
		}
	
		function hotDownloadManifest(callback) { // eslint-disable-line no-unused-vars
			var filename = __webpack_require__(4).join(__dirname, $hotMainFilename$);
			__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).readFile(filename, "utf-8", function(err, content) {
				if(err) return callback();
				try {
					var update = JSON.parse(content);
				} catch(e) {
					return callback(e);
				}
				callback(null, update);
			});
		}
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	var indexOf = __webpack_require__(207);
	
	var Object_keys = function (obj) {
	    if (Object.keys) return Object.keys(obj)
	    else {
	        var res = [];
	        for (var key in obj) res.push(key)
	        return res;
	    }
	};
	
	var forEach = function (xs, fn) {
	    if (xs.forEach) return xs.forEach(fn)
	    else for (var i = 0; i < xs.length; i++) {
	        fn(xs[i], i, xs);
	    }
	};
	
	var defineProp = (function() {
	    try {
	        Object.defineProperty({}, '_', {});
	        return function(obj, name, value) {
	            Object.defineProperty(obj, name, {
	                writable: true,
	                enumerable: false,
	                configurable: true,
	                value: value
	            })
	        };
	    } catch(e) {
	        return function(obj, name, value) {
	            obj[name] = value;
	        };
	    }
	}());
	
	var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
	'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
	'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
	'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
	'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];
	
	function Context() {}
	Context.prototype = {};
	
	var Script = exports.Script = function NodeScript (code) {
	    if (!(this instanceof Script)) return new Script(code);
	    this.code = code;
	};
	
	Script.prototype.runInContext = function (context) {
	    if (!(context instanceof Context)) {
	        throw new TypeError("needs a 'context' argument.");
	    }
	    
	    var iframe = document.createElement('iframe');
	    if (!iframe.style) iframe.style = {};
	    iframe.style.display = 'none';
	    
	    document.body.appendChild(iframe);
	    
	    var win = iframe.contentWindow;
	    var wEval = win.eval, wExecScript = win.execScript;
	
	    if (!wEval && wExecScript) {
	        // win.eval() magically appears when this is called in IE:
	        wExecScript.call(win, 'null');
	        wEval = win.eval;
	    }
	    
	    forEach(Object_keys(context), function (key) {
	        win[key] = context[key];
	    });
	    forEach(globals, function (key) {
	        if (context[key]) {
	            win[key] = context[key];
	        }
	    });
	    
	    var winKeys = Object_keys(win);
	
	    var res = wEval.call(win, this.code);
	    
	    forEach(Object_keys(win), function (key) {
	        // Avoid copying circular objects like `top` and `window` by only
	        // updating existing context properties or new properties in the `win`
	        // that was only introduced after the eval.
	        if (key in context || indexOf(winKeys, key) === -1) {
	            context[key] = win[key];
	        }
	    });
	
	    forEach(globals, function (key) {
	        if (!(key in context)) {
	            defineProp(context, key, win[key]);
	        }
	    });
	    
	    document.body.removeChild(iframe);
	    
	    return res;
	};
	
	Script.prototype.runInThisContext = function () {
	    return eval(this.code); // maybe...
	};
	
	Script.prototype.runInNewContext = function (context) {
	    var ctx = Script.createContext(context);
	    var res = this.runInContext(ctx);
	
	    forEach(Object_keys(ctx), function (key) {
	        context[key] = ctx[key];
	    });
	
	    return res;
	};
	
	forEach(Object_keys(Script.prototype), function (name) {
	    exports[name] = Script[name] = function (code) {
	        var s = Script(code);
	        return s[name].apply(s, [].slice.call(arguments, 1));
	    };
	});
	
	exports.createScript = function (code) {
	    return exports.Script(code);
	};
	
	exports.createContext = Script.createContext = function (context) {
	    var copy = new Context();
	    if(typeof context === 'object') {
	        forEach(Object_keys(context), function (key) {
	            copy[key] = context[key];
	        });
	    }
	    return copy;
	};


/***/ },
/* 207 */
/***/ function(module, exports) {

	
	var indexOf = [].indexOf;
	
	module.exports = function(arr, obj){
	  if (indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	};

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	/*global $hotChunkFilename$ hotAddUpdateChunk $hotMainFilename$ */
	module.exports = function() {
		function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
			var chunk = __webpack_require__(209)("./" + $hotChunkFilename$);
			hotAddUpdateChunk(chunk.id, chunk.modules);
		}
	
		function hotDownloadManifest(callback) { // eslint-disable-line no-unused-vars
			try {
				var update = __webpack_require__(209)("./" + $hotMainFilename$);
			} catch(e) {
				return callback();
			}
			callback(null, update);
		}
	};


/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./NodeChunkTemplatePlugin": 210,
		"./NodeChunkTemplatePlugin.js": 210,
		"./NodeEnvironmentPlugin": 211,
		"./NodeEnvironmentPlugin.js": 211,
		"./NodeHotUpdateChunkTemplatePlugin": 302,
		"./NodeHotUpdateChunkTemplatePlugin.js": 302,
		"./NodeMainTemplate.runtime": 208,
		"./NodeMainTemplate.runtime.js": 208,
		"./NodeMainTemplateAsync.runtime": 205,
		"./NodeMainTemplateAsync.runtime.js": 205,
		"./NodeMainTemplatePlugin": 204,
		"./NodeMainTemplatePlugin.js": 204,
		"./NodeOutputFileSystem": 298,
		"./NodeOutputFileSystem.js": 298,
		"./NodeSourcePlugin": 188,
		"./NodeSourcePlugin.js": 188,
		"./NodeTargetPlugin": 303,
		"./NodeTargetPlugin.js": 303,
		"./NodeTemplatePlugin": 203,
		"./NodeTemplatePlugin.js": 203,
		"./NodeWatchFileSystem": 212,
		"./NodeWatchFileSystem.js": 212,
		"./OldNodeWatchFileSystem": 307,
		"./OldNodeWatchFileSystem.js": 307
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 209;


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConcatSource = __webpack_require__(49);
	
	function NodeChunkTemplatePlugin() {}
	module.exports = NodeChunkTemplatePlugin;
	
	NodeChunkTemplatePlugin.prototype.apply = function(chunkTemplate) {
		chunkTemplate.plugin("render", function(modules, chunk) {
			var source = new ConcatSource();
			source.add("exports.ids = " + JSON.stringify(chunk.ids) + ";\nexports.modules = ");
			source.add(modules);
			source.add(";");
			return source;
		});
		chunkTemplate.plugin("hash", function(hash) {
			hash.update("node");
			hash.update("3");
		});
	};


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var NodeWatchFileSystem = __webpack_require__(212);
	var NodeOutputFileSystem = __webpack_require__(298);
	var NodeJsInputFileSystem = __webpack_require__(300);
	var CachedInputFileSystem = __webpack_require__(301);
	
	function NodeEnvironmentPlugin() {}
	module.exports = NodeEnvironmentPlugin;
	NodeEnvironmentPlugin.prototype.apply = function(compiler) {
		compiler.inputFileSystem = new NodeJsInputFileSystem();
		var inputFileSystem = compiler.inputFileSystem = new CachedInputFileSystem(compiler.inputFileSystem, 60000);
		compiler.resolvers.normal.fileSystem = compiler.inputFileSystem;
		compiler.resolvers.context.fileSystem = compiler.inputFileSystem;
		compiler.resolvers.loader.fileSystem = compiler.inputFileSystem;
		compiler.outputFileSystem = new NodeOutputFileSystem();
		compiler.watchFileSystem = new NodeWatchFileSystem(compiler.inputFileSystem);
		compiler.plugin("run", function(compiler, callback) {
			if(compiler.inputFileSystem === inputFileSystem)
				inputFileSystem.purge();
			callback();
		});
	};


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Watchpack = __webpack_require__(213);
	
	function NodeWatchFileSystem(inputFileSystem) {
		this.inputFileSystem = inputFileSystem;
		this.watcherOptions = {
			aggregateTimeout: 0
		};
		this.watcher = new Watchpack(this.watcherOptions);
	}
	
	module.exports = NodeWatchFileSystem;
	
	NodeWatchFileSystem.prototype.watch = function watch(files, dirs, missing, startTime, options, callback, callbackUndelayed) {
		if(!Array.isArray(files))
			throw new Error("Invalid arguments: 'files'");
		if(!Array.isArray(dirs))
			throw new Error("Invalid arguments: 'dirs'");
		if(!Array.isArray(missing))
			throw new Error("Invalid arguments: 'missing'");
		if(typeof callback !== "function")
			throw new Error("Invalid arguments: 'callback'");
		if(typeof startTime !== "number" && startTime)
			throw new Error("Invalid arguments: 'startTime'");
		if(typeof options !== "object")
			throw new Error("Invalid arguments: 'options'");
		if(typeof callbackUndelayed !== "function" && callbackUndelayed)
			throw new Error("Invalid arguments: 'callbackUndelayed'");
		var oldWatcher = this.watcher;
		this.watcher = new Watchpack(options);
	
		if(callbackUndelayed)
			this.watcher.once("change", callbackUndelayed);
	
		this.watcher.once("aggregated", function(changes) {
			if(this.inputFileSystem && this.inputFileSystem.purge) {
				this.inputFileSystem.purge(changes);
			}
			var times = this.watcher.getTimes();
			callback(null, changes.filter(function(file) {
				return files.indexOf(file) >= 0;
			}).sort(), changes.filter(function(file) {
				return dirs.indexOf(file) >= 0;
			}).sort(), changes.filter(function(file) {
				return missing.indexOf(file) >= 0;
			}).sort(), times, times);
		}.bind(this));
	
		this.watcher.watch(files.concat(missing), dirs, startTime);
	
		if(oldWatcher) {
			oldWatcher.close();
		}
		return {
			close: function() {
				this.watcher.close();
			}.bind(this),
			pause: function() {
				this.watcher.pause();
			}.bind(this)
		};
	};


/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var watcherManager = __webpack_require__(214);
	var EventEmitter = __webpack_require__(216).EventEmitter;
	
	function Watchpack(options) {
		EventEmitter.call(this);
		if(!options) options = {};
		if(!options.aggregateTimeout) options.aggregateTimeout = 200;
		this.options = options;
		this.watcherOptions = {
			poll: options.poll
		};
		this.fileWatchers = [];
		this.dirWatchers = [];
		this.mtimes = {};
		this.paused = false;
		this.aggregatedChanges = [];
		this.aggregateTimeout = 0;
		this._onTimeout = this._onTimeout.bind(this);
	}
	
	module.exports = Watchpack;
	
	Watchpack.prototype = Object.create(EventEmitter.prototype);
	
	Watchpack.prototype.watch = function watch(files, directories, startTime) {
		this.paused = false;
		var oldFileWatchers = this.fileWatchers;
		var oldDirWatchers = this.dirWatchers;
		this.fileWatchers = files.map(function(file) {
			return this._fileWatcher(file, watcherManager.watchFile(file, this.watcherOptions, startTime));
		}, this);
		this.dirWatchers = directories.map(function(dir) {
			return this._dirWatcher(dir, watcherManager.watchDirectory(dir, this.watcherOptions, startTime));
		}, this);
		oldFileWatchers.forEach(function(w) {
			w.close();
		}, this);
		oldDirWatchers.forEach(function(w) {
			w.close();
		}, this);
	};
	
	Watchpack.prototype.close = function resume() {
		this.paused = true;
		if(this.aggregateTimeout)
			clearTimeout(this.aggregateTimeout);
		this.fileWatchers.forEach(function(w) {
			w.close();
		}, this);
		this.dirWatchers.forEach(function(w) {
			w.close();
		}, this);
		this.fileWatchers.length = 0;
		this.dirWatchers.length = 0;
	};
	
	Watchpack.prototype.pause = function pause() {
		this.paused = true;
		if(this.aggregateTimeout)
			clearTimeout(this.aggregateTimeout);
	};
	
	function addWatchersToArray(watchers, array) {
		watchers.forEach(function(w) {
			if(array.indexOf(w.directoryWatcher) < 0) {
				array.push(w.directoryWatcher);
				addWatchersToArray(Object.keys(w.directoryWatcher.directories).reduce(function(a, dir) {
					if(w.directoryWatcher.directories[dir] !== true)
						a.push(w.directoryWatcher.directories[dir]);
					return a;
				}, []), array);
			}
		});
	}
	
	Watchpack.prototype.getTimes = function() {
		var directoryWatchers = [];
		addWatchersToArray(this.fileWatchers.concat(this.dirWatchers), directoryWatchers);
		var obj = {};
		directoryWatchers.forEach(function(w) {
			var times = w.getTimes();
			Object.keys(times).forEach(function(file) {
				obj[file] = times[file];
			});
		});
		return obj;
	};
	
	Watchpack.prototype._fileWatcher = function _fileWatcher(file, watcher) {
		watcher.on("change", this._onChange.bind(this, file));
		return watcher;
	};
	
	Watchpack.prototype._dirWatcher = function _dirWatcher(item, watcher) {
		watcher.on("change", function(file, mtime) {
			this._onChange(item, mtime, file);
		}.bind(this));
		return watcher;
	};
	
	Watchpack.prototype._onChange = function _onChange(item, mtime, file) {
		file = file || item;
		this.mtimes[file] = mtime;
		if(this.paused) return;
		this.emit("change", file, mtime);
		if(this.aggregateTimeout)
			clearTimeout(this.aggregateTimeout);
		if(this.aggregatedChanges.indexOf(item) < 0)
			this.aggregatedChanges.push(item);
		this.aggregateTimeout = setTimeout(this._onTimeout, this.options.aggregateTimeout);
	};
	
	Watchpack.prototype._onTimeout = function _onTimeout() {
		this.aggregateTimeout = 0;
		var changes = this.aggregatedChanges;
		this.aggregatedChanges = [];
		this.emit("aggregated", changes);
	};


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var path = __webpack_require__(4);
	
	function WatcherManager() {
		this.directoryWatchers = {};
	}
	
	WatcherManager.prototype.getDirectoryWatcher = function(directory, options) {
		var DirectoryWatcher = __webpack_require__(215);
		options = options || {};
		var key = directory + " " + JSON.stringify(options);
		if(!this.directoryWatchers[key]) {
			this.directoryWatchers[key] = new DirectoryWatcher(directory, options);
			this.directoryWatchers[key].on("closed", function() {
				delete this.directoryWatchers[key];
			}.bind(this));
		}
		return this.directoryWatchers[key];
	};
	
	WatcherManager.prototype.watchFile = function watchFile(p, options, startTime) {
		var directory = path.dirname(p);
		return this.getDirectoryWatcher(directory, options).watch(p, startTime);
	};
	
	WatcherManager.prototype.watchDirectory = function watchDirectory(directory, options, startTime) {
		return this.getDirectoryWatcher(directory, options).watch(directory, startTime);
	};
	
	module.exports = new WatcherManager();


/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var EventEmitter = __webpack_require__(216).EventEmitter;
	var async = __webpack_require__(217);
	var chokidar = __webpack_require__(218);
	var fs = __webpack_require__(264);
	var path = __webpack_require__(4);
	
	var watcherManager = __webpack_require__(214);
	
	var FS_ACCURENCY = 10000;
	
	
	function withoutCase(str) {
		return str.toLowerCase();
	}
	
	
	function Watcher(directoryWatcher, filePath, startTime) {
		EventEmitter.call(this);
		this.directoryWatcher = directoryWatcher;
		this.path = filePath;
		this.startTime = startTime && +startTime;
		this.data = 0;
	}
	
	Watcher.prototype = Object.create(EventEmitter.prototype);
	Watcher.prototype.constructor = Watcher;
	
	Watcher.prototype.checkStartTime = function checkStartTime(mtime, initial) {
		if(typeof this.startTime !== "number") return !initial;
		var startTime = this.startTime && Math.floor(this.startTime / FS_ACCURENCY) * FS_ACCURENCY;
		return startTime <= mtime;
	};
	
	Watcher.prototype.close = function close() {
		this.emit("closed");
	};
	
	
	function DirectoryWatcher(directoryPath, options) {
		EventEmitter.call(this);
		this.path = directoryPath;
		this.files = {};
		this.directories = {};
		this.watcher = chokidar.watch(directoryPath, {
			ignoreInitial: true,
			persistent: true,
			followSymlinks: false,
			depth: 0,
			atomic: false,
			alwaysStat: true,
			ignorePermissionErrors: true,
			usePolling: options.poll ? true : undefined,
			interval: typeof options.poll === "number" ? options.poll : undefined
		});
		this.watcher.on("add", this.onFileAdded.bind(this));
		this.watcher.on("addDir", this.onDirectoryAdded.bind(this));
		this.watcher.on("change", this.onChange.bind(this));
		this.watcher.on("unlink", this.onFileUnlinked.bind(this));
		this.watcher.on("unlinkDir", this.onDirectoryUnlinked.bind(this));
		this.watcher.on("error", this.onWatcherError.bind(this));
		this.initialScan = true;
		this.nestedWatching = false;
		this.initialScanRemoved = [];
		this.doInitialScan();
		this.watchers = {};
		this.refs = 0;
	}
	module.exports = DirectoryWatcher;
	
	DirectoryWatcher.prototype = Object.create(EventEmitter.prototype);
	DirectoryWatcher.prototype.constructor = DirectoryWatcher;
	
	DirectoryWatcher.prototype.setFileTime = function setFileTime(filePath, mtime, initial, type) {
		var now = Date.now();
		var old = this.files[filePath];
		this.files[filePath] = [initial ? Math.min(now, mtime) : now, mtime];
		if(!old) {
			if(mtime) {
				if(this.watchers[withoutCase(filePath)]) {
					this.watchers[withoutCase(filePath)].forEach(function(w) {
						if(!initial || w.checkStartTime(mtime, initial)) {
							w.emit("change", mtime);
						}
					});
				}
			}
		} else if(!initial && mtime && type !== "add") {
			if(this.watchers[withoutCase(filePath)]) {
				this.watchers[withoutCase(filePath)].forEach(function(w) {
					w.emit("change", mtime);
				});
			}
		} else if(!initial && !mtime) {
			if(this.watchers[withoutCase(filePath)]) {
				this.watchers[withoutCase(filePath)].forEach(function(w) {
					w.emit("remove");
				});
			}
		}
		if(this.watchers[withoutCase(this.path)]) {
			this.watchers[withoutCase(this.path)].forEach(function(w) {
				if(!initial || w.checkStartTime(mtime, initial)) {
					w.emit("change", filePath, mtime);
				}
			});
		}
	};
	
	DirectoryWatcher.prototype.setDirectory = function setDirectory(directoryPath, exist, initial) {
		var old = this.directories[directoryPath];
		if(!old) {
			if(exist) {
				if(this.nestedWatching) {
					this.createNestedWatcher(directoryPath);
				} else {
					this.directories[directoryPath] = true;
				}
			}
		} else {
			if(!exist) {
				if(this.nestedWatching)
					this.directories[directoryPath].close();
				delete this.directories[directoryPath];
				if(!initial && this.watchers[withoutCase(this.path)]) {
					this.watchers[withoutCase(this.path)].forEach(function(w) {
						w.emit("change", directoryPath, w.data);
					});
				}
			}
		}
	};
	
	DirectoryWatcher.prototype.createNestedWatcher = function(directoryPath) {
		this.directories[directoryPath] = watcherManager.watchDirectory(directoryPath, this.options, 1);
		this.directories[directoryPath].on("change", function(filePath, mtime) {
			if(this.watchers[withoutCase(this.path)]) {
				this.watchers[withoutCase(this.path)].forEach(function(w) {
					if(w.checkStartTime(mtime, false)) {
						w.emit("change", filePath, mtime);
					}
				});
			}
		}.bind(this));
	};
	
	DirectoryWatcher.prototype.setNestedWatching = function(flag) {
		if(this.nestedWatching !== !!flag) {
			this.nestedWatching = !!flag;
			if(this.nestedWatching) {
				Object.keys(this.directories).forEach(function(directory) {
					this.createNestedWatcher(directory);
				}, this);
			} else {
				Object.keys(this.directories).forEach(function(directory) {
					this.directories[directory].close();
					this.directories[directory] = true;
				}, this);
			}
		}
	};
	
	DirectoryWatcher.prototype.watch = function watch(filePath, startTime) {
		this.watchers[withoutCase(filePath)] = this.watchers[withoutCase(filePath)] || [];
		this.refs++;
		var watcher = new Watcher(this, filePath, startTime);
		watcher.on("closed", function() {
			var idx = this.watchers[withoutCase(filePath)].indexOf(watcher);
			this.watchers[withoutCase(filePath)].splice(idx, 1);
			if(this.watchers[withoutCase(filePath)].length === 0) {
				delete this.watchers[withoutCase(filePath)];
				if(this.path === filePath)
					this.setNestedWatching(false);
			}
			if(--this.refs <= 0)
				this.close();
		}.bind(this));
		this.watchers[withoutCase(filePath)].push(watcher);
		var data;
		if(filePath === this.path) {
			this.setNestedWatching(true);
			data = false;
			Object.keys(this.files).forEach(function(file) {
				var d = this.files[file];
				if(!data)
					data = d;
				else
					data = [Math.max(data[0], d[0]), Math.max(data[1], d[1])];
			}, this);
		} else {
			data = this.files[filePath];
		}
		process.nextTick(function() {
			if(data) {
				if(data[0] > startTime)
					watcher.emit("change", data[1]);
			} else if(this.initialScan && this.initialScanRemoved.indexOf(filePath) >= 0) {
				watcher.emit("remove");
			}
		}.bind(this));
		return watcher;
	};
	
	DirectoryWatcher.prototype.onFileAdded = function onFileAdded(filePath, stat) {
		if(filePath.indexOf(this.path) !== 0) return;
		if(/[\\\/]/.test(filePath.substr(this.path.length + 1))) return;
	
		this.setFileTime(filePath, +stat.mtime, false, "add");
	};
	
	DirectoryWatcher.prototype.onDirectoryAdded = function onDirectoryAdded(directoryPath /*, stat */) {
		if(directoryPath.indexOf(this.path) !== 0) return;
		if(/[\\\/]/.test(directoryPath.substr(this.path.length + 1))) return;
		this.setDirectory(directoryPath, true, false);
	};
	
	DirectoryWatcher.prototype.onChange = function onChange(filePath, stat) {
		if(filePath.indexOf(this.path) !== 0) return;
		if(/[\\\/]/.test(filePath.substr(this.path.length + 1))) return;
		var mtime = +stat.mtime;
		if(FS_ACCURENCY > 1 && mtime % 1 !== 0)
			FS_ACCURENCY = 1;
		else if(FS_ACCURENCY > 10 && mtime % 10 !== 0)
			FS_ACCURENCY = 10;
		else if(FS_ACCURENCY > 100 && mtime % 100 !== 0)
			FS_ACCURENCY = 100;
		else if(FS_ACCURENCY > 1000 && mtime % 1000 !== 0)
			FS_ACCURENCY = 1000;
		else if(FS_ACCURENCY > 2000 && mtime % 2000 !== 0)
			FS_ACCURENCY = 2000;
		this.setFileTime(filePath, mtime, false, "change");
	};
	
	DirectoryWatcher.prototype.onFileUnlinked = function onFileUnlinked(filePath) {
		if(filePath.indexOf(this.path) !== 0) return;
		if(/[\\\/]/.test(filePath.substr(this.path.length + 1))) return;
		this.setFileTime(filePath, null, false, "unlink");
		if(this.initialScan) {
			this.initialScanRemoved.push(filePath);
		}
	};
	
	DirectoryWatcher.prototype.onDirectoryUnlinked = function onDirectoryUnlinked(directoryPath) {
		if(directoryPath.indexOf(this.path) !== 0) return;
		if(/[\\\/]/.test(directoryPath.substr(this.path.length + 1))) return;
		this.setDirectory(directoryPath, false, false);
		if(this.initialScan) {
			this.initialScanRemoved.push(directoryPath);
		}
	};
	
	DirectoryWatcher.prototype.onWatcherError = function onWatcherError(/* err */) {
	};
	
	DirectoryWatcher.prototype.doInitialScan = function doInitialScan() {
		fs.readdir(this.path, function(err, items) {
			if(err) {
				this.initialScan = false;
				return;
			}
			async.forEach(items, function(item, callback) {
				var itemPath = path.join(this.path, item);
				fs.stat(itemPath, function(err2, stat) {
					if(!this.initialScan) return;
					if(err2) {
						callback();
						return;
					}
					if(stat.isFile()) {
						if(!this.files[itemPath])
							this.setFileTime(itemPath, +stat.mtime, true);
					} else if(stat.isDirectory()) {
						if(!this.directories[itemPath])
							this.setDirectory(itemPath, true, true);
					}
					callback();
				}.bind(this));
			}.bind(this), function() {
				this.initialScan = false;
				this.initialScanRemoved = null;
			}.bind(this));
		}.bind(this));
	};
	
	DirectoryWatcher.prototype.getTimes = function() {
		var obj = {};
		var selfTime = 0;
		Object.keys(this.files).forEach(function(file) {
			var data = this.files[file];
			if(data[1]) {
				var time = Math.max(data[0], data[1]);
				obj[file] = time;
				if(time > selfTime)
					selfTime = time;
			}
		}, this);
		if(this.nestedWatching) {
			Object.keys(this.directories).forEach(function(dir) {
				var w = this.directories[dir];
				var times = w.directoryWatcher.getTimes();
				Object.keys(times).forEach(function(file) {
					var time = times[file];
					obj[file] = time;
					if(time > selfTime)
						selfTime = time;
				});
			}, this);
			obj[this.path] = selfTime;
		}
		return obj;
	};
	
	DirectoryWatcher.prototype.close = function() {
		this.initialScan = false;
		this.watcher.close();
		if(this.nestedWatching) {
			Object.keys(this.directories).forEach(function(dir) {
				this.directories[dir].close();
			}, this);
		}
		this.emit("closed");
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 216 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process, setImmediate) {/*!
	 * async
	 * https://github.com/caolan/async
	 *
	 * Copyright 2010-2014 Caolan McMahon
	 * Released under the MIT license
	 */
	/*jshint onevar: false, indent:4 */
	/*global setImmediate: false, setTimeout: false, console: false */
	(function () {
	
	    var async = {};
	
	    // global on the server, window in the browser
	    var root, previous_async;
	
	    root = this;
	    if (root != null) {
	      previous_async = root.async;
	    }
	
	    async.noConflict = function () {
	        root.async = previous_async;
	        return async;
	    };
	
	    function only_once(fn) {
	        var called = false;
	        return function() {
	            if (called) throw new Error("Callback was already called.");
	            called = true;
	            fn.apply(root, arguments);
	        }
	    }
	
	    //// cross-browser compatiblity functions ////
	
	    var _toString = Object.prototype.toString;
	
	    var _isArray = Array.isArray || function (obj) {
	        return _toString.call(obj) === '[object Array]';
	    };
	
	    var _each = function (arr, iterator) {
	        for (var i = 0; i < arr.length; i += 1) {
	            iterator(arr[i], i, arr);
	        }
	    };
	
	    var _map = function (arr, iterator) {
	        if (arr.map) {
	            return arr.map(iterator);
	        }
	        var results = [];
	        _each(arr, function (x, i, a) {
	            results.push(iterator(x, i, a));
	        });
	        return results;
	    };
	
	    var _reduce = function (arr, iterator, memo) {
	        if (arr.reduce) {
	            return arr.reduce(iterator, memo);
	        }
	        _each(arr, function (x, i, a) {
	            memo = iterator(memo, x, i, a);
	        });
	        return memo;
	    };
	
	    var _keys = function (obj) {
	        if (Object.keys) {
	            return Object.keys(obj);
	        }
	        var keys = [];
	        for (var k in obj) {
	            if (obj.hasOwnProperty(k)) {
	                keys.push(k);
	            }
	        }
	        return keys;
	    };
	
	    //// exported async module functions ////
	
	    //// nextTick implementation with browser-compatible fallback ////
	    if (typeof process === 'undefined' || !(process.nextTick)) {
	        if (typeof setImmediate === 'function') {
	            async.nextTick = function (fn) {
	                // not a direct alias for IE10 compatibility
	                setImmediate(fn);
	            };
	            async.setImmediate = async.nextTick;
	        }
	        else {
	            async.nextTick = function (fn) {
	                setTimeout(fn, 0);
	            };
	            async.setImmediate = async.nextTick;
	        }
	    }
	    else {
	        async.nextTick = process.nextTick;
	        if (typeof setImmediate !== 'undefined') {
	            async.setImmediate = function (fn) {
	              // not a direct alias for IE10 compatibility
	              setImmediate(fn);
	            };
	        }
	        else {
	            async.setImmediate = async.nextTick;
	        }
	    }
	
	    async.each = function (arr, iterator, callback) {
	        callback = callback || function () {};
	        if (!arr.length) {
	            return callback();
	        }
	        var completed = 0;
	        _each(arr, function (x) {
	            iterator(x, only_once(done) );
	        });
	        function done(err) {
	          if (err) {
	              callback(err);
	              callback = function () {};
	          }
	          else {
	              completed += 1;
	              if (completed >= arr.length) {
	                  callback();
	              }
	          }
	        }
	    };
	    async.forEach = async.each;
	
	    async.eachSeries = function (arr, iterator, callback) {
	        callback = callback || function () {};
	        if (!arr.length) {
	            return callback();
	        }
	        var completed = 0;
	        var iterate = function () {
	            iterator(arr[completed], function (err) {
	                if (err) {
	                    callback(err);
	                    callback = function () {};
	                }
	                else {
	                    completed += 1;
	                    if (completed >= arr.length) {
	                        callback();
	                    }
	                    else {
	                        iterate();
	                    }
	                }
	            });
	        };
	        iterate();
	    };
	    async.forEachSeries = async.eachSeries;
	
	    async.eachLimit = function (arr, limit, iterator, callback) {
	        var fn = _eachLimit(limit);
	        fn.apply(null, [arr, iterator, callback]);
	    };
	    async.forEachLimit = async.eachLimit;
	
	    var _eachLimit = function (limit) {
	
	        return function (arr, iterator, callback) {
	            callback = callback || function () {};
	            if (!arr.length || limit <= 0) {
	                return callback();
	            }
	            var completed = 0;
	            var started = 0;
	            var running = 0;
	
	            (function replenish () {
	                if (completed >= arr.length) {
	                    return callback();
	                }
	
	                while (running < limit && started < arr.length) {
	                    started += 1;
	                    running += 1;
	                    iterator(arr[started - 1], function (err) {
	                        if (err) {
	                            callback(err);
	                            callback = function () {};
	                        }
	                        else {
	                            completed += 1;
	                            running -= 1;
	                            if (completed >= arr.length) {
	                                callback();
	                            }
	                            else {
	                                replenish();
	                            }
	                        }
	                    });
	                }
	            })();
	        };
	    };
	
	
	    var doParallel = function (fn) {
	        return function () {
	            var args = Array.prototype.slice.call(arguments);
	            return fn.apply(null, [async.each].concat(args));
	        };
	    };
	    var doParallelLimit = function(limit, fn) {
	        return function () {
	            var args = Array.prototype.slice.call(arguments);
	            return fn.apply(null, [_eachLimit(limit)].concat(args));
	        };
	    };
	    var doSeries = function (fn) {
	        return function () {
	            var args = Array.prototype.slice.call(arguments);
	            return fn.apply(null, [async.eachSeries].concat(args));
	        };
	    };
	
	
	    var _asyncMap = function (eachfn, arr, iterator, callback) {
	        arr = _map(arr, function (x, i) {
	            return {index: i, value: x};
	        });
	        if (!callback) {
	            eachfn(arr, function (x, callback) {
	                iterator(x.value, function (err) {
	                    callback(err);
	                });
	            });
	        } else {
	            var results = [];
	            eachfn(arr, function (x, callback) {
	                iterator(x.value, function (err, v) {
	                    results[x.index] = v;
	                    callback(err);
	                });
	            }, function (err) {
	                callback(err, results);
	            });
	        }
	    };
	    async.map = doParallel(_asyncMap);
	    async.mapSeries = doSeries(_asyncMap);
	    async.mapLimit = function (arr, limit, iterator, callback) {
	        return _mapLimit(limit)(arr, iterator, callback);
	    };
	
	    var _mapLimit = function(limit) {
	        return doParallelLimit(limit, _asyncMap);
	    };
	
	    // reduce only has a series version, as doing reduce in parallel won't
	    // work in many situations.
	    async.reduce = function (arr, memo, iterator, callback) {
	        async.eachSeries(arr, function (x, callback) {
	            iterator(memo, x, function (err, v) {
	                memo = v;
	                callback(err);
	            });
	        }, function (err) {
	            callback(err, memo);
	        });
	    };
	    // inject alias
	    async.inject = async.reduce;
	    // foldl alias
	    async.foldl = async.reduce;
	
	    async.reduceRight = function (arr, memo, iterator, callback) {
	        var reversed = _map(arr, function (x) {
	            return x;
	        }).reverse();
	        async.reduce(reversed, memo, iterator, callback);
	    };
	    // foldr alias
	    async.foldr = async.reduceRight;
	
	    var _filter = function (eachfn, arr, iterator, callback) {
	        var results = [];
	        arr = _map(arr, function (x, i) {
	            return {index: i, value: x};
	        });
	        eachfn(arr, function (x, callback) {
	            iterator(x.value, function (v) {
	                if (v) {
	                    results.push(x);
	                }
	                callback();
	            });
	        }, function (err) {
	            callback(_map(results.sort(function (a, b) {
	                return a.index - b.index;
	            }), function (x) {
	                return x.value;
	            }));
	        });
	    };
	    async.filter = doParallel(_filter);
	    async.filterSeries = doSeries(_filter);
	    // select alias
	    async.select = async.filter;
	    async.selectSeries = async.filterSeries;
	
	    var _reject = function (eachfn, arr, iterator, callback) {
	        var results = [];
	        arr = _map(arr, function (x, i) {
	            return {index: i, value: x};
	        });
	        eachfn(arr, function (x, callback) {
	            iterator(x.value, function (v) {
	                if (!v) {
	                    results.push(x);
	                }
	                callback();
	            });
	        }, function (err) {
	            callback(_map(results.sort(function (a, b) {
	                return a.index - b.index;
	            }), function (x) {
	                return x.value;
	            }));
	        });
	    };
	    async.reject = doParallel(_reject);
	    async.rejectSeries = doSeries(_reject);
	
	    var _detect = function (eachfn, arr, iterator, main_callback) {
	        eachfn(arr, function (x, callback) {
	            iterator(x, function (result) {
	                if (result) {
	                    main_callback(x);
	                    main_callback = function () {};
	                }
	                else {
	                    callback();
	                }
	            });
	        }, function (err) {
	            main_callback();
	        });
	    };
	    async.detect = doParallel(_detect);
	    async.detectSeries = doSeries(_detect);
	
	    async.some = function (arr, iterator, main_callback) {
	        async.each(arr, function (x, callback) {
	            iterator(x, function (v) {
	                if (v) {
	                    main_callback(true);
	                    main_callback = function () {};
	                }
	                callback();
	            });
	        }, function (err) {
	            main_callback(false);
	        });
	    };
	    // any alias
	    async.any = async.some;
	
	    async.every = function (arr, iterator, main_callback) {
	        async.each(arr, function (x, callback) {
	            iterator(x, function (v) {
	                if (!v) {
	                    main_callback(false);
	                    main_callback = function () {};
	                }
	                callback();
	            });
	        }, function (err) {
	            main_callback(true);
	        });
	    };
	    // all alias
	    async.all = async.every;
	
	    async.sortBy = function (arr, iterator, callback) {
	        async.map(arr, function (x, callback) {
	            iterator(x, function (err, criteria) {
	                if (err) {
	                    callback(err);
	                }
	                else {
	                    callback(null, {value: x, criteria: criteria});
	                }
	            });
	        }, function (err, results) {
	            if (err) {
	                return callback(err);
	            }
	            else {
	                var fn = function (left, right) {
	                    var a = left.criteria, b = right.criteria;
	                    return a < b ? -1 : a > b ? 1 : 0;
	                };
	                callback(null, _map(results.sort(fn), function (x) {
	                    return x.value;
	                }));
	            }
	        });
	    };
	
	    async.auto = function (tasks, callback) {
	        callback = callback || function () {};
	        var keys = _keys(tasks);
	        var remainingTasks = keys.length
	        if (!remainingTasks) {
	            return callback();
	        }
	
	        var results = {};
	
	        var listeners = [];
	        var addListener = function (fn) {
	            listeners.unshift(fn);
	        };
	        var removeListener = function (fn) {
	            for (var i = 0; i < listeners.length; i += 1) {
	                if (listeners[i] === fn) {
	                    listeners.splice(i, 1);
	                    return;
	                }
	            }
	        };
	        var taskComplete = function () {
	            remainingTasks--
	            _each(listeners.slice(0), function (fn) {
	                fn();
	            });
	        };
	
	        addListener(function () {
	            if (!remainingTasks) {
	                var theCallback = callback;
	                // prevent final callback from calling itself if it errors
	                callback = function () {};
	
	                theCallback(null, results);
	            }
	        });
	
	        _each(keys, function (k) {
	            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
	            var taskCallback = function (err) {
	                var args = Array.prototype.slice.call(arguments, 1);
	                if (args.length <= 1) {
	                    args = args[0];
	                }
	                if (err) {
	                    var safeResults = {};
	                    _each(_keys(results), function(rkey) {
	                        safeResults[rkey] = results[rkey];
	                    });
	                    safeResults[k] = args;
	                    callback(err, safeResults);
	                    // stop subsequent errors hitting callback multiple times
	                    callback = function () {};
	                }
	                else {
	                    results[k] = args;
	                    async.setImmediate(taskComplete);
	                }
	            };
	            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
	            var ready = function () {
	                return _reduce(requires, function (a, x) {
	                    return (a && results.hasOwnProperty(x));
	                }, true) && !results.hasOwnProperty(k);
	            };
	            if (ready()) {
	                task[task.length - 1](taskCallback, results);
	            }
	            else {
	                var listener = function () {
	                    if (ready()) {
	                        removeListener(listener);
	                        task[task.length - 1](taskCallback, results);
	                    }
	                };
	                addListener(listener);
	            }
	        });
	    };
	
	    async.retry = function(times, task, callback) {
	        var DEFAULT_TIMES = 5;
	        var attempts = [];
	        // Use defaults if times not passed
	        if (typeof times === 'function') {
	            callback = task;
	            task = times;
	            times = DEFAULT_TIMES;
	        }
	        // Make sure times is a number
	        times = parseInt(times, 10) || DEFAULT_TIMES;
	        var wrappedTask = function(wrappedCallback, wrappedResults) {
	            var retryAttempt = function(task, finalAttempt) {
	                return function(seriesCallback) {
	                    task(function(err, result){
	                        seriesCallback(!err || finalAttempt, {err: err, result: result});
	                    }, wrappedResults);
	                };
	            };
	            while (times) {
	                attempts.push(retryAttempt(task, !(times-=1)));
	            }
	            async.series(attempts, function(done, data){
	                data = data[data.length - 1];
	                (wrappedCallback || callback)(data.err, data.result);
	            });
	        }
	        // If a callback is passed, run this as a controll flow
	        return callback ? wrappedTask() : wrappedTask
	    };
	
	    async.waterfall = function (tasks, callback) {
	        callback = callback || function () {};
	        if (!_isArray(tasks)) {
	          var err = new Error('First argument to waterfall must be an array of functions');
	          return callback(err);
	        }
	        if (!tasks.length) {
	            return callback();
	        }
	        var wrapIterator = function (iterator) {
	            return function (err) {
	                if (err) {
	                    callback.apply(null, arguments);
	                    callback = function () {};
	                }
	                else {
	                    var args = Array.prototype.slice.call(arguments, 1);
	                    var next = iterator.next();
	                    if (next) {
	                        args.push(wrapIterator(next));
	                    }
	                    else {
	                        args.push(callback);
	                    }
	                    async.setImmediate(function () {
	                        iterator.apply(null, args);
	                    });
	                }
	            };
	        };
	        wrapIterator(async.iterator(tasks))();
	    };
	
	    var _parallel = function(eachfn, tasks, callback) {
	        callback = callback || function () {};
	        if (_isArray(tasks)) {
	            eachfn.map(tasks, function (fn, callback) {
	                if (fn) {
	                    fn(function (err) {
	                        var args = Array.prototype.slice.call(arguments, 1);
	                        if (args.length <= 1) {
	                            args = args[0];
	                        }
	                        callback.call(null, err, args);
	                    });
	                }
	            }, callback);
	        }
	        else {
	            var results = {};
	            eachfn.each(_keys(tasks), function (k, callback) {
	                tasks[k](function (err) {
	                    var args = Array.prototype.slice.call(arguments, 1);
	                    if (args.length <= 1) {
	                        args = args[0];
	                    }
	                    results[k] = args;
	                    callback(err);
	                });
	            }, function (err) {
	                callback(err, results);
	            });
	        }
	    };
	
	    async.parallel = function (tasks, callback) {
	        _parallel({ map: async.map, each: async.each }, tasks, callback);
	    };
	
	    async.parallelLimit = function(tasks, limit, callback) {
	        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
	    };
	
	    async.series = function (tasks, callback) {
	        callback = callback || function () {};
	        if (_isArray(tasks)) {
	            async.mapSeries(tasks, function (fn, callback) {
	                if (fn) {
	                    fn(function (err) {
	                        var args = Array.prototype.slice.call(arguments, 1);
	                        if (args.length <= 1) {
	                            args = args[0];
	                        }
	                        callback.call(null, err, args);
	                    });
	                }
	            }, callback);
	        }
	        else {
	            var results = {};
	            async.eachSeries(_keys(tasks), function (k, callback) {
	                tasks[k](function (err) {
	                    var args = Array.prototype.slice.call(arguments, 1);
	                    if (args.length <= 1) {
	                        args = args[0];
	                    }
	                    results[k] = args;
	                    callback(err);
	                });
	            }, function (err) {
	                callback(err, results);
	            });
	        }
	    };
	
	    async.iterator = function (tasks) {
	        var makeCallback = function (index) {
	            var fn = function () {
	                if (tasks.length) {
	                    tasks[index].apply(null, arguments);
	                }
	                return fn.next();
	            };
	            fn.next = function () {
	                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
	            };
	            return fn;
	        };
	        return makeCallback(0);
	    };
	
	    async.apply = function (fn) {
	        var args = Array.prototype.slice.call(arguments, 1);
	        return function () {
	            return fn.apply(
	                null, args.concat(Array.prototype.slice.call(arguments))
	            );
	        };
	    };
	
	    var _concat = function (eachfn, arr, fn, callback) {
	        var r = [];
	        eachfn(arr, function (x, cb) {
	            fn(x, function (err, y) {
	                r = r.concat(y || []);
	                cb(err);
	            });
	        }, function (err) {
	            callback(err, r);
	        });
	    };
	    async.concat = doParallel(_concat);
	    async.concatSeries = doSeries(_concat);
	
	    async.whilst = function (test, iterator, callback) {
	        if (test()) {
	            iterator(function (err) {
	                if (err) {
	                    return callback(err);
	                }
	                async.whilst(test, iterator, callback);
	            });
	        }
	        else {
	            callback();
	        }
	    };
	
	    async.doWhilst = function (iterator, test, callback) {
	        iterator(function (err) {
	            if (err) {
	                return callback(err);
	            }
	            var args = Array.prototype.slice.call(arguments, 1);
	            if (test.apply(null, args)) {
	                async.doWhilst(iterator, test, callback);
	            }
	            else {
	                callback();
	            }
	        });
	    };
	
	    async.until = function (test, iterator, callback) {
	        if (!test()) {
	            iterator(function (err) {
	                if (err) {
	                    return callback(err);
	                }
	                async.until(test, iterator, callback);
	            });
	        }
	        else {
	            callback();
	        }
	    };
	
	    async.doUntil = function (iterator, test, callback) {
	        iterator(function (err) {
	            if (err) {
	                return callback(err);
	            }
	            var args = Array.prototype.slice.call(arguments, 1);
	            if (!test.apply(null, args)) {
	                async.doUntil(iterator, test, callback);
	            }
	            else {
	                callback();
	            }
	        });
	    };
	
	    async.queue = function (worker, concurrency) {
	        if (concurrency === undefined) {
	            concurrency = 1;
	        }
	        function _insert(q, data, pos, callback) {
	          if (!q.started){
	            q.started = true;
	          }
	          if (!_isArray(data)) {
	              data = [data];
	          }
	          if(data.length == 0) {
	             // call drain immediately if there are no tasks
	             return async.setImmediate(function() {
	                 if (q.drain) {
	                     q.drain();
	                 }
	             });
	          }
	          _each(data, function(task) {
	              var item = {
	                  data: task,
	                  callback: typeof callback === 'function' ? callback : null
	              };
	
	              if (pos) {
	                q.tasks.unshift(item);
	              } else {
	                q.tasks.push(item);
	              }
	
	              if (q.saturated && q.tasks.length === q.concurrency) {
	                  q.saturated();
	              }
	              async.setImmediate(q.process);
	          });
	        }
	
	        var workers = 0;
	        var q = {
	            tasks: [],
	            concurrency: concurrency,
	            saturated: null,
	            empty: null,
	            drain: null,
	            started: false,
	            paused: false,
	            push: function (data, callback) {
	              _insert(q, data, false, callback);
	            },
	            kill: function () {
	              q.drain = null;
	              q.tasks = [];
	            },
	            unshift: function (data, callback) {
	              _insert(q, data, true, callback);
	            },
	            process: function () {
	                if (!q.paused && workers < q.concurrency && q.tasks.length) {
	                    var task = q.tasks.shift();
	                    if (q.empty && q.tasks.length === 0) {
	                        q.empty();
	                    }
	                    workers += 1;
	                    var next = function () {
	                        workers -= 1;
	                        if (task.callback) {
	                            task.callback.apply(task, arguments);
	                        }
	                        if (q.drain && q.tasks.length + workers === 0) {
	                            q.drain();
	                        }
	                        q.process();
	                    };
	                    var cb = only_once(next);
	                    worker(task.data, cb);
	                }
	            },
	            length: function () {
	                return q.tasks.length;
	            },
	            running: function () {
	                return workers;
	            },
	            idle: function() {
	                return q.tasks.length + workers === 0;
	            },
	            pause: function () {
	                if (q.paused === true) { return; }
	                q.paused = true;
	            },
	            resume: function () {
	                if (q.paused === false) { return; }
	                q.paused = false;
	                // Need to call q.process once per concurrent
	                // worker to preserve full concurrency after pause
	                for (var w = 1; w <= q.concurrency; w++) {
	                    async.setImmediate(q.process);
	                }
	            }
	        };
	        return q;
	    };
	
	    async.priorityQueue = function (worker, concurrency) {
	
	        function _compareTasks(a, b){
	          return a.priority - b.priority;
	        };
	
	        function _binarySearch(sequence, item, compare) {
	          var beg = -1,
	              end = sequence.length - 1;
	          while (beg < end) {
	            var mid = beg + ((end - beg + 1) >>> 1);
	            if (compare(item, sequence[mid]) >= 0) {
	              beg = mid;
	            } else {
	              end = mid - 1;
	            }
	          }
	          return beg;
	        }
	
	        function _insert(q, data, priority, callback) {
	          if (!q.started){
	            q.started = true;
	          }
	          if (!_isArray(data)) {
	              data = [data];
	          }
	          if(data.length == 0) {
	             // call drain immediately if there are no tasks
	             return async.setImmediate(function() {
	                 if (q.drain) {
	                     q.drain();
	                 }
	             });
	          }
	          _each(data, function(task) {
	              var item = {
	                  data: task,
	                  priority: priority,
	                  callback: typeof callback === 'function' ? callback : null
	              };
	
	              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);
	
	              if (q.saturated && q.tasks.length === q.concurrency) {
	                  q.saturated();
	              }
	              async.setImmediate(q.process);
	          });
	        }
	
	        // Start with a normal queue
	        var q = async.queue(worker, concurrency);
	
	        // Override push to accept second parameter representing priority
	        q.push = function (data, priority, callback) {
	          _insert(q, data, priority, callback);
	        };
	
	        // Remove unshift function
	        delete q.unshift;
	
	        return q;
	    };
	
	    async.cargo = function (worker, payload) {
	        var working     = false,
	            tasks       = [];
	
	        var cargo = {
	            tasks: tasks,
	            payload: payload,
	            saturated: null,
	            empty: null,
	            drain: null,
	            drained: true,
	            push: function (data, callback) {
	                if (!_isArray(data)) {
	                    data = [data];
	                }
	                _each(data, function(task) {
	                    tasks.push({
	                        data: task,
	                        callback: typeof callback === 'function' ? callback : null
	                    });
	                    cargo.drained = false;
	                    if (cargo.saturated && tasks.length === payload) {
	                        cargo.saturated();
	                    }
	                });
	                async.setImmediate(cargo.process);
	            },
	            process: function process() {
	                if (working) return;
	                if (tasks.length === 0) {
	                    if(cargo.drain && !cargo.drained) cargo.drain();
	                    cargo.drained = true;
	                    return;
	                }
	
	                var ts = typeof payload === 'number'
	                            ? tasks.splice(0, payload)
	                            : tasks.splice(0, tasks.length);
	
	                var ds = _map(ts, function (task) {
	                    return task.data;
	                });
	
	                if(cargo.empty) cargo.empty();
	                working = true;
	                worker(ds, function () {
	                    working = false;
	
	                    var args = arguments;
	                    _each(ts, function (data) {
	                        if (data.callback) {
	                            data.callback.apply(null, args);
	                        }
	                    });
	
	                    process();
	                });
	            },
	            length: function () {
	                return tasks.length;
	            },
	            running: function () {
	                return working;
	            }
	        };
	        return cargo;
	    };
	
	    var _console_fn = function (name) {
	        return function (fn) {
	            var args = Array.prototype.slice.call(arguments, 1);
	            fn.apply(null, args.concat([function (err) {
	                var args = Array.prototype.slice.call(arguments, 1);
	                if (typeof console !== 'undefined') {
	                    if (err) {
	                        if (console.error) {
	                            console.error(err);
	                        }
	                    }
	                    else if (console[name]) {
	                        _each(args, function (x) {
	                            console[name](x);
	                        });
	                    }
	                }
	            }]));
	        };
	    };
	    async.log = _console_fn('log');
	    async.dir = _console_fn('dir');
	    /*async.info = _console_fn('info');
	    async.warn = _console_fn('warn');
	    async.error = _console_fn('error');*/
	
	    async.memoize = function (fn, hasher) {
	        var memo = {};
	        var queues = {};
	        hasher = hasher || function (x) {
	            return x;
	        };
	        var memoized = function () {
	            var args = Array.prototype.slice.call(arguments);
	            var callback = args.pop();
	            var key = hasher.apply(null, args);
	            if (key in memo) {
	                async.nextTick(function () {
	                    callback.apply(null, memo[key]);
	                });
	            }
	            else if (key in queues) {
	                queues[key].push(callback);
	            }
	            else {
	                queues[key] = [callback];
	                fn.apply(null, args.concat([function () {
	                    memo[key] = arguments;
	                    var q = queues[key];
	                    delete queues[key];
	                    for (var i = 0, l = q.length; i < l; i++) {
	                      q[i].apply(null, arguments);
	                    }
	                }]));
	            }
	        };
	        memoized.memo = memo;
	        memoized.unmemoized = fn;
	        return memoized;
	    };
	
	    async.unmemoize = function (fn) {
	      return function () {
	        return (fn.unmemoized || fn).apply(null, arguments);
	      };
	    };
	
	    async.times = function (count, iterator, callback) {
	        var counter = [];
	        for (var i = 0; i < count; i++) {
	            counter.push(i);
	        }
	        return async.map(counter, iterator, callback);
	    };
	
	    async.timesSeries = function (count, iterator, callback) {
	        var counter = [];
	        for (var i = 0; i < count; i++) {
	            counter.push(i);
	        }
	        return async.mapSeries(counter, iterator, callback);
	    };
	
	    async.seq = function (/* functions... */) {
	        var fns = arguments;
	        return function () {
	            var that = this;
	            var args = Array.prototype.slice.call(arguments);
	            var callback = args.pop();
	            async.reduce(fns, args, function (newargs, fn, cb) {
	                fn.apply(that, newargs.concat([function () {
	                    var err = arguments[0];
	                    var nextargs = Array.prototype.slice.call(arguments, 1);
	                    cb(err, nextargs);
	                }]))
	            },
	            function (err, results) {
	                callback.apply(that, [err].concat(results));
	            });
	        };
	    };
	
	    async.compose = function (/* functions... */) {
	      return async.seq.apply(null, Array.prototype.reverse.call(arguments));
	    };
	
	    var _applyEach = function (eachfn, fns /*args...*/) {
	        var go = function () {
	            var that = this;
	            var args = Array.prototype.slice.call(arguments);
	            var callback = args.pop();
	            return eachfn(fns, function (fn, cb) {
	                fn.apply(that, args.concat([cb]));
	            },
	            callback);
	        };
	        if (arguments.length > 2) {
	            var args = Array.prototype.slice.call(arguments, 2);
	            return go.apply(this, args);
	        }
	        else {
	            return go;
	        }
	    };
	    async.applyEach = doParallel(_applyEach);
	    async.applyEachSeries = doSeries(_applyEach);
	
	    async.forever = function (fn, callback) {
	        function next(err) {
	            if (err) {
	                if (callback) {
	                    return callback(err);
	                }
	                throw err;
	            }
	            fn(next);
	        }
	        next();
	    };
	
	    // Node.js
	    if (typeof module !== 'undefined' && module.exports) {
	        module.exports = async;
	    }
	    // AMD / RequireJS
	    else if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return async;
	        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    }
	    // included directly via <script> tag
	    else {
	        root.async = async;
	    }
	
	}());
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(11).setImmediate))

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	var EventEmitter = __webpack_require__(216).EventEmitter;
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var sysPath = __webpack_require__(4);
	var asyncEach = __webpack_require__(219);
	var anymatch = __webpack_require__(220);
	var globParent = __webpack_require__(253);
	var isGlob = __webpack_require__(245);
	var isAbsolute = __webpack_require__(260);
	var inherits = __webpack_require__(261);
	
	var NodeFsHandler = __webpack_require__(262);
	var FsEventsHandler = __webpack_require__(297);
	
	var arrify = function(value) {
	  if (value == null) return [];
	  return Array.isArray(value) ? value : [value];
	};
	
	var flatten = function(list, result) {
	  if (result == null) result = [];
	  list.forEach(function(item) {
	    if (Array.isArray(item)) {
	      flatten(item, result);
	    } else {
	      result.push(item);
	    }
	  });
	  return result;
	};
	
	// Little isString util for use in Array#every.
	var isString = function(thing) {
	  return typeof thing === 'string';
	};
	
	// Public: Main class.
	// Watches files & directories for changes.
	//
	// * _opts - object, chokidar options hash
	//
	// Emitted events:
	// `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`
	//
	// Examples
	//
	//  var watcher = new FSWatcher()
	//    .add(directories)
	//    .on('add', path => console.log('File', path, 'was added'))
	//    .on('change', path => console.log('File', path, 'was changed'))
	//    .on('unlink', path => console.log('File', path, 'was removed'))
	//    .on('all', (event, path) => console.log(path, ' emitted ', event))
	//
	function FSWatcher(_opts) {
	  EventEmitter.call(this);
	  var opts = {};
	  // in case _opts that is passed in is a frozen object
	  if (_opts) for (var opt in _opts) opts[opt] = _opts[opt];
	  this._watched = Object.create(null);
	  this._closers = Object.create(null);
	  this._ignoredPaths = Object.create(null);
	  Object.defineProperty(this, '_globIgnored', {
	    get: function() { return Object.keys(this._ignoredPaths); }
	  });
	  this.closed = false;
	  this._throttled = Object.create(null);
	  this._symlinkPaths = Object.create(null);
	
	  function undef(key) {
	    return opts[key] === undefined;
	  }
	
	  // Set up default options.
	  if (undef('persistent')) opts.persistent = true;
	  if (undef('ignoreInitial')) opts.ignoreInitial = false;
	  if (undef('ignorePermissionErrors')) opts.ignorePermissionErrors = false;
	  if (undef('interval')) opts.interval = 100;
	  if (undef('binaryInterval')) opts.binaryInterval = 300;
	  this.enableBinaryInterval = opts.binaryInterval !== opts.interval;
	
	  // Enable fsevents on OS X when polling isn't explicitly enabled.
	  if (undef('useFsEvents')) opts.useFsEvents = !opts.usePolling;
	
	  // If we can't use fsevents, ensure the options reflect it's disabled.
	  if (!FsEventsHandler.canUse()) opts.useFsEvents = false;
	
	  // Use polling on Mac if not using fsevents.
	  // Other platforms use non-polling fs.watch.
	  if (undef('usePolling') && !opts.useFsEvents) {
	    opts.usePolling = process.platform === 'darwin';
	  }
	
	  // Global override (useful for end-developers that need to force polling for all
	  // instances of chokidar, regardless of usage/dependency depth)
	  var envPoll = process.env.CHOKIDAR_USEPOLLING;
	  if (envPoll !== undefined) {
	    var envLower = envPoll.toLowerCase();
	
	    if (envLower === 'false' || envLower === '0') {
	      opts.usePolling = false;
	    } else if (envLower === 'true' || envLower === '1') {
	      opts.usePolling = true;
	    } else {
	      opts.usePolling = !!envLower
	    }
	  }
	
	  // Editor atomic write normalization enabled by default with fs.watch
	  if (undef('atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;
	  if (opts.atomic) this._pendingUnlinks = Object.create(null);
	
	  if (undef('followSymlinks')) opts.followSymlinks = true;
	
	  if (undef('awaitWriteFinish')) opts.awaitWriteFinish = false;
	  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};
	  var awf = opts.awaitWriteFinish;
	  if (awf) {
	    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;
	    if (!awf.pollInterval) awf.pollInterval = 100;
	
	    this._pendingWrites = Object.create(null);
	  }
	  if (opts.ignored) opts.ignored = arrify(opts.ignored);
	
	  this._isntIgnored = function(path, stat) {
	    return !this._isIgnored(path, stat);
	  }.bind(this);
	
	  var readyCalls = 0;
	  this._emitReady = function() {
	    if (++readyCalls >= this._readyCount) {
	      this._emitReady = Function.prototype;
	      this._readyEmitted = true;
	      // use process.nextTick to allow time for listener to be bound
	      process.nextTick(this.emit.bind(this, 'ready'));
	    }
	  }.bind(this);
	
	  this.options = opts;
	
	  // You’re frozen when your heart’s not open.
	  Object.freeze(opts);
	}
	
	inherits(FSWatcher, EventEmitter);
	
	// Common helpers
	// --------------
	
	// Private method: Normalize and emit events
	//
	// * event     - string, type of event
	// * path      - string, file or directory path
	// * val[1..3] - arguments to be passed with event
	//
	// Returns the error if defined, otherwise the value of the
	// FSWatcher instance's `closed` flag
	FSWatcher.prototype._emit = function(event, path, val1, val2, val3) {
	  if (this.options.cwd) path = sysPath.relative(this.options.cwd, path);
	  var args = [event, path];
	  if (val3 !== undefined) args.push(val1, val2, val3);
	  else if (val2 !== undefined) args.push(val1, val2);
	  else if (val1 !== undefined) args.push(val1);
	
	  var awf = this.options.awaitWriteFinish;
	  if (awf && this._pendingWrites[path]) {
	    this._pendingWrites[path].lastChange = new Date();
	    return this;
	  }
	
	  if (this.options.atomic) {
	    if (event === 'unlink') {
	      this._pendingUnlinks[path] = args;
	      setTimeout(function() {
	        Object.keys(this._pendingUnlinks).forEach(function(path) {
	          this.emit.apply(this, this._pendingUnlinks[path]);
	          this.emit.apply(this, ['all'].concat(this._pendingUnlinks[path]));
	          delete this._pendingUnlinks[path];
	        }.bind(this));
	      }.bind(this), typeof this.options.atomic === "number"
	        ? this.options.atomic
	        : 100);
	      return this;
	    } else if (event === 'add' && this._pendingUnlinks[path]) {
	      event = args[0] = 'change';
	      delete this._pendingUnlinks[path];
	    }
	  }
	
	  var emitEvent = function() {
	    this.emit.apply(this, args);
	    if (event !== 'error') this.emit.apply(this, ['all'].concat(args));
	  }.bind(this);
	
	  if (awf && (event === 'add' || event === 'change') && this._readyEmitted) {
	    var awfEmit = function(err, stats) {
	      if (err) {
	        event = args[0] = 'error';
	        args[1] = err;
	        emitEvent();
	      } else if (stats) {
	        // if stats doesn't exist the file must have been deleted
	        if (args.length > 2) {
	          args[2] = stats;
	        } else {
	          args.push(stats);
	        }
	        emitEvent();
	      }
	    };
	
	    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);
	    return this;
	  }
	
	  if (event === 'change') {
	    if (!this._throttle('change', path, 50)) return this;
	  }
	
	  if (
	    this.options.alwaysStat && val1 === undefined &&
	    (event === 'add' || event === 'addDir' || event === 'change')
	  ) {
	    var fullPath = this.options.cwd ? sysPath.join(this.options.cwd, path) : path;
	    fs.stat(fullPath, function(error, stats) {
	      // Suppress event when fs.stat fails, to avoid sending undefined 'stat'
	      if (error || !stats) return;
	
	      args.push(stats);
	      emitEvent();
	    });
	  } else {
	    emitEvent();
	  }
	
	  return this;
	};
	
	// Private method: Common handler for errors
	//
	// * error  - object, Error instance
	//
	// Returns the error if defined, otherwise the value of the
	// FSWatcher instance's `closed` flag
	FSWatcher.prototype._handleError = function(error) {
	  var code = error && error.code;
	  var ipe = this.options.ignorePermissionErrors;
	  if (error &&
	    code !== 'ENOENT' &&
	    code !== 'ENOTDIR' &&
	    (!ipe || (code !== 'EPERM' && code !== 'EACCES'))
	  ) this.emit('error', error);
	  return error || this.closed;
	};
	
	// Private method: Helper utility for throttling
	//
	// * action  - string, type of action being throttled
	// * path    - string, path being acted upon
	// * timeout - int, duration of time to suppress duplicate actions
	//
	// Returns throttle tracking object or false if action should be suppressed
	FSWatcher.prototype._throttle = function(action, path, timeout) {
	  if (!(action in this._throttled)) {
	    this._throttled[action] = Object.create(null);
	  }
	  var throttled = this._throttled[action];
	  if (path in throttled) return false;
	  function clear() {
	    delete throttled[path];
	    clearTimeout(timeoutObject);
	  }
	  var timeoutObject = setTimeout(clear, timeout);
	  throttled[path] = {timeoutObject: timeoutObject, clear: clear};
	  return throttled[path];
	};
	
	// Private method: Awaits write operation to finish
	//
	// * path    - string, path being acted upon
	// * threshold - int, time in milliseconds a file size must be fixed before
	//                    acknowledgeing write operation is finished
	// * awfEmit - function, to be called when ready for event to be emitted
	// Polls a newly created file for size variations. When files size does not
	// change for 'threshold' milliseconds calls callback.
	FSWatcher.prototype._awaitWriteFinish = function(path, threshold, event, awfEmit) {
	  var timeoutHandler;
	
	  var fullPath = path;
	  if (this.options.cwd && !isAbsolute(path)) {
	    fullPath = sysPath.join(this.options.cwd, path);
	  }
	
	  var now = new Date();
	
	  var awaitWriteFinish = (function (prevStat) {
	    fs.stat(fullPath, function(err, curStat) {
	      if (err) {
	        if (err.code !== 'ENOENT') awfEmit(err);
	        return;
	      }
	
	      var now = new Date();
	
	      if (prevStat && curStat.size != prevStat.size) {
	        this._pendingWrites[path].lastChange = now;
	      }
	
	      if (now - this._pendingWrites[path].lastChange >= threshold) {
	        delete this._pendingWrites[path];
	        awfEmit(null, curStat);
	      } else {
	        timeoutHandler = setTimeout(
	          awaitWriteFinish.bind(this, curStat),
	          this.options.awaitWriteFinish.pollInterval
	        );
	      }
	    }.bind(this));
	  }.bind(this));
	
	  if (!(path in this._pendingWrites)) {
	    this._pendingWrites[path] = {
	      lastChange: now,
	      cancelWait: function() {
	        delete this._pendingWrites[path];
	        clearTimeout(timeoutHandler);
	        return event;
	      }.bind(this)
	    };
	    timeoutHandler = setTimeout(
	      awaitWriteFinish.bind(this),
	      this.options.awaitWriteFinish.pollInterval
	    );
	  }
	};
	
	// Private method: Determines whether user has asked to ignore this path
	//
	// * path  - string, path to file or directory
	// * stats - object, result of fs.stat
	//
	// Returns boolean
	var dotRe = /\..*\.(sw[px])$|\~$|\.subl.*\.tmp/;
	FSWatcher.prototype._isIgnored = function(path, stats) {
	  if (this.options.atomic && dotRe.test(path)) return true;
	
	  if (!this._userIgnored) {
	    var cwd = this.options.cwd;
	    var ignored = this.options.ignored;
	    if (cwd && ignored) {
	      ignored = ignored.map(function (path) {
	        if (typeof path !== 'string') return path;
	        return isAbsolute(path) ? path : sysPath.join(cwd, path);
	      });
	    }
	    var paths = arrify(ignored)
	      .filter(function(path) {
	        return typeof path === 'string' && !isGlob(path);
	      }).map(function(path) {
	        return path + '/**';
	      });
	    this._userIgnored = anymatch(
	      this._globIgnored.concat(ignored).concat(paths)
	    );
	  }
	
	  return this._userIgnored([path, stats]);
	};
	
	// Private method: Provides a set of common helpers and properties relating to
	// symlink and glob handling
	//
	// * path - string, file, directory, or glob pattern being watched
	// * depth - int, at any depth > 0, this isn't a glob
	//
	// Returns object containing helpers for this path
	var replacerRe = /^\.[\/\\]/;
	FSWatcher.prototype._getWatchHelpers = function(path, depth) {
	  path = path.replace(replacerRe, '');
	  var watchPath = depth || !isGlob(path) ? path : globParent(path);
	  var fullWatchPath = sysPath.resolve(watchPath);
	  var hasGlob = watchPath !== path;
	  var globFilter = hasGlob ? anymatch(path) : false;
	  var follow = this.options.followSymlinks;
	  var globSymlink = hasGlob && follow ? null : false;
	
	  var checkGlobSymlink = function(entry) {
	    // only need to resolve once
	    // first entry should always have entry.parentDir === ''
	    if (globSymlink == null) {
	      globSymlink = entry.fullParentDir === fullWatchPath ? false : {
	        realPath: entry.fullParentDir,
	        linkPath: fullWatchPath
	      };
	    }
	
	    if (globSymlink) {
	      return entry.fullPath.replace(globSymlink.realPath, globSymlink.linkPath);
	    }
	
	    return entry.fullPath;
	  };
	
	  var entryPath = function(entry) {
	    return sysPath.join(watchPath,
	      sysPath.relative(watchPath, checkGlobSymlink(entry))
	    );
	  };
	
	  var filterPath = function(entry) {
	    if (entry.stat && entry.stat.isSymbolicLink()) return filterDir(entry);
	    var resolvedPath = entryPath(entry);
	    return (!hasGlob || globFilter(resolvedPath)) &&
	      this._isntIgnored(resolvedPath, entry.stat) &&
	      (this.options.ignorePermissionErrors ||
	        this._hasReadPermissions(entry.stat));
	  }.bind(this);
	
	  var getDirParts = function(path) {
	    if (!hasGlob) return false;
	    var parts = sysPath.relative(watchPath, path).split(/[\/\\]/);
	    return parts;
	  };
	
	  var dirParts = getDirParts(path);
	  if (dirParts && dirParts.length > 1) dirParts.pop();
	  var unmatchedGlob;
	
	  var filterDir = function(entry) {
	    if (hasGlob) {
	      var entryParts = getDirParts(checkGlobSymlink(entry));
	      var globstar = false;
	      unmatchedGlob = !dirParts.every(function(part, i) {
	        if (part === '**') globstar = true;
	        return globstar || !entryParts[i] || anymatch(part, entryParts[i]);
	      });
	    }
	    return !unmatchedGlob && this._isntIgnored(entryPath(entry), entry.stat);
	  }.bind(this);
	
	  return {
	    followSymlinks: follow,
	    statMethod: follow ? 'stat' : 'lstat',
	    path: path,
	    watchPath: watchPath,
	    entryPath: entryPath,
	    hasGlob: hasGlob,
	    globFilter: globFilter,
	    filterPath: filterPath,
	    filterDir: filterDir
	  };
	};
	
	// Directory helpers
	// -----------------
	
	// Private method: Provides directory tracking objects
	//
	// * directory - string, path of the directory
	//
	// Returns the directory's tracking object
	FSWatcher.prototype._getWatchedDir = function(directory) {
	  var dir = sysPath.resolve(directory);
	  var watcherRemove = this._remove.bind(this);
	  if (!(dir in this._watched)) this._watched[dir] = {
	    _items: Object.create(null),
	    add: function(item) {
	      if (item !== '.') this._items[item] = true;
	    },
	    remove: function(item) {
	      delete this._items[item];
	      if (!this.children().length) {
	        fs.readdir(dir, function(err) {
	          if (err) watcherRemove(sysPath.dirname(dir), sysPath.basename(dir));
	        });
	      }
	    },
	    has: function(item) {return item in this._items;},
	    children: function() {return Object.keys(this._items);}
	  };
	  return this._watched[dir];
	};
	
	// File helpers
	// ------------
	
	// Private method: Check for read permissions
	// Based on this answer on SO: http://stackoverflow.com/a/11781404/1358405
	//
	// * stats - object, result of fs.stat
	//
	// Returns boolean
	FSWatcher.prototype._hasReadPermissions = function(stats) {
	  return Boolean(4 & parseInt(((stats && stats.mode) & 0x1ff).toString(8)[0], 10));
	};
	
	// Private method: Handles emitting unlink events for
	// files and directories, and via recursion, for
	// files and directories within directories that are unlinked
	//
	// * directory - string, directory within which the following item is located
	// * item      - string, base path of item/directory
	//
	// Returns nothing
	FSWatcher.prototype._remove = function(directory, item) {
	  // if what is being deleted is a directory, get that directory's paths
	  // for recursive deleting and cleaning of watched object
	  // if it is not a directory, nestedDirectoryChildren will be empty array
	  var path = sysPath.join(directory, item);
	  var fullPath = sysPath.resolve(path);
	  var isDirectory = this._watched[path] || this._watched[fullPath];
	
	  // prevent duplicate handling in case of arriving here nearly simultaneously
	  // via multiple paths (such as _handleFile and _handleDir)
	  if (!this._throttle('remove', path, 100)) return;
	
	  // if the only watched file is removed, watch for its return
	  var watchedDirs = Object.keys(this._watched);
	  if (!isDirectory && !this.options.useFsEvents && watchedDirs.length === 1) {
	    this.add(directory, item, true);
	  }
	
	  // This will create a new entry in the watched object in either case
	  // so we got to do the directory check beforehand
	  var nestedDirectoryChildren = this._getWatchedDir(path).children();
	
	  // Recursively remove children directories / files.
	  nestedDirectoryChildren.forEach(function(nestedItem) {
	    this._remove(path, nestedItem);
	  }, this);
	
	  // Check if item was on the watched list and remove it
	  var parent = this._getWatchedDir(directory);
	  var wasTracked = parent.has(item);
	  parent.remove(item);
	
	  // If we wait for this file to be fully written, cancel the wait.
	  var relPath = path;
	  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);
	  if (this.options.awaitWriteFinish && this._pendingWrites[relPath]) {
	    var event = this._pendingWrites[relPath].cancelWait();
	    if (event === 'add') return;
	  }
	
	  // The Entry will either be a directory that just got removed
	  // or a bogus entry to a file, in either case we have to remove it
	  delete this._watched[path];
	  delete this._watched[fullPath];
	  var eventName = isDirectory ? 'unlinkDir' : 'unlink';
	  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);
	
	  // Avoid conflicts if we later create another file with the same name
	  if (!this.options.useFsEvents) {
	    this._closePath(path);
	  }
	};
	
	FSWatcher.prototype._closePath = function(path) {
	  if (!this._closers[path]) return;
	  this._closers[path]();
	  delete this._closers[path];
	  this._getWatchedDir(sysPath.dirname(path)).remove(sysPath.basename(path));
	}
	
	// Public method: Adds paths to be watched on an existing FSWatcher instance
	
	// * paths     - string or array of strings, file/directory paths and/or globs
	// * _origAdd  - private boolean, for handling non-existent paths to be watched
	// * _internal - private boolean, indicates a non-user add
	
	// Returns an instance of FSWatcher for chaining.
	FSWatcher.prototype.add = function(paths, _origAdd, _internal) {
	  var cwd = this.options.cwd;
	  this.closed = false;
	  paths = flatten(arrify(paths));
	
	  if (!paths.every(isString)) {
	    throw new TypeError('Non-string provided as watch path: ' + paths);
	  }
	
	  if (cwd) paths = paths.map(function(path) {
	    if (isAbsolute(path)) {
	      return path;
	    } else if (path[0] === '!') {
	      return '!' + sysPath.join(cwd, path.substring(1));
	    } else {
	      return sysPath.join(cwd, path);
	    }
	  });
	
	  // set aside negated glob strings
	  paths = paths.filter(function(path) {
	    if (path[0] === '!') {
	      this._ignoredPaths[path.substring(1)] = true;
	    } else {
	      // if a path is being added that was previously ignored, stop ignoring it
	      delete this._ignoredPaths[path];
	      delete this._ignoredPaths[path + '/**'];
	
	      // reset the cached userIgnored anymatch fn
	      // to make ignoredPaths changes effective
	      this._userIgnored = null;
	
	      return true;
	    }
	  }, this);
	
	  if (this.options.useFsEvents && FsEventsHandler.canUse()) {
	    if (!this._readyCount) this._readyCount = paths.length;
	    if (this.options.persistent) this._readyCount *= 2;
	    paths.forEach(this._addToFsEvents, this);
	  } else {
	    if (!this._readyCount) this._readyCount = 0;
	    this._readyCount += paths.length;
	    asyncEach(paths, function(path, next) {
	      this._addToNodeFs(path, !_internal, 0, 0, _origAdd, function(err, res) {
	        if (res) this._emitReady();
	        next(err, res);
	      }.bind(this));
	    }.bind(this), function(error, results) {
	      results.forEach(function(item) {
	        if (!item) return;
	        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
	      }, this);
	    }.bind(this));
	  }
	
	  return this;
	};
	
	// Public method: Close watchers or start ignoring events from specified paths.
	
	// * paths     - string or array of strings, file/directory paths and/or globs
	
	// Returns instance of FSWatcher for chaining.
	FSWatcher.prototype.unwatch = function(paths) {
	  if (this.closed) return this;
	  paths = flatten(arrify(paths));
	
	  paths.forEach(function(path) {
	    // convert to absolute path unless relative path already matches
	    if (!isAbsolute(path) && !this._closers[path]) {
	      if (this.options.cwd) path = sysPath.join(this.options.cwd, path);
	      path = sysPath.resolve(path);
	    }
	
	    this._closePath(path);
	
	    this._ignoredPaths[path] = true;
	    if (path in this._watched) {
	      this._ignoredPaths[path + '/**'] = true;
	    }
	
	    // reset the cached userIgnored anymatch fn
	    // to make ignoredPaths changes effective
	    this._userIgnored = null;
	  }, this);
	
	  return this;
	};
	
	// Public method: Close watchers and remove all listeners from watched paths.
	
	// Returns instance of FSWatcher for chaining.
	FSWatcher.prototype.close = function() {
	  if (this.closed) return this;
	
	  this.closed = true;
	  Object.keys(this._closers).forEach(function(watchPath) {
	    this._closers[watchPath]();
	    delete this._closers[watchPath];
	  }, this);
	  this._watched = Object.create(null);
	
	  this.removeAllListeners();
	  return this;
	};
	
	// Public method: Expose list of watched paths
	
	// Returns object w/ dir paths as keys and arrays of contained paths as values.
	FSWatcher.prototype.getWatched = function() {
	  var watchList = {};
	  Object.keys(this._watched).forEach(function(dir) {
	    var key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
	    watchList[key || '.'] = Object.keys(this._watched[dir]._items).sort();
	  }.bind(this));
	  return watchList;
	};
	
	// Attach watch handler prototype methods
	function importHandler(handler) {
	  Object.keys(handler.prototype).forEach(function(method) {
	    FSWatcher.prototype[method] = handler.prototype[method];
	  });
	}
	importHandler(NodeFsHandler);
	if (FsEventsHandler.canUse()) importHandler(FsEventsHandler);
	
	// Export FSWatcher class
	exports.FSWatcher = FSWatcher;
	
	// Public function: Instantiates watcher with paths to be tracked.
	
	// * paths     - string or array of strings, file/directory paths and/or globs
	// * options   - object, chokidar options
	
	// Returns an instance of FSWatcher for chaining.
	exports.watch = function(paths, options) {
	  return new FSWatcher(options).add(paths);
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// async-each MIT license (by Paul Miller from http://paulmillr.com).
	(function(globals) {
	  'use strict';
	  var each = function(items, next, callback) {
	    if (!Array.isArray(items)) throw new TypeError('each() expects array as first argument');
	    if (typeof next !== 'function') throw new TypeError('each() expects function as second argument');
	    if (typeof callback !== 'function') callback = Function.prototype; // no-op
	
	    if (items.length === 0) return callback(undefined, items);
	
	    var transformed = new Array(items.length);
	    var count = 0;
	    var returned = false;
	
	    items.forEach(function(item, index) {
	      next(item, function(error, transformedItem) {
	        if (returned) return;
	        if (error) {
	          returned = true;
	          return callback(error);
	        }
	        transformed[index] = transformedItem;
	        count += 1;
	        if (count === items.length) return callback(undefined, transformed);
	      });
	    });
	  };
	
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return each;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // RequireJS
	  } else if (typeof module !== 'undefined' && module.exports) {
	    module.exports = each; // CommonJS
	  } else {
	    globals.asyncEach = each; // <script>
	  }
	})(this);


/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var arrify = __webpack_require__(221);
	var micromatch = __webpack_require__(222);
	var path = __webpack_require__(4);
	
	var anymatch = function(criteria, value, returnIndex, startIndex, endIndex) {
	  criteria = arrify(criteria);
	  value = arrify(value);
	  if (arguments.length === 1) {
	    return anymatch.bind(null, criteria.map(function(criterion) {
	      return typeof criterion === 'string' && criterion[0] !== '!' ?
	        micromatch.matcher(criterion) : criterion;
	    }));
	  }
	  startIndex = startIndex || 0;
	  var string = value[0];
	  var altString;
	  var matched = false;
	  var matchIndex = -1;
	  function testCriteria (criterion, index) {
	    var result;
	    switch (toString.call(criterion)) {
	    case '[object String]':
	      result = string === criterion || altString && altString === criterion;
	      result = result || micromatch.isMatch(string, criterion);
	      break;
	    case '[object RegExp]':
	      result = criterion.test(string) || altString && criterion.test(altString);
	      break;
	    case '[object Function]':
	      result = criterion.apply(null, value);
	      break;
	    default:
	      result = false;
	    }
	    if (result) {
	      matchIndex = index + startIndex;
	    }
	    return result;
	  }
	  var crit = criteria;
	  var negGlobs = crit.reduce(function(arr, criterion, index) {
	    if (typeof criterion === 'string' && criterion[0] === '!') {
	      if (crit === criteria) {
	        // make a copy before modifying
	        crit = crit.slice();
	      }
	      crit[index] = null;
	      arr.push(criterion.substr(1));
	    }
	    return arr;
	  }, []);
	  if (!negGlobs.length || !micromatch.any(string, negGlobs)) {
	    if (path.sep === '\\' && typeof string === 'string') {
	      altString = string.split('\\').join('/');
	      altString = altString === string ? null : altString;
	    }
	    matched = crit.slice(startIndex, endIndex).some(testCriteria);
	  }
	  return returnIndex === true ? matchIndex : matched;
	};
	
	module.exports = anymatch;


/***/ },
/* 221 */
/***/ function(module, exports) {

	'use strict';
	module.exports = function (val) {
		if (val === null || val === undefined) {
			return [];
		}
	
		return Array.isArray(val) ? val : [val];
	};


/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * micromatch <https://github.com/jonschlinkert/micromatch>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	var expand = __webpack_require__(223);
	var utils = __webpack_require__(224);
	
	/**
	 * The main function. Pass an array of filepaths,
	 * and a string or array of glob patterns
	 *
	 * @param  {Array|String} `files`
	 * @param  {Array|String} `patterns`
	 * @param  {Object} `opts`
	 * @return {Array} Array of matches
	 */
	
	function micromatch(files, patterns, opts) {
	  if (!files || !patterns) return [];
	  opts = opts || {};
	
	  if (typeof opts.cache === 'undefined') {
	    opts.cache = true;
	  }
	
	  if (!Array.isArray(patterns)) {
	    return match(files, patterns, opts);
	  }
	
	  var len = patterns.length, i = 0;
	  var omit = [], keep = [];
	
	  while (len--) {
	    var glob = patterns[i++];
	    if (typeof glob === 'string' && glob.charCodeAt(0) === 33 /* ! */) {
	      omit.push.apply(omit, match(files, glob.slice(1), opts));
	    } else {
	      keep.push.apply(keep, match(files, glob, opts));
	    }
	  }
	  return utils.diff(keep, omit);
	}
	
	/**
	 * Return an array of files that match the given glob pattern.
	 *
	 * This function is called by the main `micromatch` function If you only
	 * need to pass a single pattern you might get very minor speed improvements
	 * using this function.
	 *
	 * @param  {Array} `files`
	 * @param  {String} `pattern`
	 * @param  {Object} `options`
	 * @return {Array}
	 */
	
	function match(files, pattern, opts) {
	  if (utils.typeOf(files) !== 'string' && !Array.isArray(files)) {
	    throw new Error(msg('match', 'files', 'a string or array'));
	  }
	
	  files = utils.arrayify(files);
	  opts = opts || {};
	
	  var negate = opts.negate || false;
	  var orig = pattern;
	
	  if (typeof pattern === 'string') {
	    negate = pattern.charAt(0) === '!';
	    if (negate) {
	      pattern = pattern.slice(1);
	    }
	
	    // we need to remove the character regardless,
	    // so the above logic is still needed
	    if (opts.nonegate === true) {
	      negate = false;
	    }
	  }
	
	  var _isMatch = matcher(pattern, opts);
	  var len = files.length, i = 0;
	  var res = [];
	
	  while (i < len) {
	    var file = files[i++];
	    var fp = utils.unixify(file, opts);
	
	    if (!_isMatch(fp)) { continue; }
	    res.push(fp);
	  }
	
	  if (res.length === 0) {
	    if (opts.failglob === true) {
	      throw new Error('micromatch.match() found no matches for: "' + orig + '".');
	    }
	
	    if (opts.nonull || opts.nullglob) {
	      res.push(utils.unescapeGlob(orig));
	    }
	  }
	
	  // if `negate` was defined, diff negated files
	  if (negate) { res = utils.diff(files, res); }
	
	  // if `ignore` was defined, diff ignored filed
	  if (opts.ignore && opts.ignore.length) {
	    pattern = opts.ignore;
	    opts = utils.omit(opts, ['ignore']);
	    res = utils.diff(res, micromatch(res, pattern, opts));
	  }
	
	  if (opts.nodupes) {
	    return utils.unique(res);
	  }
	  return res;
	}
	
	/**
	 * Returns a function that takes a glob pattern or array of glob patterns
	 * to be used with `Array#filter()`. (Internally this function generates
	 * the matching function using the [matcher] method).
	 *
	 * ```js
	 * var fn = mm.filter('[a-c]');
	 * ['a', 'b', 'c', 'd', 'e'].filter(fn);
	 * //=> ['a', 'b', 'c']
	 * ```
	 * @param  {String|Array} `patterns` Can be a glob or array of globs.
	 * @param  {Options} `opts` Options to pass to the [matcher] method.
	 * @return {Function} Filter function to be passed to `Array#filter()`.
	 */
	
	function filter(patterns, opts) {
	  if (!Array.isArray(patterns) && typeof patterns !== 'string') {
	    throw new TypeError(msg('filter', 'patterns', 'a string or array'));
	  }
	
	  patterns = utils.arrayify(patterns);
	  var len = patterns.length, i = 0;
	  var patternMatchers = Array(len);
	  while (i < len) {
	    patternMatchers[i] = matcher(patterns[i++], opts);
	  }
	
	  return function(fp) {
	    if (fp == null) return [];
	    var len = patternMatchers.length, i = 0;
	    var res = true;
	
	    fp = utils.unixify(fp, opts);
	    while (i < len) {
	      var fn = patternMatchers[i++];
	      if (!fn(fp)) {
	        res = false;
	        break;
	      }
	    }
	    return res;
	  };
	}
	
	/**
	 * Returns true if the filepath contains the given
	 * pattern. Can also return a function for matching.
	 *
	 * ```js
	 * isMatch('foo.md', '*.md', {});
	 * //=> true
	 *
	 * isMatch('*.md', {})('foo.md')
	 * //=> true
	 * ```
	 * @param  {String} `fp`
	 * @param  {String} `pattern`
	 * @param  {Object} `opts`
	 * @return {Boolean}
	 */
	
	function isMatch(fp, pattern, opts) {
	  if (typeof fp !== 'string') {
	    throw new TypeError(msg('isMatch', 'filepath', 'a string'));
	  }
	
	  fp = utils.unixify(fp, opts);
	  if (utils.typeOf(pattern) === 'object') {
	    return matcher(fp, pattern);
	  }
	  return matcher(pattern, opts)(fp);
	}
	
	/**
	 * Returns true if the filepath matches the
	 * given pattern.
	 */
	
	function contains(fp, pattern, opts) {
	  if (typeof fp !== 'string') {
	    throw new TypeError(msg('contains', 'pattern', 'a string'));
	  }
	
	  opts = opts || {};
	  opts.contains = (pattern !== '');
	  fp = utils.unixify(fp, opts);
	
	  if (opts.contains && !utils.isGlob(pattern)) {
	    return fp.indexOf(pattern) !== -1;
	  }
	  return matcher(pattern, opts)(fp);
	}
	
	/**
	 * Returns true if a file path matches any of the
	 * given patterns.
	 *
	 * @param  {String} `fp` The filepath to test.
	 * @param  {String|Array} `patterns` Glob patterns to use.
	 * @param  {Object} `opts` Options to pass to the `matcher()` function.
	 * @return {String}
	 */
	
	function any(fp, patterns, opts) {
	  if (!Array.isArray(patterns) && typeof patterns !== 'string') {
	    throw new TypeError(msg('any', 'patterns', 'a string or array'));
	  }
	
	  patterns = utils.arrayify(patterns);
	  var len = patterns.length;
	
	  fp = utils.unixify(fp, opts);
	  while (len--) {
	    var isMatch = matcher(patterns[len], opts);
	    if (isMatch(fp)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Filter the keys of an object with the given `glob` pattern
	 * and `options`
	 *
	 * @param  {Object} `object`
	 * @param  {Pattern} `object`
	 * @return {Array}
	 */
	
	function matchKeys(obj, glob, options) {
	  if (utils.typeOf(obj) !== 'object') {
	    throw new TypeError(msg('matchKeys', 'first argument', 'an object'));
	  }
	
	  var fn = matcher(glob, options);
	  var res = {};
	
	  for (var key in obj) {
	    if (obj.hasOwnProperty(key) && fn(key)) {
	      res[key] = obj[key];
	    }
	  }
	  return res;
	}
	
	/**
	 * Return a function for matching based on the
	 * given `pattern` and `options`.
	 *
	 * @param  {String} `pattern`
	 * @param  {Object} `options`
	 * @return {Function}
	 */
	
	function matcher(pattern, opts) {
	  // pattern is a function
	  if (typeof pattern === 'function') {
	    return pattern;
	  }
	  // pattern is a regex
	  if (pattern instanceof RegExp) {
	    return function(fp) {
	      return pattern.test(fp);
	    };
	  }
	
	  if (typeof pattern !== 'string') {
	    throw new TypeError(msg('matcher', 'pattern', 'a string, regex, or function'));
	  }
	
	  // strings, all the way down...
	  pattern = utils.unixify(pattern, opts);
	
	  // pattern is a non-glob string
	  if (!utils.isGlob(pattern)) {
	    return utils.matchPath(pattern, opts);
	  }
	  // pattern is a glob string
	  var re = makeRe(pattern, opts);
	
	  // `matchBase` is defined
	  if (opts && opts.matchBase) {
	    return utils.hasFilename(re, opts);
	  }
	  // `matchBase` is not defined
	  return function(fp) {
	    fp = utils.unixify(fp, opts);
	    return re.test(fp);
	  };
	}
	
	/**
	 * Create and cache a regular expression for matching
	 * file paths.
	 *
	 * If the leading character in the `glob` is `!`, a negation
	 * regex is returned.
	 *
	 * @param  {String} `glob`
	 * @param  {Object} `options`
	 * @return {RegExp}
	 */
	
	function toRegex(glob, options) {
	  // clone options to prevent  mutating the original object
	  var opts = Object.create(options || {});
	  var flags = opts.flags || '';
	  if (opts.nocase && flags.indexOf('i') === -1) {
	    flags += 'i';
	  }
	
	  var parsed = expand(glob, opts);
	
	  // pass in tokens to avoid parsing more than once
	  opts.negated = opts.negated || parsed.negated;
	  opts.negate = opts.negated;
	  glob = wrapGlob(parsed.pattern, opts);
	  var re;
	
	  try {
	    re = new RegExp(glob, flags);
	    return re;
	  } catch (err) {
	    err.reason = 'micromatch invalid regex: (' + re + ')';
	    if (opts.strict) throw new SyntaxError(err);
	  }
	
	  // we're only here if a bad pattern was used and the user
	  // passed `options.silent`, so match nothing
	  return /$^/;
	}
	
	/**
	 * Create the regex to do the matching. If the leading
	 * character in the `glob` is `!` a negation regex is returned.
	 *
	 * @param {String} `glob`
	 * @param {Boolean} `negate`
	 */
	
	function wrapGlob(glob, opts) {
	  var prefix = (opts && !opts.contains) ? '^' : '';
	  var after = (opts && !opts.contains) ? '$' : '';
	  glob = ('(?:' + glob + ')' + after);
	  if (opts && opts.negate) {
	    return prefix + ('(?!^' + glob + ').*$');
	  }
	  return prefix + glob;
	}
	
	/**
	 * Create and cache a regular expression for matching file paths.
	 * If the leading character in the `glob` is `!`, a negation
	 * regex is returned.
	 *
	 * @param  {String} `glob`
	 * @param  {Object} `options`
	 * @return {RegExp}
	 */
	
	function makeRe(glob, opts) {
	  if (utils.typeOf(glob) !== 'string') {
	    throw new Error(msg('makeRe', 'glob', 'a string'));
	  }
	  return utils.cache(toRegex, glob, opts);
	}
	
	/**
	 * Make error messages consistent. Follows this format:
	 *
	 * ```js
	 * msg(methodName, argNumber, nativeType);
	 * // example:
	 * msg('matchKeys', 'first', 'an object');
	 * ```
	 *
	 * @param  {String} `method`
	 * @param  {String} `num`
	 * @param  {String} `type`
	 * @return {String}
	 */
	
	function msg(method, what, type) {
	  return 'micromatch.' + method + '(): ' + what + ' should be ' + type + '.';
	}
	
	/**
	 * Public methods
	 */
	
	/* eslint no-multi-spaces: 0 */
	micromatch.any       = any;
	micromatch.braces    = micromatch.braceExpand = utils.braces;
	micromatch.contains  = contains;
	micromatch.expand    = expand;
	micromatch.filter    = filter;
	micromatch.isMatch   = isMatch;
	micromatch.makeRe    = makeRe;
	micromatch.match     = match;
	micromatch.matcher   = matcher;
	micromatch.matchKeys = matchKeys;
	
	/**
	 * Expose `micromatch`
	 */
	
	module.exports = micromatch;


/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * micromatch <https://github.com/jonschlinkert/micromatch>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	var utils = __webpack_require__(224);
	var Glob = __webpack_require__(258);
	
	/**
	 * Expose `expand`
	 */
	
	module.exports = expand;
	
	/**
	 * Expand a glob pattern to resolve braces and
	 * similar patterns before converting to regex.
	 *
	 * @param  {String|Array} `pattern`
	 * @param  {Array} `files`
	 * @param  {Options} `opts`
	 * @return {Array}
	 */
	
	function expand(pattern, options) {
	  if (typeof pattern !== 'string') {
	    throw new TypeError('micromatch.expand(): argument should be a string.');
	  }
	
	  var glob = new Glob(pattern, options || {});
	  var opts = glob.options;
	
	  if (!utils.isGlob(pattern)) {
	    glob.pattern = glob.pattern.replace(/([\/.])/g, '\\$1');
	    return glob;
	  }
	
	  glob.pattern = glob.pattern.replace(/(\+)(?!\()/g, '\\$1');
	  glob.pattern = glob.pattern.split('$').join('\\$');
	
	  if (typeof opts.braces !== 'boolean' && typeof opts.nobraces !== 'boolean') {
	    opts.braces = true;
	  }
	
	  if (glob.pattern === '.*') {
	    return {
	      pattern: '\\.' + star,
	      tokens: tok,
	      options: opts
	    };
	  }
	
	  if (glob.pattern === '*') {
	    return {
	      pattern: oneStar(opts.dot),
	      tokens: tok,
	      options: opts
	    };
	  }
	
	  // parse the glob pattern into tokens
	  glob.parse();
	  var tok = glob.tokens;
	  tok.is.negated = opts.negated;
	
	  // dotfile handling
	  if ((opts.dotfiles === true || tok.is.dotfile) && opts.dot !== false) {
	    opts.dotfiles = true;
	    opts.dot = true;
	  }
	
	  if ((opts.dotdirs === true || tok.is.dotdir) && opts.dot !== false) {
	    opts.dotdirs = true;
	    opts.dot = true;
	  }
	
	  // check for braces with a dotfile pattern
	  if (/[{,]\./.test(glob.pattern)) {
	    opts.makeRe = false;
	    opts.dot = true;
	  }
	
	  if (opts.nonegate !== true) {
	    opts.negated = glob.negated;
	  }
	
	  // if the leading character is a dot or a slash, escape it
	  if (glob.pattern.charAt(0) === '.' && glob.pattern.charAt(1) !== '/') {
	    glob.pattern = '\\' + glob.pattern;
	  }
	
	  /**
	   * Extended globs
	   */
	
	  // expand braces, e.g `{1..5}`
	  glob.track('before braces');
	  if (tok.is.braces) {
	    glob.braces();
	  }
	  glob.track('after braces');
	
	  // expand extglobs, e.g `foo/!(a|b)`
	  glob.track('before extglob');
	  if (tok.is.extglob) {
	    glob.extglob();
	  }
	  glob.track('after extglob');
	
	  // expand brackets, e.g `[[:alpha:]]`
	  glob.track('before brackets');
	  if (tok.is.brackets) {
	    glob.brackets();
	  }
	  glob.track('after brackets');
	
	  // special patterns
	  glob._replace('[!', '[^');
	  glob._replace('(?', '(%~');
	  glob._replace(/\[\]/, '\\[\\]');
	  glob._replace('/[', '/' + (opts.dot ? dotfiles : nodot) + '[', true);
	  glob._replace('/?', '/' + (opts.dot ? dotfiles : nodot) + '[^/]', true);
	  glob._replace('/.', '/(?=.)\\.', true);
	
	  // windows drives
	  glob._replace(/^(\w):([\\\/]+?)/gi, '(?=.)$1:$2', true);
	
	  // negate slashes in exclusion ranges
	  if (glob.pattern.indexOf('[^') !== -1) {
	    glob.pattern = negateSlash(glob.pattern);
	  }
	
	  if (opts.globstar !== false && glob.pattern === '**') {
	    glob.pattern = globstar(opts.dot);
	
	  } else {
	    glob.pattern = balance(glob.pattern, '[', ']');
	    glob.escape(glob.pattern);
	
	    // if the pattern has `**`
	    if (tok.is.globstar) {
	      glob.pattern = collapse(glob.pattern, '/**');
	      glob.pattern = collapse(glob.pattern, '**/');
	      glob._replace('/**/', '(?:/' + globstar(opts.dot) + '/|/)', true);
	      glob._replace(/\*{2,}/g, '**');
	
	      // 'foo/*'
	      glob._replace(/(\w+)\*(?!\/)/g, '$1[^/]*?', true);
	      glob._replace(/\*\*\/\*(\w)/g, globstar(opts.dot) + '\\/' + (opts.dot ? dotfiles : nodot) + '[^/]*?$1', true);
	
	      if (opts.dot !== true) {
	        glob._replace(/\*\*\/(.)/g, '(?:**\\/|)$1');
	      }
	
	      // 'foo/**' or '{**,*}', but not 'foo**'
	      if (tok.path.dirname !== '' || /,\*\*|\*\*,/.test(glob.orig)) {
	        glob._replace('**', globstar(opts.dot), true);
	      }
	    }
	
	    // ends with /*
	    glob._replace(/\/\*$/, '\\/' + oneStar(opts.dot), true);
	    // ends with *, no slashes
	    glob._replace(/(?!\/)\*$/, star, true);
	    // has 'n*.' (partial wildcard w/ file extension)
	    glob._replace(/([^\/]+)\*/, '$1' + oneStar(true), true);
	    // has '*'
	    glob._replace('*', oneStar(opts.dot), true);
	    glob._replace('?.', '?\\.', true);
	    glob._replace('?:', '?:', true);
	
	    glob._replace(/\?+/g, function(match) {
	      var len = match.length;
	      if (len === 1) {
	        return qmark;
	      }
	      return qmark + '{' + len + '}';
	    });
	
	    // escape '.abc' => '\\.abc'
	    glob._replace(/\.([*\w]+)/g, '\\.$1');
	    // fix '[^\\\\/]'
	    glob._replace(/\[\^[\\\/]+\]/g, qmark);
	    // '///' => '\/'
	    glob._replace(/\/+/g, '\\/');
	    // '\\\\\\' => '\\'
	    glob._replace(/\\{2,}/g, '\\');
	  }
	
	  // unescape previously escaped patterns
	  glob.unescape(glob.pattern);
	  glob._replace('__UNESC_STAR__', '*');
	
	  // escape dots that follow qmarks
	  glob._replace('?.', '?\\.');
	
	  // remove unnecessary slashes in character classes
	  glob._replace('[^\\/]', qmark);
	
	  if (glob.pattern.length > 1) {
	    if (/^[\[?*]/.test(glob.pattern)) {
	      // only prepend the string if we don't want to match dotfiles
	      glob.pattern = (opts.dot ? dotfiles : nodot) + glob.pattern;
	    }
	  }
	
	  return glob;
	}
	
	/**
	 * Collapse repeated character sequences.
	 *
	 * ```js
	 * collapse('a/../../../b', '../');
	 * //=> 'a/../b'
	 * ```
	 *
	 * @param  {String} `str`
	 * @param  {String} `ch` Character sequence to collapse
	 * @return {String}
	 */
	
	function collapse(str, ch) {
	  var res = str.split(ch);
	  var isFirst = res[0] === '';
	  var isLast = res[res.length - 1] === '';
	  res = res.filter(Boolean);
	  if (isFirst) res.unshift('');
	  if (isLast) res.push('');
	  return res.join(ch);
	}
	
	/**
	 * Negate slashes in exclusion ranges, per glob spec:
	 *
	 * ```js
	 * negateSlash('[^foo]');
	 * //=> '[^\\/foo]'
	 * ```
	 *
	 * @param  {String} `str` glob pattern
	 * @return {String}
	 */
	
	function negateSlash(str) {
	  return str.replace(/\[\^([^\]]*?)\]/g, function(match, inner) {
	    if (inner.indexOf('/') === -1) {
	      inner = '\\/' + inner;
	    }
	    return '[^' + inner + ']';
	  });
	}
	
	/**
	 * Escape imbalanced braces/bracket. This is a very
	 * basic, naive implementation that only does enough
	 * to serve the purpose.
	 */
	
	function balance(str, a, b) {
	  var aarr = str.split(a);
	  var alen = aarr.join('').length;
	  var blen = str.split(b).join('').length;
	
	  if (alen !== blen) {
	    str = aarr.join('\\' + a);
	    return str.split(b).join('\\' + b);
	  }
	  return str;
	}
	
	/**
	 * Special patterns to be converted to regex.
	 * Heuristics are used to simplify patterns
	 * and speed up processing.
	 */
	
	/* eslint no-multi-spaces: 0 */
	var qmark       = '[^/]';
	var star        = qmark + '*?';
	var nodot       = '(?!\\.)(?=.)';
	var dotfileGlob = '(?:\\/|^)\\.{1,2}($|\\/)';
	var dotfiles    = '(?!' + dotfileGlob + ')(?=.)';
	var twoStarDot  = '(?:(?!' + dotfileGlob + ').)*?';
	
	/**
	 * Create a regex for `*`.
	 *
	 * If `dot` is true, or the pattern does not begin with
	 * a leading star, then return the simpler regex.
	 */
	
	function oneStar(dotfile) {
	  return dotfile ? '(?!' + dotfileGlob + ')(?=.)' + star : (nodot + star);
	}
	
	function globstar(dotfile) {
	  if (dotfile) { return twoStarDot; }
	  return '(?:(?!(?:\\/|^)\\.).)*?';
	}


/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var win32 = process && process.platform === 'win32';
	var path = __webpack_require__(4);
	var fileRe = __webpack_require__(225);
	var utils = module.exports;
	
	/**
	 * Module dependencies
	 */
	
	utils.diff = __webpack_require__(226);
	utils.unique = __webpack_require__(228);
	utils.braces = __webpack_require__(229);
	utils.brackets = __webpack_require__(241);
	utils.extglob = __webpack_require__(243);
	utils.isExtglob = __webpack_require__(244);
	utils.isGlob = __webpack_require__(245);
	utils.typeOf = __webpack_require__(235);
	utils.normalize = __webpack_require__(246);
	utils.omit = __webpack_require__(247);
	utils.parseGlob = __webpack_require__(251);
	utils.cache = __webpack_require__(255);
	
	/**
	 * Get the filename of a filepath
	 *
	 * @param {String} `string`
	 * @return {String}
	 */
	
	utils.filename = function filename(fp) {
	  var seg = fp.match(fileRe());
	  return seg && seg[0];
	};
	
	/**
	 * Returns a function that returns true if the given
	 * pattern is the same as a given `filepath`
	 *
	 * @param {String} `pattern`
	 * @return {Function}
	 */
	
	utils.isPath = function isPath(pattern, opts) {
	  opts = opts || {};
	  return function(fp) {
	    var unixified = utils.unixify(fp, opts);
	    if(opts.nocase){
	      return pattern.toLowerCase() === unixified.toLowerCase();
	    }
	    return pattern === unixified;
	  };
	};
	
	/**
	 * Returns a function that returns true if the given
	 * pattern contains a `filepath`
	 *
	 * @param {String} `pattern`
	 * @return {Function}
	 */
	
	utils.hasPath = function hasPath(pattern, opts) {
	  return function(fp) {
	    return utils.unixify(pattern, opts).indexOf(fp) !== -1;
	  };
	};
	
	/**
	 * Returns a function that returns true if the given
	 * pattern matches or contains a `filepath`
	 *
	 * @param {String} `pattern`
	 * @return {Function}
	 */
	
	utils.matchPath = function matchPath(pattern, opts) {
	  var fn = (opts && opts.contains)
	    ? utils.hasPath(pattern, opts)
	    : utils.isPath(pattern, opts);
	  return fn;
	};
	
	/**
	 * Returns a function that returns true if the given
	 * regex matches the `filename` of a file path.
	 *
	 * @param {RegExp} `re`
	 * @return {Boolean}
	 */
	
	utils.hasFilename = function hasFilename(re) {
	  return function(fp) {
	    var name = utils.filename(fp);
	    return name && re.test(name);
	  };
	};
	
	/**
	 * Coerce `val` to an array
	 *
	 * @param  {*} val
	 * @return {Array}
	 */
	
	utils.arrayify = function arrayify(val) {
	  return !Array.isArray(val)
	    ? [val]
	    : val;
	};
	
	/**
	 * Normalize all slashes in a file path or glob pattern to
	 * forward slashes.
	 */
	
	utils.unixify = function unixify(fp, opts) {
	  if (opts && opts.unixify === false) return fp;
	  if (opts && opts.unixify === true || win32 || path.sep === '\\') {
	    return utils.normalize(fp, false);
	  }
	  if (opts && opts.unescape === true) {
	    return fp ? fp.toString().replace(/\\(\w)/g, '$1') : '';
	  }
	  return fp;
	};
	
	/**
	 * Escape/unescape utils
	 */
	
	utils.escapePath = function escapePath(fp) {
	  return fp.replace(/[\\.]/g, '\\$&');
	};
	
	utils.unescapeGlob = function unescapeGlob(fp) {
	  return fp.replace(/[\\"']/g, '');
	};
	
	utils.escapeRe = function escapeRe(str) {
	  return str.replace(/[-[\\$*+?.#^\s{}(|)\]]/g, '\\$&');
	};
	
	/**
	 * Expose `utils`
	 */
	
	module.exports = utils;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 225 */
/***/ function(module, exports) {

	/*!
	 * filename-regex <https://github.com/regexps/filename-regex>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert
	 * Licensed under the MIT license.
	 */
	
	module.exports = function filenameRegex() {
	  return /([^\\\/]+)$/;
	};


/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * arr-diff <https://github.com/jonschlinkert/arr-diff>
	 *
	 * Copyright (c) 2014 Jon Schlinkert, contributors.
	 * Licensed under the MIT License
	 */
	
	'use strict';
	
	var flatten = __webpack_require__(227);
	var slice = [].slice;
	
	/**
	 * Return the difference between the first array and
	 * additional arrays.
	 *
	 * ```js
	 * var diff = require('{%= name %}');
	 *
	 * var a = ['a', 'b', 'c', 'd'];
	 * var b = ['b', 'c'];
	 *
	 * console.log(diff(a, b))
	 * //=> ['a', 'd']
	 * ```
	 *
	 * @param  {Array} `a`
	 * @param  {Array} `b`
	 * @return {Array}
	 * @api public
	 */
	
	function diff(arr, arrays) {
	  var argsLen = arguments.length;
	  var len = arr.length, i = -1;
	  var res = [], arrays;
	
	  if (argsLen === 1) {
	    return arr;
	  }
	
	  if (argsLen > 2) {
	    arrays = flatten(slice.call(arguments, 1));
	  }
	
	  while (++i < len) {
	    if (!~arrays.indexOf(arr[i])) {
	      res.push(arr[i]);
	    }
	  }
	  return res;
	}
	
	/**
	 * Expose `diff`
	 */
	
	module.exports = diff;


/***/ },
/* 227 */
/***/ function(module, exports) {

	/*!
	 * arr-flatten <https://github.com/jonschlinkert/arr-flatten>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	module.exports = function flatten(arr) {
	  return flat(arr, []);
	};
	
	function flat(arr, res) {
	  var len = arr.length;
	  var i = -1;
	
	  while (len--) {
	    var cur = arr[++i];
	    if (Array.isArray(cur)) {
	      flat(cur, res);
	    } else {
	      res.push(cur);
	    }
	  }
	  return res;
	}

/***/ },
/* 228 */
/***/ function(module, exports) {

	/*!
	 * array-unique <https://github.com/jonschlinkert/array-unique>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	module.exports = function unique(arr) {
	  if (!Array.isArray(arr)) {
	    throw new TypeError('array-unique expects an array.');
	  }
	
	  var len = arr.length;
	  var i = -1;
	
	  while (i++ < len) {
	    var j = i + 1;
	
	    for (; j < arr.length; ++j) {
	      if (arr[i] === arr[j]) {
	        arr.splice(j--, 1);
	      }
	    }
	  }
	  return arr;
	};


/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * braces <https://github.com/jonschlinkert/braces>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT license.
	 */
	
	'use strict';
	
	/**
	 * Module dependencies
	 */
	
	var expand = __webpack_require__(230);
	var repeat = __webpack_require__(239);
	var tokens = __webpack_require__(240);
	
	/**
	 * Expose `braces`
	 */
	
	module.exports = function(str, options) {
	  if (typeof str !== 'string') {
	    throw new Error('braces expects a string');
	  }
	  return braces(str, options);
	};
	
	/**
	 * Expand `{foo,bar}` or `{1..5}` braces in the
	 * given `string`.
	 *
	 * @param  {String} `str`
	 * @param  {Array} `arr`
	 * @param  {Object} `options`
	 * @return {Array}
	 */
	
	function braces(str, arr, options) {
	  if (str === '') {
	    return [];
	  }
	
	  if (!Array.isArray(arr)) {
	    options = arr;
	    arr = [];
	  }
	
	  var opts = options || {};
	  arr = arr || [];
	
	  if (typeof opts.nodupes === 'undefined') {
	    opts.nodupes = true;
	  }
	
	  var fn = opts.fn;
	  var es6;
	
	  if (typeof opts === 'function') {
	    fn = opts;
	    opts = {};
	  }
	
	  if (!(patternRe instanceof RegExp)) {
	    patternRe = patternRegex();
	  }
	
	  var matches = str.match(patternRe) || [];
	  var m = matches[0];
	
	  switch(m) {
	    case '\\,':
	      return escapeCommas(str, arr, opts);
	    case '\\.':
	      return escapeDots(str, arr, opts);
	    case '\/.':
	      return escapePaths(str, arr, opts);
	    case ' ':
	      return splitWhitespace(str);
	    case '{,}':
	      return exponential(str, opts, braces);
	    case '{}':
	      return emptyBraces(str, arr, opts);
	    case '\\{':
	    case '\\}':
	      return escapeBraces(str, arr, opts);
	    case '${':
	      if (!/\{[^{]+\{/.test(str)) {
	        return arr.concat(str);
	      } else {
	        es6 = true;
	        str = tokens.before(str, es6Regex());
	      }
	  }
	
	  if (!(braceRe instanceof RegExp)) {
	    braceRe = braceRegex();
	  }
	
	  var match = braceRe.exec(str);
	  if (match == null) {
	    return [str];
	  }
	
	  var outter = match[1];
	  var inner = match[2];
	  if (inner === '') { return [str]; }
	
	  var segs, segsLength;
	
	  if (inner.indexOf('..') !== -1) {
	    segs = expand(inner, opts, fn) || inner.split(',');
	    segsLength = segs.length;
	
	  } else if (inner[0] === '"' || inner[0] === '\'') {
	    return arr.concat(str.split(/['"]/).join(''));
	
	  } else {
	    segs = inner.split(',');
	    if (opts.makeRe) {
	      return braces(str.replace(outter, wrap(segs, '|')), opts);
	    }
	
	    segsLength = segs.length;
	    if (segsLength === 1 && opts.bash) {
	      segs[0] = wrap(segs[0], '\\');
	    }
	  }
	
	  var len = segs.length;
	  var i = 0, val;
	
	  while (len--) {
	    var path = segs[i++];
	
	    if (/(\.[^.\/])/.test(path)) {
	      if (segsLength > 1) {
	        return segs;
	      } else {
	        return [str];
	      }
	    }
	
	    val = splice(str, outter, path);
	
	    if (/\{[^{}]+?\}/.test(val)) {
	      arr = braces(val, arr, opts);
	    } else if (val !== '') {
	      if (opts.nodupes && arr.indexOf(val) !== -1) { continue; }
	      arr.push(es6 ? tokens.after(val) : val);
	    }
	  }
	
	  if (opts.strict) { return filter(arr, filterEmpty); }
	  return arr;
	}
	
	/**
	 * Expand exponential ranges
	 *
	 *   `a{,}{,}` => ['a', 'a', 'a', 'a']
	 */
	
	function exponential(str, options, fn) {
	  if (typeof options === 'function') {
	    fn = options;
	    options = null;
	  }
	
	  var opts = options || {};
	  var esc = '__ESC_EXP__';
	  var exp = 0;
	  var res;
	
	  var parts = str.split('{,}');
	  if (opts.nodupes) {
	    return fn(parts.join(''), opts);
	  }
	
	  exp = parts.length - 1;
	  res = fn(parts.join(esc), opts);
	  var len = res.length;
	  var arr = [];
	  var i = 0;
	
	  while (len--) {
	    var ele = res[i++];
	    var idx = ele.indexOf(esc);
	
	    if (idx === -1) {
	      arr.push(ele);
	
	    } else {
	      ele = ele.split('__ESC_EXP__').join('');
	      if (!!ele && opts.nodupes !== false) {
	        arr.push(ele);
	
	      } else {
	        var num = Math.pow(2, exp);
	        arr.push.apply(arr, repeat(ele, num));
	      }
	    }
	  }
	  return arr;
	}
	
	/**
	 * Wrap a value with parens, brackets or braces,
	 * based on the given character/separator.
	 *
	 * @param  {String|Array} `val`
	 * @param  {String} `ch`
	 * @return {String}
	 */
	
	function wrap(val, ch) {
	  if (ch === '|') {
	    return '(' + val.join(ch) + ')';
	  }
	  if (ch === ',') {
	    return '{' + val.join(ch) + '}';
	  }
	  if (ch === '-') {
	    return '[' + val.join(ch) + ']';
	  }
	  if (ch === '\\') {
	    return '\\{' + val + '\\}';
	  }
	}
	
	/**
	 * Handle empty braces: `{}`
	 */
	
	function emptyBraces(str, arr, opts) {
	  return braces(str.split('{}').join('\\{\\}'), arr, opts);
	}
	
	/**
	 * Filter out empty-ish values
	 */
	
	function filterEmpty(ele) {
	  return !!ele && ele !== '\\';
	}
	
	/**
	 * Handle patterns with whitespace
	 */
	
	function splitWhitespace(str) {
	  var segs = str.split(' ');
	  var len = segs.length;
	  var res = [];
	  var i = 0;
	
	  while (len--) {
	    res.push.apply(res, braces(segs[i++]));
	  }
	  return res;
	}
	
	/**
	 * Handle escaped braces: `\\{foo,bar}`
	 */
	
	function escapeBraces(str, arr, opts) {
	  if (!/\{[^{]+\{/.test(str)) {
	    return arr.concat(str.split('\\').join(''));
	  } else {
	    str = str.split('\\{').join('__LT_BRACE__');
	    str = str.split('\\}').join('__RT_BRACE__');
	    return map(braces(str, arr, opts), function(ele) {
	      ele = ele.split('__LT_BRACE__').join('{');
	      return ele.split('__RT_BRACE__').join('}');
	    });
	  }
	}
	
	/**
	 * Handle escaped dots: `{1\\.2}`
	 */
	
	function escapeDots(str, arr, opts) {
	  if (!/[^\\]\..+\\\./.test(str)) {
	    return arr.concat(str.split('\\').join(''));
	  } else {
	    str = str.split('\\.').join('__ESC_DOT__');
	    return map(braces(str, arr, opts), function(ele) {
	      return ele.split('__ESC_DOT__').join('.');
	    });
	  }
	}
	
	/**
	 * Handle escaped dots: `{1\\.2}`
	 */
	
	function escapePaths(str, arr, opts) {
	  str = str.split('\/.').join('__ESC_PATH__');
	  return map(braces(str, arr, opts), function(ele) {
	    return ele.split('__ESC_PATH__').join('\/.');
	  });
	}
	
	/**
	 * Handle escaped commas: `{a\\,b}`
	 */
	
	function escapeCommas(str, arr, opts) {
	  if (!/\w,/.test(str)) {
	    return arr.concat(str.split('\\').join(''));
	  } else {
	    str = str.split('\\,').join('__ESC_COMMA__');
	    return map(braces(str, arr, opts), function(ele) {
	      return ele.split('__ESC_COMMA__').join(',');
	    });
	  }
	}
	
	/**
	 * Regex for common patterns
	 */
	
	function patternRegex() {
	  return /\${|( (?=[{,}])|(?=[{,}]) )|{}|{,}|\\,(?=.*[{}])|\/\.(?=.*[{}])|\\\.(?={)|\\{|\\}/;
	}
	
	/**
	 * Braces regex.
	 */
	
	function braceRegex() {
	  return /.*(\\?\{([^}]+)\})/;
	}
	
	/**
	 * es6 delimiter regex.
	 */
	
	function es6Regex() {
	  return /\$\{([^}]+)\}/;
	}
	
	var braceRe;
	var patternRe;
	
	/**
	 * Faster alternative to `String.replace()` when the
	 * index of the token to be replaces can't be supplied
	 */
	
	function splice(str, token, replacement) {
	  var i = str.indexOf(token);
	  return str.substr(0, i) + replacement
	    + str.substr(i + token.length);
	}
	
	/**
	 * Fast array map
	 */
	
	function map(arr, fn) {
	  if (arr == null) {
	    return [];
	  }
	
	  var len = arr.length;
	  var res = new Array(len);
	  var i = -1;
	
	  while (++i < len) {
	    res[i] = fn(arr[i], i, arr);
	  }
	
	  return res;
	}
	
	/**
	 * Fast array filter
	 */
	
	function filter(arr, cb) {
	  if (arr == null) return [];
	  if (typeof cb !== 'function') {
	    throw new TypeError('braces: filter expects a callback function.');
	  }
	
	  var len = arr.length;
	  var res = arr.slice();
	  var i = 0;
	
	  while (len--) {
	    if (!cb(arr[len], i++)) {
	      res.splice(len, 1);
	    }
	  }
	  return res;
	}


/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * expand-range <https://github.com/jonschlinkert/expand-range>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT license.
	 */
	
	'use strict';
	
	var fill = __webpack_require__(231);
	
	module.exports = function expandRange(str, options, fn) {
	  if (typeof str !== 'string') {
	    throw new TypeError('expand-range expects a string.');
	  }
	
	  if (typeof options === 'function') {
	    fn = options;
	    options = {};
	  }
	
	  if (typeof options === 'boolean') {
	    options = {};
	    options.makeRe = true;
	  }
	
	  // create arguments to pass to fill-range
	  var opts = options || {};
	  var args = str.split('..');
	  var len = args.length;
	  if (len > 3) { return str; }
	
	  // if only one argument, it can't expand so return it
	  if (len === 1) { return args; }
	
	  // if `true`, tell fill-range to regexify the string
	  if (typeof fn === 'boolean' && fn === true) {
	    opts.makeRe = true;
	  }
	
	  args.push(opts);
	  return fill.apply(null, args.concat(fn));
	};


/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * fill-range <https://github.com/jonschlinkert/fill-range>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	var isObject = __webpack_require__(232);
	var isNumber = __webpack_require__(234);
	var randomize = __webpack_require__(237);
	var repeatStr = __webpack_require__(238);
	var repeat = __webpack_require__(239);
	
	/**
	 * Expose `fillRange`
	 */
	
	module.exports = fillRange;
	
	/**
	 * Return a range of numbers or letters.
	 *
	 * @param  {String} `a` Start of the range
	 * @param  {String} `b` End of the range
	 * @param  {String} `step` Increment or decrement to use.
	 * @param  {Function} `fn` Custom function to modify each element in the range.
	 * @return {Array}
	 */
	
	function fillRange(a, b, step, options, fn) {
	  if (a == null || b == null) {
	    throw new Error('fill-range expects the first and second args to be strings.');
	  }
	
	  if (typeof step === 'function') {
	    fn = step; options = {}; step = null;
	  }
	
	  if (typeof options === 'function') {
	    fn = options; options = {};
	  }
	
	  if (isObject(step)) {
	    options = step; step = '';
	  }
	
	  var expand, regex = false, sep = '';
	  var opts = options || {};
	
	  if (typeof opts.silent === 'undefined') {
	    opts.silent = true;
	  }
	
	  step = step || opts.step;
	
	  // store a ref to unmodified arg
	  var origA = a, origB = b;
	
	  b = (b.toString() === '-0') ? 0 : b;
	
	  if (opts.optimize || opts.makeRe) {
	    step = step ? (step += '~') : step;
	    expand = true;
	    regex = true;
	    sep = '~';
	  }
	
	  // handle special step characters
	  if (typeof step === 'string') {
	    var match = stepRe().exec(step);
	
	    if (match) {
	      var i = match.index;
	      var m = match[0];
	
	      // repeat string
	      if (m === '+') {
	        return repeat(a, b);
	
	      // randomize a, `b` times
	      } else if (m === '?') {
	        return [randomize(a, b)];
	
	      // expand right, no regex reduction
	      } else if (m === '>') {
	        step = step.substr(0, i) + step.substr(i + 1);
	        expand = true;
	
	      // expand to an array, or if valid create a reduced
	      // string for a regex logic `or`
	      } else if (m === '|') {
	        step = step.substr(0, i) + step.substr(i + 1);
	        expand = true;
	        regex = true;
	        sep = m;
	
	      // expand to an array, or if valid create a reduced
	      // string for a regex range
	      } else if (m === '~') {
	        step = step.substr(0, i) + step.substr(i + 1);
	        expand = true;
	        regex = true;
	        sep = m;
	      }
	    } else if (!isNumber(step)) {
	      if (!opts.silent) {
	        throw new TypeError('fill-range: invalid step.');
	      }
	      return null;
	    }
	  }
	
	  if (/[.&*()[\]^%$#@!]/.test(a) || /[.&*()[\]^%$#@!]/.test(b)) {
	    if (!opts.silent) {
	      throw new RangeError('fill-range: invalid range arguments.');
	    }
	    return null;
	  }
	
	  // has neither a letter nor number, or has both letters and numbers
	  // this needs to be after the step logic
	  if (!noAlphaNum(a) || !noAlphaNum(b) || hasBoth(a) || hasBoth(b)) {
	    if (!opts.silent) {
	      throw new RangeError('fill-range: invalid range arguments.');
	    }
	    return null;
	  }
	
	  // validate arguments
	  var isNumA = isNumber(zeros(a));
	  var isNumB = isNumber(zeros(b));
	
	  if ((!isNumA && isNumB) || (isNumA && !isNumB)) {
	    if (!opts.silent) {
	      throw new TypeError('fill-range: first range argument is incompatible with second.');
	    }
	    return null;
	  }
	
	  // by this point both are the same, so we
	  // can use A to check going forward.
	  var isNum = isNumA;
	  var num = formatStep(step);
	
	  // is the range alphabetical? or numeric?
	  if (isNum) {
	    // if numeric, coerce to an integer
	    a = +a; b = +b;
	  } else {
	    // otherwise, get the charCode to expand alpha ranges
	    a = a.charCodeAt(0);
	    b = b.charCodeAt(0);
	  }
	
	  // is the pattern descending?
	  var isDescending = a > b;
	
	  // don't create a character class if the args are < 0
	  if (a < 0 || b < 0) {
	    expand = false;
	    regex = false;
	  }
	
	  // detect padding
	  var padding = isPadded(origA, origB);
	  var res, pad, arr = [];
	  var ii = 0;
	
	  // character classes, ranges and logical `or`
	  if (regex) {
	    if (shouldExpand(a, b, num, isNum, padding, opts)) {
	      // make sure the correct separator is used
	      if (sep === '|' || sep === '~') {
	        sep = detectSeparator(a, b, num, isNum, isDescending);
	      }
	      return wrap([origA, origB], sep, opts);
	    }
	  }
	
	  while (isDescending ? (a >= b) : (a <= b)) {
	    if (padding && isNum) {
	      pad = padding(a);
	    }
	
	    // custom function
	    if (typeof fn === 'function') {
	      res = fn(a, isNum, pad, ii++);
	
	    // letters
	    } else if (!isNum) {
	      if (regex && isInvalidChar(a)) {
	        res = null;
	      } else {
	        res = String.fromCharCode(a);
	      }
	
	    // numbers
	    } else {
	      res = formatPadding(a, pad);
	    }
	
	    // add result to the array, filtering any nulled values
	    if (res !== null) arr.push(res);
	
	    // increment or decrement
	    if (isDescending) {
	      a -= num;
	    } else {
	      a += num;
	    }
	  }
	
	  // now that the array is expanded, we need to handle regex
	  // character classes, ranges or logical `or` that wasn't
	  // already handled before the loop
	  if ((regex || expand) && !opts.noexpand) {
	    // make sure the correct separator is used
	    if (sep === '|' || sep === '~') {
	      sep = detectSeparator(a, b, num, isNum, isDescending);
	    }
	    if (arr.length === 1 || a < 0 || b < 0) { return arr; }
	    return wrap(arr, sep, opts);
	  }
	
	  return arr;
	}
	
	/**
	 * Wrap the string with the correct regex
	 * syntax.
	 */
	
	function wrap(arr, sep, opts) {
	  if (sep === '~') { sep = '-'; }
	  var str = arr.join(sep);
	  var pre = opts && opts.regexPrefix;
	
	  // regex logical `or`
	  if (sep === '|') {
	    str = pre ? pre + str : str;
	    str = '(' + str + ')';
	  }
	
	  // regex character class
	  if (sep === '-') {
	    str = (pre && pre === '^')
	      ? pre + str
	      : str;
	    str = '[' + str + ']';
	  }
	  return [str];
	}
	
	/**
	 * Check for invalid characters
	 */
	
	function isCharClass(a, b, step, isNum, isDescending) {
	  if (isDescending) { return false; }
	  if (isNum) { return a <= 9 && b <= 9; }
	  if (a < b) { return step === 1; }
	  return false;
	}
	
	/**
	 * Detect the correct separator to use
	 */
	
	function shouldExpand(a, b, num, isNum, padding, opts) {
	  if (isNum && (a > 9 || b > 9)) { return false; }
	  return !padding && num === 1 && a < b;
	}
	
	/**
	 * Detect the correct separator to use
	 */
	
	function detectSeparator(a, b, step, isNum, isDescending) {
	  var isChar = isCharClass(a, b, step, isNum, isDescending);
	  if (!isChar) {
	    return '|';
	  }
	  return '~';
	}
	
	/**
	 * Correctly format the step based on type
	 */
	
	function formatStep(step) {
	  return Math.abs(step >> 0) || 1;
	}
	
	/**
	 * Format padding, taking leading `-` into account
	 */
	
	function formatPadding(ch, pad) {
	  var res = pad ? pad + ch : ch;
	  if (pad && ch.toString().charAt(0) === '-') {
	    res = '-' + pad + ch.toString().substr(1);
	  }
	  return res.toString();
	}
	
	/**
	 * Check for invalid characters
	 */
	
	function isInvalidChar(str) {
	  var ch = toStr(str);
	  return ch === '\\'
	    || ch === '['
	    || ch === ']'
	    || ch === '^'
	    || ch === '('
	    || ch === ')'
	    || ch === '`';
	}
	
	/**
	 * Convert to a string from a charCode
	 */
	
	function toStr(ch) {
	  return String.fromCharCode(ch);
	}
	
	
	/**
	 * Step regex
	 */
	
	function stepRe() {
	  return /\?|>|\||\+|\~/g;
	}
	
	/**
	 * Return true if `val` has either a letter
	 * or a number
	 */
	
	function noAlphaNum(val) {
	  return /[a-z0-9]/i.test(val);
	}
	
	/**
	 * Return true if `val` has both a letter and
	 * a number (invalid)
	 */
	
	function hasBoth(val) {
	  return /[a-z][0-9]|[0-9][a-z]/i.test(val);
	}
	
	/**
	 * Normalize zeros for checks
	 */
	
	function zeros(val) {
	  if (/^-*0+$/.test(val.toString())) {
	    return '0';
	  }
	  return val;
	}
	
	/**
	 * Return true if `val` has leading zeros,
	 * or a similar valid pattern.
	 */
	
	function hasZeros(val) {
	  return /[^.]\.|^-*0+[0-9]/.test(val);
	}
	
	/**
	 * If the string is padded, returns a curried function with
	 * the a cached padding string, or `false` if no padding.
	 *
	 * @param  {*} `origA` String or number.
	 * @return {String|Boolean}
	 */
	
	function isPadded(origA, origB) {
	  if (hasZeros(origA) || hasZeros(origB)) {
	    var alen = length(origA);
	    var blen = length(origB);
	
	    var len = alen >= blen
	      ? alen
	      : blen;
	
	    return function (a) {
	      return repeatStr('0', len - length(a));
	    };
	  }
	  return false;
	}
	
	/**
	 * Get the string length of `val`
	 */
	
	function length(val) {
	  return val.toString().length;
	}


/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * isobject <https://github.com/jonschlinkert/isobject>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	var isArray = __webpack_require__(233);
	
	module.exports = function isObject(val) {
	  return val != null && typeof val === 'object' && isArray(val) === false;
	};


/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(3))(146);

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * is-number <https://github.com/jonschlinkert/is-number>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	var typeOf = __webpack_require__(235);
	
	module.exports = function isNumber(num) {
	  var type = typeOf(num);
	  if (type !== 'number' && type !== 'string') {
	    return false;
	  }
	  var n = +num;
	  return (n - n + 1) >= 0 && num !== '';
	};


/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var isBuffer = __webpack_require__(236);
	var toString = Object.prototype.toString;
	
	/**
	 * Get the native `typeof` a value.
	 *
	 * @param  {*} `val`
	 * @return {*} Native javascript type
	 */
	
	module.exports = function kindOf(val) {
	  // primitivies
	  if (typeof val === 'undefined') {
	    return 'undefined';
	  }
	  if (val === null) {
	    return 'null';
	  }
	  if (val === true || val === false || val instanceof Boolean) {
	    return 'boolean';
	  }
	  if (typeof val === 'string' || val instanceof String) {
	    return 'string';
	  }
	  if (typeof val === 'number' || val instanceof Number) {
	    return 'number';
	  }
	
	  // functions
	  if (typeof val === 'function' || val instanceof Function) {
	    return 'function';
	  }
	
	  // array
	  if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
	    return 'array';
	  }
	
	  // check for instances of RegExp and Date before calling `toString`
	  if (val instanceof RegExp) {
	    return 'regexp';
	  }
	  if (val instanceof Date) {
	    return 'date';
	  }
	
	  // other objects
	  var type = toString.call(val);
	
	  if (type === '[object RegExp]') {
	    return 'regexp';
	  }
	  if (type === '[object Date]') {
	    return 'date';
	  }
	  if (type === '[object Arguments]') {
	    return 'arguments';
	  }
	  if (type === '[object Error]') {
	    return 'error';
	  }
	
	  // buffer
	  if (typeof Buffer !== 'undefined' && isBuffer(val)) {
	    return 'buffer';
	  }
	
	  // es6: Map, WeakMap, Set, WeakSet
	  if (type === '[object Set]') {
	    return 'set';
	  }
	  if (type === '[object WeakSet]') {
	    return 'weakset';
	  }
	  if (type === '[object Map]') {
	    return 'map';
	  }
	  if (type === '[object WeakMap]') {
	    return 'weakmap';
	  }
	  if (type === '[object Symbol]') {
	    return 'symbol';
	  }
	
	  // typed arrays
	  if (type === '[object Int8Array]') {
	    return 'int8array';
	  }
	  if (type === '[object Uint8Array]') {
	    return 'uint8array';
	  }
	  if (type === '[object Uint8ClampedArray]') {
	    return 'uint8clampedarray';
	  }
	  if (type === '[object Int16Array]') {
	    return 'int16array';
	  }
	  if (type === '[object Uint16Array]') {
	    return 'uint16array';
	  }
	  if (type === '[object Int32Array]') {
	    return 'int32array';
	  }
	  if (type === '[object Uint32Array]') {
	    return 'uint32array';
	  }
	  if (type === '[object Float32Array]') {
	    return 'float32array';
	  }
	  if (type === '[object Float64Array]') {
	    return 'float64array';
	  }
	
	  // must be a plain object
	  return 'object';
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7).Buffer))

/***/ },
/* 236 */
/***/ function(module, exports) {

	/*!
	 * Determine if an object is a Buffer
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	
	// The _isBuffer check is for Safari 5-7 support, because it's missing
	// Object.prototype.constructor. Remove this eventually
	module.exports = function (obj) {
	  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
	}
	
	function isBuffer (obj) {
	  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
	}
	
	// For Node v0.10 support. Remove this eventually.
	function isSlowBuffer (obj) {
	  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
	}


/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * randomatic <https://github.com/jonschlinkert/randomatic>
	 *
	 * This was originally inspired by <http://stackoverflow.com/a/10727155/1267639>
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License (MIT)
	 */
	
	'use strict';
	
	var isNumber = __webpack_require__(234);
	var typeOf = __webpack_require__(235);
	
	/**
	 * Expose `randomatic`
	 */
	
	module.exports = randomatic;
	
	/**
	 * Available mask characters
	 */
	
	var type = {
	  lower: 'abcdefghijklmnopqrstuvwxyz',
	  upper: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
	  number: '0123456789',
	  special: '~!@#$%^&()_+-={}[];\',.'
	};
	
	type.all = type.lower + type.upper + type.number;
	
	/**
	 * Generate random character sequences of a specified `length`,
	 * based on the given `pattern`.
	 *
	 * @param {String} `pattern` The pattern to use for generating the random string.
	 * @param {String} `length` The length of the string to generate.
	 * @param {String} `options`
	 * @return {String}
	 * @api public
	 */
	
	function randomatic(pattern, length, options) {
	  if (typeof pattern === 'undefined') {
	    throw new Error('randomatic expects a string or number.');
	  }
	
	  var custom = false;
	  if (arguments.length === 1) {
	    if (typeof pattern === 'string') {
	      length = pattern.length;
	
	    } else if (isNumber(pattern)) {
	      options = {}; length = pattern; pattern = '*';
	    }
	  }
	
	  if (typeOf(length) === 'object' && length.hasOwnProperty('chars')) {
	    options = length;
	    pattern = options.chars;
	    length = pattern.length;
	    custom = true;
	  }
	
	  var opts = options || {};
	  var mask = '';
	  var res = '';
	
	  // Characters to be used
	  if (pattern.indexOf('?') !== -1) mask += opts.chars;
	  if (pattern.indexOf('a') !== -1) mask += type.lower;
	  if (pattern.indexOf('A') !== -1) mask += type.upper;
	  if (pattern.indexOf('0') !== -1) mask += type.number;
	  if (pattern.indexOf('!') !== -1) mask += type.special;
	  if (pattern.indexOf('*') !== -1) mask += type.all;
	  if (custom) mask += pattern;
	
	  while (length--) {
	    res += mask.charAt(parseInt(Math.random() * mask.length, 10));
	  }
	  return res;
	};


/***/ },
/* 238 */
/***/ function(module, exports) {

	/*!
	 * repeat-string <https://github.com/jonschlinkert/repeat-string>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	/**
	 * Results cache
	 */
	
	var res = '';
	var cache;
	
	/**
	 * Expose `repeat`
	 */
	
	module.exports = repeat;
	
	/**
	 * Repeat the given `string` the specified `number`
	 * of times.
	 *
	 * **Example:**
	 *
	 * ```js
	 * var repeat = require('repeat-string');
	 * repeat('A', 5);
	 * //=> AAAAA
	 * ```
	 *
	 * @param {String} `string` The string to repeat
	 * @param {Number} `number` The number of times to repeat the string
	 * @return {String} Repeated string
	 * @api public
	 */
	
	function repeat(str, num) {
	  if (typeof str !== 'string') {
	    throw new TypeError('expected a string');
	  }
	
	  // cover common, quick use cases
	  if (num === 1) return str;
	  if (num === 2) return str + str;
	
	  var max = str.length * num;
	  if (cache !== str || typeof cache === 'undefined') {
	    cache = str;
	    res = '';
	  } else if (res.length >= max) {
	    return res.substr(0, max);
	  }
	
	  while (max > res.length && num > 1) {
	    if (num & 1) {
	      res += str;
	    }
	
	    num >>= 1;
	    str += str;
	  }
	
	  res += str;
	  res = res.substr(0, max);
	  return res;
	}


/***/ },
/* 239 */
/***/ function(module, exports) {

	/*!
	 * repeat-element <https://github.com/jonschlinkert/repeat-element>
	 *
	 * Copyright (c) 2015 Jon Schlinkert.
	 * Licensed under the MIT license.
	 */
	
	'use strict';
	
	module.exports = function repeat(ele, num) {
	  var arr = new Array(num);
	
	  for (var i = 0; i < num; i++) {
	    arr[i] = ele;
	  }
	
	  return arr;
	};


/***/ },
/* 240 */
/***/ function(module, exports) {

	/*!
	 * preserve <https://github.com/jonschlinkert/preserve>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT license.
	 */
	
	'use strict';
	
	/**
	 * Replace tokens in `str` with a temporary, heuristic placeholder.
	 *
	 * ```js
	 * tokens.before('{a\\,b}');
	 * //=> '{__ID1__}'
	 * ```
	 *
	 * @param  {String} `str`
	 * @return {String} String with placeholders.
	 * @api public
	 */
	
	exports.before = function before(str, re) {
	  return str.replace(re, function (match) {
	    var id = randomize();
	    cache[id] = match;
	    return '__ID' + id + '__';
	  });
	};
	
	/**
	 * Replace placeholders in `str` with original tokens.
	 *
	 * ```js
	 * tokens.after('{__ID1__}');
	 * //=> '{a\\,b}'
	 * ```
	 *
	 * @param  {String} `str` String with placeholders
	 * @return {String} `str` String with original tokens.
	 * @api public
	 */
	
	exports.after = function after(str) {
	  return str.replace(/__ID(.{5})__/g, function (_, id) {
	    return cache[id];
	  });
	};
	
	function randomize() {
	  return Math.random().toString().slice(2, 7);
	}
	
	var cache = {};

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * expand-brackets <https://github.com/jonschlinkert/expand-brackets>
	 *
	 * Copyright (c) 2015 Jon Schlinkert.
	 * Licensed under the MIT license.
	 */
	
	'use strict';
	
	var isPosixBracket = __webpack_require__(242);
	
	/**
	 * POSIX character classes
	 */
	
	var POSIX = {
	  alnum: 'a-zA-Z0-9',
	  alpha: 'a-zA-Z',
	  blank: ' \\t',
	  cntrl: '\\x00-\\x1F\\x7F',
	  digit: '0-9',
	  graph: '\\x21-\\x7E',
	  lower: 'a-z',
	  print: '\\x20-\\x7E',
	  punct: '-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
	  space: ' \\t\\r\\n\\v\\f',
	  upper: 'A-Z',
	  word:  'A-Za-z0-9_',
	  xdigit: 'A-Fa-f0-9',
	};
	
	/**
	 * Expose `brackets`
	 */
	
	module.exports = brackets;
	
	function brackets(str) {
	  if (!isPosixBracket(str)) {
	    return str;
	  }
	
	  var negated = false;
	  if (str.indexOf('[^') !== -1) {
	    negated = true;
	    str = str.split('[^').join('[');
	  }
	  if (str.indexOf('[!') !== -1) {
	    negated = true;
	    str = str.split('[!').join('[');
	  }
	
	  var a = str.split('[');
	  var b = str.split(']');
	  var imbalanced = a.length !== b.length;
	
	  var parts = str.split(/(?::\]\[:|\[?\[:|:\]\]?)/);
	  var len = parts.length, i = 0;
	  var end = '', beg = '';
	  var res = [];
	
	  // start at the end (innermost) first
	  while (len--) {
	    var inner = parts[i++];
	    if (inner === '^[!' || inner === '[!') {
	      inner = '';
	      negated = true;
	    }
	
	    var prefix = negated ? '^' : '';
	    var ch = POSIX[inner];
	
	    if (ch) {
	      res.push('[' + prefix + ch + ']');
	    } else if (inner) {
	      if (/^\[?\w-\w\]?$/.test(inner)) {
	        if (i === parts.length) {
	          res.push('[' + prefix + inner);
	        } else if (i === 1) {
	          res.push(prefix + inner + ']');
	        } else {
	          res.push(prefix + inner);
	        }
	      } else {
	        if (i === 1) {
	          beg += inner;
	        } else if (i === parts.length) {
	          end += inner;
	        } else {
	          res.push('[' + prefix + inner + ']');
	        }
	      }
	    }
	  }
	
	  var result = res.join('|');
	  var rlen = res.length || 1;
	  if (rlen > 1) {
	    result = '(?:' + result + ')';
	    rlen = 1;
	  }
	  if (beg) {
	    rlen++;
	    if (beg.charAt(0) === '[') {
	      if (imbalanced) {
	        beg = '\\[' + beg.slice(1);
	      } else {
	        beg += ']';
	      }
	    }
	    result = beg + result;
	  }
	  if (end) {
	    rlen++;
	    if (end.slice(-1) === ']') {
	      if (imbalanced) {
	        end = end.slice(0, end.length - 1) + '\\]';
	      } else {
	        end = '[' + end;
	      }
	    }
	    result += end;
	  }
	
	  if (rlen > 1) {
	    result = result.split('][').join(']|[');
	    if (result.indexOf('|') !== -1 && !/\(\?/.test(result)) {
	      result = '(?:' + result + ')';
	    }
	  }
	
	  result = result.replace(/\[+=|=\]+/g, '\\b');
	  return result;
	}
	
	brackets.makeRe = function(pattern) {
	  try {
	    return new RegExp(brackets(pattern));
	  } catch (err) {}
	};
	
	brackets.isMatch = function(str, pattern) {
	  try {
	    return brackets.makeRe(pattern).test(str);
	  } catch (err) {
	    return false;
	  }
	};
	
	brackets.match = function(arr, pattern) {
	  var len = arr.length, i = 0;
	  var res = arr.slice();
	
	  var re = brackets.makeRe(pattern);
	  while (i < len) {
	    var ele = arr[i++];
	    if (!re.test(ele)) {
	      continue;
	    }
	    res.splice(i, 1);
	  }
	  return res;
	};


/***/ },
/* 242 */
/***/ function(module, exports) {

	/*!
	 * is-posix-bracket <https://github.com/jonschlinkert/is-posix-bracket>
	 *
	 * Copyright (c) 2015-2016, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	module.exports = function isPosixBracket(str) {
	  return typeof str === 'string' && /\[([:.=+])(?:[^\[\]]|)+\1\]/.test(str);
	};


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * extglob <https://github.com/jonschlinkert/extglob>
	 *
	 * Copyright (c) 2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	/**
	 * Module dependencies
	 */
	
	var isExtglob = __webpack_require__(244);
	var re, cache = {};
	
	/**
	 * Expose `extglob`
	 */
	
	module.exports = extglob;
	
	/**
	 * Convert the given extglob `string` to a regex-compatible
	 * string.
	 *
	 * ```js
	 * var extglob = require('extglob');
	 * extglob('!(a?(b))');
	 * //=> '(?!a(?:b)?)[^/]*?'
	 * ```
	 *
	 * @param {String} `str` The string to convert.
	 * @param {Object} `options`
	 *   @option {Boolean} [options] `esc` If `false` special characters will not be escaped. Defaults to `true`.
	 *   @option {Boolean} [options] `regex` If `true` a regular expression is returned instead of a string.
	 * @return {String}
	 * @api public
	 */
	
	
	function extglob(str, opts) {
	  opts = opts || {};
	  var o = {}, i = 0;
	
	  // fix common character reversals
	  // '*!(.js)' => '*.!(js)'
	  str = str.replace(/!\(([^\w*()])/g, '$1!(');
	
	  // support file extension negation
	  str = str.replace(/([*\/])\.!\([*]\)/g, function (m, ch) {
	    if (ch === '/') {
	      return escape('\\/[^.]+');
	    }
	    return escape('[^.]+');
	  });
	
	  // create a unique key for caching by
	  // combining the string and options
	  var key = str
	    + String(!!opts.regex)
	    + String(!!opts.contains)
	    + String(!!opts.escape);
	
	  if (cache.hasOwnProperty(key)) {
	    return cache[key];
	  }
	
	  if (!(re instanceof RegExp)) {
	    re = regex();
	  }
	
	  opts.negate = false;
	  var m;
	
	  while (m = re.exec(str)) {
	    var prefix = m[1];
	    var inner = m[3];
	    if (prefix === '!') {
	      opts.negate = true;
	    }
	
	    var id = '__EXTGLOB_' + (i++) + '__';
	    // use the prefix of the _last_ (outtermost) pattern
	    o[id] = wrap(inner, prefix, opts.escape);
	    str = str.split(m[0]).join(id);
	  }
	
	  var keys = Object.keys(o);
	  var len = keys.length;
	
	  // we have to loop again to allow us to convert
	  // patterns in reverse order (starting with the
	  // innermost/last pattern first)
	  while (len--) {
	    var prop = keys[len];
	    str = str.split(prop).join(o[prop]);
	  }
	
	  var result = opts.regex
	    ? toRegex(str, opts.contains, opts.negate)
	    : str;
	
	  result = result.split('.').join('\\.');
	
	  // cache the result and return it
	  return (cache[key] = result);
	}
	
	/**
	 * Convert `string` to a regex string.
	 *
	 * @param  {String} `str`
	 * @param  {String} `prefix` Character that determines how to wrap the string.
	 * @param  {Boolean} `esc` If `false` special characters will not be escaped. Defaults to `true`.
	 * @return {String}
	 */
	
	function wrap(inner, prefix, esc) {
	  if (esc) inner = escape(inner);
	
	  switch (prefix) {
	    case '!':
	      return '(?!' + inner + ')[^/]' + (esc ? '%%%~' : '*?');
	    case '@':
	      return '(?:' + inner + ')';
	    case '+':
	      return '(?:' + inner + ')+';
	    case '*':
	      return '(?:' + inner + ')' + (esc ? '%%' : '*')
	    case '?':
	      return '(?:' + inner + '|)';
	    default:
	      return inner;
	  }
	}
	
	function escape(str) {
	  str = str.split('*').join('[^/]%%%~');
	  str = str.split('.').join('\\.');
	  return str;
	}
	
	/**
	 * extglob regex.
	 */
	
	function regex() {
	  return /(\\?[@?!+*$]\\?)(\(([^()]*?)\))/;
	}
	
	/**
	 * Negation regex
	 */
	
	function negate(str) {
	  return '(?!^' + str + ').*$';
	}
	
	/**
	 * Create the regex to do the matching. If
	 * the leading character in the `pattern` is `!`
	 * a negation regex is returned.
	 *
	 * @param {String} `pattern`
	 * @param {Boolean} `contains` Allow loose matching.
	 * @param {Boolean} `isNegated` True if the pattern is a negation pattern.
	 */
	
	function toRegex(pattern, contains, isNegated) {
	  var prefix = contains ? '^' : '';
	  var after = contains ? '$' : '';
	  pattern = ('(?:' + pattern + ')' + after);
	  if (isNegated) {
	    pattern = prefix + negate(pattern);
	  }
	  return new RegExp(prefix + pattern);
	}


/***/ },
/* 244 */
/***/ function(module, exports) {

	/*!
	 * is-extglob <https://github.com/jonschlinkert/is-extglob>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	module.exports = function isExtglob(str) {
	  return typeof str === 'string'
	    && /[@?!+*]\(/.test(str);
	};


/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * is-glob <https://github.com/jonschlinkert/is-glob>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	var isExtglob = __webpack_require__(244);
	
	module.exports = function isGlob(str) {
	  return typeof str === 'string'
	    && (/[*!?{}(|)[\]]/.test(str)
	     || isExtglob(str));
	};

/***/ },
/* 246 */
/***/ function(module, exports) {

	/*!
	 * normalize-path <https://github.com/jonschlinkert/normalize-path>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License
	 */
	
	module.exports = function normalizePath(str, stripTrailing) {
	  if (typeof str !== 'string') {
	    throw new TypeError('expected a string');
	  }
	  str = str.replace(/[\\\/]+/g, '/');
	  if (stripTrailing !== false) {
	    str = str.replace(/\/$/, '');
	  }
	  return str;
	};


/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * object.omit <https://github.com/jonschlinkert/object.omit>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	var isObject = __webpack_require__(248);
	var forOwn = __webpack_require__(249);
	
	module.exports = function omit(obj, keys) {
	  if (!isObject(obj)) return {};
	
	  keys = [].concat.apply([], [].slice.call(arguments, 1));
	  var last = keys[keys.length - 1];
	  var res = {}, fn;
	
	  if (typeof last === 'function') {
	    fn = keys.pop();
	  }
	
	  var isFunction = typeof fn === 'function';
	  if (!keys.length && !isFunction) {
	    return obj;
	  }
	
	  forOwn(obj, function(value, key) {
	    if (keys.indexOf(key) === -1) {
	
	      if (!isFunction) {
	        res[key] = value;
	      } else if (fn(value, key, obj)) {
	        res[key] = value;
	      }
	    }
	  });
	  return res;
	};


/***/ },
/* 248 */
/***/ function(module, exports) {

	/*!
	 * is-extendable <https://github.com/jonschlinkert/is-extendable>
	 *
	 * Copyright (c) 2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	module.exports = function isExtendable(val) {
	  return typeof val !== 'undefined' && val !== null
	    && (typeof val === 'object' || typeof val === 'function');
	};


/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * for-own <https://github.com/jonschlinkert/for-own>
	 *
	 * Copyright (c) 2014-2016, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	var forIn = __webpack_require__(250);
	var hasOwn = Object.prototype.hasOwnProperty;
	
	module.exports = function forOwn(o, fn, thisArg) {
	  forIn(o, function(val, key) {
	    if (hasOwn.call(o, key)) {
	      return fn.call(thisArg, o[key], key, o);
	    }
	  });
	};


/***/ },
/* 250 */
/***/ function(module, exports) {

	/*!
	 * for-in <https://github.com/jonschlinkert/for-in>
	 *
	 * Copyright (c) 2014-2016, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	module.exports = function forIn(o, fn, thisArg) {
	  for (var key in o) {
	    if (fn.call(thisArg, o[key], key, o) === false) {
	      break;
	    }
	  }
	};


/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * parse-glob <https://github.com/jonschlinkert/parse-glob>
	 *
	 * Copyright (c) 2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	var isGlob = __webpack_require__(245);
	var findBase = __webpack_require__(252);
	var extglob = __webpack_require__(244);
	var dotfile = __webpack_require__(254);
	
	/**
	 * Expose `cache`
	 */
	
	var cache = module.exports.cache = {};
	
	/**
	 * Parse a glob pattern into tokens.
	 *
	 * When no paths or '**' are in the glob, we use a
	 * different strategy for parsing the filename, since
	 * file names can contain braces and other difficult
	 * patterns. such as:
	 *
	 *  - `*.{a,b}`
	 *  - `(**|*.js)`
	 */
	
	module.exports = function parseGlob(glob) {
	  if (cache.hasOwnProperty(glob)) {
	    return cache[glob];
	  }
	
	  var tok = {};
	  tok.orig = glob;
	  tok.is = {};
	
	  // unescape dots and slashes in braces/brackets
	  glob = escape(glob);
	
	  var parsed = findBase(glob);
	  tok.is.glob = parsed.isGlob;
	
	  tok.glob = parsed.glob;
	  tok.base = parsed.base;
	  var segs = /([^\/]*)$/.exec(glob);
	
	  tok.path = {};
	  tok.path.dirname = '';
	  tok.path.basename = segs[1] || '';
	  tok.path.dirname = glob.split(tok.path.basename).join('') || '';
	  var basename = (tok.path.basename || '').split('.') || '';
	  tok.path.filename = basename[0] || '';
	  tok.path.extname = basename.slice(1).join('.') || '';
	  tok.path.ext = '';
	
	  if (isGlob(tok.path.dirname) && !tok.path.basename) {
	    if (!/\/$/.test(tok.glob)) {
	      tok.path.basename = tok.glob;
	    }
	    tok.path.dirname = tok.base;
	  }
	
	  if (glob.indexOf('/') === -1 && !tok.is.globstar) {
	    tok.path.dirname = '';
	    tok.path.basename = tok.orig;
	  }
	
	  var dot = tok.path.basename.indexOf('.');
	  if (dot !== -1) {
	    tok.path.filename = tok.path.basename.slice(0, dot);
	    tok.path.extname = tok.path.basename.slice(dot);
	  }
	
	  if (tok.path.extname.charAt(0) === '.') {
	    var exts = tok.path.extname.split('.');
	    tok.path.ext = exts[exts.length - 1];
	  }
	
	  // unescape dots and slashes in braces/brackets
	  tok.glob = unescape(tok.glob);
	  tok.path.dirname = unescape(tok.path.dirname);
	  tok.path.basename = unescape(tok.path.basename);
	  tok.path.filename = unescape(tok.path.filename);
	  tok.path.extname = unescape(tok.path.extname);
	
	  // Booleans
	  var is = (glob && tok.is.glob);
	  tok.is.negated  = glob && glob.charAt(0) === '!';
	  tok.is.extglob  = glob && extglob(glob);
	  tok.is.braces   = has(is, glob, '{');
	  tok.is.brackets = has(is, glob, '[:');
	  tok.is.globstar = has(is, glob, '**');
	  tok.is.dotfile  = dotfile(tok.path.basename) || dotfile(tok.path.filename);
	  tok.is.dotdir   = dotdir(tok.path.dirname);
	  return (cache[glob] = tok);
	}
	
	/**
	 * Returns true if the glob matches dot-directories.
	 *
	 * @param  {Object} `tok` The tokens object
	 * @param  {Object} `path` The path object
	 * @return {Object}
	 */
	
	function dotdir(base) {
	  if (base.indexOf('/.') !== -1) {
	    return true;
	  }
	  if (base.charAt(0) === '.' && base.charAt(1) !== '/') {
	    return true;
	  }
	  return false;
	}
	
	/**
	 * Returns true if the pattern has the given `ch`aracter(s)
	 *
	 * @param  {Object} `glob` The glob pattern.
	 * @param  {Object} `ch` The character to test for
	 * @return {Object}
	 */
	
	function has(is, glob, ch) {
	  return is && glob.indexOf(ch) !== -1;
	}
	
	/**
	 * Escape/unescape utils
	 */
	
	function escape(str) {
	  var re = /\{([^{}]*?)}|\(([^()]*?)\)|\[([^\[\]]*?)\]/g;
	  return str.replace(re, function (outter, braces, parens, brackets) {
	    var inner = braces || parens || brackets;
	    if (!inner) { return outter; }
	    return outter.split(inner).join(esc(inner));
	  });
	}
	
	function esc(str) {
	  str = str.split('/').join('__SLASH__');
	  str = str.split('.').join('__DOT__');
	  return str;
	}
	
	function unescape(str) {
	  str = str.split('__SLASH__').join('/');
	  str = str.split('__DOT__').join('.');
	  return str;
	}


/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * glob-base <https://github.com/jonschlinkert/glob-base>
	 *
	 * Copyright (c) 2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	var path = __webpack_require__(4);
	var parent = __webpack_require__(253);
	var isGlob = __webpack_require__(245);
	
	module.exports = function globBase(pattern) {
	  if (typeof pattern !== 'string') {
	    throw new TypeError('glob-base expects a string.');
	  }
	
	  var res = {};
	  res.base = parent(pattern);
	  res.isGlob = isGlob(pattern);
	
	  if (res.base !== '.') {
	    res.glob = pattern.substr(res.base.length);
	    if (res.glob.charAt(0) === '/') {
	      res.glob = res.glob.substr(1);
	    }
	  } else {
	    res.glob = pattern;
	  }
	
	  if (!res.isGlob) {
	    res.base = dirname(pattern);
	    res.glob = res.base !== '.'
	      ? pattern.substr(res.base.length)
	      : pattern;
	  }
	
	  if (res.glob.substr(0, 2) === './') {
	    res.glob = res.glob.substr(2);
	  }
	  if (res.glob.charAt(0) === '/') {
	    res.glob = res.glob.substr(1);
	  }
	  return res;
	};
	
	function dirname(glob) {
	  if (glob.slice(-1) === '/') return glob;
	  return path.dirname(glob);
	}


/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var path = __webpack_require__(4);
	var isglob = __webpack_require__(245);
	
	module.exports = function globParent(str) {
		str += 'a'; // preserves full path in case of trailing path separator
		do {str = path.dirname(str)} while (isglob(str));
		return str;
	};


/***/ },
/* 254 */
/***/ function(module, exports) {

	/*!
	 * is-dotfile <https://github.com/regexps/is-dotfile>
	 *
	 * Copyright (c) 2015 Jon Schlinkert, contributors.
	 * Licensed under the MIT license.
	 */
	
	module.exports = function(str) {
	  if (str.charCodeAt(0) === 46 /* . */ && str.indexOf('/', 1) === -1) {
	    return true;
	  }
	
	  var last = str.lastIndexOf('/');
	  return last !== -1 ? str.charCodeAt(last + 1) === 46  /* . */ : false;
	};


/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * regex-cache <https://github.com/jonschlinkert/regex-cache>
	 *
	 * Copyright (c) 2015 Jon Schlinkert.
	 * Licensed under the MIT license.
	 */
	
	'use strict';
	
	var isPrimitive = __webpack_require__(256);
	var equal = __webpack_require__(257);
	var basic = {};
	var cache = {};
	
	/**
	 * Expose `regexCache`
	 */
	
	module.exports = regexCache;
	
	/**
	 * Memoize the results of a call to the new RegExp constructor.
	 *
	 * @param  {Function} fn [description]
	 * @param  {String} str [description]
	 * @param  {Options} options [description]
	 * @param  {Boolean} nocompare [description]
	 * @return {RegExp}
	 */
	
	function regexCache(fn, str, opts) {
	  var key = '_default_', regex, cached;
	
	  if (!str && !opts) {
	    if (typeof fn !== 'function') {
	      return fn;
	    }
	    return basic[key] || (basic[key] = fn(str));
	  }
	
	  var isString = typeof str === 'string';
	  if (isString) {
	    if (!opts) {
	      return basic[str] || (basic[str] = fn(str));
	    }
	    key = str;
	  } else {
	    opts = str;
	  }
	
	  cached = cache[key];
	  if (cached && equal(cached.opts, opts)) {
	    return cached.regex;
	  }
	
	  memo(key, opts, (regex = fn(str, opts)));
	  return regex;
	}
	
	function memo(key, opts, regex) {
	  cache[key] = {regex: regex, opts: opts};
	}
	
	/**
	 * Expose `cache`
	 */
	
	module.exports.cache = cache;
	module.exports.basic = basic;


/***/ },
/* 256 */
/***/ function(module, exports) {

	/*!
	 * is-primitive <https://github.com/jonschlinkert/is-primitive>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	// see http://jsperf.com/testing-value-is-primitive/7
	module.exports = function isPrimitive(value) {
	  return value == null || (typeof value !== 'function' && typeof value !== 'object');
	};


/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * is-equal-shallow <https://github.com/jonschlinkert/is-equal-shallow>
	 *
	 * Copyright (c) 2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */
	
	'use strict';
	
	var isPrimitive = __webpack_require__(256);
	
	module.exports = function isEqual(a, b) {
	  if (!a && !b) { return true; }
	  if (!a && b || a && !b) { return false; }
	
	  var numKeysA = 0, numKeysB = 0, key;
	  for (key in b) {
	    numKeysB++;
	    if (!isPrimitive(b[key]) || !a.hasOwnProperty(key) || (a[key] !== b[key])) {
	      return false;
	    }
	  }
	  for (key in a) {
	    numKeysA++;
	  }
	  return numKeysA === numKeysB;
	};


/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var chars = __webpack_require__(259);
	var utils = __webpack_require__(224);
	
	/**
	 * Expose `Glob`
	 */
	
	var Glob = module.exports = function Glob(pattern, options) {
	  if (!(this instanceof Glob)) {
	    return new Glob(pattern, options);
	  }
	  this.options = options || {};
	  this.pattern = pattern;
	  this.history = [];
	  this.tokens = {};
	  this.init(pattern);
	};
	
	/**
	 * Initialize defaults
	 */
	
	Glob.prototype.init = function(pattern) {
	  this.orig = pattern;
	  this.negated = this.isNegated();
	  this.options.track = this.options.track || false;
	  this.options.makeRe = true;
	};
	
	/**
	 * Push a change into `glob.history`. Useful
	 * for debugging.
	 */
	
	Glob.prototype.track = function(msg) {
	  if (this.options.track) {
	    this.history.push({msg: msg, pattern: this.pattern});
	  }
	};
	
	/**
	 * Return true if `glob.pattern` was negated
	 * with `!`, also remove the `!` from the pattern.
	 *
	 * @return {Boolean}
	 */
	
	Glob.prototype.isNegated = function() {
	  if (this.pattern.charCodeAt(0) === 33 /* '!' */) {
	    this.pattern = this.pattern.slice(1);
	    return true;
	  }
	  return false;
	};
	
	/**
	 * Expand braces in the given glob pattern.
	 *
	 * We only need to use the [braces] lib when
	 * patterns are nested.
	 */
	
	Glob.prototype.braces = function() {
	  if (this.options.nobraces !== true && this.options.nobrace !== true) {
	    // naive/fast check for imbalanced characters
	    var a = this.pattern.match(/[\{\(\[]/g);
	    var b = this.pattern.match(/[\}\)\]]/g);
	
	    // if imbalanced, don't optimize the pattern
	    if (a && b && (a.length !== b.length)) {
	      this.options.makeRe = false;
	    }
	
	    // expand brace patterns and join the resulting array
	    var expanded = utils.braces(this.pattern, this.options);
	    this.pattern = expanded.join('|');
	  }
	};
	
	/**
	 * Expand bracket expressions in `glob.pattern`
	 */
	
	Glob.prototype.brackets = function() {
	  if (this.options.nobrackets !== true) {
	    this.pattern = utils.brackets(this.pattern);
	  }
	};
	
	/**
	 * Expand bracket expressions in `glob.pattern`
	 */
	
	Glob.prototype.extglob = function() {
	  if (this.options.noextglob === true) return;
	
	  if (utils.isExtglob(this.pattern)) {
	    this.pattern = utils.extglob(this.pattern, {escape: true});
	  }
	};
	
	/**
	 * Parse the given pattern
	 */
	
	Glob.prototype.parse = function(pattern) {
	  this.tokens = utils.parseGlob(pattern || this.pattern, true);
	  return this.tokens;
	};
	
	/**
	 * Replace `a` with `b`. Also tracks the change before and
	 * after each replacement. This is disabled by default, but
	 * can be enabled by setting `options.track` to true.
	 *
	 * Also, when the pattern is a string, `.split()` is used,
	 * because it's much faster than replace.
	 *
	 * @param  {RegExp|String} `a`
	 * @param  {String} `b`
	 * @param  {Boolean} `escape` When `true`, escapes `*` and `?` in the replacement.
	 * @return {String}
	 */
	
	Glob.prototype._replace = function(a, b, escape) {
	  this.track('before (find): "' + a + '" (replace with): "' + b + '"');
	  if (escape) b = esc(b);
	  if (a && b && typeof a === 'string') {
	    this.pattern = this.pattern.split(a).join(b);
	  } else {
	    this.pattern = this.pattern.replace(a, b);
	  }
	  this.track('after');
	};
	
	/**
	 * Escape special characters in the given string.
	 *
	 * @param  {String} `str` Glob pattern
	 * @return {String}
	 */
	
	Glob.prototype.escape = function(str) {
	  this.track('before escape: ');
	  var re = /["\\](['"]?[^"'\\]['"]?)/g;
	
	  this.pattern = str.replace(re, function($0, $1) {
	    var o = chars.ESC;
	    var ch = o && o[$1];
	    if (ch) {
	      return ch;
	    }
	    if (/[a-z]/i.test($0)) {
	      return $0.split('\\').join('');
	    }
	    return $0;
	  });
	
	  this.track('after escape: ');
	};
	
	/**
	 * Unescape special characters in the given string.
	 *
	 * @param  {String} `str`
	 * @return {String}
	 */
	
	Glob.prototype.unescape = function(str) {
	  var re = /__([A-Z]+)_([A-Z]+)__/g;
	  this.pattern = str.replace(re, function($0, $1) {
	    return chars[$1][$0];
	  });
	  this.pattern = unesc(this.pattern);
	};
	
	/**
	 * Escape/unescape utils
	 */
	
	function esc(str) {
	  str = str.split('?').join('%~');
	  str = str.split('*').join('%%');
	  return str;
	}
	
	function unesc(str) {
	  str = str.split('%~').join('?');
	  str = str.split('%%').join('*');
	  return str;
	}


/***/ },
/* 259 */
/***/ function(module, exports) {

	'use strict';
	
	var chars = {}, unesc, temp;
	
	function reverse(object, prepender) {
	  return Object.keys(object).reduce(function(reversed, key) {
	    var newKey = prepender ? prepender + key : key; // Optionally prepend a string to key.
	    reversed[object[key]] = newKey; // Swap key and value.
	    return reversed; // Return the result.
	  }, {});
	}
	
	/**
	 * Regex for common characters
	 */
	
	chars.escapeRegex = {
	  '?': /\?/g,
	  '@': /\@/g,
	  '!': /\!/g,
	  '+': /\+/g,
	  '*': /\*/g,
	  '(': /\(/g,
	  ')': /\)/g,
	  '[': /\[/g,
	  ']': /\]/g
	};
	
	/**
	 * Escape characters
	 */
	
	chars.ESC = {
	  '?': '__UNESC_QMRK__',
	  '@': '__UNESC_AMPE__',
	  '!': '__UNESC_EXCL__',
	  '+': '__UNESC_PLUS__',
	  '*': '__UNESC_STAR__',
	  ',': '__UNESC_COMMA__',
	  '(': '__UNESC_LTPAREN__',
	  ')': '__UNESC_RTPAREN__',
	  '[': '__UNESC_LTBRACK__',
	  ']': '__UNESC_RTBRACK__'
	};
	
	/**
	 * Unescape characters
	 */
	
	chars.UNESC = unesc || (unesc = reverse(chars.ESC, '\\'));
	
	chars.ESC_TEMP = {
	  '?': '__TEMP_QMRK__',
	  '@': '__TEMP_AMPE__',
	  '!': '__TEMP_EXCL__',
	  '*': '__TEMP_STAR__',
	  '+': '__TEMP_PLUS__',
	  ',': '__TEMP_COMMA__',
	  '(': '__TEMP_LTPAREN__',
	  ')': '__TEMP_RTPAREN__',
	  '[': '__TEMP_LTBRACK__',
	  ']': '__TEMP_RTBRACK__'
	};
	
	chars.TEMP = temp || (temp = reverse(chars.ESC_TEMP));
	
	module.exports = chars;


/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	function posix(path) {
		return path.charAt(0) === '/';
	}
	
	function win32(path) {
		// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
		var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
		var result = splitDeviceRe.exec(path);
		var device = result[1] || '';
		var isUnc = Boolean(device && device.charAt(1) !== ':');
	
		// UNC paths are always absolute
		return Boolean(result[2] || isUnc);
	}
	
	module.exports = process.platform === 'win32' ? win32 : posix;
	module.exports.posix = posix;
	module.exports.win32 = win32;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 261 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var sysPath = __webpack_require__(4);
	var readdirp = __webpack_require__(263);
	var isBinaryPath = __webpack_require__(295);
	
	// fs.watch helpers
	
	// object to hold per-process fs.watch instances
	// (may be shared across chokidar FSWatcher instances)
	var FsWatchInstances = Object.create(null);
	
	// Private function: Instantiates the fs.watch interface
	
	// * path       - string, path to be watched
	// * options    - object, options to be passed to fs.watch
	// * listener   - function, main event handler
	// * errHandler - function, handler which emits info about errors
	// * emitRaw    - function, handler which emits raw event data
	
	// Returns new fsevents instance
	function createFsWatchInstance(path, options, listener, errHandler, emitRaw) {
	  var handleEvent = function(rawEvent, evPath) {
	    listener(path);
	    emitRaw(rawEvent, evPath, {watchedPath: path});
	
	    // emit based on events occuring for files from a directory's watcher in
	    // case the file's watcher misses it (and rely on throttling to de-dupe)
	    if (evPath && path !== evPath) {
	      fsWatchBroadcast(
	        sysPath.resolve(path, evPath), 'listeners', sysPath.join(path, evPath)
	      );
	    }
	  };
	  try {
	    return fs.watch(path, options, handleEvent);
	  } catch (error) {
	    errHandler(error);
	  }
	}
	
	// Private function: Helper for passing fs.watch event data to a
	// collection of listeners
	
	// * fullPath   - string, absolute path bound to the fs.watch instance
	// * type       - string, listener type
	// * val[1..3]  - arguments to be passed to listeners
	
	// Returns nothing
	function fsWatchBroadcast(fullPath, type, val1, val2, val3) {
	  if (!FsWatchInstances[fullPath]) return;
	  FsWatchInstances[fullPath][type].forEach(function(listener) {
	    listener(val1, val2, val3);
	  });
	}
	
	// Private function: Instantiates the fs.watch interface or binds listeners
	// to an existing one covering the same file system entry
	
	// * path       - string, path to be watched
	// * fullPath   - string, absolute path
	// * options    - object, options to be passed to fs.watch
	// * handlers   - object, container for event listener functions
	
	// Returns close function
	function setFsWatchListener(path, fullPath, options, handlers) {
	  var listener = handlers.listener;
	  var errHandler = handlers.errHandler;
	  var rawEmitter = handlers.rawEmitter;
	  var container = FsWatchInstances[fullPath];
	  var watcher;
	  if (!options.persistent) {
	    watcher = createFsWatchInstance(
	      path, options, listener, errHandler, rawEmitter
	    );
	    return watcher.close.bind(watcher);
	  }
	  if (!container) {
	    watcher = createFsWatchInstance(
	      path,
	      options,
	      fsWatchBroadcast.bind(null, fullPath, 'listeners'),
	      errHandler, // no need to use broadcast here
	      fsWatchBroadcast.bind(null, fullPath, 'rawEmitters')
	    );
	    if (!watcher) return;
	    var broadcastErr = fsWatchBroadcast.bind(null, fullPath, 'errHandlers');
	    watcher.on('error', function(error) {
	      // Workaround for https://github.com/joyent/node/issues/4337
	      if (process.platform === 'win32' && error.code === 'EPERM') {
	        fs.open(path, 'r', function(err, fd) {
	          if (fd) fs.close(fd);
	          if (!err) broadcastErr(error);
	        });
	      } else {
	        broadcastErr(error);
	      }
	    });
	    container = FsWatchInstances[fullPath] = {
	      listeners: [listener],
	      errHandlers: [errHandler],
	      rawEmitters: [rawEmitter],
	      watcher: watcher
	    };
	  } else {
	    container.listeners.push(listener);
	    container.errHandlers.push(errHandler);
	    container.rawEmitters.push(rawEmitter);
	  }
	  var listenerIndex = container.listeners.length - 1;
	
	  // removes this instance's listeners and closes the underlying fs.watch
	  // instance if there are no more listeners left
	  return function close() {
	    delete container.listeners[listenerIndex];
	    delete container.errHandlers[listenerIndex];
	    delete container.rawEmitters[listenerIndex];
	    if (!Object.keys(container.listeners).length) {
	      container.watcher.close();
	      delete FsWatchInstances[fullPath];
	    }
	  };
	}
	
	// fs.watchFile helpers
	
	// object to hold per-process fs.watchFile instances
	// (may be shared across chokidar FSWatcher instances)
	var FsWatchFileInstances = Object.create(null);
	
	// Private function: Instantiates the fs.watchFile interface or binds listeners
	// to an existing one covering the same file system entry
	
	// * path       - string, path to be watched
	// * fullPath   - string, absolute path
	// * options    - object, options to be passed to fs.watchFile
	// * handlers   - object, container for event listener functions
	
	// Returns close function
	function setFsWatchFileListener(path, fullPath, options, handlers) {
	  var listener = handlers.listener;
	  var rawEmitter = handlers.rawEmitter;
	  var container = FsWatchFileInstances[fullPath];
	  var listeners = [];
	  var rawEmitters = [];
	  if (
	    container && (
	      container.options.persistent < options.persistent ||
	      container.options.interval > options.interval
	    )
	  ) {
	    // "Upgrade" the watcher to persistence or a quicker interval.
	    // This creates some unlikely edge case issues if the user mixes
	    // settings in a very weird way, but solving for those cases
	    // doesn't seem worthwhile for the added complexity.
	    listeners = container.listeners;
	    rawEmitters = container.rawEmitters;
	    fs.unwatchFile(fullPath);
	    container = false;
	  }
	  if (!container) {
	    listeners.push(listener);
	    rawEmitters.push(rawEmitter);
	    container = FsWatchFileInstances[fullPath] = {
	      listeners: listeners,
	      rawEmitters: rawEmitters,
	      options: options,
	      watcher: fs.watchFile(fullPath, options, function(curr, prev) {
	        container.rawEmitters.forEach(function(rawEmitter) {
	          rawEmitter('change', fullPath, {curr: curr, prev: prev});
	        });
	        var currmtime = curr.mtime.getTime();
	        if (curr.size !== prev.size || currmtime > prev.mtime.getTime() || currmtime === 0) {
	          container.listeners.forEach(function(listener) {
	            listener(path, curr);
	          });
	        }
	      })
	    };
	  } else {
	    container.listeners.push(listener);
	    container.rawEmitters.push(rawEmitter);
	  }
	  var listenerIndex = container.listeners.length - 1;
	
	  // removes this instance's listeners and closes the underlying fs.watchFile
	  // instance if there are no more listeners left
	  return function close() {
	    delete container.listeners[listenerIndex];
	    delete container.rawEmitters[listenerIndex];
	    if (!Object.keys(container.listeners).length) {
	      fs.unwatchFile(fullPath);
	      delete FsWatchFileInstances[fullPath];
	    }
	  };
	}
	
	// fake constructor for attaching nodefs-specific prototype methods that
	// will be copied to FSWatcher's prototype
	function NodeFsHandler() {}
	
	// Private method: Watch file for changes with fs.watchFile or fs.watch.
	
	// * path     - string, path to file or directory.
	// * listener - function, to be executed on fs change.
	
	// Returns close function for the watcher instance
	NodeFsHandler.prototype._watchWithNodeFs =
	function(path, listener) {
	  var directory = sysPath.dirname(path);
	  var basename = sysPath.basename(path);
	  var parent = this._getWatchedDir(directory);
	  parent.add(basename);
	  var absolutePath = sysPath.resolve(path);
	  var options = {persistent: this.options.persistent};
	  if (!listener) listener = Function.prototype; // empty function
	
	  var closer;
	  if (this.options.usePolling) {
	    options.interval = this.enableBinaryInterval && isBinaryPath(basename) ?
	      this.options.binaryInterval : this.options.interval;
	    closer = setFsWatchFileListener(path, absolutePath, options, {
	      listener: listener,
	      rawEmitter: this.emit.bind(this, 'raw')
	    });
	  } else {
	    closer = setFsWatchListener(path, absolutePath, options, {
	      listener: listener,
	      errHandler: this._handleError.bind(this),
	      rawEmitter: this.emit.bind(this, 'raw')
	    });
	  }
	  return closer;
	};
	
	// Private method: Watch a file and emit add event if warranted
	
	// * file       - string, the file's path
	// * stats      - object, result of fs.stat
	// * initialAdd - boolean, was the file added at watch instantiation?
	// * callback   - function, called when done processing as a newly seen file
	
	// Returns close function for the watcher instance
	NodeFsHandler.prototype._handleFile =
	function(file, stats, initialAdd, callback) {
	  var dirname = sysPath.dirname(file);
	  var basename = sysPath.basename(file);
	  var parent = this._getWatchedDir(dirname);
	
	  // if the file is already being watched, do nothing
	  if (parent.has(basename)) return callback();
	
	  // kick off the watcher
	  var closer = this._watchWithNodeFs(file, function(path, newStats) {
	    if (!this._throttle('watch', file, 5)) return;
	    if (!newStats || newStats && newStats.mtime.getTime() === 0) {
	      fs.stat(file, function(error, newStats) {
	        // Fix issues where mtime is null but file is still present
	        if (error) {
	          this._remove(dirname, basename);
	        } else {
	          this._emit('change', file, newStats);
	        }
	      }.bind(this));
	    // add is about to be emitted if file not already tracked in parent
	    } else if (parent.has(basename)) {
	      this._emit('change', file, newStats);
	    }
	  }.bind(this));
	
	  // emit an add event if we're supposed to
	  if (!(initialAdd && this.options.ignoreInitial)) {
	    if (!this._throttle('add', file, 0)) return;
	    this._emit('add', file, stats);
	  }
	
	  if (callback) callback();
	  return closer;
	};
	
	// Private method: Handle symlinks encountered while reading a dir
	
	// * entry      - object, entry object returned by readdirp
	// * directory  - string, path of the directory being read
	// * path       - string, path of this item
	// * item       - string, basename of this item
	
	// Returns true if no more processing is needed for this entry.
	NodeFsHandler.prototype._handleSymlink =
	function(entry, directory, path, item) {
	  var full = entry.fullPath;
	  var dir = this._getWatchedDir(directory);
	
	  if (!this.options.followSymlinks) {
	    // watch symlink directly (don't follow) and detect changes
	    this._readyCount++;
	    fs.realpath(path, function(error, linkPath) {
	      if (dir.has(item)) {
	        if (this._symlinkPaths[full] !== linkPath) {
	          this._symlinkPaths[full] = linkPath;
	          this._emit('change', path, entry.stat);
	        }
	      } else {
	        dir.add(item);
	        this._symlinkPaths[full] = linkPath;
	        this._emit('add', path, entry.stat);
	      }
	      this._emitReady();
	    }.bind(this));
	    return true;
	  }
	
	  // don't follow the same symlink more than once
	  if (this._symlinkPaths[full]) return true;
	  else this._symlinkPaths[full] = true;
	};
	
	// Private method: Read directory to add / remove files from `@watched` list
	// and re-read it on change.
	
	// * dir        - string, fs path.
	// * stats      - object, result of fs.stat
	// * initialAdd - boolean, was the file added at watch instantiation?
	// * depth      - int, depth relative to user-supplied path
	// * target     - string, child path actually targeted for watch
	// * wh         - object, common watch helpers for this path
	// * callback   - function, called when dir scan is complete
	
	// Returns close function for the watcher instance
	NodeFsHandler.prototype._handleDir =
	function(dir, stats, initialAdd, depth, target, wh, callback) {
	  var parentDir = this._getWatchedDir(sysPath.dirname(dir));
	  var tracked = parentDir.has(sysPath.basename(dir));
	  if (!(initialAdd && this.options.ignoreInitial) && !target && !tracked) {
	    if (!wh.hasGlob || wh.globFilter(dir)) this._emit('addDir', dir, stats);
	  }
	
	  // ensure dir is tracked (harmless if redundant)
	  parentDir.add(sysPath.basename(dir));
	  this._getWatchedDir(dir);
	
	  var read = function(directory, initialAdd, done) {
	    // Normalize the directory name on Windows
	    directory = sysPath.join(directory, '');
	
	    if (!wh.hasGlob) {
	      var throttler = this._throttle('readdir', directory, 1000);
	      if (!throttler) return;
	    }
	
	    var previous = this._getWatchedDir(wh.path);
	    var current = [];
	
	    readdirp({
	      root: directory,
	      entryType: 'all',
	      fileFilter: wh.filterPath,
	      directoryFilter: wh.filterDir,
	      depth: 0,
	      lstat: true
	    }).on('data', function(entry) {
	      var item = entry.path;
	      var path = sysPath.join(directory, item);
	      current.push(item);
	
	      if (entry.stat.isSymbolicLink() &&
	        this._handleSymlink(entry, directory, path, item)) return;
	
	      // Files that present in current directory snapshot
	      // but absent in previous are added to watch list and
	      // emit `add` event.
	      if (item === target || !target && !previous.has(item)) {
	        this._readyCount++;
	
	        // ensure relativeness of path is preserved in case of watcher reuse
	        path = sysPath.join(dir, sysPath.relative(dir, path));
	
	        this._addToNodeFs(path, initialAdd, wh, depth + 1);
	      }
	    }.bind(this)).on('end', function() {
	      if (throttler) throttler.clear();
	      if (done) done();
	
	      // Files that absent in current directory snapshot
	      // but present in previous emit `remove` event
	      // and are removed from @watched[directory].
	      previous.children().filter(function(item) {
	        return item !== directory &&
	          current.indexOf(item) === -1 &&
	          // in case of intersecting globs;
	          // a path may have been filtered out of this readdir, but
	          // shouldn't be removed because it matches a different glob
	          (!wh.hasGlob || wh.filterPath({
	            fullPath: sysPath.resolve(directory, item)
	          }));
	      }).forEach(function(item) {
	        this._remove(directory, item);
	      }, this);
	    }.bind(this)).on('error', this._handleError.bind(this));
	  }.bind(this);
	
	  var closer;
	
	  if (this.options.depth == null || depth <= this.options.depth) {
	    if (!target) read(dir, initialAdd, callback);
	    closer = this._watchWithNodeFs(dir, function(dirPath, stats) {
	      // if current directory is removed, do nothing
	      if (stats && stats.mtime.getTime() === 0) return;
	
	      read(dirPath, false);
	    });
	  } else {
	    callback();
	  }
	  return closer;
	};
	
	// Private method: Handle added file, directory, or glob pattern.
	// Delegates call to _handleFile / _handleDir after checks.
	
	// * path       - string, path to file or directory.
	// * initialAdd - boolean, was the file added at watch instantiation?
	// * depth      - int, depth relative to user-supplied path
	// * target     - string, child path actually targeted for watch
	// * callback   - function, indicates whether the path was found or not
	
	// Returns nothing
	NodeFsHandler.prototype._addToNodeFs =
	function(path, initialAdd, priorWh, depth, target, callback) {
	  if (!callback) callback = Function.prototype;
	  var ready = this._emitReady;
	  if (this._isIgnored(path) || this.closed) {
	    ready();
	    return callback(null, false);
	  }
	
	  var wh = this._getWatchHelpers(path, depth);
	  if (!wh.hasGlob && priorWh) {
	    wh.hasGlob = priorWh.hasGlob;
	    wh.globFilter = priorWh.globFilter;
	    wh.filterPath = priorWh.filterPath;
	    wh.filterDir = priorWh.filterDir;
	  }
	
	  // evaluate what is at the path we're being asked to watch
	  fs[wh.statMethod](wh.watchPath, function(error, stats) {
	    if (this._handleError(error)) return callback(null, path);
	    if (this._isIgnored(wh.watchPath, stats)) {
	      ready();
	      return callback(null, false);
	    }
	
	    var initDir = function(dir, target) {
	      return this._handleDir(dir, stats, initialAdd, depth, target, wh, ready);
	    }.bind(this);
	
	    var closer;
	    if (stats.isDirectory()) {
	      closer = initDir(wh.watchPath, target);
	    } else if (stats.isSymbolicLink()) {
	      var parent = sysPath.dirname(wh.watchPath);
	      this._getWatchedDir(parent).add(wh.watchPath);
	      this._emit('add', wh.watchPath, stats);
	      closer = initDir(parent, path);
	
	      // preserve this symlink's target path
	      fs.realpath(path, function(error, targetPath) {
	        this._symlinkPaths[sysPath.resolve(path)] = targetPath;
	        ready();
	      }.bind(this));
	    } else {
	      closer = this._handleFile(wh.watchPath, stats, initialAdd, ready);
	    }
	
	    if (closer) this._closers[path] = closer;
	    callback(null, false);
	  }.bind(this));
	};
	
	module.exports = NodeFsHandler;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var fs        =  __webpack_require__(264)
	  , path      =  __webpack_require__(4)
	  , minimatch =  __webpack_require__(289)
	  , toString  =  Object.prototype.toString
	  , si        =  __webpack_require__(293)
	  ;
	
	
	// Standard helpers
	function isFunction (obj) {
	  return toString.call(obj) === '[object Function]';
	}
	
	function isString (obj) {
	  return toString.call(obj) === '[object String]';
	}
	
	function isRegExp (obj) {
	  return toString.call(obj) === '[object RegExp]';
	}
	
	function isUndefined (obj) {
	  return obj === void 0;
	}
	
	/** 
	 * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.
	 * @param { Object }   opts     Options to specify root (start directory), filters and recursion depth
	 * @param { function } callback1  When callback2 is given calls back for each processed file - function (fileInfo) { ... },
	 *                                when callback2 is not given, it behaves like explained in callback2
	 * @param { function } callback2  Calls back once all files have been processed with an array of errors and file infos
	 *                                function (err, fileInfos) { ... }
	 */
	function readdir(opts, callback1, callback2) {
	  var stream
	    , handleError
	    , handleFatalError
	    , pending = 0
	    , errors = []
	    , readdirResult = {
	        directories: []
	      , files: []
	    }
	    , fileProcessed
	    , allProcessed
	    , realRoot
	    , aborted = false
	    , paused = false
	    ;
	
	  // If no callbacks were given we will use a streaming interface
	  if (isUndefined(callback1)) {
	    var api          =  __webpack_require__(294)();
	    stream           =  api.stream;
	    callback1        =  api.processEntry;
	    callback2        =  api.done;
	    handleError      =  api.handleError;
	    handleFatalError =  api.handleFatalError;
	
	    stream.on('close', function () { aborted = true; });
	    stream.on('pause', function () { paused = true; });
	    stream.on('resume', function () { paused = false; });
	  } else {
	    handleError      =  function (err) { errors.push(err); };
	    handleFatalError =  function (err) {
	      handleError(err);
	      allProcessed(errors, null);
	    };
	  }
	
	  if (isUndefined(opts)){
	    handleFatalError(new Error (
	      'Need to pass at least one argument: opts! \n' +
	      'https://github.com/thlorenz/readdirp#options'
	      )
	    );
	    return stream;
	  }
	
	  opts.root            =  opts.root            || '.';
	  opts.fileFilter      =  opts.fileFilter      || function() { return true; };
	  opts.directoryFilter =  opts.directoryFilter || function() { return true; };
	  opts.depth           =  typeof opts.depth === 'undefined' ? 999999999 : opts.depth;
	  opts.entryType       =  opts.entryType       || 'files';
	
	  var statfn = opts.lstat === true ? fs.lstat.bind(fs) : fs.stat.bind(fs);
	
	  if (isUndefined(callback2)) {
	    fileProcessed = function() { };
	    allProcessed = callback1;
	  } else {
	    fileProcessed = callback1;
	    allProcessed = callback2;
	  }
	
	  function normalizeFilter (filter) {
	
	    if (isUndefined(filter)) return undefined;
	
	    function isNegated (filters) {
	
	      function negated(f) { 
	        return f.indexOf('!') === 0; 
	      }
	
	      var some = filters.some(negated);
	      if (!some) {
	        return false;
	      } else {
	        if (filters.every(negated)) {
	          return true;
	        } else {
	          // if we detect illegal filters, bail out immediately
	          throw new Error(
	            'Cannot mix negated with non negated glob filters: ' + filters + '\n' +
	            'https://github.com/thlorenz/readdirp#filters'
	          );
	        }
	      }
	    }
	
	    // Turn all filters into a function
	    if (isFunction(filter)) {
	
	      return filter;
	
	    } else if (isString(filter)) {
	
	      return function (entryInfo) {
	        return minimatch(entryInfo.name, filter.trim());
	      };
	
	    } else if (filter && Array.isArray(filter)) {
	
	      if (filter) filter = filter.map(function (f) {
	        return f.trim();
	      });
	
	      return isNegated(filter) ?
	        // use AND to concat multiple negated filters
	        function (entryInfo) {
	          return filter.every(function (f) {
	            return minimatch(entryInfo.name, f);
	          });
	        }
	        :
	        // use OR to concat multiple inclusive filters
	        function (entryInfo) {
	          return filter.some(function (f) {
	            return minimatch(entryInfo.name, f);
	          });
	        };
	    }
	  }
	
	  function processDir(currentDir, entries, callProcessed) {
	    if (aborted) return;
	    var total = entries.length
	      , processed = 0
	      , entryInfos = []
	      ;
	
	    fs.realpath(currentDir, function(err, realCurrentDir) {
	      if (aborted) return;
	      if (err) {
	        handleError(err);
	        callProcessed(entryInfos);
	        return;
	      }
	
	      var relDir = path.relative(realRoot, realCurrentDir);
	
	      if (entries.length === 0) {
	        callProcessed([]);
	      } else {
	        entries.forEach(function (entry) { 
	
	          var fullPath = path.join(realCurrentDir, entry)
	            , relPath  = path.join(relDir, entry);
	
	          statfn(fullPath, function (err, stat) {
	            if (err) {
	              handleError(err);
	            } else {
	              entryInfos.push({
	                  name          :  entry
	                , path          :  relPath   // relative to root
	                , fullPath      :  fullPath
	
	                , parentDir     :  relDir    // relative to root
	                , fullParentDir :  realCurrentDir
	
	                , stat          :  stat
	              });
	            }
	            processed++;
	            if (processed === total) callProcessed(entryInfos);
	          });
	        });
	      }
	    });
	  }
	
	  function readdirRec(currentDir, depth, callCurrentDirProcessed) {
	    var args = arguments;
	    if (aborted) return;
	    if (paused) {
	      si(function () {
	        readdirRec.apply(null, args);
	      })
	      return;
	    } 
	
	    fs.readdir(currentDir, function (err, entries) {
	      if (err) {
	        handleError(err);
	        callCurrentDirProcessed();
	        return;
	      }
	
	      processDir(currentDir, entries, function(entryInfos) {
	
	        var subdirs = entryInfos
	          .filter(function (ei) { return ei.stat.isDirectory() && opts.directoryFilter(ei); });
	
	        subdirs.forEach(function (di) {
	          if(opts.entryType === 'directories' || opts.entryType === 'both' || opts.entryType === 'all') {
	            fileProcessed(di);
	          }
	          readdirResult.directories.push(di); 
	        });
	
	        entryInfos
	          .filter(function(ei) {
	            var isCorrectType = opts.entryType === 'all' ?
	              !ei.stat.isDirectory() : ei.stat.isFile() || ei.stat.isSymbolicLink();
	            return isCorrectType && opts.fileFilter(ei);
	          })
	          .forEach(function (fi) {
	            if(opts.entryType === 'files' || opts.entryType === 'both' || opts.entryType === 'all') {
	              fileProcessed(fi);
	            }
	            readdirResult.files.push(fi); 
	          });
	
	        var pendingSubdirs = subdirs.length;
	
	        // Be done if no more subfolders exist or we reached the maximum desired depth
	        if(pendingSubdirs === 0 || depth === opts.depth) {
	          callCurrentDirProcessed();
	        } else {
	          // recurse into subdirs, keeping track of which ones are done 
	          // and call back once all are processed
	          subdirs.forEach(function (subdir) {
	            readdirRec(subdir.fullPath, depth + 1, function () {
	              pendingSubdirs = pendingSubdirs - 1;
	              if(pendingSubdirs === 0) { 
	                callCurrentDirProcessed();
	              }
	            });
	          });
	        }
	      });
	    });
	  }
	
	  // Validate and normalize filters
	  try {
	    opts.fileFilter = normalizeFilter(opts.fileFilter);
	    opts.directoryFilter = normalizeFilter(opts.directoryFilter);
	  } catch (err) {
	    // if we detect illegal filters, bail out immediately
	    handleFatalError(err);
	    return stream;
	  }
	
	  // If filters were valid get on with the show
	  fs.realpath(opts.root, function(err, res) {
	    if (err) {
	      handleFatalError(err);
	      return stream;
	    }
	
	    realRoot = res;
	    readdirRec(opts.root, 0, function () { 
	      // All errors are collected into the errors array
	      if (errors.length > 0) {
	        allProcessed(errors, readdirResult); 
	      } else {
	        allProcessed(null, readdirResult);
	      }
	    });
	  });
	
	  return stream;
	}
	
	module.exports = readdir;


/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	var polyfills = __webpack_require__(265)
	var legacy = __webpack_require__(268)
	var queue = []
	
	var util = __webpack_require__(287)
	
	function noop () {}
	
	var debug = noop
	if (util.debuglog)
	  debug = util.debuglog('gfs4')
	else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
	  debug = function() {
	    var m = util.format.apply(util, arguments)
	    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ')
	    console.error(m)
	  }
	
	if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
	  process.on('exit', function() {
	    debug(queue)
	    __webpack_require__(288).equal(queue.length, 0)
	  })
	}
	
	module.exports = patch(__webpack_require__(266))
	if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH) {
	  module.exports = patch(fs)
	}
	
	// Always patch fs.close/closeSync, because we want to
	// retry() whenever a close happens *anywhere* in the program.
	// This is essential when multiple graceful-fs instances are
	// in play at the same time.
	module.exports.close =
	fs.close = (function (fs$close) { return function (fd, cb) {
	  return fs$close.call(fs, fd, function (err) {
	    if (!err)
	      retry()
	
	    if (typeof cb === 'function')
	      cb.apply(this, arguments)
	  })
	}})(fs.close)
	
	module.exports.closeSync =
	fs.closeSync = (function (fs$closeSync) { return function (fd) {
	  // Note that graceful-fs also retries when fs.closeSync() fails.
	  // Looks like a bug to me, although it's probably a harmless one.
	  var rval = fs$closeSync.apply(fs, arguments)
	  retry()
	  return rval
	}})(fs.closeSync)
	
	function patch (fs) {
	  // Everything that references the open() function needs to be in here
	  polyfills(fs)
	  fs.gracefulify = patch
	  fs.FileReadStream = ReadStream;  // Legacy name.
	  fs.FileWriteStream = WriteStream;  // Legacy name.
	  fs.createReadStream = createReadStream
	  fs.createWriteStream = createWriteStream
	  var fs$readFile = fs.readFile
	  fs.readFile = readFile
	  function readFile (path, options, cb) {
	    if (typeof options === 'function')
	      cb = options, options = null
	
	    return go$readFile(path, options, cb)
	
	    function go$readFile (path, options, cb) {
	      return fs$readFile(path, options, function (err) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
	          enqueue([go$readFile, [path, options, cb]])
	        else {
	          if (typeof cb === 'function')
	            cb.apply(this, arguments)
	          retry()
	        }
	      })
	    }
	  }
	
	  var fs$writeFile = fs.writeFile
	  fs.writeFile = writeFile
	  function writeFile (path, data, options, cb) {
	    if (typeof options === 'function')
	      cb = options, options = null
	
	    return go$writeFile(path, data, options, cb)
	
	    function go$writeFile (path, data, options, cb) {
	      return fs$writeFile(path, data, options, function (err) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
	          enqueue([go$writeFile, [path, data, options, cb]])
	        else {
	          if (typeof cb === 'function')
	            cb.apply(this, arguments)
	          retry()
	        }
	      })
	    }
	  }
	
	  var fs$appendFile = fs.appendFile
	  if (fs$appendFile)
	    fs.appendFile = appendFile
	  function appendFile (path, data, options, cb) {
	    if (typeof options === 'function')
	      cb = options, options = null
	
	    return go$appendFile(path, data, options, cb)
	
	    function go$appendFile (path, data, options, cb) {
	      return fs$appendFile(path, data, options, function (err) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
	          enqueue([go$appendFile, [path, data, options, cb]])
	        else {
	          if (typeof cb === 'function')
	            cb.apply(this, arguments)
	          retry()
	        }
	      })
	    }
	  }
	
	  var fs$readdir = fs.readdir
	  fs.readdir = readdir
	  function readdir (path, options, cb) {
	    var args = [path]
	    if (typeof options !== 'function') {
	      args.push(options)
	    } else {
	      cb = options
	    }
	    args.push(go$readdir$cb)
	
	    return go$readdir(args)
	
	    function go$readdir$cb (err, files) {
	      if (files && files.sort)
	        files.sort()
	
	      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
	        enqueue([go$readdir, [args]])
	      else {
	        if (typeof cb === 'function')
	          cb.apply(this, arguments)
	        retry()
	      }
	    }
	  }
	
	  function go$readdir (args) {
	    return fs$readdir.apply(fs, args)
	  }
	
	  if (process.version.substr(0, 4) === 'v0.8') {
	    var legStreams = legacy(fs)
	    ReadStream = legStreams.ReadStream
	    WriteStream = legStreams.WriteStream
	  }
	
	  var fs$ReadStream = fs.ReadStream
	  ReadStream.prototype = Object.create(fs$ReadStream.prototype)
	  ReadStream.prototype.open = ReadStream$open
	
	  var fs$WriteStream = fs.WriteStream
	  WriteStream.prototype = Object.create(fs$WriteStream.prototype)
	  WriteStream.prototype.open = WriteStream$open
	
	  fs.ReadStream = ReadStream
	  fs.WriteStream = WriteStream
	
	  function ReadStream (path, options) {
	    if (this instanceof ReadStream)
	      return fs$ReadStream.apply(this, arguments), this
	    else
	      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
	  }
	
	  function ReadStream$open () {
	    var that = this
	    open(that.path, that.flags, that.mode, function (err, fd) {
	      if (err) {
	        if (that.autoClose)
	          that.destroy()
	
	        that.emit('error', err)
	      } else {
	        that.fd = fd
	        that.emit('open', fd)
	        that.read()
	      }
	    })
	  }
	
	  function WriteStream (path, options) {
	    if (this instanceof WriteStream)
	      return fs$WriteStream.apply(this, arguments), this
	    else
	      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
	  }
	
	  function WriteStream$open () {
	    var that = this
	    open(that.path, that.flags, that.mode, function (err, fd) {
	      if (err) {
	        that.destroy()
	        that.emit('error', err)
	      } else {
	        that.fd = fd
	        that.emit('open', fd)
	      }
	    })
	  }
	
	  function createReadStream (path, options) {
	    return new ReadStream(path, options)
	  }
	
	  function createWriteStream (path, options) {
	    return new WriteStream(path, options)
	  }
	
	  var fs$open = fs.open
	  fs.open = open
	  function open (path, flags, mode, cb) {
	    if (typeof mode === 'function')
	      cb = mode, mode = null
	
	    return go$open(path, flags, mode, cb)
	
	    function go$open (path, flags, mode, cb) {
	      return fs$open(path, flags, mode, function (err, fd) {
	        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
	          enqueue([go$open, [path, flags, mode, cb]])
	        else {
	          if (typeof cb === 'function')
	            cb.apply(this, arguments)
	          retry()
	        }
	      })
	    }
	  }
	
	  return fs
	}
	
	function enqueue (elem) {
	  debug('ENQUEUE', elem[0].name, elem[1])
	  queue.push(elem)
	}
	
	function retry () {
	  var elem = queue.shift()
	  if (elem) {
	    debug('RETRY', elem[0].name, elem[1])
	    elem[0].apply(null, elem[1])
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var fs = __webpack_require__(266)
	var constants = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"constants\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	
	var origCwd = process.cwd
	var cwd = null
	
	var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform
	
	process.cwd = function() {
	  if (!cwd)
	    cwd = origCwd.call(process)
	  return cwd
	}
	try {
	  process.cwd()
	} catch (er) {}
	
	var chdir = process.chdir
	process.chdir = function(d) {
	  cwd = null
	  chdir.call(process, d)
	}
	
	module.exports = patch
	
	function patch (fs) {
	  // (re-)implement some things that are known busted or missing.
	
	  // lchmod, broken prior to 0.6.2
	  // back-port the fix here.
	  if (constants.hasOwnProperty('O_SYMLINK') &&
	      process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
	    patchLchmod(fs)
	  }
	
	  // lutimes implementation, or no-op
	  if (!fs.lutimes) {
	    patchLutimes(fs)
	  }
	
	  // https://github.com/isaacs/node-graceful-fs/issues/4
	  // Chown should not fail on einval or eperm if non-root.
	  // It should not fail on enosys ever, as this just indicates
	  // that a fs doesn't support the intended operation.
	
	  fs.chown = chownFix(fs.chown)
	  fs.fchown = chownFix(fs.fchown)
	  fs.lchown = chownFix(fs.lchown)
	
	  fs.chmod = chmodFix(fs.chmod)
	  fs.fchmod = chmodFix(fs.fchmod)
	  fs.lchmod = chmodFix(fs.lchmod)
	
	  fs.chownSync = chownFixSync(fs.chownSync)
	  fs.fchownSync = chownFixSync(fs.fchownSync)
	  fs.lchownSync = chownFixSync(fs.lchownSync)
	
	  fs.chmodSync = chmodFixSync(fs.chmodSync)
	  fs.fchmodSync = chmodFixSync(fs.fchmodSync)
	  fs.lchmodSync = chmodFixSync(fs.lchmodSync)
	
	  fs.stat = statFix(fs.stat)
	  fs.fstat = statFix(fs.fstat)
	  fs.lstat = statFix(fs.lstat)
	
	  fs.statSync = statFixSync(fs.statSync)
	  fs.fstatSync = statFixSync(fs.fstatSync)
	  fs.lstatSync = statFixSync(fs.lstatSync)
	
	  // if lchmod/lchown do not exist, then make them no-ops
	  if (!fs.lchmod) {
	    fs.lchmod = function (path, mode, cb) {
	      if (cb) process.nextTick(cb)
	    }
	    fs.lchmodSync = function () {}
	  }
	  if (!fs.lchown) {
	    fs.lchown = function (path, uid, gid, cb) {
	      if (cb) process.nextTick(cb)
	    }
	    fs.lchownSync = function () {}
	  }
	
	  // on Windows, A/V software can lock the directory, causing this
	  // to fail with an EACCES or EPERM if the directory contains newly
	  // created files.  Try again on failure, for up to 60 seconds.
	
	  // Set the timeout this long because some Windows Anti-Virus, such as Parity
	  // bit9, may lock files for up to a minute, causing npm package install
	  // failures. Also, take care to yield the scheduler. Windows scheduling gives
	  // CPU to a busy looping process, which can cause the program causing the lock
	  // contention to be starved of CPU by node, so the contention doesn't resolve.
	  if (platform === "win32") {
	    fs.rename = (function (fs$rename) { return function (from, to, cb) {
	      var start = Date.now()
	      var backoff = 0;
	      fs$rename(from, to, function CB (er) {
	        if (er
	            && (er.code === "EACCES" || er.code === "EPERM")
	            && Date.now() - start < 60000) {
	          setTimeout(function() {
	            fs.stat(to, function (stater, st) {
	              if (stater && stater.code === "ENOENT")
	                fs$rename(from, to, CB);
	              else
	                cb(er)
	            })
	          }, backoff)
	          if (backoff < 100)
	            backoff += 10;
	          return;
	        }
	        if (cb) cb(er)
	      })
	    }})(fs.rename)
	  }
	
	  // if read() returns EAGAIN, then just try it again.
	  fs.read = (function (fs$read) { return function (fd, buffer, offset, length, position, callback_) {
	    var callback
	    if (callback_ && typeof callback_ === 'function') {
	      var eagCounter = 0
	      callback = function (er, _, __) {
	        if (er && er.code === 'EAGAIN' && eagCounter < 10) {
	          eagCounter ++
	          return fs$read.call(fs, fd, buffer, offset, length, position, callback)
	        }
	        callback_.apply(this, arguments)
	      }
	    }
	    return fs$read.call(fs, fd, buffer, offset, length, position, callback)
	  }})(fs.read)
	
	  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {
	    var eagCounter = 0
	    while (true) {
	      try {
	        return fs$readSync.call(fs, fd, buffer, offset, length, position)
	      } catch (er) {
	        if (er.code === 'EAGAIN' && eagCounter < 10) {
	          eagCounter ++
	          continue
	        }
	        throw er
	      }
	    }
	  }})(fs.readSync)
	}
	
	function patchLchmod (fs) {
	  fs.lchmod = function (path, mode, callback) {
	    fs.open( path
	           , constants.O_WRONLY | constants.O_SYMLINK
	           , mode
	           , function (err, fd) {
	      if (err) {
	        if (callback) callback(err)
	        return
	      }
	      // prefer to return the chmod error, if one occurs,
	      // but still try to close, and report closing errors if they occur.
	      fs.fchmod(fd, mode, function (err) {
	        fs.close(fd, function(err2) {
	          if (callback) callback(err || err2)
	        })
	      })
	    })
	  }
	
	  fs.lchmodSync = function (path, mode) {
	    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)
	
	    // prefer to return the chmod error, if one occurs,
	    // but still try to close, and report closing errors if they occur.
	    var threw = true
	    var ret
	    try {
	      ret = fs.fchmodSync(fd, mode)
	      threw = false
	    } finally {
	      if (threw) {
	        try {
	          fs.closeSync(fd)
	        } catch (er) {}
	      } else {
	        fs.closeSync(fd)
	      }
	    }
	    return ret
	  }
	}
	
	function patchLutimes (fs) {
	  if (constants.hasOwnProperty("O_SYMLINK")) {
	    fs.lutimes = function (path, at, mt, cb) {
	      fs.open(path, constants.O_SYMLINK, function (er, fd) {
	        if (er) {
	          if (cb) cb(er)
	          return
	        }
	        fs.futimes(fd, at, mt, function (er) {
	          fs.close(fd, function (er2) {
	            if (cb) cb(er || er2)
	          })
	        })
	      })
	    }
	
	    fs.lutimesSync = function (path, at, mt) {
	      var fd = fs.openSync(path, constants.O_SYMLINK)
	      var ret
	      var threw = true
	      try {
	        ret = fs.futimesSync(fd, at, mt)
	        threw = false
	      } finally {
	        if (threw) {
	          try {
	            fs.closeSync(fd)
	          } catch (er) {}
	        } else {
	          fs.closeSync(fd)
	        }
	      }
	      return ret
	    }
	
	  } else {
	    fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }
	    fs.lutimesSync = function () {}
	  }
	}
	
	function chmodFix (orig) {
	  if (!orig) return orig
	  return function (target, mode, cb) {
	    return orig.call(fs, target, mode, function (er) {
	      if (chownErOk(er)) er = null
	      if (cb) cb.apply(this, arguments)
	    })
	  }
	}
	
	function chmodFixSync (orig) {
	  if (!orig) return orig
	  return function (target, mode) {
	    try {
	      return orig.call(fs, target, mode)
	    } catch (er) {
	      if (!chownErOk(er)) throw er
	    }
	  }
	}
	
	
	function chownFix (orig) {
	  if (!orig) return orig
	  return function (target, uid, gid, cb) {
	    return orig.call(fs, target, uid, gid, function (er) {
	      if (chownErOk(er)) er = null
	      if (cb) cb.apply(this, arguments)
	    })
	  }
	}
	
	function chownFixSync (orig) {
	  if (!orig) return orig
	  return function (target, uid, gid) {
	    try {
	      return orig.call(fs, target, uid, gid)
	    } catch (er) {
	      if (!chownErOk(er)) throw er
	    }
	  }
	}
	
	
	function statFix (orig) {
	  if (!orig) return orig
	  // Older versions of Node erroneously returned signed integers for
	  // uid + gid.
	  return function (target, cb) {
	    return orig.call(fs, target, function (er, stats) {
	      if (!stats) return cb.apply(this, arguments)
	      if (stats.uid < 0) stats.uid += 0x100000000
	      if (stats.gid < 0) stats.gid += 0x100000000
	      if (cb) cb.apply(this, arguments)
	    })
	  }
	}
	
	function statFixSync (orig) {
	  if (!orig) return orig
	  // Older versions of Node erroneously returned signed integers for
	  // uid + gid.
	  return function (target) {
	    var stats = orig.call(fs, target)
	    if (stats.uid < 0) stats.uid += 0x100000000
	    if (stats.gid < 0) stats.gid += 0x100000000
	    return stats;
	  }
	}
	
	// ENOSYS means that the fs doesn't support the op. Just ignore
	// that, because it doesn't matter.
	//
	// if there's no getuid, or if getuid() is something other
	// than 0, and the error is EINVAL or EPERM, then just ignore
	// it.
	//
	// This specific case is a silent failure in cp, install, tar,
	// and most other unix tools that manage permissions.
	//
	// When running as root, or if other types of errors are
	// encountered, then it's strict.
	function chownErOk (er) {
	  if (!er)
	    return true
	
	  if (er.code === "ENOSYS")
	    return true
	
	  var nonroot = !process.getuid || process.getuid() !== 0
	  if (nonroot) {
	    if (er.code === "EINVAL" || er.code === "EPERM")
	      return true
	  }
	
	  return false
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	'use strict'
	
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	
	module.exports = clone(fs)
	
	function clone (obj) {
	  if (obj === null || typeof obj !== 'object')
	    return obj
	
	  if (obj instanceof Object)
	    var copy = { __proto__: obj.__proto__ }
	  else
	    var copy = Object.create(null)
	
	  Object.getOwnPropertyNames(obj).forEach(function (key) {
	    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))
	  })
	
	  return copy
	}


/***/ },
/* 267 */,
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var Stream = __webpack_require__(269).Stream
	
	module.exports = legacy
	
	function legacy (fs) {
	  return {
	    ReadStream: ReadStream,
	    WriteStream: WriteStream
	  }
	
	  function ReadStream (path, options) {
	    if (!(this instanceof ReadStream)) return new ReadStream(path, options);
	
	    Stream.call(this);
	
	    var self = this;
	
	    this.path = path;
	    this.fd = null;
	    this.readable = true;
	    this.paused = false;
	
	    this.flags = 'r';
	    this.mode = 438; /*=0666*/
	    this.bufferSize = 64 * 1024;
	
	    options = options || {};
	
	    // Mixin options into this
	    var keys = Object.keys(options);
	    for (var index = 0, length = keys.length; index < length; index++) {
	      var key = keys[index];
	      this[key] = options[key];
	    }
	
	    if (this.encoding) this.setEncoding(this.encoding);
	
	    if (this.start !== undefined) {
	      if ('number' !== typeof this.start) {
	        throw TypeError('start must be a Number');
	      }
	      if (this.end === undefined) {
	        this.end = Infinity;
	      } else if ('number' !== typeof this.end) {
	        throw TypeError('end must be a Number');
	      }
	
	      if (this.start > this.end) {
	        throw new Error('start must be <= end');
	      }
	
	      this.pos = this.start;
	    }
	
	    if (this.fd !== null) {
	      process.nextTick(function() {
	        self._read();
	      });
	      return;
	    }
	
	    fs.open(this.path, this.flags, this.mode, function (err, fd) {
	      if (err) {
	        self.emit('error', err);
	        self.readable = false;
	        return;
	      }
	
	      self.fd = fd;
	      self.emit('open', fd);
	      self._read();
	    })
	  }
	
	  function WriteStream (path, options) {
	    if (!(this instanceof WriteStream)) return new WriteStream(path, options);
	
	    Stream.call(this);
	
	    this.path = path;
	    this.fd = null;
	    this.writable = true;
	
	    this.flags = 'w';
	    this.encoding = 'binary';
	    this.mode = 438; /*=0666*/
	    this.bytesWritten = 0;
	
	    options = options || {};
	
	    // Mixin options into this
	    var keys = Object.keys(options);
	    for (var index = 0, length = keys.length; index < length; index++) {
	      var key = keys[index];
	      this[key] = options[key];
	    }
	
	    if (this.start !== undefined) {
	      if ('number' !== typeof this.start) {
	        throw TypeError('start must be a Number');
	      }
	      if (this.start < 0) {
	        throw new Error('start must be >= zero');
	      }
	
	      this.pos = this.start;
	    }
	
	    this.busy = false;
	    this._queue = [];
	
	    if (this.fd === null) {
	      this._open = fs.open;
	      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
	      this.flush();
	    }
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	module.exports = Stream;
	
	var EE = __webpack_require__(216).EventEmitter;
	var inherits = __webpack_require__(261);
	
	inherits(Stream, EE);
	Stream.Readable = __webpack_require__(270);
	Stream.Writable = __webpack_require__(283);
	Stream.Duplex = __webpack_require__(284);
	Stream.Transform = __webpack_require__(285);
	Stream.PassThrough = __webpack_require__(286);
	
	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;
	
	
	
	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.
	
	function Stream() {
	  EE.call(this);
	}
	
	Stream.prototype.pipe = function(dest, options) {
	  var source = this;
	
	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }
	
	  source.on('data', ondata);
	
	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }
	
	  dest.on('drain', ondrain);
	
	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }
	
	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;
	
	    dest.end();
	  }
	
	
	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;
	
	    if (typeof dest.destroy === 'function') dest.destroy();
	  }
	
	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }
	
	  source.on('error', onerror);
	  dest.on('error', onerror);
	
	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);
	
	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);
	
	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);
	
	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);
	
	    dest.removeListener('close', cleanup);
	  }
	
	  source.on('end', cleanup);
	  source.on('close', cleanup);
	
	  dest.on('close', cleanup);
	
	  dest.emit('pipe', source);
	
	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};


/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var Stream = (function (){
	  try {
	    return __webpack_require__(269); // hack to fix a circular dependency issue when used with browserify
	  } catch(_){}
	}());
	exports = module.exports = __webpack_require__(271);
	exports.Stream = Stream || exports;
	exports.Readable = exports;
	exports.Writable = __webpack_require__(278);
	exports.Duplex = __webpack_require__(277);
	exports.Transform = __webpack_require__(281);
	exports.PassThrough = __webpack_require__(282);
	
	if (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {
	  module.exports = Stream;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	module.exports = Readable;
	
	/*<replacement>*/
	var processNextTick = __webpack_require__(272);
	/*</replacement>*/
	
	/*<replacement>*/
	var isArray = __webpack_require__(233);
	/*</replacement>*/
	
	/*<replacement>*/
	var Duplex;
	/*</replacement>*/
	
	Readable.ReadableState = ReadableState;
	
	/*<replacement>*/
	var EE = __webpack_require__(216).EventEmitter;
	
	var EElistenerCount = function (emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/
	
	/*<replacement>*/
	var Stream;
	(function () {
	  try {
	    Stream = __webpack_require__(269);
	  } catch (_) {} finally {
	    if (!Stream) Stream = __webpack_require__(216).EventEmitter;
	  }
	})();
	/*</replacement>*/
	
	var Buffer = __webpack_require__(7).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(273);
	/*</replacement>*/
	
	/*<replacement>*/
	var util = __webpack_require__(274);
	util.inherits = __webpack_require__(261);
	/*</replacement>*/
	
	/*<replacement>*/
	var debugUtil = __webpack_require__(275);
	var debug = void 0;
	if (debugUtil && debugUtil.debuglog) {
	  debug = debugUtil.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/
	
	var BufferList = __webpack_require__(276);
	var StringDecoder;
	
	util.inherits(Readable, Stream);
	
	function prependListener(emitter, event, fn) {
	  // Sadly this is not cacheable as some libraries bundle their own
	  // event emitter implementation with them.
	  if (typeof emitter.prependListener === 'function') {
	    return emitter.prependListener(event, fn);
	  } else {
	    // This is a hack to make sure that our error handler is attached before any
	    // userland ones.  NEVER DO THIS. This is here only because this code needs
	    // to continue to work with older versions of Node.js that do not include
	    // the prependListener() method. The goal is to eventually remove this hack.
	    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
	  }
	}
	
	function ReadableState(options, stream) {
	  Duplex = Duplex || __webpack_require__(277);
	
	  options = options || {};
	
	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
	
	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
	
	  // cast to ints.
	  this.highWaterMark = ~ ~this.highWaterMark;
	
	  // A linked list is used to store data chunks instead of an array because the
	  // linked list can remove elements from the beginning faster than
	  // array.shift()
	  this.buffer = new BufferList();
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	  this.resumeScheduled = false;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;
	
	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;
	
	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder) StringDecoder = __webpack_require__(280).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	
	function Readable(options) {
	  Duplex = Duplex || __webpack_require__(277);
	
	  if (!(this instanceof Readable)) return new Readable(options);
	
	  this._readableState = new ReadableState(options, this);
	
	  // legacy
	  this.readable = true;
	
	  if (options && typeof options.read === 'function') this._read = options.read;
	
	  Stream.call(this);
	}
	
	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  var state = this._readableState;
	
	  if (!state.objectMode && typeof chunk === 'string') {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = bufferShim.from(chunk, encoding);
	      encoding = '';
	    }
	  }
	
	  return readableAddChunk(this, state, chunk, encoding, false);
	};
	
	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function (chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};
	
	Readable.prototype.isPaused = function () {
	  return this._readableState.flowing === false;
	};
	
	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var _e = new Error('stream.unshift() after end event');
	      stream.emit('error', _e);
	    } else {
	      var skipAdd;
	      if (state.decoder && !addToFront && !encoding) {
	        chunk = state.decoder.write(chunk);
	        skipAdd = !state.objectMode && chunk.length === 0;
	      }
	
	      if (!addToFront) state.reading = false;
	
	      // Don't add to the buffer if we've decoded to an empty string chunk and
	      // we're not in object mode
	      if (!skipAdd) {
	        // if we want the data now, just emit it.
	        if (state.flowing && state.length === 0 && !state.sync) {
	          stream.emit('data', chunk);
	          stream.read(0);
	        } else {
	          // update the buffer info.
	          state.length += state.objectMode ? 1 : chunk.length;
	          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
	
	          if (state.needReadable) emitReadable(stream);
	        }
	      }
	
	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }
	
	  return needMoreData(state);
	}
	
	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
	}
	
	// backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  if (!StringDecoder) StringDecoder = __webpack_require__(280).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};
	
	// Don't raise the hwm > 8MB
	var MAX_HWM = 0x800000;
	function computeNewHighWaterMark(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2 to prevent increasing hwm excessively in
	    // tiny amounts
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n;
	}
	
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function howMuchToRead(n, state) {
	  if (n <= 0 || state.length === 0 && state.ended) return 0;
	  if (state.objectMode) return 1;
	  if (n !== n) {
	    // Only flow one buffer at a time
	    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
	  }
	  // If we're asking for more than the current hwm, then raise the hwm.
	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
	  if (n <= state.length) return n;
	  // Don't have enough
	  if (!state.ended) {
	    state.needReadable = true;
	    return 0;
	  }
	  return state.length;
	}
	
	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug('read', n);
	  n = parseInt(n, 10);
	  var state = this._readableState;
	  var nOrig = n;
	
	  if (n !== 0) state.emittedReadable = false;
	
	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	    return null;
	  }
	
	  n = howMuchToRead(n, state);
	
	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null;
	  }
	
	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.
	
	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);
	
	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }
	
	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  } else if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	    // If _read pushed data synchronously, then `reading` will be false,
	    // and we need to re-evaluate how much data we can return to the user.
	    if (!state.reading) n = howMuchToRead(nOrig, state);
	  }
	
	  var ret;
	  if (n > 0) ret = fromList(n, state);else ret = null;
	
	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  } else {
	    state.length -= n;
	  }
	
	  if (state.length === 0) {
	    // If we have nothing in the buffer, then we want to know
	    // as soon as we *do* get something into the buffer.
	    if (!state.ended) state.needReadable = true;
	
	    // If we tried to read() past the EOF, then emit end on the next tick.
	    if (nOrig !== n && state.ended) endReadable(this);
	  }
	
	  if (ret !== null) this.emit('data', ret);
	
	  return ret;
	};
	
	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}
	
	function onEofChunk(stream, state) {
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	
	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}
	
	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
	  }
	}
	
	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}
	
	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    processNextTick(maybeReadMore_, stream, state);
	  }
	}
	
	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;else len = state.length;
	  }
	  state.readingMore = false;
	}
	
	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  this.emit('error', new Error('_read() is not implemented'));
	};
	
	Readable.prototype.pipe = function (dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
	
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
	
	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);
	
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }
	
	  function onend() {
	    debug('onend');
	    dest.end();
	  }
	
	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	
	  var cleanedUp = false;
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);
	
	    cleanedUp = true;
	
	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }
	
	  // If the user pushes more data while we're writing to dest then we'll end up
	  // in ondata again. However, we only want to increase awaitDrain once because
	  // dest will only emit one 'drain' event for the multiple writes.
	  // => Introduce a guard on increasing awaitDrain.
	  var increasedAwaitDrain = false;
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    increasedAwaitDrain = false;
	    var ret = dest.write(chunk);
	    if (false === ret && !increasedAwaitDrain) {
	      // If the user unpiped during `dest.write()`, it is possible
	      // to get stuck in a permanently paused state if that write
	      // also returned false.
	      // => Check whether `dest` is still a piping destination.
	      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
	        debug('false write response, pause', src._readableState.awaitDrain);
	        src._readableState.awaitDrain++;
	        increasedAwaitDrain = true;
	      }
	      src.pause();
	    }
	  }
	
	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
	  }
	
	  // Make sure our error handler is attached before userland ones.
	  prependListener(dest, 'error', onerror);
	
	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	
	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }
	
	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);
	
	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }
	
	  return dest;
	};
	
	function pipeOnDrain(src) {
	  return function () {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain) state.awaitDrain--;
	    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}
	
	Readable.prototype.unpipe = function (dest) {
	  var state = this._readableState;
	
	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0) return this;
	
	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes) return this;
	
	    if (!dest) dest = state.pipes;
	
	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest) dest.emit('unpipe', this);
	    return this;
	  }
	
	  // slow case. multiple pipe destinations.
	
	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	
	    for (var i = 0; i < len; i++) {
	      dests[i].emit('unpipe', this);
	    }return this;
	  }
	
	  // try to find the right one.
	  var index = indexOf(state.pipes, dest);
	  if (index === -1) return this;
	
	  state.pipes.splice(index, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1) state.pipes = state.pipes[0];
	
	  dest.emit('unpipe', this);
	
	  return this;
	};
	
	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function (ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);
	
	  if (ev === 'data') {
	    // Start flowing on next tick if stream isn't explicitly paused
	    if (this._readableState.flowing !== false) this.resume();
	  } else if (ev === 'readable') {
	    var state = this._readableState;
	    if (!state.endEmitted && !state.readableListening) {
	      state.readableListening = state.needReadable = true;
	      state.emittedReadable = false;
	      if (!state.reading) {
	        processNextTick(nReadingNextTick, this);
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }
	
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	
	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}
	
	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    resume(this, state);
	  }
	  return this;
	};
	
	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    processNextTick(resume_, stream, state);
	  }
	}
	
	function resume_(stream, state) {
	  if (!state.reading) {
	    debug('resume read 0');
	    stream.read(0);
	  }
	
	  state.resumeScheduled = false;
	  state.awaitDrain = 0;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}
	
	Readable.prototype.pause = function () {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};
	
	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  while (state.flowing && stream.read() !== null) {}
	}
	
	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  var state = this._readableState;
	  var paused = false;
	
	  var self = this;
	  stream.on('end', function () {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) self.push(chunk);
	    }
	
	    self.push(null);
	  });
	
	  stream.on('data', function (chunk) {
	    debug('wrapped data');
	    if (state.decoder) chunk = state.decoder.write(chunk);
	
	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
	
	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });
	
	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function (method) {
	        return function () {
	          return stream[method].apply(stream, arguments);
	        };
	      }(i);
	    }
	  }
	
	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function (ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });
	
	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function (n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	
	  return self;
	};
	
	// exposed for testing purposes only.
	Readable._fromList = fromList;
	
	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromList(n, state) {
	  // nothing buffered
	  if (state.length === 0) return null;
	
	  var ret;
	  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
	    // read it all, truncate the list
	    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
	    state.buffer.clear();
	  } else {
	    // read part of list
	    ret = fromListPartial(n, state.buffer, state.decoder);
	  }
	
	  return ret;
	}
	
	// Extracts only enough buffered data to satisfy the amount requested.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromListPartial(n, list, hasStrings) {
	  var ret;
	  if (n < list.head.data.length) {
	    // slice is the same for buffers and strings
	    ret = list.head.data.slice(0, n);
	    list.head.data = list.head.data.slice(n);
	  } else if (n === list.head.data.length) {
	    // first chunk is a perfect match
	    ret = list.shift();
	  } else {
	    // result spans more than one buffer
	    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
	  }
	  return ret;
	}
	
	// Copies a specified amount of characters from the list of buffered data
	// chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBufferString(n, list) {
	  var p = list.head;
	  var c = 1;
	  var ret = p.data;
	  n -= ret.length;
	  while (p = p.next) {
	    var str = p.data;
	    var nb = n > str.length ? str.length : n;
	    if (nb === str.length) ret += str;else ret += str.slice(0, n);
	    n -= nb;
	    if (n === 0) {
	      if (nb === str.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = str.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}
	
	// Copies a specified amount of bytes from the list of buffered data chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBuffer(n, list) {
	  var ret = bufferShim.allocUnsafe(n);
	  var p = list.head;
	  var c = 1;
	  p.data.copy(ret);
	  n -= p.data.length;
	  while (p = p.next) {
	    var buf = p.data;
	    var nb = n > buf.length ? buf.length : n;
	    buf.copy(ret, ret.length - n, 0, nb);
	    n -= nb;
	    if (n === 0) {
	      if (nb === buf.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = buf.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}
	
	function endReadable(stream) {
	  var state = stream._readableState;
	
	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
	
	  if (!state.endEmitted) {
	    state.ended = true;
	    processNextTick(endReadableNT, state, stream);
	  }
	}
	
	function endReadableNT(state, stream) {
	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	  }
	}
	
	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	
	function indexOf(xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	if (!process.version ||
	    process.version.indexOf('v0.') === 0 ||
	    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
	  module.exports = nextTick;
	} else {
	  module.exports = process.nextTick;
	}
	
	function nextTick(fn, arg1, arg2, arg3) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('"callback" argument must be a function');
	  }
	  var len = arguments.length;
	  var args, i;
	  switch (len) {
	  case 0:
	  case 1:
	    return process.nextTick(fn);
	  case 2:
	    return process.nextTick(function afterTickOne() {
	      fn.call(null, arg1);
	    });
	  case 3:
	    return process.nextTick(function afterTickTwo() {
	      fn.call(null, arg1, arg2);
	    });
	  case 4:
	    return process.nextTick(function afterTickThree() {
	      fn.call(null, arg1, arg2, arg3);
	    });
	  default:
	    args = new Array(len - 1);
	    i = 0;
	    while (i < args.length) {
	      args[i++] = arguments[i];
	    }
	    return process.nextTick(function afterTick() {
	      fn.apply(null, args);
	    });
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var buffer = __webpack_require__(7);
	var Buffer = buffer.Buffer;
	var SlowBuffer = buffer.SlowBuffer;
	var MAX_LEN = buffer.kMaxLength || 2147483647;
	exports.alloc = function alloc(size, fill, encoding) {
	  if (typeof Buffer.alloc === 'function') {
	    return Buffer.alloc(size, fill, encoding);
	  }
	  if (typeof encoding === 'number') {
	    throw new TypeError('encoding must not be number');
	  }
	  if (typeof size !== 'number') {
	    throw new TypeError('size must be a number');
	  }
	  if (size > MAX_LEN) {
	    throw new RangeError('size is too large');
	  }
	  var enc = encoding;
	  var _fill = fill;
	  if (_fill === undefined) {
	    enc = undefined;
	    _fill = 0;
	  }
	  var buf = new Buffer(size);
	  if (typeof _fill === 'string') {
	    var fillBuf = new Buffer(_fill, enc);
	    var flen = fillBuf.length;
	    var i = -1;
	    while (++i < size) {
	      buf[i] = fillBuf[i % flen];
	    }
	  } else {
	    buf.fill(_fill);
	  }
	  return buf;
	}
	exports.allocUnsafe = function allocUnsafe(size) {
	  if (typeof Buffer.allocUnsafe === 'function') {
	    return Buffer.allocUnsafe(size);
	  }
	  if (typeof size !== 'number') {
	    throw new TypeError('size must be a number');
	  }
	  if (size > MAX_LEN) {
	    throw new RangeError('size is too large');
	  }
	  return new Buffer(size);
	}
	exports.from = function from(value, encodingOrOffset, length) {
	  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
	    return Buffer.from(value, encodingOrOffset, length);
	  }
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number');
	  }
	  if (typeof value === 'string') {
	    return new Buffer(value, encodingOrOffset);
	  }
	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    var offset = encodingOrOffset;
	    if (arguments.length === 1) {
	      return new Buffer(value);
	    }
	    if (typeof offset === 'undefined') {
	      offset = 0;
	    }
	    var len = length;
	    if (typeof len === 'undefined') {
	      len = value.byteLength - offset;
	    }
	    if (offset >= value.byteLength) {
	      throw new RangeError('\'offset\' is out of bounds');
	    }
	    if (len > value.byteLength - offset) {
	      throw new RangeError('\'length\' is out of bounds');
	    }
	    return new Buffer(value.slice(offset, offset + len));
	  }
	  if (Buffer.isBuffer(value)) {
	    var out = new Buffer(value.length);
	    value.copy(out, 0, 0, value.length);
	    return out;
	  }
	  if (value) {
	    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {
	      return new Buffer(value);
	    }
	    if (value.type === 'Buffer' && Array.isArray(value.data)) {
	      return new Buffer(value.data);
	    }
	  }
	
	  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
	}
	exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
	  if (typeof Buffer.allocUnsafeSlow === 'function') {
	    return Buffer.allocUnsafeSlow(size);
	  }
	  if (typeof size !== 'number') {
	    throw new TypeError('size must be a number');
	  }
	  if (size >= MAX_LEN) {
	    throw new RangeError('size is too large');
	  }
	  return new SlowBuffer(size);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	
	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = Buffer.isBuffer;
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7).Buffer))

/***/ },
/* 275 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Buffer = __webpack_require__(7).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(273);
	/*</replacement>*/
	
	module.exports = BufferList;
	
	function BufferList() {
	  this.head = null;
	  this.tail = null;
	  this.length = 0;
	}
	
	BufferList.prototype.push = function (v) {
	  var entry = { data: v, next: null };
	  if (this.length > 0) this.tail.next = entry;else this.head = entry;
	  this.tail = entry;
	  ++this.length;
	};
	
	BufferList.prototype.unshift = function (v) {
	  var entry = { data: v, next: this.head };
	  if (this.length === 0) this.tail = entry;
	  this.head = entry;
	  ++this.length;
	};
	
	BufferList.prototype.shift = function () {
	  if (this.length === 0) return;
	  var ret = this.head.data;
	  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
	  --this.length;
	  return ret;
	};
	
	BufferList.prototype.clear = function () {
	  this.head = this.tail = null;
	  this.length = 0;
	};
	
	BufferList.prototype.join = function (s) {
	  if (this.length === 0) return '';
	  var p = this.head;
	  var ret = '' + p.data;
	  while (p = p.next) {
	    ret += s + p.data;
	  }return ret;
	};
	
	BufferList.prototype.concat = function (n) {
	  if (this.length === 0) return bufferShim.alloc(0);
	  if (this.length === 1) return this.head.data;
	  var ret = bufferShim.allocUnsafe(n >>> 0);
	  var p = this.head;
	  var i = 0;
	  while (p) {
	    p.data.copy(ret, i);
	    i += p.data.length;
	    p = p.next;
	  }
	  return ret;
	};

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.
	
	'use strict';
	
	/*<replacement>*/
	
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    keys.push(key);
	  }return keys;
	};
	/*</replacement>*/
	
	module.exports = Duplex;
	
	/*<replacement>*/
	var processNextTick = __webpack_require__(272);
	/*</replacement>*/
	
	/*<replacement>*/
	var util = __webpack_require__(274);
	util.inherits = __webpack_require__(261);
	/*</replacement>*/
	
	var Readable = __webpack_require__(271);
	var Writable = __webpack_require__(278);
	
	util.inherits(Duplex, Readable);
	
	var keys = objectKeys(Writable.prototype);
	for (var v = 0; v < keys.length; v++) {
	  var method = keys[v];
	  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	}
	
	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options);
	
	  Readable.call(this, options);
	  Writable.call(this, options);
	
	  if (options && options.readable === false) this.readable = false;
	
	  if (options && options.writable === false) this.writable = false;
	
	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
	
	  this.once('end', onend);
	}
	
	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended) return;
	
	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  processNextTick(onEndNT, this);
	}
	
	function onEndNT(self) {
	  self.end();
	}
	
	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, setImmediate) {// A bit simpler than readable streams.
	// Implement an async ._write(chunk, encoding, cb), and it'll handle all
	// the drain event emission and buffering.
	
	'use strict';
	
	module.exports = Writable;
	
	/*<replacement>*/
	var processNextTick = __webpack_require__(272);
	/*</replacement>*/
	
	/*<replacement>*/
	var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
	/*</replacement>*/
	
	/*<replacement>*/
	var Duplex;
	/*</replacement>*/
	
	Writable.WritableState = WritableState;
	
	/*<replacement>*/
	var util = __webpack_require__(274);
	util.inherits = __webpack_require__(261);
	/*</replacement>*/
	
	/*<replacement>*/
	var internalUtil = {
	  deprecate: __webpack_require__(279)
	};
	/*</replacement>*/
	
	/*<replacement>*/
	var Stream;
	(function () {
	  try {
	    Stream = __webpack_require__(269);
	  } catch (_) {} finally {
	    if (!Stream) Stream = __webpack_require__(216).EventEmitter;
	  }
	})();
	/*</replacement>*/
	
	var Buffer = __webpack_require__(7).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(273);
	/*</replacement>*/
	
	util.inherits(Writable, Stream);
	
	function nop() {}
	
	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	  this.next = null;
	}
	
	function WritableState(options, stream) {
	  Duplex = Duplex || __webpack_require__(277);
	
	  options = options || {};
	
	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	
	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
	
	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
	
	  // cast to ints.
	  this.highWaterMark = ~ ~this.highWaterMark;
	
	  // drain event flag.
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;
	
	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;
	
	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';
	
	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;
	
	  // a flag to see when we're in the middle of a write.
	  this.writing = false;
	
	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;
	
	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;
	
	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;
	
	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function (er) {
	    onwrite(stream, er);
	  };
	
	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;
	
	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	
	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;
	
	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;
	
	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;
	
	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	
	  // count buffered requests
	  this.bufferedRequestCount = 0;
	
	  // allocate the first CorkedRequest, there is always
	  // one allocated and free to use, and we maintain at most two
	  this.corkedRequestsFree = new CorkedRequest(this);
	}
	
	WritableState.prototype.getBuffer = function getBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};
	
	(function () {
	  try {
	    Object.defineProperty(WritableState.prototype, 'buffer', {
	      get: internalUtil.deprecate(function () {
	        return this.getBuffer();
	      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
	    });
	  } catch (_) {}
	})();
	
	// Test _writableState for inheritance to account for Duplex streams,
	// whose prototype chain only points to Readable.
	var realHasInstance;
	if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
	  realHasInstance = Function.prototype[Symbol.hasInstance];
	  Object.defineProperty(Writable, Symbol.hasInstance, {
	    value: function (object) {
	      if (realHasInstance.call(this, object)) return true;
	
	      return object && object._writableState instanceof WritableState;
	    }
	  });
	} else {
	  realHasInstance = function (object) {
	    return object instanceof this;
	  };
	}
	
	function Writable(options) {
	  Duplex = Duplex || __webpack_require__(277);
	
	  // Writable ctor is applied to Duplexes, too.
	  // `realHasInstance` is necessary because using plain `instanceof`
	  // would return false, as no `_writableState` property is attached.
	
	  // Trying to use the custom `instanceof` for Writable here will also break the
	  // Node.js LazyTransform implementation, which has a non-trivial getter for
	  // `_writableState` that would lead to infinite recursion.
	  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
	    return new Writable(options);
	  }
	
	  this._writableState = new WritableState(options, this);
	
	  // legacy.
	  this.writable = true;
	
	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;
	
	    if (typeof options.writev === 'function') this._writev = options.writev;
	  }
	
	  Stream.call(this);
	}
	
	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  this.emit('error', new Error('Cannot pipe, not readable'));
	};
	
	function writeAfterEnd(stream, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  processNextTick(cb, er);
	}
	
	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  var er = false;
	  // Always throw error if a null is written
	  // if we are not in object mode then throw
	  // if it is not a buffer, string, or undefined.
	  if (chunk === null) {
	    er = new TypeError('May not write null values to stream');
	  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  if (er) {
	    stream.emit('error', er);
	    processNextTick(cb, er);
	    valid = false;
	  }
	  return valid;
	}
	
	Writable.prototype.write = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	
	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
	
	  if (typeof cb !== 'function') cb = nop;
	
	  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }
	
	  return ret;
	};
	
	Writable.prototype.cork = function () {
	  var state = this._writableState;
	
	  state.corked++;
	};
	
	Writable.prototype.uncork = function () {
	  var state = this._writableState;
	
	  if (state.corked) {
	    state.corked--;
	
	    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
	  }
	};
	
	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
	  this._writableState.defaultEncoding = encoding;
	  return this;
	};
	
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
	    chunk = bufferShim.from(chunk, encoding);
	  }
	  return chunk;
	}
	
	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	
	  if (Buffer.isBuffer(chunk)) encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;
	
	  state.length += len;
	
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;
	
	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	    state.bufferedRequestCount += 1;
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }
	
	  return ret;
	}
	
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	
	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;
	  if (sync) processNextTick(cb, er);else cb(er);
	
	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}
	
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	
	  onwriteStateUpdate(state);
	
	  if (er) onwriteError(stream, state, sync, er, cb);else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state);
	
	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }
	
	    if (sync) {
	      /*<replacement>*/
	      asyncWrite(afterWrite, stream, state, finished, cb);
	      /*</replacement>*/
	    } else {
	        afterWrite(stream, state, finished, cb);
	      }
	  }
	}
	
	function afterWrite(stream, state, finished, cb) {
	  if (!finished) onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}
	
	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}
	
	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;
	
	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var l = state.bufferedRequestCount;
	    var buffer = new Array(l);
	    var holder = state.corkedRequestsFree;
	    holder.entry = entry;
	
	    var count = 0;
	    while (entry) {
	      buffer[count] = entry;
	      entry = entry.next;
	      count += 1;
	    }
	
	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);
	
	    // doWrite is almost always async, defer these to save a bit of time
	    // as the hot path ends with doWrite
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    if (holder.next) {
	      state.corkedRequestsFree = holder.next;
	      holder.next = null;
	    } else {
	      state.corkedRequestsFree = new CorkedRequest(state);
	    }
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;
	
	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }
	
	    if (entry === null) state.lastBufferedRequest = null;
	  }
	
	  state.bufferedRequestCount = 0;
	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}
	
	Writable.prototype._write = function (chunk, encoding, cb) {
	  cb(new Error('_write() is not implemented'));
	};
	
	Writable.prototype._writev = null;
	
	Writable.prototype.end = function (chunk, encoding, cb) {
	  var state = this._writableState;
	
	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	
	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
	
	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }
	
	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished) endWritable(this, state, cb);
	};
	
	function needFinish(state) {
	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}
	
	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}
	
	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else {
	      prefinish(stream, state);
	    }
	  }
	  return need;
	}
	
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
	  }
	  state.ended = true;
	  stream.writable = false;
	}
	
	// It seems a linked list but it is not
	// there will be only 2 of these for each stream
	function CorkedRequest(state) {
	  var _this = this;
	
	  this.next = null;
	  this.entry = null;
	
	  this.finish = function (err) {
	    var entry = _this.entry;
	    _this.entry = null;
	    while (entry) {
	      var cb = entry.callback;
	      state.pendingcb--;
	      cb(err);
	      entry = entry.next;
	    }
	    if (state.corkedRequestsFree) {
	      state.corkedRequestsFree.next = _this;
	    } else {
	      state.corkedRequestsFree = _this;
	    }
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(11).setImmediate))

/***/ },
/* 279 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module exports.
	 */
	
	module.exports = deprecate;
	
	/**
	 * Mark that a method should not be used.
	 * Returns a modified function which warns once by default.
	 *
	 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
	 *
	 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
	 * will throw an Error when invoked.
	 *
	 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
	 * will invoke `console.trace()` instead of `console.error()`.
	 *
	 * @param {Function} fn - the function to deprecate
	 * @param {String} msg - the string to print to the console when `fn` is invoked
	 * @returns {Function} a new "deprecated" version of `fn`
	 * @api public
	 */
	
	function deprecate (fn, msg) {
	  if (config('noDeprecation')) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (config('throwDeprecation')) {
	        throw new Error(msg);
	      } else if (config('traceDeprecation')) {
	        console.trace(msg);
	      } else {
	        console.warn(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	}
	
	/**
	 * Checks `localStorage` for boolean values for the given `name`.
	 *
	 * @param {String} name
	 * @returns {Boolean}
	 * @api private
	 */
	
	function config (name) {
	  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
	  try {
	    if (!global.localStorage) return false;
	  } catch (_) {
	    return false;
	  }
	  var val = global.localStorage[name];
	  if (null == val) return false;
	  return String(val).toLowerCase() === 'true';
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var Buffer = __webpack_require__(7).Buffer;
	
	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }
	
	
	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}
	
	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }
	
	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};
	
	
	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;
	
	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;
	
	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }
	
	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);
	
	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
	
	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;
	
	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }
	
	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);
	
	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }
	
	  charStr += buffer.toString(this.encoding, 0, end);
	
	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }
	
	  // or just emit the charStr
	  return charStr;
	};
	
	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;
	
	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];
	
	    // See http://en.wikipedia.org/wiki/UTF-8#Description
	
	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }
	
	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }
	
	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};
	
	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);
	
	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }
	
	  return res;
	};
	
	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}
	
	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}
	
	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.
	
	'use strict';
	
	module.exports = Transform;
	
	var Duplex = __webpack_require__(277);
	
	/*<replacement>*/
	var util = __webpack_require__(274);
	util.inherits = __webpack_require__(261);
	/*</replacement>*/
	
	util.inherits(Transform, Duplex);
	
	function TransformState(stream) {
	  this.afterTransform = function (er, data) {
	    return afterTransform(stream, er, data);
	  };
	
	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	  this.writeencoding = null;
	}
	
	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;
	
	  var cb = ts.writecb;
	
	  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));
	
	  ts.writechunk = null;
	  ts.writecb = null;
	
	  if (data !== null && data !== undefined) stream.push(data);
	
	  cb(er);
	
	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}
	
	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options);
	
	  Duplex.call(this, options);
	
	  this._transformState = new TransformState(this);
	
	  var stream = this;
	
	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;
	
	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	
	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;
	
	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }
	
	  // When the writable side finishes, then flush out anything remaining.
	  this.once('prefinish', function () {
	    if (typeof this._flush === 'function') this._flush(function (er, data) {
	      done(stream, er, data);
	    });else done(stream);
	  });
	}
	
	Transform.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};
	
	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function (chunk, encoding, cb) {
	  throw new Error('_transform() is not implemented');
	};
	
	Transform.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	};
	
	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function (n) {
	  var ts = this._transformState;
	
	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	
	function done(stream, er, data) {
	  if (er) return stream.emit('error', er);
	
	  if (data !== null && data !== undefined) stream.push(data);
	
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;
	
	  if (ws.length) throw new Error('Calling transform done when ws.length != 0');
	
	  if (ts.transforming) throw new Error('Calling transform done when still transforming');
	
	  return stream.push(null);
	}

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.
	
	'use strict';
	
	module.exports = PassThrough;
	
	var Transform = __webpack_require__(281);
	
	/*<replacement>*/
	var util = __webpack_require__(274);
	util.inherits = __webpack_require__(261);
	/*</replacement>*/
	
	util.inherits(PassThrough, Transform);
	
	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);
	
	  Transform.call(this, options);
	}
	
	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(278)


/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(277)


/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(281)


/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(282)


/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = (__webpack_require__(3))(54);

/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
	// original notice:
	
	/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	function compare(a, b) {
	  if (a === b) {
	    return 0;
	  }
	
	  var x = a.length;
	  var y = b.length;
	
	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break;
	    }
	  }
	
	  if (x < y) {
	    return -1;
	  }
	  if (y < x) {
	    return 1;
	  }
	  return 0;
	}
	function isBuffer(b) {
	  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
	    return global.Buffer.isBuffer(b);
	  }
	  return !!(b != null && b._isBuffer);
	}
	
	// based on node assert, original notice:
	
	// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
	//
	// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
	//
	// Originally from narwhal.js (http://narwhaljs.org)
	// Copyright (c) 2009 Thomas Robinson <280north.com>
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the 'Software'), to
	// deal in the Software without restriction, including without limitation the
	// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	// sell copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var util = __webpack_require__(287);
	var hasOwn = Object.prototype.hasOwnProperty;
	var pSlice = Array.prototype.slice;
	var functionsHaveNames = (function () {
	  return function foo() {}.name === 'foo';
	}());
	function pToString (obj) {
	  return Object.prototype.toString.call(obj);
	}
	function isView(arrbuf) {
	  if (isBuffer(arrbuf)) {
	    return false;
	  }
	  if (typeof global.ArrayBuffer !== 'function') {
	    return false;
	  }
	  if (typeof ArrayBuffer.isView === 'function') {
	    return ArrayBuffer.isView(arrbuf);
	  }
	  if (!arrbuf) {
	    return false;
	  }
	  if (arrbuf instanceof DataView) {
	    return true;
	  }
	  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
	    return true;
	  }
	  return false;
	}
	// 1. The assert module provides functions that throw
	// AssertionError's when particular conditions are not met. The
	// assert module must conform to the following interface.
	
	var assert = module.exports = ok;
	
	// 2. The AssertionError is defined in assert.
	// new assert.AssertionError({ message: message,
	//                             actual: actual,
	//                             expected: expected })
	
	var regex = /\s*function\s+([^\(\s]*)\s*/;
	// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
	function getName(func) {
	  if (!util.isFunction(func)) {
	    return;
	  }
	  if (functionsHaveNames) {
	    return func.name;
	  }
	  var str = func.toString();
	  var match = str.match(regex);
	  return match && match[1];
	}
	assert.AssertionError = function AssertionError(options) {
	  this.name = 'AssertionError';
	  this.actual = options.actual;
	  this.expected = options.expected;
	  this.operator = options.operator;
	  if (options.message) {
	    this.message = options.message;
	    this.generatedMessage = false;
	  } else {
	    this.message = getMessage(this);
	    this.generatedMessage = true;
	  }
	  var stackStartFunction = options.stackStartFunction || fail;
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, stackStartFunction);
	  } else {
	    // non v8 browsers so we can have a stacktrace
	    var err = new Error();
	    if (err.stack) {
	      var out = err.stack;
	
	      // try to strip useless frames
	      var fn_name = getName(stackStartFunction);
	      var idx = out.indexOf('\n' + fn_name);
	      if (idx >= 0) {
	        // once we have located the function frame
	        // we need to strip out everything before it (and its line)
	        var next_line = out.indexOf('\n', idx + 1);
	        out = out.substring(next_line + 1);
	      }
	
	      this.stack = out;
	    }
	  }
	};
	
	// assert.AssertionError instanceof Error
	util.inherits(assert.AssertionError, Error);
	
	function truncate(s, n) {
	  if (typeof s === 'string') {
	    return s.length < n ? s : s.slice(0, n);
	  } else {
	    return s;
	  }
	}
	function inspect(something) {
	  if (functionsHaveNames || !util.isFunction(something)) {
	    return util.inspect(something);
	  }
	  var rawname = getName(something);
	  var name = rawname ? ': ' + rawname : '';
	  return '[Function' +  name + ']';
	}
	function getMessage(self) {
	  return truncate(inspect(self.actual), 128) + ' ' +
	         self.operator + ' ' +
	         truncate(inspect(self.expected), 128);
	}
	
	// At present only the three keys mentioned above are used and
	// understood by the spec. Implementations or sub modules can pass
	// other keys to the AssertionError's constructor - they will be
	// ignored.
	
	// 3. All of the following functions must throw an AssertionError
	// when a corresponding condition is not met, with a message that
	// may be undefined if not provided.  All assertion methods provide
	// both the actual and expected values to the assertion error for
	// display purposes.
	
	function fail(actual, expected, message, operator, stackStartFunction) {
	  throw new assert.AssertionError({
	    message: message,
	    actual: actual,
	    expected: expected,
	    operator: operator,
	    stackStartFunction: stackStartFunction
	  });
	}
	
	// EXTENSION! allows for well behaved errors defined elsewhere.
	assert.fail = fail;
	
	// 4. Pure assertion tests whether a value is truthy, as determined
	// by !!guard.
	// assert.ok(guard, message_opt);
	// This statement is equivalent to assert.equal(true, !!guard,
	// message_opt);. To test strictly for the value true, use
	// assert.strictEqual(true, guard, message_opt);.
	
	function ok(value, message) {
	  if (!value) fail(value, true, message, '==', assert.ok);
	}
	assert.ok = ok;
	
	// 5. The equality assertion tests shallow, coercive equality with
	// ==.
	// assert.equal(actual, expected, message_opt);
	
	assert.equal = function equal(actual, expected, message) {
	  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
	};
	
	// 6. The non-equality assertion tests for whether two objects are not equal
	// with != assert.notEqual(actual, expected, message_opt);
	
	assert.notEqual = function notEqual(actual, expected, message) {
	  if (actual == expected) {
	    fail(actual, expected, message, '!=', assert.notEqual);
	  }
	};
	
	// 7. The equivalence assertion tests a deep equality relation.
	// assert.deepEqual(actual, expected, message_opt);
	
	assert.deepEqual = function deepEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
	  }
	};
	
	assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
	  }
	};
	
	function _deepEqual(actual, expected, strict, memos) {
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	  } else if (isBuffer(actual) && isBuffer(expected)) {
	    return compare(actual, expected) === 0;
	
	  // 7.2. If the expected value is a Date object, the actual value is
	  // equivalent if it is also a Date object that refers to the same time.
	  } else if (util.isDate(actual) && util.isDate(expected)) {
	    return actual.getTime() === expected.getTime();
	
	  // 7.3 If the expected value is a RegExp object, the actual value is
	  // equivalent if it is also a RegExp object with the same source and
	  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	    return actual.source === expected.source &&
	           actual.global === expected.global &&
	           actual.multiline === expected.multiline &&
	           actual.lastIndex === expected.lastIndex &&
	           actual.ignoreCase === expected.ignoreCase;
	
	  // 7.4. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if ((actual === null || typeof actual !== 'object') &&
	             (expected === null || typeof expected !== 'object')) {
	    return strict ? actual === expected : actual == expected;
	
	  // If both values are instances of typed arrays, wrap their underlying
	  // ArrayBuffers in a Buffer each to increase performance
	  // This optimization requires the arrays to have the same type as checked by
	  // Object.prototype.toString (aka pToString). Never perform binary
	  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
	  // bit patterns are not identical.
	  } else if (isView(actual) && isView(expected) &&
	             pToString(actual) === pToString(expected) &&
	             !(actual instanceof Float32Array ||
	               actual instanceof Float64Array)) {
	    return compare(new Uint8Array(actual.buffer),
	                   new Uint8Array(expected.buffer)) === 0;
	
	  // 7.5 For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else if (isBuffer(actual) !== isBuffer(expected)) {
	    return false;
	  } else {
	    memos = memos || {actual: [], expected: []};
	
	    var actualIndex = memos.actual.indexOf(actual);
	    if (actualIndex !== -1) {
	      if (actualIndex === memos.expected.indexOf(expected)) {
	        return true;
	      }
	    }
	
	    memos.actual.push(actual);
	    memos.expected.push(expected);
	
	    return objEquiv(actual, expected, strict, memos);
	  }
	}
	
	function isArguments(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}
	
	function objEquiv(a, b, strict, actualVisitedObjects) {
	  if (a === null || a === undefined || b === null || b === undefined)
	    return false;
	  // if one is a primitive, the other must be same
	  if (util.isPrimitive(a) || util.isPrimitive(b))
	    return a === b;
	  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
	    return false;
	  var aIsArgs = isArguments(a);
	  var bIsArgs = isArguments(b);
	  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
	    return false;
	  if (aIsArgs) {
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return _deepEqual(a, b, strict);
	  }
	  var ka = objectKeys(a);
	  var kb = objectKeys(b);
	  var key, i;
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length !== kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] !== kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
	      return false;
	  }
	  return true;
	}
	
	// 8. The non-equivalence assertion tests for any deep inequality.
	// assert.notDeepEqual(actual, expected, message_opt);
	
	assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
	  }
	};
	
	assert.notDeepStrictEqual = notDeepStrictEqual;
	function notDeepStrictEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
	  }
	}
	
	
	// 9. The strict equality assertion tests strict equality, as determined by ===.
	// assert.strictEqual(actual, expected, message_opt);
	
	assert.strictEqual = function strictEqual(actual, expected, message) {
	  if (actual !== expected) {
	    fail(actual, expected, message, '===', assert.strictEqual);
	  }
	};
	
	// 10. The strict non-equality assertion tests for strict inequality, as
	// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);
	
	assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
	  if (actual === expected) {
	    fail(actual, expected, message, '!==', assert.notStrictEqual);
	  }
	};
	
	function expectedException(actual, expected) {
	  if (!actual || !expected) {
	    return false;
	  }
	
	  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	    return expected.test(actual);
	  }
	
	  try {
	    if (actual instanceof expected) {
	      return true;
	    }
	  } catch (e) {
	    // Ignore.  The instanceof check doesn't work for arrow functions.
	  }
	
	  if (Error.isPrototypeOf(expected)) {
	    return false;
	  }
	
	  return expected.call({}, actual) === true;
	}
	
	function _tryBlock(block) {
	  var error;
	  try {
	    block();
	  } catch (e) {
	    error = e;
	  }
	  return error;
	}
	
	function _throws(shouldThrow, block, expected, message) {
	  var actual;
	
	  if (typeof block !== 'function') {
	    throw new TypeError('"block" argument must be a function');
	  }
	
	  if (typeof expected === 'string') {
	    message = expected;
	    expected = null;
	  }
	
	  actual = _tryBlock(block);
	
	  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
	            (message ? ' ' + message : '.');
	
	  if (shouldThrow && !actual) {
	    fail(actual, expected, 'Missing expected exception' + message);
	  }
	
	  var userProvidedMessage = typeof message === 'string';
	  var isUnwantedException = !shouldThrow && util.isError(actual);
	  var isUnexpectedException = !shouldThrow && actual && !expected;
	
	  if ((isUnwantedException &&
	      userProvidedMessage &&
	      expectedException(actual, expected)) ||
	      isUnexpectedException) {
	    fail(actual, expected, 'Got unwanted exception' + message);
	  }
	
	  if ((shouldThrow && actual && expected &&
	      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
	    throw actual;
	  }
	}
	
	// 11. Expected to throw an error:
	// assert.throws(block, Error_opt, message_opt);
	
	assert.throws = function(block, /*optional*/error, /*optional*/message) {
	  _throws(true, block, error, message);
	};
	
	// EXTENSION! This is annoying to write outside this module.
	assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
	  _throws(false, block, error, message);
	};
	
	assert.ifError = function(err) { if (err) throw err; };
	
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    if (hasOwn.call(obj, key)) keys.push(key);
	  }
	  return keys;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = minimatch
	minimatch.Minimatch = Minimatch
	
	var path = { sep: '/' }
	try {
	  path = __webpack_require__(4)
	} catch (er) {}
	
	var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
	var expand = __webpack_require__(290)
	
	var plTypes = {
	  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
	  '?': { open: '(?:', close: ')?' },
	  '+': { open: '(?:', close: ')+' },
	  '*': { open: '(?:', close: ')*' },
	  '@': { open: '(?:', close: ')' }
	}
	
	// any single thing other than /
	// don't need to escape / when using new RegExp()
	var qmark = '[^/]'
	
	// * => any number of characters
	var star = qmark + '*?'
	
	// ** when dots are allowed.  Anything goes, except .. and .
	// not (^ or / followed by one or two dots followed by $ or /),
	// followed by anything, any number of times.
	var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'
	
	// not a ^ or / followed by a dot,
	// followed by anything, any number of times.
	var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'
	
	// characters that need to be escaped in RegExp.
	var reSpecials = charSet('().*{}+?[]^$\\!')
	
	// "abc" -> { a:true, b:true, c:true }
	function charSet (s) {
	  return s.split('').reduce(function (set, c) {
	    set[c] = true
	    return set
	  }, {})
	}
	
	// normalizes slashes.
	var slashSplit = /\/+/
	
	minimatch.filter = filter
	function filter (pattern, options) {
	  options = options || {}
	  return function (p, i, list) {
	    return minimatch(p, pattern, options)
	  }
	}
	
	function ext (a, b) {
	  a = a || {}
	  b = b || {}
	  var t = {}
	  Object.keys(b).forEach(function (k) {
	    t[k] = b[k]
	  })
	  Object.keys(a).forEach(function (k) {
	    t[k] = a[k]
	  })
	  return t
	}
	
	minimatch.defaults = function (def) {
	  if (!def || !Object.keys(def).length) return minimatch
	
	  var orig = minimatch
	
	  var m = function minimatch (p, pattern, options) {
	    return orig.minimatch(p, pattern, ext(def, options))
	  }
	
	  m.Minimatch = function Minimatch (pattern, options) {
	    return new orig.Minimatch(pattern, ext(def, options))
	  }
	
	  return m
	}
	
	Minimatch.defaults = function (def) {
	  if (!def || !Object.keys(def).length) return Minimatch
	  return minimatch.defaults(def).Minimatch
	}
	
	function minimatch (p, pattern, options) {
	  if (typeof pattern !== 'string') {
	    throw new TypeError('glob pattern string required')
	  }
	
	  if (!options) options = {}
	
	  // shortcut: comments match nothing.
	  if (!options.nocomment && pattern.charAt(0) === '#') {
	    return false
	  }
	
	  // "" only matches ""
	  if (pattern.trim() === '') return p === ''
	
	  return new Minimatch(pattern, options).match(p)
	}
	
	function Minimatch (pattern, options) {
	  if (!(this instanceof Minimatch)) {
	    return new Minimatch(pattern, options)
	  }
	
	  if (typeof pattern !== 'string') {
	    throw new TypeError('glob pattern string required')
	  }
	
	  if (!options) options = {}
	  pattern = pattern.trim()
	
	  // windows support: need to use /, not \
	  if (path.sep !== '/') {
	    pattern = pattern.split(path.sep).join('/')
	  }
	
	  this.options = options
	  this.set = []
	  this.pattern = pattern
	  this.regexp = null
	  this.negate = false
	  this.comment = false
	  this.empty = false
	
	  // make the set of regexps etc.
	  this.make()
	}
	
	Minimatch.prototype.debug = function () {}
	
	Minimatch.prototype.make = make
	function make () {
	  // don't do it more than once.
	  if (this._made) return
	
	  var pattern = this.pattern
	  var options = this.options
	
	  // empty patterns and comments match nothing.
	  if (!options.nocomment && pattern.charAt(0) === '#') {
	    this.comment = true
	    return
	  }
	  if (!pattern) {
	    this.empty = true
	    return
	  }
	
	  // step 1: figure out negation, etc.
	  this.parseNegate()
	
	  // step 2: expand braces
	  var set = this.globSet = this.braceExpand()
	
	  if (options.debug) this.debug = console.error
	
	  this.debug(this.pattern, set)
	
	  // step 3: now we have a set, so turn each one into a series of path-portion
	  // matching patterns.
	  // These will be regexps, except in the case of "**", which is
	  // set to the GLOBSTAR object for globstar behavior,
	  // and will not contain any / characters
	  set = this.globParts = set.map(function (s) {
	    return s.split(slashSplit)
	  })
	
	  this.debug(this.pattern, set)
	
	  // glob --> regexps
	  set = set.map(function (s, si, set) {
	    return s.map(this.parse, this)
	  }, this)
	
	  this.debug(this.pattern, set)
	
	  // filter out everything that didn't compile properly.
	  set = set.filter(function (s) {
	    return s.indexOf(false) === -1
	  })
	
	  this.debug(this.pattern, set)
	
	  this.set = set
	}
	
	Minimatch.prototype.parseNegate = parseNegate
	function parseNegate () {
	  var pattern = this.pattern
	  var negate = false
	  var options = this.options
	  var negateOffset = 0
	
	  if (options.nonegate) return
	
	  for (var i = 0, l = pattern.length
	    ; i < l && pattern.charAt(i) === '!'
	    ; i++) {
	    negate = !negate
	    negateOffset++
	  }
	
	  if (negateOffset) this.pattern = pattern.substr(negateOffset)
	  this.negate = negate
	}
	
	// Brace expansion:
	// a{b,c}d -> abd acd
	// a{b,}c -> abc ac
	// a{0..3}d -> a0d a1d a2d a3d
	// a{b,c{d,e}f}g -> abg acdfg acefg
	// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
	//
	// Invalid sets are not expanded.
	// a{2..}b -> a{2..}b
	// a{b}c -> a{b}c
	minimatch.braceExpand = function (pattern, options) {
	  return braceExpand(pattern, options)
	}
	
	Minimatch.prototype.braceExpand = braceExpand
	
	function braceExpand (pattern, options) {
	  if (!options) {
	    if (this instanceof Minimatch) {
	      options = this.options
	    } else {
	      options = {}
	    }
	  }
	
	  pattern = typeof pattern === 'undefined'
	    ? this.pattern : pattern
	
	  if (typeof pattern === 'undefined') {
	    throw new TypeError('undefined pattern')
	  }
	
	  if (options.nobrace ||
	    !pattern.match(/\{.*\}/)) {
	    // shortcut. no need to expand.
	    return [pattern]
	  }
	
	  return expand(pattern)
	}
	
	// parse a component of the expanded set.
	// At this point, no pattern may contain "/" in it
	// so we're going to return a 2d array, where each entry is the full
	// pattern, split on '/', and then turned into a regular expression.
	// A regexp is made at the end which joins each array with an
	// escaped /, and another full one which joins each regexp with |.
	//
	// Following the lead of Bash 4.1, note that "**" only has special meaning
	// when it is the *only* thing in a path portion.  Otherwise, any series
	// of * is equivalent to a single *.  Globstar behavior is enabled by
	// default, and can be disabled by setting options.noglobstar.
	Minimatch.prototype.parse = parse
	var SUBPARSE = {}
	function parse (pattern, isSub) {
	  if (pattern.length > 1024 * 64) {
	    throw new TypeError('pattern is too long')
	  }
	
	  var options = this.options
	
	  // shortcuts
	  if (!options.noglobstar && pattern === '**') return GLOBSTAR
	  if (pattern === '') return ''
	
	  var re = ''
	  var hasMagic = !!options.nocase
	  var escaping = false
	  // ? => one single character
	  var patternListStack = []
	  var negativeLists = []
	  var stateChar
	  var inClass = false
	  var reClassStart = -1
	  var classStart = -1
	  // . and .. never match anything that doesn't start with .,
	  // even when options.dot is set.
	  var patternStart = pattern.charAt(0) === '.' ? '' // anything
	  // not (start or / followed by . or .. followed by / or end)
	  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
	  : '(?!\\.)'
	  var self = this
	
	  function clearStateChar () {
	    if (stateChar) {
	      // we had some state-tracking character
	      // that wasn't consumed by this pass.
	      switch (stateChar) {
	        case '*':
	          re += star
	          hasMagic = true
	        break
	        case '?':
	          re += qmark
	          hasMagic = true
	        break
	        default:
	          re += '\\' + stateChar
	        break
	      }
	      self.debug('clearStateChar %j %j', stateChar, re)
	      stateChar = false
	    }
	  }
	
	  for (var i = 0, len = pattern.length, c
	    ; (i < len) && (c = pattern.charAt(i))
	    ; i++) {
	    this.debug('%s\t%s %s %j', pattern, i, re, c)
	
	    // skip over any that are escaped.
	    if (escaping && reSpecials[c]) {
	      re += '\\' + c
	      escaping = false
	      continue
	    }
	
	    switch (c) {
	      case '/':
	        // completely not allowed, even escaped.
	        // Should already be path-split by now.
	        return false
	
	      case '\\':
	        clearStateChar()
	        escaping = true
	      continue
	
	      // the various stateChar values
	      // for the "extglob" stuff.
	      case '?':
	      case '*':
	      case '+':
	      case '@':
	      case '!':
	        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)
	
	        // all of those are literals inside a class, except that
	        // the glob [!a] means [^a] in regexp
	        if (inClass) {
	          this.debug('  in class')
	          if (c === '!' && i === classStart + 1) c = '^'
	          re += c
	          continue
	        }
	
	        // if we already have a stateChar, then it means
	        // that there was something like ** or +? in there.
	        // Handle the stateChar, then proceed with this one.
	        self.debug('call clearStateChar %j', stateChar)
	        clearStateChar()
	        stateChar = c
	        // if extglob is disabled, then +(asdf|foo) isn't a thing.
	        // just clear the statechar *now*, rather than even diving into
	        // the patternList stuff.
	        if (options.noext) clearStateChar()
	      continue
	
	      case '(':
	        if (inClass) {
	          re += '('
	          continue
	        }
	
	        if (!stateChar) {
	          re += '\\('
	          continue
	        }
	
	        patternListStack.push({
	          type: stateChar,
	          start: i - 1,
	          reStart: re.length,
	          open: plTypes[stateChar].open,
	          close: plTypes[stateChar].close
	        })
	        // negation is (?:(?!js)[^/]*)
	        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
	        this.debug('plType %j %j', stateChar, re)
	        stateChar = false
	      continue
	
	      case ')':
	        if (inClass || !patternListStack.length) {
	          re += '\\)'
	          continue
	        }
	
	        clearStateChar()
	        hasMagic = true
	        var pl = patternListStack.pop()
	        // negation is (?:(?!js)[^/]*)
	        // The others are (?:<pattern>)<type>
	        re += pl.close
	        if (pl.type === '!') {
	          negativeLists.push(pl)
	        }
	        pl.reEnd = re.length
	      continue
	
	      case '|':
	        if (inClass || !patternListStack.length || escaping) {
	          re += '\\|'
	          escaping = false
	          continue
	        }
	
	        clearStateChar()
	        re += '|'
	      continue
	
	      // these are mostly the same in regexp and glob
	      case '[':
	        // swallow any state-tracking char before the [
	        clearStateChar()
	
	        if (inClass) {
	          re += '\\' + c
	          continue
	        }
	
	        inClass = true
	        classStart = i
	        reClassStart = re.length
	        re += c
	      continue
	
	      case ']':
	        //  a right bracket shall lose its special
	        //  meaning and represent itself in
	        //  a bracket expression if it occurs
	        //  first in the list.  -- POSIX.2 2.8.3.2
	        if (i === classStart + 1 || !inClass) {
	          re += '\\' + c
	          escaping = false
	          continue
	        }
	
	        // handle the case where we left a class open.
	        // "[z-a]" is valid, equivalent to "\[z-a\]"
	        if (inClass) {
	          // split where the last [ was, make sure we don't have
	          // an invalid re. if so, re-walk the contents of the
	          // would-be class to re-translate any characters that
	          // were passed through as-is
	          // TODO: It would probably be faster to determine this
	          // without a try/catch and a new RegExp, but it's tricky
	          // to do safely.  For now, this is safe and works.
	          var cs = pattern.substring(classStart + 1, i)
	          try {
	            RegExp('[' + cs + ']')
	          } catch (er) {
	            // not a valid class!
	            var sp = this.parse(cs, SUBPARSE)
	            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
	            hasMagic = hasMagic || sp[1]
	            inClass = false
	            continue
	          }
	        }
	
	        // finish up the class.
	        hasMagic = true
	        inClass = false
	        re += c
	      continue
	
	      default:
	        // swallow any state char that wasn't consumed
	        clearStateChar()
	
	        if (escaping) {
	          // no need
	          escaping = false
	        } else if (reSpecials[c]
	          && !(c === '^' && inClass)) {
	          re += '\\'
	        }
	
	        re += c
	
	    } // switch
	  } // for
	
	  // handle the case where we left a class open.
	  // "[abc" is valid, equivalent to "\[abc"
	  if (inClass) {
	    // split where the last [ was, and escape it
	    // this is a huge pita.  We now have to re-walk
	    // the contents of the would-be class to re-translate
	    // any characters that were passed through as-is
	    cs = pattern.substr(classStart + 1)
	    sp = this.parse(cs, SUBPARSE)
	    re = re.substr(0, reClassStart) + '\\[' + sp[0]
	    hasMagic = hasMagic || sp[1]
	  }
	
	  // handle the case where we had a +( thing at the *end*
	  // of the pattern.
	  // each pattern list stack adds 3 chars, and we need to go through
	  // and escape any | chars that were passed through as-is for the regexp.
	  // Go through and escape them, taking care not to double-escape any
	  // | chars that were already escaped.
	  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
	    var tail = re.slice(pl.reStart + pl.open.length)
	    this.debug('setting tail', re, pl)
	    // maybe some even number of \, then maybe 1 \, followed by a |
	    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
	      if (!$2) {
	        // the | isn't already escaped, so escape it.
	        $2 = '\\'
	      }
	
	      // need to escape all those slashes *again*, without escaping the
	      // one that we need for escaping the | character.  As it works out,
	      // escaping an even number of slashes can be done by simply repeating
	      // it exactly after itself.  That's why this trick works.
	      //
	      // I am sorry that you have to see this.
	      return $1 + $1 + $2 + '|'
	    })
	
	    this.debug('tail=%j\n   %s', tail, tail, pl, re)
	    var t = pl.type === '*' ? star
	      : pl.type === '?' ? qmark
	      : '\\' + pl.type
	
	    hasMagic = true
	    re = re.slice(0, pl.reStart) + t + '\\(' + tail
	  }
	
	  // handle trailing things that only matter at the very end.
	  clearStateChar()
	  if (escaping) {
	    // trailing \\
	    re += '\\\\'
	  }
	
	  // only need to apply the nodot start if the re starts with
	  // something that could conceivably capture a dot
	  var addPatternStart = false
	  switch (re.charAt(0)) {
	    case '.':
	    case '[':
	    case '(': addPatternStart = true
	  }
	
	  // Hack to work around lack of negative lookbehind in JS
	  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
	  // like 'a.xyz.yz' doesn't match.  So, the first negative
	  // lookahead, has to look ALL the way ahead, to the end of
	  // the pattern.
	  for (var n = negativeLists.length - 1; n > -1; n--) {
	    var nl = negativeLists[n]
	
	    var nlBefore = re.slice(0, nl.reStart)
	    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
	    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
	    var nlAfter = re.slice(nl.reEnd)
	
	    nlLast += nlAfter
	
	    // Handle nested stuff like *(*.js|!(*.json)), where open parens
	    // mean that we should *not* include the ) in the bit that is considered
	    // "after" the negated section.
	    var openParensBefore = nlBefore.split('(').length - 1
	    var cleanAfter = nlAfter
	    for (i = 0; i < openParensBefore; i++) {
	      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
	    }
	    nlAfter = cleanAfter
	
	    var dollar = ''
	    if (nlAfter === '' && isSub !== SUBPARSE) {
	      dollar = '$'
	    }
	    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
	    re = newRe
	  }
	
	  // if the re is not "" at this point, then we need to make sure
	  // it doesn't match against an empty path part.
	  // Otherwise a/* will match a/, which it should not.
	  if (re !== '' && hasMagic) {
	    re = '(?=.)' + re
	  }
	
	  if (addPatternStart) {
	    re = patternStart + re
	  }
	
	  // parsing just a piece of a larger pattern.
	  if (isSub === SUBPARSE) {
	    return [re, hasMagic]
	  }
	
	  // skip the regexp for non-magical patterns
	  // unescape anything in it, though, so that it'll be
	  // an exact match against a file etc.
	  if (!hasMagic) {
	    return globUnescape(pattern)
	  }
	
	  var flags = options.nocase ? 'i' : ''
	  try {
	    var regExp = new RegExp('^' + re + '$', flags)
	  } catch (er) {
	    // If it was an invalid regular expression, then it can't match
	    // anything.  This trick looks for a character after the end of
	    // the string, which is of course impossible, except in multi-line
	    // mode, but it's not a /m regex.
	    return new RegExp('$.')
	  }
	
	  regExp._glob = pattern
	  regExp._src = re
	
	  return regExp
	}
	
	minimatch.makeRe = function (pattern, options) {
	  return new Minimatch(pattern, options || {}).makeRe()
	}
	
	Minimatch.prototype.makeRe = makeRe
	function makeRe () {
	  if (this.regexp || this.regexp === false) return this.regexp
	
	  // at this point, this.set is a 2d array of partial
	  // pattern strings, or "**".
	  //
	  // It's better to use .match().  This function shouldn't
	  // be used, really, but it's pretty convenient sometimes,
	  // when you just want to work with a regex.
	  var set = this.set
	
	  if (!set.length) {
	    this.regexp = false
	    return this.regexp
	  }
	  var options = this.options
	
	  var twoStar = options.noglobstar ? star
	    : options.dot ? twoStarDot
	    : twoStarNoDot
	  var flags = options.nocase ? 'i' : ''
	
	  var re = set.map(function (pattern) {
	    return pattern.map(function (p) {
	      return (p === GLOBSTAR) ? twoStar
	      : (typeof p === 'string') ? regExpEscape(p)
	      : p._src
	    }).join('\\\/')
	  }).join('|')
	
	  // must match entire pattern
	  // ending in a * or ** will make it less strict.
	  re = '^(?:' + re + ')$'
	
	  // can match anything, as long as it's not this.
	  if (this.negate) re = '^(?!' + re + ').*$'
	
	  try {
	    this.regexp = new RegExp(re, flags)
	  } catch (ex) {
	    this.regexp = false
	  }
	  return this.regexp
	}
	
	minimatch.match = function (list, pattern, options) {
	  options = options || {}
	  var mm = new Minimatch(pattern, options)
	  list = list.filter(function (f) {
	    return mm.match(f)
	  })
	  if (mm.options.nonull && !list.length) {
	    list.push(pattern)
	  }
	  return list
	}
	
	Minimatch.prototype.match = match
	function match (f, partial) {
	  this.debug('match', f, this.pattern)
	  // short-circuit in the case of busted things.
	  // comments, etc.
	  if (this.comment) return false
	  if (this.empty) return f === ''
	
	  if (f === '/' && partial) return true
	
	  var options = this.options
	
	  // windows: need to use /, not \
	  if (path.sep !== '/') {
	    f = f.split(path.sep).join('/')
	  }
	
	  // treat the test path as a set of pathparts.
	  f = f.split(slashSplit)
	  this.debug(this.pattern, 'split', f)
	
	  // just ONE of the pattern sets in this.set needs to match
	  // in order for it to be valid.  If negating, then just one
	  // match means that we have failed.
	  // Either way, return on the first hit.
	
	  var set = this.set
	  this.debug(this.pattern, 'set', set)
	
	  // Find the basename of the path by looking for the last non-empty segment
	  var filename
	  var i
	  for (i = f.length - 1; i >= 0; i--) {
	    filename = f[i]
	    if (filename) break
	  }
	
	  for (i = 0; i < set.length; i++) {
	    var pattern = set[i]
	    var file = f
	    if (options.matchBase && pattern.length === 1) {
	      file = [filename]
	    }
	    var hit = this.matchOne(file, pattern, partial)
	    if (hit) {
	      if (options.flipNegate) return true
	      return !this.negate
	    }
	  }
	
	  // didn't get any hits.  this is success if it's a negative
	  // pattern, failure otherwise.
	  if (options.flipNegate) return false
	  return this.negate
	}
	
	// set partial to true to test if, for example,
	// "/a/b" matches the start of "/*/b/*/d"
	// Partial means, if you run out of file before you run
	// out of pattern, then that's fine, as long as all
	// the parts match.
	Minimatch.prototype.matchOne = function (file, pattern, partial) {
	  var options = this.options
	
	  this.debug('matchOne',
	    { 'this': this, file: file, pattern: pattern })
	
	  this.debug('matchOne', file.length, pattern.length)
	
	  for (var fi = 0,
	      pi = 0,
	      fl = file.length,
	      pl = pattern.length
	      ; (fi < fl) && (pi < pl)
	      ; fi++, pi++) {
	    this.debug('matchOne loop')
	    var p = pattern[pi]
	    var f = file[fi]
	
	    this.debug(pattern, p, f)
	
	    // should be impossible.
	    // some invalid regexp stuff in the set.
	    if (p === false) return false
	
	    if (p === GLOBSTAR) {
	      this.debug('GLOBSTAR', [pattern, p, f])
	
	      // "**"
	      // a/**/b/**/c would match the following:
	      // a/b/x/y/z/c
	      // a/x/y/z/b/c
	      // a/b/x/b/x/c
	      // a/b/c
	      // To do this, take the rest of the pattern after
	      // the **, and see if it would match the file remainder.
	      // If so, return success.
	      // If not, the ** "swallows" a segment, and try again.
	      // This is recursively awful.
	      //
	      // a/**/b/**/c matching a/b/x/y/z/c
	      // - a matches a
	      // - doublestar
	      //   - matchOne(b/x/y/z/c, b/**/c)
	      //     - b matches b
	      //     - doublestar
	      //       - matchOne(x/y/z/c, c) -> no
	      //       - matchOne(y/z/c, c) -> no
	      //       - matchOne(z/c, c) -> no
	      //       - matchOne(c, c) yes, hit
	      var fr = fi
	      var pr = pi + 1
	      if (pr === pl) {
	        this.debug('** at the end')
	        // a ** at the end will just swallow the rest.
	        // We have found a match.
	        // however, it will not swallow /.x, unless
	        // options.dot is set.
	        // . and .. are *never* matched by **, for explosively
	        // exponential reasons.
	        for (; fi < fl; fi++) {
	          if (file[fi] === '.' || file[fi] === '..' ||
	            (!options.dot && file[fi].charAt(0) === '.')) return false
	        }
	        return true
	      }
	
	      // ok, let's see if we can swallow whatever we can.
	      while (fr < fl) {
	        var swallowee = file[fr]
	
	        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)
	
	        // XXX remove this slice.  Just pass the start index.
	        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
	          this.debug('globstar found match!', fr, fl, swallowee)
	          // found a match.
	          return true
	        } else {
	          // can't swallow "." or ".." ever.
	          // can only swallow ".foo" when explicitly asked.
	          if (swallowee === '.' || swallowee === '..' ||
	            (!options.dot && swallowee.charAt(0) === '.')) {
	            this.debug('dot detected!', file, fr, pattern, pr)
	            break
	          }
	
	          // ** swallows a segment, and continue.
	          this.debug('globstar swallow a segment, and continue')
	          fr++
	        }
	      }
	
	      // no match was found.
	      // However, in partial mode, we can't say this is necessarily over.
	      // If there's more *pattern* left, then
	      if (partial) {
	        // ran out of file
	        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
	        if (fr === fl) return true
	      }
	      return false
	    }
	
	    // something other than **
	    // non-magic patterns just have to match exactly
	    // patterns with magic have been turned into regexps.
	    var hit
	    if (typeof p === 'string') {
	      if (options.nocase) {
	        hit = f.toLowerCase() === p.toLowerCase()
	      } else {
	        hit = f === p
	      }
	      this.debug('string match', p, f, hit)
	    } else {
	      hit = f.match(p)
	      this.debug('pattern match', p, f, hit)
	    }
	
	    if (!hit) return false
	  }
	
	  // Note: ending in / means that we'll get a final ""
	  // at the end of the pattern.  This can only match a
	  // corresponding "" at the end of the file.
	  // If the file ends in /, then it can only match a
	  // a pattern that ends in /, unless the pattern just
	  // doesn't have any more for it. But, a/b/ should *not*
	  // match "a/b/*", even though "" matches against the
	  // [^/]*? pattern, except in partial mode, where it might
	  // simply not be reached yet.
	  // However, a/b/ should still satisfy a/*
	
	  // now either we fell off the end of the pattern, or we're done.
	  if (fi === fl && pi === pl) {
	    // ran out of pattern and filename at the same time.
	    // an exact hit!
	    return true
	  } else if (fi === fl) {
	    // ran out of file, but still had pattern left.
	    // this is ok if we're doing the match as part of
	    // a glob fs traversal.
	    return partial
	  } else if (pi === pl) {
	    // ran out of pattern, still have file left.
	    // this is only acceptable if we're on the very last
	    // empty segment of a file with a trailing slash.
	    // a/* should match a/b/
	    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
	    return emptyFileEnd
	  }
	
	  // should be unreachable.
	  throw new Error('wtf?')
	}
	
	// replace stuff like \* with *
	function globUnescape (s) {
	  return s.replace(/\\(.)/g, '$1')
	}
	
	function regExpEscape (s) {
	  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
	}


/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	var concatMap = __webpack_require__(291);
	var balanced = __webpack_require__(292);
	
	module.exports = expandTop;
	
	var escSlash = '\0SLASH'+Math.random()+'\0';
	var escOpen = '\0OPEN'+Math.random()+'\0';
	var escClose = '\0CLOSE'+Math.random()+'\0';
	var escComma = '\0COMMA'+Math.random()+'\0';
	var escPeriod = '\0PERIOD'+Math.random()+'\0';
	
	function numeric(str) {
	  return parseInt(str, 10) == str
	    ? parseInt(str, 10)
	    : str.charCodeAt(0);
	}
	
	function escapeBraces(str) {
	  return str.split('\\\\').join(escSlash)
	            .split('\\{').join(escOpen)
	            .split('\\}').join(escClose)
	            .split('\\,').join(escComma)
	            .split('\\.').join(escPeriod);
	}
	
	function unescapeBraces(str) {
	  return str.split(escSlash).join('\\')
	            .split(escOpen).join('{')
	            .split(escClose).join('}')
	            .split(escComma).join(',')
	            .split(escPeriod).join('.');
	}
	
	
	// Basically just str.split(","), but handling cases
	// where we have nested braced sections, which should be
	// treated as individual members, like {a,{b,c},d}
	function parseCommaParts(str) {
	  if (!str)
	    return [''];
	
	  var parts = [];
	  var m = balanced('{', '}', str);
	
	  if (!m)
	    return str.split(',');
	
	  var pre = m.pre;
	  var body = m.body;
	  var post = m.post;
	  var p = pre.split(',');
	
	  p[p.length-1] += '{' + body + '}';
	  var postParts = parseCommaParts(post);
	  if (post.length) {
	    p[p.length-1] += postParts.shift();
	    p.push.apply(p, postParts);
	  }
	
	  parts.push.apply(parts, p);
	
	  return parts;
	}
	
	function expandTop(str) {
	  if (!str)
	    return [];
	
	  // I don't know why Bash 4.3 does this, but it does.
	  // Anything starting with {} will have the first two bytes preserved
	  // but *only* at the top level, so {},a}b will not expand to anything,
	  // but a{},b}c will be expanded to [a}c,abc].
	  // One could argue that this is a bug in Bash, but since the goal of
	  // this module is to match Bash's rules, we escape a leading {}
	  if (str.substr(0, 2) === '{}') {
	    str = '\\{\\}' + str.substr(2);
	  }
	
	  return expand(escapeBraces(str), true).map(unescapeBraces);
	}
	
	function identity(e) {
	  return e;
	}
	
	function embrace(str) {
	  return '{' + str + '}';
	}
	function isPadded(el) {
	  return /^-?0\d/.test(el);
	}
	
	function lte(i, y) {
	  return i <= y;
	}
	function gte(i, y) {
	  return i >= y;
	}
	
	function expand(str, isTop) {
	  var expansions = [];
	
	  var m = balanced('{', '}', str);
	  if (!m || /\$$/.test(m.pre)) return [str];
	
	  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
	  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
	  var isSequence = isNumericSequence || isAlphaSequence;
	  var isOptions = /^(.*,)+(.+)?$/.test(m.body);
	  if (!isSequence && !isOptions) {
	    // {a},b}
	    if (m.post.match(/,.*\}/)) {
	      str = m.pre + '{' + m.body + escClose + m.post;
	      return expand(str);
	    }
	    return [str];
	  }
	
	  var n;
	  if (isSequence) {
	    n = m.body.split(/\.\./);
	  } else {
	    n = parseCommaParts(m.body);
	    if (n.length === 1) {
	      // x{{a,b}}y ==> x{a}y x{b}y
	      n = expand(n[0], false).map(embrace);
	      if (n.length === 1) {
	        var post = m.post.length
	          ? expand(m.post, false)
	          : [''];
	        return post.map(function(p) {
	          return m.pre + n[0] + p;
	        });
	      }
	    }
	  }
	
	  // at this point, n is the parts, and we know it's not a comma set
	  // with a single entry.
	
	  // no need to expand pre, since it is guaranteed to be free of brace-sets
	  var pre = m.pre;
	  var post = m.post.length
	    ? expand(m.post, false)
	    : [''];
	
	  var N;
	
	  if (isSequence) {
	    var x = numeric(n[0]);
	    var y = numeric(n[1]);
	    var width = Math.max(n[0].length, n[1].length)
	    var incr = n.length == 3
	      ? Math.abs(numeric(n[2]))
	      : 1;
	    var test = lte;
	    var reverse = y < x;
	    if (reverse) {
	      incr *= -1;
	      test = gte;
	    }
	    var pad = n.some(isPadded);
	
	    N = [];
	
	    for (var i = x; test(i, y); i += incr) {
	      var c;
	      if (isAlphaSequence) {
	        c = String.fromCharCode(i);
	        if (c === '\\')
	          c = '';
	      } else {
	        c = String(i);
	        if (pad) {
	          var need = width - c.length;
	          if (need > 0) {
	            var z = new Array(need + 1).join('0');
	            if (i < 0)
	              c = '-' + z + c.slice(1);
	            else
	              c = z + c;
	          }
	        }
	      }
	      N.push(c);
	    }
	  } else {
	    N = concatMap(n, function(el) { return expand(el, false) });
	  }
	
	  for (var j = 0; j < N.length; j++) {
	    for (var k = 0; k < post.length; k++) {
	      var expansion = pre + N[j] + post[k];
	      if (!isTop || isSequence || expansion)
	        expansions.push(expansion);
	    }
	  }
	
	  return expansions;
	}
	


/***/ },
/* 291 */
/***/ function(module, exports) {

	module.exports = function (xs, fn) {
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        var x = fn(xs[i], i);
	        if (isArray(x)) res.push.apply(res, x);
	        else res.push(x);
	    }
	    return res;
	};
	
	var isArray = Array.isArray || function (xs) {
	    return Object.prototype.toString.call(xs) === '[object Array]';
	};


/***/ },
/* 292 */
/***/ function(module, exports) {

	module.exports = balanced;
	function balanced(a, b, str) {
	  if (a instanceof RegExp) a = maybeMatch(a, str);
	  if (b instanceof RegExp) b = maybeMatch(b, str);
	
	  var r = range(a, b, str);
	
	  return r && {
	    start: r[0],
	    end: r[1],
	    pre: str.slice(0, r[0]),
	    body: str.slice(r[0] + a.length, r[1]),
	    post: str.slice(r[1] + b.length)
	  };
	}
	
	function maybeMatch(reg, str) {
	  var m = str.match(reg);
	  return m ? m[0] : null;
	}
	
	balanced.range = range;
	function range(a, b, str) {
	  var begs, beg, left, right, result;
	  var ai = str.indexOf(a);
	  var bi = str.indexOf(b, ai + 1);
	  var i = ai;
	
	  if (ai >= 0 && bi > 0) {
	    begs = [];
	    left = str.length;
	
	    while (i >= 0 && !result) {
	      if (i == ai) {
	        begs.push(i);
	        ai = str.indexOf(a, i + 1);
	      } else if (begs.length == 1) {
	        result = [ begs.pop(), bi ];
	      } else {
	        beg = begs.pop();
	        if (beg < left) {
	          left = beg;
	          right = bi;
	        }
	
	        bi = str.indexOf(b, i + 1);
	      }
	
	      i = ai < bi && ai >= 0 ? ai : bi;
	    }
	
	    if (begs.length) {
	      result = [ left, right ];
	    }
	  }
	
	  return result;
	}


/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate) {'use strict';
	module.exports = typeof setImmediate === 'function' ? setImmediate :
		function setImmediate() {
			var args = [].slice.apply(arguments);
			args.splice(1, 0, 0);
			setTimeout.apply(null, args);
		};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11).setImmediate))

/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var si =  __webpack_require__(293);
	var stream = __webpack_require__(270);
	var util = __webpack_require__(287);
	
	var Readable = stream.Readable;
	
	module.exports = ReaddirpReadable;
	
	util.inherits(ReaddirpReadable, Readable);
	
	function ReaddirpReadable (opts) {
	  if (!(this instanceof ReaddirpReadable)) return new ReaddirpReadable(opts);
	
	  opts = opts || {};
	
	  opts.objectMode = true;
	  Readable.call(this, opts);
	
	  // backpressure not implemented at this point
	  this.highWaterMark = Infinity;
	
	  this._destroyed = false;
	  this._paused = false;
	  this._warnings = [];
	  this._errors = [];
	
	  this._pauseResumeErrors();
	}
	
	var proto = ReaddirpReadable.prototype;
	
	proto._pauseResumeErrors = function () {
	  var self = this;
	  self.on('pause', function () { self._paused = true });
	  self.on('resume', function () {
	    if (self._destroyed) return;
	    self._paused = false;
	
	    self._warnings.forEach(function (err) { self.emit('warn', err) });
	    self._warnings.length = 0;
	
	    self._errors.forEach(function (err) { self.emit('error', err) });
	    self._errors.length = 0;
	  })
	}
	
	// called for each entry
	proto._processEntry = function (entry) {
	  if (this._destroyed) return;
	  this.push(entry);
	}
	
	proto._read = function () { }
	
	proto.destroy = function () {
	  // when stream is destroyed it will emit nothing further, not even errors or warnings
	  this.push(null);
	  this.readable = false;
	  this._destroyed = true;
	  this.emit('close');
	}
	
	proto._done = function () {
	  this.push(null);
	}
	
	// we emit errors and warnings async since we may handle errors like invalid args
	// within the initial event loop before any event listeners subscribed
	proto._handleError = function (err) {
	  var self = this;
	  si(function () {
	    if (self._paused) return self._warnings.push(err);
	    if (!self._destroyed) self.emit('warn', err);
	  });
	}
	
	proto._handleFatalError = function (err) {
	  var self = this;
	  si(function () {
	    if (self._paused) return self._errors.push(err);
	    if (!self._destroyed) self.emit('error', err);
	  });
	}
	
	function createStreamAPI () {
	  var stream = new ReaddirpReadable();
	
	  return {
	      stream           :  stream
	    , processEntry     :  stream._processEntry.bind(stream)
	    , done             :  stream._done.bind(stream)
	    , handleError      :  stream._handleError.bind(stream)
	    , handleFatalError :  stream._handleFatalError.bind(stream)
	  };
	}
	
	module.exports = createStreamAPI;


/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var path = __webpack_require__(4);
	var binaryExtensions = __webpack_require__(296);
	var exts = Object.create(null);
	
	binaryExtensions.forEach(function (el) {
		exts[el] = true;
	});
	
	module.exports = function (filepath) {
		return path.extname(filepath).slice(1).toLowerCase() in exts;
	};


/***/ },
/* 296 */
/***/ function(module, exports) {

	[
		"3ds",
		"3g2",
		"3gp",
		"7z",
		"a",
		"aac",
		"adp",
		"ai",
		"aif",
		"aiff",
		"alz",
		"ape",
		"apk",
		"ar",
		"arj",
		"asf",
		"au",
		"avi",
		"bak",
		"bh",
		"bin",
		"bk",
		"bmp",
		"btif",
		"bz2",
		"bzip2",
		"cab",
		"caf",
		"cgm",
		"class",
		"cmx",
		"cpio",
		"cr2",
		"csv",
		"cur",
		"dat",
		"deb",
		"dex",
		"djvu",
		"dll",
		"dmg",
		"dng",
		"doc",
		"docm",
		"docx",
		"dot",
		"dotm",
		"dra",
		"DS_Store",
		"dsk",
		"dts",
		"dtshd",
		"dvb",
		"dwg",
		"dxf",
		"ecelp4800",
		"ecelp7470",
		"ecelp9600",
		"egg",
		"eol",
		"eot",
		"epub",
		"exe",
		"f4v",
		"fbs",
		"fh",
		"fla",
		"flac",
		"fli",
		"flv",
		"fpx",
		"fst",
		"fvt",
		"g3",
		"gif",
		"graffle",
		"gz",
		"gzip",
		"h261",
		"h263",
		"h264",
		"ico",
		"ief",
		"img",
		"ipa",
		"iso",
		"jar",
		"jpeg",
		"jpg",
		"jpgv",
		"jpm",
		"jxr",
		"key",
		"ktx",
		"lha",
		"lvp",
		"lz",
		"lzh",
		"lzma",
		"lzo",
		"m3u",
		"m4a",
		"m4v",
		"mar",
		"mdi",
		"mht",
		"mid",
		"midi",
		"mj2",
		"mka",
		"mkv",
		"mmr",
		"mng",
		"mobi",
		"mov",
		"movie",
		"mp3",
		"mp4",
		"mp4a",
		"mpeg",
		"mpg",
		"mpga",
		"mxu",
		"nef",
		"npx",
		"numbers",
		"o",
		"oga",
		"ogg",
		"ogv",
		"otf",
		"pages",
		"pbm",
		"pcx",
		"pdf",
		"pea",
		"pgm",
		"pic",
		"png",
		"pnm",
		"pot",
		"potm",
		"potx",
		"ppa",
		"ppam",
		"ppm",
		"pps",
		"ppsm",
		"ppsx",
		"ppt",
		"pptm",
		"pptx",
		"psd",
		"pya",
		"pyc",
		"pyo",
		"pyv",
		"qt",
		"rar",
		"ras",
		"raw",
		"rgb",
		"rip",
		"rlc",
		"rmf",
		"rmvb",
		"rtf",
		"rz",
		"s3m",
		"s7z",
		"scpt",
		"sgi",
		"shar",
		"sil",
		"sketch",
		"slk",
		"smv",
		"so",
		"sub",
		"swf",
		"tar",
		"tbz",
		"tbz2",
		"tga",
		"tgz",
		"thmx",
		"tif",
		"tiff",
		"tlz",
		"ttc",
		"ttf",
		"txz",
		"udf",
		"uvh",
		"uvi",
		"uvm",
		"uvp",
		"uvs",
		"uvu",
		"viv",
		"vob",
		"war",
		"wav",
		"wax",
		"wbmp",
		"wdp",
		"weba",
		"webm",
		"webp",
		"whl",
		"wim",
		"wm",
		"wma",
		"wmv",
		"wmx",
		"woff",
		"woff2",
		"wvx",
		"xbm",
		"xif",
		"xla",
		"xlam",
		"xls",
		"xlsb",
		"xlsm",
		"xlsx",
		"xlt",
		"xltm",
		"xltx",
		"xm",
		"xmind",
		"xpi",
		"xpm",
		"xwd",
		"xz",
		"z",
		"zip",
		"zipx"
	]


/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var sysPath = __webpack_require__(4);
	var readdirp = __webpack_require__(263);
	var fsevents;
	try { fsevents = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fsevents\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())); } catch (error) {}
	
	// fsevents instance helper functions
	
	// object to hold per-process fsevents instances
	// (may be shared across chokidar FSWatcher instances)
	var FSEventsWatchers = Object.create(null);
	
	// Threshold of duplicate path prefixes at which to start
	// consolidating going forward
	var consolidateThreshhold = 10;
	
	// Private function: Instantiates the fsevents interface
	
	// * path       - string, path to be watched
	// * callback   - function, called when fsevents is bound and ready
	
	// Returns new fsevents instance
	function createFSEventsInstance(path, callback) {
	  return (new fsevents(path)).on('fsevent', callback).start();
	}
	
	// Private function: Instantiates the fsevents interface or binds listeners
	// to an existing one covering the same file tree
	
	// * path       - string, path to be watched
	// * realPath   - string, real path (in case of symlinks)
	// * listener   - function, called when fsevents emits events
	// * rawEmitter - function, passes data to listeners of the 'raw' event
	
	// Returns close function
	function setFSEventsListener(path, realPath, listener, rawEmitter) {
	  var watchPath = sysPath.extname(path) ? sysPath.dirname(path) : path;
	  var watchContainer;
	  var parentPath = sysPath.dirname(watchPath);
	
	  // If we've accumulated a substantial number of paths that
	  // could have been consolidated by watching one directory
	  // above the current one, create a watcher on the parent
	  // path instead, so that we do consolidate going forward.
	  if (couldConsolidate(parentPath)) {
	    watchPath = parentPath;
	  }
	
	  var resolvedPath = sysPath.resolve(path);
	  var hasSymlink = resolvedPath !== realPath;
	  function filteredListener(fullPath, flags, info) {
	    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);
	    if (
	      fullPath === resolvedPath ||
	      !fullPath.indexOf(resolvedPath + sysPath.sep)
	    ) listener(fullPath, flags, info);
	  }
	
	  // check if there is already a watcher on a parent path
	  // modifies `watchPath` to the parent path when it finds a match
	  function watchedParent() {
	    return Object.keys(FSEventsWatchers).some(function(watchedPath) {
	      // condition is met when indexOf returns 0
	      if (!realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep)) {
	        watchPath = watchedPath;
	        return true;
	      }
	    });
	  }
	
	  if (watchPath in FSEventsWatchers || watchedParent()) {
	    watchContainer = FSEventsWatchers[watchPath];
	    watchContainer.listeners.push(filteredListener);
	  } else {
	    watchContainer = FSEventsWatchers[watchPath] = {
	      listeners: [filteredListener],
	      rawEmitters: [rawEmitter],
	      watcher: createFSEventsInstance(watchPath, function(fullPath, flags) {
	        var info = fsevents.getInfo(fullPath, flags);
	        watchContainer.listeners.forEach(function(listener) {
	          listener(fullPath, flags, info);
	        });
	        watchContainer.rawEmitters.forEach(function(emitter) {
	          emitter(info.event, fullPath, info);
	        });
	      })
	    };
	  }
	  var listenerIndex = watchContainer.listeners.length - 1;
	
	  // removes this instance's listeners and closes the underlying fsevents
	  // instance if there are no more listeners left
	  return function close() {
	    delete watchContainer.listeners[listenerIndex];
	    delete watchContainer.rawEmitters[listenerIndex];
	    if (!Object.keys(watchContainer.listeners).length) {
	      watchContainer.watcher.stop();
	      delete FSEventsWatchers[watchPath];
	    }
	  };
	}
	
	// Decide whether or not we should start a new higher-level
	// parent watcher
	function couldConsolidate(path) {
	  var keys = Object.keys(FSEventsWatchers);
	  var count = 0;
	
	  for (var i = 0, len = keys.length; i < len; ++i) {
	    var watchPath = keys[i];
	    if (watchPath.indexOf(path) === 0) {
	      count++;
	      if (count >= consolidateThreshhold) {
	        return true;
	      }
	    }
	  }
	
	  return false;
	}
	
	// returns boolean indicating whether fsevents can be used
	function canUse() {
	  return fsevents && Object.keys(FSEventsWatchers).length < 128;
	}
	
	// determines subdirectory traversal levels from root to path
	function depth(path, root) {
	  var i = 0;
	  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;
	  return i;
	}
	
	// fake constructor for attaching fsevents-specific prototype methods that
	// will be copied to FSWatcher's prototype
	function FsEventsHandler() {}
	
	// Private method: Handle symlinks encountered during directory scan
	
	// * watchPath  - string, file/dir path to be watched with fsevents
	// * realPath   - string, real path (in case of symlinks)
	// * transform  - function, path transformer
	// * globFilter - function, path filter in case a glob pattern was provided
	
	// Returns close function for the watcher instance
	FsEventsHandler.prototype._watchWithFsEvents =
	function(watchPath, realPath, transform, globFilter) {
	  if (this._isIgnored(watchPath)) return;
	  var watchCallback = function(fullPath, flags, info) {
	    if (
	      this.options.depth !== undefined &&
	      depth(fullPath, realPath) > this.options.depth
	    ) return;
	    var path = transform(sysPath.join(
	      watchPath, sysPath.relative(watchPath, fullPath)
	    ));
	    if (globFilter && !globFilter(path)) return;
	    // ensure directories are tracked
	    var parent = sysPath.dirname(path);
	    var item = sysPath.basename(path);
	    var watchedDir = this._getWatchedDir(
	      info.type === 'directory' ? path : parent
	    );
	    var checkIgnored = function(stats) {
	      if (this._isIgnored(path, stats)) {
	        this._ignoredPaths[path] = true;
	        if (stats && stats.isDirectory()) {
	          this._ignoredPaths[path + '/**/*'] = true;
	        }
	        return true;
	      } else {
	        delete this._ignoredPaths[path];
	        delete this._ignoredPaths[path + '/**/*'];
	      }
	    }.bind(this);
	
	    var handleEvent = function(event) {
	      if (checkIgnored()) return;
	
	      if (event === 'unlink') {
	        // suppress unlink events on never before seen files
	        if (info.type === 'directory' || watchedDir.has(item)) {
	          this._remove(parent, item);
	        }
	      } else {
	        if (event === 'add') {
	          // track new directories
	          if (info.type === 'directory') this._getWatchedDir(path);
	
	          if (info.type === 'symlink' && this.options.followSymlinks) {
	            // push symlinks back to the top of the stack to get handled
	            var curDepth = this.options.depth === undefined ?
	              undefined : depth(fullPath, realPath) + 1;
	            return this._addToFsEvents(path, false, true, curDepth);
	          } else {
	            // track new paths
	            // (other than symlinks being followed, which will be tracked soon)
	            this._getWatchedDir(parent).add(item);
	          }
	        }
	        var eventName = info.type === 'directory' ? event + 'Dir' : event;
	        this._emit(eventName, path);
	        if (eventName === 'addDir') this._addToFsEvents(path, false, true);
	      }
	    }.bind(this);
	
	    function addOrChange() {
	      handleEvent(watchedDir.has(item) ? 'change' : 'add');
	    }
	    function checkFd() {
	      fs.open(path, 'r', function(error, fd) {
	        if (fd) fs.close(fd);
	        error && error.code !== 'EACCES' ?
	          handleEvent('unlink') : addOrChange();
	      });
	    }
	    // correct for wrong events emitted
	    var wrongEventFlags = [
	      69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912
	    ];
	    if (wrongEventFlags.indexOf(flags) !== -1 || info.event === 'unknown') {
	      if (typeof this.options.ignored === 'function') {
	        fs.stat(path, function(error, stats) {
	          if (checkIgnored(stats)) return;
	          stats ? addOrChange() : handleEvent('unlink');
	        });
	      } else {
	        checkFd();
	      }
	    } else {
	      switch (info.event) {
	      case 'created':
	      case 'modified':
	        return addOrChange();
	      case 'deleted':
	      case 'moved':
	        return checkFd();
	      }
	    }
	  }.bind(this);
	
	  var closer = setFSEventsListener(
	    watchPath,
	    realPath,
	    watchCallback,
	    this.emit.bind(this, 'raw')
	  );
	
	  this._emitReady();
	  return closer;
	};
	
	// Private method: Handle symlinks encountered during directory scan
	
	// * linkPath   - string, path to symlink
	// * fullPath   - string, absolute path to the symlink
	// * transform  - function, pre-existing path transformer
	// * curDepth   - int, level of subdirectories traversed to where symlink is
	
	// Returns nothing
	FsEventsHandler.prototype._handleFsEventsSymlink =
	function(linkPath, fullPath, transform, curDepth) {
	  // don't follow the same symlink more than once
	  if (this._symlinkPaths[fullPath]) return;
	  else this._symlinkPaths[fullPath] = true;
	
	  this._readyCount++;
	
	  fs.realpath(linkPath, function(error, linkTarget) {
	    if (this._handleError(error) || this._isIgnored(linkTarget)) {
	      return this._emitReady();
	    }
	
	    this._readyCount++;
	
	    // add the linkTarget for watching with a wrapper for transform
	    // that causes emitted paths to incorporate the link's path
	    this._addToFsEvents(linkTarget || linkPath, function(path) {
	      var dotSlash = '.' + sysPath.sep;
	      var aliasedPath = linkPath;
	      if (linkTarget && linkTarget !== dotSlash) {
	        aliasedPath = path.replace(linkTarget, linkPath);
	      } else if (path !== dotSlash) {
	        aliasedPath = sysPath.join(linkPath, path);
	      }
	      return transform(aliasedPath);
	    }, false, curDepth);
	  }.bind(this));
	};
	
	// Private method: Handle added path with fsevents
	
	// * path       - string, file/directory path or glob pattern
	// * transform  - function, converts working path to what the user expects
	// * forceAdd   - boolean, ensure add is emitted
	// * priorDepth - int, level of subdirectories already traversed
	
	// Returns nothing
	FsEventsHandler.prototype._addToFsEvents =
	function(path, transform, forceAdd, priorDepth) {
	
	  // applies transform if provided, otherwise returns same value
	  var processPath = typeof transform === 'function' ?
	    transform : function(val) { return val; };
	
	  var emitAdd = function(newPath, stats) {
	    var pp = processPath(newPath);
	    var isDir = stats.isDirectory();
	    var dirObj = this._getWatchedDir(sysPath.dirname(pp));
	    var base = sysPath.basename(pp);
	
	    // ensure empty dirs get tracked
	    if (isDir) this._getWatchedDir(pp);
	
	    if (dirObj.has(base)) return;
	    dirObj.add(base);
	
	    if (!this.options.ignoreInitial || forceAdd === true) {
	      this._emit(isDir ? 'addDir' : 'add', pp, stats);
	    }
	  }.bind(this);
	
	  var wh = this._getWatchHelpers(path);
	
	  // evaluate what is at the path we're being asked to watch
	  fs[wh.statMethod](wh.watchPath, function(error, stats) {
	    if (this._handleError(error) || this._isIgnored(wh.watchPath, stats)) {
	      this._emitReady();
	      return this._emitReady();
	    }
	
	    if (stats.isDirectory()) {
	      // emit addDir unless this is a glob parent
	      if (!wh.globFilter) emitAdd(processPath(path), stats);
	
	      // don't recurse further if it would exceed depth setting
	      if (priorDepth && priorDepth > this.options.depth) return;
	
	      // scan the contents of the dir
	      readdirp({
	        root: wh.watchPath,
	        entryType: 'all',
	        fileFilter: wh.filterPath,
	        directoryFilter: wh.filterDir,
	        lstat: true,
	        depth: this.options.depth - (priorDepth || 0)
	      }).on('data', function(entry) {
	        // need to check filterPath on dirs b/c filterDir is less restrictive
	        if (entry.stat.isDirectory() && !wh.filterPath(entry)) return;
	
	        var joinedPath = sysPath.join(wh.watchPath, entry.path);
	        var fullPath = entry.fullPath;
	
	        if (wh.followSymlinks && entry.stat.isSymbolicLink()) {
	          // preserve the current depth here since it can't be derived from
	          // real paths past the symlink
	          var curDepth = this.options.depth === undefined ?
	            undefined : depth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;
	
	          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
	        } else {
	          emitAdd(joinedPath, entry.stat);
	        }
	      }.bind(this)).on('error', function() {
	        // Ignore readdirp errors
	      }).on('end', this._emitReady);
	    } else {
	      emitAdd(wh.watchPath, stats);
	      this._emitReady();
	    }
	  }.bind(this));
	
	  if (this.options.persistent && forceAdd !== true) {
	    var initWatch = function(error, realPath) {
	      var closer = this._watchWithFsEvents(
	        wh.watchPath,
	        sysPath.resolve(realPath || wh.watchPath),
	        processPath,
	        wh.globFilter
	      );
	      if (closer) this._closers[path] = closer;
	    }.bind(this);
	
	    if (typeof transform === 'function') {
	      // realpath has already been resolved
	      initWatch();
	    } else {
	      fs.realpath(wh.watchPath, initWatch);
	    }
	  }
	};
	
	module.exports = FsEventsHandler;
	module.exports.canUse = canUse;


/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var path = __webpack_require__(4);
	var mkdirp = __webpack_require__(299);
	
	function NodeOutputFileSystem() {}
	module.exports = NodeOutputFileSystem;
	
	NodeOutputFileSystem.prototype.mkdirp = mkdirp;
	NodeOutputFileSystem.prototype.mkdir = fs.mkdir.bind(this);
	NodeOutputFileSystem.prototype.rmdir = fs.rmdir.bind(this);
	NodeOutputFileSystem.prototype.unlink = fs.unlink.bind(this);
	NodeOutputFileSystem.prototype.writeFile = fs.writeFile.bind(fs);
	NodeOutputFileSystem.prototype.join = path.join.bind(path);


/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var path = __webpack_require__(4);
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var _0777 = parseInt('0777', 8);
	
	module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
	
	function mkdirP (p, opts, f, made) {
	    if (typeof opts === 'function') {
	        f = opts;
	        opts = {};
	    }
	    else if (!opts || typeof opts !== 'object') {
	        opts = { mode: opts };
	    }
	    
	    var mode = opts.mode;
	    var xfs = opts.fs || fs;
	    
	    if (mode === undefined) {
	        mode = _0777 & (~process.umask());
	    }
	    if (!made) made = null;
	    
	    var cb = f || function () {};
	    p = path.resolve(p);
	    
	    xfs.mkdir(p, mode, function (er) {
	        if (!er) {
	            made = made || p;
	            return cb(null, made);
	        }
	        switch (er.code) {
	            case 'ENOENT':
	                mkdirP(path.dirname(p), opts, function (er, made) {
	                    if (er) cb(er, made);
	                    else mkdirP(p, opts, cb, made);
	                });
	                break;
	
	            // In the case of any other error, just see if there's a dir
	            // there already.  If so, then hooray!  If not, then something
	            // is borked.
	            default:
	                xfs.stat(p, function (er2, stat) {
	                    // if the stat fails, then that's super weird.
	                    // let the original error be the failure reason.
	                    if (er2 || !stat.isDirectory()) cb(er, made)
	                    else cb(null, made);
	                });
	                break;
	        }
	    });
	}
	
	mkdirP.sync = function sync (p, opts, made) {
	    if (!opts || typeof opts !== 'object') {
	        opts = { mode: opts };
	    }
	    
	    var mode = opts.mode;
	    var xfs = opts.fs || fs;
	    
	    if (mode === undefined) {
	        mode = _0777 & (~process.umask());
	    }
	    if (!made) made = null;
	
	    p = path.resolve(p);
	
	    try {
	        xfs.mkdirSync(p, mode);
	        made = made || p;
	    }
	    catch (err0) {
	        switch (err0.code) {
	            case 'ENOENT' :
	                made = sync(path.dirname(p), opts, made);
	                sync(p, opts, made);
	                break;
	
	            // In the case of any other error, just see if there's a dir
	            // there already.  If so, then hooray!  If not, then something
	            // is borked.
	            default:
	                var stat;
	                try {
	                    stat = xfs.statSync(p);
	                }
	                catch (err1) {
	                    throw err0;
	                }
	                if (!stat.isDirectory()) throw err0;
	                break;
	        }
	    }
	
	    return made;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var fs = __webpack_require__(264);
	
	function NodeJsInputFileSystem() {}
	module.exports = NodeJsInputFileSystem;
	
	NodeJsInputFileSystem.prototype.isSync = function() {
		return false;
	};
	
	NodeJsInputFileSystem.prototype.stat = fs.stat.bind(fs);
	NodeJsInputFileSystem.prototype.readdir = function readdir(path, callback) {
		fs.readdir(path, function (err, files) {
			callback(err, files && files.map(function (file) {
				return file.normalize ? file.normalize("NFC") : file;
			}));
		});
	};
	NodeJsInputFileSystem.prototype.readFile = fs.readFile.bind(fs);
	NodeJsInputFileSystem.prototype.readlink = fs.readlink.bind(fs);

/***/ },
/* 301 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function Storage(duration) {
		this.duration = duration;
		this.running = {};
		this.data = {};
		this.levels = [];
		if(duration > 0) {
			this.levels.push([], [], [], [], [], [], [], [], []);
			for(var i = 8000; i < duration; i+=500)
				this.levels.push([]);
		}
		this.count = 0;
		this.interval = null;
		this.needTickCheck = false;
		this.nextTick = null;
		this.passive = true;
	}
	
	Storage.prototype.ensureTick = function() {
		if(!this.interval && this.duration > 0 && !this.nextTick)
			this.interval = setInterval(this.tick.bind(this), Math.floor(this.duration / this.levels.length));
	};
	
	Storage.prototype.finished = function(name) {
		var args = Array.prototype.slice.call(arguments, 1);
		var callbacks = this.running[name];
		delete this.running[name];
		if(this.duration > 0) {
			this.count++;
			this.data[name] = args;
			this.levels[0].push(name);
			this.ensureTick();
		}
		for(var i = 0; i < callbacks.length; i++) {
			callbacks[i].apply(null, args);
		}
	};
	
	Storage.prototype.provide = function(name, provider, callback) {
		var running = this.running[name];
		if(running) {
			running.push(callback);
			return;
		}
		if(this.duration > 0) {
			this.checkTicks();
			var data = this.data[name];
			if(data) {
				return callback.apply(null, data);
			}
		}
		this.running[name] = running = [callback];
		provider(name, this.finished.bind(this, name));
	};
	
	Storage.prototype.tick = function() {
		var decay = this.levels.pop();
		for(var i = decay.length - 1; i >= 0; i--) {
			delete this.data[decay[i]];
		}
		this.count -= decay.length;
		decay.length = 0;
		this.levels.unshift(decay);
		if(this.count == 0) {
			clearInterval(this.interval);
			this.interval = null;
			this.nextTick = null;
			return true;
		} else if(this.nextTick) {
			this.nextTick += Math.floor(this.duration / this.levels.length);
			var time = new Date().getTime();
			if(this.nextTick > time) {
				this.nextTick = null;
				this.interval = setInterval(this.tick.bind(this), Math.floor(this.duration / this.levels.length));
				return true;
			}
		} else if(this.passive) {
			clearInterval(this.interval);
			this.interval = null;
			this.nextTick = new Date().getTime() + Math.floor(this.duration / this.levels.length);
		} else {
			this.passive = true;
		}
	};
	
	Storage.prototype.checkTicks = function() {
		this.passive = false;
		if(this.nextTick) {
			while(!this.tick());
		}
	};
	
	Storage.prototype.purge = function(what) {
		if(!what) {
			this.count = 0;
			clearInterval(this.interval);
			this.nextTick = null;
			this.data = {};
			this.levels.forEach(function(level) {
				level.length = 0;
			});
		} else if(typeof what === "string") {
			Object.keys(this.data).forEach(function(key) {
				if(key.indexOf(what) === 0)
					delete this.data[key];
			}, this);
		} else {
			for(var i = what.length - 1; i >= 0; i--) {
				this.purge(what[i]);
			}
		}
	};
	
	
	function CachedInputFileSystem(fileSystem, duration) {
		this.fileSystem = fileSystem;
		this._statStorage = new Storage(duration);
		this._readdirStorage = new Storage(duration);
		this._readFileStorage = new Storage(duration);
		this._readlinkStorage = new Storage(duration);
	}
	module.exports = CachedInputFileSystem;
	
	CachedInputFileSystem.prototype.isSync = function() {
		return this.fileSystem.isSync();
	};
	
	CachedInputFileSystem.prototype.stat = function(path, callback) {
		this._statStorage.provide(path, this.fileSystem.stat.bind(this.fileSystem), callback);
	};
	
	CachedInputFileSystem.prototype.readdir = function(path, callback) {
		this._readdirStorage.provide(path, this.fileSystem.readdir.bind(this.fileSystem), callback);
	};
	
	CachedInputFileSystem.prototype.readFile = function(path, callback) {
		this._readFileStorage.provide(path, this.fileSystem.readFile.bind(this.fileSystem), callback);
	};
	
	CachedInputFileSystem.prototype.readlink = function(path, callback) {
		this._readlinkStorage.provide(path, this.fileSystem.readlink.bind(this.fileSystem), callback);
	};
	
	CachedInputFileSystem.prototype.purge = function(what) {
		this._statStorage.purge(what);
		this._readdirStorage.purge(what);
		this._readFileStorage.purge(what);
		this._readlinkStorage.purge(what);
	};

/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConcatSource = __webpack_require__(49);
	
	function NodeHotUpdateChunkTemplatePlugin() {}
	module.exports = NodeHotUpdateChunkTemplatePlugin;
	
	NodeHotUpdateChunkTemplatePlugin.prototype.apply = function(hotUpdateChunkTemplate) {
		hotUpdateChunkTemplate.plugin("render", function(modulesSource, modules, hash, id) {
			var source = new ConcatSource();
			source.add("exports.id = " + JSON.stringify(id) + ";\nexports.modules = ");
			source.add(modulesSource);
			source.add(";");
			return source;
		});
		hotUpdateChunkTemplate.plugin("hash", function(hash) {
			hash.update("NodeHotUpdateChunkTemplatePlugin");
			hash.update("3");
			hash.update(this.outputOptions.hotUpdateFunction + "");
			hash.update(this.outputOptions.library + "");
		});
	};


/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ExternalsPlugin = __webpack_require__(304);
	
	function NodeTargetPlugin() {}
	
	module.exports = NodeTargetPlugin;
	NodeTargetPlugin.prototype.apply = function(compiler) {
		new ExternalsPlugin("commonjs", Object.keys(process.binding("natives"))).apply(compiler);
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ExternalModuleFactoryPlugin = __webpack_require__(305);
	
	function ExternalsPlugin(type, externals) {
		this.type = type;
		this.externals = externals;
	}
	module.exports = ExternalsPlugin;
	ExternalsPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compile", function(params) {
			params.normalModuleFactory.apply(new ExternalModuleFactoryPlugin(this.type, this.externals));
		}.bind(this));
	};


/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ExternalModule = __webpack_require__(306);
	
	function ExternalModuleFactoryPlugin(type, externals) {
		this.type = type;
		this.externals = externals;
	}
	module.exports = ExternalModuleFactoryPlugin;
	
	ExternalModuleFactoryPlugin.prototype.apply = function(normalModuleFactory) {
		var globalType = this.type;
		normalModuleFactory.plugin("factory", function(factory) {
			return function(data, callback) {
				var context = data.context;
				var dependency = data.dependency;
	
				function handleExternal(value, type, callback) {
					if(typeof type === "function") {
						callback = type;
						type = undefined;
					}
					if(value === false) return factory(data, callback);
					if(value === true) value = dependency.request;
					if(typeof type === "undefined" && /^[a-z0-9]+ /.test(value)) {
						var idx = value.indexOf(" ");
						type = value.substr(0, idx);
						value = value.substr(idx + 1);
					}
					callback(null, new ExternalModule(value, type || globalType));
					return true;
				}
				(function handleExternals(externals, callback) {
					if(typeof externals === "string") {
						if(externals === dependency.request) {
							return handleExternal(dependency.request, callback);
						}
					} else if(Array.isArray(externals)) {
						var i = 0;
						(function next() {
							do {
								var async = true;
								if(i >= externals.length) return callback();
								handleExternals(externals[i++], function(err, module) {
									if(err) return callback(err);
									if(!module) {
										if(async) {
											async = false;
											return;
										}
										return next();
									}
									callback(null, module);
								});
							} while (!async);
							async = false;
						}());
						return;
					} else if(externals instanceof RegExp) {
						if(externals.test(dependency.request)) {
							return handleExternal(dependency.request, callback);
						}
					} else if(typeof externals === "function") {
						externals.call(null, context, dependency.request, function(err, value, type) {
							if(err) return callback(err);
							if(typeof value !== "undefined") {
								handleExternal(value, type, callback);
							} else {
								callback();
							}
						});
						return;
					} else if(typeof externals === "object" && Object.prototype.hasOwnProperty.call(externals, dependency.request)) {
						return handleExternal(externals[dependency.request], callback);
					}
					callback();
				}(this.externals, function(err, module) {
					if(err) return callback(err);
					if(!module) return handleExternal(false, callback);
					return callback(null, module);
				}));
			}.bind(this);
		}.bind(this));
	};


/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Module = __webpack_require__(15);
	var OriginalSource = __webpack_require__(50);
	var RawSource = __webpack_require__(40);
	var WebpackMissingModule = __webpack_require__(126);
	
	function ExternalModule(request, type) {
		Module.call(this);
		this.request = request;
		this.type = type;
		this.built = false;
	}
	module.exports = ExternalModule;
	
	ExternalModule.prototype = Object.create(Module.prototype);
	
	ExternalModule.prototype.external = true;
	
	ExternalModule.prototype.identifier = function() {
		return "external " + JSON.stringify(this.request);
	};
	
	ExternalModule.prototype.readableIdentifier = function() {
		return "external " + JSON.stringify(this.request);
	};
	
	ExternalModule.prototype.needRebuild = function() {
		return false;
	};
	
	ExternalModule.prototype.build = function(options, compilation, resolver, fs, callback) {
		this.builtTime = new Date().getTime();
		callback();
	};
	
	ExternalModule.prototype.source = function() {
		var str = "throw new Error('Externals not supported');";
		var request = this.request;
		if(typeof request === "object") request = request[this.type];
		switch(this.type) {
			case "this":
			case "window":
			case "global":
				if(Array.isArray(request)) {
					str = "(function() { module.exports = " + this.type + request.map(function(r) {
						return "[" + JSON.stringify(r) + "]";
					}).join("") + "; }());";
				} else
					str = "(function() { module.exports = " + this.type + "[" + JSON.stringify(request) + "]; }());";
				break;
			case "commonjs":
			case "commonjs2":
				if(Array.isArray(request)) {
					str = "module.exports = require(" + JSON.stringify(request[0]) + ")" + request.slice(1).map(function(r) {
						return "[" + JSON.stringify(r) + "]";
					}).join("") + ";";
				} else
					str = "module.exports = require(" + JSON.stringify(request) + ");";
				break;
			case "amd":
			case "umd":
			case "umd2":
				str = "";
				if(this.optional) {
					str += "if(typeof __WEBPACK_EXTERNAL_MODULE_" + this.id + "__ === 'undefined') {" + WebpackMissingModule.moduleCode(request) + "}\n";
				}
				str += "module.exports = __WEBPACK_EXTERNAL_MODULE_" + this.id + "__;";
				break;
			default:
				str = "";
				if(this.optional) {
					str += "if(typeof " + request + " === 'undefined') {" + WebpackMissingModule.moduleCode(request) + "}\n";
				}
				str += "module.exports = " + request + ";";
				break;
		}
		if(this.useSourceMap) {
			return new OriginalSource(str, this.identifier());
		} else {
			return new RawSource(str);
		}
	};
	
	ExternalModule.prototype.size = function() {
		return 42;
	};


/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var path = __webpack_require__(4);
	var async = __webpack_require__(10);
	
	function OldNodeWatchFileSystem(inputFileSystem) {
		this.inputFileSystem = inputFileSystem;
	}
	module.exports = OldNodeWatchFileSystem;
	
	/**
	 *
	 * @param files {String[]} a sorted array of paths to files
	 * @param dirs {String[]} a sorted array of paths to directories
	 * @param startTime {number} the virtual start time
	 * @param delay {number} in ms, the time to wait to signal after the first change
	 * @param callback {function(err, filesModified: String[], dirsModified: String[], fileTimestamps: Object, dirTimestamps: Object)] called once after change plus delay
	 * @param callbackUndelayed {function()} called once after first change
	 */
	OldNodeWatchFileSystem.prototype.watch = function(files, dirs, missing, startTime, delay, callback, callbackUndelayed) {
		var inputFileSystem = this.inputFileSystem;
	
		if(!callbackUndelayed) callbackUndelayed = function() {};
		var closed = false;
		var fileTimestamps = {};
		var dirTimestamps = {};
		var filesModified = {};
		var dirsModified = {};
	
		var lastChangeTime;
	
		startTime = Math.floor(startTime / 1000) * 1000; // only 1 second accuracy
	
		var directories = {};
		dirs.forEach(function(dir) {
			directories[dir] = {
				context: dir,
				files: []
			};
		});
		files.forEach(function(file) {
			var dir = path.dirname(file);
			if(!directories[dir]) directories[dir] = {
				files: []
			};
			directories[dir].files.push(file);
		});
	
		var items = Object.keys(directories).map(function(dir) {
			directories[dir].path = dir;
			return directories[dir];
		});
		items.sort(function(a, b) {
			if(a.path === b.path) return 0;
			return a.path < b.path ? -1 : 1;
		});
		items.forEach(function(item) {
			if(item.files) {
				item.files.sort();
			}
		});
	
		var initialChange = false;
		var change = function() {
			initialChange = true;
		};
	
		function readStat(item, callback) {
			if(item.context) {
				fs.readdir(item.path, function(err, files) {
					function onTimestamp(ts) {
						if(!dirTimestamps[item.context] || dirTimestamps[item.context] < ts)
							dirTimestamps[item.context] = ts;
						if(ts >= startTime) {
							dirsModified[item.context] = true;
							change(item.path);
						}
						return callback();
					}
					if(err) return onTimestamp(Infinity);
					async.map(files, function(file, callback) {
						file = path.join(item.path, file);
						var isFile = false;
						if(item.files) {
							if(binarySearch(item.files, function(path) {
									if(path === file) return 0;
									return path < file ? -1 : 1;
								}) >= 0) {
								isFile = true;
							}
						}
						fs.stat(file, function(err, stat) {
							var ts = err ? Infinity : stat.mtime.getTime();
							if(isFile) {
								fileTimestamps[file] = ts;
								if(ts >= startTime) filesModified[file] = true;
							}
							return callback(null, ts);
						});
					}, function(err, timestamps) {
						if(err) return onTimestamp(Infinity);
						var ts = timestamps.reduce(function(max, ts) {
							if(ts > max)
								return ts;
							return max;
						}, 0);
						onTimestamp(ts);
					});
				});
			} else {
				async.forEach(item.files, function(file, callback) {
					fs.stat(file, function(err, stat) {
						var ts = err ? Infinity : stat.mtime.getTime();
						fileTimestamps[file] = ts;
						if(ts >= startTime) {
							filesModified[file] = true;
							change(file);
						}
						return callback(null, ts);
					});
				}, callback);
			}
		}
		async.forEach(items, function processItem(item, callback) {
			var isRunning = false;
			var isScheduled = false;
			item.watcher = fs.watch(item.path, function() {
				if(isRunning) {
					isScheduled = true;
					return;
				}
				isRunning = true;
				readStat(item, done);
			});
			if(item.context) {
				item.children = [];
				fs.readdir(item.path, function(err, files) {
					if(err) {
						change();
						onWatcherApplied();
						return;
					}
					async.forEach(files, function(file, callback) {
						file = path.join(item.path, file);
						fs.stat(file, function(err, stat) {
							if(err) {
								change(file);
								callback();
								return;
							}
							if(!stat.isDirectory()) return callback();
							var subitem = {
								path: file,
								context: item.context
							};
							item.children.push(subitem);
							processItem(subitem, callback);
						});
					}, onWatcherApplied);
				});
			} else onWatcherApplied();
	
			function onWatcherApplied() {
				readStat(item, function() {
					callback();
					done();
				});
			}
	
			function done() {
				if(closed) return;
				if(isScheduled) {
					isScheduled = false;
					readStat(item, done);
				} else {
					isRunning = false;
				}
			}
		}, function() {
			var timeout;
			if(initialChange) {
	
				callbackUndelayed();
				if(delay) {
					lastChangeTime = Date.now();
					change = restartDelay;
					timeout = setTimeout(onTimeout, delay);
				} else onTimeout();
	
			} else {
	
				change = function() {
	
					callbackUndelayed();
					if(delay) {
						lastChangeTime = Date.now();
						change = restartDelay;
						timeout = setTimeout(onTimeout, delay);
					} else {
						change = function() {};
						onTimeout();
					}
				};
	
			}
	
			function restartDelay() {
				lastChangeTime = Date.now();
				clearTimeout(timeout);
				timeout = setTimeout(onTimeout, delay);
			}
	
		});
	
		// 7.
		function onTimeout() {
			var nextSecond = Math.ceil(lastChangeTime / 1000) * 1000;
			var timeToNextSecond = nextSecond - Date.now();
			if(timeToNextSecond > 0) {
				setTimeout(onTimeout, timeToNextSecond);
				return;
			}
			change = function() {};
			if(closed) return;
			var outdatedFiles = Object.keys(filesModified).sort();
			var outdatedDirs = Object.keys(dirsModified).sort();
			if(inputFileSystem && inputFileSystem.purge) {
				inputFileSystem.purge(outdatedFiles);
				inputFileSystem.purge(outdatedDirs);
			}
			callback(null, outdatedFiles, outdatedDirs, [], fileTimestamps, dirTimestamps);
	
			close();
		}
	
		function close() {
			closed = true;
			items.forEach(function closeItem(item) {
				item.watcher.close();
				if(item.children) item.children.forEach(closeItem);
			});
		}
	
		return {
			close: close,
			pause: close
		};
	};
	
	function binarySearch(array, comparator) {
		var left = 0;
		var right = array.length - 1;
	
		while(left <= right) {
			var middle = ((left + right) / 2) | 0;
			var comp = comparator(array[middle]);
			if(comp === 0) return middle;
			if(comp > 0) right = middle - 1;
			if(comp < 0) left = middle + 1;
		}
		return -1;
	}


/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var SetVarMainTemplatePlugin = __webpack_require__(309);
	
	function accessorToObjectAccess(accessor) {
		return accessor.map(function(a) {
			return "[" + JSON.stringify(a) + "]";
		}).join("");
	}
	
	function accessorAccess(base, accessor, joinWith) {
		accessor = [].concat(accessor);
		return accessor.map(function(a, idx) {
			a = base ?
				base + accessorToObjectAccess(accessor.slice(0, idx + 1)) :
				accessor[0] + accessorToObjectAccess(accessor.slice(1, idx + 1));
			if(idx === accessor.length - 1) return a;
			if(idx === 0 && typeof base === "undefined") return a + " = typeof " + a + " === \"object\" ? " + a + " : {}";
			return a + " = " + a + " || {}";
		}).join(joinWith || "; ");
	}
	
	function LibraryTemplatePlugin(name, target, umdNamedDefine) {
		this.name = name;
		this.target = target;
		this.umdNamedDefine = umdNamedDefine;
	}
	module.exports = LibraryTemplatePlugin;
	LibraryTemplatePlugin.prototype.apply = function(compiler) {
		compiler.plugin("this-compilation", function(compilation) {
			switch(this.target) {
				case "var":
					compilation.apply(new SetVarMainTemplatePlugin("var " + accessorAccess(false, this.name)));
					break;
				case "assign":
					compilation.apply(new SetVarMainTemplatePlugin(accessorAccess(undefined, this.name)));
					break;
				case "this":
				case "window":
				case "global":
					if(this.name)
						compilation.apply(new SetVarMainTemplatePlugin(accessorAccess(this.target, this.name)));
					else
						compilation.apply(new SetVarMainTemplatePlugin(this.target, true));
					break;
				case "commonjs":
					if(this.name)
						compilation.apply(new SetVarMainTemplatePlugin(accessorAccess("exports", this.name)));
					else
						compilation.apply(new SetVarMainTemplatePlugin("exports", true));
					break;
				case "commonjs2":
					compilation.apply(new SetVarMainTemplatePlugin("module.exports"));
					break;
				case "amd":
					var AmdMainTemplatePlugin = __webpack_require__(310);
					compilation.apply(new AmdMainTemplatePlugin(this.name));
					break;
				case "umd":
				case "umd2":
					var UmdMainTemplatePlugin = __webpack_require__(311);
					compilation.apply(new UmdMainTemplatePlugin(this.name, {
						optionalAmdExternalAsGlobal: this.target === "umd2",
						namedDefine: this.umdNamedDefine
					}));
					break;
				case "jsonp":
					var JsonpExportMainTemplatePlugin = __webpack_require__(312);
					compilation.apply(new JsonpExportMainTemplatePlugin(this.name));
					break;
				default:
					throw new Error(this.target + " is not a valid Library target");
			}
		}.bind(this));
	};


/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConcatSource = __webpack_require__(49);
	
	function SetVarMainTemplatePlugin(varExpression, copyObject) {
		this.varExpression = varExpression;
		this.copyObject = copyObject;
	}
	module.exports = SetVarMainTemplatePlugin;
	SetVarMainTemplatePlugin.prototype.apply = function(compilation) {
		var mainTemplate = compilation.mainTemplate;
		compilation.templatesPlugin("render-with-entry", function(source, chunk, hash) {
			var varExpression = mainTemplate.applyPluginsWaterfall("asset-path", this.varExpression, {
				hash: hash,
				chunk: chunk
			});
			if(this.copyObject) {
				return new ConcatSource("(function(e, a) { for(var i in a) e[i] = a[i]; }(" +
					varExpression + ", ", source, "))");
			} else {
				var prefix = varExpression + " =\n";
				return new ConcatSource(prefix, source);
			}
		}.bind(this));
		mainTemplate.plugin("global-hash-paths", function(paths) {
			if(this.varExpression) paths.push(this.varExpression);
			return paths;
		});
		mainTemplate.plugin("hash", function(hash) {
			hash.update("set var");
			hash.update(this.varExpression + "");
			hash.update(this.copyObject + "");
		}.bind(this));
	};


/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConcatSource = __webpack_require__(49);
	
	function AmdMainTemplatePlugin(name) {
		this.name = name;
	}
	module.exports = AmdMainTemplatePlugin;
	AmdMainTemplatePlugin.prototype.apply = function(compilation) {
		var mainTemplate = compilation.mainTemplate;
		compilation.templatesPlugin("render-with-entry", function(source, chunk, hash) {
			var externals = chunk.modules.filter(function(m) {
				return m.external;
			});
			var externalsDepsArray = JSON.stringify(externals.map(function(m) {
				return typeof m.request === "object" ? m.request.amd : m.request;
			}));
			var externalsArguments = externals.map(function(m) {
				return "__WEBPACK_EXTERNAL_MODULE_" + m.id + "__";
			}).join(", ");
			if(this.name) {
				var name = mainTemplate.applyPluginsWaterfall("asset-path", this.name, {
					hash: hash,
					chunk: chunk
				});
				return new ConcatSource("define(" + JSON.stringify(name) + ", " + externalsDepsArray + ", function(" + externalsArguments + ") { return ", source, "});");
			} else if(externalsArguments) {
				return new ConcatSource("define(" + externalsDepsArray + ", function(" + externalsArguments + ") { return ", source, "});");
			} else {
				return new ConcatSource("define(function() { return ", source, "});");
			}
		}.bind(this));
		mainTemplate.plugin("global-hash-paths", function(paths) {
			if(this.name) paths.push(this.name);
			return paths;
		}.bind(this));
		mainTemplate.plugin("hash", function(hash) {
			hash.update("exports amd");
			hash.update(this.name + "");
		}.bind(this));
	};


/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConcatSource = __webpack_require__(49);
	var OriginalSource = __webpack_require__(50);
	
	function accessorToObjectAccess(accessor) {
		return accessor.map(function(a) {
			return "[" + JSON.stringify(a) + "]";
		}).join("");
	}
	
	function accessorAccess(base, accessor) {
		accessor = [].concat(accessor);
		return accessor.map(function(a, idx) {
			a = base + accessorToObjectAccess(accessor.slice(0, idx + 1));
			if(idx === accessor.length - 1) return a;
			return a + " = " + a + " || {}";
		}).join(", ");
	}
	
	function UmdMainTemplatePlugin(name, options) {
		this.name = name;
		this.optionalAmdExternalAsGlobal = options.optionalAmdExternalAsGlobal;
		this.namedDefine = options.namedDefine;
	}
	module.exports = UmdMainTemplatePlugin;
	UmdMainTemplatePlugin.prototype.apply = function(compilation) {
		var mainTemplate = compilation.mainTemplate;
		compilation.templatesPlugin("render-with-entry", function(source, chunk, hash) {
			var externals = chunk.modules.filter(function(m) {
				return m.external;
			});
			var optionalExternals = [],
				requiredExternals = [];
			if(this.optionalAmdExternalAsGlobal) {
				externals.forEach(function(m) {
					if(m.optional) {
						optionalExternals.push(m);
					} else {
						requiredExternals.push(m);
					}
				});
				externals = requiredExternals.concat(optionalExternals);
			} else {
				requiredExternals = externals;
			}
	
			function replaceKeys(str) {
				return mainTemplate.applyPluginsWaterfall("asset-path", str, {
					hash: hash,
					chunk: chunk
				});
			}
	
			function externalsDepsArray(modules) {
				return "[" + replaceKeys(modules.map(function(m) {
					return JSON.stringify(typeof m.request === "object" ? m.request.amd : m.request);
				}).join(", ")) + "]";
			}
	
			function externalsRootArray(modules) {
				return replaceKeys(modules.map(function(m) {
					var request = m.request;
					if(typeof request === "object") request = request.root;
					return "root" + accessorToObjectAccess([].concat(request));
				}).join(", "));
			}
	
			function externalsRequireArray(type) {
				return replaceKeys(externals.map(function(m) {
					var request = m.request;
					if(typeof request === "object") request = request[type];
					if(Array.isArray(request)) {
						var expr = "require(" + JSON.stringify(request[0]) + ")" + accessorToObjectAccess(request.slice(1));
					} else
						var expr = "require(" + JSON.stringify(request) + ")";
					if(m.optional) {
						expr = "(function webpackLoadOptionalExternalModule() { try { return " + expr + "; } catch(e) {} }())";
					}
					return expr;
				}).join(", "));
			}
	
			function externalsArguments(modules) {
				return modules.map(function(m) {
					return "__WEBPACK_EXTERNAL_MODULE_" + m.id + "__";
				}).join(", ");
			}
	
			function libraryName(library) {
				return JSON.stringify(replaceKeys([].concat(library).pop()));
			}
	
			if(optionalExternals.length > 0) {
				var amdFactory = "function webpackLoadOptionalExternalModuleAmd(" + externalsArguments(requiredExternals) + ") {\n" +
					"			return factory(" + (
						requiredExternals.length > 0 ?
						externalsArguments(requiredExternals) + ", " + externalsRootArray(optionalExternals) :
						externalsRootArray(optionalExternals)
					) + ");\n" +
					"		}";
			} else {
				var amdFactory = "factory";
			}
	
			return new ConcatSource(new OriginalSource(
				"(function webpackUniversalModuleDefinition(root, factory) {\n" +
				"	if(typeof exports === 'object' && typeof module === 'object')\n" +
				"		module.exports = factory(" + externalsRequireArray("commonjs2") + ");\n" +
				"	else if(typeof define === 'function' && define.amd)\n" +
				(requiredExternals.length > 0 ?
					(this.name && this.namedDefine === true ?
						"		define(" + libraryName(this.name) + ", " + externalsDepsArray(requiredExternals) + ", " + amdFactory + ");\n" :
						"		define(" + externalsDepsArray(requiredExternals) + ", " + amdFactory + ");\n"
					) :
					(this.name && this.namedDefine === true ?
						"		define(" + libraryName(this.name) + ", [], " + amdFactory + ");\n" :
						"		define([], " + amdFactory + ");\n"
					)
				) +
				(this.name ?
					"	else if(typeof exports === 'object')\n" +
					"		exports[" + libraryName(this.name) + "] = factory(" + externalsRequireArray("commonjs") + ");\n" +
					"	else\n" +
					"		" + replaceKeys(accessorAccess("root", this.name)) + " = factory(" + externalsRootArray(externals) + ");\n" :
					"	else {\n" +
					(externals.length > 0 ?
						"		var a = typeof exports === 'object' ? factory(" + externalsRequireArray("commonjs") + ") : factory(" + externalsRootArray(externals) + ");\n" :
						"		var a = factory();\n"
					) +
					"		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n" +
					"	}\n"
				) +
				"})(this, function(" + externalsArguments(externals) + ") {\nreturn ", "webpack/universalModuleDefinition"), source, "\n});\n");
		}.bind(this));
		mainTemplate.plugin("global-hash-paths", function(paths) {
			if(this.name) paths = paths.concat(this.name);
			return paths;
		}.bind(this));
		mainTemplate.plugin("hash", function(hash) {
			hash.update("umd");
			hash.update(this.name + "");
		}.bind(this));
	};


/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConcatSource = __webpack_require__(49);
	
	function JsonpExportMainTemplatePlugin(name) {
		this.name = name;
	}
	module.exports = JsonpExportMainTemplatePlugin;
	JsonpExportMainTemplatePlugin.prototype.apply = function(compilation) {
		var mainTemplate = compilation.mainTemplate;
		compilation.templatesPlugin("render-with-entry", function(source, chunk, hash) {
			var name = mainTemplate.applyPluginsWaterfall("asset-path", this.name || "", {
				hash: hash,
				chunk: chunk
			});
			return new ConcatSource(name + "(", source, ");");
		}.bind(this));
		mainTemplate.plugin("global-hash-paths", function(paths) {
			if(this.name) paths.push(this.name);
			return paths;
		}.bind(this));
		mainTemplate.plugin("hash", function(hash) {
			hash.update("jsonp export");
			hash.update(this.name + "");
		}.bind(this));
	};


/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Template = __webpack_require__(52);
	var BasicEvaluatedExpression = __webpack_require__(62);
	var ModuleHotAcceptDependency = __webpack_require__(314);
	var ModuleHotDeclineDependency = __webpack_require__(315);
	var RawSource = __webpack_require__(40);
	var ConstDependency = __webpack_require__(106);
	var NullFactory = __webpack_require__(108);
	
	function HotModuleReplacementPlugin() {}
	module.exports = HotModuleReplacementPlugin;
	
	HotModuleReplacementPlugin.prototype.apply = function(compiler) {
		var hotUpdateChunkFilename = compiler.options.output.hotUpdateChunkFilename;
		var hotUpdateMainFilename = compiler.options.output.hotUpdateMainFilename;
		compiler.plugin("compilation", function(compilation, params) {
			var hotUpdateChunkTemplate = compilation.hotUpdateChunkTemplate;
			if(!hotUpdateChunkTemplate) return;
	
			var normalModuleFactory = params.normalModuleFactory;
	
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());
	
			compilation.dependencyFactories.set(ModuleHotAcceptDependency, normalModuleFactory);
			compilation.dependencyTemplates.set(ModuleHotAcceptDependency, new ModuleHotAcceptDependency.Template());
	
			compilation.dependencyFactories.set(ModuleHotDeclineDependency, normalModuleFactory);
			compilation.dependencyTemplates.set(ModuleHotDeclineDependency, new ModuleHotDeclineDependency.Template());
	
			compilation.plugin("record", function(compilation, records) {
				if(records.hash === this.hash) return;
				records.hash = compilation.hash;
				records.moduleHashs = {};
				this.modules.forEach(function(module) {
					var identifier = module.identifier();
					var hash = __webpack_require__(59).createHash("md5");
					module.updateHash(hash);
					records.moduleHashs[identifier] = hash.digest("hex");
				});
				records.chunkHashs = {};
				this.chunks.forEach(function(chunk) {
					records.chunkHashs[chunk.id] = chunk.hash;
				});
				records.chunkModuleIds = {};
				this.chunks.forEach(function(chunk) {
					records.chunkModuleIds[chunk.id] = chunk.modules.map(function(m) {
						return m.id;
					});
				});
			});
			compilation.plugin("after-hash", function() {
				var records = this.records;
				if(!records) return;
				var preHash = records.preHash || "x";
				var prepreHash = records.prepreHash || "x";
				if(preHash === this.hash) {
					this.modifyHash(prepreHash);
					return;
				}
				records.prepreHash = records.hash || "x";
				records.preHash = this.hash;
				this.modifyHash(records.prepreHash);
			});
			compilation.plugin("additional-chunk-assets", function() {
				var records = this.records;
				if(records.hash === this.hash) return;
				if(!records.moduleHashs || !records.chunkHashs || !records.chunkModuleIds) return;
				this.modules.forEach(function(module) {
					var identifier = module.identifier();
					var hash = __webpack_require__(59).createHash("md5");
					module.updateHash(hash);
					hash = hash.digest("hex");
					module.hotUpdate = records.moduleHashs[identifier] !== hash;
				});
				var hotUpdateMainContent = {
					h: this.hash,
					c: []
				};
				Object.keys(records.chunkHashs).forEach(function(chunkId) {
					chunkId = +chunkId;
					var currentChunk = this.chunks.filter(function(chunk) {
						return chunk.id === chunkId;
					})[0];
					if(currentChunk) {
						var newModules = currentChunk.modules.filter(function(module) {
							return module.hotUpdate;
						});
						if(newModules.length > 0) {
							var source = hotUpdateChunkTemplate.render(chunkId, newModules, this.hash, this.moduleTemplate, this.dependencyTemplates);
							var filename = this.getPath(hotUpdateChunkFilename, {
								hash: records.hash,
								chunk: currentChunk
							});
							this.additionalChunkAssets.push(filename);
							this.assets[filename] = source;
							hotUpdateMainContent.c.push(chunkId);
							currentChunk.files.push(filename);
							this.applyPlugins("chunk-asset", currentChunk, filename);
						}
					}
				}, this);
				var source = new RawSource(JSON.stringify(hotUpdateMainContent));
				var filename = this.getPath(hotUpdateMainFilename, {
					hash: records.hash
				});
				this.assets[filename] = source;
			});
	
			compilation.mainTemplate.plugin("hash", function(hash) {
				hash.update("HotMainTemplateDecorator");
			});
	
			compilation.mainTemplate.plugin("module-require", function(_, chunk, hash, varModuleId) {
				return "hotCreateRequire(" + varModuleId + ")";
			});
	
			compilation.mainTemplate.plugin("require-extensions", function(source) {
				var buf = [source];
				buf.push("");
				buf.push("// __webpack_hash__");
				buf.push(this.requireFn + ".h = function() { return hotCurrentHash; };");
				return this.asString(buf);
			});
	
			compilation.mainTemplate.plugin("bootstrap", function(source, chunk, hash) {
				source = this.applyPluginsWaterfall("hot-bootstrap", source, chunk, hash);
				return this.asString([
					source,
					"",
					hotInitCode
					.replace(/\$require\$/g, this.requireFn)
					.replace(/\$hash\$/g, JSON.stringify(hash))
					.replace(/\/\*foreachInstalledChunks\*\//g, chunk.chunks.length > 0 ? "for(var chunkId in installedChunks)" : "var chunkId = " + chunk.id + ";")
				]);
			});
	
			compilation.mainTemplate.plugin("global-hash", function() {
				return true;
			});
	
			compilation.mainTemplate.plugin("current-hash", function(_, length) {
				if(isFinite(length))
					return "hotCurrentHash.substr(0, " + length + ")";
				else
					return "hotCurrentHash";
			});
	
			compilation.mainTemplate.plugin("module-obj", function(source, chunk, hash, varModuleId) {
				return this.asString([
					source + ",",
					"hot: hotCreateModule(" + varModuleId + "),",
					"parents: hotCurrentParents,",
					"children: []"
				]);
			});
	
		});
		compiler.parser.plugin("expression __webpack_hash__", function(expr) {
			var dep = new ConstDependency("__webpack_require__.h()", expr.range);
			dep.loc = expr.loc;
			this.state.current.addDependency(dep);
			return true;
		});
		compiler.parser.plugin("evaluate typeof __webpack_hash__", function(expr) {
			return new BasicEvaluatedExpression().setString("string").setRange(expr.range);
		});
		compiler.parser.plugin("evaluate Identifier module.hot", function(expr) {
			return new BasicEvaluatedExpression()
				.setBoolean(!!this.state.compilation.hotUpdateChunkTemplate)
				.setRange(expr.range);
		});
		compiler.parser.plugin("call module.hot.accept", function(expr) {
			if(!this.state.compilation.hotUpdateChunkTemplate) return false;
			if(expr.arguments.length > 1) {
				var arg = this.evaluateExpression(expr.arguments[0]);
				var params = [];
				if(arg.isString()) {
					params = [arg];
				} else if(arg.isArray()) {
					params = arg.items.filter(function(param) {
						return param.isString();
					});
				}
				params.forEach(function(param, idx) {
					var dep = new ModuleHotAcceptDependency(param.string, param.range);
					dep.optional = true;
					dep.loc = Object.create(expr.loc);
					dep.loc.index = idx;
					this.state.module.addDependency(dep);
				}.bind(this));
			}
		});
		compiler.parser.plugin("call module.hot.decline", function(expr) {
			if(!this.state.compilation.hotUpdateChunkTemplate) return false;
			if(expr.arguments.length === 1) {
				var arg = this.evaluateExpression(expr.arguments[0]);
				var params = [];
				if(arg.isString()) {
					params = [arg];
				} else if(arg.isArray()) {
					params = arg.items.filter(function(param) {
						return param.isString();
					});
				}
				params.forEach(function(param, idx) {
					var dep = new ModuleHotDeclineDependency(param.string, param.range);
					dep.optional = true;
					dep.loc = Object.create(expr.loc);
					dep.loc.index = idx;
					this.state.module.addDependency(dep);
				}.bind(this));
			}
		});
		compiler.parser.plugin("expression module.hot", function() {
			return true;
		});
	};
	
	var hotInitCode = Template.getFunctionContent(__webpack_require__(316));


/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleDependency = __webpack_require__(83);
	
	function ModuleHotAcceptDependency(request, range) {
		ModuleDependency.call(this, request);
		this.range = range;
		this.weak = true;
	}
	module.exports = ModuleHotAcceptDependency;
	
	ModuleHotAcceptDependency.prototype = Object.create(ModuleDependency.prototype);
	ModuleHotAcceptDependency.prototype.constructor = ModuleHotAcceptDependency;
	ModuleHotAcceptDependency.prototype.type = "module.hot.accept";
	
	ModuleHotAcceptDependency.Template = __webpack_require__(125);


/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleDependency = __webpack_require__(83);
	
	function ModuleHotDeclineDependency(request, range) {
		ModuleDependency.call(this, request);
		this.range = range;
		this.weak = true;
	}
	module.exports = ModuleHotDeclineDependency;
	
	ModuleHotDeclineDependency.prototype = Object.create(ModuleDependency.prototype);
	ModuleHotDeclineDependency.prototype.constructor = ModuleHotDeclineDependency;
	ModuleHotDeclineDependency.prototype.type = "module.hot.decline";
	
	ModuleHotDeclineDependency.Template = __webpack_require__(125);


/***/ },
/* 316 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	/*global $hash$ installedModules $require$ hotDownloadManifest hotDownloadUpdateChunk modules */
	module.exports = function() {
	
		// Copied from https://github.com/facebook/react/blob/bef45b0/src/shared/utils/canDefineProperty.js
		var canDefineProperty = false;
		try {
			Object.defineProperty({}, "x", {
				get: function() {}
			});
			canDefineProperty = true;
		} catch(x) {
			// IE will fail on defineProperty
		}
	
		var hotApplyOnUpdate = true;
		var hotCurrentHash = $hash$; // eslint-disable-line no-unused-vars
		var hotCurrentModuleData = {};
		var hotCurrentParents = []; // eslint-disable-line no-unused-vars
	
		function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
			var me = installedModules[moduleId];
			if(!me) return $require$;
			var fn = function(request) {
				if(me.hot.active) {
					if(installedModules[request]) {
						if(installedModules[request].parents.indexOf(moduleId) < 0)
							installedModules[request].parents.push(moduleId);
						if(me.children.indexOf(request) < 0)
							me.children.push(request);
					} else hotCurrentParents = [moduleId];
				} else {
					console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
					hotCurrentParents = [];
				}
				return $require$(request);
			};
			for(var name in $require$) {
				if(Object.prototype.hasOwnProperty.call($require$, name)) {
					if(canDefineProperty) {
						Object.defineProperty(fn, name, (function(name) {
							return {
								configurable: true,
								enumerable: true,
								get: function() {
									return $require$[name];
								},
								set: function(value) {
									$require$[name] = value;
								}
							};
						}(name)));
					} else {
						fn[name] = $require$[name];
					}
				}
			}
	
			function ensure(chunkId, callback) {
				if(hotStatus === "ready")
					hotSetStatus("prepare");
				hotChunksLoading++;
				$require$.e(chunkId, function() {
					try {
						callback.call(null, fn);
					} finally {
						finishChunkLoading();
					}
	
					function finishChunkLoading() {
						hotChunksLoading--;
						if(hotStatus === "prepare") {
							if(!hotWaitingFilesMap[chunkId]) {
								hotEnsureUpdateChunk(chunkId);
							}
							if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
								hotUpdateDownloaded();
							}
						}
					}
				});
			}
			if(canDefineProperty) {
				Object.defineProperty(fn, "e", {
					enumerable: true,
					value: ensure
				});
			} else {
				fn.e = ensure;
			}
			return fn;
		}
	
		function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
			var hot = {
				// private stuff
				_acceptedDependencies: {},
				_declinedDependencies: {},
				_selfAccepted: false,
				_selfDeclined: false,
				_disposeHandlers: [],
	
				// Module API
				active: true,
				accept: function(dep, callback) {
					if(typeof dep === "undefined")
						hot._selfAccepted = true;
					else if(typeof dep === "function")
						hot._selfAccepted = dep;
					else if(typeof dep === "object")
						for(var i = 0; i < dep.length; i++)
							hot._acceptedDependencies[dep[i]] = callback;
					else
						hot._acceptedDependencies[dep] = callback;
				},
				decline: function(dep) {
					if(typeof dep === "undefined")
						hot._selfDeclined = true;
					else if(typeof dep === "number")
						hot._declinedDependencies[dep] = true;
					else
						for(var i = 0; i < dep.length; i++)
							hot._declinedDependencies[dep[i]] = true;
				},
				dispose: function(callback) {
					hot._disposeHandlers.push(callback);
				},
				addDisposeHandler: function(callback) {
					hot._disposeHandlers.push(callback);
				},
				removeDisposeHandler: function(callback) {
					var idx = hot._disposeHandlers.indexOf(callback);
					if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
				},
	
				// Management API
				check: hotCheck,
				apply: hotApply,
				status: function(l) {
					if(!l) return hotStatus;
					hotStatusHandlers.push(l);
				},
				addStatusHandler: function(l) {
					hotStatusHandlers.push(l);
				},
				removeStatusHandler: function(l) {
					var idx = hotStatusHandlers.indexOf(l);
					if(idx >= 0) hotStatusHandlers.splice(idx, 1);
				},
	
				//inherit from previous dispose call
				data: hotCurrentModuleData[moduleId]
			};
			return hot;
		}
	
		var hotStatusHandlers = [];
		var hotStatus = "idle";
	
		function hotSetStatus(newStatus) {
			hotStatus = newStatus;
			for(var i = 0; i < hotStatusHandlers.length; i++)
				hotStatusHandlers[i].call(null, newStatus);
		}
	
		// while downloading
		var hotWaitingFiles = 0;
		var hotChunksLoading = 0;
		var hotWaitingFilesMap = {};
		var hotRequestedFilesMap = {};
		var hotAvailibleFilesMap = {};
		var hotCallback;
	
		// The update info
		var hotUpdate, hotUpdateNewHash;
	
		function toModuleId(id) {
			var isNumber = (+id) + "" === id;
			return isNumber ? +id : id;
		}
	
		function hotCheck(apply, callback) {
			if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
			if(typeof apply === "function") {
				hotApplyOnUpdate = false;
				callback = apply;
			} else {
				hotApplyOnUpdate = apply;
				callback = callback || function(err) {
					if(err) throw err;
				};
			}
			hotSetStatus("check");
			hotDownloadManifest(function(err, update) {
				if(err) return callback(err);
				if(!update) {
					hotSetStatus("idle");
					callback(null, null);
					return;
				}
	
				hotRequestedFilesMap = {};
				hotAvailibleFilesMap = {};
				hotWaitingFilesMap = {};
				for(var i = 0; i < update.c.length; i++)
					hotAvailibleFilesMap[update.c[i]] = true;
				hotUpdateNewHash = update.h;
	
				hotSetStatus("prepare");
				hotCallback = callback;
				hotUpdate = {};
				/*foreachInstalledChunks*/
				{ // eslint-disable-line no-lone-blocks
					/*globals chunkId */
					hotEnsureUpdateChunk(chunkId);
				}
				if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
					hotUpdateDownloaded();
				}
			});
		}
	
		function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
			if(!hotAvailibleFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
				return;
			hotRequestedFilesMap[chunkId] = false;
			for(var moduleId in moreModules) {
				if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
					hotUpdate[moduleId] = moreModules[moduleId];
				}
			}
			if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
				hotUpdateDownloaded();
			}
		}
	
		function hotEnsureUpdateChunk(chunkId) {
			if(!hotAvailibleFilesMap[chunkId]) {
				hotWaitingFilesMap[chunkId] = true;
			} else {
				hotRequestedFilesMap[chunkId] = true;
				hotWaitingFiles++;
				hotDownloadUpdateChunk(chunkId);
			}
		}
	
		function hotUpdateDownloaded() {
			hotSetStatus("ready");
			var callback = hotCallback;
			hotCallback = null;
			if(!callback) return;
			if(hotApplyOnUpdate) {
				hotApply(hotApplyOnUpdate, callback);
			} else {
				var outdatedModules = [];
				for(var id in hotUpdate) {
					if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
						outdatedModules.push(toModuleId(id));
					}
				}
				callback(null, outdatedModules);
			}
		}
	
		function hotApply(options, callback) {
			if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
			if(typeof options === "function") {
				callback = options;
				options = {};
			} else if(options && typeof options === "object") {
				callback = callback || function(err) {
					if(err) throw err;
				};
			} else {
				options = {};
				callback = callback || function(err) {
					if(err) throw err;
				};
			}
	
			function getAffectedStuff(module) {
				var outdatedModules = [module];
				var outdatedDependencies = {};
	
				var queue = outdatedModules.slice();
				while(queue.length > 0) {
					var moduleId = queue.pop();
					var module = installedModules[moduleId];
					if(!module || module.hot._selfAccepted)
						continue;
					if(module.hot._selfDeclined) {
						return new Error("Aborted because of self decline: " + moduleId);
					}
					if(moduleId === 0) {
						return;
					}
					for(var i = 0; i < module.parents.length; i++) {
						var parentId = module.parents[i];
						var parent = installedModules[parentId];
						if(parent.hot._declinedDependencies[moduleId]) {
							return new Error("Aborted because of declined dependency: " + moduleId + " in " + parentId);
						}
						if(outdatedModules.indexOf(parentId) >= 0) continue;
						if(parent.hot._acceptedDependencies[moduleId]) {
							if(!outdatedDependencies[parentId])
								outdatedDependencies[parentId] = [];
							addAllToSet(outdatedDependencies[parentId], [moduleId]);
							continue;
						}
						delete outdatedDependencies[parentId];
						outdatedModules.push(parentId);
						queue.push(parentId);
					}
				}
	
				return [outdatedModules, outdatedDependencies];
			}
	
			function addAllToSet(a, b) {
				for(var i = 0; i < b.length; i++) {
					var item = b[i];
					if(a.indexOf(item) < 0)
						a.push(item);
				}
			}
	
			// at begin all updates modules are outdated
			// the "outdated" status can propagate to parents if they don't accept the children
			var outdatedDependencies = {};
			var outdatedModules = [];
			var appliedUpdate = {};
			for(var id in hotUpdate) {
				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
					var moduleId = toModuleId(id);
					var result = getAffectedStuff(moduleId);
					if(!result) {
						if(options.ignoreUnaccepted)
							continue;
						hotSetStatus("abort");
						return callback(new Error("Aborted because " + moduleId + " is not accepted"));
					}
					if(result instanceof Error) {
						hotSetStatus("abort");
						return callback(result);
					}
					appliedUpdate[moduleId] = hotUpdate[moduleId];
					addAllToSet(outdatedModules, result[0]);
					for(var moduleId in result[1]) {
						if(Object.prototype.hasOwnProperty.call(result[1], moduleId)) {
							if(!outdatedDependencies[moduleId])
								outdatedDependencies[moduleId] = [];
							addAllToSet(outdatedDependencies[moduleId], result[1][moduleId]);
						}
					}
				}
			}
	
			// Store self accepted outdated modules to require them later by the module system
			var outdatedSelfAcceptedModules = [];
			for(var i = 0; i < outdatedModules.length; i++) {
				var moduleId = outdatedModules[i];
				if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
					outdatedSelfAcceptedModules.push({
						module: moduleId,
						errorHandler: installedModules[moduleId].hot._selfAccepted
					});
			}
	
			// Now in "dispose" phase
			hotSetStatus("dispose");
			var queue = outdatedModules.slice();
			while(queue.length > 0) {
				var moduleId = queue.pop();
				var module = installedModules[moduleId];
				if(!module) continue;
	
				var data = {};
	
				// Call dispose handlers
				var disposeHandlers = module.hot._disposeHandlers;
				for(var j = 0; j < disposeHandlers.length; j++) {
					var cb = disposeHandlers[j];
					cb(data);
				}
				hotCurrentModuleData[moduleId] = data;
	
				// disable module (this disables requires from this module)
				module.hot.active = false;
	
				// remove module from cache
				delete installedModules[moduleId];
	
				// remove "parents" references from all children
				for(var j = 0; j < module.children.length; j++) {
					var child = installedModules[module.children[j]];
					if(!child) continue;
					var idx = child.parents.indexOf(moduleId);
					if(idx >= 0) {
						child.parents.splice(idx, 1);
					}
				}
			}
	
			// remove outdated dependency from module children
			for(var moduleId in outdatedDependencies) {
				if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
					var module = installedModules[moduleId];
					var moduleOutdatedDependencies = outdatedDependencies[moduleId];
					for(var j = 0; j < moduleOutdatedDependencies.length; j++) {
						var dependency = moduleOutdatedDependencies[j];
						var idx = module.children.indexOf(dependency);
						if(idx >= 0) module.children.splice(idx, 1);
					}
				}
			}
	
			// Not in "apply" phase
			hotSetStatus("apply");
	
			hotCurrentHash = hotUpdateNewHash;
	
			// insert new code
			for(var moduleId in appliedUpdate) {
				if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
					modules[moduleId] = appliedUpdate[moduleId];
				}
			}
	
			// call accept handlers
			var error = null;
			for(var moduleId in outdatedDependencies) {
				if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
					var module = installedModules[moduleId];
					var moduleOutdatedDependencies = outdatedDependencies[moduleId];
					var callbacks = [];
					for(var i = 0; i < moduleOutdatedDependencies.length; i++) {
						var dependency = moduleOutdatedDependencies[i];
						var cb = module.hot._acceptedDependencies[dependency];
						if(callbacks.indexOf(cb) >= 0) continue;
						callbacks.push(cb);
					}
					for(var i = 0; i < callbacks.length; i++) {
						var cb = callbacks[i];
						try {
							cb(outdatedDependencies);
						} catch(err) {
							if(!error)
								error = err;
						}
					}
				}
			}
	
			// Load self accepted modules
			for(var i = 0; i < outdatedSelfAcceptedModules.length; i++) {
				var item = outdatedSelfAcceptedModules[i];
				var moduleId = item.module;
				hotCurrentParents = [moduleId];
				try {
					$require$(moduleId);
				} catch(err) {
					if(typeof item.errorHandler === "function") {
						try {
							item.errorHandler(err);
						} catch(err) {
							if(!error)
								error = err;
						}
					} else if(!error)
						error = err;
				}
			}
	
			// handle errors in accept handlers and self accepted module load
			if(error) {
				hotSetStatus("fail");
				return callback(error);
			}
	
			hotSetStatus("idle");
			callback(null, outdatedModules);
		}
	};


/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var PrefetchDependency = __webpack_require__(318);
	
	function PrefetchPlugin(context, request) {
		if(!request) {
			this.request = context;
		} else {
			this.context = context;
			this.request = request;
		}
	}
	module.exports = PrefetchPlugin;
	PrefetchPlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation, params) {
			var normalModuleFactory = params.normalModuleFactory;
	
			compilation.dependencyFactories.set(PrefetchDependency, normalModuleFactory);
		});
		compiler.plugin("make", function(compilation, callback) {
			compilation.prefetch(this.context || compiler.context, new PrefetchDependency(this.request), callback);
		}.bind(this));
	};


/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleDependency = __webpack_require__(83);
	
	function PrefetchDependency(request) {
		ModuleDependency.call(this, request);
	}
	module.exports = PrefetchDependency;
	
	PrefetchDependency.prototype = Object.create(ModuleDependency.prototype);
	PrefetchDependency.prototype.constructor = PrefetchDependency;
	PrefetchDependency.prototype.type = "prefetch";


/***/ },
/* 319 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function OccurrenceOrderPlugin(preferEntry) {
		if(preferEntry !== undefined && typeof preferEntry !== "boolean") {
			throw new Error("Argument should be a boolean.\nFor more info on this plugin, see https://webpack.github.io/docs/list-of-plugins.html");
		}
		this.preferEntry = preferEntry;
	}
	module.exports = OccurrenceOrderPlugin;
	OccurrenceOrderPlugin.prototype.apply = function(compiler) {
		var preferEntry = this.preferEntry;
		compiler.plugin("compilation", function(compilation) {
			compilation.plugin("optimize-module-order", function(modules) {
				function entryChunks(m) {
					return m.chunks.filter(function(c) {
						return c.initial;
					}).length;
				}
	
				function occursInEntry(m) {
					return m.reasons.map(function(r) {
						if(!r.module) return 0;
						return entryChunks(r.module);
					}).reduce(function(a, b) {
						return a + b;
					}, 0) + entryChunks(m);
				}
	
				function occurs(m) {
					return m.reasons.map(function(r) {
						if(!r.module) return 0;
						return r.module.chunks.length;
					}).reduce(function(a, b) {
						return a + b;
					}, 0) + m.chunks.length;
				}
				modules.sort(function(a, b) {
					if(preferEntry) {
						var aEntryOccurs = occursInEntry(a);
						var bEntryOccurs = occursInEntry(b);
						if(aEntryOccurs > bEntryOccurs) return -1;
						if(aEntryOccurs < bEntryOccurs) return 1;
					}
					var aOccurs = occurs(a);
					var bOccurs = occurs(b);
					if(aOccurs > bOccurs) return -1;
					if(aOccurs < bOccurs) return 1;
					if(a.identifier() > b.identifier()) return 1;
					if(a.identifier() < b.identifier()) return -1;
					return 0;
				});
			});
			compilation.plugin("optimize-chunk-order", function(chunks) {
				function occursInEntry(c) {
					return c.parents.filter(function(p) {
						return p.initial;
					}).length + (c.entry ? 1 : 0);
				}
	
				function occurs(c) {
					return c.blocks.length + (c.entry ? 1 : 0);
				}
				chunks.forEach(function(c) {
					c.modules.sort(function(a, b) {
						if(a.identifier() > b.identifier()) return 1;
						if(a.identifier() < b.identifier()) return -1;
						return 0;
					});
				});
				chunks.sort(function(a, b) {
					var aEntryOccurs = occursInEntry(a);
					var bEntryOccurs = occursInEntry(b);
					if(aEntryOccurs > bEntryOccurs) return -1;
					if(aEntryOccurs < bEntryOccurs) return 1;
					var aOccurs = occurs(a);
					var bOccurs = occurs(b);
					if(aOccurs > bOccurs) return -1;
					if(aOccurs < bOccurs) return 1;
					if(a.modules.length > b.modules.length) return -1;
					if(a.modules.length < b.modules.length) return 1;
					for(var i = 0; i < a.modules.length; i++) {
						if(a.modules[i].identifier() > b.modules[i].identifier()) return -1;
						if(a.modules[i].identifier() < b.modules[i].identifier()) return 1;
					}
					return 0;
				});
			});
		});
	};


/***/ },
/* 320 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function MinChunkSizePlugin(options) {
		if(typeof options !== "object" || Array.isArray(options)) {
			throw new Error("Argument should be an options object.\nFor more info on options, see https://webpack.github.io/docs/list-of-plugins.html");
		}
		this.options = options;
	}
	module.exports = MinChunkSizePlugin;
	
	MinChunkSizePlugin.prototype.apply = function(compiler) {
		var options = this.options;
		var minChunkSize = options.minChunkSize;
		compiler.plugin("compilation", function(compilation) {
			compilation.plugin("optimize-chunks", function(chunks) {
	
				var combinations = [];
				chunks.forEach(function(a, idx) {
					for(var i = 0; i < idx; i++) {
						var b = chunks[i];
						combinations.push([b, a]);
					}
				});
	
				var equalOptions = {
					chunkOverhead: 1,
					entryChunkMultiplicator: 1
				};
				combinations = combinations.filter(function(pair) {
					return pair[0].size(equalOptions) < minChunkSize || pair[1].size(equalOptions) < minChunkSize;
				});
	
				combinations.forEach(function(pair) {
					var a = pair[0].size(options);
					var b = pair[1].size(options);
					var ab = pair[0].integratedSize(pair[1], options);
					pair.unshift(a + b - ab, ab);
				});
	
				combinations = combinations.filter(function(pair) {
					return pair[1] !== false;
				});
	
				if(combinations.length === 0) return;
	
				combinations.sort(function(a, b) {
					var diff = b[0] - a[0];
					if(diff !== 0) return diff;
					return a[1] - b[1];
				});
	
				var pair = combinations[0];
	
				pair[2].integrate(pair[3], "min-size");
				chunks.splice(chunks.indexOf(pair[3]), 1);
				this.restartApplyPlugins();
			});
		});
	};


/***/ },
/* 321 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function LimitChunkCountPlugin(options) {
		if(options !== undefined && typeof options !== "object" || Array.isArray(options)) {
			throw new Error("Argument should be an options object.\nFor more info on options, see https://webpack.github.io/docs/list-of-plugins.html");
		}
		this.options = options || {};
	}
	module.exports = LimitChunkCountPlugin;
	
	LimitChunkCountPlugin.prototype.apply = function(compiler) {
		var options = this.options;
		compiler.plugin("compilation", function(compilation) {
			compilation.plugin("optimize-chunks", function(chunks) {
				var maxChunks = options.maxChunks;
				if(!maxChunks) return;
				if(maxChunks < 1) return;
				if(chunks.length <= maxChunks) return;
	
				if(chunks.length > maxChunks) {
					var combinations = [];
					chunks.forEach(function(a, idx) {
						for(var i = 0; i < idx; i++) {
							var b = chunks[i];
							combinations.push([b, a]);
						}
					});
	
					combinations.forEach(function(pair) {
						var a = pair[0].size(options);
						var b = pair[1].size(options);
						var ab = pair[0].integratedSize(pair[1], options);
						pair.unshift(a + b - ab, ab);
					});
					combinations = combinations.filter(function(pair) {
						return pair[1] !== false;
					});
					combinations.sort(function(a, b) {
						var diff = b[0] - a[0];
						if(diff !== 0) return diff;
						return a[1] - b[1];
					});
	
					var pair = combinations[0];
	
					if(pair && pair[2].integrate(pair[3], "limit")) {
						chunks.splice(chunks.indexOf(pair[3]), 1);
						this.restartApplyPlugins();
					}
				}
			});
		});
	};


/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var SourceMapConsumer = __webpack_require__(323).SourceMapConsumer;
	var SourceMapSource = __webpack_require__(70);
	var RawSource = __webpack_require__(40);
	var RequestShortener = __webpack_require__(46);
	var ModuleFilenameHelpers = __webpack_require__(92);
	var uglify = __webpack_require__(324);
	
	function UglifyJsPlugin(options) {
		if(typeof options !== "object") options = {};
		if(typeof options.compressor !== "undefined") {
			options.compress = options.compressor;
		}
		this.options = options;
	}
	module.exports = UglifyJsPlugin;
	
	UglifyJsPlugin.prototype.apply = function(compiler) {
		var options = this.options;
		options.test = options.test || /\.js($|\?)/i;
	
		var requestShortener = new RequestShortener(compiler.context);
		compiler.plugin("compilation", function(compilation) {
			if(options.sourceMap !== false) {
				compilation.plugin("build-module", function(module) {
					// to get detailed location info about errors
					module.useSourceMap = true;
				});
			}
			compilation.plugin("optimize-chunk-assets", function(chunks, callback) {
				var files = [];
				chunks.forEach(function(chunk) {
					chunk.files.forEach(function(file) {
						files.push(file);
					});
				});
				compilation.additionalChunkAssets.forEach(function(file) {
					files.push(file);
				});
				files = files.filter(ModuleFilenameHelpers.matchObject.bind(undefined, options));
				files.forEach(function(file) {
					var oldWarnFunction = uglify.AST_Node.warn_function;
					var warnings = [];
					try {
						var asset = compilation.assets[file];
						if(asset.__UglifyJsPlugin) {
							compilation.assets[file] = asset.__UglifyJsPlugin;
							return;
						}
						if(options.sourceMap !== false) {
							if(asset.sourceAndMap) {
								var sourceAndMap = asset.sourceAndMap();
								var inputSourceMap = sourceAndMap.map;
								var input = sourceAndMap.source;
							} else {
								var inputSourceMap = asset.map();
								var input = asset.source();
							}
							var sourceMap = new SourceMapConsumer(inputSourceMap);
							uglify.AST_Node.warn_function = function(warning) { // eslint-disable-line camelcase
								var match = /\[.+:([0-9]+),([0-9]+)\]/.exec(warning);
								var line = +match[1];
								var column = +match[2];
								var original = sourceMap.originalPositionFor({
									line: line,
									column: column
								});
								if(!original || !original.source || original.source === file) return;
								warnings.push(warning.replace(/\[.+:([0-9]+),([0-9]+)\]/, "") +
									"[" + requestShortener.shorten(original.source) + ":" + original.line + "," + original.column + "]");
							};
						} else {
							var input = asset.source();
							uglify.AST_Node.warn_function = function(warning) { // eslint-disable-line camelcase
								warnings.push(warning);
							};
						}
						uglify.base54.reset();
						var ast = uglify.parse(input, {
							filename: file
						});
						if(options.compress !== false) {
							ast.figure_out_scope();
							var compress = uglify.Compressor(options.compress); // eslint-disable-line new-cap
							ast = ast.transform(compress);
						}
						if(options.mangle !== false) {
							ast.figure_out_scope();
							ast.compute_char_frequency(options.mangle || {});
							ast.mangle_names(options.mangle || {});
							if(options.mangle && options.mangle.props) {
								uglify.mangle_properties(ast, options.mangle.props);
							}
						}
						var output = {};
						output.comments = Object.prototype.hasOwnProperty.call(options, "comments") ? options.comments : /^\**!|@preserve|@license/;
						output.beautify = options.beautify;
						for(var k in options.output) {
							output[k] = options.output[k];
						}
						if(options.sourceMap !== false) {
							var map = uglify.SourceMap({ // eslint-disable-line new-cap
								file: file,
								root: ""
							});
							output.source_map = map; // eslint-disable-line camelcase
						}
						var stream = uglify.OutputStream(output); // eslint-disable-line new-cap
						ast.print(stream);
						if(map) map = map + "";
						stream = stream + "";
						asset.__UglifyJsPlugin = compilation.assets[file] = (map ?
							new SourceMapSource(stream, file, JSON.parse(map), input, inputSourceMap) :
							new RawSource(stream));
						if(warnings.length > 0) {
							compilation.warnings.push(new Error(file + " from UglifyJs\n" + warnings.join("\n")));
						}
					} catch(err) {
						if(err.line) {
							var original = sourceMap && sourceMap.originalPositionFor({
								line: err.line,
								column: err.col
							});
							if(original && original.source) {
								compilation.errors.push(new Error(file + " from UglifyJs\n" + err.message + " [" + requestShortener.shorten(original.source) + ":" + original.line + "," + original.column + "]"));
							} else {
								compilation.errors.push(new Error(file + " from UglifyJs\n" + err.message + " [" + file + ":" + err.line + "," + err.col + "]"));
							}
						} else if(err.msg) {
							compilation.errors.push(new Error(file + " from UglifyJs\n" + err.msg));
						} else
							compilation.errors.push(new Error(file + " from UglifyJs\n" + err.stack));
					} finally {
						uglify.AST_Node.warn_function = oldWarnFunction; // eslint-disable-line camelcase
					}
				});
				callback();
			});
			compilation.plugin("normal-module-loader", function(context) {
				context.minimize = true;
			});
		});
	};


/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = __webpack_require__(20);

/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, __filename, global, Buffer, __dirname) {// workaround for tty output truncation upon process.exit()
	[process.stdout, process.stderr].forEach(function(stream){
	    if (stream._handle && stream._handle.setBlocking)
	        stream._handle.setBlocking(true);
	});
	
	var path = __webpack_require__(4);
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	
	var FILES = exports.FILES = [
	    "../lib/utils.js",
	    "../lib/ast.js",
	    "../lib/parse.js",
	    "../lib/transform.js",
	    "../lib/scope.js",
	    "../lib/output.js",
	    "../lib/compress.js",
	    "../lib/sourcemap.js",
	    "../lib/mozilla-ast.js",
	    "../lib/propmangle.js",
	    "./exports.js",
	].map(function(file){
	    return fs.realpathSync(path.join(path.dirname(__filename), file));
	});
	
	var UglifyJS = exports;
	
	new Function("MOZ_SourceMap", "exports", "DEBUG", FILES.map(function(file){
	    return fs.readFileSync(file, "utf8");
	}).join("\n\n"))(
	    __webpack_require__(325),
	    UglifyJS,
	    !!global.UGLIFY_DEBUG
	);
	
	UglifyJS.AST_Node.warn_function = function(txt) {
	    console.error("WARN: %s", txt);
	};
	
	exports.minify = function(files, options) {
	    options = UglifyJS.defaults(options, {
	        spidermonkey     : false,
	        outSourceMap     : null,
	        outFileName      : null,
	        sourceRoot       : null,
	        inSourceMap      : null,
	        sourceMapUrl     : null,
	        sourceMapInline  : false,
	        fromString       : false,
	        warnings         : false,
	        mangle           : {},
	        mangleProperties : false,
	        nameCache        : null,
	        output           : null,
	        compress         : {},
	        parse            : {}
	    });
	    UglifyJS.base54.reset();
	
	    // 1. parse
	    var toplevel = null,
	        sourcesContent = {};
	
	    if (options.spidermonkey) {
	        toplevel = UglifyJS.AST_Node.from_mozilla_ast(files);
	    } else {
	        function addFile(file, fileUrl) {
	            var code = options.fromString
	                ? file
	                : fs.readFileSync(file, "utf8");
	            sourcesContent[fileUrl] = code;
	            toplevel = UglifyJS.parse(code, {
	                filename: fileUrl,
	                toplevel: toplevel,
	                bare_returns: options.parse ? options.parse.bare_returns : undefined
	            });
	        }
	        if (!options.fromString) files = UglifyJS.simple_glob(files);
	        [].concat(files).forEach(function (files, i) {
	            if (typeof files === 'string') {
	                addFile(files, options.fromString ? i : files);
	            } else {
	                for (var fileUrl in files) {
	                    addFile(files[fileUrl], fileUrl);
	                }
	            }
	        });
	    }
	    if (options.wrap) {
	      toplevel = toplevel.wrap_commonjs(options.wrap, options.exportAll);
	    }
	
	    // 2. compress
	    if (options.compress) {
	        var compress = { warnings: options.warnings };
	        UglifyJS.merge(compress, options.compress);
	        toplevel.figure_out_scope();
	        var sq = UglifyJS.Compressor(compress);
	        toplevel = sq.compress(toplevel);
	    }
	
	    // 3. mangle properties
	    if (options.mangleProperties || options.nameCache) {
	        options.mangleProperties.cache = UglifyJS.readNameCache(options.nameCache, "props");
	        toplevel = UglifyJS.mangle_properties(toplevel, options.mangleProperties);
	        UglifyJS.writeNameCache(options.nameCache, "props", options.mangleProperties.cache);
	    }
	
	    // 4. mangle
	    if (options.mangle) {
	        toplevel.figure_out_scope(options.mangle);
	        toplevel.compute_char_frequency(options.mangle);
	        toplevel.mangle_names(options.mangle);
	    }
	
	    // 5. output
	    var inMap = options.inSourceMap;
	    var output = {};
	    if (typeof options.inSourceMap == "string") {
	        inMap = JSON.parse(fs.readFileSync(options.inSourceMap, "utf8"));
	    }
	    if (options.outSourceMap || options.sourceMapInline) {
	        output.source_map = UglifyJS.SourceMap({
	            // prefer outFileName, otherwise use outSourceMap without .map suffix
	            file: options.outFileName || (typeof options.outSourceMap === 'string' ? options.outSourceMap.replace(/\.map$/i, '') : null),
	            orig: inMap,
	            root: options.sourceRoot
	        });
	        if (options.sourceMapIncludeSources) {
	            for (var file in sourcesContent) {
	                if (sourcesContent.hasOwnProperty(file)) {
	                    output.source_map.get().setSourceContent(file, sourcesContent[file]);
	                }
	            }
	        }
	
	    }
	    if (options.output) {
	        UglifyJS.merge(output, options.output);
	    }
	    var stream = UglifyJS.OutputStream(output);
	    toplevel.print(stream);
	
	
	    var source_map = output.source_map;
	    if (source_map) {
	        source_map = source_map + "";
	    }
	
	    var mappingUrlPrefix = "\n//# sourceMappingURL=";
	    if (options.sourceMapInline) {
	        stream += mappingUrlPrefix + "data:application/json;charset=utf-8;base64," + new Buffer(source_map).toString("base64");
	    } else if (options.outSourceMap && typeof options.outSourceMap === "string" && options.sourceMapUrl !== false) {
	        stream += mappingUrlPrefix + (typeof options.sourceMapUrl === "string" ? options.sourceMapUrl : options.outSourceMap);
	    }
	
	    return {
	        code : stream + "",
	        map  : source_map
	    };
	};
	
	// exports.describe_ast = function() {
	//     function doitem(ctor) {
	//         var sub = {};
	//         ctor.SUBCLASSES.forEach(function(ctor){
	//             sub[ctor.TYPE] = doitem(ctor);
	//         });
	//         var ret = {};
	//         if (ctor.SELF_PROPS.length > 0) ret.props = ctor.SELF_PROPS;
	//         if (ctor.SUBCLASSES.length > 0) ret.sub = sub;
	//         return ret;
	//     }
	//     return doitem(UglifyJS.AST_Node).sub;
	// }
	
	exports.describe_ast = function() {
	    var out = UglifyJS.OutputStream({ beautify: true });
	    function doitem(ctor) {
	        out.print("AST_" + ctor.TYPE);
	        var props = ctor.SELF_PROPS.filter(function(prop){
	            return !/^\$/.test(prop);
	        });
	        if (props.length > 0) {
	            out.space();
	            out.with_parens(function(){
	                props.forEach(function(prop, i){
	                    if (i) out.space();
	                    out.print(prop);
	                });
	            });
	        }
	        if (ctor.documentation) {
	            out.space();
	            out.print_string(ctor.documentation);
	        }
	        if (ctor.SUBCLASSES.length > 0) {
	            out.space();
	            out.with_block(function(){
	                ctor.SUBCLASSES.forEach(function(ctor, i){
	                    out.indent();
	                    doitem(ctor);
	                    out.newline();
	                });
	            });
	        }
	    };
	    doitem(UglifyJS.AST_Node);
	    return out + "";
	};
	
	function readReservedFile(filename, reserved) {
	    if (!reserved) {
	        reserved = { vars: [], props: [] };
	    }
	    var data = fs.readFileSync(filename, "utf8");
	    data = JSON.parse(data);
	    if (data.vars) {
	        data.vars.forEach(function(name){
	            UglifyJS.push_uniq(reserved.vars, name);
	        });
	    }
	    if (data.props) {
	        data.props.forEach(function(name){
	            UglifyJS.push_uniq(reserved.props, name);
	        });
	    }
	    return reserved;
	}
	
	exports.readReservedFile = readReservedFile;
	
	exports.readDefaultReservedFile = function(reserved) {
	    return readReservedFile(path.join(__dirname, "domprops.json"), reserved);
	};
	
	exports.readNameCache = function(filename, key) {
	    var cache = null;
	    if (filename) {
	        try {
	            var cache = fs.readFileSync(filename, "utf8");
	            cache = JSON.parse(cache)[key];
	            if (!cache) throw "init";
	            cache.props = UglifyJS.Dictionary.fromObject(cache.props);
	        } catch(ex) {
	            cache = {
	                cname: -1,
	                props: new UglifyJS.Dictionary()
	            };
	        }
	    }
	    return cache;
	};
	
	exports.writeNameCache = function(filename, key, cache) {
	    if (filename) {
	        var data;
	        try {
	            data = fs.readFileSync(filename, "utf8");
	            data = JSON.parse(data);
	        } catch(ex) {
	            data = {};
	        }
	        data[key] = {
	            cname: cache.cname,
	            props: cache.props.toObject()
	        };
	        fs.writeFileSync(filename, JSON.stringify(data, null, 2), "utf8");
	    }
	};
	
	// A file glob function that only supports "*" and "?" wildcards in the basename.
	// Example: "foo/bar/*baz??.*.js"
	// Argument `glob` may be a string or an array of strings.
	// Returns an array of strings. Garbage in, garbage out.
	exports.simple_glob = function simple_glob(glob) {
	    var results = [];
	    if (Array.isArray(glob)) {
	        glob.forEach(function(elem) {
	            results = results.concat(simple_glob(elem));
	        });
	        return results;
	    }
	    if (glob.match(/\*|\?/)) {
	        var dir = path.dirname(glob);
	        try {
	            var entries = fs.readdirSync(dir);
	        } catch (ex) {}
	        if (entries) {
	            var pattern = "^" + (path.basename(glob)
	                .replace(/\(/g, "\\(")
	                .replace(/\)/g, "\\)")
	                .replace(/\{/g, "\\{")
	                .replace(/\}/g, "\\}")
	                .replace(/\[/g, "\\[")
	                .replace(/\]/g, "\\]")
	                .replace(/\+/g, "\\+")
	                .replace(/\^/g, "\\^")
	                .replace(/\$/g, "\\$")
	                .replace(/\*/g, "[^/\\\\]*")
	                .replace(/\./g, "\\.")
	                .replace(/\?/g, ".")) + "$";
	            var mod = process.platform === "win32" ? "i" : "";
	            var rx = new RegExp(pattern, mod);
	            for (var i in entries) {
	                if (rx.test(entries[i]))
	                    results.push(dir + "/" + entries[i]);
	            }
	        }
	    }
	    if (results.length === 0)
	        results = [ glob ];
	    return results;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), "/index.js", (function() { return this; }()), __webpack_require__(7).Buffer, "/"))

/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2009-2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE.txt or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	exports.SourceMapGenerator = __webpack_require__(326).SourceMapGenerator;
	exports.SourceMapConsumer = __webpack_require__(332).SourceMapConsumer;
	exports.SourceNode = __webpack_require__(335).SourceNode;


/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	
	var base64VLQ = __webpack_require__(327);
	var util = __webpack_require__(329);
	var ArraySet = __webpack_require__(330).ArraySet;
	var MappingList = __webpack_require__(331).MappingList;
	
	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet();
	  this._names = new ArraySet();
	  this._mappings = new MappingList();
	  this._sourcesContents = null;
	}
	
	SourceMapGenerator.prototype._version = 3;
	
	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };
	
	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }
	
	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };
	
	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }
	
	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };
	
	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);
	
	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }
	
	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }
	
	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }
	
	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };
	
	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }
	
	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };
	
	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet();
	    var newNames = new ArraySet();
	
	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source)
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }
	
	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }
	
	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }
	
	    }, this);
	    this._sources = newSources;
	    this._names = newNames;
	
	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };
	
	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };
	
	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;
	
	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = ''
	
	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }
	
	      next += base64VLQ.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;
	
	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64VLQ.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;
	
	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64VLQ.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;
	
	        next += base64VLQ.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;
	
	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64VLQ.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }
	
	      result += next;
	    }
	
	    return result;
	  };
	
	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };
	
	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }
	
	    return map;
	  };
	
	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };
	
	exports.SourceMapGenerator = SourceMapGenerator;


/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
	
	var base64 = __webpack_require__(328);
	
	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011
	
	var VLQ_BASE_SHIFT = 5;
	
	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
	
	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;
	
	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;
	
	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}
	
	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}
	
	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	exports.encode = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;
	
	  var vlq = toVLQSigned(aValue);
	
	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);
	
	  return encoded;
	};
	
	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;
	
	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }
	
	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }
	
	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);
	
	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};


/***/ },
/* 328 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	
	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
	
	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	exports.encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};
	
	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	exports.decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'
	
	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'
	
	  var zero = 48;     // '0'
	  var nine = 57;     // '9'
	
	  var plus = 43;     // '+'
	  var slash = 47;    // '/'
	
	  var littleOffset = 26;
	  var numberOffset = 52;
	
	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }
	
	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }
	
	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }
	
	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }
	
	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }
	
	  // Invalid base64 digit.
	  return -1;
	};


/***/ },
/* 329 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	
	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;
	
	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;
	
	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;
	
	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;
	
	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);
	
	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');
	
	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }
	
	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;
	
	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }
	
	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }
	
	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }
	
	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }
	
	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
	
	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;
	
	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
	};
	
	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	
	  aRoot = aRoot.replace(/\/$/, '');
	
	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }
	
	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }
	
	    ++level;
	  }
	
	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;
	
	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());
	
	function identity (s) {
	  return s;
	}
	
	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }
	
	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;
	
	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }
	
	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;
	
	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }
	
	  var length = s.length;
	
	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }
	
	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }
	
	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = mappingA.source - mappingB.source;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }
	
	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  return mappingA.name - mappingB.name;
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;
	
	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }
	
	  cmp = mappingA.source - mappingB.source;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  return mappingA.name - mappingB.name;
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
	
	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }
	
	  if (aStr1 > aStr2) {
	    return 1;
	  }
	
	  return -1;
	}
	
	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;


/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	
	var util = __webpack_require__(329);
	var has = Object.prototype.hasOwnProperty;
	
	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = Object.create(null);
	}
	
	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};
	
	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return Object.getOwnPropertyNames(this._set).length;
	};
	
	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = util.toSetString(aStr);
	  var isDuplicate = has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    this._set[sStr] = idx;
	  }
	};
	
	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  var sStr = util.toSetString(aStr);
	  return has.call(this._set, sStr);
	};
	
	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  var sStr = util.toSetString(aStr);
	  if (has.call(this._set, sStr)) {
	    return this._set[sStr];
	  }
	  throw new Error('"' + aStr + '" is not in the set.');
	};
	
	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};
	
	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};
	
	exports.ArraySet = ArraySet;


/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	
	var util = __webpack_require__(329);
	
	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}
	
	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}
	
	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };
	
	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};
	
	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};
	
	exports.MappingList = MappingList;


/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	
	var util = __webpack_require__(329);
	var binarySearch = __webpack_require__(333);
	var ArraySet = __webpack_require__(330).ArraySet;
	var base64VLQ = __webpack_require__(327);
	var quickSort = __webpack_require__(334).quickSort;
	
	function SourceMapConsumer(aSourceMap) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	  }
	
	  return sourceMap.sections != null
	    ? new IndexedSourceMapConsumer(sourceMap)
	    : new BasicSourceMapConsumer(sourceMap);
	}
	
	SourceMapConsumer.fromSourceMap = function(aSourceMap) {
	  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
	}
	
	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	SourceMapConsumer.prototype._version = 3;
	
	// `__generatedMappings` and `__originalMappings` are arrays that hold the
	// parsed mapping coordinates from the source map's "mappings" attribute. They
	// are lazily instantiated, accessed via the `_generatedMappings` and
	// `_originalMappings` getters respectively, and we only parse the mappings
	// and create these arrays once queried for a source location. We jump through
	// these hoops because there can be many thousands of mappings, and parsing
	// them is expensive, so we only want to do it if we must.
	//
	// Each object in the arrays is of the form:
	//
	//     {
	//       generatedLine: The line number in the generated code,
	//       generatedColumn: The column number in the generated code,
	//       source: The path to the original source file that generated this
	//               chunk of code,
	//       originalLine: The line number in the original source that
	//                     corresponds to this chunk of generated code,
	//       originalColumn: The column number in the original source that
	//                       corresponds to this chunk of generated code,
	//       name: The name of the original symbol which generated this chunk of
	//             code.
	//     }
	//
	// All properties except for `generatedLine` and `generatedColumn` can be
	// `null`.
	//
	// `_generatedMappings` is ordered by the generated positions.
	//
	// `_originalMappings` is ordered by the original positions.
	
	SourceMapConsumer.prototype.__generatedMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	  get: function () {
	    if (!this.__generatedMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }
	
	    return this.__generatedMappings;
	  }
	});
	
	SourceMapConsumer.prototype.__originalMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	  get: function () {
	    if (!this.__originalMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }
	
	    return this.__originalMappings;
	  }
	});
	
	SourceMapConsumer.prototype._charIsMappingSeparator =
	  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
	    var c = aStr.charAt(index);
	    return c === ";" || c === ",";
	  };
	
	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	SourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    throw new Error("Subclasses must implement _parseMappings");
	  };
	
	SourceMapConsumer.GENERATED_ORDER = 1;
	SourceMapConsumer.ORIGINAL_ORDER = 2;
	
	SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
	SourceMapConsumer.LEAST_UPPER_BOUND = 2;
	
	/**
	 * Iterate over each mapping between an original source/line/column and a
	 * generated line/column in this source map.
	 *
	 * @param Function aCallback
	 *        The function that is called with each mapping.
	 * @param Object aContext
	 *        Optional. If specified, this object will be the value of `this` every
	 *        time that `aCallback` is called.
	 * @param aOrder
	 *        Either `SourceMapConsumer.GENERATED_ORDER` or
	 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
	 *        iterate over the mappings sorted by the generated file's line/column
	 *        order or the original's source/line/column order, respectively. Defaults to
	 *        `SourceMapConsumer.GENERATED_ORDER`.
	 */
	SourceMapConsumer.prototype.eachMapping =
	  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	    var context = aContext || null;
	    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
	
	    var mappings;
	    switch (order) {
	    case SourceMapConsumer.GENERATED_ORDER:
	      mappings = this._generatedMappings;
	      break;
	    case SourceMapConsumer.ORIGINAL_ORDER:
	      mappings = this._originalMappings;
	      break;
	    default:
	      throw new Error("Unknown order of iteration.");
	    }
	
	    var sourceRoot = this.sourceRoot;
	    mappings.map(function (mapping) {
	      var source = mapping.source === null ? null : this._sources.at(mapping.source);
	      if (source != null && sourceRoot != null) {
	        source = util.join(sourceRoot, source);
	      }
	      return {
	        source: source,
	        generatedLine: mapping.generatedLine,
	        generatedColumn: mapping.generatedColumn,
	        originalLine: mapping.originalLine,
	        originalColumn: mapping.originalColumn,
	        name: mapping.name === null ? null : this._names.at(mapping.name)
	      };
	    }, this).forEach(aCallback, context);
	  };
	
	/**
	 * Returns all generated line and column information for the original source,
	 * line, and column provided. If no column is provided, returns all mappings
	 * corresponding to a either the line we are searching for or the next
	 * closest line that has any mappings. Otherwise, returns all mappings
	 * corresponding to the given line and either the column we are searching for
	 * or the next closest column that has any offsets.
	 *
	 * The only argument is an object with the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.
	 *   - column: Optional. the column number in the original source.
	 *
	 * and an array of objects is returned, each with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.
	 *   - column: The column number in the generated source, or null.
	 */
	SourceMapConsumer.prototype.allGeneratedPositionsFor =
	  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
	    var line = util.getArg(aArgs, 'line');
	
	    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
	    // returns the index of the closest mapping less than the needle. By
	    // setting needle.originalColumn to 0, we thus find the last mapping for
	    // the given line, provided such a mapping exists.
	    var needle = {
	      source: util.getArg(aArgs, 'source'),
	      originalLine: line,
	      originalColumn: util.getArg(aArgs, 'column', 0)
	    };
	
	    if (this.sourceRoot != null) {
	      needle.source = util.relative(this.sourceRoot, needle.source);
	    }
	    if (!this._sources.has(needle.source)) {
	      return [];
	    }
	    needle.source = this._sources.indexOf(needle.source);
	
	    var mappings = [];
	
	    var index = this._findMapping(needle,
	                                  this._originalMappings,
	                                  "originalLine",
	                                  "originalColumn",
	                                  util.compareByOriginalPositions,
	                                  binarySearch.LEAST_UPPER_BOUND);
	    if (index >= 0) {
	      var mapping = this._originalMappings[index];
	
	      if (aArgs.column === undefined) {
	        var originalLine = mapping.originalLine;
	
	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we found. Since
	        // mappings are sorted, this is guaranteed to find all mappings for
	        // the line we found.
	        while (mapping && mapping.originalLine === originalLine) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });
	
	          mapping = this._originalMappings[++index];
	        }
	      } else {
	        var originalColumn = mapping.originalColumn;
	
	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we were searching for.
	        // Since mappings are sorted, this is guaranteed to find all mappings for
	        // the line we are searching for.
	        while (mapping &&
	               mapping.originalLine === line &&
	               mapping.originalColumn == originalColumn) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });
	
	          mapping = this._originalMappings[++index];
	        }
	      }
	    }
	
	    return mappings;
	  };
	
	exports.SourceMapConsumer = SourceMapConsumer;
	
	/**
	 * A BasicSourceMapConsumer instance represents a parsed source map which we can
	 * query for information about the original file positions by giving it a file
	 * position in the generated source.
	 *
	 * The only parameter is the raw source map (either as a JSON string, or
	 * already parsed to an object). According to the spec, source maps have the
	 * following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - sources: An array of URLs to the original source files.
	 *   - names: An array of identifiers which can be referrenced by individual mappings.
	 *   - sourceRoot: Optional. The URL root from which all sources are relative.
	 *   - sourcesContent: Optional. An array of contents of the original source files.
	 *   - mappings: A string of base64 VLQs which contain the actual mappings.
	 *   - file: Optional. The generated file this source map is associated with.
	 *
	 * Here is an example source map, taken from the source map spec[0]:
	 *
	 *     {
	 *       version : 3,
	 *       file: "out.js",
	 *       sourceRoot : "",
	 *       sources: ["foo.js", "bar.js"],
	 *       names: ["src", "maps", "are", "fun"],
	 *       mappings: "AA,AB;;ABCDE;"
	 *     }
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
	 */
	function BasicSourceMapConsumer(aSourceMap) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	  }
	
	  var version = util.getArg(sourceMap, 'version');
	  var sources = util.getArg(sourceMap, 'sources');
	  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
	  // requires the array) to play nice here.
	  var names = util.getArg(sourceMap, 'names', []);
	  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	  var mappings = util.getArg(sourceMap, 'mappings');
	  var file = util.getArg(sourceMap, 'file', null);
	
	  // Once again, Sass deviates from the spec and supplies the version as a
	  // string rather than a number, so we use loose equality checking here.
	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }
	
	  sources = sources
	    .map(String)
	    // Some source maps produce relative source paths like "./foo.js" instead of
	    // "foo.js".  Normalize these first so that future comparisons will succeed.
	    // See bugzil.la/1090768.
	    .map(util.normalize)
	    // Always ensure that absolute sources are internally stored relative to
	    // the source root, if the source root is absolute. Not doing this would
	    // be particularly problematic when the source root is a prefix of the
	    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
	    .map(function (source) {
	      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
	        ? util.relative(sourceRoot, source)
	        : source;
	    });
	
	  // Pass `true` below to allow duplicate names and sources. While source maps
	  // are intended to be compressed and deduplicated, the TypeScript compiler
	  // sometimes generates source maps with duplicates in them. See Github issue
	  // #72 and bugzil.la/889492.
	  this._names = ArraySet.fromArray(names.map(String), true);
	  this._sources = ArraySet.fromArray(sources, true);
	
	  this.sourceRoot = sourceRoot;
	  this.sourcesContent = sourcesContent;
	  this._mappings = mappings;
	  this.file = file;
	}
	
	BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
	
	/**
	 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
	 *
	 * @param SourceMapGenerator aSourceMap
	 *        The source map that will be consumed.
	 * @returns BasicSourceMapConsumer
	 */
	BasicSourceMapConsumer.fromSourceMap =
	  function SourceMapConsumer_fromSourceMap(aSourceMap) {
	    var smc = Object.create(BasicSourceMapConsumer.prototype);
	
	    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
	    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
	    smc.sourceRoot = aSourceMap._sourceRoot;
	    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
	                                                            smc.sourceRoot);
	    smc.file = aSourceMap._file;
	
	    // Because we are modifying the entries (by converting string sources and
	    // names to indices into the sources and names ArraySets), we have to make
	    // a copy of the entry or else bad things happen. Shared mutable state
	    // strikes again! See github issue #191.
	
	    var generatedMappings = aSourceMap._mappings.toArray().slice();
	    var destGeneratedMappings = smc.__generatedMappings = [];
	    var destOriginalMappings = smc.__originalMappings = [];
	
	    for (var i = 0, length = generatedMappings.length; i < length; i++) {
	      var srcMapping = generatedMappings[i];
	      var destMapping = new Mapping;
	      destMapping.generatedLine = srcMapping.generatedLine;
	      destMapping.generatedColumn = srcMapping.generatedColumn;
	
	      if (srcMapping.source) {
	        destMapping.source = sources.indexOf(srcMapping.source);
	        destMapping.originalLine = srcMapping.originalLine;
	        destMapping.originalColumn = srcMapping.originalColumn;
	
	        if (srcMapping.name) {
	          destMapping.name = names.indexOf(srcMapping.name);
	        }
	
	        destOriginalMappings.push(destMapping);
	      }
	
	      destGeneratedMappings.push(destMapping);
	    }
	
	    quickSort(smc.__originalMappings, util.compareByOriginalPositions);
	
	    return smc;
	  };
	
	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	BasicSourceMapConsumer.prototype._version = 3;
	
	/**
	 * The list of original sources.
	 */
	Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    return this._sources.toArray().map(function (s) {
	      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
	    }, this);
	  }
	});
	
	/**
	 * Provide the JIT with a nice shape / hidden class.
	 */
	function Mapping() {
	  this.generatedLine = 0;
	  this.generatedColumn = 0;
	  this.source = null;
	  this.originalLine = null;
	  this.originalColumn = null;
	  this.name = null;
	}
	
	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	BasicSourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    var generatedLine = 1;
	    var previousGeneratedColumn = 0;
	    var previousOriginalLine = 0;
	    var previousOriginalColumn = 0;
	    var previousSource = 0;
	    var previousName = 0;
	    var length = aStr.length;
	    var index = 0;
	    var cachedSegments = {};
	    var temp = {};
	    var originalMappings = [];
	    var generatedMappings = [];
	    var mapping, str, segment, end, value;
	
	    while (index < length) {
	      if (aStr.charAt(index) === ';') {
	        generatedLine++;
	        index++;
	        previousGeneratedColumn = 0;
	      }
	      else if (aStr.charAt(index) === ',') {
	        index++;
	      }
	      else {
	        mapping = new Mapping();
	        mapping.generatedLine = generatedLine;
	
	        // Because each offset is encoded relative to the previous one,
	        // many segments often have the same encoding. We can exploit this
	        // fact by caching the parsed variable length fields of each segment,
	        // allowing us to avoid a second parse if we encounter the same
	        // segment again.
	        for (end = index; end < length; end++) {
	          if (this._charIsMappingSeparator(aStr, end)) {
	            break;
	          }
	        }
	        str = aStr.slice(index, end);
	
	        segment = cachedSegments[str];
	        if (segment) {
	          index += str.length;
	        } else {
	          segment = [];
	          while (index < end) {
	            base64VLQ.decode(aStr, index, temp);
	            value = temp.value;
	            index = temp.rest;
	            segment.push(value);
	          }
	
	          if (segment.length === 2) {
	            throw new Error('Found a source, but no line and column');
	          }
	
	          if (segment.length === 3) {
	            throw new Error('Found a source and line, but no column');
	          }
	
	          cachedSegments[str] = segment;
	        }
	
	        // Generated column.
	        mapping.generatedColumn = previousGeneratedColumn + segment[0];
	        previousGeneratedColumn = mapping.generatedColumn;
	
	        if (segment.length > 1) {
	          // Original source.
	          mapping.source = previousSource + segment[1];
	          previousSource += segment[1];
	
	          // Original line.
	          mapping.originalLine = previousOriginalLine + segment[2];
	          previousOriginalLine = mapping.originalLine;
	          // Lines are stored 0-based
	          mapping.originalLine += 1;
	
	          // Original column.
	          mapping.originalColumn = previousOriginalColumn + segment[3];
	          previousOriginalColumn = mapping.originalColumn;
	
	          if (segment.length > 4) {
	            // Original name.
	            mapping.name = previousName + segment[4];
	            previousName += segment[4];
	          }
	        }
	
	        generatedMappings.push(mapping);
	        if (typeof mapping.originalLine === 'number') {
	          originalMappings.push(mapping);
	        }
	      }
	    }
	
	    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
	    this.__generatedMappings = generatedMappings;
	
	    quickSort(originalMappings, util.compareByOriginalPositions);
	    this.__originalMappings = originalMappings;
	  };
	
	/**
	 * Find the mapping that best matches the hypothetical "needle" mapping that
	 * we are searching for in the given "haystack" of mappings.
	 */
	BasicSourceMapConsumer.prototype._findMapping =
	  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
	                                         aColumnName, aComparator, aBias) {
	    // To return the position we are searching for, we must first find the
	    // mapping for the given position and then return the opposite position it
	    // points to. Because the mappings are sorted, we can use binary search to
	    // find the best mapping.
	
	    if (aNeedle[aLineName] <= 0) {
	      throw new TypeError('Line must be greater than or equal to 1, got '
	                          + aNeedle[aLineName]);
	    }
	    if (aNeedle[aColumnName] < 0) {
	      throw new TypeError('Column must be greater than or equal to 0, got '
	                          + aNeedle[aColumnName]);
	    }
	
	    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	  };
	
	/**
	 * Compute the last column for each generated mapping. The last column is
	 * inclusive.
	 */
	BasicSourceMapConsumer.prototype.computeColumnSpans =
	  function SourceMapConsumer_computeColumnSpans() {
	    for (var index = 0; index < this._generatedMappings.length; ++index) {
	      var mapping = this._generatedMappings[index];
	
	      // Mappings do not contain a field for the last generated columnt. We
	      // can come up with an optimistic estimate, however, by assuming that
	      // mappings are contiguous (i.e. given two consecutive mappings, the
	      // first mapping ends where the second one starts).
	      if (index + 1 < this._generatedMappings.length) {
	        var nextMapping = this._generatedMappings[index + 1];
	
	        if (mapping.generatedLine === nextMapping.generatedLine) {
	          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
	          continue;
	        }
	      }
	
	      // The last mapping for each line spans the entire line.
	      mapping.lastGeneratedColumn = Infinity;
	    }
	  };
	
	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.
	 *   - column: The column number in the generated source.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.
	 *   - column: The column number in the original source, or null.
	 *   - name: The original identifier, or null.
	 */
	BasicSourceMapConsumer.prototype.originalPositionFor =
	  function SourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };
	
	    var index = this._findMapping(
	      needle,
	      this._generatedMappings,
	      "generatedLine",
	      "generatedColumn",
	      util.compareByGeneratedPositionsDeflated,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );
	
	    if (index >= 0) {
	      var mapping = this._generatedMappings[index];
	
	      if (mapping.generatedLine === needle.generatedLine) {
	        var source = util.getArg(mapping, 'source', null);
	        if (source !== null) {
	          source = this._sources.at(source);
	          if (this.sourceRoot != null) {
	            source = util.join(this.sourceRoot, source);
	          }
	        }
	        var name = util.getArg(mapping, 'name', null);
	        if (name !== null) {
	          name = this._names.at(name);
	        }
	        return {
	          source: source,
	          line: util.getArg(mapping, 'originalLine', null),
	          column: util.getArg(mapping, 'originalColumn', null),
	          name: name
	        };
	      }
	    }
	
	    return {
	      source: null,
	      line: null,
	      column: null,
	      name: null
	    };
	  };
	
	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function BasicSourceMapConsumer_hasContentsOfAllSources() {
	    if (!this.sourcesContent) {
	      return false;
	    }
	    return this.sourcesContent.length >= this._sources.size() &&
	      !this.sourcesContent.some(function (sc) { return sc == null; });
	  };
	
	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	BasicSourceMapConsumer.prototype.sourceContentFor =
	  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    if (!this.sourcesContent) {
	      return null;
	    }
	
	    if (this.sourceRoot != null) {
	      aSource = util.relative(this.sourceRoot, aSource);
	    }
	
	    if (this._sources.has(aSource)) {
	      return this.sourcesContent[this._sources.indexOf(aSource)];
	    }
	
	    var url;
	    if (this.sourceRoot != null
	        && (url = util.urlParse(this.sourceRoot))) {
	      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
	      // many users. We can help them out when they expect file:// URIs to
	      // behave like it would if they were running a local HTTP server. See
	      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
	      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
	      if (url.scheme == "file"
	          && this._sources.has(fileUriAbsPath)) {
	        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
	      }
	
	      if ((!url.path || url.path == "/")
	          && this._sources.has("/" + aSource)) {
	        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
	      }
	    }
	
	    // This function is used recursively from
	    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
	    // don't want to throw if we can't find the source - we just want to
	    // return null, so we provide a flag to exit gracefully.
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    }
	  };
	
	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.
	 *   - column: The column number in the original source.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.
	 *   - column: The column number in the generated source, or null.
	 */
	BasicSourceMapConsumer.prototype.generatedPositionFor =
	  function SourceMapConsumer_generatedPositionFor(aArgs) {
	    var source = util.getArg(aArgs, 'source');
	    if (this.sourceRoot != null) {
	      source = util.relative(this.sourceRoot, source);
	    }
	    if (!this._sources.has(source)) {
	      return {
	        line: null,
	        column: null,
	        lastColumn: null
	      };
	    }
	    source = this._sources.indexOf(source);
	
	    var needle = {
	      source: source,
	      originalLine: util.getArg(aArgs, 'line'),
	      originalColumn: util.getArg(aArgs, 'column')
	    };
	
	    var index = this._findMapping(
	      needle,
	      this._originalMappings,
	      "originalLine",
	      "originalColumn",
	      util.compareByOriginalPositions,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );
	
	    if (index >= 0) {
	      var mapping = this._originalMappings[index];
	
	      if (mapping.source === needle.source) {
	        return {
	          line: util.getArg(mapping, 'generatedLine', null),
	          column: util.getArg(mapping, 'generatedColumn', null),
	          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	        };
	      }
	    }
	
	    return {
	      line: null,
	      column: null,
	      lastColumn: null
	    };
	  };
	
	exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
	
	/**
	 * An IndexedSourceMapConsumer instance represents a parsed source map which
	 * we can query for information. It differs from BasicSourceMapConsumer in
	 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
	 * input.
	 *
	 * The only parameter is a raw source map (either as a JSON string, or already
	 * parsed to an object). According to the spec for indexed source maps, they
	 * have the following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - file: Optional. The generated file this source map is associated with.
	 *   - sections: A list of section definitions.
	 *
	 * Each value under the "sections" field has two fields:
	 *   - offset: The offset into the original specified at which this section
	 *       begins to apply, defined as an object with a "line" and "column"
	 *       field.
	 *   - map: A source map definition. This source map could also be indexed,
	 *       but doesn't have to be.
	 *
	 * Instead of the "map" field, it's also possible to have a "url" field
	 * specifying a URL to retrieve a source map from, but that's currently
	 * unsupported.
	 *
	 * Here's an example source map, taken from the source map spec[0], but
	 * modified to omit a section which uses the "url" field.
	 *
	 *  {
	 *    version : 3,
	 *    file: "app.js",
	 *    sections: [{
	 *      offset: {line:100, column:10},
	 *      map: {
	 *        version : 3,
	 *        file: "section.js",
	 *        sources: ["foo.js", "bar.js"],
	 *        names: ["src", "maps", "are", "fun"],
	 *        mappings: "AAAA,E;;ABCDE;"
	 *      }
	 *    }],
	 *  }
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
	 */
	function IndexedSourceMapConsumer(aSourceMap) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	  }
	
	  var version = util.getArg(sourceMap, 'version');
	  var sections = util.getArg(sourceMap, 'sections');
	
	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }
	
	  this._sources = new ArraySet();
	  this._names = new ArraySet();
	
	  var lastOffset = {
	    line: -1,
	    column: 0
	  };
	  this._sections = sections.map(function (s) {
	    if (s.url) {
	      // The url field will require support for asynchronicity.
	      // See https://github.com/mozilla/source-map/issues/16
	      throw new Error('Support for url field in sections not implemented.');
	    }
	    var offset = util.getArg(s, 'offset');
	    var offsetLine = util.getArg(offset, 'line');
	    var offsetColumn = util.getArg(offset, 'column');
	
	    if (offsetLine < lastOffset.line ||
	        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
	      throw new Error('Section offsets must be ordered and non-overlapping.');
	    }
	    lastOffset = offset;
	
	    return {
	      generatedOffset: {
	        // The offset fields are 0-based, but we use 1-based indices when
	        // encoding/decoding from VLQ.
	        generatedLine: offsetLine + 1,
	        generatedColumn: offsetColumn + 1
	      },
	      consumer: new SourceMapConsumer(util.getArg(s, 'map'))
	    }
	  });
	}
	
	IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
	
	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	IndexedSourceMapConsumer.prototype._version = 3;
	
	/**
	 * The list of original sources.
	 */
	Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    var sources = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
	        sources.push(this._sections[i].consumer.sources[j]);
	      }
	    }
	    return sources;
	  }
	});
	
	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.
	 *   - column: The column number in the generated source.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.
	 *   - column: The column number in the original source, or null.
	 *   - name: The original identifier, or null.
	 */
	IndexedSourceMapConsumer.prototype.originalPositionFor =
	  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };
	
	    // Find the section containing the generated position we're trying to map
	    // to an original position.
	    var sectionIndex = binarySearch.search(needle, this._sections,
	      function(needle, section) {
	        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
	        if (cmp) {
	          return cmp;
	        }
	
	        return (needle.generatedColumn -
	                section.generatedOffset.generatedColumn);
	      });
	    var section = this._sections[sectionIndex];
	
	    if (!section) {
	      return {
	        source: null,
	        line: null,
	        column: null,
	        name: null
	      };
	    }
	
	    return section.consumer.originalPositionFor({
	      line: needle.generatedLine -
	        (section.generatedOffset.generatedLine - 1),
	      column: needle.generatedColumn -
	        (section.generatedOffset.generatedLine === needle.generatedLine
	         ? section.generatedOffset.generatedColumn - 1
	         : 0),
	      bias: aArgs.bias
	    });
	  };
	
	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
	    return this._sections.every(function (s) {
	      return s.consumer.hasContentsOfAllSources();
	    });
	  };
	
	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	IndexedSourceMapConsumer.prototype.sourceContentFor =
	  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	
	      var content = section.consumer.sourceContentFor(aSource, true);
	      if (content) {
	        return content;
	      }
	    }
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    }
	  };
	
	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.
	 *   - column: The column number in the original source.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.
	 *   - column: The column number in the generated source, or null.
	 */
	IndexedSourceMapConsumer.prototype.generatedPositionFor =
	  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	
	      // Only consider this section if the requested source is in the list of
	      // sources of the consumer.
	      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
	        continue;
	      }
	      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
	      if (generatedPosition) {
	        var ret = {
	          line: generatedPosition.line +
	            (section.generatedOffset.generatedLine - 1),
	          column: generatedPosition.column +
	            (section.generatedOffset.generatedLine === generatedPosition.line
	             ? section.generatedOffset.generatedColumn - 1
	             : 0)
	        };
	        return ret;
	      }
	    }
	
	    return {
	      line: null,
	      column: null
	    };
	  };
	
	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	IndexedSourceMapConsumer.prototype._parseMappings =
	  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    this.__generatedMappings = [];
	    this.__originalMappings = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	      var sectionMappings = section.consumer._generatedMappings;
	      for (var j = 0; j < sectionMappings.length; j++) {
	        var mapping = sectionMappings[j];
	
	        var source = section.consumer._sources.at(mapping.source);
	        if (section.consumer.sourceRoot !== null) {
	          source = util.join(section.consumer.sourceRoot, source);
	        }
	        this._sources.add(source);
	        source = this._sources.indexOf(source);
	
	        var name = section.consumer._names.at(mapping.name);
	        this._names.add(name);
	        name = this._names.indexOf(name);
	
	        // The mappings coming from the consumer for the section have
	        // generated positions relative to the start of the section, so we
	        // need to offset them to be relative to the start of the concatenated
	        // generated file.
	        var adjustedMapping = {
	          source: source,
	          generatedLine: mapping.generatedLine +
	            (section.generatedOffset.generatedLine - 1),
	          generatedColumn: mapping.generatedColumn +
	            (section.generatedOffset.generatedLine === mapping.generatedLine
	            ? section.generatedOffset.generatedColumn - 1
	            : 0),
	          originalLine: mapping.originalLine,
	          originalColumn: mapping.originalColumn,
	          name: name
	        };
	
	        this.__generatedMappings.push(adjustedMapping);
	        if (typeof adjustedMapping.originalLine === 'number') {
	          this.__originalMappings.push(adjustedMapping);
	        }
	      }
	    }
	
	    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
	    quickSort(this.__originalMappings, util.compareByOriginalPositions);
	  };
	
	exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;


/***/ },
/* 333 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	
	exports.GREATEST_LOWER_BOUND = 1;
	exports.LEAST_UPPER_BOUND = 2;
	
	/**
	 * Recursive implementation of binary search.
	 *
	 * @param aLow Indices here and lower do not contain the needle.
	 * @param aHigh Indices here and higher do not contain the needle.
	 * @param aNeedle The element being searched for.
	 * @param aHaystack The non-empty array being searched.
	 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
	 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 */
	function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
	  // This function terminates when one of the following is true:
	  //
	  //   1. We find the exact element we are looking for.
	  //
	  //   2. We did not find the exact element, but we can return the index of
	  //      the next-closest element.
	  //
	  //   3. We did not find the exact element, and there is no next-closest
	  //      element than the one we are searching for, so we return -1.
	  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
	  var cmp = aCompare(aNeedle, aHaystack[mid], true);
	  if (cmp === 0) {
	    // Found the element we are looking for.
	    return mid;
	  }
	  else if (cmp > 0) {
	    // Our needle is greater than aHaystack[mid].
	    if (aHigh - mid > 1) {
	      // The element is in the upper half.
	      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
	    }
	
	    // The exact needle element was not found in this haystack. Determine if
	    // we are in termination case (3) or (2) and return the appropriate thing.
	    if (aBias == exports.LEAST_UPPER_BOUND) {
	      return aHigh < aHaystack.length ? aHigh : -1;
	    } else {
	      return mid;
	    }
	  }
	  else {
	    // Our needle is less than aHaystack[mid].
	    if (mid - aLow > 1) {
	      // The element is in the lower half.
	      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
	    }
	
	    // we are in termination case (3) or (2) and return the appropriate thing.
	    if (aBias == exports.LEAST_UPPER_BOUND) {
	      return mid;
	    } else {
	      return aLow < 0 ? -1 : aLow;
	    }
	  }
	}
	
	/**
	 * This is an implementation of binary search which will always try and return
	 * the index of the closest element if there is no exact hit. This is because
	 * mappings between original and generated line/col pairs are single points,
	 * and there is an implicit region between each of them, so a miss just means
	 * that you aren't on the very start of a region.
	 *
	 * @param aNeedle The element you are looking for.
	 * @param aHaystack The array that is being searched.
	 * @param aCompare A function which takes the needle and an element in the
	 *     array and returns -1, 0, or 1 depending on whether the needle is less
	 *     than, equal to, or greater than the element, respectively.
	 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
	 */
	exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
	  if (aHaystack.length === 0) {
	    return -1;
	  }
	
	  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
	                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
	  if (index < 0) {
	    return -1;
	  }
	
	  // We have found either the exact element, or the next-closest element than
	  // the one we are searching for. However, there may be more than one such
	  // element. Make sure we always return the smallest of these.
	  while (index - 1 >= 0) {
	    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
	      break;
	    }
	    --index;
	  }
	
	  return index;
	};


/***/ },
/* 334 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	
	// It turns out that some (most?) JavaScript engines don't self-host
	// `Array.prototype.sort`. This makes sense because C++ will likely remain
	// faster than JS when doing raw CPU-intensive sorting. However, when using a
	// custom comparator function, calling back and forth between the VM's C++ and
	// JIT'd JS is rather slow *and* loses JIT type information, resulting in
	// worse generated code for the comparator function than would be optimal. In
	// fact, when sorting with a comparator, these costs outweigh the benefits of
	// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
	// a ~3500ms mean speed-up in `bench/bench.html`.
	
	/**
	 * Swap the elements indexed by `x` and `y` in the array `ary`.
	 *
	 * @param {Array} ary
	 *        The array.
	 * @param {Number} x
	 *        The index of the first item.
	 * @param {Number} y
	 *        The index of the second item.
	 */
	function swap(ary, x, y) {
	  var temp = ary[x];
	  ary[x] = ary[y];
	  ary[y] = temp;
	}
	
	/**
	 * Returns a random integer within the range `low .. high` inclusive.
	 *
	 * @param {Number} low
	 *        The lower bound on the range.
	 * @param {Number} high
	 *        The upper bound on the range.
	 */
	function randomIntInRange(low, high) {
	  return Math.round(low + (Math.random() * (high - low)));
	}
	
	/**
	 * The Quick Sort algorithm.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 * @param {Number} p
	 *        Start index of the array
	 * @param {Number} r
	 *        End index of the array
	 */
	function doQuickSort(ary, comparator, p, r) {
	  // If our lower bound is less than our upper bound, we (1) partition the
	  // array into two pieces and (2) recurse on each half. If it is not, this is
	  // the empty array and our base case.
	
	  if (p < r) {
	    // (1) Partitioning.
	    //
	    // The partitioning chooses a pivot between `p` and `r` and moves all
	    // elements that are less than or equal to the pivot to the before it, and
	    // all the elements that are greater than it after it. The effect is that
	    // once partition is done, the pivot is in the exact place it will be when
	    // the array is put in sorted order, and it will not need to be moved
	    // again. This runs in O(n) time.
	
	    // Always choose a random pivot so that an input array which is reverse
	    // sorted does not cause O(n^2) running time.
	    var pivotIndex = randomIntInRange(p, r);
	    var i = p - 1;
	
	    swap(ary, pivotIndex, r);
	    var pivot = ary[r];
	
	    // Immediately after `j` is incremented in this loop, the following hold
	    // true:
	    //
	    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
	    //
	    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
	    for (var j = p; j < r; j++) {
	      if (comparator(ary[j], pivot) <= 0) {
	        i += 1;
	        swap(ary, i, j);
	      }
	    }
	
	    swap(ary, i + 1, j);
	    var q = i + 1;
	
	    // (2) Recurse on each half.
	
	    doQuickSort(ary, comparator, p, q - 1);
	    doQuickSort(ary, comparator, q + 1, r);
	  }
	}
	
	/**
	 * Sort the given array in-place with the given comparator function.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 */
	exports.quickSort = function (ary, comparator) {
	  doQuickSort(ary, comparator, 0, ary.length - 1);
	};


/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	
	var SourceMapGenerator = __webpack_require__(326).SourceMapGenerator;
	var util = __webpack_require__(329);
	
	// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
	// operating systems these days (capturing the result).
	var REGEX_NEWLINE = /(\r?\n)/;
	
	// Newline character code for charCodeAt() comparisons
	var NEWLINE_CODE = 10;
	
	// Private symbol for identifying `SourceNode`s when multiple versions of
	// the source-map library are loaded. This MUST NOT CHANGE across
	// versions!
	var isSourceNode = "$$$isSourceNode$$$";
	
	/**
	 * SourceNodes provide a way to abstract over interpolating/concatenating
	 * snippets of generated JavaScript source code while maintaining the line and
	 * column information associated with the original source code.
	 *
	 * @param aLine The original line number.
	 * @param aColumn The original column number.
	 * @param aSource The original source's filename.
	 * @param aChunks Optional. An array of strings which are snippets of
	 *        generated JS, or other SourceNodes.
	 * @param aName The original identifier.
	 */
	function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
	  this.children = [];
	  this.sourceContents = {};
	  this.line = aLine == null ? null : aLine;
	  this.column = aColumn == null ? null : aColumn;
	  this.source = aSource == null ? null : aSource;
	  this.name = aName == null ? null : aName;
	  this[isSourceNode] = true;
	  if (aChunks != null) this.add(aChunks);
	}
	
	/**
	 * Creates a SourceNode from generated code and a SourceMapConsumer.
	 *
	 * @param aGeneratedCode The generated code
	 * @param aSourceMapConsumer The SourceMap for the generated code
	 * @param aRelativePath Optional. The path that relative sources in the
	 *        SourceMapConsumer should be relative to.
	 */
	SourceNode.fromStringWithSourceMap =
	  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
	    // The SourceNode we want to fill with the generated code
	    // and the SourceMap
	    var node = new SourceNode();
	
	    // All even indices of this array are one line of the generated code,
	    // while all odd indices are the newlines between two adjacent lines
	    // (since `REGEX_NEWLINE` captures its match).
	    // Processed fragments are removed from this array, by calling `shiftNextLine`.
	    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
	    var shiftNextLine = function() {
	      var lineContents = remainingLines.shift();
	      // The last line of a file might not have a newline.
	      var newLine = remainingLines.shift() || "";
	      return lineContents + newLine;
	    };
	
	    // We need to remember the position of "remainingLines"
	    var lastGeneratedLine = 1, lastGeneratedColumn = 0;
	
	    // The generate SourceNodes we need a code range.
	    // To extract it current and last mapping is used.
	    // Here we store the last mapping.
	    var lastMapping = null;
	
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      if (lastMapping !== null) {
	        // We add the code from "lastMapping" to "mapping":
	        // First check if there is a new line in between.
	        if (lastGeneratedLine < mapping.generatedLine) {
	          // Associate first line with "lastMapping"
	          addMappingWithCode(lastMapping, shiftNextLine());
	          lastGeneratedLine++;
	          lastGeneratedColumn = 0;
	          // The remaining code is added without mapping
	        } else {
	          // There is no new line in between.
	          // Associate the code between "lastGeneratedColumn" and
	          // "mapping.generatedColumn" with "lastMapping"
	          var nextLine = remainingLines[0];
	          var code = nextLine.substr(0, mapping.generatedColumn -
	                                        lastGeneratedColumn);
	          remainingLines[0] = nextLine.substr(mapping.generatedColumn -
	                                              lastGeneratedColumn);
	          lastGeneratedColumn = mapping.generatedColumn;
	          addMappingWithCode(lastMapping, code);
	          // No more remaining code, continue
	          lastMapping = mapping;
	          return;
	        }
	      }
	      // We add the generated code until the first mapping
	      // to the SourceNode without any mapping.
	      // Each line is added as separate string.
	      while (lastGeneratedLine < mapping.generatedLine) {
	        node.add(shiftNextLine());
	        lastGeneratedLine++;
	      }
	      if (lastGeneratedColumn < mapping.generatedColumn) {
	        var nextLine = remainingLines[0];
	        node.add(nextLine.substr(0, mapping.generatedColumn));
	        remainingLines[0] = nextLine.substr(mapping.generatedColumn);
	        lastGeneratedColumn = mapping.generatedColumn;
	      }
	      lastMapping = mapping;
	    }, this);
	    // We have processed all mappings.
	    if (remainingLines.length > 0) {
	      if (lastMapping) {
	        // Associate the remaining code in the current line with "lastMapping"
	        addMappingWithCode(lastMapping, shiftNextLine());
	      }
	      // and add the remaining lines without any mapping
	      node.add(remainingLines.join(""));
	    }
	
	    // Copy sourcesContent into SourceNode
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aRelativePath != null) {
	          sourceFile = util.join(aRelativePath, sourceFile);
	        }
	        node.setSourceContent(sourceFile, content);
	      }
	    });
	
	    return node;
	
	    function addMappingWithCode(mapping, code) {
	      if (mapping === null || mapping.source === undefined) {
	        node.add(code);
	      } else {
	        var source = aRelativePath
	          ? util.join(aRelativePath, mapping.source)
	          : mapping.source;
	        node.add(new SourceNode(mapping.originalLine,
	                                mapping.originalColumn,
	                                source,
	                                code,
	                                mapping.name));
	      }
	    }
	  };
	
	/**
	 * Add a chunk of generated JS to this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.add = function SourceNode_add(aChunk) {
	  if (Array.isArray(aChunk)) {
	    aChunk.forEach(function (chunk) {
	      this.add(chunk);
	    }, this);
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    if (aChunk) {
	      this.children.push(aChunk);
	    }
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};
	
	/**
	 * Add a chunk of generated JS to the beginning of this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
	  if (Array.isArray(aChunk)) {
	    for (var i = aChunk.length-1; i >= 0; i--) {
	      this.prepend(aChunk[i]);
	    }
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    this.children.unshift(aChunk);
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};
	
	/**
	 * Walk over the tree of JS snippets in this node and its children. The
	 * walking function is called once for each snippet of JS and is passed that
	 * snippet and the its original associated source's line/column location.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walk = function SourceNode_walk(aFn) {
	  var chunk;
	  for (var i = 0, len = this.children.length; i < len; i++) {
	    chunk = this.children[i];
	    if (chunk[isSourceNode]) {
	      chunk.walk(aFn);
	    }
	    else {
	      if (chunk !== '') {
	        aFn(chunk, { source: this.source,
	                     line: this.line,
	                     column: this.column,
	                     name: this.name });
	      }
	    }
	  }
	};
	
	/**
	 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
	 * each of `this.children`.
	 *
	 * @param aSep The separator.
	 */
	SourceNode.prototype.join = function SourceNode_join(aSep) {
	  var newChildren;
	  var i;
	  var len = this.children.length;
	  if (len > 0) {
	    newChildren = [];
	    for (i = 0; i < len-1; i++) {
	      newChildren.push(this.children[i]);
	      newChildren.push(aSep);
	    }
	    newChildren.push(this.children[i]);
	    this.children = newChildren;
	  }
	  return this;
	};
	
	/**
	 * Call String.prototype.replace on the very right-most source snippet. Useful
	 * for trimming whitespace from the end of a source node, etc.
	 *
	 * @param aPattern The pattern to replace.
	 * @param aReplacement The thing to replace the pattern with.
	 */
	SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
	  var lastChild = this.children[this.children.length - 1];
	  if (lastChild[isSourceNode]) {
	    lastChild.replaceRight(aPattern, aReplacement);
	  }
	  else if (typeof lastChild === 'string') {
	    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
	  }
	  else {
	    this.children.push(''.replace(aPattern, aReplacement));
	  }
	  return this;
	};
	
	/**
	 * Set the source content for a source file. This will be added to the SourceMapGenerator
	 * in the sourcesContent field.
	 *
	 * @param aSourceFile The filename of the source file
	 * @param aSourceContent The content of the source file
	 */
	SourceNode.prototype.setSourceContent =
	  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
	    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	  };
	
	/**
	 * Walk over the tree of SourceNodes. The walking function is called for each
	 * source file content and is passed the filename and source content.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walkSourceContents =
	  function SourceNode_walkSourceContents(aFn) {
	    for (var i = 0, len = this.children.length; i < len; i++) {
	      if (this.children[i][isSourceNode]) {
	        this.children[i].walkSourceContents(aFn);
	      }
	    }
	
	    var sources = Object.keys(this.sourceContents);
	    for (var i = 0, len = sources.length; i < len; i++) {
	      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
	    }
	  };
	
	/**
	 * Return the string representation of this source node. Walks over the tree
	 * and concatenates all the various snippets together to one string.
	 */
	SourceNode.prototype.toString = function SourceNode_toString() {
	  var str = "";
	  this.walk(function (chunk) {
	    str += chunk;
	  });
	  return str;
	};
	
	/**
	 * Returns the string representation of this source node along with a source
	 * map.
	 */
	SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
	  var generated = {
	    code: "",
	    line: 1,
	    column: 0
	  };
	  var map = new SourceMapGenerator(aArgs);
	  var sourceMappingActive = false;
	  var lastOriginalSource = null;
	  var lastOriginalLine = null;
	  var lastOriginalColumn = null;
	  var lastOriginalName = null;
	  this.walk(function (chunk, original) {
	    generated.code += chunk;
	    if (original.source !== null
	        && original.line !== null
	        && original.column !== null) {
	      if(lastOriginalSource !== original.source
	         || lastOriginalLine !== original.line
	         || lastOriginalColumn !== original.column
	         || lastOriginalName !== original.name) {
	        map.addMapping({
	          source: original.source,
	          original: {
	            line: original.line,
	            column: original.column
	          },
	          generated: {
	            line: generated.line,
	            column: generated.column
	          },
	          name: original.name
	        });
	      }
	      lastOriginalSource = original.source;
	      lastOriginalLine = original.line;
	      lastOriginalColumn = original.column;
	      lastOriginalName = original.name;
	      sourceMappingActive = true;
	    } else if (sourceMappingActive) {
	      map.addMapping({
	        generated: {
	          line: generated.line,
	          column: generated.column
	        }
	      });
	      lastOriginalSource = null;
	      sourceMappingActive = false;
	    }
	    for (var idx = 0, length = chunk.length; idx < length; idx++) {
	      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
	        generated.line++;
	        generated.column = 0;
	        // Mappings end at eol
	        if (idx + 1 === length) {
	          lastOriginalSource = null;
	          sourceMappingActive = false;
	        } else if (sourceMappingActive) {
	          map.addMapping({
	            source: original.source,
	            original: {
	              line: original.line,
	              column: original.column
	            },
	            generated: {
	              line: generated.line,
	              column: generated.column
	            },
	            name: original.name
	          });
	        }
	      } else {
	        generated.column++;
	      }
	    }
	  });
	  this.walkSourceContents(function (sourceFile, sourceContent) {
	    map.setSourceContent(sourceFile, sourceContent);
	  });
	
	  return { code: generated.code, map: map };
	};
	
	exports.SourceNode = SourceNode;


/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var async = __webpack_require__(10);
	
	function CachePlugin(cache) {
		this.cache = cache || {};
	}
	module.exports = CachePlugin;
	
	CachePlugin.prototype.apply = function(compiler) {
		if(Array.isArray(compiler.compilers)) {
			compiler.compilers.forEach(function(c, idx) {
				c.apply(new CachePlugin(this.cache[idx] = this.cache[idx] || {}));
			}, this);
		} else {
			compiler.plugin("compilation", function(compilation) {
				compilation.cache = this.cache;
			}.bind(this));
			compiler.plugin("run", function(compiler, callback) {
				if(!compiler._lastCompilationFileDependencies) return callback();
				var fs = compiler.inputFileSystem;
				var fileTs = compiler.fileTimestamps = {};
				async.forEach(compiler._lastCompilationFileDependencies, function(file, callback) {
					fs.stat(file, function(err, stat) {
						if(err) {
							if(err.code === "ENOENT") return callback();
							return callback(err);
						}
	
						fileTs[file] = stat.mtime || Infinity;
						callback();
					});
				}, callback);
			});
			compiler.plugin("after-compile", function(compilation, callback) {
				compilation.compiler._lastCompilationFileDependencies = compilation.fileDependencies;
				compilation.compiler._lastCompilationContextDependencies = compilation.contextDependencies;
				callback();
			});
		}
	};


/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ModuleParserHelpers = __webpack_require__(112);
	var ConstDependency = __webpack_require__(106);
	
	var NullFactory = __webpack_require__(108);
	
	function ProvidePlugin(definitions) {
		this.definitions = definitions;
	}
	module.exports = ProvidePlugin;
	ProvidePlugin.prototype.apply = function(compiler) {
		compiler.plugin("compilation", function(compilation) {
			compilation.dependencyFactories.set(ConstDependency, new NullFactory());
			compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());
		});
		Object.keys(this.definitions).forEach(function(name) {
			var request = this.definitions[name];
			var splittedName = name.split(".");
			if(splittedName.length > 0) {
				splittedName.slice(1).forEach(function(_, i) {
					var name = splittedName.slice(0, i + 1).join(".");
					compiler.parser.plugin("can-rename " + name, function() {
						return true;
					});
				});
			}
			compiler.parser.plugin("expression " + name, function(expr) {
				var nameIdentifier = name;
				var scopedName = name.indexOf(".") >= 0;
				if(scopedName) {
					nameIdentifier = "__webpack_provided_" + name.replace(/\./g, "_dot_");
				}
				if(!ModuleParserHelpers.addParsedVariable(this, nameIdentifier, "require(" + JSON.stringify(request) + ")")) {
					return false;
				}
				if(scopedName) {
					nameIdentifier = "__webpack_provided_" + name.replace(/\./g, "_dot_");
					var dep = new ConstDependency(nameIdentifier, expr.range);
					dep.loc = expr.loc;
					this.state.current.addDependency(dep);
				}
				return true;
			});
		}, this);
	};


/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var OptionsDefaulter = __webpack_require__(339);
	
	function WebpackOptionsDefaulter() {
		OptionsDefaulter.call(this);
		this.set("debug", false);
		this.set("devtool", false);
		this.set("cache", true);
	
		this.set("context", process.cwd());
		this.set("target", "web");
		this.set("output", {});
		this.set("node", {});
		this.set("resolve", {});
		this.set("resolveLoader", {});
	
		this.set("module.unknownContextRequest", ".");
		this.set("module.unknownContextRecursive", true);
		this.set("module.unknownContextRegExp", /^\.\/.*$/);
		this.set("module.unknownContextCritical", true);
		this.set("module.exprContextRequest", ".");
		this.set("module.exprContextRegExp", /^\.\/.*$/);
		this.set("module.exprContextRecursive", true);
		this.set("module.exprContextCritical", true);
		this.set("module.wrappedContextRegExp", /.*/);
		this.set("module.wrappedContextRecursive", true);
		this.set("module.wrappedContextCritical", false);
	
		this.set("output.libraryTarget", "var");
		this.set("output.path", "");
		this.set("output.sourceMapFilename", "[file].map[query]");
		this.set("output.hotUpdateChunkFilename", "[id].[hash].hot-update.js");
		this.set("output.hotUpdateMainFilename", "[hash].hot-update.json");
		this.set("output.crossOriginLoading", false);
		this.set("output.hashFunction", "md5");
		this.set("output.hashDigest", "hex");
		this.set("output.hashDigestLength", 20);
		this.set("output.sourcePrefix", "\t");
		this.set("output.devtoolLineToLine", false);
	
		this.set("node.console", false);
		this.set("node.process", true);
		this.set("node.global", true);
		// TODO: add this in next major version
		// this.set("node.Buffer", true);
		this.set("node.setImmediate", true);
		this.set("node.__filename", "mock");
		this.set("node.__dirname", "mock");
	
		this.set("resolve.fastUnsafe", []);
		this.set("resolveLoader.fastUnsafe", []);
	
		this.set("resolve.alias", {});
		this.set("resolveLoader.alias", {});
	
		this.set("optimize.occurenceOrderPreferEntry", true);
	}
	module.exports = WebpackOptionsDefaulter;
	
	WebpackOptionsDefaulter.prototype = Object.create(OptionsDefaulter.prototype);
	
	WebpackOptionsDefaulter.prototype.constructor = WebpackOptionsDefaulter;
	
	WebpackOptionsDefaulter.prototype.process = function(options) {
		OptionsDefaulter.prototype.process.call(this, options);
	
		if(options.resolve.packageAlias === undefined) {
			if(options.target === "web" || options.target === "webworker")
				options.resolve.packageAlias = "browser";
		}
	
		function defaultByTarget(value, web, webworker, node, nodeWebkit, def) {
			if(value !== undefined) return value;
			switch(options.target) {
				case "web":
					return web;
				case "webworker":
					return webworker;
				case "node":
				case "async-node":
					return node;
				case "node-webkit":
					return nodeWebkit;
				default:
					return def;
			}
		}
	
		options.resolve.modulesDirectories = defaultByTarget(options.resolve.modulesDirectories, ["web_modules", "node_modules"], ["webworker_modules", "web_modules", "node_modules"], ["node_modules"], ["node_modules", "web_modules"], ["node_modules"]);
	
		options.resolveLoader.modulesDirectories = defaultByTarget(options.resolveLoader.modulesDirectories, ["web_loaders", "web_modules", "node_loaders", "node_modules"], ["webworker_loaders", "web_loaders", "web_modules", "node_loaders", "node_modules"], ["node_loaders", "node_modules"], ["node_loaders", "web_loaders", "node_modules", "web_modules"], ["node_modules"]);
	
		options.resolve.packageMains = defaultByTarget(options.resolve.packageMains, ["webpack", "browser", "web", "browserify", ["jam", "main"], "main"], ["webpackWorker", "webworker", "webpack", "browser", "web", "browserify", ["jam", "main"], "main"], ["webpackNode", "node", "main"], ["webpackNodeWebkit", "webpackNode", "node", "main", "web"], ["main"]);
	
		options.resolve.packageAlias = defaultByTarget(options.resolve.packageAlias,
			"browser",
			"browser",
			false,
			"node-webkit",
			false);
	
		options.resolveLoader.packageMains = defaultByTarget(options.resolveLoader.packageMains, ["webpackLoader", "webLoader", "loader", "main"], ["webpackWorkerLoader", "webworkerLoader", "webLoader", "loader", "main"], ["webpackNodeLoader", "nodeLoader", "loader", "main"], ["webpackNodeWebkitLoader", "webpackNodeLoader", "nodeLoader", "loader", "webLoader", "main"], ["loader", "main"]);
	
		options.resolve.extensions = defaultByTarget(options.resolve.extensions, ["", ".webpack.js", ".web.js", ".js", ".json"], ["", ".webpack-worker.js", ".webworker.js", ".web.js", ".js", ".json"], ["", ".webpack-node.js", ".js", ".json", ".node"], ["", ".webpack-node-webkit.js", ".webpack-node.js", ".js", ".json", ".node", ".web.js"], ["", ".js", ".json"]);
	
		options.resolveLoader.extensions = defaultByTarget(options.resolveLoader.extensions, ["", ".webpack-loader.js", ".web-loader.js", ".loader.js", ".js"], ["", ".webpack-worker-loader.js", ".webpack-loader.js", ".webworker-loader.js", ".web-loader.js", ".loader.js", ".js"], ["", ".webpack-node-loader.js", ".loader.js", ".js"], ["", ".webpack-node-webkit-loader.js", ".webpack-node-loader.js", ".loader.js", ".web-loader.js", ".js"], ["", ".js"]);
	
		options.resolveLoader.moduleTemplates = defaultByTarget(options.resolveLoader.moduleTemplates, ["*-webpack-loader", "*-web-loader", "*-loader", "*"], ["*-webpack-worker-loader", "*-webworker-loader", "*-web-loader", "*-loader", "*"], ["*-webpack-node-loader", "*-node-loader", "*-loader", "*"], ["*-webpack-node-webkit-loader", "*-webpack-node-loader", "*-node-loader", "*-loader", "*-web-loader", "*"], ["*-loader", "*"]);
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ },
/* 339 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function OptionsDefaulter() {
		this.defaults = {};
		this.config = {};
	}
	module.exports = OptionsDefaulter;
	
	function getProperty(obj, name) {
		name = name.split(".");
		for(var i = 0; i < name.length - 1; i++) {
			obj = obj[name[i]];
			if(typeof obj != "object" || !obj) return;
		}
		return obj[name.pop()];
	}
	
	function setProperty(obj, name, value) {
		name = name.split(".");
		for(var i = 0; i < name.length - 1; i++) {
			if(typeof (obj[name[i]]) !== "object" || !obj[name[i]]) obj[name[i]] = {};
			obj = obj[name[i]];
		}
		obj[name.pop()] = value;
	}
	
	function hasProperty(obj, name, value) {
		name = name.split(".");
		for(var i = 0; i < name.length - 1; i++) {
			obj = obj[name[i]];
			if(typeof obj != "object" || !obj) return false;
		}
		return Object.prototype.hasOwnProperty.call(obj, name.pop());
	}
	
	OptionsDefaulter.prototype.process = function(options) {
		for(var name in this.defaults) {
			switch(this.config[name]) {
			case undefined:
				if(getProperty(options, name) === undefined)
					setProperty(options, name, this.defaults[name]);
				break;
			case "call":
				setProperty(options, name, this.defaults[name].call(this, getProperty(options, name)), options);
				break;
			case "append":
				var oldValue = getProperty(options, name);
				if(!Array.isArray(oldValue)) oldValue = [];
				this.defaults[name].forEach(function(item) {
					oldValue.push(item);
				});
				setProperty(options, name, oldValue);
				break;
			default:
				throw new Error("OptionsDefaulter cannot process " + this.config[name]);
			}
		}
	};
	
	OptionsDefaulter.prototype.set = function(name, config, def) {
		if(arguments.length === 3) {
			this.defaults[name] = def;
			this.config[name] = config;
		} else {
			this.defaults[name] = config;
			delete this.config[name];
		}
	}

/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var ConcatSource = __webpack_require__(341).ConcatSource;
	var async = __webpack_require__(10);
	var ExtractedModule = __webpack_require__(363);
	var Chunk = __webpack_require__(44);
	var OrderUndefinedError = __webpack_require__(364);
	var loaderUtils = __webpack_require__(365);
	
	var nextId = 0;
	
	function ExtractTextPluginCompilation() {
		this.modulesByIdentifier = {};
	}
	
	ExtractTextPlugin.prototype.mergeNonInitialChunks = function(chunk, intoChunk, checkedChunks) {
		if(!intoChunk) {
			checkedChunks = [];
			chunk.chunks.forEach(function(c) {
				if(c.initial) return;
				this.mergeNonInitialChunks(c, chunk, checkedChunks);
			}, this);
		} else if(checkedChunks.indexOf(chunk) < 0) {
			checkedChunks.push(chunk);
			chunk.modules.slice().forEach(function(module) {
				intoChunk.addModule(module);
				module.addChunk(intoChunk);
			});
			chunk.chunks.forEach(function(c) {
				if(c.initial) return;
				this.mergeNonInitialChunks(c, intoChunk, checkedChunks);
			}, this);
		}
	};
	
	ExtractTextPluginCompilation.prototype.addModule = function(identifier, originalModule, source, additionalInformation, sourceMap, prevModules) {
		var m;
		if(!this.modulesByIdentifier[identifier]) {
			m = this.modulesByIdentifier[identifier] = new ExtractedModule(identifier, originalModule, source, sourceMap, additionalInformation, prevModules);
		} else {
			m = this.modulesByIdentifier[identifier];
			m.addPrevModules(prevModules);
			if(originalModule.index2 < m.getOriginalModule().index2) {
				m.setOriginalModule(originalModule);
			}
		}
		return m;
	};
	
	ExtractTextPluginCompilation.prototype.addResultToChunk = function(identifier, result, originalModule, extractedChunk) {
		if(!Array.isArray(result)) {
			result = [[identifier, result]];
		}
		var counterMap = {};
		var prevModules = [];
		result.forEach(function(item) {
			var c = counterMap[item[0]];
			var module = this.addModule.call(this, item[0] + (c || ""), originalModule, item[1], item[2], item[3], prevModules.slice());
			extractedChunk.addModule(module);
			module.addChunk(extractedChunk);
			counterMap[item[0]] = (c || 0) + 1;
			prevModules.push(module);
		}, this);
	};
	
	ExtractTextPlugin.prototype.renderExtractedChunk = function(chunk) {
		var source = new ConcatSource();
		chunk.modules.forEach(function(module) {
			var moduleSource = module.source();
			source.add(this.applyAdditionalInformation(moduleSource, module.additionalInformation));
		}, this);
		return source;
	};
	
	function isInvalidOrder(a, b) {
		var bBeforeA = a.getPrevModules().indexOf(b) >= 0;
		var aBeforeB = b.getPrevModules().indexOf(a) >= 0;
		return aBeforeB && bBeforeA;
	}
	
	function getOrder(a, b) {
		var aOrder = a.getOrder();
		var bOrder = b.getOrder();
		if(aOrder < bOrder) return -1;
		if(aOrder > bOrder) return 1;
		var aIndex = a.getOriginalModule().index2;
		var bIndex = b.getOriginalModule().index2;
		if(aIndex < bIndex) return -1;
		if(aIndex > bIndex) return 1;
		var bBeforeA = a.getPrevModules().indexOf(b) >= 0;
		var aBeforeB = b.getPrevModules().indexOf(a) >= 0;
		if(aBeforeB && !bBeforeA) return -1;
		if(!aBeforeB && bBeforeA) return 1;
		var ai = a.identifier();
		var bi = b.identifier();
		if(ai < bi) return -1;
		if(ai > bi) return 1;
		return 0;
	}
	
	function ExtractTextPlugin(id, filename, options) {
		if(typeof filename !== "string") {
			options = filename;
			filename = id;
			id = ++nextId;
		}
		if(!options) options = {};
		this.filename = filename;
		this.options = options;
		this.id = id;
	}
	module.exports = ExtractTextPlugin;
	
	function mergeOptions(a, b) {
		if(!b) return a;
		Object.keys(b).forEach(function(key) {
			a[key] = b[key];
		});
		return a;
	}
	
	ExtractTextPlugin.loader = function(options) {
		return /*require.resolve*/(370) + (options ? "?" + JSON.stringify(options) : "");
	};
	
	ExtractTextPlugin.extract = function(before, loader, options) {
		if(typeof loader === "string" || Array.isArray(loader)) {
			if(typeof before === "string") {
				before = before.split("!");
			}
			return [
				ExtractTextPlugin.loader(mergeOptions({omit: before.length, extract: true, remove: true}, options))
			].concat(before, loader).join("!");
		} else {
			options = loader;
			loader = before;
			return [
				ExtractTextPlugin.loader(mergeOptions({remove: true}, options))
			].concat(loader).join("!");
		}
	};
	
	ExtractTextPlugin.prototype.applyAdditionalInformation = function(source, info) {
		if(info) {
			return new ConcatSource(
				"@media " + info[0] + " {",
				source,
				"}"
			);
		}
		return source;
	};
	
	ExtractTextPlugin.prototype.loader = function(options) {
		options = JSON.parse(JSON.stringify(options || {}));
		options.id = this.id;
		return ExtractTextPlugin.loader(options);
	};
	
	ExtractTextPlugin.prototype.extract = function(before, loader, options) {
		if(typeof loader === "string" || Array.isArray(loader)) {
			if(typeof before === "string") {
				before = before.split("!");
			}
			return [
				this.loader(mergeOptions({omit: before.length, extract: true, remove: true}, options))
			].concat(before, loader).join("!");
		} else {
			options = loader;
			loader = before;
			return [
				this.loader(mergeOptions({remove: true}, options))
			].concat(loader).join("!");
		}
	};
	
	ExtractTextPlugin.prototype.apply = function(compiler) {
		var options = this.options;
		compiler.plugin("this-compilation", function(compilation) {
			var extractCompilation = new ExtractTextPluginCompilation();
			compilation.plugin("normal-module-loader", function(loaderContext, module) {
				loaderContext[__dirname] = function(content, opt) {
					if(options.disable)
						return false;
					if(!Array.isArray(content) && content !== null)
						throw new Error("Exported value is not a string.");
					module.meta[__dirname] = {
						content: content,
						options: opt || {}
					};
					return options.allChunks || module.meta[__dirname + "/extract"]; // eslint-disable-line no-path-concat
				};
			});
			var filename = this.filename;
			var id = this.id;
			var extractedChunks, entryChunks, initialChunks;
			compilation.plugin("optimize", function() {
				entryChunks = compilation.chunks.filter(function(c) {
					return c.entry;
				});
				initialChunks = compilation.chunks.filter(function(c) {
					return c.initial;
				});
			});
			compilation.plugin("optimize-tree", function(chunks, modules, callback) {
				extractedChunks = chunks.map(function() {
					return new Chunk();
				});
				chunks.forEach(function(chunk, i) {
					var extractedChunk = extractedChunks[i];
					extractedChunk.index = i;
					extractedChunk.originalChunk = chunk;
					extractedChunk.name = chunk.name;
					extractedChunk.entry = chunk.entry;
					extractedChunk.initial = chunk.initial;
					chunk.chunks.forEach(function(c) {
						extractedChunk.addChunk(extractedChunks[chunks.indexOf(c)]);
					});
					chunk.parents.forEach(function(c) {
						extractedChunk.addParent(extractedChunks[chunks.indexOf(c)]);
					});
				});
				entryChunks.forEach(function(chunk) {
					var idx = chunks.indexOf(chunk);
					if(idx < 0) return;
					var extractedChunk = extractedChunks[idx];
					extractedChunk.entry = true;
				});
				initialChunks.forEach(function(chunk) {
					var idx = chunks.indexOf(chunk);
					if(idx < 0) return;
					var extractedChunk = extractedChunks[idx];
					extractedChunk.initial = true;
				});
				async.forEach(chunks, function(chunk, callback) {
					var extractedChunk = extractedChunks[chunks.indexOf(chunk)];
					var shouldExtract = !!(options.allChunks || chunk.initial);
					async.forEach(chunk.modules.slice(), function(module, callback) {
						var meta = module.meta && module.meta[__dirname];
						if(meta && (!meta.options.id || meta.options.id === id)) {
							var wasExtracted = Array.isArray(meta.content);
							if(shouldExtract !== wasExtracted) {
								module.meta[__dirname + "/extract"] = shouldExtract; // eslint-disable-line no-path-concat
								compilation.rebuildModule(module, function(err) {
									if(err) {
										compilation.errors.push(err);
										return callback();
									}
									meta = module.meta[__dirname];
									if(!Array.isArray(meta.content)) {
										err = new Error(module.identifier() + " doesn't export content");
										compilation.errors.push(err);
										return callback();
									}
									if(meta.content)
										extractCompilation.addResultToChunk(module.identifier(), meta.content, module, extractedChunk);
									callback();
								});
							} else {
								if(meta.content)
									extractCompilation.addResultToChunk(module.identifier(), meta.content, module, extractedChunk);
								callback();
							}
						} else callback();
					}, function(err) {
						if(err) return callback(err);
						callback();
					});
				}, function(err) {
					if(err) return callback(err);
					extractedChunks.forEach(function(extractedChunk) {
						if(extractedChunk.initial)
							this.mergeNonInitialChunks(extractedChunk);
					}, this);
					extractedChunks.forEach(function(extractedChunk) {
						if(!extractedChunk.initial) {
							extractedChunk.modules.forEach(function(module) {
								extractedChunk.removeModule(module);
							});
						}
					});
					compilation.applyPlugins("optimize-extracted-chunks", extractedChunks);
					callback();
				}.bind(this));
			}.bind(this));
			compilation.plugin("additional-assets", function(callback) {
				extractedChunks.forEach(function(extractedChunk) {
					if(extractedChunk.modules.length) {
						extractedChunk.modules.sort(function(a, b) {
							if(isInvalidOrder(a, b)) {
								compilation.errors.push(new OrderUndefinedError(a.getOriginalModule()));
								compilation.errors.push(new OrderUndefinedError(b.getOriginalModule()));
							}
							return getOrder(a, b);
						});
						var chunk = extractedChunk.originalChunk;
						var source = this.renderExtractedChunk(extractedChunk);
						var file = compilation.getPath(filename, {
							chunk: chunk
						}).replace(/\[(?:(\w+):)?contenthash(?::([a-z]+\d*))?(?::(\d+))?\]/ig, function() {
							return loaderUtils.getHashDigest(source.source(), arguments[1], arguments[2], parseInt(arguments[3], 10));
						});
						compilation.assets[file] = source;
						chunk.files.push(file);
					}
				}, this);
				callback();
			}.bind(this));
		}.bind(this));
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	exports.Source = __webpack_require__(342);
	
	exports.RawSource = __webpack_require__(354);
	exports.OriginalSource = __webpack_require__(355);
	exports.SourceMapSource = __webpack_require__(357);
	exports.LineToLineMappedSource = __webpack_require__(358);
	
	exports.CachedSource = __webpack_require__(359);
	exports.ConcatSource = __webpack_require__(360);
	exports.ReplaceSource = __webpack_require__(361);
	exports.PrefixSource = __webpack_require__(362);


/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var SourceNode = __webpack_require__(343).SourceNode;
	var SourceMapConsumer = __webpack_require__(343).SourceMapConsumer;
	
	function Source() {}
	
	module.exports = Source;
	
	Source.prototype.source = null;
	
	Source.prototype.size = function() {
		return this.source().length;
	};
	
	Source.prototype.map = function(options) {
		return null;
	};
	
	Source.prototype.sourceAndMap = function(options) {
		return {
			source: this.source(),
			map: this.map()
		};
	};
	
	Source.prototype.node = null;
	
	Source.prototype.listNode = null;
	
	Source.prototype.updateHash = function(hash) {
		var source = this.source();
		hash.update(source || "");
	};


/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2009-2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE.txt or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	exports.SourceMapGenerator = __webpack_require__(344).SourceMapGenerator;
	exports.SourceMapConsumer = __webpack_require__(350).SourceMapConsumer;
	exports.SourceNode = __webpack_require__(353).SourceNode;


/***/ },
/* 344 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	
	var base64VLQ = __webpack_require__(345);
	var util = __webpack_require__(347);
	var ArraySet = __webpack_require__(348).ArraySet;
	var MappingList = __webpack_require__(349).MappingList;
	
	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet();
	  this._names = new ArraySet();
	  this._mappings = new MappingList();
	  this._sourcesContents = null;
	}
	
	SourceMapGenerator.prototype._version = 3;
	
	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };
	
	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }
	
	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };
	
	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }
	
	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };
	
	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);
	
	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }
	
	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }
	
	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }
	
	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };
	
	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }
	
	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };
	
	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet();
	    var newNames = new ArraySet();
	
	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source)
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }
	
	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }
	
	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }
	
	    }, this);
	    this._sources = newSources;
	    this._names = newNames;
	
	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };
	
	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };
	
	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;
	
	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = ''
	
	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }
	
	      next += base64VLQ.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;
	
	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64VLQ.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;
	
	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64VLQ.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;
	
	        next += base64VLQ.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;
	
	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64VLQ.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }
	
	      result += next;
	    }
	
	    return result;
	  };
	
	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };
	
	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }
	
	    return map;
	  };
	
	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };
	
	exports.SourceMapGenerator = SourceMapGenerator;


/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
	
	var base64 = __webpack_require__(346);
	
	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011
	
	var VLQ_BASE_SHIFT = 5;
	
	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
	
	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;
	
	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;
	
	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}
	
	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}
	
	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	exports.encode = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;
	
	  var vlq = toVLQSigned(aValue);
	
	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);
	
	  return encoded;
	};
	
	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;
	
	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }
	
	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }
	
	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);
	
	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};


/***/ },
/* 346 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	
	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
	
	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	exports.encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};
	
	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	exports.decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'
	
	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'
	
	  var zero = 48;     // '0'
	  var nine = 57;     // '9'
	
	  var plus = 43;     // '+'
	  var slash = 47;    // '/'
	
	  var littleOffset = 26;
	  var numberOffset = 52;
	
	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }
	
	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }
	
	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }
	
	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }
	
	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }
	
	  // Invalid base64 digit.
	  return -1;
	};


/***/ },
/* 347 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	
	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;
	
	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;
	
	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;
	
	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;
	
	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);
	
	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');
	
	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }
	
	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;
	
	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }
	
	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }
	
	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }
	
	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }
	
	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
	
	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;
	
	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
	};
	
	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	
	  aRoot = aRoot.replace(/\/$/, '');
	
	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }
	
	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }
	
	    ++level;
	  }
	
	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;
	
	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());
	
	function identity (s) {
	  return s;
	}
	
	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }
	
	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;
	
	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }
	
	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;
	
	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }
	
	  var length = s.length;
	
	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }
	
	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }
	
	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = mappingA.source - mappingB.source;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }
	
	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  return mappingA.name - mappingB.name;
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;
	
	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }
	
	  cmp = mappingA.source - mappingB.source;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  return mappingA.name - mappingB.name;
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
	
	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }
	
	  if (aStr1 > aStr2) {
	    return 1;
	  }
	
	  return -1;
	}
	
	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }
	
	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;


/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	
	var util = __webpack_require__(347);
	var has = Object.prototype.hasOwnProperty;
	
	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = Object.create(null);
	}
	
	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};
	
	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return Object.getOwnPropertyNames(this._set).length;
	};
	
	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = util.toSetString(aStr);
	  var isDuplicate = has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    this._set[sStr] = idx;
	  }
	};
	
	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  var sStr = util.toSetString(aStr);
	  return has.call(this._set, sStr);
	};
	
	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  var sStr = util.toSetString(aStr);
	  if (has.call(this._set, sStr)) {
	    return this._set[sStr];
	  }
	  throw new Error('"' + aStr + '" is not in the set.');
	};
	
	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};
	
	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};
	
	exports.ArraySet = ArraySet;


/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	
	var util = __webpack_require__(347);
	
	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}
	
	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}
	
	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };
	
	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};
	
	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};
	
	exports.MappingList = MappingList;


/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	
	var util = __webpack_require__(347);
	var binarySearch = __webpack_require__(351);
	var ArraySet = __webpack_require__(348).ArraySet;
	var base64VLQ = __webpack_require__(345);
	var quickSort = __webpack_require__(352).quickSort;
	
	function SourceMapConsumer(aSourceMap) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	  }
	
	  return sourceMap.sections != null
	    ? new IndexedSourceMapConsumer(sourceMap)
	    : new BasicSourceMapConsumer(sourceMap);
	}
	
	SourceMapConsumer.fromSourceMap = function(aSourceMap) {
	  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
	}
	
	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	SourceMapConsumer.prototype._version = 3;
	
	// `__generatedMappings` and `__originalMappings` are arrays that hold the
	// parsed mapping coordinates from the source map's "mappings" attribute. They
	// are lazily instantiated, accessed via the `_generatedMappings` and
	// `_originalMappings` getters respectively, and we only parse the mappings
	// and create these arrays once queried for a source location. We jump through
	// these hoops because there can be many thousands of mappings, and parsing
	// them is expensive, so we only want to do it if we must.
	//
	// Each object in the arrays is of the form:
	//
	//     {
	//       generatedLine: The line number in the generated code,
	//       generatedColumn: The column number in the generated code,
	//       source: The path to the original source file that generated this
	//               chunk of code,
	//       originalLine: The line number in the original source that
	//                     corresponds to this chunk of generated code,
	//       originalColumn: The column number in the original source that
	//                       corresponds to this chunk of generated code,
	//       name: The name of the original symbol which generated this chunk of
	//             code.
	//     }
	//
	// All properties except for `generatedLine` and `generatedColumn` can be
	// `null`.
	//
	// `_generatedMappings` is ordered by the generated positions.
	//
	// `_originalMappings` is ordered by the original positions.
	
	SourceMapConsumer.prototype.__generatedMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	  get: function () {
	    if (!this.__generatedMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }
	
	    return this.__generatedMappings;
	  }
	});
	
	SourceMapConsumer.prototype.__originalMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	  get: function () {
	    if (!this.__originalMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }
	
	    return this.__originalMappings;
	  }
	});
	
	SourceMapConsumer.prototype._charIsMappingSeparator =
	  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
	    var c = aStr.charAt(index);
	    return c === ";" || c === ",";
	  };
	
	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	SourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    throw new Error("Subclasses must implement _parseMappings");
	  };
	
	SourceMapConsumer.GENERATED_ORDER = 1;
	SourceMapConsumer.ORIGINAL_ORDER = 2;
	
	SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
	SourceMapConsumer.LEAST_UPPER_BOUND = 2;
	
	/**
	 * Iterate over each mapping between an original source/line/column and a
	 * generated line/column in this source map.
	 *
	 * @param Function aCallback
	 *        The function that is called with each mapping.
	 * @param Object aContext
	 *        Optional. If specified, this object will be the value of `this` every
	 *        time that `aCallback` is called.
	 * @param aOrder
	 *        Either `SourceMapConsumer.GENERATED_ORDER` or
	 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
	 *        iterate over the mappings sorted by the generated file's line/column
	 *        order or the original's source/line/column order, respectively. Defaults to
	 *        `SourceMapConsumer.GENERATED_ORDER`.
	 */
	SourceMapConsumer.prototype.eachMapping =
	  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	    var context = aContext || null;
	    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
	
	    var mappings;
	    switch (order) {
	    case SourceMapConsumer.GENERATED_ORDER:
	      mappings = this._generatedMappings;
	      break;
	    case SourceMapConsumer.ORIGINAL_ORDER:
	      mappings = this._originalMappings;
	      break;
	    default:
	      throw new Error("Unknown order of iteration.");
	    }
	
	    var sourceRoot = this.sourceRoot;
	    mappings.map(function (mapping) {
	      var source = mapping.source === null ? null : this._sources.at(mapping.source);
	      if (source != null && sourceRoot != null) {
	        source = util.join(sourceRoot, source);
	      }
	      return {
	        source: source,
	        generatedLine: mapping.generatedLine,
	        generatedColumn: mapping.generatedColumn,
	        originalLine: mapping.originalLine,
	        originalColumn: mapping.originalColumn,
	        name: mapping.name === null ? null : this._names.at(mapping.name)
	      };
	    }, this).forEach(aCallback, context);
	  };
	
	/**
	 * Returns all generated line and column information for the original source,
	 * line, and column provided. If no column is provided, returns all mappings
	 * corresponding to a either the line we are searching for or the next
	 * closest line that has any mappings. Otherwise, returns all mappings
	 * corresponding to the given line and either the column we are searching for
	 * or the next closest column that has any offsets.
	 *
	 * The only argument is an object with the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.
	 *   - column: Optional. the column number in the original source.
	 *
	 * and an array of objects is returned, each with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.
	 *   - column: The column number in the generated source, or null.
	 */
	SourceMapConsumer.prototype.allGeneratedPositionsFor =
	  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
	    var line = util.getArg(aArgs, 'line');
	
	    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
	    // returns the index of the closest mapping less than the needle. By
	    // setting needle.originalColumn to 0, we thus find the last mapping for
	    // the given line, provided such a mapping exists.
	    var needle = {
	      source: util.getArg(aArgs, 'source'),
	      originalLine: line,
	      originalColumn: util.getArg(aArgs, 'column', 0)
	    };
	
	    if (this.sourceRoot != null) {
	      needle.source = util.relative(this.sourceRoot, needle.source);
	    }
	    if (!this._sources.has(needle.source)) {
	      return [];
	    }
	    needle.source = this._sources.indexOf(needle.source);
	
	    var mappings = [];
	
	    var index = this._findMapping(needle,
	                                  this._originalMappings,
	                                  "originalLine",
	                                  "originalColumn",
	                                  util.compareByOriginalPositions,
	                                  binarySearch.LEAST_UPPER_BOUND);
	    if (index >= 0) {
	      var mapping = this._originalMappings[index];
	
	      if (aArgs.column === undefined) {
	        var originalLine = mapping.originalLine;
	
	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we found. Since
	        // mappings are sorted, this is guaranteed to find all mappings for
	        // the line we found.
	        while (mapping && mapping.originalLine === originalLine) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });
	
	          mapping = this._originalMappings[++index];
	        }
	      } else {
	        var originalColumn = mapping.originalColumn;
	
	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we were searching for.
	        // Since mappings are sorted, this is guaranteed to find all mappings for
	        // the line we are searching for.
	        while (mapping &&
	               mapping.originalLine === line &&
	               mapping.originalColumn == originalColumn) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });
	
	          mapping = this._originalMappings[++index];
	        }
	      }
	    }
	
	    return mappings;
	  };
	
	exports.SourceMapConsumer = SourceMapConsumer;
	
	/**
	 * A BasicSourceMapConsumer instance represents a parsed source map which we can
	 * query for information about the original file positions by giving it a file
	 * position in the generated source.
	 *
	 * The only parameter is the raw source map (either as a JSON string, or
	 * already parsed to an object). According to the spec, source maps have the
	 * following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - sources: An array of URLs to the original source files.
	 *   - names: An array of identifiers which can be referrenced by individual mappings.
	 *   - sourceRoot: Optional. The URL root from which all sources are relative.
	 *   - sourcesContent: Optional. An array of contents of the original source files.
	 *   - mappings: A string of base64 VLQs which contain the actual mappings.
	 *   - file: Optional. The generated file this source map is associated with.
	 *
	 * Here is an example source map, taken from the source map spec[0]:
	 *
	 *     {
	 *       version : 3,
	 *       file: "out.js",
	 *       sourceRoot : "",
	 *       sources: ["foo.js", "bar.js"],
	 *       names: ["src", "maps", "are", "fun"],
	 *       mappings: "AA,AB;;ABCDE;"
	 *     }
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
	 */
	function BasicSourceMapConsumer(aSourceMap) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	  }
	
	  var version = util.getArg(sourceMap, 'version');
	  var sources = util.getArg(sourceMap, 'sources');
	  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
	  // requires the array) to play nice here.
	  var names = util.getArg(sourceMap, 'names', []);
	  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	  var mappings = util.getArg(sourceMap, 'mappings');
	  var file = util.getArg(sourceMap, 'file', null);
	
	  // Once again, Sass deviates from the spec and supplies the version as a
	  // string rather than a number, so we use loose equality checking here.
	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }
	
	  sources = sources
	    .map(String)
	    // Some source maps produce relative source paths like "./foo.js" instead of
	    // "foo.js".  Normalize these first so that future comparisons will succeed.
	    // See bugzil.la/1090768.
	    .map(util.normalize)
	    // Always ensure that absolute sources are internally stored relative to
	    // the source root, if the source root is absolute. Not doing this would
	    // be particularly problematic when the source root is a prefix of the
	    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
	    .map(function (source) {
	      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
	        ? util.relative(sourceRoot, source)
	        : source;
	    });
	
	  // Pass `true` below to allow duplicate names and sources. While source maps
	  // are intended to be compressed and deduplicated, the TypeScript compiler
	  // sometimes generates source maps with duplicates in them. See Github issue
	  // #72 and bugzil.la/889492.
	  this._names = ArraySet.fromArray(names.map(String), true);
	  this._sources = ArraySet.fromArray(sources, true);
	
	  this.sourceRoot = sourceRoot;
	  this.sourcesContent = sourcesContent;
	  this._mappings = mappings;
	  this.file = file;
	}
	
	BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
	
	/**
	 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
	 *
	 * @param SourceMapGenerator aSourceMap
	 *        The source map that will be consumed.
	 * @returns BasicSourceMapConsumer
	 */
	BasicSourceMapConsumer.fromSourceMap =
	  function SourceMapConsumer_fromSourceMap(aSourceMap) {
	    var smc = Object.create(BasicSourceMapConsumer.prototype);
	
	    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
	    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
	    smc.sourceRoot = aSourceMap._sourceRoot;
	    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
	                                                            smc.sourceRoot);
	    smc.file = aSourceMap._file;
	
	    // Because we are modifying the entries (by converting string sources and
	    // names to indices into the sources and names ArraySets), we have to make
	    // a copy of the entry or else bad things happen. Shared mutable state
	    // strikes again! See github issue #191.
	
	    var generatedMappings = aSourceMap._mappings.toArray().slice();
	    var destGeneratedMappings = smc.__generatedMappings = [];
	    var destOriginalMappings = smc.__originalMappings = [];
	
	    for (var i = 0, length = generatedMappings.length; i < length; i++) {
	      var srcMapping = generatedMappings[i];
	      var destMapping = new Mapping;
	      destMapping.generatedLine = srcMapping.generatedLine;
	      destMapping.generatedColumn = srcMapping.generatedColumn;
	
	      if (srcMapping.source) {
	        destMapping.source = sources.indexOf(srcMapping.source);
	        destMapping.originalLine = srcMapping.originalLine;
	        destMapping.originalColumn = srcMapping.originalColumn;
	
	        if (srcMapping.name) {
	          destMapping.name = names.indexOf(srcMapping.name);
	        }
	
	        destOriginalMappings.push(destMapping);
	      }
	
	      destGeneratedMappings.push(destMapping);
	    }
	
	    quickSort(smc.__originalMappings, util.compareByOriginalPositions);
	
	    return smc;
	  };
	
	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	BasicSourceMapConsumer.prototype._version = 3;
	
	/**
	 * The list of original sources.
	 */
	Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    return this._sources.toArray().map(function (s) {
	      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
	    }, this);
	  }
	});
	
	/**
	 * Provide the JIT with a nice shape / hidden class.
	 */
	function Mapping() {
	  this.generatedLine = 0;
	  this.generatedColumn = 0;
	  this.source = null;
	  this.originalLine = null;
	  this.originalColumn = null;
	  this.name = null;
	}
	
	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	BasicSourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    var generatedLine = 1;
	    var previousGeneratedColumn = 0;
	    var previousOriginalLine = 0;
	    var previousOriginalColumn = 0;
	    var previousSource = 0;
	    var previousName = 0;
	    var length = aStr.length;
	    var index = 0;
	    var cachedSegments = {};
	    var temp = {};
	    var originalMappings = [];
	    var generatedMappings = [];
	    var mapping, str, segment, end, value;
	
	    while (index < length) {
	      if (aStr.charAt(index) === ';') {
	        generatedLine++;
	        index++;
	        previousGeneratedColumn = 0;
	      }
	      else if (aStr.charAt(index) === ',') {
	        index++;
	      }
	      else {
	        mapping = new Mapping();
	        mapping.generatedLine = generatedLine;
	
	        // Because each offset is encoded relative to the previous one,
	        // many segments often have the same encoding. We can exploit this
	        // fact by caching the parsed variable length fields of each segment,
	        // allowing us to avoid a second parse if we encounter the same
	        // segment again.
	        for (end = index; end < length; end++) {
	          if (this._charIsMappingSeparator(aStr, end)) {
	            break;
	          }
	        }
	        str = aStr.slice(index, end);
	
	        segment = cachedSegments[str];
	        if (segment) {
	          index += str.length;
	        } else {
	          segment = [];
	          while (index < end) {
	            base64VLQ.decode(aStr, index, temp);
	            value = temp.value;
	            index = temp.rest;
	            segment.push(value);
	          }
	
	          if (segment.length === 2) {
	            throw new Error('Found a source, but no line and column');
	          }
	
	          if (segment.length === 3) {
	            throw new Error('Found a source and line, but no column');
	          }
	
	          cachedSegments[str] = segment;
	        }
	
	        // Generated column.
	        mapping.generatedColumn = previousGeneratedColumn + segment[0];
	        previousGeneratedColumn = mapping.generatedColumn;
	
	        if (segment.length > 1) {
	          // Original source.
	          mapping.source = previousSource + segment[1];
	          previousSource += segment[1];
	
	          // Original line.
	          mapping.originalLine = previousOriginalLine + segment[2];
	          previousOriginalLine = mapping.originalLine;
	          // Lines are stored 0-based
	          mapping.originalLine += 1;
	
	          // Original column.
	          mapping.originalColumn = previousOriginalColumn + segment[3];
	          previousOriginalColumn = mapping.originalColumn;
	
	          if (segment.length > 4) {
	            // Original name.
	            mapping.name = previousName + segment[4];
	            previousName += segment[4];
	          }
	        }
	
	        generatedMappings.push(mapping);
	        if (typeof mapping.originalLine === 'number') {
	          originalMappings.push(mapping);
	        }
	      }
	    }
	
	    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
	    this.__generatedMappings = generatedMappings;
	
	    quickSort(originalMappings, util.compareByOriginalPositions);
	    this.__originalMappings = originalMappings;
	  };
	
	/**
	 * Find the mapping that best matches the hypothetical "needle" mapping that
	 * we are searching for in the given "haystack" of mappings.
	 */
	BasicSourceMapConsumer.prototype._findMapping =
	  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
	                                         aColumnName, aComparator, aBias) {
	    // To return the position we are searching for, we must first find the
	    // mapping for the given position and then return the opposite position it
	    // points to. Because the mappings are sorted, we can use binary search to
	    // find the best mapping.
	
	    if (aNeedle[aLineName] <= 0) {
	      throw new TypeError('Line must be greater than or equal to 1, got '
	                          + aNeedle[aLineName]);
	    }
	    if (aNeedle[aColumnName] < 0) {
	      throw new TypeError('Column must be greater than or equal to 0, got '
	                          + aNeedle[aColumnName]);
	    }
	
	    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	  };
	
	/**
	 * Compute the last column for each generated mapping. The last column is
	 * inclusive.
	 */
	BasicSourceMapConsumer.prototype.computeColumnSpans =
	  function SourceMapConsumer_computeColumnSpans() {
	    for (var index = 0; index < this._generatedMappings.length; ++index) {
	      var mapping = this._generatedMappings[index];
	
	      // Mappings do not contain a field for the last generated columnt. We
	      // can come up with an optimistic estimate, however, by assuming that
	      // mappings are contiguous (i.e. given two consecutive mappings, the
	      // first mapping ends where the second one starts).
	      if (index + 1 < this._generatedMappings.length) {
	        var nextMapping = this._generatedMappings[index + 1];
	
	        if (mapping.generatedLine === nextMapping.generatedLine) {
	          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
	          continue;
	        }
	      }
	
	      // The last mapping for each line spans the entire line.
	      mapping.lastGeneratedColumn = Infinity;
	    }
	  };
	
	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.
	 *   - column: The column number in the generated source.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.
	 *   - column: The column number in the original source, or null.
	 *   - name: The original identifier, or null.
	 */
	BasicSourceMapConsumer.prototype.originalPositionFor =
	  function SourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };
	
	    var index = this._findMapping(
	      needle,
	      this._generatedMappings,
	      "generatedLine",
	      "generatedColumn",
	      util.compareByGeneratedPositionsDeflated,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );
	
	    if (index >= 0) {
	      var mapping = this._generatedMappings[index];
	
	      if (mapping.generatedLine === needle.generatedLine) {
	        var source = util.getArg(mapping, 'source', null);
	        if (source !== null) {
	          source = this._sources.at(source);
	          if (this.sourceRoot != null) {
	            source = util.join(this.sourceRoot, source);
	          }
	        }
	        var name = util.getArg(mapping, 'name', null);
	        if (name !== null) {
	          name = this._names.at(name);
	        }
	        return {
	          source: source,
	          line: util.getArg(mapping, 'originalLine', null),
	          column: util.getArg(mapping, 'originalColumn', null),
	          name: name
	        };
	      }
	    }
	
	    return {
	      source: null,
	      line: null,
	      column: null,
	      name: null
	    };
	  };
	
	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function BasicSourceMapConsumer_hasContentsOfAllSources() {
	    if (!this.sourcesContent) {
	      return false;
	    }
	    return this.sourcesContent.length >= this._sources.size() &&
	      !this.sourcesContent.some(function (sc) { return sc == null; });
	  };
	
	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	BasicSourceMapConsumer.prototype.sourceContentFor =
	  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    if (!this.sourcesContent) {
	      return null;
	    }
	
	    if (this.sourceRoot != null) {
	      aSource = util.relative(this.sourceRoot, aSource);
	    }
	
	    if (this._sources.has(aSource)) {
	      return this.sourcesContent[this._sources.indexOf(aSource)];
	    }
	
	    var url;
	    if (this.sourceRoot != null
	        && (url = util.urlParse(this.sourceRoot))) {
	      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
	      // many users. We can help them out when they expect file:// URIs to
	      // behave like it would if they were running a local HTTP server. See
	      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
	      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
	      if (url.scheme == "file"
	          && this._sources.has(fileUriAbsPath)) {
	        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
	      }
	
	      if ((!url.path || url.path == "/")
	          && this._sources.has("/" + aSource)) {
	        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
	      }
	    }
	
	    // This function is used recursively from
	    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
	    // don't want to throw if we can't find the source - we just want to
	    // return null, so we provide a flag to exit gracefully.
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    }
	  };
	
	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.
	 *   - column: The column number in the original source.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.
	 *   - column: The column number in the generated source, or null.
	 */
	BasicSourceMapConsumer.prototype.generatedPositionFor =
	  function SourceMapConsumer_generatedPositionFor(aArgs) {
	    var source = util.getArg(aArgs, 'source');
	    if (this.sourceRoot != null) {
	      source = util.relative(this.sourceRoot, source);
	    }
	    if (!this._sources.has(source)) {
	      return {
	        line: null,
	        column: null,
	        lastColumn: null
	      };
	    }
	    source = this._sources.indexOf(source);
	
	    var needle = {
	      source: source,
	      originalLine: util.getArg(aArgs, 'line'),
	      originalColumn: util.getArg(aArgs, 'column')
	    };
	
	    var index = this._findMapping(
	      needle,
	      this._originalMappings,
	      "originalLine",
	      "originalColumn",
	      util.compareByOriginalPositions,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );
	
	    if (index >= 0) {
	      var mapping = this._originalMappings[index];
	
	      if (mapping.source === needle.source) {
	        return {
	          line: util.getArg(mapping, 'generatedLine', null),
	          column: util.getArg(mapping, 'generatedColumn', null),
	          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	        };
	      }
	    }
	
	    return {
	      line: null,
	      column: null,
	      lastColumn: null
	    };
	  };
	
	exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
	
	/**
	 * An IndexedSourceMapConsumer instance represents a parsed source map which
	 * we can query for information. It differs from BasicSourceMapConsumer in
	 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
	 * input.
	 *
	 * The only parameter is a raw source map (either as a JSON string, or already
	 * parsed to an object). According to the spec for indexed source maps, they
	 * have the following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - file: Optional. The generated file this source map is associated with.
	 *   - sections: A list of section definitions.
	 *
	 * Each value under the "sections" field has two fields:
	 *   - offset: The offset into the original specified at which this section
	 *       begins to apply, defined as an object with a "line" and "column"
	 *       field.
	 *   - map: A source map definition. This source map could also be indexed,
	 *       but doesn't have to be.
	 *
	 * Instead of the "map" field, it's also possible to have a "url" field
	 * specifying a URL to retrieve a source map from, but that's currently
	 * unsupported.
	 *
	 * Here's an example source map, taken from the source map spec[0], but
	 * modified to omit a section which uses the "url" field.
	 *
	 *  {
	 *    version : 3,
	 *    file: "app.js",
	 *    sections: [{
	 *      offset: {line:100, column:10},
	 *      map: {
	 *        version : 3,
	 *        file: "section.js",
	 *        sources: ["foo.js", "bar.js"],
	 *        names: ["src", "maps", "are", "fun"],
	 *        mappings: "AAAA,E;;ABCDE;"
	 *      }
	 *    }],
	 *  }
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
	 */
	function IndexedSourceMapConsumer(aSourceMap) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	  }
	
	  var version = util.getArg(sourceMap, 'version');
	  var sections = util.getArg(sourceMap, 'sections');
	
	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }
	
	  this._sources = new ArraySet();
	  this._names = new ArraySet();
	
	  var lastOffset = {
	    line: -1,
	    column: 0
	  };
	  this._sections = sections.map(function (s) {
	    if (s.url) {
	      // The url field will require support for asynchronicity.
	      // See https://github.com/mozilla/source-map/issues/16
	      throw new Error('Support for url field in sections not implemented.');
	    }
	    var offset = util.getArg(s, 'offset');
	    var offsetLine = util.getArg(offset, 'line');
	    var offsetColumn = util.getArg(offset, 'column');
	
	    if (offsetLine < lastOffset.line ||
	        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
	      throw new Error('Section offsets must be ordered and non-overlapping.');
	    }
	    lastOffset = offset;
	
	    return {
	      generatedOffset: {
	        // The offset fields are 0-based, but we use 1-based indices when
	        // encoding/decoding from VLQ.
	        generatedLine: offsetLine + 1,
	        generatedColumn: offsetColumn + 1
	      },
	      consumer: new SourceMapConsumer(util.getArg(s, 'map'))
	    }
	  });
	}
	
	IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
	
	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	IndexedSourceMapConsumer.prototype._version = 3;
	
	/**
	 * The list of original sources.
	 */
	Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    var sources = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
	        sources.push(this._sections[i].consumer.sources[j]);
	      }
	    }
	    return sources;
	  }
	});
	
	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.
	 *   - column: The column number in the generated source.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.
	 *   - column: The column number in the original source, or null.
	 *   - name: The original identifier, or null.
	 */
	IndexedSourceMapConsumer.prototype.originalPositionFor =
	  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };
	
	    // Find the section containing the generated position we're trying to map
	    // to an original position.
	    var sectionIndex = binarySearch.search(needle, this._sections,
	      function(needle, section) {
	        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
	        if (cmp) {
	          return cmp;
	        }
	
	        return (needle.generatedColumn -
	                section.generatedOffset.generatedColumn);
	      });
	    var section = this._sections[sectionIndex];
	
	    if (!section) {
	      return {
	        source: null,
	        line: null,
	        column: null,
	        name: null
	      };
	    }
	
	    return section.consumer.originalPositionFor({
	      line: needle.generatedLine -
	        (section.generatedOffset.generatedLine - 1),
	      column: needle.generatedColumn -
	        (section.generatedOffset.generatedLine === needle.generatedLine
	         ? section.generatedOffset.generatedColumn - 1
	         : 0),
	      bias: aArgs.bias
	    });
	  };
	
	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
	    return this._sections.every(function (s) {
	      return s.consumer.hasContentsOfAllSources();
	    });
	  };
	
	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	IndexedSourceMapConsumer.prototype.sourceContentFor =
	  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	
	      var content = section.consumer.sourceContentFor(aSource, true);
	      if (content) {
	        return content;
	      }
	    }
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    }
	  };
	
	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.
	 *   - column: The column number in the original source.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.
	 *   - column: The column number in the generated source, or null.
	 */
	IndexedSourceMapConsumer.prototype.generatedPositionFor =
	  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	
	      // Only consider this section if the requested source is in the list of
	      // sources of the consumer.
	      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
	        continue;
	      }
	      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
	      if (generatedPosition) {
	        var ret = {
	          line: generatedPosition.line +
	            (section.generatedOffset.generatedLine - 1),
	          column: generatedPosition.column +
	            (section.generatedOffset.generatedLine === generatedPosition.line
	             ? section.generatedOffset.generatedColumn - 1
	             : 0)
	        };
	        return ret;
	      }
	    }
	
	    return {
	      line: null,
	      column: null
	    };
	  };
	
	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	IndexedSourceMapConsumer.prototype._parseMappings =
	  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    this.__generatedMappings = [];
	    this.__originalMappings = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	      var sectionMappings = section.consumer._generatedMappings;
	      for (var j = 0; j < sectionMappings.length; j++) {
	        var mapping = sectionMappings[j];
	
	        var source = section.consumer._sources.at(mapping.source);
	        if (section.consumer.sourceRoot !== null) {
	          source = util.join(section.consumer.sourceRoot, source);
	        }
	        this._sources.add(source);
	        source = this._sources.indexOf(source);
	
	        var name = section.consumer._names.at(mapping.name);
	        this._names.add(name);
	        name = this._names.indexOf(name);
	
	        // The mappings coming from the consumer for the section have
	        // generated positions relative to the start of the section, so we
	        // need to offset them to be relative to the start of the concatenated
	        // generated file.
	        var adjustedMapping = {
	          source: source,
	          generatedLine: mapping.generatedLine +
	            (section.generatedOffset.generatedLine - 1),
	          generatedColumn: mapping.generatedColumn +
	            (section.generatedOffset.generatedLine === mapping.generatedLine
	            ? section.generatedOffset.generatedColumn - 1
	            : 0),
	          originalLine: mapping.originalLine,
	          originalColumn: mapping.originalColumn,
	          name: name
	        };
	
	        this.__generatedMappings.push(adjustedMapping);
	        if (typeof adjustedMapping.originalLine === 'number') {
	          this.__originalMappings.push(adjustedMapping);
	        }
	      }
	    }
	
	    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
	    quickSort(this.__originalMappings, util.compareByOriginalPositions);
	  };
	
	exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;


/***/ },
/* 351 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	
	exports.GREATEST_LOWER_BOUND = 1;
	exports.LEAST_UPPER_BOUND = 2;
	
	/**
	 * Recursive implementation of binary search.
	 *
	 * @param aLow Indices here and lower do not contain the needle.
	 * @param aHigh Indices here and higher do not contain the needle.
	 * @param aNeedle The element being searched for.
	 * @param aHaystack The non-empty array being searched.
	 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
	 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 */
	function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
	  // This function terminates when one of the following is true:
	  //
	  //   1. We find the exact element we are looking for.
	  //
	  //   2. We did not find the exact element, but we can return the index of
	  //      the next-closest element.
	  //
	  //   3. We did not find the exact element, and there is no next-closest
	  //      element than the one we are searching for, so we return -1.
	  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
	  var cmp = aCompare(aNeedle, aHaystack[mid], true);
	  if (cmp === 0) {
	    // Found the element we are looking for.
	    return mid;
	  }
	  else if (cmp > 0) {
	    // Our needle is greater than aHaystack[mid].
	    if (aHigh - mid > 1) {
	      // The element is in the upper half.
	      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
	    }
	
	    // The exact needle element was not found in this haystack. Determine if
	    // we are in termination case (3) or (2) and return the appropriate thing.
	    if (aBias == exports.LEAST_UPPER_BOUND) {
	      return aHigh < aHaystack.length ? aHigh : -1;
	    } else {
	      return mid;
	    }
	  }
	  else {
	    // Our needle is less than aHaystack[mid].
	    if (mid - aLow > 1) {
	      // The element is in the lower half.
	      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
	    }
	
	    // we are in termination case (3) or (2) and return the appropriate thing.
	    if (aBias == exports.LEAST_UPPER_BOUND) {
	      return mid;
	    } else {
	      return aLow < 0 ? -1 : aLow;
	    }
	  }
	}
	
	/**
	 * This is an implementation of binary search which will always try and return
	 * the index of the closest element if there is no exact hit. This is because
	 * mappings between original and generated line/col pairs are single points,
	 * and there is an implicit region between each of them, so a miss just means
	 * that you aren't on the very start of a region.
	 *
	 * @param aNeedle The element you are looking for.
	 * @param aHaystack The array that is being searched.
	 * @param aCompare A function which takes the needle and an element in the
	 *     array and returns -1, 0, or 1 depending on whether the needle is less
	 *     than, equal to, or greater than the element, respectively.
	 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
	 */
	exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
	  if (aHaystack.length === 0) {
	    return -1;
	  }
	
	  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
	                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
	  if (index < 0) {
	    return -1;
	  }
	
	  // We have found either the exact element, or the next-closest element than
	  // the one we are searching for. However, there may be more than one such
	  // element. Make sure we always return the smallest of these.
	  while (index - 1 >= 0) {
	    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
	      break;
	    }
	    --index;
	  }
	
	  return index;
	};


/***/ },
/* 352 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	
	// It turns out that some (most?) JavaScript engines don't self-host
	// `Array.prototype.sort`. This makes sense because C++ will likely remain
	// faster than JS when doing raw CPU-intensive sorting. However, when using a
	// custom comparator function, calling back and forth between the VM's C++ and
	// JIT'd JS is rather slow *and* loses JIT type information, resulting in
	// worse generated code for the comparator function than would be optimal. In
	// fact, when sorting with a comparator, these costs outweigh the benefits of
	// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
	// a ~3500ms mean speed-up in `bench/bench.html`.
	
	/**
	 * Swap the elements indexed by `x` and `y` in the array `ary`.
	 *
	 * @param {Array} ary
	 *        The array.
	 * @param {Number} x
	 *        The index of the first item.
	 * @param {Number} y
	 *        The index of the second item.
	 */
	function swap(ary, x, y) {
	  var temp = ary[x];
	  ary[x] = ary[y];
	  ary[y] = temp;
	}
	
	/**
	 * Returns a random integer within the range `low .. high` inclusive.
	 *
	 * @param {Number} low
	 *        The lower bound on the range.
	 * @param {Number} high
	 *        The upper bound on the range.
	 */
	function randomIntInRange(low, high) {
	  return Math.round(low + (Math.random() * (high - low)));
	}
	
	/**
	 * The Quick Sort algorithm.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 * @param {Number} p
	 *        Start index of the array
	 * @param {Number} r
	 *        End index of the array
	 */
	function doQuickSort(ary, comparator, p, r) {
	  // If our lower bound is less than our upper bound, we (1) partition the
	  // array into two pieces and (2) recurse on each half. If it is not, this is
	  // the empty array and our base case.
	
	  if (p < r) {
	    // (1) Partitioning.
	    //
	    // The partitioning chooses a pivot between `p` and `r` and moves all
	    // elements that are less than or equal to the pivot to the before it, and
	    // all the elements that are greater than it after it. The effect is that
	    // once partition is done, the pivot is in the exact place it will be when
	    // the array is put in sorted order, and it will not need to be moved
	    // again. This runs in O(n) time.
	
	    // Always choose a random pivot so that an input array which is reverse
	    // sorted does not cause O(n^2) running time.
	    var pivotIndex = randomIntInRange(p, r);
	    var i = p - 1;
	
	    swap(ary, pivotIndex, r);
	    var pivot = ary[r];
	
	    // Immediately after `j` is incremented in this loop, the following hold
	    // true:
	    //
	    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
	    //
	    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
	    for (var j = p; j < r; j++) {
	      if (comparator(ary[j], pivot) <= 0) {
	        i += 1;
	        swap(ary, i, j);
	      }
	    }
	
	    swap(ary, i + 1, j);
	    var q = i + 1;
	
	    // (2) Recurse on each half.
	
	    doQuickSort(ary, comparator, p, q - 1);
	    doQuickSort(ary, comparator, q + 1, r);
	  }
	}
	
	/**
	 * Sort the given array in-place with the given comparator function.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 */
	exports.quickSort = function (ary, comparator) {
	  doQuickSort(ary, comparator, 0, ary.length - 1);
	};


/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	
	var SourceMapGenerator = __webpack_require__(344).SourceMapGenerator;
	var util = __webpack_require__(347);
	
	// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
	// operating systems these days (capturing the result).
	var REGEX_NEWLINE = /(\r?\n)/;
	
	// Newline character code for charCodeAt() comparisons
	var NEWLINE_CODE = 10;
	
	// Private symbol for identifying `SourceNode`s when multiple versions of
	// the source-map library are loaded. This MUST NOT CHANGE across
	// versions!
	var isSourceNode = "$$$isSourceNode$$$";
	
	/**
	 * SourceNodes provide a way to abstract over interpolating/concatenating
	 * snippets of generated JavaScript source code while maintaining the line and
	 * column information associated with the original source code.
	 *
	 * @param aLine The original line number.
	 * @param aColumn The original column number.
	 * @param aSource The original source's filename.
	 * @param aChunks Optional. An array of strings which are snippets of
	 *        generated JS, or other SourceNodes.
	 * @param aName The original identifier.
	 */
	function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
	  this.children = [];
	  this.sourceContents = {};
	  this.line = aLine == null ? null : aLine;
	  this.column = aColumn == null ? null : aColumn;
	  this.source = aSource == null ? null : aSource;
	  this.name = aName == null ? null : aName;
	  this[isSourceNode] = true;
	  if (aChunks != null) this.add(aChunks);
	}
	
	/**
	 * Creates a SourceNode from generated code and a SourceMapConsumer.
	 *
	 * @param aGeneratedCode The generated code
	 * @param aSourceMapConsumer The SourceMap for the generated code
	 * @param aRelativePath Optional. The path that relative sources in the
	 *        SourceMapConsumer should be relative to.
	 */
	SourceNode.fromStringWithSourceMap =
	  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
	    // The SourceNode we want to fill with the generated code
	    // and the SourceMap
	    var node = new SourceNode();
	
	    // All even indices of this array are one line of the generated code,
	    // while all odd indices are the newlines between two adjacent lines
	    // (since `REGEX_NEWLINE` captures its match).
	    // Processed fragments are removed from this array, by calling `shiftNextLine`.
	    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
	    var shiftNextLine = function() {
	      var lineContents = remainingLines.shift();
	      // The last line of a file might not have a newline.
	      var newLine = remainingLines.shift() || "";
	      return lineContents + newLine;
	    };
	
	    // We need to remember the position of "remainingLines"
	    var lastGeneratedLine = 1, lastGeneratedColumn = 0;
	
	    // The generate SourceNodes we need a code range.
	    // To extract it current and last mapping is used.
	    // Here we store the last mapping.
	    var lastMapping = null;
	
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      if (lastMapping !== null) {
	        // We add the code from "lastMapping" to "mapping":
	        // First check if there is a new line in between.
	        if (lastGeneratedLine < mapping.generatedLine) {
	          // Associate first line with "lastMapping"
	          addMappingWithCode(lastMapping, shiftNextLine());
	          lastGeneratedLine++;
	          lastGeneratedColumn = 0;
	          // The remaining code is added without mapping
	        } else {
	          // There is no new line in between.
	          // Associate the code between "lastGeneratedColumn" and
	          // "mapping.generatedColumn" with "lastMapping"
	          var nextLine = remainingLines[0];
	          var code = nextLine.substr(0, mapping.generatedColumn -
	                                        lastGeneratedColumn);
	          remainingLines[0] = nextLine.substr(mapping.generatedColumn -
	                                              lastGeneratedColumn);
	          lastGeneratedColumn = mapping.generatedColumn;
	          addMappingWithCode(lastMapping, code);
	          // No more remaining code, continue
	          lastMapping = mapping;
	          return;
	        }
	      }
	      // We add the generated code until the first mapping
	      // to the SourceNode without any mapping.
	      // Each line is added as separate string.
	      while (lastGeneratedLine < mapping.generatedLine) {
	        node.add(shiftNextLine());
	        lastGeneratedLine++;
	      }
	      if (lastGeneratedColumn < mapping.generatedColumn) {
	        var nextLine = remainingLines[0];
	        node.add(nextLine.substr(0, mapping.generatedColumn));
	        remainingLines[0] = nextLine.substr(mapping.generatedColumn);
	        lastGeneratedColumn = mapping.generatedColumn;
	      }
	      lastMapping = mapping;
	    }, this);
	    // We have processed all mappings.
	    if (remainingLines.length > 0) {
	      if (lastMapping) {
	        // Associate the remaining code in the current line with "lastMapping"
	        addMappingWithCode(lastMapping, shiftNextLine());
	      }
	      // and add the remaining lines without any mapping
	      node.add(remainingLines.join(""));
	    }
	
	    // Copy sourcesContent into SourceNode
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aRelativePath != null) {
	          sourceFile = util.join(aRelativePath, sourceFile);
	        }
	        node.setSourceContent(sourceFile, content);
	      }
	    });
	
	    return node;
	
	    function addMappingWithCode(mapping, code) {
	      if (mapping === null || mapping.source === undefined) {
	        node.add(code);
	      } else {
	        var source = aRelativePath
	          ? util.join(aRelativePath, mapping.source)
	          : mapping.source;
	        node.add(new SourceNode(mapping.originalLine,
	                                mapping.originalColumn,
	                                source,
	                                code,
	                                mapping.name));
	      }
	    }
	  };
	
	/**
	 * Add a chunk of generated JS to this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.add = function SourceNode_add(aChunk) {
	  if (Array.isArray(aChunk)) {
	    aChunk.forEach(function (chunk) {
	      this.add(chunk);
	    }, this);
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    if (aChunk) {
	      this.children.push(aChunk);
	    }
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};
	
	/**
	 * Add a chunk of generated JS to the beginning of this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
	  if (Array.isArray(aChunk)) {
	    for (var i = aChunk.length-1; i >= 0; i--) {
	      this.prepend(aChunk[i]);
	    }
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    this.children.unshift(aChunk);
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};
	
	/**
	 * Walk over the tree of JS snippets in this node and its children. The
	 * walking function is called once for each snippet of JS and is passed that
	 * snippet and the its original associated source's line/column location.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walk = function SourceNode_walk(aFn) {
	  var chunk;
	  for (var i = 0, len = this.children.length; i < len; i++) {
	    chunk = this.children[i];
	    if (chunk[isSourceNode]) {
	      chunk.walk(aFn);
	    }
	    else {
	      if (chunk !== '') {
	        aFn(chunk, { source: this.source,
	                     line: this.line,
	                     column: this.column,
	                     name: this.name });
	      }
	    }
	  }
	};
	
	/**
	 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
	 * each of `this.children`.
	 *
	 * @param aSep The separator.
	 */
	SourceNode.prototype.join = function SourceNode_join(aSep) {
	  var newChildren;
	  var i;
	  var len = this.children.length;
	  if (len > 0) {
	    newChildren = [];
	    for (i = 0; i < len-1; i++) {
	      newChildren.push(this.children[i]);
	      newChildren.push(aSep);
	    }
	    newChildren.push(this.children[i]);
	    this.children = newChildren;
	  }
	  return this;
	};
	
	/**
	 * Call String.prototype.replace on the very right-most source snippet. Useful
	 * for trimming whitespace from the end of a source node, etc.
	 *
	 * @param aPattern The pattern to replace.
	 * @param aReplacement The thing to replace the pattern with.
	 */
	SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
	  var lastChild = this.children[this.children.length - 1];
	  if (lastChild[isSourceNode]) {
	    lastChild.replaceRight(aPattern, aReplacement);
	  }
	  else if (typeof lastChild === 'string') {
	    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
	  }
	  else {
	    this.children.push(''.replace(aPattern, aReplacement));
	  }
	  return this;
	};
	
	/**
	 * Set the source content for a source file. This will be added to the SourceMapGenerator
	 * in the sourcesContent field.
	 *
	 * @param aSourceFile The filename of the source file
	 * @param aSourceContent The content of the source file
	 */
	SourceNode.prototype.setSourceContent =
	  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
	    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	  };
	
	/**
	 * Walk over the tree of SourceNodes. The walking function is called for each
	 * source file content and is passed the filename and source content.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walkSourceContents =
	  function SourceNode_walkSourceContents(aFn) {
	    for (var i = 0, len = this.children.length; i < len; i++) {
	      if (this.children[i][isSourceNode]) {
	        this.children[i].walkSourceContents(aFn);
	      }
	    }
	
	    var sources = Object.keys(this.sourceContents);
	    for (var i = 0, len = sources.length; i < len; i++) {
	      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
	    }
	  };
	
	/**
	 * Return the string representation of this source node. Walks over the tree
	 * and concatenates all the various snippets together to one string.
	 */
	SourceNode.prototype.toString = function SourceNode_toString() {
	  var str = "";
	  this.walk(function (chunk) {
	    str += chunk;
	  });
	  return str;
	};
	
	/**
	 * Returns the string representation of this source node along with a source
	 * map.
	 */
	SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
	  var generated = {
	    code: "",
	    line: 1,
	    column: 0
	  };
	  var map = new SourceMapGenerator(aArgs);
	  var sourceMappingActive = false;
	  var lastOriginalSource = null;
	  var lastOriginalLine = null;
	  var lastOriginalColumn = null;
	  var lastOriginalName = null;
	  this.walk(function (chunk, original) {
	    generated.code += chunk;
	    if (original.source !== null
	        && original.line !== null
	        && original.column !== null) {
	      if(lastOriginalSource !== original.source
	         || lastOriginalLine !== original.line
	         || lastOriginalColumn !== original.column
	         || lastOriginalName !== original.name) {
	        map.addMapping({
	          source: original.source,
	          original: {
	            line: original.line,
	            column: original.column
	          },
	          generated: {
	            line: generated.line,
	            column: generated.column
	          },
	          name: original.name
	        });
	      }
	      lastOriginalSource = original.source;
	      lastOriginalLine = original.line;
	      lastOriginalColumn = original.column;
	      lastOriginalName = original.name;
	      sourceMappingActive = true;
	    } else if (sourceMappingActive) {
	      map.addMapping({
	        generated: {
	          line: generated.line,
	          column: generated.column
	        }
	      });
	      lastOriginalSource = null;
	      sourceMappingActive = false;
	    }
	    for (var idx = 0, length = chunk.length; idx < length; idx++) {
	      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
	        generated.line++;
	        generated.column = 0;
	        // Mappings end at eol
	        if (idx + 1 === length) {
	          lastOriginalSource = null;
	          sourceMappingActive = false;
	        } else if (sourceMappingActive) {
	          map.addMapping({
	            source: original.source,
	            original: {
	              line: original.line,
	              column: original.column
	            },
	            generated: {
	              line: generated.line,
	              column: generated.column
	            },
	            name: original.name
	          });
	        }
	      } else {
	        generated.column++;
	      }
	    }
	  });
	  this.walkSourceContents(function (sourceFile, sourceContent) {
	    map.setSourceContent(sourceFile, sourceContent);
	  });
	
	  return { code: generated.code, map: map };
	};
	
	exports.SourceNode = SourceNode;


/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Source = __webpack_require__(342);
	var SourceNode = __webpack_require__(343).SourceNode;
	var SourceListMap = __webpack_require__(31).SourceListMap;
	
	function RawSource(value) {
		Source.call(this);
		this._value = value;
	}
	module.exports = RawSource;
	
	RawSource.prototype = Object.create(Source.prototype);
	RawSource.prototype.constructor = RawSource;
	
	RawSource.prototype.source = function() {
		return this._value;
	};
	
	RawSource.prototype.map = function(options) {
		return null;
	};
	
	RawSource.prototype.node = function(options) {
		return new SourceNode(null, null, null, this._value);
	};
	
	RawSource.prototype.listMap = function(options) {
		return new SourceListMap(this._value);
	};
	
	RawSource.prototype.updateHash = function(hash) {
		hash.update(this._value);
	};


/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var SourceNode = __webpack_require__(343).SourceNode;
	var SourceMapConsumer = __webpack_require__(343).SourceMapConsumer;
	var SourceListMap = __webpack_require__(31).SourceListMap;
	var Source = __webpack_require__(342);
	
	function isSplitter(c) {
		switch(c) {
			case 10: // \n
			case 13: // \r
			case 59: // ;
			case 123: // {
			case 125: // }
				return true;
		}
		return false;
	}
	
	function _splitCode(code) {
		var result = [];
		var i = 0;
		var j = 0;
		for(; i < code.length; i++) {
			if(isSplitter(code.charCodeAt(i))) {
				while(isSplitter(code.charCodeAt(++i)));
				result.push(code.substring(j, i));
				j = i;
			}
		}
		if(j < code.length)
			result.push(code.substr(j));
		return result;
	}
	
	function OriginalSource(value, name) {
		Source.call(this);
		this._value = value;
		this._name = name;
	}
	
	module.exports = OriginalSource;
	
	OriginalSource.prototype = Object.create(Source.prototype);
	OriginalSource.prototype.constructor = OriginalSource;
	
	OriginalSource.prototype.source = function() {
		return this._value;
	};
	
	__webpack_require__(356)(OriginalSource.prototype);
	
	OriginalSource.prototype.node = function(options) {
		options = options || {};
		var sourceMap = this._sourceMap;
		var value = this._value;
		var name = this._name;
		var lines = value.split("\n");
		var node = new SourceNode(null, null, null,
			lines.map(function(line, idx) {
				var pos = 0;
				if(options.columns === false) {
					var content = line + (idx != lines.length - 1 ? "\n" : "");
					return new SourceNode(idx + 1, 0, name, content);
				}
				return new SourceNode(null, null, null,
					_splitCode(line + (idx != lines.length - 1 ? "\n" : "")).map(function(item) {
						if(/^\s*$/.test(item)) return item;
						var res = new SourceNode(idx + 1, pos, name, item);
						pos += item.length;
						return res;
					})
				);
			})
		);
		node.setSourceContent(name, value);
		return node;
	};
	
	OriginalSource.prototype.listMap = function(options) {
		return new SourceListMap(this._value, this._name, this._value)
	};
	
	OriginalSource.prototype.updateHash = function(hash) {
		hash.update(this._value);
	};


/***/ },
/* 356 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function mixinSourceAndMap(proto) {
		proto.map = function(options) {
			options = options || {};
			if(options.columns === false) {
				return this.listMap(options).toStringWithSourceMap({
					file: "x"
				}).map;
			}
	
			return this.node(options).toStringWithSourceMap({
				file: "x"
			}).map.toJSON();
		};
	
		proto.sourceAndMap = function(options) {
			options = options || {};
			if(options.columns === false) {
				//console.log(this.listMap(options).debugInfo());
				return this.listMap(options).toStringWithSourceMap({
					file: "x"
				});
			}
	
			var res = this.node(options).toStringWithSourceMap({
				file: "x"
			});
			return {
				source: res.code,
				map: res.map.toJSON()
			};
		};
	}


/***/ },
/* 357 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var SourceNode = __webpack_require__(343).SourceNode;
	var SourceMapConsumer = __webpack_require__(343).SourceMapConsumer;
	var SourceMapGenerator = __webpack_require__(343).SourceMapGenerator;
	var SourceListMap = __webpack_require__(31).SourceListMap;
	var fromStringWithSourceMap = __webpack_require__(31).fromStringWithSourceMap;
	var Source = __webpack_require__(342);
	
	function SourceMapSource(value, name, sourceMap, originalSource, innerSourceMap) {
		Source.call(this);
		this._value = value;
		this._name = name;
		this._sourceMap = sourceMap;
		this._originalSource = originalSource;
		this._innerSourceMap = innerSourceMap;
	}
	module.exports = SourceMapSource;
	
	SourceMapSource.prototype = Object.create(Source.prototype);
	SourceMapSource.prototype.constructor = SourceMapSource;
	
	SourceMapSource.prototype.source = function() {
		return this._value;
	};
	
	__webpack_require__(356)(SourceMapSource.prototype);
	
	SourceMapSource.prototype.node = function(options) {
		var innerSourceMap = this._innerSourceMap;
		var sourceMap = this._sourceMap;
		if(innerSourceMap) {
			sourceMap = SourceMapGenerator.fromSourceMap(new SourceMapConsumer(sourceMap));
			if(this._originalSource)
				sourceMap.setSourceContent(this._name, this._originalSource);
			innerSourceMap = new SourceMapConsumer(innerSourceMap);
			sourceMap.applySourceMap(innerSourceMap, this._name);
			sourceMap = sourceMap.toJSON();
		}
		return SourceNode.fromStringWithSourceMap(this._value, new SourceMapConsumer(sourceMap));
	};
	
	SourceMapSource.prototype.listMap = function(options) {
		if(options.module === false)
			return new SourceListMap(this._value, this._name, this._value);
		return fromStringWithSourceMap(this._value, typeof this._sourceMap === "string" ? JSON.parse(this._sourceMap) : this._sourceMap);
	};
	
	SourceMapSource.prototype.updateHash = function(hash) {
		hash.update(this._value);
		if(this._originalSource)
			hash.update(this._originalSource);
	};


/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var SourceNode = __webpack_require__(343).SourceNode;
	var SourceMapConsumer = __webpack_require__(343).SourceMapConsumer;
	var SourceListMap = __webpack_require__(31).SourceListMap;
	var Source = __webpack_require__(342);
	
	function LineToLineMappedSource(value, name, originalSource) {
		Source.call(this);
		this._value = value;
		this._name = name;
		this._originalSource = originalSource;
	}
	
	module.exports = LineToLineMappedSource;
	
	LineToLineMappedSource.prototype = Object.create(Source.prototype);
	LineToLineMappedSource.prototype.constructor = LineToLineMappedSource;
	
	LineToLineMappedSource.prototype.source = function() {
		return this._value;
	};
	
	__webpack_require__(356)(LineToLineMappedSource.prototype);
	
	LineToLineMappedSource.prototype.node = function(options) {
		var value = this._value;
		var name = this._name;
		var lines = value.split("\n");
		var node = new SourceNode(null, null, null,
			lines.map(function(line, idx) {
				return new SourceNode(idx + 1, 0, name, (line + (idx != lines.length - 1 ? "\n" : "")));
			})
		);
		node.setSourceContent(name, this._originalSource);
		return node;
	};
	
	LineToLineMappedSource.prototype.listMap = function(options) {
		return new SourceListMap(this._value, this._name, this._originalSource)
	};
	
	LineToLineMappedSource.prototype.updateHash = function(hash) {
		hash.update(this._value);
		hash.update(this._originalSource);
	};


/***/ },
/* 359 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function CachedSource(source) {
		this._source = source;
		this._cachedSource = undefined;
		this._cachedSize = undefined;
		this._cachedMaps = {};
	
		if(source.node) this.node = function(options) {
			return this._source.node(options);
		};
	
		if(source.listMap) this.listMap = function(options) {
			return this._source.listMap(options);
		};
	}
	module.exports = CachedSource;
	
	CachedSource.prototype.source = function() {
		if(typeof this._cachedSource !== "undefined") return this._cachedSource;
		return this._cachedSource = this._source.source();
	};
	
	CachedSource.prototype.size = function() {
		if(typeof this._cachedSize !== "undefined") return this._cachedSize;
		if(typeof this._cachedSource !== "undefined")
			return this._cachedSize = this._cachedSource.length;
		return this._cachedSize = this._source.size();
	};
	
	CachedSource.prototype.sourceAndMap = function(options) {
		var key = JSON.stringify(options);
		if(typeof this._cachedSource !== "undefined" && key in this._cachedMaps)
			return {
				source: this._cachedSource,
				map: this._cachedMaps[key]
			};
		else if(typeof this._cachedSource !== "undefined") {
			return {
				source: this._cachedSource,
				map: this._cachedMaps[key] = this._source.map(options)
			};
		} else if(key in this._cachedMaps) {
			return {
				source: this._cachedSource = this._source.source(),
				map: this._cachedMaps[key]
			};
		}
		var result = this._source.sourceAndMap(options);
		this._cachedSource = result.source;
		this._cachedMaps[key] = result.map;
		return {
			source: this._cachedSource,
			map: this._cachedMaps[key]
		};
	};
	
	CachedSource.prototype.map = function(options) {
		if(!options) options = {};
		var key = JSON.stringify(options);
		if(key in this._cachedMaps)
			return this._cachedMaps[key];
		return this._cachedMaps[key] = this._source.map();
	};
	
	CachedSource.prototype.updateHash = function(hash) {
		this._source.updateHash(hash);
	};


/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var SourceNode = __webpack_require__(343).SourceNode;
	var SourceListMap = __webpack_require__(31).SourceListMap;
	var Source = __webpack_require__(342);
	
	function ConcatSource() {
		Source.call(this);
		this.children = Array.prototype.slice.call(arguments);
	}
	module.exports = ConcatSource;
	
	ConcatSource.prototype = Object.create(Source.prototype);
	ConcatSource.prototype.constructor = ConcatSource;
	
	ConcatSource.prototype.add = function(item) {
		this.children.push(item);
	};
	
	ConcatSource.prototype.source = function() {
		return this.children.map(function(item) {
			return typeof item === "string" ? item : item.source();
		}).join("");
	};
	
	ConcatSource.prototype.size = function() {
		return this.children.map(function(item) {
			return typeof item === "string" ? item.length : item.size();
		}).reduce(function(sum, s) {
			return sum + s;
		}, 0);
	};
	
	__webpack_require__(356)(ConcatSource.prototype);
	
	ConcatSource.prototype.node = function(options) {
		var node = new SourceNode(null, null, null, this.children.map(function(item) {
			return typeof item === "string" ? item : item.node(options);
		}));
		return node;
	};
	
	ConcatSource.prototype.listMap = function(options) {
		var map = new SourceListMap();
		this.children.forEach(function(item) {
			if(typeof item === "string")
				map.add(item);
			else
				map.add(item.listMap(options));
		});
		return map;
	};
	
	ConcatSource.prototype.updateHash = function(hash) {
		this.children.forEach(function(item) {
			if(typeof item === "string")
				hash.update(item);
			else
				item.updateHash(hash);
		});
	};


/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Source = __webpack_require__(342);
	var SourceNode = __webpack_require__(343).SourceNode;
	var SourceListMap = __webpack_require__(31).SourceListMap;
	var fromStringWithSourceMap = __webpack_require__(31).fromStringWithSourceMap;
	var SourceMapConsumer = __webpack_require__(343).SourceMapConsumer;
	
	function ReplaceSource(source, name) {
		Source.call(this);
		this._source = source;
		this._name = name;
		this.replacements = [];
	}
	module.exports = ReplaceSource;
	
	ReplaceSource.prototype = Object.create(Source.prototype);
	ReplaceSource.prototype.constructor = ReplaceSource;
	
	ReplaceSource.prototype.replace = function(start, end, newValue) {
		if(typeof newValue !== "string")
			throw new Error("insertion must be a string, but is a " + typeof newValue);
		this.replacements.push([start, end, newValue, this.replacements.length]);
	};
	
	ReplaceSource.prototype.insert = function(pos, newValue) {
		if(typeof newValue !== "string")
			throw new Error("insertion must be a string, but is a " + typeof newValue + ": " + newValue);
		this.replacements.push([pos, pos - 1, newValue, this.replacements.length]);
	};
	
	ReplaceSource.prototype.source = function(options) {
		return this._replaceString(this._source.source());
	};
	
	ReplaceSource.prototype._sortReplacements = function() {
		this.replacements.sort(function(a, b) {
			var diff = b[1] - a[1];
			if(diff !== 0)
				return diff;
			diff = b[0] - a[0];
			if(diff !== 0)
				return diff;
			return b[3] - a[3];
		});
	};
	
	ReplaceSource.prototype._replaceString = function(str) {
		if(typeof str !== "string")
			throw new Error("str must be a string, but is a " + typeof str + ": " + str);
		this._sortReplacements();
		var result = [str];
		this.replacements.forEach(function(repl) {
			var remSource = result.pop();
			var splitted1 = this._splitString(remSource, Math.floor(repl[1] + 1));
			var splitted2 = this._splitString(splitted1[0], Math.floor(repl[0]));
			result.push(splitted1[1], repl[2], splitted2[0]);
		}, this);
		result = result.reverse();
		return result.join("");
	};
	
	__webpack_require__(356)(ReplaceSource.prototype);
	
	ReplaceSource.prototype.node = function(options) {
		this._sortReplacements();
		var result = [this._source.node(options)];
		this.replacements.forEach(function(repl) {
			var remSource = result.pop();
			var splitted1 = this._splitSourceNode(remSource, Math.floor(repl[1] + 1));
			var splitted2;
			if(Array.isArray(splitted1)) {
				splitted2 = this._splitSourceNode(splitted1[0], Math.floor(repl[0]));
				if(Array.isArray(splitted2)) {
					result.push(splitted1[1], this._replacementToSourceNode(splitted2[1], repl[2]), splitted2[0]);
				} else {
					result.push(splitted1[1], this._replacementToSourceNode(splitted1[1], repl[2]), splitted1[0]);
				}
			} else {
				splitted2 = this._splitSourceNode(remSource, Math.floor(repl[0]));
				if(Array.isArray(splitted2)) {
					result.push(this._replacementToSourceNode(splitted2[1], repl[2]), splitted2[0]);
				} else {
					result.push(repl[2], remSource);
				}
			}
		}, this);
		result = result.reverse();
		return new SourceNode(null, null, null, result);
	};
	
	ReplaceSource.prototype.listMap = function(options) {
		var map = this._source.listMap(options);
		if(map.children.length !== 1) {
			var code = map.toString();
			code = this._replaceString(code).split("\n");
			var currentIndex = 0;
			map.mapGeneratedCode(function(str) {
				var idx = -1;
				var count = -1;
				do {
					count++;
					idx = str.indexOf("\n", idx + 1);
				} while (idx >= 0);
				if(!count) return "";
				var result = code.slice(currentIndex, currentIndex + count).join("\n") + "\n";
				currentIndex += count;
				return result;
			});
			map.add(code.slice(currentIndex).join("\n"));
		} else {
			map.mapGeneratedCode(this._replaceString.bind(this));
		}
		return map;
	};
	
	ReplaceSource.prototype._replacementToSourceNode = function(oldNode, newString) {
		var map = oldNode.toStringWithSourceMap({
			file: "?"
		}).map;
		var original = new SourceMapConsumer(map.toJSON()).originalPositionFor({
			line: 1,
			column: 0
		});
		if(original) {
			return new SourceNode(original.line, original.column, original.source, newString);
		} else {
			return newString;
		}
	};
	
	ReplaceSource.prototype._splitSourceNode = function(node, position) {
		if(typeof node === "string") {
			if(node.length <= position) return position - node.length;
			return position <= 0 ? ["", node] : [node.substr(0, position), node.substr(position)];
		} else {
			for(var i = 0; i < node.children.length; i++) {
				position = this._splitSourceNode(node.children[i], position);
				if(Array.isArray(position)) {
					var leftNode = new SourceNode(
						node.line,
						node.column,
						node.source,
						node.children.slice(0, i).concat([position[0]]),
						node.name
					);
					var rightNode = new SourceNode(
						node.line,
						node.column,
						node.source, [position[1]].concat(node.children.slice(i + 1)),
						node.name
					);
					leftNode.sourceContents = node.sourceContents;
					return [leftNode, rightNode];
				}
			}
			return position;
		}
	};
	
	ReplaceSource.prototype._splitString = function(str, position) {
		return position <= 0 ? ["", str] : [str.substr(0, position), str.substr(position)];
	};


/***/ },
/* 362 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var Source = __webpack_require__(342);
	var SourceNode = __webpack_require__(343).SourceNode;
	
	function PrefixSource(prefix, source) {
		Source.call(this);
		this._source = source;
		this._prefix = prefix;
	}
	module.exports = PrefixSource;
	
	PrefixSource.prototype = Object.create(Source.prototype);
	PrefixSource.prototype.constructor = PrefixSource;
	
	PrefixSource.prototype.source = function() {
		var node = typeof this._source === "string" ? this._source : this._source.source();
		var prefix = this._prefix;
		return prefix + node.replace(/\n(.)/g, "\n" + prefix + "$1");
	};
	
	__webpack_require__(356)(PrefixSource.prototype);
	
	PrefixSource.prototype.node = function(options) {
		var node = this._source.node(options);
		var append = [this._prefix];
		return new SourceNode(null, null, null, [
			cloneAndPrefix(node, this._prefix, append)
		]);
	};
	
	PrefixSource.prototype.listMap = function(options) {
		var prefix = this._prefix;
		var map = this._source.listMap(options);
		map.mapGeneratedCode(function(code) {
			return prefix + code.replace(/\n(.)/g, "\n" + prefix + "$1");
		});
		return map;
	};
	
	PrefixSource.prototype.updateHash = function(hash) {
		if(typeof this._source === "string")
			hash.update(this._source);
		else
			this._source.updateHash(hash);
		if(typeof this._prefix === "string")
			hash.update(this._prefix);
		else
			this._prefix.updateHash(hash);
	};
	
	function cloneAndPrefix(node, prefix, append) {
		if(typeof node === "string") {
			var result = node.replace(/\n(.)/g, "\n" + prefix + "$1");
			if(append.length > 0) result = append.pop() + result;
			if(/\n$/.test(node)) append.push(prefix);
			return result;
		} else {
			var newNode = new SourceNode(
				node.line,
				node.column,
				node.source,
				node.children.map(function(node) {
					return cloneAndPrefix(node, prefix, append);
				}),
				node.name
			);
			newNode.sourceContents = node.sourceContents;
			return newNode;
		}
	};


/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var SourceMapSource = __webpack_require__(341).SourceMapSource;
	var RawSource = __webpack_require__(341).RawSource;
	
	function ExtractedModule(identifier, originalModule, source, sourceMap, addtitionalInformation, prevModules) {
		this._identifier = identifier;
		this._originalModule = originalModule;
		this._source = source;
		this._sourceMap = sourceMap;
		this._prevModules = prevModules;
		this.addtitionalInformation = addtitionalInformation;
		this.chunks = [];
	}
	module.exports = ExtractedModule;
	
	ExtractedModule.prototype.getOrder = function() {
		// http://stackoverflow.com/a/14676665/1458162
		return /^@import url/.test(this._source) ? 0 : 1;
	};
	
	ExtractedModule.prototype.addChunk = function(chunk) {
		var idx = this.chunks.indexOf(chunk);
		if(idx < 0)
			this.chunks.push(chunk);
	};
	
	ExtractedModule.prototype._removeAndDo = __webpack_require__(42);
	
	ExtractedModule.prototype.removeChunk = function(chunk) {
		return this._removeAndDo("chunks", chunk, "removeModule");
	};
	
	ExtractedModule.prototype.rewriteChunkInReasons = function(oldChunk, newChunks) { };
	
	ExtractedModule.prototype.identifier = function() {
		return this._identifier;
	};
	
	ExtractedModule.prototype.source = function() {
		if(this._sourceMap)
			return new SourceMapSource(this._source, null, this._sourceMap);
		else
			return new RawSource(this._source);
	};
	
	ExtractedModule.prototype.getOriginalModule = function() {
		return this._originalModule;
	};
	
	ExtractedModule.prototype.getPrevModules = function() {
		return this._prevModules;
	};
	
	ExtractedModule.prototype.addPrevModules = function(prevModules) {
		prevModules.forEach(function(m) {
			if(this._prevModules.indexOf(m) < 0)
				this._prevModules.push(m);
		}, this);
	};
	
	ExtractedModule.prototype.setOriginalModule = function(originalModule) {
		this._originalModule = originalModule;
	};


/***/ },
/* 364 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	function OrderUndefinedError(module) {
		Error.call(this);
		Error.captureStackTrace(this, OrderUndefinedError);
		this.name = "OrderUndefinedError";
		this.message = "Order in extracted chunk undefined";
		this.module = module;
	}
	module.exports = OrderUndefinedError;
	
	OrderUndefinedError.prototype = Object.create(Error.prototype);


/***/ },
/* 365 */
/***/ function(module, exports, __webpack_require__) {

	var JSON5 = __webpack_require__(366);
	var path = __webpack_require__(4);
	var assign = __webpack_require__(367);
	var emojiRegex = /[\uD800-\uDFFF]./;
	var emojiList = __webpack_require__(368).filter(function(emoji) {
		return emojiRegex.test(emoji)
	});
	
	var baseEncodeTables = {
		26: "abcdefghijklmnopqrstuvwxyz",
		32: "123456789abcdefghjkmnpqrstuvwxyz", // no 0lio
		36: "0123456789abcdefghijklmnopqrstuvwxyz",
		49: "abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ", // no lIO
		52: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
		58: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ", // no 0lIO
		62: "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
		64: "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_"
	};
	var emojiCache = {};
	
	function encodeStringToEmoji(content, length) {
		if (emojiCache[content]) return emojiCache[content];
		length = length || 1;
		var emojis = [];
		do {
			var index = Math.floor(Math.random() * emojiList.length);
			emojis.push(emojiList[index]);
			emojiList.splice(index, 1);
		} while (--length > 0);
		var emojiEncoding = emojis.join('');
		emojiCache[content] = emojiEncoding;
		return emojiEncoding;
	}
	
	function encodeBufferToBase(buffer, base) {
		var encodeTable = baseEncodeTables[base];
		if (!encodeTable) throw new Error("Unknown encoding base" + base);
	
		var readLength = buffer.length;
	
		var Big = __webpack_require__(369);
		Big.RM = Big.DP = 0;
		var b = new Big(0);
		for (var i = readLength - 1; i >= 0; i--) {
			b = b.times(256).plus(buffer[i]);
		}
	
		var output = "";
		while (b.gt(0)) {
			output = encodeTable[b.mod(base)] + output;
			b = b.div(base);
		}
	
		Big.DP = 20;
		Big.RM = 1;
	
		return output;
	}
	
	exports.parseQuery = function parseQuery(query) {
		var specialValues = {
			'null': null,
			'true': true,
			'false': false
		};
		if(!query) return {};
		if(typeof query !== "string")
			return query;
		if(query.substr(0, 1) !== "?")
			throw new Error("a valid query string passed to parseQuery should begin with '?'");
		query = query.substr(1);
		var queryLength = query.length;
		if(query.substr(0, 1) === "{" && query.substr(-1) === "}") {
			return JSON5.parse(query);
		}
		var queryArgs = query.split(/[,\&]/g);
		var result = {};
		queryArgs.forEach(function(arg) {
			var idx = arg.indexOf("=");
			if(idx >= 0) {
				var name = arg.substr(0, idx);
				var value = decodeURIComponent(arg.substr(idx+1));
				if (specialValues.hasOwnProperty(value)) {
					value = specialValues[value];
				}
				if(name.substr(-2) === "[]") {
					name = decodeURIComponent(name.substr(0, name.length-2));
					if(!Array.isArray(result[name]))
						result[name] = [];
					result[name].push(value);
				} else {
					name = decodeURIComponent(name);
					result[name] = value;
				}
			} else {
				if(arg.substr(0, 1) === "-") {
					result[decodeURIComponent(arg.substr(1))] = false;
				} else if(arg.substr(0, 1) === "+") {
					result[decodeURIComponent(arg.substr(1))] = true;
				} else {
					result[decodeURIComponent(arg)] = true;
				}
			}
		});
		return result;
	};
	
	exports.getLoaderConfig = function(loaderContext, defaultConfigKey) {
		var query = exports.parseQuery(loaderContext.query);
		var configKey = query.config || defaultConfigKey;
		if (configKey) {
			var config = loaderContext.options[configKey] || {};
			delete query.config;
			return assign({}, config, query);
		}
	
		return query;
	};
	
	exports.stringifyRequest = function(loaderContext, request) {
		var splitted = request.split("!");
		var context = loaderContext.context || (loaderContext.options && loaderContext.options.context);
		return JSON.stringify(splitted.map(function(part) {
			if(/^\/|^[A-Z]:/i.test(part) && context) {
				part = path.relative(context, part);
				if(/^[A-Z]:/i.test(part)) {
					return part;
				} else {
					return "./" + part.replace(/\\/g, "/");
				}
			}
			return part;
		}).join("!"));
	};
	
	function dotRequest(obj) {
		return obj.request;
	}
	
	exports.getRemainingRequest = function(loaderContext) {
		if(loaderContext.remainingRequest)
			return loaderContext.remainingRequest;
		var request = loaderContext.loaders.slice(loaderContext.loaderIndex+1).map(dotRequest).concat([loaderContext.resource]);
		return request.join("!");
	};
	
	exports.getCurrentRequest = function(loaderContext) {
		if(loaderContext.currentRequest)
			return loaderContext.currentRequest;
		var request = loaderContext.loaders.slice(loaderContext.loaderIndex).map(dotRequest).concat([loaderContext.resource]);
		return request.join("!");
	};
	
	exports.isUrlRequest = function(url, root) {
		// An URL is not an request if
		// 1. it's a Data Url
		// 2. it's an absolute url or and protocol-relative
		// 3. it's some kind of url for a template
		if(/^data:|^chrome-extension:|^(https?:)?\/\/|^[\{\}\[\]#*;,'§\$%&\(=?`´\^°<>]/.test(url)) return false;
		// 4. It's also not an request if root isn't set and it's a root-relative url
		if((root === undefined || root === false) && /^\//.test(url)) return false;
		return true;
	};
	
	exports.urlToRequest = function(url, root) {
		var moduleRequestRegex = /^[^?]*~/;
		var request;
	
		if(/^[a-zA-Z]:\\|^\\\\/.test(url)) {
			// absolute windows path, keep it
			request = url;
		} else if(root !== undefined && root !== false && /^\//.test(url)) {
			// if root is set and the url is root-relative
			switch(typeof root) {
				// 1. root is a string: root is prefixed to the url
				case "string":
					// special case: `~` roots convert to module request
					if (moduleRequestRegex.test(root)) {
						request = root.replace(/([^~\/])$/, "$1/") + url.slice(1);
					} else {
						request = root + url;
					}
					break;
				// 2. root is `true`: absolute paths are allowed
				//    *nix only, windows-style absolute paths are always allowed as they doesn't start with a `/`
				case "boolean":
					request = url;
					break;
				default:
					throw new Error("Unexpected parameters to loader-utils 'urlToRequest': url = " + url + ", root = " + root + ".");
			}
		} else if(/^\.\.?\//.test(url)) {
			// A relative url stays
			request = url;
		} else {
			// every other url is threaded like a relative url
			request = "./" + url;
		}
	
		// A `~` makes the url an module
		if (moduleRequestRegex.test(request)) {
			request = request.replace(moduleRequestRegex, "");
		}
	
		return request;
	};
	
	exports.parseString = function parseString(str) {
		try {
			if(str[0] === '"') return JSON.parse(str);
			if(str[0] === "'" && str.substr(str.length - 1) === "'") {
				return parseString(str.replace(/\\.|"/g, function(x) {
					if(x === '"') return '\\"';
					return x;
				}).replace(/^'|'$/g, '"'));
			}
			return JSON.parse('"' + str + '"');
		} catch(e) {
			return str;
		}
	};
	
	exports.getHashDigest = function getHashDigest(buffer, hashType, digestType, maxLength) {
		hashType = hashType || "md5";
		maxLength = maxLength || 9999;
		var hash = __webpack_require__(59).createHash(hashType);
		hash.update(buffer);
		if (digestType === "base26" || digestType === "base32" || digestType === "base36" ||
		    digestType === "base49" || digestType === "base52" || digestType === "base58" ||
		    digestType === "base62" || digestType === "base64") {
			return encodeBufferToBase(hash.digest(), digestType.substr(4)).substr(0, maxLength);
		} else {
			return hash.digest(digestType || "hex").substr(0, maxLength);
		}
	};
	
	exports.interpolateName = function interpolateName(loaderContext, name, options) {
		var filename = name || "[hash].[ext]";
		var context = options.context;
		var content = options.content;
		var regExp = options.regExp;
		var ext = "bin";
		var basename = "file";
		var directory = "";
		var folder = "";
		if(loaderContext.resourcePath) {
			var resourcePath = loaderContext.resourcePath;
			var idx = resourcePath.lastIndexOf(".");
			var i = resourcePath.lastIndexOf("\\");
			var j = resourcePath.lastIndexOf("/");
			var p = i < 0 ? j : j < 0 ? i : i < j ? i : j;
			if(idx >= 0) {
				ext = resourcePath.substr(idx+1);
				resourcePath = resourcePath.substr(0, idx);
			}
			if(p >= 0) {
				basename = resourcePath.substr(p+1);
				resourcePath = resourcePath.substr(0, p+1);
			}
			if (typeof context !== 'undefined') {
				directory = path.relative(context, resourcePath + "_").replace(/\\/g, "/").replace(/\.\.(\/)?/g, "_$1");
				directory = directory.substr(0, directory.length-1);
			}
			else {
				directory = resourcePath.replace(/\\/g, "/").replace(/\.\.(\/)?/g, "_$1");
			}
			if (directory.length === 1) {
				directory = "";
			} else if (directory.length > 1) {
				folder = path.basename(directory);
			}
		}
		var url = filename;
		if(content) {
			// Match hash template
			url = url.replace(/\[(?:(\w+):)?hash(?::([a-z]+\d*))?(?::(\d+))?\]/ig, function() {
				return exports.getHashDigest(content, arguments[1], arguments[2], parseInt(arguments[3], 10));
			}).replace(/\[emoji(?::(\d+))?\]/ig, function() {
				return encodeStringToEmoji(content, arguments[1]);
			});
		}
		url = url.replace(/\[ext\]/ig, function() {
			return ext;
		}).replace(/\[name\]/ig, function() {
			return basename;
		}).replace(/\[path\]/ig, function() {
			return directory;
		}).replace(/\[folder\]/ig, function() {
			return folder;
		});
		if(regExp && loaderContext.resourcePath) {
			var re = new RegExp(regExp);
			var match = loaderContext.resourcePath.match(re);
			if(match) {
				for (var i = 0; i < match.length; i++) {
					var re = new RegExp("\\[" + i + "\\]", "ig");
					url = url.replace(re, match[i]);
				}
			}
		}
		if(typeof loaderContext.options === "object" && typeof loaderContext.options.customInterpolateName === "function") {
			url = loaderContext.options.customInterpolateName.call(loaderContext, url, name, options);
		}
		return url;
	};


/***/ },
/* 366 */
/***/ function(module, exports, __webpack_require__) {

	// json5.js
	// Modern JSON. See README.md for details.
	//
	// This file is based directly off of Douglas Crockford's json_parse.js:
	// https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js
	
	var JSON5 = ( true ? exports : {});
	
	JSON5.parse = (function () {
	    "use strict";
	
	// This is a function that can parse a JSON5 text, producing a JavaScript
	// data structure. It is a simple, recursive descent parser. It does not use
	// eval or regular expressions, so it can be used as a model for implementing
	// a JSON5 parser in other languages.
	
	// We are defining the function inside of another function to avoid creating
	// global variables.
	
	    var at,           // The index of the current character
	        lineNumber,   // The current line number
	        columnNumber, // The current column number
	        ch,           // The current character
	        escapee = {
	            "'":  "'",
	            '"':  '"',
	            '\\': '\\',
	            '/':  '/',
	            '\n': '',       // Replace escaped newlines in strings w/ empty string
	            b:    '\b',
	            f:    '\f',
	            n:    '\n',
	            r:    '\r',
	            t:    '\t'
	        },
	        ws = [
	            ' ',
	            '\t',
	            '\r',
	            '\n',
	            '\v',
	            '\f',
	            '\xA0',
	            '\uFEFF'
	        ],
	        text,
	
	        renderChar = function (chr) {
	            return chr === '' ? 'EOF' : "'" + chr + "'";
	        },
	
	        error = function (m) {
	
	// Call error when something is wrong.
	
	            var error = new SyntaxError();
	            // beginning of message suffix to agree with that provided by Gecko - see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse
	            error.message = m + " at line " + lineNumber + " column " + columnNumber + " of the JSON5 data. Still to read: " + JSON.stringify(text.substring(at - 1, at + 19));
	            error.at = at;
	            // These two property names have been chosen to agree with the ones in Gecko, the only popular
	            // environment which seems to supply this info on JSON.parse
	            error.lineNumber = lineNumber;
	            error.columnNumber = columnNumber;
	            throw error;
	        },
	
	        next = function (c) {
	
	// If a c parameter is provided, verify that it matches the current character.
	
	            if (c && c !== ch) {
	                error("Expected " + renderChar(c) + " instead of " + renderChar(ch));
	            }
	
	// Get the next character. When there are no more characters,
	// return the empty string.
	
	            ch = text.charAt(at);
	            at++;
	            columnNumber++;
	            if (ch === '\n' || ch === '\r' && peek() !== '\n') {
	                lineNumber++;
	                columnNumber = 0;
	            }
	            return ch;
	        },
	
	        peek = function () {
	
	// Get the next character without consuming it or
	// assigning it to the ch varaible.
	
	            return text.charAt(at);
	        },
	
	        identifier = function () {
	
	// Parse an identifier. Normally, reserved words are disallowed here, but we
	// only use this for unquoted object keys, where reserved words are allowed,
	// so we don't check for those here. References:
	// - http://es5.github.com/#x7.6
	// - https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Variables
	// - http://docstore.mik.ua/orelly/webprog/jscript/ch02_07.htm
	// TODO Identifiers can have Unicode "letters" in them; add support for those.
	
	            var key = ch;
	
	            // Identifiers must start with a letter, _ or $.
	            if ((ch !== '_' && ch !== '$') &&
	                    (ch < 'a' || ch > 'z') &&
	                    (ch < 'A' || ch > 'Z')) {
	                error("Bad identifier as unquoted key");
	            }
	
	            // Subsequent characters can contain digits.
	            while (next() && (
	                    ch === '_' || ch === '$' ||
	                    (ch >= 'a' && ch <= 'z') ||
	                    (ch >= 'A' && ch <= 'Z') ||
	                    (ch >= '0' && ch <= '9'))) {
	                key += ch;
	            }
	
	            return key;
	        },
	
	        number = function () {
	
	// Parse a number value.
	
	            var number,
	                sign = '',
	                string = '',
	                base = 10;
	
	            if (ch === '-' || ch === '+') {
	                sign = ch;
	                next(ch);
	            }
	
	            // support for Infinity (could tweak to allow other words):
	            if (ch === 'I') {
	                number = word();
	                if (typeof number !== 'number' || isNaN(number)) {
	                    error('Unexpected word for number');
	                }
	                return (sign === '-') ? -number : number;
	            }
	
	            // support for NaN
	            if (ch === 'N' ) {
	              number = word();
	              if (!isNaN(number)) {
	                error('expected word to be NaN');
	              }
	              // ignore sign as -NaN also is NaN
	              return number;
	            }
	
	            if (ch === '0') {
	                string += ch;
	                next();
	                if (ch === 'x' || ch === 'X') {
	                    string += ch;
	                    next();
	                    base = 16;
	                } else if (ch >= '0' && ch <= '9') {
	                    error('Octal literal');
	                }
	            }
	
	            switch (base) {
	            case 10:
	                while (ch >= '0' && ch <= '9' ) {
	                    string += ch;
	                    next();
	                }
	                if (ch === '.') {
	                    string += '.';
	                    while (next() && ch >= '0' && ch <= '9') {
	                        string += ch;
	                    }
	                }
	                if (ch === 'e' || ch === 'E') {
	                    string += ch;
	                    next();
	                    if (ch === '-' || ch === '+') {
	                        string += ch;
	                        next();
	                    }
	                    while (ch >= '0' && ch <= '9') {
	                        string += ch;
	                        next();
	                    }
	                }
	                break;
	            case 16:
	                while (ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f') {
	                    string += ch;
	                    next();
	                }
	                break;
	            }
	
	            if(sign === '-') {
	                number = -string;
	            } else {
	                number = +string;
	            }
	
	            if (!isFinite(number)) {
	                error("Bad number");
	            } else {
	                return number;
	            }
	        },
	
	        string = function () {
	
	// Parse a string value.
	
	            var hex,
	                i,
	                string = '',
	                delim,      // double quote or single quote
	                uffff;
	
	// When parsing for string values, we must look for ' or " and \ characters.
	
	            if (ch === '"' || ch === "'") {
	                delim = ch;
	                while (next()) {
	                    if (ch === delim) {
	                        next();
	                        return string;
	                    } else if (ch === '\\') {
	                        next();
	                        if (ch === 'u') {
	                            uffff = 0;
	                            for (i = 0; i < 4; i += 1) {
	                                hex = parseInt(next(), 16);
	                                if (!isFinite(hex)) {
	                                    break;
	                                }
	                                uffff = uffff * 16 + hex;
	                            }
	                            string += String.fromCharCode(uffff);
	                        } else if (ch === '\r') {
	                            if (peek() === '\n') {
	                                next();
	                            }
	                        } else if (typeof escapee[ch] === 'string') {
	                            string += escapee[ch];
	                        } else {
	                            break;
	                        }
	                    } else if (ch === '\n') {
	                        // unescaped newlines are invalid; see:
	                        // https://github.com/aseemk/json5/issues/24
	                        // TODO this feels special-cased; are there other
	                        // invalid unescaped chars?
	                        break;
	                    } else {
	                        string += ch;
	                    }
	                }
	            }
	            error("Bad string");
	        },
	
	        inlineComment = function () {
	
	// Skip an inline comment, assuming this is one. The current character should
	// be the second / character in the // pair that begins this inline comment.
	// To finish the inline comment, we look for a newline or the end of the text.
	
	            if (ch !== '/') {
	                error("Not an inline comment");
	            }
	
	            do {
	                next();
	                if (ch === '\n' || ch === '\r') {
	                    next();
	                    return;
	                }
	            } while (ch);
	        },
	
	        blockComment = function () {
	
	// Skip a block comment, assuming this is one. The current character should be
	// the * character in the /* pair that begins this block comment.
	// To finish the block comment, we look for an ending */ pair of characters,
	// but we also watch for the end of text before the comment is terminated.
	
	            if (ch !== '*') {
	                error("Not a block comment");
	            }
	
	            do {
	                next();
	                while (ch === '*') {
	                    next('*');
	                    if (ch === '/') {
	                        next('/');
	                        return;
	                    }
	                }
	            } while (ch);
	
	            error("Unterminated block comment");
	        },
	
	        comment = function () {
	
	// Skip a comment, whether inline or block-level, assuming this is one.
	// Comments always begin with a / character.
	
	            if (ch !== '/') {
	                error("Not a comment");
	            }
	
	            next('/');
	
	            if (ch === '/') {
	                inlineComment();
	            } else if (ch === '*') {
	                blockComment();
	            } else {
	                error("Unrecognized comment");
	            }
	        },
	
	        white = function () {
	
	// Skip whitespace and comments.
	// Note that we're detecting comments by only a single / character.
	// This works since regular expressions are not valid JSON(5), but this will
	// break if there are other valid values that begin with a / character!
	
	            while (ch) {
	                if (ch === '/') {
	                    comment();
	                } else if (ws.indexOf(ch) >= 0) {
	                    next();
	                } else {
	                    return;
	                }
	            }
	        },
	
	        word = function () {
	
	// true, false, or null.
	
	            switch (ch) {
	            case 't':
	                next('t');
	                next('r');
	                next('u');
	                next('e');
	                return true;
	            case 'f':
	                next('f');
	                next('a');
	                next('l');
	                next('s');
	                next('e');
	                return false;
	            case 'n':
	                next('n');
	                next('u');
	                next('l');
	                next('l');
	                return null;
	            case 'I':
	                next('I');
	                next('n');
	                next('f');
	                next('i');
	                next('n');
	                next('i');
	                next('t');
	                next('y');
	                return Infinity;
	            case 'N':
	              next( 'N' );
	              next( 'a' );
	              next( 'N' );
	              return NaN;
	            }
	            error("Unexpected " + renderChar(ch));
	        },
	
	        value,  // Place holder for the value function.
	
	        array = function () {
	
	// Parse an array value.
	
	            var array = [];
	
	            if (ch === '[') {
	                next('[');
	                white();
	                while (ch) {
	                    if (ch === ']') {
	                        next(']');
	                        return array;   // Potentially empty array
	                    }
	                    // ES5 allows omitting elements in arrays, e.g. [,] and
	                    // [,null]. We don't allow this in JSON5.
	                    if (ch === ',') {
	                        error("Missing array element");
	                    } else {
	                        array.push(value());
	                    }
	                    white();
	                    // If there's no comma after this value, this needs to
	                    // be the end of the array.
	                    if (ch !== ',') {
	                        next(']');
	                        return array;
	                    }
	                    next(',');
	                    white();
	                }
	            }
	            error("Bad array");
	        },
	
	        object = function () {
	
	// Parse an object value.
	
	            var key,
	                object = {};
	
	            if (ch === '{') {
	                next('{');
	                white();
	                while (ch) {
	                    if (ch === '}') {
	                        next('}');
	                        return object;   // Potentially empty object
	                    }
	
	                    // Keys can be unquoted. If they are, they need to be
	                    // valid JS identifiers.
	                    if (ch === '"' || ch === "'") {
	                        key = string();
	                    } else {
	                        key = identifier();
	                    }
	
	                    white();
	                    next(':');
	                    object[key] = value();
	                    white();
	                    // If there's no comma after this pair, this needs to be
	                    // the end of the object.
	                    if (ch !== ',') {
	                        next('}');
	                        return object;
	                    }
	                    next(',');
	                    white();
	                }
	            }
	            error("Bad object");
	        };
	
	    value = function () {
	
	// Parse a JSON value. It could be an object, an array, a string, a number,
	// or a word.
	
	        white();
	        switch (ch) {
	        case '{':
	            return object();
	        case '[':
	            return array();
	        case '"':
	        case "'":
	            return string();
	        case '-':
	        case '+':
	        case '.':
	            return number();
	        default:
	            return ch >= '0' && ch <= '9' ? number() : word();
	        }
	    };
	
	// Return the json_parse function. It will have access to all of the above
	// functions and variables.
	
	    return function (source, reviver) {
	        var result;
	
	        text = String(source);
	        at = 0;
	        lineNumber = 1;
	        columnNumber = 1;
	        ch = ' ';
	        result = value();
	        white();
	        if (ch) {
	            error("Syntax error");
	        }
	
	// If there is a reviver function, we recursively walk the new structure,
	// passing each name/value pair to the reviver function for possible
	// transformation, starting with a temporary root object that holds the result
	// in an empty key. If there is not a reviver function, we simply return the
	// result.
	
	        return typeof reviver === 'function' ? (function walk(holder, key) {
	            var k, v, value = holder[key];
	            if (value && typeof value === 'object') {
	                for (k in value) {
	                    if (Object.prototype.hasOwnProperty.call(value, k)) {
	                        v = walk(value, k);
	                        if (v !== undefined) {
	                            value[k] = v;
	                        } else {
	                            delete value[k];
	                        }
	                    }
	                }
	            }
	            return reviver.call(holder, key, value);
	        }({'': result}, '')) : result;
	    };
	}());
	
	// JSON5 stringify will not quote keys where appropriate
	JSON5.stringify = function (obj, replacer, space) {
	    if (replacer && (typeof(replacer) !== "function" && !isArray(replacer))) {
	        throw new Error('Replacer must be a function or an array');
	    }
	    var getReplacedValueOrUndefined = function(holder, key, isTopLevel) {
	        var value = holder[key];
	
	        // Replace the value with its toJSON value first, if possible
	        if (value && value.toJSON && typeof value.toJSON === "function") {
	            value = value.toJSON();
	        }
	
	        // If the user-supplied replacer if a function, call it. If it's an array, check objects' string keys for
	        // presence in the array (removing the key/value pair from the resulting JSON if the key is missing).
	        if (typeof(replacer) === "function") {
	            return replacer.call(holder, key, value);
	        } else if(replacer) {
	            if (isTopLevel || isArray(holder) || replacer.indexOf(key) >= 0) {
	                return value;
	            } else {
	                return undefined;
	            }
	        } else {
	            return value;
	        }
	    };
	
	    function isWordChar(c) {
	        return (c >= 'a' && c <= 'z') ||
	            (c >= 'A' && c <= 'Z') ||
	            (c >= '0' && c <= '9') ||
	            c === '_' || c === '$';
	    }
	
	    function isWordStart(c) {
	        return (c >= 'a' && c <= 'z') ||
	            (c >= 'A' && c <= 'Z') ||
	            c === '_' || c === '$';
	    }
	
	    function isWord(key) {
	        if (typeof key !== 'string') {
	            return false;
	        }
	        if (!isWordStart(key[0])) {
	            return false;
	        }
	        var i = 1, length = key.length;
	        while (i < length) {
	            if (!isWordChar(key[i])) {
	                return false;
	            }
	            i++;
	        }
	        return true;
	    }
	
	    // export for use in tests
	    JSON5.isWord = isWord;
	
	    // polyfills
	    function isArray(obj) {
	        if (Array.isArray) {
	            return Array.isArray(obj);
	        } else {
	            return Object.prototype.toString.call(obj) === '[object Array]';
	        }
	    }
	
	    function isDate(obj) {
	        return Object.prototype.toString.call(obj) === '[object Date]';
	    }
	
	    var objStack = [];
	    function checkForCircular(obj) {
	        for (var i = 0; i < objStack.length; i++) {
	            if (objStack[i] === obj) {
	                throw new TypeError("Converting circular structure to JSON");
	            }
	        }
	    }
	
	    function makeIndent(str, num, noNewLine) {
	        if (!str) {
	            return "";
	        }
	        // indentation no more than 10 chars
	        if (str.length > 10) {
	            str = str.substring(0, 10);
	        }
	
	        var indent = noNewLine ? "" : "\n";
	        for (var i = 0; i < num; i++) {
	            indent += str;
	        }
	
	        return indent;
	    }
	
	    var indentStr;
	    if (space) {
	        if (typeof space === "string") {
	            indentStr = space;
	        } else if (typeof space === "number" && space >= 0) {
	            indentStr = makeIndent(" ", space, true);
	        } else {
	            // ignore space parameter
	        }
	    }
	
	    // Copied from Crokford's implementation of JSON
	    // See https://github.com/douglascrockford/JSON-js/blob/e39db4b7e6249f04a195e7dd0840e610cc9e941e/json2.js#L195
	    // Begin
	    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
	        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
	        meta = { // table of character substitutions
	        '\b': '\\b',
	        '\t': '\\t',
	        '\n': '\\n',
	        '\f': '\\f',
	        '\r': '\\r',
	        '"' : '\\"',
	        '\\': '\\\\'
	    };
	    function escapeString(string) {
	
	// If the string contains no control characters, no quote characters, and no
	// backslash characters, then we can safely slap some quotes around it.
	// Otherwise we must also replace the offending characters with safe escape
	// sequences.
	        escapable.lastIndex = 0;
	        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
	            var c = meta[a];
	            return typeof c === 'string' ?
	                c :
	                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
	        }) + '"' : '"' + string + '"';
	    }
	    // End
	
	    function internalStringify(holder, key, isTopLevel) {
	        var buffer, res;
	
	        // Replace the value, if necessary
	        var obj_part = getReplacedValueOrUndefined(holder, key, isTopLevel);
	
	        if (obj_part && !isDate(obj_part)) {
	            // unbox objects
	            // don't unbox dates, since will turn it into number
	            obj_part = obj_part.valueOf();
	        }
	        switch(typeof obj_part) {
	            case "boolean":
	                return obj_part.toString();
	
	            case "number":
	                if (isNaN(obj_part) || !isFinite(obj_part)) {
	                    return "null";
	                }
	                return obj_part.toString();
	
	            case "string":
	                return escapeString(obj_part.toString());
	
	            case "object":
	                if (obj_part === null) {
	                    return "null";
	                } else if (isArray(obj_part)) {
	                    checkForCircular(obj_part);
	                    buffer = "[";
	                    objStack.push(obj_part);
	
	                    for (var i = 0; i < obj_part.length; i++) {
	                        res = internalStringify(obj_part, i, false);
	                        buffer += makeIndent(indentStr, objStack.length);
	                        if (res === null || typeof res === "undefined") {
	                            buffer += "null";
	                        } else {
	                            buffer += res;
	                        }
	                        if (i < obj_part.length-1) {
	                            buffer += ",";
	                        } else if (indentStr) {
	                            buffer += "\n";
	                        }
	                    }
	                    objStack.pop();
	                    if (obj_part.length) {
	                        buffer += makeIndent(indentStr, objStack.length, true)
	                    }
	                    buffer += "]";
	                } else {
	                    checkForCircular(obj_part);
	                    buffer = "{";
	                    var nonEmpty = false;
	                    objStack.push(obj_part);
	                    for (var prop in obj_part) {
	                        if (obj_part.hasOwnProperty(prop)) {
	                            var value = internalStringify(obj_part, prop, false);
	                            isTopLevel = false;
	                            if (typeof value !== "undefined" && value !== null) {
	                                buffer += makeIndent(indentStr, objStack.length);
	                                nonEmpty = true;
	                                key = isWord(prop) ? prop : escapeString(prop);
	                                buffer += key + ":" + (indentStr ? ' ' : '') + value + ",";
	                            }
	                        }
	                    }
	                    objStack.pop();
	                    if (nonEmpty) {
	                        buffer = buffer.substring(0, buffer.length-1) + makeIndent(indentStr, objStack.length) + "}";
	                    } else {
	                        buffer = '{}';
	                    }
	                }
	                return buffer;
	            default:
	                // functions and undefined should be ignored
	                return undefined;
	        }
	    }
	
	    // special case...when undefined is used inside of
	    // a compound object/array, return null.
	    // but when top-level, return undefined
	    var topLevelHolder = {"":obj};
	    if (obj === undefined) {
	        return getReplacedValueOrUndefined(topLevelHolder, '', true);
	    }
	    return internalStringify(topLevelHolder, '', true);
	};


/***/ },
/* 367 */
/***/ function(module, exports) {

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/
	
	'use strict';
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}
	
		return Object(val);
	}
	
	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}
	
			// Detect buggy property enumeration order in older V8 versions.
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}
	
			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}
	
	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;
	
		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);
	
			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}
	
			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}
	
		return to;
	};


/***/ },
/* 368 */
/***/ function(module, exports) {

	module.exports = [
	  "🀄",
	  "🃏",
	  "🅰",
	  "🅱",
	  "🅾",
	  "🅿",
	  "🆎",
	  "🆑",
	  "🆒",
	  "🆓",
	  "🆔",
	  "🆕",
	  "🆖",
	  "🆗",
	  "🆘",
	  "🆙",
	  "🆚",
	  "🇦🇨",
	  "🇦🇩",
	  "🇦🇪",
	  "🇦🇫",
	  "🇦🇬",
	  "🇦🇮",
	  "🇦🇱",
	  "🇦🇲",
	  "🇦🇴",
	  "🇦🇶",
	  "🇦🇷",
	  "🇦🇸",
	  "🇦🇹",
	  "🇦🇺",
	  "🇦🇼",
	  "🇦🇽",
	  "🇦🇿",
	  "🇦",
	  "🇧🇦",
	  "🇧🇧",
	  "🇧🇩",
	  "🇧🇪",
	  "🇧🇫",
	  "🇧🇬",
	  "🇧🇭",
	  "🇧🇮",
	  "🇧🇯",
	  "🇧🇱",
	  "🇧🇲",
	  "🇧🇳",
	  "🇧🇴",
	  "🇧🇶",
	  "🇧🇷",
	  "🇧🇸",
	  "🇧🇹",
	  "🇧🇻",
	  "🇧🇼",
	  "🇧🇾",
	  "🇧🇿",
	  "🇧",
	  "🇨🇦",
	  "🇨🇨",
	  "🇨🇩",
	  "🇨🇫",
	  "🇨🇬",
	  "🇨🇭",
	  "🇨🇮",
	  "🇨🇰",
	  "🇨🇱",
	  "🇨🇲",
	  "🇨🇳",
	  "🇨🇴",
	  "🇨🇵",
	  "🇨🇷",
	  "🇨🇺",
	  "🇨🇻",
	  "🇨🇼",
	  "🇨🇽",
	  "🇨🇾",
	  "🇨🇿",
	  "🇨",
	  "🇩🇪",
	  "🇩🇬",
	  "🇩🇯",
	  "🇩🇰",
	  "🇩🇲",
	  "🇩🇴",
	  "🇩🇿",
	  "🇩",
	  "🇪🇦",
	  "🇪🇨",
	  "🇪🇪",
	  "🇪🇬",
	  "🇪🇭",
	  "🇪🇷",
	  "🇪🇸",
	  "🇪🇹",
	  "🇪🇺",
	  "🇪",
	  "🇫🇮",
	  "🇫🇯",
	  "🇫🇰",
	  "🇫🇲",
	  "🇫🇴",
	  "🇫🇷",
	  "🇫",
	  "🇬🇦",
	  "🇬🇧",
	  "🇬🇩",
	  "🇬🇪",
	  "🇬🇫",
	  "🇬🇬",
	  "🇬🇭",
	  "🇬🇮",
	  "🇬🇱",
	  "🇬🇲",
	  "🇬🇳",
	  "🇬🇵",
	  "🇬🇶",
	  "🇬🇷",
	  "🇬🇸",
	  "🇬🇹",
	  "🇬🇺",
	  "🇬🇼",
	  "🇬🇾",
	  "🇬",
	  "🇭🇰",
	  "🇭🇲",
	  "🇭🇳",
	  "🇭🇷",
	  "🇭🇹",
	  "🇭🇺",
	  "🇭",
	  "🇮🇨",
	  "🇮🇩",
	  "🇮🇪",
	  "🇮🇱",
	  "🇮🇲",
	  "🇮🇳",
	  "🇮🇴",
	  "🇮🇶",
	  "🇮🇷",
	  "🇮🇸",
	  "🇮🇹",
	  "🇮",
	  "🇯🇪",
	  "🇯🇲",
	  "🇯🇴",
	  "🇯🇵",
	  "🇯",
	  "🇰🇪",
	  "🇰🇬",
	  "🇰🇭",
	  "🇰🇮",
	  "🇰🇲",
	  "🇰🇳",
	  "🇰🇵",
	  "🇰🇷",
	  "🇰🇼",
	  "🇰🇾",
	  "🇰🇿",
	  "🇰",
	  "🇱🇦",
	  "🇱🇧",
	  "🇱🇨",
	  "🇱🇮",
	  "🇱🇰",
	  "🇱🇷",
	  "🇱🇸",
	  "🇱🇹",
	  "🇱🇺",
	  "🇱🇻",
	  "🇱🇾",
	  "🇱",
	  "🇲🇦",
	  "🇲🇨",
	  "🇲🇩",
	  "🇲🇪",
	  "🇲🇫",
	  "🇲🇬",
	  "🇲🇭",
	  "🇲🇰",
	  "🇲🇱",
	  "🇲🇲",
	  "🇲🇳",
	  "🇲🇴",
	  "🇲🇵",
	  "🇲🇶",
	  "🇲🇷",
	  "🇲🇸",
	  "🇲🇹",
	  "🇲🇺",
	  "🇲🇻",
	  "🇲🇼",
	  "🇲🇽",
	  "🇲🇾",
	  "🇲🇿",
	  "🇲",
	  "🇳🇦",
	  "🇳🇨",
	  "🇳🇪",
	  "🇳🇫",
	  "🇳🇬",
	  "🇳🇮",
	  "🇳🇱",
	  "🇳🇴",
	  "🇳🇵",
	  "🇳🇷",
	  "🇳🇺",
	  "🇳🇿",
	  "🇳",
	  "🇴🇲",
	  "🇴",
	  "🇵🇦",
	  "🇵🇪",
	  "🇵🇫",
	  "🇵🇬",
	  "🇵🇭",
	  "🇵🇰",
	  "🇵🇱",
	  "🇵🇲",
	  "🇵🇳",
	  "🇵🇷",
	  "🇵🇸",
	  "🇵🇹",
	  "🇵🇼",
	  "🇵🇾",
	  "🇵",
	  "🇶🇦",
	  "🇶",
	  "🇷🇪",
	  "🇷🇴",
	  "🇷🇸",
	  "🇷🇺",
	  "🇷🇼",
	  "🇷",
	  "🇸🇦",
	  "🇸🇧",
	  "🇸🇨",
	  "🇸🇩",
	  "🇸🇪",
	  "🇸🇬",
	  "🇸🇭",
	  "🇸🇮",
	  "🇸🇯",
	  "🇸🇰",
	  "🇸🇱",
	  "🇸🇲",
	  "🇸🇳",
	  "🇸🇴",
	  "🇸🇷",
	  "🇸🇸",
	  "🇸🇹",
	  "🇸🇻",
	  "🇸🇽",
	  "🇸🇾",
	  "🇸🇿",
	  "🇸",
	  "🇹🇦",
	  "🇹🇨",
	  "🇹🇩",
	  "🇹🇫",
	  "🇹🇬",
	  "🇹🇭",
	  "🇹🇯",
	  "🇹🇰",
	  "🇹🇱",
	  "🇹🇲",
	  "🇹🇳",
	  "🇹🇴",
	  "🇹🇷",
	  "🇹🇹",
	  "🇹🇻",
	  "🇹🇼",
	  "🇹🇿",
	  "🇹",
	  "🇺🇦",
	  "🇺🇬",
	  "🇺🇲",
	  "🇺🇳",
	  "🇺🇸",
	  "🇺🇾",
	  "🇺🇿",
	  "🇺",
	  "🇻🇦",
	  "🇻🇨",
	  "🇻🇪",
	  "🇻🇬",
	  "🇻🇮",
	  "🇻🇳",
	  "🇻🇺",
	  "🇻",
	  "🇼🇫",
	  "🇼🇸",
	  "🇼",
	  "🇽🇰",
	  "🇽",
	  "🇾🇪",
	  "🇾🇹",
	  "🇾",
	  "🇿🇦",
	  "🇿🇲",
	  "🇿🇼",
	  "🇿",
	  "🈁",
	  "🈂",
	  "🈚",
	  "🈯",
	  "🈲",
	  "🈳",
	  "🈴",
	  "🈵",
	  "🈶",
	  "🈷",
	  "🈸",
	  "🈹",
	  "🈺",
	  "🉐",
	  "🉑",
	  "🌀",
	  "🌁",
	  "🌂",
	  "🌃",
	  "🌄",
	  "🌅",
	  "🌆",
	  "🌇",
	  "🌈",
	  "🌉",
	  "🌊",
	  "🌋",
	  "🌌",
	  "🌍",
	  "🌎",
	  "🌏",
	  "🌐",
	  "🌑",
	  "🌒",
	  "🌓",
	  "🌔",
	  "🌕",
	  "🌖",
	  "🌗",
	  "🌘",
	  "🌙",
	  "🌚",
	  "🌛",
	  "🌜",
	  "🌝",
	  "🌞",
	  "🌟",
	  "🌠",
	  "🌡",
	  "🌤",
	  "🌥",
	  "🌦",
	  "🌧",
	  "🌨",
	  "🌩",
	  "🌪",
	  "🌫",
	  "🌬",
	  "🌭",
	  "🌮",
	  "🌯",
	  "🌰",
	  "🌱",
	  "🌲",
	  "🌳",
	  "🌴",
	  "🌵",
	  "🌶",
	  "🌷",
	  "🌸",
	  "🌹",
	  "🌺",
	  "🌻",
	  "🌼",
	  "🌽",
	  "🌾",
	  "🌿",
	  "🍀",
	  "🍁",
	  "🍂",
	  "🍃",
	  "🍄",
	  "🍅",
	  "🍆",
	  "🍇",
	  "🍈",
	  "🍉",
	  "🍊",
	  "🍋",
	  "🍌",
	  "🍍",
	  "🍎",
	  "🍏",
	  "🍐",
	  "🍑",
	  "🍒",
	  "🍓",
	  "🍔",
	  "🍕",
	  "🍖",
	  "🍗",
	  "🍘",
	  "🍙",
	  "🍚",
	  "🍛",
	  "🍜",
	  "🍝",
	  "🍞",
	  "🍟",
	  "🍠",
	  "🍡",
	  "🍢",
	  "🍣",
	  "🍤",
	  "🍥",
	  "🍦",
	  "🍧",
	  "🍨",
	  "🍩",
	  "🍪",
	  "🍫",
	  "🍬",
	  "🍭",
	  "🍮",
	  "🍯",
	  "🍰",
	  "🍱",
	  "🍲",
	  "🍳",
	  "🍴",
	  "🍵",
	  "🍶",
	  "🍷",
	  "🍸",
	  "🍹",
	  "🍺",
	  "🍻",
	  "🍼",
	  "🍽",
	  "🍾",
	  "🍿",
	  "🎀",
	  "🎁",
	  "🎂",
	  "🎃",
	  "🎄",
	  "🎅🏻",
	  "🎅🏼",
	  "🎅🏽",
	  "🎅🏾",
	  "🎅🏿",
	  "🎅",
	  "🎆",
	  "🎇",
	  "🎈",
	  "🎉",
	  "🎊",
	  "🎋",
	  "🎌",
	  "🎍",
	  "🎎",
	  "🎏",
	  "🎐",
	  "🎑",
	  "🎒",
	  "🎓",
	  "🎖",
	  "🎗",
	  "🎙",
	  "🎚",
	  "🎛",
	  "🎞",
	  "🎟",
	  "🎠",
	  "🎡",
	  "🎢",
	  "🎣",
	  "🎤",
	  "🎥",
	  "🎦",
	  "🎧",
	  "🎨",
	  "🎩",
	  "🎪",
	  "🎫",
	  "🎬",
	  "🎭",
	  "🎮",
	  "🎯",
	  "🎰",
	  "🎱",
	  "🎲",
	  "🎳",
	  "🎴",
	  "🎵",
	  "🎶",
	  "🎷",
	  "🎸",
	  "🎹",
	  "🎺",
	  "🎻",
	  "🎼",
	  "🎽",
	  "🎾",
	  "🎿",
	  "🏀",
	  "🏁",
	  "🏂🏻",
	  "🏂🏼",
	  "🏂🏽",
	  "🏂🏾",
	  "🏂🏿",
	  "🏂",
	  "🏃🏻‍♀️",
	  "🏃🏻‍♂️",
	  "🏃🏻",
	  "🏃🏼‍♀️",
	  "🏃🏼‍♂️",
	  "🏃🏼",
	  "🏃🏽‍♀️",
	  "🏃🏽‍♂️",
	  "🏃🏽",
	  "🏃🏾‍♀️",
	  "🏃🏾‍♂️",
	  "🏃🏾",
	  "🏃🏿‍♀️",
	  "🏃🏿‍♂️",
	  "🏃🏿",
	  "🏃‍♀️",
	  "🏃‍♂️",
	  "🏃",
	  "🏄🏻‍♀️",
	  "🏄🏻‍♂️",
	  "🏄🏻",
	  "🏄🏼‍♀️",
	  "🏄🏼‍♂️",
	  "🏄🏼",
	  "🏄🏽‍♀️",
	  "🏄🏽‍♂️",
	  "🏄🏽",
	  "🏄🏾‍♀️",
	  "🏄🏾‍♂️",
	  "🏄🏾",
	  "🏄🏿‍♀️",
	  "🏄🏿‍♂️",
	  "🏄🏿",
	  "🏄‍♀️",
	  "🏄‍♂️",
	  "🏄",
	  "🏅",
	  "🏆",
	  "🏇🏻",
	  "🏇🏼",
	  "🏇🏽",
	  "🏇🏾",
	  "🏇🏿",
	  "🏇",
	  "🏈",
	  "🏉",
	  "🏊🏻‍♀️",
	  "🏊🏻‍♂️",
	  "🏊🏻",
	  "🏊🏼‍♀️",
	  "🏊🏼‍♂️",
	  "🏊🏼",
	  "🏊🏽‍♀️",
	  "🏊🏽‍♂️",
	  "🏊🏽",
	  "🏊🏾‍♀️",
	  "🏊🏾‍♂️",
	  "🏊🏾",
	  "🏊🏿‍♀️",
	  "🏊🏿‍♂️",
	  "🏊🏿",
	  "🏊‍♀️",
	  "🏊‍♂️",
	  "🏊",
	  "🏋🏻‍♀️",
	  "🏋🏻‍♂️",
	  "🏋🏻",
	  "🏋🏼‍♀️",
	  "🏋🏼‍♂️",
	  "🏋🏼",
	  "🏋🏽‍♀️",
	  "🏋🏽‍♂️",
	  "🏋🏽",
	  "🏋🏾‍♀️",
	  "🏋🏾‍♂️",
	  "🏋🏾",
	  "🏋🏿‍♀️",
	  "🏋🏿‍♂️",
	  "🏋🏿",
	  "🏋️‍♀️",
	  "🏋️‍♂️",
	  "🏋",
	  "🏌🏻‍♀️",
	  "🏌🏻‍♂️",
	  "🏌🏻",
	  "🏌🏼‍♀️",
	  "🏌🏼‍♂️",
	  "🏌🏼",
	  "🏌🏽‍♀️",
	  "🏌🏽‍♂️",
	  "🏌🏽",
	  "🏌🏾‍♀️",
	  "🏌🏾‍♂️",
	  "🏌🏾",
	  "🏌🏿‍♀️",
	  "🏌🏿‍♂️",
	  "🏌🏿",
	  "🏌️‍♀️",
	  "🏌️‍♂️",
	  "🏌",
	  "🏍",
	  "🏎",
	  "🏏",
	  "🏐",
	  "🏑",
	  "🏒",
	  "🏓",
	  "🏔",
	  "🏕",
	  "🏖",
	  "🏗",
	  "🏘",
	  "🏙",
	  "🏚",
	  "🏛",
	  "🏜",
	  "🏝",
	  "🏞",
	  "🏟",
	  "🏠",
	  "🏡",
	  "🏢",
	  "🏣",
	  "🏤",
	  "🏥",
	  "🏦",
	  "🏧",
	  "🏨",
	  "🏩",
	  "🏪",
	  "🏫",
	  "🏬",
	  "🏭",
	  "🏮",
	  "🏯",
	  "🏰",
	  "🏳️‍🌈",
	  "🏳",
	  "🏴‍☠️",
	  "🏴",
	  "🏵",
	  "🏷",
	  "🏸",
	  "🏹",
	  "🏺",
	  "🏻",
	  "🏼",
	  "🏽",
	  "🏾",
	  "🏿",
	  "🐀",
	  "🐁",
	  "🐂",
	  "🐃",
	  "🐄",
	  "🐅",
	  "🐆",
	  "🐇",
	  "🐈",
	  "🐉",
	  "🐊",
	  "🐋",
	  "🐌",
	  "🐍",
	  "🐎",
	  "🐏",
	  "🐐",
	  "🐑",
	  "🐒",
	  "🐓",
	  "🐔",
	  "🐕",
	  "🐖",
	  "🐗",
	  "🐘",
	  "🐙",
	  "🐚",
	  "🐛",
	  "🐜",
	  "🐝",
	  "🐞",
	  "🐟",
	  "🐠",
	  "🐡",
	  "🐢",
	  "🐣",
	  "🐤",
	  "🐥",
	  "🐦",
	  "🐧",
	  "🐨",
	  "🐩",
	  "🐪",
	  "🐫",
	  "🐬",
	  "🐭",
	  "🐮",
	  "🐯",
	  "🐰",
	  "🐱",
	  "🐲",
	  "🐳",
	  "🐴",
	  "🐵",
	  "🐶",
	  "🐷",
	  "🐸",
	  "🐹",
	  "🐺",
	  "🐻",
	  "🐼",
	  "🐽",
	  "🐾",
	  "🐿",
	  "👀",
	  "👁‍🗨",
	  "👁",
	  "👂🏻",
	  "👂🏼",
	  "👂🏽",
	  "👂🏾",
	  "👂🏿",
	  "👂",
	  "👃🏻",
	  "👃🏼",
	  "👃🏽",
	  "👃🏾",
	  "👃🏿",
	  "👃",
	  "👄",
	  "👅",
	  "👆🏻",
	  "👆🏼",
	  "👆🏽",
	  "👆🏾",
	  "👆🏿",
	  "👆",
	  "👇🏻",
	  "👇🏼",
	  "👇🏽",
	  "👇🏾",
	  "👇🏿",
	  "👇",
	  "👈🏻",
	  "👈🏼",
	  "👈🏽",
	  "👈🏾",
	  "👈🏿",
	  "👈",
	  "👉🏻",
	  "👉🏼",
	  "👉🏽",
	  "👉🏾",
	  "👉🏿",
	  "👉",
	  "👊🏻",
	  "👊🏼",
	  "👊🏽",
	  "👊🏾",
	  "👊🏿",
	  "👊",
	  "👋🏻",
	  "👋🏼",
	  "👋🏽",
	  "👋🏾",
	  "👋🏿",
	  "👋",
	  "👌🏻",
	  "👌🏼",
	  "👌🏽",
	  "👌🏾",
	  "👌🏿",
	  "👌",
	  "👍🏻",
	  "👍🏼",
	  "👍🏽",
	  "👍🏾",
	  "👍🏿",
	  "👍",
	  "👎🏻",
	  "👎🏼",
	  "👎🏽",
	  "👎🏾",
	  "👎🏿",
	  "👎",
	  "👏🏻",
	  "👏🏼",
	  "👏🏽",
	  "👏🏾",
	  "👏🏿",
	  "👏",
	  "👐🏻",
	  "👐🏼",
	  "👐🏽",
	  "👐🏾",
	  "👐🏿",
	  "👐",
	  "👑",
	  "👒",
	  "👓",
	  "👔",
	  "👕",
	  "👖",
	  "👗",
	  "👘",
	  "👙",
	  "👚",
	  "👛",
	  "👜",
	  "👝",
	  "👞",
	  "👟",
	  "👠",
	  "👡",
	  "👢",
	  "👣",
	  "👤",
	  "👥",
	  "👦🏻",
	  "👦🏼",
	  "👦🏽",
	  "👦🏾",
	  "👦🏿",
	  "👦",
	  "👧🏻",
	  "👧🏼",
	  "👧🏽",
	  "👧🏾",
	  "👧🏿",
	  "👧",
	  "👨🏻‍🌾",
	  "👨🏻‍🍳",
	  "👨🏻‍🎓",
	  "👨🏻‍🎤",
	  "👨🏻‍🎨",
	  "👨🏻‍🏫",
	  "👨🏻‍🏭",
	  "👨🏻‍💻",
	  "👨🏻‍💼",
	  "👨🏻‍🔧",
	  "👨🏻‍🔬",
	  "👨🏻‍🚀",
	  "👨🏻‍🚒",
	  "👨🏻‍⚕️",
	  "👨🏻‍⚖️",
	  "👨🏻‍✈️",
	  "👨🏻",
	  "👨🏼‍🌾",
	  "👨🏼‍🍳",
	  "👨🏼‍🎓",
	  "👨🏼‍🎤",
	  "👨🏼‍🎨",
	  "👨🏼‍🏫",
	  "👨🏼‍🏭",
	  "👨🏼‍💻",
	  "👨🏼‍💼",
	  "👨🏼‍🔧",
	  "👨🏼‍🔬",
	  "👨🏼‍🚀",
	  "👨🏼‍🚒",
	  "👨🏼‍⚕️",
	  "👨🏼‍⚖️",
	  "👨🏼‍✈️",
	  "👨🏼",
	  "👨🏽‍🌾",
	  "👨🏽‍🍳",
	  "👨🏽‍🎓",
	  "👨🏽‍🎤",
	  "👨🏽‍🎨",
	  "👨🏽‍🏫",
	  "👨🏽‍🏭",
	  "👨🏽‍💻",
	  "👨🏽‍💼",
	  "👨🏽‍🔧",
	  "👨🏽‍🔬",
	  "👨🏽‍🚀",
	  "👨🏽‍🚒",
	  "👨🏽‍⚕️",
	  "👨🏽‍⚖️",
	  "👨🏽‍✈️",
	  "👨🏽",
	  "👨🏾‍🌾",
	  "👨🏾‍🍳",
	  "👨🏾‍🎓",
	  "👨🏾‍🎤",
	  "👨🏾‍🎨",
	  "👨🏾‍🏫",
	  "👨🏾‍🏭",
	  "👨🏾‍💻",
	  "👨🏾‍💼",
	  "👨🏾‍🔧",
	  "👨🏾‍🔬",
	  "👨🏾‍🚀",
	  "👨🏾‍🚒",
	  "👨🏾‍⚕️",
	  "👨🏾‍⚖️",
	  "👨🏾‍✈️",
	  "👨🏾",
	  "👨🏿‍🌾",
	  "👨🏿‍🍳",
	  "👨🏿‍🎓",
	  "👨🏿‍🎤",
	  "👨🏿‍🎨",
	  "👨🏿‍🏫",
	  "👨🏿‍🏭",
	  "👨🏿‍💻",
	  "👨🏿‍💼",
	  "👨🏿‍🔧",
	  "👨🏿‍🔬",
	  "👨🏿‍🚀",
	  "👨🏿‍🚒",
	  "👨🏿‍⚕️",
	  "👨🏿‍⚖️",
	  "👨🏿‍✈️",
	  "👨🏿",
	  "👨‍🌾",
	  "👨‍🍳",
	  "👨‍🎓",
	  "👨‍🎤",
	  "👨‍🎨",
	  "👨‍🏫",
	  "👨‍🏭",
	  "👨‍👦‍👦",
	  "👨‍👦",
	  "👨‍👧‍👦",
	  "👨‍👧‍👧",
	  "👨‍👧",
	  "👨‍👨‍👦‍👦",
	  "👨‍👨‍👦",
	  "👨‍👨‍👧‍👦",
	  "👨‍👨‍👧‍👧",
	  "👨‍👨‍👧",
	  "👨‍👩‍👦‍👦",
	  "👨‍👩‍👦",
	  "👨‍👩‍👧‍👦",
	  "👨‍👩‍👧‍👧",
	  "👨‍👩‍👧",
	  "👨‍💻",
	  "👨‍💼",
	  "👨‍🔧",
	  "👨‍🔬",
	  "👨‍🚀",
	  "👨‍🚒",
	  "👨‍⚕️",
	  "👨‍⚖️",
	  "👨‍✈️",
	  "👨‍❤️‍👨",
	  "👨‍❤️‍💋‍👨",
	  "👨",
	  "👩🏻‍🌾",
	  "👩🏻‍🍳",
	  "👩🏻‍🎓",
	  "👩🏻‍🎤",
	  "👩🏻‍🎨",
	  "👩🏻‍🏫",
	  "👩🏻‍🏭",
	  "👩🏻‍💻",
	  "👩🏻‍💼",
	  "👩🏻‍🔧",
	  "👩🏻‍🔬",
	  "👩🏻‍🚀",
	  "👩🏻‍🚒",
	  "👩🏻‍⚕️",
	  "👩🏻‍⚖️",
	  "👩🏻‍✈️",
	  "👩🏻",
	  "👩🏼‍🌾",
	  "👩🏼‍🍳",
	  "👩🏼‍🎓",
	  "👩🏼‍🎤",
	  "👩🏼‍🎨",
	  "👩🏼‍🏫",
	  "👩🏼‍🏭",
	  "👩🏼‍💻",
	  "👩🏼‍💼",
	  "👩🏼‍🔧",
	  "👩🏼‍🔬",
	  "👩🏼‍🚀",
	  "👩🏼‍🚒",
	  "👩🏼‍⚕️",
	  "👩🏼‍⚖️",
	  "👩🏼‍✈️",
	  "👩🏼",
	  "👩🏽‍🌾",
	  "👩🏽‍🍳",
	  "👩🏽‍🎓",
	  "👩🏽‍🎤",
	  "👩🏽‍🎨",
	  "👩🏽‍🏫",
	  "👩🏽‍🏭",
	  "👩🏽‍💻",
	  "👩🏽‍💼",
	  "👩🏽‍🔧",
	  "👩🏽‍🔬",
	  "👩🏽‍🚀",
	  "👩🏽‍🚒",
	  "👩🏽‍⚕️",
	  "👩🏽‍⚖️",
	  "👩🏽‍✈️",
	  "👩🏽",
	  "👩🏾‍🌾",
	  "👩🏾‍🍳",
	  "👩🏾‍🎓",
	  "👩🏾‍🎤",
	  "👩🏾‍🎨",
	  "👩🏾‍🏫",
	  "👩🏾‍🏭",
	  "👩🏾‍💻",
	  "👩🏾‍💼",
	  "👩🏾‍🔧",
	  "👩🏾‍🔬",
	  "👩🏾‍🚀",
	  "👩🏾‍🚒",
	  "👩🏾‍⚕️",
	  "👩🏾‍⚖️",
	  "👩🏾‍✈️",
	  "👩🏾",
	  "👩🏿‍🌾",
	  "👩🏿‍🍳",
	  "👩🏿‍🎓",
	  "👩🏿‍🎤",
	  "👩🏿‍🎨",
	  "👩🏿‍🏫",
	  "👩🏿‍🏭",
	  "👩🏿‍💻",
	  "👩🏿‍💼",
	  "👩🏿‍🔧",
	  "👩🏿‍🔬",
	  "👩🏿‍🚀",
	  "👩🏿‍🚒",
	  "👩🏿‍⚕️",
	  "👩🏿‍⚖️",
	  "👩🏿‍✈️",
	  "👩🏿",
	  "👩‍🌾",
	  "👩‍🍳",
	  "👩‍🎓",
	  "👩‍🎤",
	  "👩‍🎨",
	  "👩‍🏫",
	  "👩‍🏭",
	  "👩‍👦‍👦",
	  "👩‍👦",
	  "👩‍👧‍👦",
	  "👩‍👧‍👧",
	  "👩‍👧",
	  "👩‍👩‍👦‍👦",
	  "👩‍👩‍👦",
	  "👩‍👩‍👧‍👦",
	  "👩‍👩‍👧‍👧",
	  "👩‍👩‍👧",
	  "👩‍💻",
	  "👩‍💼",
	  "👩‍🔧",
	  "👩‍🔬",
	  "👩‍🚀",
	  "👩‍🚒",
	  "👩‍⚕️",
	  "👩‍⚖️",
	  "👩‍✈️",
	  "👩‍❤️‍👨",
	  "👩‍❤️‍👩",
	  "👩‍❤️‍💋‍👨",
	  "👩‍❤️‍💋‍👩",
	  "👩",
	  "👪🏻",
	  "👪🏼",
	  "👪🏽",
	  "👪🏾",
	  "👪🏿",
	  "👪",
	  "👫🏻",
	  "👫🏼",
	  "👫🏽",
	  "👫🏾",
	  "👫🏿",
	  "👫",
	  "👬🏻",
	  "👬🏼",
	  "👬🏽",
	  "👬🏾",
	  "👬🏿",
	  "👬",
	  "👭🏻",
	  "👭🏼",
	  "👭🏽",
	  "👭🏾",
	  "👭🏿",
	  "👭",
	  "👮🏻‍♀️",
	  "👮🏻‍♂️",
	  "👮🏻",
	  "👮🏼‍♀️",
	  "👮🏼‍♂️",
	  "👮🏼",
	  "👮🏽‍♀️",
	  "👮🏽‍♂️",
	  "👮🏽",
	  "👮🏾‍♀️",
	  "👮🏾‍♂️",
	  "👮🏾",
	  "👮🏿‍♀️",
	  "👮🏿‍♂️",
	  "👮🏿",
	  "👮‍♀️",
	  "👮‍♂️",
	  "👮",
	  "👯🏻‍♀️",
	  "👯🏻‍♂️",
	  "👯🏻",
	  "👯🏼‍♀️",
	  "👯🏼‍♂️",
	  "👯🏼",
	  "👯🏽‍♀️",
	  "👯🏽‍♂️",
	  "👯🏽",
	  "👯🏾‍♀️",
	  "👯🏾‍♂️",
	  "👯🏾",
	  "👯🏿‍♀️",
	  "👯🏿‍♂️",
	  "👯🏿",
	  "👯‍♀️",
	  "👯‍♂️",
	  "👯",
	  "👰🏻",
	  "👰🏼",
	  "👰🏽",
	  "👰🏾",
	  "👰🏿",
	  "👰",
	  "👱🏻‍♀️",
	  "👱🏻‍♂️",
	  "👱🏻",
	  "👱🏼‍♀️",
	  "👱🏼‍♂️",
	  "👱🏼",
	  "👱🏽‍♀️",
	  "👱🏽‍♂️",
	  "👱🏽",
	  "👱🏾‍♀️",
	  "👱🏾‍♂️",
	  "👱🏾",
	  "👱🏿‍♀️",
	  "👱🏿‍♂️",
	  "👱🏿",
	  "👱‍♀️",
	  "👱‍♂️",
	  "👱",
	  "👲🏻",
	  "👲🏼",
	  "👲🏽",
	  "👲🏾",
	  "👲🏿",
	  "👲",
	  "👳🏻‍♀️",
	  "👳🏻‍♂️",
	  "👳🏻",
	  "👳🏼‍♀️",
	  "👳🏼‍♂️",
	  "👳🏼",
	  "👳🏽‍♀️",
	  "👳🏽‍♂️",
	  "👳🏽",
	  "👳🏾‍♀️",
	  "👳🏾‍♂️",
	  "👳🏾",
	  "👳🏿‍♀️",
	  "👳🏿‍♂️",
	  "👳🏿",
	  "👳‍♀️",
	  "👳‍♂️",
	  "👳",
	  "👴🏻",
	  "👴🏼",
	  "👴🏽",
	  "👴🏾",
	  "👴🏿",
	  "👴",
	  "👵🏻",
	  "👵🏼",
	  "👵🏽",
	  "👵🏾",
	  "👵🏿",
	  "👵",
	  "👶🏻",
	  "👶🏼",
	  "👶🏽",
	  "👶🏾",
	  "👶🏿",
	  "👶",
	  "👷🏻‍♀️",
	  "👷🏻‍♂️",
	  "👷🏻",
	  "👷🏼‍♀️",
	  "👷🏼‍♂️",
	  "👷🏼",
	  "👷🏽‍♀️",
	  "👷🏽‍♂️",
	  "👷🏽",
	  "👷🏾‍♀️",
	  "👷🏾‍♂️",
	  "👷🏾",
	  "👷🏿‍♀️",
	  "👷🏿‍♂️",
	  "👷🏿",
	  "👷‍♀️",
	  "👷‍♂️",
	  "👷",
	  "👸🏻",
	  "👸🏼",
	  "👸🏽",
	  "👸🏾",
	  "👸🏿",
	  "👸",
	  "👹",
	  "👺",
	  "👻",
	  "👼🏻",
	  "👼🏼",
	  "👼🏽",
	  "👼🏾",
	  "👼🏿",
	  "👼",
	  "👽",
	  "👾",
	  "👿",
	  "💀",
	  "💁🏻‍♀️",
	  "💁🏻‍♂️",
	  "💁🏻",
	  "💁🏼‍♀️",
	  "💁🏼‍♂️",
	  "💁🏼",
	  "💁🏽‍♀️",
	  "💁🏽‍♂️",
	  "💁🏽",
	  "💁🏾‍♀️",
	  "💁🏾‍♂️",
	  "💁🏾",
	  "💁🏿‍♀️",
	  "💁🏿‍♂️",
	  "💁🏿",
	  "💁‍♀️",
	  "💁‍♂️",
	  "💁",
	  "💂🏻‍♀️",
	  "💂🏻‍♂️",
	  "💂🏻",
	  "💂🏼‍♀️",
	  "💂🏼‍♂️",
	  "💂🏼",
	  "💂🏽‍♀️",
	  "💂🏽‍♂️",
	  "💂🏽",
	  "💂🏾‍♀️",
	  "💂🏾‍♂️",
	  "💂🏾",
	  "💂🏿‍♀️",
	  "💂🏿‍♂️",
	  "💂🏿",
	  "💂‍♀️",
	  "💂‍♂️",
	  "💂",
	  "💃🏻",
	  "💃🏼",
	  "💃🏽",
	  "💃🏾",
	  "💃🏿",
	  "💃",
	  "💄",
	  "💅🏻",
	  "💅🏼",
	  "💅🏽",
	  "💅🏾",
	  "💅🏿",
	  "💅",
	  "💆🏻‍♀️",
	  "💆🏻‍♂️",
	  "💆🏻",
	  "💆🏼‍♀️",
	  "💆🏼‍♂️",
	  "💆🏼",
	  "💆🏽‍♀️",
	  "💆🏽‍♂️",
	  "💆🏽",
	  "💆🏾‍♀️",
	  "💆🏾‍♂️",
	  "💆🏾",
	  "💆🏿‍♀️",
	  "💆🏿‍♂️",
	  "💆🏿",
	  "💆‍♀️",
	  "💆‍♂️",
	  "💆",
	  "💇🏻‍♀️",
	  "💇🏻‍♂️",
	  "💇🏻",
	  "💇🏼‍♀️",
	  "💇🏼‍♂️",
	  "💇🏼",
	  "💇🏽‍♀️",
	  "💇🏽‍♂️",
	  "💇🏽",
	  "💇🏾‍♀️",
	  "💇🏾‍♂️",
	  "💇🏾",
	  "💇🏿‍♀️",
	  "💇🏿‍♂️",
	  "💇🏿",
	  "💇‍♀️",
	  "💇‍♂️",
	  "💇",
	  "💈",
	  "💉",
	  "💊",
	  "💋",
	  "💌",
	  "💍",
	  "💎",
	  "💏",
	  "💐",
	  "💑",
	  "💒",
	  "💓",
	  "💔",
	  "💕",
	  "💖",
	  "💗",
	  "💘",
	  "💙",
	  "💚",
	  "💛",
	  "💜",
	  "💝",
	  "💞",
	  "💟",
	  "💠",
	  "💡",
	  "💢",
	  "💣",
	  "💤",
	  "💥",
	  "💦",
	  "💧",
	  "💨",
	  "💩",
	  "💪🏻",
	  "💪🏼",
	  "💪🏽",
	  "💪🏾",
	  "💪🏿",
	  "💪",
	  "💫",
	  "💬",
	  "💭",
	  "💮",
	  "💯",
	  "💰",
	  "💱",
	  "💲",
	  "💳",
	  "💴",
	  "💵",
	  "💶",
	  "💷",
	  "💸",
	  "💹",
	  "💺",
	  "💻",
	  "💼",
	  "💽",
	  "💾",
	  "💿",
	  "📀",
	  "📁",
	  "📂",
	  "📃",
	  "📄",
	  "📅",
	  "📆",
	  "📇",
	  "📈",
	  "📉",
	  "📊",
	  "📋",
	  "📌",
	  "📍",
	  "📎",
	  "📏",
	  "📐",
	  "📑",
	  "📒",
	  "📓",
	  "📔",
	  "📕",
	  "📖",
	  "📗",
	  "📘",
	  "📙",
	  "📚",
	  "📛",
	  "📜",
	  "📝",
	  "📞",
	  "📟",
	  "📠",
	  "📡",
	  "📢",
	  "📣",
	  "📤",
	  "📥",
	  "📦",
	  "📧",
	  "📨",
	  "📩",
	  "📪",
	  "📫",
	  "📬",
	  "📭",
	  "📮",
	  "📯",
	  "📰",
	  "📱",
	  "📲",
	  "📳",
	  "📴",
	  "📵",
	  "📶",
	  "📷",
	  "📸",
	  "📹",
	  "📺",
	  "📻",
	  "📼",
	  "📽",
	  "📿",
	  "🔀",
	  "🔁",
	  "🔂",
	  "🔃",
	  "🔄",
	  "🔅",
	  "🔆",
	  "🔇",
	  "🔈",
	  "🔉",
	  "🔊",
	  "🔋",
	  "🔌",
	  "🔍",
	  "🔎",
	  "🔏",
	  "🔐",
	  "🔑",
	  "🔒",
	  "🔓",
	  "🔔",
	  "🔕",
	  "🔖",
	  "🔗",
	  "🔘",
	  "🔙",
	  "🔚",
	  "🔛",
	  "🔜",
	  "🔝",
	  "🔞",
	  "🔟",
	  "🔠",
	  "🔡",
	  "🔢",
	  "🔣",
	  "🔤",
	  "🔥",
	  "🔦",
	  "🔧",
	  "🔨",
	  "🔩",
	  "🔪",
	  "🔫",
	  "🔬",
	  "🔭",
	  "🔮",
	  "🔯",
	  "🔰",
	  "🔱",
	  "🔲",
	  "🔳",
	  "🔴",
	  "🔵",
	  "🔶",
	  "🔷",
	  "🔸",
	  "🔹",
	  "🔺",
	  "🔻",
	  "🔼",
	  "🔽",
	  "🕉",
	  "🕊",
	  "🕋",
	  "🕌",
	  "🕍",
	  "🕎",
	  "🕐",
	  "🕑",
	  "🕒",
	  "🕓",
	  "🕔",
	  "🕕",
	  "🕖",
	  "🕗",
	  "🕘",
	  "🕙",
	  "🕚",
	  "🕛",
	  "🕜",
	  "🕝",
	  "🕞",
	  "🕟",
	  "🕠",
	  "🕡",
	  "🕢",
	  "🕣",
	  "🕤",
	  "🕥",
	  "🕦",
	  "🕧",
	  "🕯",
	  "🕰",
	  "🕳",
	  "🕴🏻",
	  "🕴🏼",
	  "🕴🏽",
	  "🕴🏾",
	  "🕴🏿",
	  "🕴",
	  "🕵🏻‍♀️",
	  "🕵🏻‍♂️",
	  "🕵🏻",
	  "🕵🏼‍♀️",
	  "🕵🏼‍♂️",
	  "🕵🏼",
	  "🕵🏽‍♀️",
	  "🕵🏽‍♂️",
	  "🕵🏽",
	  "🕵🏾‍♀️",
	  "🕵🏾‍♂️",
	  "🕵🏾",
	  "🕵🏿‍♀️",
	  "🕵🏿‍♂️",
	  "🕵🏿",
	  "🕵️‍♀️",
	  "🕵️‍♂️",
	  "🕵",
	  "🕶",
	  "🕷",
	  "🕸",
	  "🕹",
	  "🕺🏻",
	  "🕺🏼",
	  "🕺🏽",
	  "🕺🏾",
	  "🕺🏿",
	  "🕺",
	  "🖇",
	  "🖊",
	  "🖋",
	  "🖌",
	  "🖍",
	  "🖐🏻",
	  "🖐🏼",
	  "🖐🏽",
	  "🖐🏾",
	  "🖐🏿",
	  "🖐",
	  "🖕🏻",
	  "🖕🏼",
	  "🖕🏽",
	  "🖕🏾",
	  "🖕🏿",
	  "🖕",
	  "🖖🏻",
	  "🖖🏼",
	  "🖖🏽",
	  "🖖🏾",
	  "🖖🏿",
	  "🖖",
	  "🖤",
	  "🖥",
	  "🖨",
	  "🖱",
	  "🖲",
	  "🖼",
	  "🗂",
	  "🗃",
	  "🗄",
	  "🗑",
	  "🗒",
	  "🗓",
	  "🗜",
	  "🗝",
	  "🗞",
	  "🗡",
	  "🗣",
	  "🗨",
	  "🗯",
	  "🗳",
	  "🗺",
	  "🗻",
	  "🗼",
	  "🗽",
	  "🗾",
	  "🗿",
	  "😀",
	  "😁",
	  "😂",
	  "😃",
	  "😄",
	  "😅",
	  "😆",
	  "😇",
	  "😈",
	  "😉",
	  "😊",
	  "😋",
	  "😌",
	  "😍",
	  "😎",
	  "😏",
	  "😐",
	  "😑",
	  "😒",
	  "😓",
	  "😔",
	  "😕",
	  "😖",
	  "😗",
	  "😘",
	  "😙",
	  "😚",
	  "😛",
	  "😜",
	  "😝",
	  "😞",
	  "😟",
	  "😠",
	  "😡",
	  "😢",
	  "😣",
	  "😤",
	  "😥",
	  "😦",
	  "😧",
	  "😨",
	  "😩",
	  "😪",
	  "😫",
	  "😬",
	  "😭",
	  "😮",
	  "😯",
	  "😰",
	  "😱",
	  "😲",
	  "😳",
	  "😴",
	  "😵",
	  "😶",
	  "😷",
	  "😸",
	  "😹",
	  "😺",
	  "😻",
	  "😼",
	  "😽",
	  "😾",
	  "😿",
	  "🙀",
	  "🙁",
	  "🙂",
	  "🙃",
	  "🙄",
	  "🙅🏻‍♀️",
	  "🙅🏻‍♂️",
	  "🙅🏻",
	  "🙅🏼‍♀️",
	  "🙅🏼‍♂️",
	  "🙅🏼",
	  "🙅🏽‍♀️",
	  "🙅🏽‍♂️",
	  "🙅🏽",
	  "🙅🏾‍♀️",
	  "🙅🏾‍♂️",
	  "🙅🏾",
	  "🙅🏿‍♀️",
	  "🙅🏿‍♂️",
	  "🙅🏿",
	  "🙅‍♀️",
	  "🙅‍♂️",
	  "🙅",
	  "🙆🏻‍♀️",
	  "🙆🏻‍♂️",
	  "🙆🏻",
	  "🙆🏼‍♀️",
	  "🙆🏼‍♂️",
	  "🙆🏼",
	  "🙆🏽‍♀️",
	  "🙆🏽‍♂️",
	  "🙆🏽",
	  "🙆🏾‍♀️",
	  "🙆🏾‍♂️",
	  "🙆🏾",
	  "🙆🏿‍♀️",
	  "🙆🏿‍♂️",
	  "🙆🏿",
	  "🙆‍♀️",
	  "🙆‍♂️",
	  "🙆",
	  "🙇🏻‍♀️",
	  "🙇🏻‍♂️",
	  "🙇🏻",
	  "🙇🏼‍♀️",
	  "🙇🏼‍♂️",
	  "🙇🏼",
	  "🙇🏽‍♀️",
	  "🙇🏽‍♂️",
	  "🙇🏽",
	  "🙇🏾‍♀️",
	  "🙇🏾‍♂️",
	  "🙇🏾",
	  "🙇🏿‍♀️",
	  "🙇🏿‍♂️",
	  "🙇🏿",
	  "🙇‍♀️",
	  "🙇‍♂️",
	  "🙇",
	  "🙈",
	  "🙉",
	  "🙊",
	  "🙋🏻‍♀️",
	  "🙋🏻‍♂️",
	  "🙋🏻",
	  "🙋🏼‍♀️",
	  "🙋🏼‍♂️",
	  "🙋🏼",
	  "🙋🏽‍♀️",
	  "🙋🏽‍♂️",
	  "🙋🏽",
	  "🙋🏾‍♀️",
	  "🙋🏾‍♂️",
	  "🙋🏾",
	  "🙋🏿‍♀️",
	  "🙋🏿‍♂️",
	  "🙋🏿",
	  "🙋‍♀️",
	  "🙋‍♂️",
	  "🙋",
	  "🙌🏻",
	  "🙌🏼",
	  "🙌🏽",
	  "🙌🏾",
	  "🙌🏿",
	  "🙌",
	  "🙍🏻‍♀️",
	  "🙍🏻‍♂️",
	  "🙍🏻",
	  "🙍🏼‍♀️",
	  "🙍🏼‍♂️",
	  "🙍🏼",
	  "🙍🏽‍♀️",
	  "🙍🏽‍♂️",
	  "🙍🏽",
	  "🙍🏾‍♀️",
	  "🙍🏾‍♂️",
	  "🙍🏾",
	  "🙍🏿‍♀️",
	  "🙍🏿‍♂️",
	  "🙍🏿",
	  "🙍‍♀️",
	  "🙍‍♂️",
	  "🙍",
	  "🙎🏻‍♀️",
	  "🙎🏻‍♂️",
	  "🙎🏻",
	  "🙎🏼‍♀️",
	  "🙎🏼‍♂️",
	  "🙎🏼",
	  "🙎🏽‍♀️",
	  "🙎🏽‍♂️",
	  "🙎🏽",
	  "🙎🏾‍♀️",
	  "🙎🏾‍♂️",
	  "🙎🏾",
	  "🙎🏿‍♀️",
	  "🙎🏿‍♂️",
	  "🙎🏿",
	  "🙎‍♀️",
	  "🙎‍♂️",
	  "🙎",
	  "🙏🏻",
	  "🙏🏼",
	  "🙏🏽",
	  "🙏🏾",
	  "🙏🏿",
	  "🙏",
	  "🚀",
	  "🚁",
	  "🚂",
	  "🚃",
	  "🚄",
	  "🚅",
	  "🚆",
	  "🚇",
	  "🚈",
	  "🚉",
	  "🚊",
	  "🚋",
	  "🚌",
	  "🚍",
	  "🚎",
	  "🚏",
	  "🚐",
	  "🚑",
	  "🚒",
	  "🚓",
	  "🚔",
	  "🚕",
	  "🚖",
	  "🚗",
	  "🚘",
	  "🚙",
	  "🚚",
	  "🚛",
	  "🚜",
	  "🚝",
	  "🚞",
	  "🚟",
	  "🚠",
	  "🚡",
	  "🚢",
	  "🚣🏻‍♀️",
	  "🚣🏻‍♂️",
	  "🚣🏻",
	  "🚣🏼‍♀️",
	  "🚣🏼‍♂️",
	  "🚣🏼",
	  "🚣🏽‍♀️",
	  "🚣🏽‍♂️",
	  "🚣🏽",
	  "🚣🏾‍♀️",
	  "🚣🏾‍♂️",
	  "🚣🏾",
	  "🚣🏿‍♀️",
	  "🚣🏿‍♂️",
	  "🚣🏿",
	  "🚣‍♀️",
	  "🚣‍♂️",
	  "🚣",
	  "🚤",
	  "🚥",
	  "🚦",
	  "🚧",
	  "🚨",
	  "🚩",
	  "🚪",
	  "🚫",
	  "🚬",
	  "🚭",
	  "🚮",
	  "🚯",
	  "🚰",
	  "🚱",
	  "🚲",
	  "🚳",
	  "🚴🏻‍♀️",
	  "🚴🏻‍♂️",
	  "🚴🏻",
	  "🚴🏼‍♀️",
	  "🚴🏼‍♂️",
	  "🚴🏼",
	  "🚴🏽‍♀️",
	  "🚴🏽‍♂️",
	  "🚴🏽",
	  "🚴🏾‍♀️",
	  "🚴🏾‍♂️",
	  "🚴🏾",
	  "🚴🏿‍♀️",
	  "🚴🏿‍♂️",
	  "🚴🏿",
	  "🚴‍♀️",
	  "🚴‍♂️",
	  "🚴",
	  "🚵🏻‍♀️",
	  "🚵🏻‍♂️",
	  "🚵🏻",
	  "🚵🏼‍♀️",
	  "🚵🏼‍♂️",
	  "🚵🏼",
	  "🚵🏽‍♀️",
	  "🚵🏽‍♂️",
	  "🚵🏽",
	  "🚵🏾‍♀️",
	  "🚵🏾‍♂️",
	  "🚵🏾",
	  "🚵🏿‍♀️",
	  "🚵🏿‍♂️",
	  "🚵🏿",
	  "🚵‍♀️",
	  "🚵‍♂️",
	  "🚵",
	  "🚶🏻‍♀️",
	  "🚶🏻‍♂️",
	  "🚶🏻",
	  "🚶🏼‍♀️",
	  "🚶🏼‍♂️",
	  "🚶🏼",
	  "🚶🏽‍♀️",
	  "🚶🏽‍♂️",
	  "🚶🏽",
	  "🚶🏾‍♀️",
	  "🚶🏾‍♂️",
	  "🚶🏾",
	  "🚶🏿‍♀️",
	  "🚶🏿‍♂️",
	  "🚶🏿",
	  "🚶‍♀️",
	  "🚶‍♂️",
	  "🚶",
	  "🚷",
	  "🚸",
	  "🚹",
	  "🚺",
	  "🚻",
	  "🚼",
	  "🚽",
	  "🚾",
	  "🚿",
	  "🛀🏻",
	  "🛀🏼",
	  "🛀🏽",
	  "🛀🏾",
	  "🛀🏿",
	  "🛀",
	  "🛁",
	  "🛂",
	  "🛃",
	  "🛄",
	  "🛅",
	  "🛋",
	  "🛌🏻",
	  "🛌🏼",
	  "🛌🏽",
	  "🛌🏾",
	  "🛌🏿",
	  "🛌",
	  "🛍",
	  "🛎",
	  "🛏",
	  "🛐",
	  "🛑",
	  "🛒",
	  "🛠",
	  "🛡",
	  "🛢",
	  "🛣",
	  "🛤",
	  "🛥",
	  "🛩",
	  "🛫",
	  "🛬",
	  "🛰",
	  "🛳",
	  "🛴",
	  "🛵",
	  "🛶",
	  "🤐",
	  "🤑",
	  "🤒",
	  "🤓",
	  "🤔",
	  "🤕",
	  "🤖",
	  "🤗",
	  "🤘🏻",
	  "🤘🏼",
	  "🤘🏽",
	  "🤘🏾",
	  "🤘🏿",
	  "🤘",
	  "🤙🏻",
	  "🤙🏼",
	  "🤙🏽",
	  "🤙🏾",
	  "🤙🏿",
	  "🤙",
	  "🤚🏻",
	  "🤚🏼",
	  "🤚🏽",
	  "🤚🏾",
	  "🤚🏿",
	  "🤚",
	  "🤛🏻",
	  "🤛🏼",
	  "🤛🏽",
	  "🤛🏾",
	  "🤛🏿",
	  "🤛",
	  "🤜🏻",
	  "🤜🏼",
	  "🤜🏽",
	  "🤜🏾",
	  "🤜🏿",
	  "🤜",
	  "🤝🏻",
	  "🤝🏼",
	  "🤝🏽",
	  "🤝🏾",
	  "🤝🏿",
	  "🤝",
	  "🤞🏻",
	  "🤞🏼",
	  "🤞🏽",
	  "🤞🏾",
	  "🤞🏿",
	  "🤞",
	  "🤠",
	  "🤡",
	  "🤢",
	  "🤣",
	  "🤤",
	  "🤥",
	  "🤦🏻‍♀️",
	  "🤦🏻‍♂️",
	  "🤦🏻",
	  "🤦🏼‍♀️",
	  "🤦🏼‍♂️",
	  "🤦🏼",
	  "🤦🏽‍♀️",
	  "🤦🏽‍♂️",
	  "🤦🏽",
	  "🤦🏾‍♀️",
	  "🤦🏾‍♂️",
	  "🤦🏾",
	  "🤦🏿‍♀️",
	  "🤦🏿‍♂️",
	  "🤦🏿",
	  "🤦‍♀️",
	  "🤦‍♂️",
	  "🤦",
	  "🤧",
	  "🤰🏻",
	  "🤰🏼",
	  "🤰🏽",
	  "🤰🏾",
	  "🤰🏿",
	  "🤰",
	  "🤳🏻",
	  "🤳🏼",
	  "🤳🏽",
	  "🤳🏾",
	  "🤳🏿",
	  "🤳",
	  "🤴🏻",
	  "🤴🏼",
	  "🤴🏽",
	  "🤴🏾",
	  "🤴🏿",
	  "🤴",
	  "🤵🏻",
	  "🤵🏼",
	  "🤵🏽",
	  "🤵🏾",
	  "🤵🏿",
	  "🤵",
	  "🤶🏻",
	  "🤶🏼",
	  "🤶🏽",
	  "🤶🏾",
	  "🤶🏿",
	  "🤶",
	  "🤷🏻‍♀️",
	  "🤷🏻‍♂️",
	  "🤷🏻",
	  "🤷🏼‍♀️",
	  "🤷🏼‍♂️",
	  "🤷🏼",
	  "🤷🏽‍♀️",
	  "🤷🏽‍♂️",
	  "🤷🏽",
	  "🤷🏾‍♀️",
	  "🤷🏾‍♂️",
	  "🤷🏾",
	  "🤷🏿‍♀️",
	  "🤷🏿‍♂️",
	  "🤷🏿",
	  "🤷‍♀️",
	  "🤷‍♂️",
	  "🤷",
	  "🤸🏻‍♀️",
	  "🤸🏻‍♂️",
	  "🤸🏻",
	  "🤸🏼‍♀️",
	  "🤸🏼‍♂️",
	  "🤸🏼",
	  "🤸🏽‍♀️",
	  "🤸🏽‍♂️",
	  "🤸🏽",
	  "🤸🏾‍♀️",
	  "🤸🏾‍♂️",
	  "🤸🏾",
	  "🤸🏿‍♀️",
	  "🤸🏿‍♂️",
	  "🤸🏿",
	  "🤸‍♀️",
	  "🤸‍♂️",
	  "🤸",
	  "🤹🏻‍♀️",
	  "🤹🏻‍♂️",
	  "🤹🏻",
	  "🤹🏼‍♀️",
	  "🤹🏼‍♂️",
	  "🤹🏼",
	  "🤹🏽‍♀️",
	  "🤹🏽‍♂️",
	  "🤹🏽",
	  "🤹🏾‍♀️",
	  "🤹🏾‍♂️",
	  "🤹🏾",
	  "🤹🏿‍♀️",
	  "🤹🏿‍♂️",
	  "🤹🏿",
	  "🤹‍♀️",
	  "🤹‍♂️",
	  "🤹",
	  "🤺",
	  "🤼🏻‍♀️",
	  "🤼🏻‍♂️",
	  "🤼🏻",
	  "🤼🏼‍♀️",
	  "🤼🏼‍♂️",
	  "🤼🏼",
	  "🤼🏽‍♀️",
	  "🤼🏽‍♂️",
	  "🤼🏽",
	  "🤼🏾‍♀️",
	  "🤼🏾‍♂️",
	  "🤼🏾",
	  "🤼🏿‍♀️",
	  "🤼🏿‍♂️",
	  "🤼🏿",
	  "🤼‍♀️",
	  "🤼‍♂️",
	  "🤼",
	  "🤽🏻‍♀️",
	  "🤽🏻‍♂️",
	  "🤽🏻",
	  "🤽🏼‍♀️",
	  "🤽🏼‍♂️",
	  "🤽🏼",
	  "🤽🏽‍♀️",
	  "🤽🏽‍♂️",
	  "🤽🏽",
	  "🤽🏾‍♀️",
	  "🤽🏾‍♂️",
	  "🤽🏾",
	  "🤽🏿‍♀️",
	  "🤽🏿‍♂️",
	  "🤽🏿",
	  "🤽‍♀️",
	  "🤽‍♂️",
	  "🤽",
	  "🤾🏻‍♀️",
	  "🤾🏻‍♂️",
	  "🤾🏻",
	  "🤾🏼‍♀️",
	  "🤾🏼‍♂️",
	  "🤾🏼",
	  "🤾🏽‍♀️",
	  "🤾🏽‍♂️",
	  "🤾🏽",
	  "🤾🏾‍♀️",
	  "🤾🏾‍♂️",
	  "🤾🏾",
	  "🤾🏿‍♀️",
	  "🤾🏿‍♂️",
	  "🤾🏿",
	  "🤾‍♀️",
	  "🤾‍♂️",
	  "🤾",
	  "🥀",
	  "🥁",
	  "🥂",
	  "🥃",
	  "🥄",
	  "🥅",
	  "🥇",
	  "🥈",
	  "🥉",
	  "🥊",
	  "🥋",
	  "🥐",
	  "🥑",
	  "🥒",
	  "🥓",
	  "🥔",
	  "🥕",
	  "🥖",
	  "🥗",
	  "🥘",
	  "🥙",
	  "🥚",
	  "🥛",
	  "🥜",
	  "🥝",
	  "🥞",
	  "🦀",
	  "🦁",
	  "🦂",
	  "🦃",
	  "🦄",
	  "🦅",
	  "🦆",
	  "🦇",
	  "🦈",
	  "🦉",
	  "🦊",
	  "🦋",
	  "🦌",
	  "🦍",
	  "🦎",
	  "🦏",
	  "🦐",
	  "🦑",
	  "🧀",
	  "‼",
	  "⁉",
	  "™",
	  "ℹ",
	  "↔",
	  "↕",
	  "↖",
	  "↗",
	  "↘",
	  "↙",
	  "↩",
	  "↪",
	  "#⃣",
	  "⌚",
	  "⌛",
	  "⌨",
	  "⏏",
	  "⏩",
	  "⏪",
	  "⏫",
	  "⏬",
	  "⏭",
	  "⏮",
	  "⏯",
	  "⏰",
	  "⏱",
	  "⏲",
	  "⏳",
	  "⏸",
	  "⏹",
	  "⏺",
	  "Ⓜ",
	  "▪",
	  "▫",
	  "▶",
	  "◀",
	  "◻",
	  "◼",
	  "◽",
	  "◾",
	  "☀",
	  "☁",
	  "☂",
	  "☃",
	  "☄",
	  "☎",
	  "☑",
	  "☔",
	  "☕",
	  "☘",
	  "☝🏻",
	  "☝🏼",
	  "☝🏽",
	  "☝🏾",
	  "☝🏿",
	  "☝",
	  "☠",
	  "☢",
	  "☣",
	  "☦",
	  "☪",
	  "☮",
	  "☯",
	  "☸",
	  "☹",
	  "☺",
	  "♀",
	  "♂",
	  "♈",
	  "♉",
	  "♊",
	  "♋",
	  "♌",
	  "♍",
	  "♎",
	  "♏",
	  "♐",
	  "♑",
	  "♒",
	  "♓",
	  "♠",
	  "♣",
	  "♥",
	  "♦",
	  "♨",
	  "♻",
	  "♿",
	  "⚒",
	  "⚓",
	  "⚔",
	  "⚕",
	  "⚖",
	  "⚗",
	  "⚙",
	  "⚛",
	  "⚜",
	  "⚠",
	  "⚡",
	  "⚪",
	  "⚫",
	  "⚰",
	  "⚱",
	  "⚽",
	  "⚾",
	  "⛄",
	  "⛅",
	  "⛈",
	  "⛎",
	  "⛏",
	  "⛑",
	  "⛓",
	  "⛔",
	  "⛩",
	  "⛪",
	  "⛰",
	  "⛱",
	  "⛲",
	  "⛳",
	  "⛴",
	  "⛵",
	  "⛷🏻",
	  "⛷🏼",
	  "⛷🏽",
	  "⛷🏾",
	  "⛷🏿",
	  "⛷",
	  "⛸",
	  "⛹🏻‍♀️",
	  "⛹🏻‍♂️",
	  "⛹🏻",
	  "⛹🏼‍♀️",
	  "⛹🏼‍♂️",
	  "⛹🏼",
	  "⛹🏽‍♀️",
	  "⛹🏽‍♂️",
	  "⛹🏽",
	  "⛹🏾‍♀️",
	  "⛹🏾‍♂️",
	  "⛹🏾",
	  "⛹🏿‍♀️",
	  "⛹🏿‍♂️",
	  "⛹🏿",
	  "⛹️‍♀️",
	  "⛹️‍♂️",
	  "⛹",
	  "⛺",
	  "⛽",
	  "✂",
	  "✅",
	  "✈",
	  "✉",
	  "✊🏻",
	  "✊🏼",
	  "✊🏽",
	  "✊🏾",
	  "✊🏿",
	  "✊",
	  "✋🏻",
	  "✋🏼",
	  "✋🏽",
	  "✋🏾",
	  "✋🏿",
	  "✋",
	  "✌🏻",
	  "✌🏼",
	  "✌🏽",
	  "✌🏾",
	  "✌🏿",
	  "✌",
	  "✍🏻",
	  "✍🏼",
	  "✍🏽",
	  "✍🏾",
	  "✍🏿",
	  "✍",
	  "✏",
	  "✒",
	  "✔",
	  "✖",
	  "✝",
	  "✡",
	  "✨",
	  "✳",
	  "✴",
	  "❄",
	  "❇",
	  "❌",
	  "❎",
	  "❓",
	  "❔",
	  "❕",
	  "❗",
	  "❣",
	  "❤",
	  "➕",
	  "➖",
	  "➗",
	  "➡",
	  "➰",
	  "➿",
	  "⤴",
	  "⤵",
	  "*⃣",
	  "⬅",
	  "⬆",
	  "⬇",
	  "⬛",
	  "⬜",
	  "⭐",
	  "⭕",
	  "0⃣",
	  "〰",
	  "〽",
	  "1⃣",
	  "2⃣",
	  "㊗",
	  "㊙",
	  "3⃣",
	  "4⃣",
	  "5⃣",
	  "6⃣",
	  "7⃣",
	  "8⃣",
	  "9⃣",
	  "©",
	  "®",
	  ""
	]

/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* big.js v3.1.3 https://github.com/MikeMcl/big.js/LICENCE */
	;(function (global) {
	    'use strict';
	
	/*
	  big.js v3.1.3
	  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.
	  https://github.com/MikeMcl/big.js/
	  Copyright (c) 2014 Michael Mclaughlin <M8ch88l@gmail.com>
	  MIT Expat Licence
	*/
	
	/***************************** EDITABLE DEFAULTS ******************************/
	
	    // The default values below must be integers within the stated ranges.
	
	    /*
	     * The maximum number of decimal places of the results of operations
	     * involving division: div and sqrt, and pow with negative exponents.
	     */
	    var DP = 20,                           // 0 to MAX_DP
	
	        /*
	         * The rounding mode used when rounding to the above decimal places.
	         *
	         * 0 Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)
	         * 1 To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)
	         * 2 To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)
	         * 3 Away from zero.                                  (ROUND_UP)
	         */
	        RM = 1,                            // 0, 1, 2 or 3
	
	        // The maximum value of DP and Big.DP.
	        MAX_DP = 1E6,                      // 0 to 1000000
	
	        // The maximum magnitude of the exponent argument to the pow method.
	        MAX_POWER = 1E6,                   // 1 to 1000000
	
	        /*
	         * The exponent value at and beneath which toString returns exponential
	         * notation.
	         * JavaScript's Number type: -7
	         * -1000000 is the minimum recommended exponent value of a Big.
	         */
	        E_NEG = -7,                   // 0 to -1000000
	
	        /*
	         * The exponent value at and above which toString returns exponential
	         * notation.
	         * JavaScript's Number type: 21
	         * 1000000 is the maximum recommended exponent value of a Big.
	         * (This limit is not enforced or checked.)
	         */
	        E_POS = 21,                   // 0 to 1000000
	
	/******************************************************************************/
	
	        // The shared prototype object.
	        P = {},
	        isValid = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
	        Big;
	
	
	    /*
	     * Create and return a Big constructor.
	     *
	     */
	    function bigFactory() {
	
	        /*
	         * The Big constructor and exported function.
	         * Create and return a new instance of a Big number object.
	         *
	         * n {number|string|Big} A numeric value.
	         */
	        function Big(n) {
	            var x = this;
	
	            // Enable constructor usage without new.
	            if (!(x instanceof Big)) {
	                return n === void 0 ? bigFactory() : new Big(n);
	            }
	
	            // Duplicate.
	            if (n instanceof Big) {
	                x.s = n.s;
	                x.e = n.e;
	                x.c = n.c.slice();
	            } else {
	                parse(x, n);
	            }
	
	            /*
	             * Retain a reference to this Big constructor, and shadow
	             * Big.prototype.constructor which points to Object.
	             */
	            x.constructor = Big;
	        }
	
	        Big.prototype = P;
	        Big.DP = DP;
	        Big.RM = RM;
	        Big.E_NEG = E_NEG;
	        Big.E_POS = E_POS;
	
	        return Big;
	    }
	
	
	    // Private functions
	
	
	    /*
	     * Return a string representing the value of Big x in normal or exponential
	     * notation to dp fixed decimal places or significant digits.
	     *
	     * x {Big} The Big to format.
	     * dp {number} Integer, 0 to MAX_DP inclusive.
	     * toE {number} 1 (toExponential), 2 (toPrecision) or undefined (toFixed).
	     */
	    function format(x, dp, toE) {
	        var Big = x.constructor,
	
	            // The index (normal notation) of the digit that may be rounded up.
	            i = dp - (x = new Big(x)).e,
	            c = x.c;
	
	        // Round?
	        if (c.length > ++dp) {
	            rnd(x, i, Big.RM);
	        }
	
	        if (!c[0]) {
	            ++i;
	        } else if (toE) {
	            i = dp;
	
	        // toFixed
	        } else {
	            c = x.c;
	
	            // Recalculate i as x.e may have changed if value rounded up.
	            i = x.e + i + 1;
	        }
	
	        // Append zeros?
	        for (; c.length < i; c.push(0)) {
	        }
	        i = x.e;
	
	        /*
	         * toPrecision returns exponential notation if the number of
	         * significant digits specified is less than the number of digits
	         * necessary to represent the integer part of the value in normal
	         * notation.
	         */
	        return toE === 1 || toE && (dp <= i || i <= Big.E_NEG) ?
	
	          // Exponential notation.
	          (x.s < 0 && c[0] ? '-' : '') +
	            (c.length > 1 ? c[0] + '.' + c.join('').slice(1) : c[0]) +
	              (i < 0 ? 'e' : 'e+') + i
	
	          // Normal notation.
	          : x.toString();
	    }
	
	
	    /*
	     * Parse the number or string value passed to a Big constructor.
	     *
	     * x {Big} A Big number instance.
	     * n {number|string} A numeric value.
	     */
	    function parse(x, n) {
	        var e, i, nL;
	
	        // Minus zero?
	        if (n === 0 && 1 / n < 0) {
	            n = '-0';
	
	        // Ensure n is string and check validity.
	        } else if (!isValid.test(n += '')) {
	            throwErr(NaN);
	        }
	
	        // Determine sign.
	        x.s = n.charAt(0) == '-' ? (n = n.slice(1), -1) : 1;
	
	        // Decimal point?
	        if ((e = n.indexOf('.')) > -1) {
	            n = n.replace('.', '');
	        }
	
	        // Exponential form?
	        if ((i = n.search(/e/i)) > 0) {
	
	            // Determine exponent.
	            if (e < 0) {
	                e = i;
	            }
	            e += +n.slice(i + 1);
	            n = n.substring(0, i);
	
	        } else if (e < 0) {
	
	            // Integer.
	            e = n.length;
	        }
	
	        // Determine leading zeros.
	        for (i = 0; n.charAt(i) == '0'; i++) {
	        }
	
	        if (i == (nL = n.length)) {
	
	            // Zero.
	            x.c = [ x.e = 0 ];
	        } else {
	
	            // Determine trailing zeros.
	            for (; n.charAt(--nL) == '0';) {
	            }
	
	            x.e = e - i - 1;
	            x.c = [];
	
	            // Convert string to array of digits without leading/trailing zeros.
	            for (e = 0; i <= nL; x.c[e++] = +n.charAt(i++)) {
	            }
	        }
	
	        return x;
	    }
	
	
	    /*
	     * Round Big x to a maximum of dp decimal places using rounding mode rm.
	     * Called by div, sqrt and round.
	     *
	     * x {Big} The Big to round.
	     * dp {number} Integer, 0 to MAX_DP inclusive.
	     * rm {number} 0, 1, 2 or 3 (DOWN, HALF_UP, HALF_EVEN, UP)
	     * [more] {boolean} Whether the result of division was truncated.
	     */
	    function rnd(x, dp, rm, more) {
	        var u,
	            xc = x.c,
	            i = x.e + dp + 1;
	
	        if (rm === 1) {
	
	            // xc[i] is the digit after the digit that may be rounded up.
	            more = xc[i] >= 5;
	        } else if (rm === 2) {
	            more = xc[i] > 5 || xc[i] == 5 &&
	              (more || i < 0 || xc[i + 1] !== u || xc[i - 1] & 1);
	        } else if (rm === 3) {
	            more = more || xc[i] !== u || i < 0;
	        } else {
	            more = false;
	
	            if (rm !== 0) {
	                throwErr('!Big.RM!');
	            }
	        }
	
	        if (i < 1 || !xc[0]) {
	
	            if (more) {
	
	                // 1, 0.1, 0.01, 0.001, 0.0001 etc.
	                x.e = -dp;
	                x.c = [1];
	            } else {
	
	                // Zero.
	                x.c = [x.e = 0];
	            }
	        } else {
	
	            // Remove any digits after the required decimal places.
	            xc.length = i--;
	
	            // Round up?
	            if (more) {
	
	                // Rounding up may mean the previous digit has to be rounded up.
	                for (; ++xc[i] > 9;) {
	                    xc[i] = 0;
	
	                    if (!i--) {
	                        ++x.e;
	                        xc.unshift(1);
	                    }
	                }
	            }
	
	            // Remove trailing zeros.
	            for (i = xc.length; !xc[--i]; xc.pop()) {
	            }
	        }
	
	        return x;
	    }
	
	
	    /*
	     * Throw a BigError.
	     *
	     * message {string} The error message.
	     */
	    function throwErr(message) {
	        var err = new Error(message);
	        err.name = 'BigError';
	
	        throw err;
	    }
	
	
	    // Prototype/instance methods
	
	
	    /*
	     * Return a new Big whose value is the absolute value of this Big.
	     */
	    P.abs = function () {
	        var x = new this.constructor(this);
	        x.s = 1;
	
	        return x;
	    };
	
	
	    /*
	     * Return
	     * 1 if the value of this Big is greater than the value of Big y,
	     * -1 if the value of this Big is less than the value of Big y, or
	     * 0 if they have the same value.
	    */
	    P.cmp = function (y) {
	        var xNeg,
	            x = this,
	            xc = x.c,
	            yc = (y = new x.constructor(y)).c,
	            i = x.s,
	            j = y.s,
	            k = x.e,
	            l = y.e;
	
	        // Either zero?
	        if (!xc[0] || !yc[0]) {
	            return !xc[0] ? !yc[0] ? 0 : -j : i;
	        }
	
	        // Signs differ?
	        if (i != j) {
	            return i;
	        }
	        xNeg = i < 0;
	
	        // Compare exponents.
	        if (k != l) {
	            return k > l ^ xNeg ? 1 : -1;
	        }
	
	        i = -1;
	        j = (k = xc.length) < (l = yc.length) ? k : l;
	
	        // Compare digit by digit.
	        for (; ++i < j;) {
	
	            if (xc[i] != yc[i]) {
	                return xc[i] > yc[i] ^ xNeg ? 1 : -1;
	            }
	        }
	
	        // Compare lengths.
	        return k == l ? 0 : k > l ^ xNeg ? 1 : -1;
	    };
	
	
	    /*
	     * Return a new Big whose value is the value of this Big divided by the
	     * value of Big y, rounded, if necessary, to a maximum of Big.DP decimal
	     * places using rounding mode Big.RM.
	     */
	    P.div = function (y) {
	        var x = this,
	            Big = x.constructor,
	            // dividend
	            dvd = x.c,
	            //divisor
	            dvs = (y = new Big(y)).c,
	            s = x.s == y.s ? 1 : -1,
	            dp = Big.DP;
	
	        if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
	            throwErr('!Big.DP!');
	        }
	
	        // Either 0?
	        if (!dvd[0] || !dvs[0]) {
	
	            // If both are 0, throw NaN
	            if (dvd[0] == dvs[0]) {
	                throwErr(NaN);
	            }
	
	            // If dvs is 0, throw +-Infinity.
	            if (!dvs[0]) {
	                throwErr(s / 0);
	            }
	
	            // dvd is 0, return +-0.
	            return new Big(s * 0);
	        }
	
	        var dvsL, dvsT, next, cmp, remI, u,
	            dvsZ = dvs.slice(),
	            dvdI = dvsL = dvs.length,
	            dvdL = dvd.length,
	            // remainder
	            rem = dvd.slice(0, dvsL),
	            remL = rem.length,
	            // quotient
	            q = y,
	            qc = q.c = [],
	            qi = 0,
	            digits = dp + (q.e = x.e - y.e) + 1;
	
	        q.s = s;
	        s = digits < 0 ? 0 : digits;
	
	        // Create version of divisor with leading zero.
	        dvsZ.unshift(0);
	
	        // Add zeros to make remainder as long as divisor.
	        for (; remL++ < dvsL; rem.push(0)) {
	        }
	
	        do {
	
	            // 'next' is how many times the divisor goes into current remainder.
	            for (next = 0; next < 10; next++) {
	
	                // Compare divisor and remainder.
	                if (dvsL != (remL = rem.length)) {
	                    cmp = dvsL > remL ? 1 : -1;
	                } else {
	
	                    for (remI = -1, cmp = 0; ++remI < dvsL;) {
	
	                        if (dvs[remI] != rem[remI]) {
	                            cmp = dvs[remI] > rem[remI] ? 1 : -1;
	                            break;
	                        }
	                    }
	                }
	
	                // If divisor < remainder, subtract divisor from remainder.
	                if (cmp < 0) {
	
	                    // Remainder can't be more than 1 digit longer than divisor.
	                    // Equalise lengths using divisor with extra leading zero?
	                    for (dvsT = remL == dvsL ? dvs : dvsZ; remL;) {
	
	                        if (rem[--remL] < dvsT[remL]) {
	                            remI = remL;
	
	                            for (; remI && !rem[--remI]; rem[remI] = 9) {
	                            }
	                            --rem[remI];
	                            rem[remL] += 10;
	                        }
	                        rem[remL] -= dvsT[remL];
	                    }
	                    for (; !rem[0]; rem.shift()) {
	                    }
	                } else {
	                    break;
	                }
	            }
	
	            // Add the 'next' digit to the result array.
	            qc[qi++] = cmp ? next : ++next;
	
	            // Update the remainder.
	            if (rem[0] && cmp) {
	                rem[remL] = dvd[dvdI] || 0;
	            } else {
	                rem = [ dvd[dvdI] ];
	            }
	
	        } while ((dvdI++ < dvdL || rem[0] !== u) && s--);
	
	        // Leading zero? Do not remove if result is simply zero (qi == 1).
	        if (!qc[0] && qi != 1) {
	
	            // There can't be more than one zero.
	            qc.shift();
	            q.e--;
	        }
	
	        // Round?
	        if (qi > digits) {
	            rnd(q, dp, Big.RM, rem[0] !== u);
	        }
	
	        return q;
	    };
	
	
	    /*
	     * Return true if the value of this Big is equal to the value of Big y,
	     * otherwise returns false.
	     */
	    P.eq = function (y) {
	        return !this.cmp(y);
	    };
	
	
	    /*
	     * Return true if the value of this Big is greater than the value of Big y,
	     * otherwise returns false.
	     */
	    P.gt = function (y) {
	        return this.cmp(y) > 0;
	    };
	
	
	    /*
	     * Return true if the value of this Big is greater than or equal to the
	     * value of Big y, otherwise returns false.
	     */
	    P.gte = function (y) {
	        return this.cmp(y) > -1;
	    };
	
	
	    /*
	     * Return true if the value of this Big is less than the value of Big y,
	     * otherwise returns false.
	     */
	    P.lt = function (y) {
	        return this.cmp(y) < 0;
	    };
	
	
	    /*
	     * Return true if the value of this Big is less than or equal to the value
	     * of Big y, otherwise returns false.
	     */
	    P.lte = function (y) {
	         return this.cmp(y) < 1;
	    };
	
	
	    /*
	     * Return a new Big whose value is the value of this Big minus the value
	     * of Big y.
	     */
	    P.sub = P.minus = function (y) {
	        var i, j, t, xLTy,
	            x = this,
	            Big = x.constructor,
	            a = x.s,
	            b = (y = new Big(y)).s;
	
	        // Signs differ?
	        if (a != b) {
	            y.s = -b;
	            return x.plus(y);
	        }
	
	        var xc = x.c.slice(),
	            xe = x.e,
	            yc = y.c,
	            ye = y.e;
	
	        // Either zero?
	        if (!xc[0] || !yc[0]) {
	
	            // y is non-zero? x is non-zero? Or both are zero.
	            return yc[0] ? (y.s = -b, y) : new Big(xc[0] ? x : 0);
	        }
	
	        // Determine which is the bigger number.
	        // Prepend zeros to equalise exponents.
	        if (a = xe - ye) {
	
	            if (xLTy = a < 0) {
	                a = -a;
	                t = xc;
	            } else {
	                ye = xe;
	                t = yc;
	            }
	
	            t.reverse();
	            for (b = a; b--; t.push(0)) {
	            }
	            t.reverse();
	        } else {
	
	            // Exponents equal. Check digit by digit.
	            j = ((xLTy = xc.length < yc.length) ? xc : yc).length;
	
	            for (a = b = 0; b < j; b++) {
	
	                if (xc[b] != yc[b]) {
	                    xLTy = xc[b] < yc[b];
	                    break;
	                }
	            }
	        }
	
	        // x < y? Point xc to the array of the bigger number.
	        if (xLTy) {
	            t = xc;
	            xc = yc;
	            yc = t;
	            y.s = -y.s;
	        }
	
	        /*
	         * Append zeros to xc if shorter. No need to add zeros to yc if shorter
	         * as subtraction only needs to start at yc.length.
	         */
	        if (( b = (j = yc.length) - (i = xc.length) ) > 0) {
	
	            for (; b--; xc[i++] = 0) {
	            }
	        }
	
	        // Subtract yc from xc.
	        for (b = i; j > a;){
	
	            if (xc[--j] < yc[j]) {
	
	                for (i = j; i && !xc[--i]; xc[i] = 9) {
	                }
	                --xc[i];
	                xc[j] += 10;
	            }
	            xc[j] -= yc[j];
	        }
	
	        // Remove trailing zeros.
	        for (; xc[--b] === 0; xc.pop()) {
	        }
	
	        // Remove leading zeros and adjust exponent accordingly.
	        for (; xc[0] === 0;) {
	            xc.shift();
	            --ye;
	        }
	
	        if (!xc[0]) {
	
	            // n - n = +0
	            y.s = 1;
	
	            // Result must be zero.
	            xc = [ye = 0];
	        }
	
	        y.c = xc;
	        y.e = ye;
	
	        return y;
	    };
	
	
	    /*
	     * Return a new Big whose value is the value of this Big modulo the
	     * value of Big y.
	     */
	    P.mod = function (y) {
	        var yGTx,
	            x = this,
	            Big = x.constructor,
	            a = x.s,
	            b = (y = new Big(y)).s;
	
	        if (!y.c[0]) {
	            throwErr(NaN);
	        }
	
	        x.s = y.s = 1;
	        yGTx = y.cmp(x) == 1;
	        x.s = a;
	        y.s = b;
	
	        if (yGTx) {
	            return new Big(x);
	        }
	
	        a = Big.DP;
	        b = Big.RM;
	        Big.DP = Big.RM = 0;
	        x = x.div(y);
	        Big.DP = a;
	        Big.RM = b;
	
	        return this.minus( x.times(y) );
	    };
	
	
	    /*
	     * Return a new Big whose value is the value of this Big plus the value
	     * of Big y.
	     */
	    P.add = P.plus = function (y) {
	        var t,
	            x = this,
	            Big = x.constructor,
	            a = x.s,
	            b = (y = new Big(y)).s;
	
	        // Signs differ?
	        if (a != b) {
	            y.s = -b;
	            return x.minus(y);
	        }
	
	        var xe = x.e,
	            xc = x.c,
	            ye = y.e,
	            yc = y.c;
	
	        // Either zero?
	        if (!xc[0] || !yc[0]) {
	
	            // y is non-zero? x is non-zero? Or both are zero.
	            return yc[0] ? y : new Big(xc[0] ? x : a * 0);
	        }
	        xc = xc.slice();
	
	        // Prepend zeros to equalise exponents.
	        // Note: Faster to use reverse then do unshifts.
	        if (a = xe - ye) {
	
	            if (a > 0) {
	                ye = xe;
	                t = yc;
	            } else {
	                a = -a;
	                t = xc;
	            }
	
	            t.reverse();
	            for (; a--; t.push(0)) {
	            }
	            t.reverse();
	        }
	
	        // Point xc to the longer array.
	        if (xc.length - yc.length < 0) {
	            t = yc;
	            yc = xc;
	            xc = t;
	        }
	        a = yc.length;
	
	        /*
	         * Only start adding at yc.length - 1 as the further digits of xc can be
	         * left as they are.
	         */
	        for (b = 0; a;) {
	            b = (xc[--a] = xc[a] + yc[a] + b) / 10 | 0;
	            xc[a] %= 10;
	        }
	
	        // No need to check for zero, as +x + +y != 0 && -x + -y != 0
	
	        if (b) {
	            xc.unshift(b);
	            ++ye;
	        }
	
	         // Remove trailing zeros.
	        for (a = xc.length; xc[--a] === 0; xc.pop()) {
	        }
	
	        y.c = xc;
	        y.e = ye;
	
	        return y;
	    };
	
	
	    /*
	     * Return a Big whose value is the value of this Big raised to the power n.
	     * If n is negative, round, if necessary, to a maximum of Big.DP decimal
	     * places using rounding mode Big.RM.
	     *
	     * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.
	     */
	    P.pow = function (n) {
	        var x = this,
	            one = new x.constructor(1),
	            y = one,
	            isNeg = n < 0;
	
	        if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {
	            throwErr('!pow!');
	        }
	
	        n = isNeg ? -n : n;
	
	        for (;;) {
	
	            if (n & 1) {
	                y = y.times(x);
	            }
	            n >>= 1;
	
	            if (!n) {
	                break;
	            }
	            x = x.times(x);
	        }
	
	        return isNeg ? one.div(y) : y;
	    };
	
	
	    /*
	     * Return a new Big whose value is the value of this Big rounded to a
	     * maximum of dp decimal places using rounding mode rm.
	     * If dp is not specified, round to 0 decimal places.
	     * If rm is not specified, use Big.RM.
	     *
	     * [dp] {number} Integer, 0 to MAX_DP inclusive.
	     * [rm] 0, 1, 2 or 3 (ROUND_DOWN, ROUND_HALF_UP, ROUND_HALF_EVEN, ROUND_UP)
	     */
	    P.round = function (dp, rm) {
	        var x = this,
	            Big = x.constructor;
	
	        if (dp == null) {
	            dp = 0;
	        } else if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
	            throwErr('!round!');
	        }
	        rnd(x = new Big(x), dp, rm == null ? Big.RM : rm);
	
	        return x;
	    };
	
	
	    /*
	     * Return a new Big whose value is the square root of the value of this Big,
	     * rounded, if necessary, to a maximum of Big.DP decimal places using
	     * rounding mode Big.RM.
	     */
	    P.sqrt = function () {
	        var estimate, r, approx,
	            x = this,
	            Big = x.constructor,
	            xc = x.c,
	            i = x.s,
	            e = x.e,
	            half = new Big('0.5');
	
	        // Zero?
	        if (!xc[0]) {
	            return new Big(x);
	        }
	
	        // If negative, throw NaN.
	        if (i < 0) {
	            throwErr(NaN);
	        }
	
	        // Estimate.
	        i = Math.sqrt(x.toString());
	
	        // Math.sqrt underflow/overflow?
	        // Pass x to Math.sqrt as integer, then adjust the result exponent.
	        if (i === 0 || i === 1 / 0) {
	            estimate = xc.join('');
	
	            if (!(estimate.length + e & 1)) {
	                estimate += '0';
	            }
	
	            r = new Big( Math.sqrt(estimate).toString() );
	            r.e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
	        } else {
	            r = new Big(i.toString());
	        }
	
	        i = r.e + (Big.DP += 4);
	
	        // Newton-Raphson iteration.
	        do {
	            approx = r;
	            r = half.times( approx.plus( x.div(approx) ) );
	        } while ( approx.c.slice(0, i).join('') !==
	                       r.c.slice(0, i).join('') );
	
	        rnd(r, Big.DP -= 4, Big.RM);
	
	        return r;
	    };
	
	
	    /*
	     * Return a new Big whose value is the value of this Big times the value of
	     * Big y.
	     */
	    P.mul = P.times = function (y) {
	        var c,
	            x = this,
	            Big = x.constructor,
	            xc = x.c,
	            yc = (y = new Big(y)).c,
	            a = xc.length,
	            b = yc.length,
	            i = x.e,
	            j = y.e;
	
	        // Determine sign of result.
	        y.s = x.s == y.s ? 1 : -1;
	
	        // Return signed 0 if either 0.
	        if (!xc[0] || !yc[0]) {
	            return new Big(y.s * 0);
	        }
	
	        // Initialise exponent of result as x.e + y.e.
	        y.e = i + j;
	
	        // If array xc has fewer digits than yc, swap xc and yc, and lengths.
	        if (a < b) {
	            c = xc;
	            xc = yc;
	            yc = c;
	            j = a;
	            a = b;
	            b = j;
	        }
	
	        // Initialise coefficient array of result with zeros.
	        for (c = new Array(j = a + b); j--; c[j] = 0) {
	        }
	
	        // Multiply.
	
	        // i is initially xc.length.
	        for (i = b; i--;) {
	            b = 0;
	
	            // a is yc.length.
	            for (j = a + i; j > i;) {
	
	                // Current sum of products at this digit position, plus carry.
	                b = c[j] + yc[i] * xc[j - i - 1] + b;
	                c[j--] = b % 10;
	
	                // carry
	                b = b / 10 | 0;
	            }
	            c[j] = (c[j] + b) % 10;
	        }
	
	        // Increment result exponent if there is a final carry.
	        if (b) {
	            ++y.e;
	        }
	
	        // Remove any leading zero.
	        if (!c[0]) {
	            c.shift();
	        }
	
	        // Remove trailing zeros.
	        for (i = c.length; !c[--i]; c.pop()) {
	        }
	        y.c = c;
	
	        return y;
	    };
	
	
	    /*
	     * Return a string representing the value of this Big.
	     * Return exponential notation if this Big has a positive exponent equal to
	     * or greater than Big.E_POS, or a negative exponent equal to or less than
	     * Big.E_NEG.
	     */
	    P.toString = P.valueOf = P.toJSON = function () {
	        var x = this,
	            Big = x.constructor,
	            e = x.e,
	            str = x.c.join(''),
	            strL = str.length;
	
	        // Exponential notation?
	        if (e <= Big.E_NEG || e >= Big.E_POS) {
	            str = str.charAt(0) + (strL > 1 ? '.' + str.slice(1) : '') +
	              (e < 0 ? 'e' : 'e+') + e;
	
	        // Negative exponent?
	        } else if (e < 0) {
	
	            // Prepend zeros.
	            for (; ++e; str = '0' + str) {
	            }
	            str = '0.' + str;
	
	        // Positive exponent?
	        } else if (e > 0) {
	
	            if (++e > strL) {
	
	                // Append zeros.
	                for (e -= strL; e-- ; str += '0') {
	                }
	            } else if (e < strL) {
	                str = str.slice(0, e) + '.' + str.slice(e);
	            }
	
	        // Exponent zero.
	        } else if (strL > 1) {
	            str = str.charAt(0) + '.' + str.slice(1);
	        }
	
	        // Avoid '-0'
	        return x.s < 0 && x.c[0] ? '-' + str : str;
	    };
	
	
	    /*
	     ***************************************************************************
	     * If toExponential, toFixed, toPrecision and format are not required they
	     * can safely be commented-out or deleted. No redundant code will be left.
	     * format is used only by toExponential, toFixed and toPrecision.
	     ***************************************************************************
	     */
	
	
	    /*
	     * Return a string representing the value of this Big in exponential
	     * notation to dp fixed decimal places and rounded, if necessary, using
	     * Big.RM.
	     *
	     * [dp] {number} Integer, 0 to MAX_DP inclusive.
	     */
	    P.toExponential = function (dp) {
	
	        if (dp == null) {
	            dp = this.c.length - 1;
	        } else if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
	            throwErr('!toExp!');
	        }
	
	        return format(this, dp, 1);
	    };
	
	
	    /*
	     * Return a string representing the value of this Big in normal notation
	     * to dp fixed decimal places and rounded, if necessary, using Big.RM.
	     *
	     * [dp] {number} Integer, 0 to MAX_DP inclusive.
	     */
	    P.toFixed = function (dp) {
	        var str,
	            x = this,
	            Big = x.constructor,
	            neg = Big.E_NEG,
	            pos = Big.E_POS;
	
	        // Prevent the possibility of exponential notation.
	        Big.E_NEG = -(Big.E_POS = 1 / 0);
	
	        if (dp == null) {
	            str = x.toString();
	        } else if (dp === ~~dp && dp >= 0 && dp <= MAX_DP) {
	            str = format(x, x.e + dp);
	
	            // (-0).toFixed() is '0', but (-0.1).toFixed() is '-0'.
	            // (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
	            if (x.s < 0 && x.c[0] && str.indexOf('-') < 0) {
	        //E.g. -0.5 if rounded to -0 will cause toString to omit the minus sign.
	                str = '-' + str;
	            }
	        }
	        Big.E_NEG = neg;
	        Big.E_POS = pos;
	
	        if (!str) {
	            throwErr('!toFix!');
	        }
	
	        return str;
	    };
	
	
	    /*
	     * Return a string representing the value of this Big rounded to sd
	     * significant digits using Big.RM. Use exponential notation if sd is less
	     * than the number of digits necessary to represent the integer part of the
	     * value in normal notation.
	     *
	     * sd {number} Integer, 1 to MAX_DP inclusive.
	     */
	    P.toPrecision = function (sd) {
	
	        if (sd == null) {
	            return this.toString();
	        } else if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
	            throwErr('!toPre!');
	        }
	
	        return format(this, sd - 1, 2);
	    };
	
	
	    // Export
	
	
	    Big = bigFactory();
	
	    //AMD.
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return Big;
	        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	
	    // Node and other CommonJS-like environments that support module.exports.
	    } else if (typeof module !== 'undefined' && module.exports) {
	        module.exports = Big;
	
	    //Browser.
	    } else {
	        global.Big = Big;
	    }
	})(this);


/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname) {/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var loaderUtils = __webpack_require__(365);
	var NodeTemplatePlugin = __webpack_require__(203);
	var NodeTargetPlugin = __webpack_require__(303);
	var LibraryTemplatePlugin = __webpack_require__(308);
	var SingleEntryPlugin = __webpack_require__(98);
	var LimitChunkCountPlugin = __webpack_require__(321);
	module.exports = function(source) {
		if(this.cacheable) this.cacheable();
		return source;
	};
	module.exports.pitch = function(request) {
		if(this.cacheable) this.cacheable();
		var query = loaderUtils.parseQuery(this.query);
		this.addDependency(this.resourcePath);
		// We already in child compiler, return empty bundle
		if(this[__dirname] === undefined) {
			throw new Error(
				'"extract-text-webpack-plugin" loader is used without the corresponding plugin, ' +
				'refer to https://github.com/webpack/extract-text-webpack-plugin for the usage example'
			);
		} else if(this[__dirname] === false) {
			return "";
		} else if(this[__dirname](null, query)) {
			if(query.omit) {
				this.loaderIndex += +query.omit + 1;
				request = request.split("!").slice(+query.omit).join("!");
			}
			var resultSource;
			if(query.remove) {
				resultSource = "// removed by extract-text-webpack-plugin";
			} else {
				resultSource = undefined;
			}
	
			if(query.extract !== false) {
				var childFilename = "extract-text-webpack-plugin-output-filename"; // eslint-disable-line no-path-concat
				var publicPath = typeof query.publicPath === "string" ? query.publicPath : this._compilation.outputOptions.publicPath;
				var outputOptions = {
					filename: childFilename,
					publicPath: publicPath
				};
				var childCompiler = this._compilation.createChildCompiler("extract-text-webpack-plugin", outputOptions);
				childCompiler.apply(new NodeTemplatePlugin(outputOptions));
				childCompiler.apply(new LibraryTemplatePlugin(null, "commonjs2"));
				childCompiler.apply(new NodeTargetPlugin());
				childCompiler.apply(new SingleEntryPlugin(this.context, "!!" + request));
				childCompiler.apply(new LimitChunkCountPlugin({ maxChunks: 1 }));
				var subCache = "subcache " + __dirname + " " + request; // eslint-disable-line no-path-concat
				childCompiler.plugin("compilation", function(compilation) {
					if(compilation.cache) {
						if(!compilation.cache[subCache])
							compilation.cache[subCache] = {};
						compilation.cache = compilation.cache[subCache];
					}
				});
				// We set loaderContext[__dirname] = false to indicate we already in
				// a child compiler so we don't spawn another child compilers from there.
				childCompiler.plugin("this-compilation", function(compilation) {
					compilation.plugin("normal-module-loader", function(loaderContext) {
						loaderContext[__dirname] = false;
					});
				});
				var source;
				childCompiler.plugin("after-compile", function(compilation, callback) {
					source = compilation.assets[childFilename] && compilation.assets[childFilename].source();
	
					// Remove all chunk assets
					compilation.chunks.forEach(function(chunk) {
						chunk.files.forEach(function(file) {
							delete compilation.assets[file];
						});
					});
	
					callback();
				});
				var callback = this.async();
				childCompiler.runAsChild(function(err, entries, compilation) {
					if(err) return callback(err);
	
					if(compilation.errors.length > 0) {
						return callback(compilation.errors[0]);
					}
					compilation.fileDependencies.forEach(function(dep) {
						this.addDependency(dep);
					}, this);
					compilation.contextDependencies.forEach(function(dep) {
						this.addContextDependency(dep);
					}, this);
					if(!source) {
						return callback(new Error("Didn't get a result from child compiler"));
					}
					try {
						var text = this.exec(source, request);
						if(typeof text === "string")
							text = [[0, text]];
						text.forEach(function(item) {
							var id = item[0];
							compilation.modules.forEach(function(module) {
								if(module.id === id)
									item[0] = module.identifier();
							});
						});
						this[__dirname](text, query);
						if(text.locals && typeof resultSource !== "undefined") {
							resultSource += "\nmodule.exports = " + JSON.stringify(text.locals) + ";";
						}
					} catch(e) {
						return callback(e);
					}
					if(resultSource)
						callback(null, resultSource);
					else
						callback();
				}.bind(this));
			} else {
				this[__dirname]("", query);
				return resultSource;
			}
		}
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3dlYnBhY2svYm9vdHN0cmFwIDNjOTRiM2IyOWRmOTVjYTdjY2Y3IiwiLi4vLi4vLi93ZWJwYWNrLmNvbmZpZy52ZW5kb3IuanMiLCIuLi8uLi9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIGZyb20gZGxsLXJlZmVyZW5jZSB2ZW5kb3JfYWU5N2JhMWNiMjQxMmMxYTg2NDQiLCIuLi8uLi9leHRlcm5hbCBcInZlbmRvcl9hZTk3YmExY2IyNDEyYzFhODY0NFwiIiwiLi4vLi4vLi9+L3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvd2VicGFjay53ZWIuanMiLCIuLi8uLi8od2VicGFjaykvbGliL0NvbXBpbGVyLmpzIiwiLi4vLi4vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgdmVuZG9yX2FlOTdiYTFjYjI0MTJjMWE4NjQ0IiwiLi4vLi4vLi9+L3RhcGFibGUvbGliL1RhcGFibGUuanMiLCIuLi8uLi8od2VicGFjaykvbGliL0NvbXBpbGF0aW9uLmpzIiwiLi4vLi4vLi9+L2FzeW5jL2xpYi9hc3luYy5qcyIsIi4uLy4uL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIGZyb20gZGxsLXJlZmVyZW5jZSB2ZW5kb3JfYWU5N2JhMWNiMjQxMmMxYTg2NDQiLCIuLi8uLi8od2VicGFjaykvbGliL0VudHJ5TW9kdWxlTm90Rm91bmRFcnJvci5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvTW9kdWxlTm90Rm91bmRFcnJvci5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvQ3JpdGljYWxEZXBlbmRlbmNpZXNXYXJuaW5nLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9Nb2R1bGUuanMiLCIuLi8uLi8od2VicGFjaykvbGliL0RlcGVuZGVuY2llc0Jsb2NrLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9EZXBlbmRlbmNpZXNCbG9ja1ZhcmlhYmxlLmpzIiwiLi4vLi4vKHdlYnBhY2spLWNvcmUvbGliL1JlcGxhY2VTb3VyY2UuanMiLCIuLi8uLi8od2VicGFjayktY29yZS9saWIvU291cmNlLmpzIiwiLi4vLi4vKHdlYnBhY2spLWNvcmUvfi9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLmpzIiwiLi4vLi4vKHdlYnBhY2spLWNvcmUvfi9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL3NvdXJjZS1tYXAtZ2VuZXJhdG9yLmpzIiwiLi4vLi4vKHdlYnBhY2spLWNvcmUvfi9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL2Jhc2U2NC12bHEuanMiLCIuLi8uLi8od2VicGFjayktY29yZS9+L3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvYmFzZTY0LmpzIiwiLi4vLi4vKHdlYnBhY2spLWNvcmUvfi9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL3V0aWwuanMiLCIuLi8uLi8od2VicGFjayktY29yZS9+L3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvYXJyYXktc2V0LmpzIiwiLi4vLi4vKHdlYnBhY2spLWNvcmUvfi9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL21hcHBpbmctbGlzdC5qcyIsIi4uLy4uLyh3ZWJwYWNrKS1jb3JlL34vc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9zb3VyY2UtbWFwLWNvbnN1bWVyLmpzIiwiLi4vLi4vKHdlYnBhY2spLWNvcmUvfi9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL2JpbmFyeS1zZWFyY2guanMiLCIuLi8uLi8od2VicGFjayktY29yZS9+L3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvcXVpY2stc29ydC5qcyIsIi4uLy4uLyh3ZWJwYWNrKS1jb3JlL34vc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9zb3VyY2Utbm9kZS5qcyIsIi4uLy4uLy4vfi9zb3VyY2UtbGlzdC1tYXAvbGliL2luZGV4LmpzIiwiLi4vLi4vLi9+L3NvdXJjZS1saXN0LW1hcC9saWIvU291cmNlTGlzdE1hcC5qcyIsIi4uLy4uLy4vfi9zb3VyY2UtbGlzdC1tYXAvbGliL0NvZGVOb2RlLmpzIiwiLi4vLi4vLi9+L3NvdXJjZS1saXN0LW1hcC9saWIvaGVscGVycy5qcyIsIi4uLy4uLy4vfi9zb3VyY2UtbGlzdC1tYXAvbGliL1NvdXJjZU5vZGUuanMiLCIuLi8uLi8uL34vc291cmNlLWxpc3QtbWFwL2xpYi9iYXNlNjQtdmxxLmpzIiwiLi4vLi4vLi9+L3NvdXJjZS1saXN0LW1hcC9saWIvTWFwcGluZ3NDb250ZXh0LmpzIiwiLi4vLi4vLi9+L3NvdXJjZS1saXN0LW1hcC9saWIvZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAuanMiLCIuLi8uLi8od2VicGFjayktY29yZS9saWIvU291cmNlQW5kTWFwTWl4aW4uanMiLCIuLi8uLi8od2VicGFjayktY29yZS9saWIvUmF3U291cmNlLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9Nb2R1bGVSZWFzb24uanMiLCIuLi8uLi8od2VicGFjaykvbGliL3JlbW92ZUFuZERvLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9BcnJheU1hcC5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvQ2h1bmsuanMiLCIuLi8uLi8od2VicGFjaykvbGliL1N0YXRzLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9SZXF1ZXN0U2hvcnRlbmVyLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9NYWluVGVtcGxhdGUuanMiLCIuLi8uLi8od2VicGFjayktY29yZS9saWIvQ29uY2F0U291cmNlLmpzIiwiLi4vLi4vKHdlYnBhY2spLWNvcmUvbGliL09yaWdpbmFsU291cmNlLmpzIiwiLi4vLi4vKHdlYnBhY2spLWNvcmUvbGliL1ByZWZpeFNvdXJjZS5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvVGVtcGxhdGUuanMiLCIuLi8uLi8od2VicGFjaykvbGliL0NodW5rVGVtcGxhdGUuanMiLCIuLi8uLi8od2VicGFjaykvbGliL0hvdFVwZGF0ZUNodW5rVGVtcGxhdGUuanMiLCIuLi8uLi8od2VicGFjaykvbGliL01vZHVsZVRlbXBsYXRlLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9EZXBlbmRlbmN5LmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9DaHVua1JlbmRlckVycm9yLmpzIiwiLi4vLi4vKHdlYnBhY2spLWNvcmUvbGliL0NhY2hlZFNvdXJjZS5qcyIsIi4uLy4uL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9pbmRleC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgdmVuZG9yX2FlOTdiYTFjYjI0MTJjMWE4NjQ0IiwiLi4vLi4vKHdlYnBhY2spL2xpYi9QYXJzZXIuanMiLCIuLi8uLi8uL34vYWNvcm4vZGlzdC9hY29ybi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uLmpzIiwiLi4vLi4vLi9+L2VuaGFuY2VkLXJlc29sdmUvbGliL1Jlc29sdmVyLmpzIiwiLi4vLi4vLi9+L2VuaGFuY2VkLXJlc29sdmUvbGliL2NyZWF0ZUlubmVyQ2FsbGJhY2suanMiLCIuLi8uLi8uL34vZW5oYW5jZWQtcmVzb2x2ZS9+L21lbW9yeS1mcy9saWIvam9pbi5qcyIsIi4uLy4uLy4vfi9lbmhhbmNlZC1yZXNvbHZlL34vbWVtb3J5LWZzL2xpYi9ub3JtYWxpemUuanMiLCIuLi8uLi8od2VicGFjaykvbGliL05vcm1hbE1vZHVsZUZhY3RvcnkuanMiLCIuLi8uLi8od2VicGFjaykvbGliL05vcm1hbE1vZHVsZS5qcyIsIi4uLy4uLyh3ZWJwYWNrKS1jb3JlL2xpYi9Ob3JtYWxNb2R1bGVNaXhpbi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS1jb3JlL2xpYi9Tb3VyY2VNYXBTb3VyY2UuanMiLCIuLi8uLi8od2VicGFjayktY29yZS9saWIvTGluZVRvTGluZU1hcHBlZFNvdXJjZS5qcyIsIi4uLy4uLyh3ZWJwYWNrKS1jb3JlL2xpYi9Nb2R1bGVCdWlsZEVycm9yLmpzIiwiLi4vLi4vKHdlYnBhY2spLWNvcmUvbGliL01vZHVsZUVycm9yLmpzIiwiLi4vLi4vKHdlYnBhY2spLWNvcmUvbGliL01vZHVsZVdhcm5pbmcuanMiLCIuLi8uLi8od2VicGFjaykvbGliL01vZHVsZVBhcnNlRXJyb3IuanMiLCIuLi8uLi8od2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9UZW1wbGF0ZUFyZ3VtZW50RGVwZW5kZW5jeS5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvQXN5bmNEZXBlbmRlbmNpZXNCbG9jay5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvUmF3TW9kdWxlLmpzIiwiLi4vLi4vKHdlYnBhY2spLWNvcmUvbGliL0xvYWRlcnNMaXN0LmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9Db250ZXh0TW9kdWxlRmFjdG9yeS5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvQ29udGV4dE1vZHVsZS5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL0NvbnRleHRFbGVtZW50RGVwZW5kZW5jeS5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL01vZHVsZURlcGVuZGVuY3kuanMiLCIuLi8uLi8od2VicGFjaykvbGliL3dlYi9XZWJFbnZpcm9ubWVudFBsdWdpbi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvV2VicGFja09wdGlvbnNBcHBseS5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvT3B0aW9uc0FwcGx5LmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9Mb2FkZXJUYXJnZXRQbHVnaW4uanMiLCIuLi8uLi8od2VicGFjaykvbGliL0Z1bmN0aW9uTW9kdWxlUGx1Z2luLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9GdW5jdGlvbk1vZHVsZVRlbXBsYXRlUGx1Z2luLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9FdmFsRGV2VG9vbE1vZHVsZVBsdWdpbi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvRXZhbERldlRvb2xNb2R1bGVUZW1wbGF0ZVBsdWdpbi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvTW9kdWxlRmlsZW5hbWVIZWxwZXJzLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9Tb3VyY2VNYXBEZXZUb29sUGx1Z2luLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9Tb3VyY2VNYXBEZXZUb29sTW9kdWxlT3B0aW9uc1BsdWdpbi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvRXZhbFNvdXJjZU1hcERldlRvb2xQbHVnaW4uanMiLCIuLi8uLi8od2VicGFjaykvbGliL0V2YWxTb3VyY2VNYXBEZXZUb29sTW9kdWxlVGVtcGxhdGVQbHVnaW4uanMiLCIuLi8uLi8od2VicGFjaykvbGliL0VudHJ5T3B0aW9uUGx1Z2luLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9TaW5nbGVFbnRyeVBsdWdpbi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL1NpbmdsZUVudHJ5RGVwZW5kZW5jeS5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvTXVsdGlFbnRyeVBsdWdpbi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL011bHRpRW50cnlEZXBlbmRlbmN5LmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9NdWx0aU1vZHVsZUZhY3RvcnkuanMiLCIuLi8uLi8od2VicGFjaykvbGliL011bHRpTW9kdWxlLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9SZWNvcmRJZHNQbHVnaW4uanMiLCIuLi8uLi8od2VicGFjaykvbGliL0FQSVBsdWdpbi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL0NvbnN0RGVwZW5kZW5jeS5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL051bGxEZXBlbmRlbmN5LmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9OdWxsRmFjdG9yeS5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvQ29uc3RQbHVnaW4uanMiLCIuLi8uLi8od2VicGFjaykvbGliL1JlcXVpcmVKc1N0dWZmUGx1Z2luLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9Ob2RlU3R1ZmZQbHVnaW4uanMiLCIuLi8uLi8od2VicGFjaykvbGliL01vZHVsZVBhcnNlckhlbHBlcnMuanMiLCIuLi8uLi8od2VicGFjaykvbGliL1Vuc3VwcG9ydGVkRmVhdHVyZVdhcm5pbmcuanMiLCIuLi8uLi8od2VicGFjaykvbGliL0NvbXBhdGliaWxpdHlQbHVnaW4uanMiLCIuLi8uLi8uL34vZW5oYW5jZWQtcmVzb2x2ZS9saWIvTW9kdWxlQWxpYXNQbHVnaW4uanMiLCIuLi8uLi8od2VicGFjaykvbGliL0RlZmluZVBsdWdpbi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvTW92ZWRUb1BsdWdpbldhcm5pbmdQbHVnaW4uanMiLCIuLi8uLi8od2VicGFjaykvbGliL1RlbXBsYXRlZFBhdGhQbHVnaW4uanMiLCIuLi8uLi8od2VicGFjaykvbGliL1dhcm5DYXNlU2Vuc2l0aXZlTW9kdWxlc1BsdWdpbi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvQ2FzZVNlbnNpdGl2ZU1vZHVsZXNXYXJuaW5nLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvTG9hZGVyUGx1Z2luLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvTG9hZGVyRGVwZW5kZW5jeS5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL0NvbW1vbkpzUGx1Z2luLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvQ29tbW9uSnNSZXF1aXJlRGVwZW5kZW5jeS5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL01vZHVsZURlcGVuZGVuY3lUZW1wbGF0ZUFzSWQuanMiLCIuLi8uLi8od2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9XZWJwYWNrTWlzc2luZ01vZHVsZS5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL0NvbW1vbkpzUmVxdWlyZUNvbnRleHREZXBlbmRlbmN5LmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvQ29udGV4dERlcGVuZGVuY3kuanMiLCIuLi8uLi8od2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9Db250ZXh0RGVwZW5kZW5jeVRlbXBsYXRlQXNSZXF1aXJlQ2FsbC5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL1JlcXVpcmVSZXNvbHZlRGVwZW5kZW5jeS5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL1JlcXVpcmVSZXNvbHZlQ29udGV4dERlcGVuZGVuY3kuanMiLCIuLi8uLi8od2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9Db250ZXh0RGVwZW5kZW5jeVRlbXBsYXRlQXNJZC5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL1JlcXVpcmVSZXNvbHZlSGVhZGVyRGVwZW5kZW5jeS5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL1JlcXVpcmVIZWFkZXJEZXBlbmRlbmN5LmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvUmVxdWlyZVJlc29sdmVEZXBlbmRlbmN5UGFyc2VyUGx1Z2luLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvQ29udGV4dERlcGVuZGVuY3lIZWxwZXJzLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvQ29tbW9uSnNSZXF1aXJlRGVwZW5kZW5jeVBhcnNlclBsdWdpbi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL0xvY2FsTW9kdWxlRGVwZW5kZW5jeS5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL0xvY2FsTW9kdWxlc0hlbHBlcnMuanMiLCIuLi8uLi8od2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9Mb2NhbE1vZHVsZS5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL0FNRFBsdWdpbi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL0FNRFJlcXVpcmVEZXBlbmRlbmN5LmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvRGVwQmxvY2tIZWxwZXJzLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvQU1EUmVxdWlyZUl0ZW1EZXBlbmRlbmN5LmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvTW9kdWxlRGVwZW5kZW5jeVRlbXBsYXRlQXNSZXF1aXJlSWQuanMiLCIuLi8uLi8od2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9BTURSZXF1aXJlQXJyYXlEZXBlbmRlbmN5LmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvQU1EUmVxdWlyZUNvbnRleHREZXBlbmRlbmN5LmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvQU1ERGVmaW5lRGVwZW5kZW5jeS5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL0FNRFJlcXVpcmVEZXBlbmRlbmNpZXNCbG9ja1BhcnNlclBsdWdpbi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL0FNRFJlcXVpcmVEZXBlbmRlbmNpZXNCbG9jay5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL2dldEZ1bmN0aW9uRXhwcmVzc2lvbi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL0FNRERlZmluZURlcGVuZGVuY3lQYXJzZXJQbHVnaW4uanMiLCIuLi8uLi8od2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9SZXF1aXJlQ29udGV4dFBsdWdpbi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL1JlcXVpcmVDb250ZXh0RGVwZW5kZW5jeS5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL1JlcXVpcmVDb250ZXh0RGVwZW5kZW5jeVBhcnNlclBsdWdpbi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvQWJzdHJhY3RQbHVnaW4uanMiLCIuLi8uLi8od2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9SZXF1aXJlRW5zdXJlUGx1Z2luLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvUmVxdWlyZUVuc3VyZUl0ZW1EZXBlbmRlbmN5LmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvTnVsbERlcGVuZGVuY3lUZW1wbGF0ZS5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL1JlcXVpcmVFbnN1cmVEZXBlbmRlbmN5LmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvUmVxdWlyZUVuc3VyZURlcGVuZGVuY2llc0Jsb2NrUGFyc2VyUGx1Z2luLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvUmVxdWlyZUVuc3VyZURlcGVuZGVuY2llc0Jsb2NrLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvUmVxdWlyZUluY2x1ZGVQbHVnaW4uanMiLCIuLi8uLi8od2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9SZXF1aXJlSW5jbHVkZURlcGVuZGVuY3kuanMiLCIuLi8uLi8od2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9SZXF1aXJlSW5jbHVkZURlcGVuZGVuY3lQYXJzZXJQbHVnaW4uanMiLCIuLi8uLi8od2VicGFjaykvbGliL29wdGltaXplL1JlbW92ZVBhcmVudE1vZHVsZXNQbHVnaW4uanMiLCIuLi8uLi8od2VicGFjaykvbGliL29wdGltaXplL1JlbW92ZUVtcHR5Q2h1bmtzUGx1Z2luLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9vcHRpbWl6ZS9NZXJnZUR1cGxpY2F0ZUNodW5rc1BsdWdpbi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvb3B0aW1pemUvRmxhZ0luY2x1ZGVkQ2h1bmtzUGx1Z2luLmpzIiwiLi4vLi4vLi9+L2VuaGFuY2VkLXJlc29sdmUvbGliL1Vuc2FmZUNhY2hlUGx1Z2luLmpzIiwiLi4vLi4vLi9+L2VuaGFuY2VkLXJlc29sdmUvbGliL01vZHVsZXNJbkRpcmVjdG9yaWVzUGx1Z2luLmpzIiwiLi4vLi4vLi9+L2VuaGFuY2VkLXJlc29sdmUvbGliL3BvcFBhdGhTZXFtZW50LmpzIiwiLi4vLi4vLi9+L2VuaGFuY2VkLXJlc29sdmUvbGliL01vZHVsZXNJblJvb3RQbHVnaW4uanMiLCIuLi8uLi8uL34vZW5oYW5jZWQtcmVzb2x2ZS9saWIvTW9kdWxlVGVtcGxhdGVzUGx1Z2luLmpzIiwiLi4vLi4vLi9+L2VuaGFuY2VkLXJlc29sdmUvbGliL01vZHVsZUFzRmlsZVBsdWdpbi5qcyIsIi4uLy4uLy4vfi9lbmhhbmNlZC1yZXNvbHZlL2xpYi9Nb2R1bGVBc0RpcmVjdG9yeVBsdWdpbi5qcyIsIi4uLy4uLy4vfi9lbmhhbmNlZC1yZXNvbHZlL2xpYi9EaXJlY3RvcnlEZWZhdWx0RmlsZVBsdWdpbi5qcyIsIi4uLy4uLy4vfi9lbmhhbmNlZC1yZXNvbHZlL2xpYi9EaXJlY3RvcnlEZXNjcmlwdGlvbkZpbGVQbHVnaW4uanMiLCIuLi8uLi8uL34vZW5oYW5jZWQtcmVzb2x2ZS9saWIvRGlyZWN0b3J5RGVzY3JpcHRpb25GaWxlRmllbGRBbGlhc1BsdWdpbi5qcyIsIi4uLy4uLy4vfi9lbmhhbmNlZC1yZXNvbHZlL2xpYi9GaWxlQXBwZW5kUGx1Z2luLmpzIiwiLi4vLi4vLi9+L2VuaGFuY2VkLXJlc29sdmUvbGliL0RpcmVjdG9yeVJlc3VsdFBsdWdpbi5qcyIsIi4uLy4uLy4vfi9lbmhhbmNlZC1yZXNvbHZlL2xpYi9SZXN1bHRTeW1saW5rUGx1Z2luLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9Kc29ucFRlbXBsYXRlUGx1Z2luLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9Kc29ucE1haW5UZW1wbGF0ZVBsdWdpbi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvSnNvbnBNYWluVGVtcGxhdGUucnVudGltZS5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvSnNvbnBDaHVua1RlbXBsYXRlUGx1Z2luLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9Kc29ucEhvdFVwZGF0ZUNodW5rVGVtcGxhdGVQbHVnaW4uanMiLCIuLi8uLi8od2VicGFjaykvbGliL25vZGUvTm9kZVNvdXJjZVBsdWdpbi5qcyIsIi4uLy4uLy4vfi9ub2RlLWxpYnMtYnJvd3Nlci9tb2NrIF5cXC5cXC8uKiQiLCIuLi8uLi8uL34vbm9kZS1saWJzLWJyb3dzZXIvbW9jay9idWZmZXIuanMiLCIuLi8uLi8uL34vbm9kZS1saWJzLWJyb3dzZXIvbW9jay9jb25zb2xlLmpzIiwiLi4vLi4vLi9+L25vZGUtbGlicy1icm93c2VyL21vY2svZG5zLmpzIiwiLi4vLi4vLi9+L25vZGUtbGlicy1icm93c2VyL21vY2svbmV0LmpzIiwiLi4vLi4vLi9+L25vZGUtbGlicy1icm93c2VyL21vY2svcHJvY2Vzcy5qcyIsIi4uLy4uLy4vfi9ub2RlLWxpYnMtYnJvd3Nlci9tb2NrL3B1bnljb2RlLmpzIiwiLi4vLi4vLi9+L25vZGUtbGlicy1icm93c2VyL21vY2svdGxzLmpzIiwiLi4vLi4vLi9+L25vZGUtbGlicy1icm93c2VyL21vY2svdHR5LmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi93ZWJ3b3JrZXIvV2ViV29ya2VyVGVtcGxhdGVQbHVnaW4uanMiLCIuLi8uLi8od2VicGFjaykvbGliL3dlYndvcmtlci9XZWJXb3JrZXJNYWluVGVtcGxhdGVQbHVnaW4uanMiLCIuLi8uLi8od2VicGFjaykvbGliL3dlYndvcmtlci9XZWJXb3JrZXJDaHVua1RlbXBsYXRlUGx1Z2luLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9ub2RlL05vZGVUZW1wbGF0ZVBsdWdpbi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvbm9kZS9Ob2RlTWFpblRlbXBsYXRlUGx1Z2luLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9ub2RlL05vZGVNYWluVGVtcGxhdGVBc3luYy5ydW50aW1lLmpzIiwiLi4vLi4vLi9+L3ZtLWJyb3dzZXJpZnkvaW5kZXguanMiLCIuLi8uLi8uL34vaW5kZXhvZi9pbmRleC5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvbm9kZS9Ob2RlTWFpblRlbXBsYXRlLnJ1bnRpbWUuanMiLCIuLi8uLi8od2VicGFjaykvbGliL25vZGUgXlxcLlxcLy4qJCIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvbm9kZS9Ob2RlQ2h1bmtUZW1wbGF0ZVBsdWdpbi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvbm9kZS9Ob2RlRW52aXJvbm1lbnRQbHVnaW4uanMiLCIuLi8uLi8od2VicGFjaykvbGliL25vZGUvTm9kZVdhdGNoRmlsZVN5c3RlbS5qcyIsIi4uLy4uLy4vfi93YXRjaHBhY2svbGliL3dhdGNocGFjay5qcyIsIi4uLy4uLy4vfi93YXRjaHBhY2svbGliL3dhdGNoZXJNYW5hZ2VyLmpzIiwiLi4vLi4vLi9+L3dhdGNocGFjay9saWIvRGlyZWN0b3J5V2F0Y2hlci5qcyIsIi4uLy4uLy4vfi9ldmVudHMvZXZlbnRzLmpzIiwiLi4vLi4vLi9+L3dhdGNocGFjay9+L2FzeW5jL2xpYi9hc3luYy5qcyIsIi4uLy4uLy4vfi9jaG9raWRhci9pbmRleC5qcyIsIi4uLy4uLy4vfi9hc3luYy1lYWNoL2luZGV4LmpzIiwiLi4vLi4vLi9+L2FueW1hdGNoL2luZGV4LmpzIiwiLi4vLi4vLi9+L2FycmlmeS9pbmRleC5qcyIsIi4uLy4uLy4vfi9taWNyb21hdGNoL2luZGV4LmpzIiwiLi4vLi4vLi9+L21pY3JvbWF0Y2gvbGliL2V4cGFuZC5qcyIsIi4uLy4uLy4vfi9taWNyb21hdGNoL2xpYi91dGlscy5qcyIsIi4uLy4uLy4vfi9maWxlbmFtZS1yZWdleC9pbmRleC5qcyIsIi4uLy4uLy4vfi9hcnItZGlmZi9pbmRleC5qcyIsIi4uLy4uLy4vfi9hcnItZmxhdHRlbi9pbmRleC5qcyIsIi4uLy4uLy4vfi9hcnJheS11bmlxdWUvaW5kZXguanMiLCIuLi8uLi8uL34vYnJhY2VzL2luZGV4LmpzIiwiLi4vLi4vLi9+L2V4cGFuZC1yYW5nZS9pbmRleC5qcyIsIi4uLy4uLy4vfi9maWxsLXJhbmdlL2luZGV4LmpzIiwiLi4vLi4vLi9+L2lzb2JqZWN0L2luZGV4LmpzIiwiLi4vLi4vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMgZnJvbSBkbGwtcmVmZXJlbmNlIHZlbmRvcl9hZTk3YmExY2IyNDEyYzFhODY0NCIsIi4uLy4uLy4vfi9pcy1udW1iZXIvaW5kZXguanMiLCIuLi8uLi8uL34va2luZC1vZi9pbmRleC5qcyIsIi4uLy4uLy4vfi9pcy1idWZmZXIvaW5kZXguanMiLCIuLi8uLi8uL34vcmFuZG9tYXRpYy9pbmRleC5qcyIsIi4uLy4uLy4vfi9yZXBlYXQtc3RyaW5nL2luZGV4LmpzIiwiLi4vLi4vLi9+L3JlcGVhdC1lbGVtZW50L2luZGV4LmpzIiwiLi4vLi4vLi9+L3ByZXNlcnZlL2luZGV4LmpzIiwiLi4vLi4vLi9+L2V4cGFuZC1icmFja2V0cy9pbmRleC5qcyIsIi4uLy4uLy4vfi9pcy1wb3NpeC1icmFja2V0L2luZGV4LmpzIiwiLi4vLi4vLi9+L2V4dGdsb2IvaW5kZXguanMiLCIuLi8uLi8uL34vaXMtZXh0Z2xvYi9pbmRleC5qcyIsIi4uLy4uLy4vfi9pcy1nbG9iL2luZGV4LmpzIiwiLi4vLi4vLi9+L25vcm1hbGl6ZS1wYXRoL2luZGV4LmpzIiwiLi4vLi4vLi9+L29iamVjdC5vbWl0L2luZGV4LmpzIiwiLi4vLi4vLi9+L2lzLWV4dGVuZGFibGUvaW5kZXguanMiLCIuLi8uLi8uL34vZm9yLW93bi9pbmRleC5qcyIsIi4uLy4uLy4vfi9mb3ItaW4vaW5kZXguanMiLCIuLi8uLi8uL34vcGFyc2UtZ2xvYi9pbmRleC5qcyIsIi4uLy4uLy4vfi9nbG9iLWJhc2UvaW5kZXguanMiLCIuLi8uLi8uL34vZ2xvYi1wYXJlbnQvaW5kZXguanMiLCIuLi8uLi8uL34vaXMtZG90ZmlsZS9pbmRleC5qcyIsIi4uLy4uLy4vfi9yZWdleC1jYWNoZS9pbmRleC5qcyIsIi4uLy4uLy4vfi9pcy1wcmltaXRpdmUvaW5kZXguanMiLCIuLi8uLi8uL34vaXMtZXF1YWwtc2hhbGxvdy9pbmRleC5qcyIsIi4uLy4uLy4vfi9taWNyb21hdGNoL2xpYi9nbG9iLmpzIiwiLi4vLi4vLi9+L21pY3JvbWF0Y2gvbGliL2NoYXJzLmpzIiwiLi4vLi4vLi9+L3BhdGgtaXMtYWJzb2x1dGUvaW5kZXguanMiLCIuLi8uLi8uL34vaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIi4uLy4uLy4vfi9jaG9raWRhci9saWIvbm9kZWZzLWhhbmRsZXIuanMiLCIuLi8uLi8uL34vcmVhZGRpcnAvcmVhZGRpcnAuanMiLCIuLi8uLi8uL34vZ3JhY2VmdWwtZnMvZ3JhY2VmdWwtZnMuanMiLCIuLi8uLi8uL34vZ3JhY2VmdWwtZnMvcG9seWZpbGxzLmpzIiwiLi4vLi4vLi9+L2dyYWNlZnVsLWZzL2ZzLmpzIiwiLi4vLi4vLi9+L2dyYWNlZnVsLWZzL2xlZ2FjeS1zdHJlYW1zLmpzIiwiLi4vLi4vLi9+L3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIiwiLi4vLi4vLi9+L3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcyIsIi4uLy4uLy4vfi9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCIuLi8uLi8uL34vcHJvY2Vzcy1uZXh0aWNrLWFyZ3MvaW5kZXguanMiLCIuLi8uLi8uL34vYnVmZmVyLXNoaW1zL2luZGV4LmpzIiwiLi4vLi4vLi9+L2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsIi4uLy4uL3V0aWwgKGlnbm9yZWQpIiwiLi4vLi4vLi9+L3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0LmpzIiwiLi4vLi4vLi9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCIuLi8uLi8uL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwiLi4vLi4vLi9+L3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCIuLi8uLi8uL34vc3RyaW5nX2RlY29kZXIvaW5kZXguanMiLCIuLi8uLi8uL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIi4uLy4uLy4vfi9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCIuLi8uLi8uL34vcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzIiwiLi4vLi4vLi9+L3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMiLCIuLi8uLi8uL34vcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsIi4uLy4uLy4vfi9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMiLCIuLi8uLi9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIGZyb20gZGxsLXJlZmVyZW5jZSB2ZW5kb3JfYWU5N2JhMWNiMjQxMmMxYTg2NDQiLCIuLi8uLi8uL34vYXNzZXJ0L2Fzc2VydC5qcyIsIi4uLy4uLy4vfi9taW5pbWF0Y2gvbWluaW1hdGNoLmpzIiwiLi4vLi4vLi9+L2JyYWNlLWV4cGFuc2lvbi9pbmRleC5qcyIsIi4uLy4uLy4vfi9jb25jYXQtbWFwL2luZGV4LmpzIiwiLi4vLi4vLi9+L2JhbGFuY2VkLW1hdGNoL2luZGV4LmpzIiwiLi4vLi4vLi9+L3NldC1pbW1lZGlhdGUtc2hpbS9pbmRleC5qcyIsIi4uLy4uLy4vfi9yZWFkZGlycC9zdHJlYW0tYXBpLmpzIiwiLi4vLi4vLi9+L2lzLWJpbmFyeS1wYXRoL2luZGV4LmpzIiwiLi4vLi4vLi9+L2JpbmFyeS1leHRlbnNpb25zL2JpbmFyeS1leHRlbnNpb25zLmpzb24iLCIuLi8uLi8uL34vY2hva2lkYXIvbGliL2ZzZXZlbnRzLWhhbmRsZXIuanMiLCIuLi8uLi8od2VicGFjaykvbGliL25vZGUvTm9kZU91dHB1dEZpbGVTeXN0ZW0uanMiLCIuLi8uLi8uL34vbWtkaXJwL2luZGV4LmpzIiwiLi4vLi4vLi9+L2VuaGFuY2VkLXJlc29sdmUvbGliL05vZGVKc0lucHV0RmlsZVN5c3RlbS5qcyIsIi4uLy4uLy4vfi9lbmhhbmNlZC1yZXNvbHZlL2xpYi9DYWNoZWRJbnB1dEZpbGVTeXN0ZW0uanMiLCIuLi8uLi8od2VicGFjaykvbGliL25vZGUvTm9kZUhvdFVwZGF0ZUNodW5rVGVtcGxhdGVQbHVnaW4uanMiLCIuLi8uLi8od2VicGFjaykvbGliL25vZGUvTm9kZVRhcmdldFBsdWdpbi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvRXh0ZXJuYWxzUGx1Z2luLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9FeHRlcm5hbE1vZHVsZUZhY3RvcnlQbHVnaW4uanMiLCIuLi8uLi8od2VicGFjaykvbGliL0V4dGVybmFsTW9kdWxlLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9ub2RlL09sZE5vZGVXYXRjaEZpbGVTeXN0ZW0uanMiLCIuLi8uLi8od2VicGFjaykvbGliL0xpYnJhcnlUZW1wbGF0ZVBsdWdpbi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvU2V0VmFyTWFpblRlbXBsYXRlUGx1Z2luLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9BbWRNYWluVGVtcGxhdGVQbHVnaW4uanMiLCIuLi8uLi8od2VicGFjaykvbGliL1VtZE1haW5UZW1wbGF0ZVBsdWdpbi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvSnNvbnBFeHBvcnRNYWluVGVtcGxhdGVQbHVnaW4uanMiLCIuLi8uLi8od2VicGFjaykvbGliL0hvdE1vZHVsZVJlcGxhY2VtZW50UGx1Z2luLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvTW9kdWxlSG90QWNjZXB0RGVwZW5kZW5jeS5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL01vZHVsZUhvdERlY2xpbmVEZXBlbmRlbmN5LmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9Ib3RNb2R1bGVSZXBsYWNlbWVudC5ydW50aW1lLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9QcmVmZXRjaFBsdWdpbi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL1ByZWZldGNoRGVwZW5kZW5jeS5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvb3B0aW1pemUvT2NjdXJyZW5jZU9yZGVyUGx1Z2luLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9vcHRpbWl6ZS9NaW5DaHVua1NpemVQbHVnaW4uanMiLCIuLi8uLi8od2VicGFjaykvbGliL29wdGltaXplL0xpbWl0Q2h1bmtDb3VudFBsdWdpbi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvb3B0aW1pemUvVWdsaWZ5SnNQbHVnaW4uanMiLCIuLi8uLi8od2VicGFjayktY29yZS9saWIvc291cmNlLW1hcC5qcyIsIi4uLy4uLy4vfi91Z2xpZnktanMvdG9vbHMvbm9kZS5qcyIsIi4uLy4uLy4vfi91Z2xpZnktanMvfi9zb3VyY2UtbWFwL3NvdXJjZS1tYXAuanMiLCIuLi8uLi8uL34vdWdsaWZ5LWpzL34vc291cmNlLW1hcC9saWIvc291cmNlLW1hcC1nZW5lcmF0b3IuanMiLCIuLi8uLi8uL34vdWdsaWZ5LWpzL34vc291cmNlLW1hcC9saWIvYmFzZTY0LXZscS5qcyIsIi4uLy4uLy4vfi91Z2xpZnktanMvfi9zb3VyY2UtbWFwL2xpYi9iYXNlNjQuanMiLCIuLi8uLi8uL34vdWdsaWZ5LWpzL34vc291cmNlLW1hcC9saWIvdXRpbC5qcyIsIi4uLy4uLy4vfi91Z2xpZnktanMvfi9zb3VyY2UtbWFwL2xpYi9hcnJheS1zZXQuanMiLCIuLi8uLi8uL34vdWdsaWZ5LWpzL34vc291cmNlLW1hcC9saWIvbWFwcGluZy1saXN0LmpzIiwiLi4vLi4vLi9+L3VnbGlmeS1qcy9+L3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAtY29uc3VtZXIuanMiLCIuLi8uLi8uL34vdWdsaWZ5LWpzL34vc291cmNlLW1hcC9saWIvYmluYXJ5LXNlYXJjaC5qcyIsIi4uLy4uLy4vfi91Z2xpZnktanMvfi9zb3VyY2UtbWFwL2xpYi9xdWljay1zb3J0LmpzIiwiLi4vLi4vLi9+L3VnbGlmeS1qcy9+L3NvdXJjZS1tYXAvbGliL3NvdXJjZS1ub2RlLmpzIiwiLi4vLi4vKHdlYnBhY2spL2xpYi9DYWNoZVBsdWdpbi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvUHJvdmlkZVBsdWdpbi5qcyIsIi4uLy4uLyh3ZWJwYWNrKS9saWIvV2VicGFja09wdGlvbnNEZWZhdWx0ZXIuanMiLCIuLi8uLi8od2VicGFjayktY29yZS9saWIvT3B0aW9uc0RlZmF1bHRlci5qcyIsIi4uLy4uLy4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vaW5kZXguanMiLCIuLi8uLi8od2VicGFjayktc291cmNlcy9saWIvaW5kZXguanMiLCIuLi8uLi8od2VicGFjayktc291cmNlcy9saWIvU291cmNlLmpzIiwiLi4vLi4vKHdlYnBhY2spLXNvdXJjZXMvfi9zb3VyY2UtbWFwL3NvdXJjZS1tYXAuanMiLCIuLi8uLi8od2VicGFjayktc291cmNlcy9+L3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAtZ2VuZXJhdG9yLmpzIiwiLi4vLi4vKHdlYnBhY2spLXNvdXJjZXMvfi9zb3VyY2UtbWFwL2xpYi9iYXNlNjQtdmxxLmpzIiwiLi4vLi4vKHdlYnBhY2spLXNvdXJjZXMvfi9zb3VyY2UtbWFwL2xpYi9iYXNlNjQuanMiLCIuLi8uLi8od2VicGFjayktc291cmNlcy9+L3NvdXJjZS1tYXAvbGliL3V0aWwuanMiLCIuLi8uLi8od2VicGFjayktc291cmNlcy9+L3NvdXJjZS1tYXAvbGliL2FycmF5LXNldC5qcyIsIi4uLy4uLyh3ZWJwYWNrKS1zb3VyY2VzL34vc291cmNlLW1hcC9saWIvbWFwcGluZy1saXN0LmpzIiwiLi4vLi4vKHdlYnBhY2spLXNvdXJjZXMvfi9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWNvbnN1bWVyLmpzIiwiLi4vLi4vKHdlYnBhY2spLXNvdXJjZXMvfi9zb3VyY2UtbWFwL2xpYi9iaW5hcnktc2VhcmNoLmpzIiwiLi4vLi4vKHdlYnBhY2spLXNvdXJjZXMvfi9zb3VyY2UtbWFwL2xpYi9xdWljay1zb3J0LmpzIiwiLi4vLi4vKHdlYnBhY2spLXNvdXJjZXMvfi9zb3VyY2UtbWFwL2xpYi9zb3VyY2Utbm9kZS5qcyIsIi4uLy4uLyh3ZWJwYWNrKS1zb3VyY2VzL2xpYi9SYXdTb3VyY2UuanMiLCIuLi8uLi8od2VicGFjayktc291cmNlcy9saWIvT3JpZ2luYWxTb3VyY2UuanMiLCIuLi8uLi8od2VicGFjayktc291cmNlcy9saWIvU291cmNlQW5kTWFwTWl4aW4uanMiLCIuLi8uLi8od2VicGFjayktc291cmNlcy9saWIvU291cmNlTWFwU291cmNlLmpzIiwiLi4vLi4vKHdlYnBhY2spLXNvdXJjZXMvbGliL0xpbmVUb0xpbmVNYXBwZWRTb3VyY2UuanMiLCIuLi8uLi8od2VicGFjayktc291cmNlcy9saWIvQ2FjaGVkU291cmNlLmpzIiwiLi4vLi4vKHdlYnBhY2spLXNvdXJjZXMvbGliL0NvbmNhdFNvdXJjZS5qcyIsIi4uLy4uLyh3ZWJwYWNrKS1zb3VyY2VzL2xpYi9SZXBsYWNlU291cmNlLmpzIiwiLi4vLi4vKHdlYnBhY2spLXNvdXJjZXMvbGliL1ByZWZpeFNvdXJjZS5qcyIsIi4uLy4uLy4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vRXh0cmFjdGVkTW9kdWxlLmpzIiwiLi4vLi4vLi9+L2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9PcmRlclVuZGVmaW5lZEVycm9yLmpzIiwiLi4vLi4vLi9+L2xvYWRlci11dGlscy9pbmRleC5qcyIsIi4uLy4uLy4vfi9qc29uNS9saWIvanNvbjUuanMiLCIuLi8uLi8uL34vb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIi4uLy4uLy4vfi9lbW9qaXMtbGlzdC9pbmRleC5qcyIsIi4uLy4uLy4vfi9iaWcuanMvYmlnLmpzIiwiLi4vLi4vLi9+L2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9sb2FkZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxjQUFhLGtGO0FBQ2I7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSw4Q0FBNkMsa0JBQWtCO0FBQy9ELG9DQUFtQyxnQ0FBZ0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSw4Q0FBNkMsWUFBWSxrQkFBa0IsRUFBRTtBQUM3RTtBQUNBOzs7Ozs7OztBQ3pEQSwrQzs7Ozs7O0FDQUEsOEM7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVSxNQUFNO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QixJQUFJO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFvQyw4QkFBOEI7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFVLG9CQUFvQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0EsV0FBVSxVQUFVO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBK0Isc0JBQXNCO0FBQ3JEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDL05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTCxLQUFJO0FBQ0osSUFBRztBQUNILEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTixNQUFLO0FBQ0wsS0FBSTtBQUNKLElBQUc7QUFDSCxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRztBQUNIOztBQUVBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdJQUErSDtBQUMvSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0osSUFBRztBQUNILEdBQUU7QUFDRjs7Ozs7Ozs7QUN0WkEsK0M7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFrQywyQ0FBMkM7QUFDN0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFrQywyQ0FBMkM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFrQywyQ0FBMkM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGLGdCQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQSxnQ0FBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSixJQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTs7Ozs7OztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZSx5QkFBeUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxLQUFJOztBQUVKLElBQUc7QUFDSCxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFJO0FBQ0o7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBLEtBQUk7QUFDSjtBQUNBLElBQUc7O0FBRUgsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLEtBQUk7QUFDSixJQUFHO0FBQ0gsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGLFlBQVcsbUJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUseUJBQXlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsWUFBVyx3QkFBd0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztpRUMxM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9EQUFtRCxVQUFVLEVBQUU7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0Esd0JBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLGdCQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQThCLG9CQUFvQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBa0MsdUJBQXVCO0FBQ3pEO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNUO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBb0MsNkJBQTZCO0FBQ2pFO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7O0FBRUEsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQThELHlCQUF5QjtBQUN2RixzQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7O0FBRXJCO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLDBDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLGtCQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QztBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQixjQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQSxrQkFBaUI7QUFDakIsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUM7Ozs7Ozs7O0FDaHZDRCwrQzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWUseUJBQXlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZSx5QkFBeUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFlLDJCQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7Ozs7Ozs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTBDLFlBQVk7QUFDdEQsMEVBQXlFLHFCQUFxQjtBQUM5RjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRixpQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDUEEsbURBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE0QyxTQUFTO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFDOzs7Ozs7O0FDOVlELG1EQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUEyRDtBQUMzRCxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxFQUFDOzs7Ozs7O0FDakpELG1EQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCLG1CQUFrQjs7QUFFbEIsc0JBQXFCO0FBQ3JCLHVCQUFzQjs7QUFFdEIsbUJBQWtCO0FBQ2xCLG1CQUFrQjs7QUFFbEIsbUJBQWtCO0FBQ2xCLG9CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBQzs7Ozs7OztBQ3hFRCxtREFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDOzs7Ozs7O0FDalhELG1EQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFDOzs7Ozs7O0FDMUdELG1EQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFDOzs7Ozs7O0FDckZELG1EQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseURBQXdEO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QixNQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXdEO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5REFBd0QsWUFBWTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5Qix3Q0FBd0M7QUFDakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFpRCxtQkFBbUIsRUFBRTtBQUN0RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0IsTUFBTTtBQUNyQztBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF3RDtBQUN4RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsMkJBQTJCO0FBQ2hELHdCQUF1QiwrQ0FBK0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQiwyQkFBMkI7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCLDJCQUEyQjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQSx3QkFBdUIsNEJBQTRCO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxFQUFDOzs7Ozs7O0FDcGpDRCxtREFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUM7Ozs7Ozs7QUNwSEQsbURBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsTUFBTTtBQUNuQjtBQUNBLGNBQWEsT0FBTztBQUNwQjtBQUNBLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE9BQU87QUFDcEI7QUFDQSxjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE1BQU07QUFDbkI7QUFDQSxjQUFhLFNBQVM7QUFDdEI7QUFDQSxjQUFhLE9BQU87QUFDcEI7QUFDQSxjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLE1BQU07QUFDbkI7QUFDQSxjQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFDOzs7Ozs7O0FDdkhELG1EQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0E7QUFDQSx5Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLCtDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLOztBQUVMLGFBQVk7QUFDWjs7QUFFQTs7QUFFQSxFQUFDOzs7Ozs7O0FDN1pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQThCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEIsMEVBQXlFO0FBQ3pFLHdGQUF1RjtBQUN2RixrQkFBaUI7QUFDakI7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQy9DQSxpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBMkQ7QUFDM0QscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7Ozs7Ozs7QUN4S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9EQUFtRCxTQUFTO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1REFBc0QsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDM1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF3RCxFQUFFO0FBQzFELEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osMkNBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0IsWUFBWTtBQUM5QjtBQUNBLG1CQUFrQixZQUFZO0FBQzlCLG9CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixZQUFZO0FBQzlCLG9CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTLHVDQUF1QztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBLGNBQWE7QUFDYixLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQSxjQUFhO0FBQ2IsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDM3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBeUQ7QUFDekQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0RBQThEO0FBQzlEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaURBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxzRkFBcUY7QUFDckY7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsNENBQTJDO0FBQzNDO0FBQ0EseUJBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4QjtBQUM5QjtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTBEO0FBQzFEO0FBQ0E7QUFDQSxnREFBK0M7QUFDL0M7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBLDBJQUF5STtBQUN6STtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSwyQkFBMEI7QUFDMUI7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBOEU7QUFDOUUsc0hBQXFIO0FBQ3JILGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDOztBQUUxQztBQUNBO0FBQ0Esb0RBQW1EOztBQUVuRDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxzRUFBcUU7QUFDckU7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXNEO0FBQ3REO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvR0FBbUc7QUFDbkc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUUsMkJBQTJCLGdCQUFnQixFQUFFO0FBQy9DOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUU7QUFDRjs7Ozs7OztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNLGlCQUFpQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxREFBb0QsU0FBUztBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILHVCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxrQ0FBaUM7QUFDakM7QUFDQTtBQUNBOzs7Ozs7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBLFdBQVU7QUFDVixHQUFFO0FBQ0YsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDekRBLGdEOzs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0Esc0JBQXFCLEVBQUU7QUFDdkI7QUFDQTtBQUNBLEdBQUU7QUFDRixzQkFBcUIsRUFBRTtBQUN2QjtBQUNBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0EsZ0JBQWUsaUNBQWlDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3o2QkE7QUFDQTtBQUNBO0FBQ0EsOENBQTZDO0FBQzdDLEVBQUMsMkJBQTJCOztBQUU1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBZ0MsOEJBQThCO0FBQzlEO0FBQ0EscUJBQW9CO0FBQ3BCLHFCQUFvQjtBQUNwQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFrQyxtQ0FBbUM7QUFDckU7QUFDQSw2QkFBNEIsSUFBSSxtQ0FBbUM7QUFDbkUsNkJBQTRCO0FBQzVCLGlDQUFnQyxtQ0FBbUM7QUFDbkU7QUFDQTtBQUNBLDJCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQyxJQUFJLG1DQUFtQzs7QUFFMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTRCLGlDQUFpQztBQUM3RCxrQ0FBaUMsaUNBQWlDO0FBQ2xFLHFDQUFvQyw4Q0FBOEM7QUFDbEYsc0NBQXFDLGlEQUFpRDtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLDJEQUEyRDtBQUM5RjtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUMsaUJBQWlCOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQiwrQkFBK0I7QUFDbEQ7QUFDQTtBQUNBLHNCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUIsYUFBYTtBQUN0QztBQUNBLHNCQUFxQixtQ0FBbUM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLDJCQUEyQjtBQUM5QyxvQ0FBbUMsMkJBQTJCO0FBQzlELDRCQUEyQixpREFBaUQ7QUFDNUUsd0JBQXVCLGlEQUFpRDtBQUN4RSw0QkFBMkIsaURBQWlEO0FBQzVFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBZ0QsYUFBYTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQXlDLGFBQWE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIsYUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTBDLDJCQUEyQjtBQUNyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXdDLGFBQWE7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyREFBMEQ7QUFDMUQscUVBQW9FOztBQUVwRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW1CO0FBQ25CLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQXlEO0FBQ3pEO0FBQ0EsK0JBQThCLG9EQUFvRDtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVUsd0NBQXdDO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBcUMsd0JBQXdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBLDJDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsdUJBQXNCLHdEQUF3RDtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLLE9BQU8sWUFBWSxZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0Esd0JBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBNkIsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXFCLDRCQUE0QjtBQUNqRDtBQUNBOztBQUVBO0FBQ0Esd0JBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUM7QUFDdkMsOENBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxtQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCLGVBQWU7QUFDakM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBNkI7QUFDN0IsOEJBQTZCO0FBQzdCLCtCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsMkRBQTBELDBCQUEwQixFQUFFO0FBQ3RGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBbUMsS0FBSzs7QUFFeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXVFO0FBQ3ZFO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXFDO0FBQ3JDO0FBQ0EsNEJBQTJCLFdBQVc7QUFDdEM7QUFDQTtBQUNBOztBQUVBLG9EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBMkM7QUFDM0M7QUFDQTtBQUNBLHVFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF3QjtBQUN4Qix5QkFBd0I7QUFDeEIseUJBQXdCO0FBQ3hCLHlCQUF3QjtBQUN4Qix5QkFBd0I7QUFDeEIseUJBQXdCO0FBQ3hCLDBCQUF5QjtBQUN6QiwwQkFBeUI7QUFDekIseUJBQXdCO0FBQ3hCLHlCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZ0UsR0FBRztBQUNuRTtBQUNBO0FBQ0EsbUNBQWtDLGdCQUFnQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1gsOENBQTZDLEVBQUU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF3Qyw0Q0FBNEM7QUFDcEY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzREFBcUQsT0FBTztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQSx1RkFBc0YsWUFBWTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DLDJCQUEyQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU8sc0JBQXNCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWdELGNBQWM7O0FBRTlELEVBQUMsRzs7Ozs7O0FDcmtHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjtBQUNBO0FBQ0Esa0JBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBLGdDQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDdE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUM3QkE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEc7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFLO0FBQ0wsS0FBSTtBQUNKO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDOztBQUVoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTixNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQSxLQUFJO0FBQ0o7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7Ozs7Ozs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUZBQXdGO0FBQ3hGO0FBQ0EsK0NBQThDLHFCQUFxQjtBQUNuRTtBQUNBO0FBQ0EsT0FBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUEyRCxpQ0FBaUM7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsK0JBQStCO0FBQy9DO0FBQ0EseUNBQXdDLGtDQUFrQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSEFBa0g7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQixrQ0FBa0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQzlUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXFFO0FBQ3JFO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhEQUE2RDtBQUM3RCxHQUFFO0FBQ0Y7QUFDQSxHQUFFO0FBQ0Y7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxrQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEc7Ozs7OztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQiwwQ0FBMEM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSCxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxPQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0EsUUFBTzs7QUFFUCxPQUFNOztBQUVOLE1BQUs7O0FBRUwsS0FBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0wsS0FBSTtBQUNKLElBQUc7QUFDSCxHQUFFO0FBQ0Y7Ozs7Ozs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLHFEQUFvRDtBQUNwRCxtQ0FBa0M7QUFDbEMsOERBQTZEO0FBQzdELE9BQU07QUFDTiwwQ0FBeUM7QUFDekMsdUNBQXNDLDJEQUEyRCxJQUFJO0FBQ3JHLE9BQU07QUFDTiwwREFBeUQ7QUFDekQsK0JBQThCO0FBQzlCLE9BQU07QUFDTixvREFBbUQ7QUFDbkQscUNBQW9DO0FBQ3BDLHlDQUF3QztBQUN4QztBQUNBLEdBQUU7QUFDRjtBQUNBLG1DQUFrQztBQUNsQyxnRUFBK0Q7QUFDL0QsTUFBSztBQUNMLHVDQUFzQyxXQUFXLEdBQUc7QUFDcEQsNkNBQTRDO0FBQzVDLHFDQUFvQztBQUNwQyx5Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBLEdBQUU7QUFDRjs7Ozs7OztBQ2pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWlEO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSw0SUFBMkk7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdlhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBa0c7QUFDbEc7QUFDQSwwQkFBeUI7QUFDekI7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXVFO0FBQ3ZFLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0RUFBMkU7QUFDM0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsbUJBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0Esc0NBQXFDLGNBQWM7QUFDbkQ7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUk7QUFDSixJQUFHO0FBQ0gsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3ZLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0Esa0JBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxpRkFBZ0YsY0FBYztBQUM5RixxR0FBb0c7QUFDcEc7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7Ozs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsZ0RBQStDO0FBQy9DO0FBQ0EsZ0JBQWUsRUFBRTtBQUNqQjtBQUNBLGNBQWE7QUFDYixHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSixJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxLQUFJO0FBQ0osSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ04sTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0Y7Ozs7Ozs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0Y7Ozs7Ozs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7Ozs7Ozs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0EsbUNBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7Ozs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7Ozs7OztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7Ozs7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRLGdCQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0Y7Ozs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTs7QUFFRjtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0EsSUFBRyxnQkFBZ0I7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7Ozs7Ozs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0Y7Ozs7Ozs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUk7QUFDSixJQUFHO0FBQ0gsR0FBRTtBQUNGOzs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxJQUFHO0FBQ0gsR0FBRTtBQUNGOzs7Ozs7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsOENBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLDhDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QztBQUM1QztBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBLDhGQUE2RjtBQUM3RixnQ0FBK0I7QUFDL0IsWUFBVztBQUNYOztBQUVBO0FBQ0EscURBQW9EO0FBQ3BELCtJQUE4STtBQUM5SSxnQ0FBK0I7QUFDL0IsWUFBVztBQUNYLEtBQUk7QUFDSjs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7Ozs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7Ozs7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQThCLEVBQUU7QUFDaEM7QUFDQSxnQ0FBK0IsRUFBRTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7Ozs7OztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsK0JBQStCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7Ozs7Ozs7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQThCO0FBQzlCLDBFQUF5RTtBQUN6RSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLGtEQUFpRDtBQUNqRCxrSUFBaUk7QUFDakksSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxrREFBaUQ7QUFDakQ7QUFDQSw0RUFBMkU7QUFDM0UsMkZBQTBGO0FBQzFGLDRFQUEyRTtBQUMzRSxJQUFHO0FBQ0g7QUFDQSx3RUFBdUU7QUFDdkU7QUFDQSw0RUFBMkU7QUFDM0UsMkZBQTBGO0FBQzFGLDRFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsMENBQXlDO0FBQ3pDLCtEQUE4RDtBQUM5RCw2Q0FBNEM7QUFDNUM7O0FBRUEsNkJBQTRCO0FBQzVCLE9BQU0sWUFBWTtBQUNsQjtBQUNBLDRFQUEyRTtBQUMzRSxNQUFLO0FBQ0wsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOzs7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBeUM7QUFDekM7QUFDQSwyRUFBMEU7QUFDMUUseUVBQXdFO0FBQ3hFO0FBQ0EsMEdBQXlHO0FBQ3pHLGlCQUFnQjtBQUNoQixpQkFBZ0I7QUFDaEIsa0RBQWlEO0FBQ2pELGdEQUErQztBQUMvQyxrQkFBaUI7QUFDakIsaUZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTs7Ozs7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSyxpRkFBaUY7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsS0FBSSxzRkFBc0Y7QUFDMUY7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7Ozs7Ozs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0IsSUFBSTtBQUN4QjtBQUNBLE1BQUs7QUFDTCxpQkFBZ0IsSUFBSTtBQUNwQjtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QixJQUFJO0FBQ2hDO0FBQ0EsT0FBTTtBQUNOLHlCQUF3QixJQUFJO0FBQzVCO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0I7QUFDQSxPQUFNO0FBQ04seUJBQXdCLElBQUk7QUFDNUI7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUMsSUFBSTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQSxNQUFLO0FBQ0wsK0JBQThCLElBQUk7QUFDbEM7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSyxpRkFBaUY7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsS0FBSSxtR0FBbUc7QUFDdkc7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7Ozs7Ozs7QUMvT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsS0FBSTtBQUNKO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsbUJBQWtCLCtCQUErQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSCxHQUFFO0FBQ0Y7QUFDQTs7Ozs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7Ozs7Ozs7QUNoQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7Ozs7O0FDakVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7Ozs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7Ozs7O0FDakJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLEtBQUk7QUFDSixJQUFHO0FBQ0gsR0FBRTtBQUNGOzs7Ozs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0osSUFBRztBQUNILEdBQUU7QUFDRjs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSCxHQUFFO0FBQ0Y7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxLQUFJO0FBQ0osSUFBRztBQUNILEdBQUU7QUFDRjs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOzs7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSixJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjs7Ozs7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osSUFBRztBQUNILEdBQUU7QUFDRjs7Ozs7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjs7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTCxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSixJQUFHO0FBQ0gsR0FBRTtBQUNGLEc7Ozs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQSxvQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMLEtBQUk7QUFDSixJQUFHO0FBQ0gsR0FBRTtBQUNGLEc7Ozs7OztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0Y7Ozs7Ozs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDLGtCQUFrQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSixJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSCxHQUFFO0FBQ0YsRzs7Ozs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0YsRzs7Ozs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLFVBQVUsRUFBRTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0YsRzs7Ozs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFrRDtBQUNsRCxxQ0FBb0M7QUFDcEMsOEJBQTZCO0FBQzdCLHlCQUF3QjtBQUN4Qiw0RUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQSxLQUFJLE1BQU07QUFDVjtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBbUU7QUFDbkU7QUFDQTtBQUNBLGlEQUFnRDtBQUNoRCx5REFBd0Q7QUFDeEQsTUFBSyxPQUFPO0FBQ1o7QUFDQTtBQUNBLDRDQUEyQztBQUMzQywwREFBeUQ7QUFDekQ7QUFDQSwrQkFBOEI7QUFDOUI7QUFDQSxNQUFLO0FBQ0w7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBNkU7QUFDN0UsNEdBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBLG9EQUFtRDtBQUNuRCxZQUFXLG9CQUFvQixPQUFPO0FBQ3RDO0FBQ0EsOEJBQTZCO0FBQzdCO0FBQ0EsOEVBQTZFO0FBQzdFLHFDQUFvQztBQUNwQztBQUNBLFFBQU87QUFDUCxxQ0FBb0M7QUFDcEM7QUFDQSxRQUFPO0FBQ1AsMEVBQXlFO0FBQ3pFO0FBQ0Esd0VBQXVFO0FBQ3ZFLDRCQUEyQjtBQUMzQjtBQUNBLGlDQUFnQztBQUNoQywwQ0FBeUM7QUFDekM7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osSUFBRzs7QUFFSDtBQUNBLG1GQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7Ozs7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7O0FBRUEsNENBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLDBEQUF5RCxhQUFhLEVBQUU7QUFDeEU7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7Ozs7Ozs7Ozs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQyx1REFBdUQ7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsNkVBQTZFO0FBQzlGO0FBQ0E7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7Ozs7Ozs7O0FDUmI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkLDJCOzs7Ozs7QUNMQTs7Ozs7OztBQ0FBO0FBQ0E7Ozs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFLLE9BQU87QUFDWjtBQUNBLE1BQUs7QUFDTCxpREFBZ0Q7QUFDaEQ7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE2RztBQUM3RztBQUNBLHlDQUF3QztBQUN4QztBQUNBLFFBQU87QUFDUDtBQUNBLHVEQUFzRDtBQUN0RDtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7Ozs7OztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEwRDtBQUMxRCx1Q0FBc0M7QUFDdEM7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscUZBQW9GO0FBQ3BGLDBDQUF5QztBQUN6QztBQUNBLDZDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQSxPQUFNLE1BQU07QUFDWiwwRUFBeUU7QUFDekU7QUFDQSxpQkFBZ0IsK0VBQStFLGdCQUFnQixFQUFFO0FBQ2pILHVCQUFzQjtBQUN0Qiw0RkFBMkYsbUJBQW1CO0FBQzlHLHNFQUFxRTtBQUNyRTtBQUNBLDJCQUEwQjtBQUMxQixzQkFBcUIscUJBQXFCLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0EscUVBQW9FO0FBQ3BFO0FBQ0EsMENBQXlDO0FBQ3pDO0FBQ0EsU0FBUTtBQUNSLGtCQUFpQixzQkFBc0I7QUFDdkMsb0VBQW1FO0FBQ25FO0FBQ0EsUUFBTyxFQUFFO0FBQ1Q7QUFDQSxPQUFNLDhDQUE4QztBQUNwRDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsT0FBTTtBQUNOO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLHFDQUFvQztBQUNwQztBQUNBLDRDQUEyQztBQUMzQztBQUNBLHFCQUFvQixxQkFBcUI7QUFDekMsb0RBQW1EO0FBQ25EO0FBQ0EsT0FBTTtBQUNOLGtEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7Ozs7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBdUQsa0JBQWtCO0FBQ3pFO0FBQ0EsSUFBRztBQUNIOztBQUVBLDBDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOzs7Ozs7OztBQ2pDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4SUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0EsRzs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTJDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBeUM7QUFDekM7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQyx1REFBdUQ7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtEQUE4RDtBQUM5RDtBQUNBLGdCQUFlO0FBQ2Y7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7Ozs7Ozs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSixJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSixJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNwVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsU0FBUztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBRztBQUNILHFCQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O2lFQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakIsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLGNBQWE7QUFDYjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQixVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNUO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBb0MsNkJBQTZCO0FBQ2pFO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBOEQseUJBQXlCO0FBQ3ZGLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakIsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxvQkFBbUIsbUNBQW1DO0FBQ3REOztBQUVBO0FBQ0Esb0JBQW1CLGlEQUFpRDtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakIsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSx5Q0FBd0MsUUFBUTtBQUNoRDtBQUNBLGNBQWE7QUFDYjtBQUNBLDBDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLGdDQUErQixvQkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7O0FBRXJCO0FBQ0Esa0JBQWlCO0FBQ2pCLGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUM7Ozs7Ozs7O0FDbG1DRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUIsd0NBQXdDO0FBQzdELElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxNQUFLO0FBQ0wsMEJBQXlCLDRCQUE0QjtBQUNyRCwyQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE1BQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3RzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXNFOztBQUV0RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUssZ0pBQUU7QUFDUCxJQUFHO0FBQ0gsMkJBQTBCO0FBQzFCLElBQUc7QUFDSCw4QkFBNkI7QUFDN0I7QUFDQSxFQUFDOzs7Ozs7O0FDckNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVksYUFBYTtBQUN6QixhQUFZLGFBQWE7QUFDekIsYUFBWSxPQUFPO0FBQ25CLGFBQVksTUFBTTtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE1BQU07QUFDbEIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXdCLFVBQVU7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFlLDhCQUE4Qjs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLGFBQWE7QUFDekIsYUFBWSxRQUFRO0FBQ3BCLGFBQVksU0FBUztBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCO0FBQy9CO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkIsYUFBWSxhQUFhO0FBQ3pCLGFBQVksT0FBTztBQUNuQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkIsYUFBWSxRQUFRO0FBQ3BCLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0EseUNBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM5YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxhQUFhO0FBQ3pCLGFBQVksTUFBTTtBQUNsQixhQUFZLFFBQVE7QUFDcEIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE0QztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEwQixLQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QixHQUFHOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF1QixLQUFLO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsWUFBWTtBQUNuQyxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCLEdBQUc7QUFDekI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWdDLElBQUk7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWdCLG1CQUFtQjtBQUNuQztBQUNBOzs7Ozs7O0FDL1NBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVksRUFBRTtBQUNkLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxNQUFNO0FBQ2xCLGFBQVksTUFBTTtBQUNsQixhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFdBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFZLFFBQVEsT0FBTyxLQUFLO0FBQ2hDO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkIsYUFBWSxNQUFNO0FBQ2xCLGFBQVksT0FBTztBQUNuQixhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYjtBQUNBLGFBQVk7QUFDWjtBQUNBLGNBQWE7QUFDYixjQUFhO0FBQ2I7QUFDQSxhQUFZO0FBQ1osZUFBYyxHQUFHLElBQUk7QUFDckI7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBcUIsY0FBYzs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUc7QUFDSDs7QUFFQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxZQUFXLElBQUksS0FBSztBQUNwQjtBQUNBLE1BQUs7QUFDTCxxREFBb0QsVUFBVTtBQUM5RDtBQUNBO0FBQ0E7O0FBRUEscUJBQW9CLGlDQUFpQztBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVEsR0FBRyxFQUFFO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMEIsRUFBRTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVksYUFBYTtBQUN6QixhQUFZLE9BQU87QUFDbkIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLHFCQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsY0FBYztBQUM3QjtBQUNBOztBQUVBO0FBQ0EsNEJBQTJCO0FBQzNCOztBQUVBO0FBQ0EsOEJBQTZCLFlBQVksR0FBRztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBOEIsUUFBUTtBQUN0Qzs7QUFFQTtBQUNBLFdBQVUsR0FBRyxJQUFJO0FBQ2pCO0FBQ0EsSUFBRztBQUNILHlCQUF3QjtBQUN4Qix5QkFBd0I7QUFDeEI7QUFDQSw4Q0FBNkM7QUFDN0MsK0NBQThDO0FBQzlDLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsMkJBQTBCLE1BQU07QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsMkJBQTBCLE1BQU07QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQSw2QkFBNEIsTUFBTTtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYSxRQUFRLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxFQUFFLFlBQVksZUFBZSxXQUFXLEtBQUssSUFBSTtBQUMzRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0IsSUFBSSxLQUFLO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWMsSUFBSSxLQUFLO0FBQ3ZCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzlZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsWUFBWTs7QUFFNUI7QUFDQSxtQkFBa0IsYUFBYTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLFNBQVM7QUFDckIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBYyxjQUFjO0FBQzVCOztBQUVBO0FBQ0Esa0JBQWlCO0FBQ2pCOztBQUVBO0FBQ0Esb0JBQW1CO0FBQ25COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLFlBQVk7QUFDekQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQW9CLFdBQVc7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBcUIsY0FBYztBQUNuQyxlQUFjLHlCQUF5QjtBQUN2QyxlQUFjLG1CQUFtQjtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFrQyxjQUFjO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLEVBQUU7QUFDZCxhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDdlpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNiQSxnRDs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNsQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLEVBQUU7QUFDZCxhQUFZLEVBQUU7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QixHQUFHO0FBQy9COztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBSztBQUNMLG9CQUFtQixrQkFBa0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFpQixTQUFTO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsTUFBTTtBQUN6QixXQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCLFFBQVE7QUFDMUIsV0FBVSxNQUFNO0FBQ2hCO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQSw4QkFBNkIsRUFBRTtBQUMvQjtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0I7Ozs7OztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4QixhQUFhLEVBQUU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsZUFBYyxRQUFRO0FBQ3RCLGVBQWMsUUFBUTtBQUN0QixhQUFZO0FBQ1o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGFBQVk7O0FBRVo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGFBQVksT0FBTztBQUNuQixhQUFZLFFBQVE7QUFDcEIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxRQUFRO0FBQ25CLFlBQVcsUUFBUTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0EsRzs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWM7O0FBRWQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7Ozs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOzs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsSUFBSTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQixhQUFZLE9BQU87QUFDbkIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFZLE9BQU87QUFDbkIsYUFBWSxPQUFPO0FBQ25CLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBYyxLQUFLLEtBQUs7QUFDeEI7QUFDQTtBQUNBLGtCQUFpQixlQUFlO0FBQ2hDO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNsREE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWixNQUFLLHdCQUF3QjtBQUM3QjtBQUNBOzs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWSxTQUFTO0FBQ3JCLGFBQVksT0FBTztBQUNuQixhQUFZLFFBQVE7QUFDcEIsYUFBWSxRQUFRO0FBQ3BCLGFBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esa0JBQWlCLGFBQWE7QUFDOUIsNEJBQTJCLGNBQWM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzFCQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBdUIsZ0NBQWdDO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9DQUFtQztBQUNuQyxvQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpREFBZ0QsYUFBYTtBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWSxjQUFjO0FBQzFCLGFBQVksT0FBTztBQUNuQixhQUFZLFFBQVE7QUFDcEIsYUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CLGFBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNoTUE7O0FBRUEsZUFBYzs7QUFFZDtBQUNBO0FBQ0Esb0RBQW1EO0FBQ25ELG9DQUFtQztBQUNuQyxxQkFBb0I7QUFDcEIsSUFBRyxJQUFJO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDbEVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQXlDLEVBQUU7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdEJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQStCLGtCQUFrQjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQyx1QkFBdUI7QUFDakUsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0EsUUFBTztBQUNQO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQixnREFBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWCxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1AsTUFBSztBQUNMLElBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTCxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTs7Ozs7Ozs7QUNoZUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsV0FBVyw4RkFBOEYsTUFBTTtBQUMxSDtBQUNBLFlBQVcsV0FBVztBQUN0Qiw4REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFvQyxnQkFBZ0IsRUFBRTtBQUN0RCxxQ0FBb0MsZUFBZSxFQUFFO0FBQ3JELHNDQUFxQyxnQkFBZ0IsRUFBRTtBQUN2RCxJQUFHO0FBQ0gseUNBQXdDLGtCQUFrQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrREFBOEQsYUFBYTtBQUMzRSwrREFBOEQsYUFBYTtBQUMzRTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUNBQWdDO0FBQ2hDO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSw0QjtBQUNBLHFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLE1BQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLE1BQUs7O0FBRUw7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQLDJDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWCxVQUFTO0FBQ1Q7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsTTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQ0FBaUMsMERBQTBELEVBQUU7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEM7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQztBQUNBLFlBQVc7O0FBRVg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QztBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsWUFBVztBQUNYO0FBQ0EsUUFBTztBQUNQLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQztBQUNBO0FBQ0E7QUFDQSw2QztBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSztBQUNMLElBQUc7O0FBRUg7QUFDQTs7QUFFQTs7Ozs7OztBQzNTQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFOztBQUVGO0FBQ0EsMENBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDO0FBQ2pDLG9DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDclFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxPQUFNO0FBQ047O0FBRUE7QUFDQSxrQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSiwwQ0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULFFBQU87QUFDUCxNQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYLFVBQVM7QUFDVCxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUc7QUFDSCw2Q0FBNEM7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDelVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7Ozs7Ozs7O0FDcEJBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFvQjtBQUNwQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsOENBQTZDLGdCQUFnQjtBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBNkMsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDOUhBO0FBQ0E7QUFDQSxxQ0FBa0M7QUFDbEMsSUFBRztBQUNILEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDZkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRyxhQUFhO0FBQ2hCO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTJFLDZFQUE2RTtBQUN4SjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLHVEQUFzRDs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBNkQ7QUFDN0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUEyRDtBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnREFBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFtQixTQUFTO0FBQzVCO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZFQUE0RTs7QUFFNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0RBQW1EO0FBQ25EO0FBQ0Esb0RBQW1ELGlFQUFpRTtBQUNwSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF1QztBQUN2QyxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF1QztBQUN2QyxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7OztBQzU2QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7Ozs7Ozs7QUMxQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMxR0EsZ0I7Ozs7OztBQ0FBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZTtBQUNmLCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEc7Ozs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0JBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBLEU7Ozs7OztBQzFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRyxhQUFhO0FBQ2hCO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLO0FBQ0wsSUFBRztBQUNILEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNILEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBa0Q7O0FBRWxEOztBQUVBLDRDQUEyQztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFtRDtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscURBQW9EO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7Ozs7O0FDeGlCQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsT0FBTztBQUNsQixjQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFRLE9BQU87QUFDZjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM1TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSyxFQUFFO0FBQ1AsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEU7Ozs7OztBQ3JMQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHOzs7Ozs7QUN6QkE7Ozs7Ozs7QUNBQTs7Ozs7OztBQ0FBOzs7Ozs7O0FDQUE7Ozs7Ozs7QUNBQSwrQzs7Ozs7O0FDQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEI7QUFDMUIsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLCtCQUE4QjtBQUM5QjtBQUNBLG9EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCLGlEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsSUFBRztBQUNILHVCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBZ0Msb0JBQW9COztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN6ZUE7QUFDQTs7QUFFQSxhQUFZO0FBQ1o7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBLFNBQVEsdUNBQXVDO0FBQy9DLFNBQVEsMkJBQTJCO0FBQ25DLFNBQVEsMkJBQTJCO0FBQ25DLFNBQVEsMkJBQTJCO0FBQ25DLFNBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBeUMsSUFBSTs7QUFFN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWdDOztBQUVoQyxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHLElBQUk7QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE1BQUs7QUFDTCxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUssSUFBSTtBQUNULE1BQUssR0FBRztBQUNSLE1BQUssS0FBSztBQUNWLE1BQUssSUFBSSxJQUFJLEVBQUU7QUFDZixNQUFLLElBQUksRUFBRSxJQUFJO0FBQ2Y7QUFDQTtBQUNBLE1BQUssSUFBSSxPQUFPLElBQUk7QUFDcEIsTUFBSyxFQUFFLE9BQU8sRUFBRTtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXNCLElBQUk7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSztBQUNMLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQUs7QUFDTCxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBbUMsSUFBSTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxpQ0FBZ0MsRUFBRSxFQUFFLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXdDLFFBQVE7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQSxjQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLLDZDQUE2Qzs7QUFFbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsUUFBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBMkI7QUFDM0I7Ozs7Ozs7QUMxNUJBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBdUI7QUFDdkIsd0JBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW1DO0FBQ25DLHFDQUFvQztBQUNwQztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSx5Q0FBd0MsR0FBRyxJQUFJO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFxQixLQUFLOztBQUUxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBOEI7QUFDOUIsd0NBQXVDLEdBQUc7QUFDMUMsYUFBWSxHQUFHLHlCQUF5QjtBQUN4QztBQUNBO0FBQ0EsK0JBQThCO0FBQzlCLGVBQWMsR0FBRztBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBcUIsS0FBSztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUSxFQUFFO0FBQ1YsNEJBQTJCO0FBQzNCLHVCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQVksS0FBSyxRQUFRLEVBQUUsSUFBSSxFQUFFO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxvQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsb0NBQW1DLDJCQUEyQjtBQUM5RDs7QUFFQSxrQkFBaUIsY0FBYztBQUMvQixvQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUN2TUE7QUFDQTtBQUNBLG9CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNOQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWdDLHNCQUFzQjtBQUN0RDtBQUNBO0FBQ0E7O0FBRUEsNENBQTJDLHlCQUF5QjtBQUNwRTs7QUFFQSwwQ0FBeUMsMEJBQTBCO0FBQ25FO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBOzs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDL09BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSyxzS0FBZ0MsRUFBRTs7QUFFdkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBUztBQUNULFFBQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULFFBQU87QUFDUDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLElBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUErQixZQUFZOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1AsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQzNZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0Y7QUFDQTtBQUNBLGlFOzs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTtBQUNGLCtCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEc7Ozs7OztBQ3ZKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdURBQXNEO0FBQ3REO0FBQ0EsZ0JBQWU7QUFDZjtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUixRQUFPO0FBQ1A7QUFDQSxPQUFNO0FBQ047QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSixJQUFHO0FBQ0gsR0FBRTtBQUNGOzs7Ozs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBd0I7QUFDeEI7QUFDQSxNQUFLLGVBQWUsRUFBRSxJQUFJO0FBQzFCLEtBQUk7QUFDSix5QkFBd0IscUVBQXFFLEVBQUUsSUFBSTtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLLGVBQWU7QUFDcEIsS0FBSTtBQUNKLHNFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBb0YsaURBQWlEO0FBQ3JJO0FBQ0EseUVBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXdELGlEQUFpRDtBQUN6RztBQUNBLDZDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUIsU0FBUztBQUMxQixpQkFBZ0IsU0FBUztBQUN6QixzQkFBcUIsT0FBTztBQUM1QixrQkFBaUIsT0FBTztBQUN4QixxQkFBb0I7QUFDcEIsOEJBQTZCLFdBQVc7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ04sTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQSxNQUFLO0FBQ0wsS0FBSTtBQUNKLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOLE1BQUs7QUFDTCxLQUFJO0FBQ0osSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKLElBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDeFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0dBQThHO0FBQzlHLGlDQUFnQztBQUNoQyxHQUFFLHFCQUFxQjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7Ozs7OztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSw4Q0FBNkMsNkJBQTZCLEVBQUU7QUFDNUU7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osb0lBQW1JLHFCQUFxQixFQUFFO0FBQzFKLElBQUc7QUFDSCxzR0FBcUcscUJBQXFCLEVBQUU7QUFDNUgsSUFBRztBQUNILGdEQUErQyxxQkFBcUIsRUFBRTtBQUN0RTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFnQztBQUNoQyxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsNkRBQTRELE1BQU0scUJBQXFCLEVBQUUsWUFBWSxFQUFFO0FBQ3ZHO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9IQUFtSDtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWCxTQUFRO0FBQ1IsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxnRUFBK0Q7QUFDL0Q7QUFDQSw0RUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsbUhBQWtIO0FBQ2xILG1GQUFrRjtBQUNsRjtBQUNBO0FBQ0Esd0VBQXVFO0FBQ3ZFLHdDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFvRztBQUNwRztBQUNBLGdIQUErRztBQUMvRyxhQUFZO0FBQ1o7QUFDQSxtSkFBa0o7QUFDbEosMkJBQTBCO0FBQzFCO0FBQ0EsaUZBQWdGO0FBQ2hGLFFBQU87QUFDUDtBQUNBLE1BQUsseURBQXlELDhEQUE4RCxFQUFFO0FBQzlILEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7Ozs7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsa0RBQWlEO0FBQ2pELEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxLQUFJO0FBQ0osSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBK0MsdUJBQXVCLEdBQUc7QUFDekU7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSkFBa0o7QUFDbEo7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSCxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBOzs7Ozs7O0FDOU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQjtBQUMxQjtBQUNBLElBQUc7QUFDSDtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0EsOEJBQTZCO0FBQzdCO0FBQ0EsNkJBQTRCOztBQUU1Qix1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSixJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXFDO0FBQ3JDO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUIsNkJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLGdCQUFnQjtBQUNuQztBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLDhCQUE4QjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBLG9EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQiwyQkFBMkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQiw0QkFBNEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWlCLDRCQUE0QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBaUIsNEJBQTRCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQix1Q0FBdUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCLHVDQUF1QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWdCLHdDQUF3QztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNyZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSixJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0osSUFBRztBQUNILEdBQUU7QUFDRjs7Ozs7OztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTs7QUFFSjtBQUNBO0FBQ0EsS0FBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjs7Ozs7OztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsR0FBRTtBQUNGOzs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsS0FBSTtBQUNKO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU07QUFDTjtBQUNBLDBEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBLDBEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFxRDtBQUNyRCw0Q0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFrQztBQUNsQztBQUNBO0FBQ0EsUUFBTztBQUNQLCtCQUE4QjtBQUM5QjtBQUNBLCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsT0FBTTtBQUNOO0FBQ0EsT0FBTTtBQUNOO0FBQ0EsTUFBSztBQUNMLHNEQUFxRDtBQUNyRDtBQUNBLEtBQUk7QUFDSjtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjs7Ozs7OztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDOzs7Ozs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0EsRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkRBQTRELGNBQWM7QUFDMUUsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXFDLGlCQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakIsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQixjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEIsUUFBUTtBQUNwQyw2QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3pUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDUEEsaUJBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMEMsU0FBUztBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNuWkEsaUJBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTJEO0FBQzNELHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7Ozs7OztBQzNJQSxpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEIsaUJBQWdCOztBQUVoQixvQkFBbUI7QUFDbkIscUJBQW9COztBQUVwQixpQkFBZ0I7QUFDaEIsaUJBQWdCOztBQUVoQixpQkFBZ0I7QUFDaEIsa0JBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ2xFQSxpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ2hhQSxpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdkdBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDOUVBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVEQUFzRDtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVzs7QUFFWDtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsTUFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUFzRDtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdURBQXNELFlBQVk7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QixjQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsd0NBQXdDO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBK0MsbUJBQW1CLEVBQUU7QUFDcEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCLE1BQU07QUFDbkM7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLDJCQUEyQjtBQUM5QyxzQkFBcUIsK0NBQStDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsMkJBQTJCO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQiwyQkFBMkI7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0Esc0JBQXFCLDRCQUE0QjtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN6akNBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDOUdBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQjtBQUNBLFlBQVcsU0FBUztBQUNwQjtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQjtBQUNBLFlBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDakhBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsY0FBYztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLFlBQVc7QUFDWDtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7O0FBRUgsV0FBVTtBQUNWOztBQUVBOzs7Ozs7O0FDdFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUVBQWtFO0FBQ2xFLElBQUc7QUFDSCxHQUFFO0FBQ0Y7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMLEtBQUk7QUFDSixJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjs7Ozs7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFzQjtBQUN0QixxQkFBb0I7QUFDcEIsd0JBQXVCO0FBQ3ZCLDhCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4QkFBNkI7QUFDN0Isb0NBQW1DOztBQUVuQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7Ozs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxxQkFBcUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUscUJBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDLGlEQUFpRDtBQUMzRjtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSwyQ0FBMEMsYUFBYTtBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTRCO0FBQzVCO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkIsaURBQWlEO0FBQzlFO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QixhQUFhO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQW9FO0FBQ3BFO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFRO0FBQ1IsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFNO0FBQ047QUFDQSxPQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0EsSUFBRztBQUNILEdBQUU7QUFDRjs7Ozs7Ozs7QUN2VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDUEEsaUJBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMEMsU0FBUztBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUNuWkEsaUJBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTJEO0FBQzNELHFCQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTs7Ozs7OztBQzNJQSxpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEIsaUJBQWdCOztBQUVoQixvQkFBbUI7QUFDbkIscUJBQW9COztBQUVwQixpQkFBZ0I7QUFDaEIsaUJBQWdCOztBQUVoQixpQkFBZ0I7QUFDaEIsa0JBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ2xFQSxpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ2hhQSxpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdkdBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDOUVBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVEQUFzRDtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVzs7QUFFWDtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsTUFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUFzRDtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdURBQXNELFlBQVk7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QixjQUFjO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsd0NBQXdDO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBK0MsbUJBQW1CLEVBQUU7QUFDcEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCLE1BQU07QUFDbkM7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLDJCQUEyQjtBQUM5QyxzQkFBcUIsK0NBQStDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsMkJBQTJCO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQiwyQkFBMkI7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0Esc0JBQXFCLDRCQUE0QjtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN6akNBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDOUdBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQjtBQUNBLFlBQVcsU0FBUztBQUNwQjtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQjtBQUNBLFlBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDakhBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNEMsY0FBYztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLFlBQVc7QUFDWDtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUc7O0FBRUgsV0FBVTtBQUNWOztBQUVBOzs7Ozs7O0FDdFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU0saUJBQWlCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0EsR0FBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOzs7Ozs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0YsaUJBQWdCLDBCQUEwQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrRkFBaUY7O0FBRWpGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkIsNEJBQTRCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW1ELEVBQUUsT0FBTztBQUM1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQSxHQUFFO0FBQ0Y7QUFDQSxHQUFFO0FBQ0Y7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDaFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQXVEOztBQUV2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBdUQ7O0FBRXZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSx3Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQiwyREFBMEQ7QUFDMUQ7QUFDQSwwREFBeUQ7QUFDekQ7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixVQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDBCQUF5QjtBQUN6Qix3QkFBdUI7QUFDdkI7QUFDQTtBQUNBLGtDQUFpQztBQUNqQyxnQ0FBK0I7QUFDL0IsdUNBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTLEVBQUUsV0FBVztBQUN0QjtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXVCLFNBQVM7QUFDaEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBLG9DQUFtQyxxQkFBcUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBLGdDQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9IQUFtSDtBQUNuSCxzQkFBcUI7QUFDckIscUNBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNqd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSCxtQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFnQixzQkFBc0I7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFOzs7Ozs7QUM5NkVBO0FBQ0EsRUFBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsSUFBSTtBQUNkLFlBQVcsT0FBTztBQUNsQixhQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWMsY0FBYztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVSxJQUFJO0FBQ2QsV0FBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW1CLG9CQUFvQjtBQUN2Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLG1CQUFrQix1QkFBdUI7QUFDekM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFVLElBQUk7QUFDZCxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGdCQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUFzQixhQUFhO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUErQixVQUFVO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBYyxTQUFTOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFjLGVBQWU7QUFDN0I7O0FBRUE7O0FBRUE7QUFDQSwyQkFBMEIsV0FBVzs7QUFFckM7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQiw2Q0FBNEMsZUFBZTs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJEQUEwRCxNQUFNOztBQUVoRTtBQUNBOztBQUVBLG1DQUFrQyxzQkFBc0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLFNBQVM7QUFDbkM7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUEsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF1QixLQUFLO0FBQzVCO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUEsNEJBQTJCLE9BQU87O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQSxvQkFBbUIsT0FBTzs7QUFFMUI7O0FBRUEsNEJBQTJCLGVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBYyxlQUFlO0FBQzdCOztBQUVBO0FBQ0EsZUFBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixHQUFHO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUEyQixlQUFlO0FBQzFDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUFzQyxLQUFLO0FBQzNDOztBQUVBOztBQUVBO0FBQ0Esb0JBQW1CLEtBQUs7QUFDeEI7O0FBRUE7QUFDQSw0QkFBMkIsT0FBTzs7QUFFbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMEIsU0FBUztBQUNuQztBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxtQkFBa0IsS0FBSztBQUN2QjtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTtBQUNBLGdDQUErQixNQUFNO0FBQ3JDO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxFQUFDOzs7Ozs7O0FDcm5DRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLHNFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFrRCxlQUFlO0FBQ2pFLDJEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTTtBQUNOLE1BQUs7O0FBRUw7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1AsT0FBTTtBQUNOO0FBQ0E7QUFDQSwrRUFBOEU7QUFDOUU7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSTtBQUNKLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Im1haW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvZGlzdC9cIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCAzYzk0YjNiMjlkZjk1Y2E3Y2NmNyIsInZhciBpc0RldkJ1aWxkID0gcHJvY2Vzcy5hcmd2LmluZGV4T2YoJy0tZW52LnByb2QnKSA8IDA7XHJcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xyXG52YXIgd2VicGFjayA9IHJlcXVpcmUoJ3dlYnBhY2snKTtcclxudmFyIEV4dHJhY3RUZXh0UGx1Z2luID0gcmVxdWlyZSgnZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luJyk7XHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICByZXNvbHZlOiB7XHJcbiAgICAgICAgZXh0ZW5zaW9uczogWyAnJywgJy5qcycgXVxyXG4gICAgfSxcclxuICAgIG1vZHVsZToge1xyXG4gICAgICAgIGxvYWRlcnM6IFtcclxuICAgICAgICAgICAgeyB0ZXN0OiAvXFwuKHBuZ3x3b2ZmfHdvZmYyfGVvdHx0dGZ8c3ZnKShcXD98JCkvLCBsb2FkZXI6ICd1cmwtbG9hZGVyP2xpbWl0PTEwMDAwMCcgfSAgICAgICAgIFxyXG4gICAgICAgIF1cclxuICAgIH0sXHJcbiAgICBlbnRyeToge1xyXG4gICAgICAgIHZlbmRvcjogW1xyXG4gICAgICAgICAgICAnQGFuZ3VsYXIvY29tbW9uJyxcclxuICAgICAgICAgICAgJ0Bhbmd1bGFyL2NvbXBpbGVyJyxcclxuICAgICAgICAgICAgJ0Bhbmd1bGFyL2NvcmUnLFxyXG4gICAgICAgICAgICAnQGFuZ3VsYXIvaHR0cCcsXHJcbiAgICAgICAgICAgICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJyxcclxuICAgICAgICAgICAgJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXItZHluYW1pYycsXHJcbiAgICAgICAgICAgICdAYW5ndWxhci9yb3V0ZXInLFxyXG4gICAgICAgICAgICAnQGFuZ3VsYXIvcGxhdGZvcm0tc2VydmVyJyxcclxuICAgICAgICAgICAgJ2FuZ3VsYXIyLXVuaXZlcnNhbCcsXHJcbiAgICAgICAgICAgICdhbmd1bGFyMi11bml2ZXJzYWwtcG9seWZpbGxzJyxcclxuICAgICAgICAgICAgJ2Jvb3RzdHJhcC1sb2FkZXIvZXh0cmFjdFN0eWxlcycsXHJcbiAgICAgICAgICAgICdlczYtc2hpbScsXHJcbiAgICAgICAgICAgICdlczYtcHJvbWlzZScsXHJcbiAgICAgICAgICAgICdldmVudC1zb3VyY2UtcG9seWZpbGwnLCAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAnem9uZS5qcycsXHJcbiAgICAgICAgICAgICdyeGpzJyxcclxuICAgICAgICAgICAgJ25nMi11cGxvYWRlcicsXHJcbiAgICAgICAgICAgICdib290c3RyYXAnLFxyXG4gICAgICAgICAgICAnZDMnLFxyXG4gICAgICAgICAgICAnYm9vdHN0cmFwLWRhdGVwaWNrZXInLFxyXG5cdFx0XHQncHJpbWVuZy9wcmltZW5nJyxcclxuXHRcdFx0J0Bzd2ltbGFuZS9uZ3gtZGF0YXRhYmxlJ1xyXG4gICAgICAgIF1cclxuICAgIH0sXHJcbiAgICBvdXRwdXQ6IHtcclxuICAgICAgICBwYXRoOiBwYXRoLmpvaW4oX19kaXJuYW1lLCAnd3d3cm9vdCcsICdkaXN0JyksXHJcbiAgICAgICAgZmlsZW5hbWU6ICdbbmFtZV0uanMnLFxyXG4gICAgICAgIGxpYnJhcnk6ICdbbmFtZV1fW2hhc2hdJyxcclxuICAgIH0sXHJcbiAgICBwbHVnaW5zOiBbXHJcbiAgICAgICAgbmV3IEV4dHJhY3RUZXh0UGx1Z2luKCd2ZW5kb3IuY3NzJywgeyBhbGxDaHVua3M6IHRydWUgfSksXHJcbiAgICAgICAgbmV3IHdlYnBhY2suUHJvdmlkZVBsdWdpbih7ICQ6ICdqcXVlcnknLCBqUXVlcnk6ICdqcXVlcnknIH0pLCAvLyBNYXBzIHRoZXNlIGlkZW50aWZpZXJzIHRvIHRoZSBqUXVlcnkgcGFja2FnZSAoYmVjYXVzZSBCb290c3RyYXAgZXhwZWN0cyBpdCB0byBiZSBhIGdsb2JhbCB2YXJpYWJsZSlcclxuICAgICAgICBuZXcgd2VicGFjay5vcHRpbWl6ZS5PY2N1cmVuY2VPcmRlclBsdWdpbigpLFxyXG4gICAgICAgIG5ldyB3ZWJwYWNrLkRsbFBsdWdpbih7XHJcbiAgICAgICAgICAgIHBhdGg6IHBhdGguam9pbihfX2Rpcm5hbWUsICd3d3dyb290JywgJ2Rpc3QnLCAnW25hbWVdLW1hbmlmZXN0Lmpzb24nKSxcclxuICAgICAgICAgICAgbmFtZTogJ1tuYW1lXV9baGFzaF0nXHJcbiAgICAgICAgfSlcclxuICAgIF0uY29uY2F0KGlzRGV2QnVpbGQgPyBbXSA6IFtcclxuICAgICAgICBuZXcgd2VicGFjay5vcHRpbWl6ZS5VZ2xpZnlKc1BsdWdpbih7IGNvbXByZXNzOiB7IHdhcm5pbmdzOiBmYWxzZSB9IH0pXHJcbiAgICBdKVxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3dlYnBhY2suY29uZmlnLnZlbmRvci5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKSgxOCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgdmVuZG9yX2FlOTdiYTFjYjI0MTJjMWE4NjQ0XG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gdmVuZG9yX2FlOTdiYTFjYjI0MTJjMWE4NjQ0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwidmVuZG9yX2FlOTdiYTFjYjI0MTJjMWE4NjQ0XCJcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIENvbXBpbGVyID0gcmVxdWlyZShcIi4vQ29tcGlsZXJcIik7XHJcbnZhciBXZWJFbnZpcm9ubWVudFBsdWdpbiA9IHJlcXVpcmUoXCIuL3dlYi9XZWJFbnZpcm9ubWVudFBsdWdpblwiKTtcclxudmFyIFdlYnBhY2tPcHRpb25zQXBwbHkgPSByZXF1aXJlKFwiLi9XZWJwYWNrT3B0aW9uc0FwcGx5XCIpO1xyXG52YXIgV2VicGFja09wdGlvbnNEZWZhdWx0ZXIgPSByZXF1aXJlKFwiLi9XZWJwYWNrT3B0aW9uc0RlZmF1bHRlclwiKTtcclxuXHJcbmZ1bmN0aW9uIHdlYnBhY2sob3B0aW9ucywgY2FsbGJhY2spIHtcclxuXHRuZXcgV2VicGFja09wdGlvbnNEZWZhdWx0ZXIoKS5wcm9jZXNzKG9wdGlvbnMpO1xyXG5cclxuXHR2YXIgY29tcGlsZXIgPSBuZXcgQ29tcGlsZXIoKTtcclxuXHRjb21waWxlci5vcHRpb25zID0gb3B0aW9ucztcclxuXHRjb21waWxlci5vcHRpb25zID0gbmV3IFdlYnBhY2tPcHRpb25zQXBwbHkoKS5wcm9jZXNzKG9wdGlvbnMsIGNvbXBpbGVyKTtcclxuXHRuZXcgV2ViRW52aXJvbm1lbnRQbHVnaW4ob3B0aW9ucy5pbnB1dEZpbGVTeXN0ZW0sIG9wdGlvbnMub3V0cHV0RmlsZVN5c3RlbSkuYXBwbHkoY29tcGlsZXIpO1xyXG5cdGlmKGNhbGxiYWNrKSB7XHJcblx0XHRjb21waWxlci5ydW4oY2FsbGJhY2spO1xyXG5cdH1cclxuXHRyZXR1cm4gY29tcGlsZXI7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrO1xyXG5cclxud2VicGFjay5XZWJwYWNrT3B0aW9uc0RlZmF1bHRlciA9IFdlYnBhY2tPcHRpb25zRGVmYXVsdGVyO1xyXG53ZWJwYWNrLldlYnBhY2tPcHRpb25zQXBwbHkgPSBXZWJwYWNrT3B0aW9uc0FwcGx5O1xyXG53ZWJwYWNrLkNvbXBpbGVyID0gQ29tcGlsZXI7XHJcbndlYnBhY2suV2ViRW52aXJvbm1lbnRQbHVnaW4gPSBXZWJFbnZpcm9ubWVudFBsdWdpbjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi93ZWJwYWNrLndlYi5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xyXG52YXIgVGFwYWJsZSA9IHJlcXVpcmUoXCJ0YXBhYmxlXCIpO1xyXG5cclxudmFyIENvbXBpbGF0aW9uID0gcmVxdWlyZShcIi4vQ29tcGlsYXRpb25cIik7XHJcbnZhciBQYXJzZXIgPSByZXF1aXJlKFwiLi9QYXJzZXJcIik7XHJcbnZhciBSZXNvbHZlciA9IHJlcXVpcmUoXCJlbmhhbmNlZC1yZXNvbHZlL2xpYi9SZXNvbHZlclwiKTtcclxuXHJcbnZhciBOb3JtYWxNb2R1bGVGYWN0b3J5ID0gcmVxdWlyZShcIi4vTm9ybWFsTW9kdWxlRmFjdG9yeVwiKTtcclxudmFyIENvbnRleHRNb2R1bGVGYWN0b3J5ID0gcmVxdWlyZShcIi4vQ29udGV4dE1vZHVsZUZhY3RvcnlcIik7XHJcblxyXG5mdW5jdGlvbiBXYXRjaGluZyhjb21waWxlciwgd2F0Y2hPcHRpb25zLCBoYW5kbGVyKSB7XHJcblx0dGhpcy5zdGFydFRpbWUgPSBudWxsO1xyXG5cdHRoaXMuaW52YWxpZCA9IGZhbHNlO1xyXG5cdHRoaXMuZXJyb3IgPSBudWxsO1xyXG5cdHRoaXMuc3RhdHMgPSBudWxsO1xyXG5cdHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XHJcblx0aWYodHlwZW9mIHdhdGNoT3B0aW9ucyA9PT0gXCJudW1iZXJcIikge1xyXG5cdFx0dGhpcy53YXRjaE9wdGlvbnMgPSB7XHJcblx0XHRcdGFnZ3JlZ2F0ZVRpbWVvdXQ6IHdhdGNoT3B0aW9uc1xyXG5cdFx0fTtcclxuXHR9IGVsc2UgaWYod2F0Y2hPcHRpb25zICYmIHR5cGVvZiB3YXRjaE9wdGlvbnMgPT09IFwib2JqZWN0XCIpIHtcclxuXHRcdHRoaXMud2F0Y2hPcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh3YXRjaE9wdGlvbnMpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aGlzLndhdGNoT3B0aW9ucyA9IHt9O1xyXG5cdH1cclxuXHR0aGlzLndhdGNoT3B0aW9ucy5hZ2dyZWdhdGVUaW1lb3V0ID0gdGhpcy53YXRjaE9wdGlvbnMuYWdncmVnYXRlVGltZW91dCB8fCAyMDA7XHJcblx0dGhpcy5jb21waWxlciA9IGNvbXBpbGVyO1xyXG5cdHRoaXMucnVubmluZyA9IHRydWU7XHJcblx0dGhpcy5jb21waWxlci5yZWFkUmVjb3JkcyhmdW5jdGlvbihlcnIpIHtcclxuXHRcdGlmKGVycikgcmV0dXJuIHRoaXMuX2RvbmUoZXJyKTtcclxuXHJcblx0XHR0aGlzLl9nbygpO1xyXG5cdH0uYmluZCh0aGlzKSk7XHJcbn1cclxuXHJcbldhdGNoaW5nLnByb3RvdHlwZS5fZ28gPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLnN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG5cdHRoaXMucnVubmluZyA9IHRydWU7XHJcblx0dGhpcy5pbnZhbGlkID0gZmFsc2U7XHJcblx0dGhpcy5jb21waWxlci5hcHBseVBsdWdpbnNBc3luYyhcIndhdGNoLXJ1blwiLCB0aGlzLCBmdW5jdGlvbihlcnIpIHtcclxuXHRcdGlmKGVycikgcmV0dXJuIHRoaXMuX2RvbmUoZXJyKTtcclxuXHRcdHRoaXMuY29tcGlsZXIuY29tcGlsZShmdW5jdGlvbihlcnIsIGNvbXBpbGF0aW9uKSB7XHJcblx0XHRcdGlmKGVycikgcmV0dXJuIHRoaXMuX2RvbmUoZXJyKTtcclxuXHRcdFx0aWYodGhpcy5pbnZhbGlkKSByZXR1cm4gdGhpcy5fZG9uZSgpO1xyXG5cclxuXHRcdFx0aWYodGhpcy5jb21waWxlci5hcHBseVBsdWdpbnNCYWlsUmVzdWx0KFwic2hvdWxkLWVtaXRcIiwgY29tcGlsYXRpb24pID09PSBmYWxzZSkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLl9kb25lKG51bGwsIGNvbXBpbGF0aW9uKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5jb21waWxlci5lbWl0QXNzZXRzKGNvbXBpbGF0aW9uLCBmdW5jdGlvbihlcnIpIHtcclxuXHRcdFx0XHRpZihlcnIpIHJldHVybiB0aGlzLl9kb25lKGVycik7XHJcblx0XHRcdFx0aWYodGhpcy5pbnZhbGlkKSByZXR1cm4gdGhpcy5fZG9uZSgpO1xyXG5cclxuXHRcdFx0XHR0aGlzLmNvbXBpbGVyLmVtaXRSZWNvcmRzKGZ1bmN0aW9uKGVycikge1xyXG5cdFx0XHRcdFx0aWYoZXJyKSByZXR1cm4gdGhpcy5fZG9uZShlcnIpO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9kb25lKG51bGwsIGNvbXBpbGF0aW9uKTtcclxuXHRcdFx0XHR9LmJpbmQodGhpcykpO1xyXG5cdFx0XHR9LmJpbmQodGhpcykpO1xyXG5cdFx0fS5iaW5kKHRoaXMpKTtcclxuXHR9LmJpbmQodGhpcykpO1xyXG59O1xyXG5cclxuV2F0Y2hpbmcucHJvdG90eXBlLl9kb25lID0gZnVuY3Rpb24oZXJyLCBjb21waWxhdGlvbikge1xyXG5cdHRoaXMucnVubmluZyA9IGZhbHNlO1xyXG5cdGlmKHRoaXMuaW52YWxpZCkgcmV0dXJuIHRoaXMuX2dvKCk7XHJcblx0dGhpcy5lcnJvciA9IGVyciB8fCBudWxsO1xyXG5cdHRoaXMuc3RhdHMgPSBjb21waWxhdGlvbiA/IGNvbXBpbGF0aW9uLmdldFN0YXRzKCkgOiBudWxsO1xyXG5cdGlmKHRoaXMuc3RhdHMpIHtcclxuXHRcdHRoaXMuc3RhdHMuc3RhcnRUaW1lID0gdGhpcy5zdGFydFRpbWU7XHJcblx0XHR0aGlzLnN0YXRzLmVuZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuXHR9XHJcblx0aWYodGhpcy5zdGF0cylcclxuXHRcdHRoaXMuY29tcGlsZXIuYXBwbHlQbHVnaW5zKFwiZG9uZVwiLCB0aGlzLnN0YXRzKTtcclxuXHRlbHNlXHJcblx0XHR0aGlzLmNvbXBpbGVyLmFwcGx5UGx1Z2lucyhcImZhaWxlZFwiLCB0aGlzLmVycm9yKTtcclxuXHR0aGlzLmhhbmRsZXIodGhpcy5lcnJvciwgdGhpcy5zdGF0cyk7XHJcblx0aWYoIXRoaXMuZXJyb3IpXHJcblx0XHR0aGlzLndhdGNoKGNvbXBpbGF0aW9uLmZpbGVEZXBlbmRlbmNpZXMsIGNvbXBpbGF0aW9uLmNvbnRleHREZXBlbmRlbmNpZXMsIGNvbXBpbGF0aW9uLm1pc3NpbmdEZXBlbmRlbmNpZXMpO1xyXG59O1xyXG5cclxuV2F0Y2hpbmcucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24oZmlsZXMsIGRpcnMsIG1pc3NpbmcpIHtcclxuXHR0aGlzLndhdGNoZXIgPSB0aGlzLmNvbXBpbGVyLndhdGNoRmlsZVN5c3RlbS53YXRjaChmaWxlcywgZGlycywgbWlzc2luZywgdGhpcy5zdGFydFRpbWUsIHRoaXMud2F0Y2hPcHRpb25zLCBmdW5jdGlvbihlcnIsIGZpbGVzTW9kaWZpZWQsIGNvbnRleHRNb2RpZmllZCwgbWlzc2luZ01vZGlmaWVkLCBmaWxlVGltZXN0YW1wcywgY29udGV4dFRpbWVzdGFtcHMpIHtcclxuXHRcdHRoaXMud2F0Y2hlciA9IG51bGw7XHJcblx0XHRpZihlcnIpIHJldHVybiB0aGlzLmhhbmRsZXIoZXJyKTtcclxuXHJcblx0XHR0aGlzLmNvbXBpbGVyLmZpbGVUaW1lc3RhbXBzID0gZmlsZVRpbWVzdGFtcHM7XHJcblx0XHR0aGlzLmNvbXBpbGVyLmNvbnRleHRUaW1lc3RhbXBzID0gY29udGV4dFRpbWVzdGFtcHM7XHJcblx0XHR0aGlzLmludmFsaWRhdGUoKTtcclxuXHR9LmJpbmQodGhpcyksIGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5jb21waWxlci5hcHBseVBsdWdpbnMoXCJpbnZhbGlkXCIpO1xyXG5cdH0uYmluZCh0aGlzKSk7XHJcbn07XHJcblxyXG5XYXRjaGluZy5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdGlmKHRoaXMud2F0Y2hlcikge1xyXG5cdFx0dGhpcy53YXRjaGVyLnBhdXNlKCk7XHJcblx0XHR0aGlzLndhdGNoZXIgPSBudWxsO1xyXG5cdH1cclxuXHRpZih0aGlzLnJ1bm5pbmcpIHtcclxuXHRcdHRoaXMuaW52YWxpZCA9IHRydWU7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRoaXMuX2dvKCk7XHJcblx0fVxyXG59O1xyXG5cclxuV2F0Y2hpbmcucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuXHRpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSBjYWxsYmFjayA9IGZ1bmN0aW9uKCkge307XHJcblxyXG5cdGlmKHRoaXMud2F0Y2hlcikge1xyXG5cdFx0dGhpcy53YXRjaGVyLmNsb3NlKCk7XHJcblx0XHR0aGlzLndhdGNoZXIgPSBudWxsO1xyXG5cdH1cclxuXHRpZih0aGlzLnJ1bm5pbmcpIHtcclxuXHRcdHRoaXMuaW52YWxpZCA9IHRydWU7XHJcblx0XHR0aGlzLl9kb25lID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHR9O1xyXG5cdH0gZWxzZSB7XHJcblx0XHRjYWxsYmFjaygpO1xyXG5cdH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIENvbXBpbGVyKCkge1xyXG5cdFRhcGFibGUuY2FsbCh0aGlzKTtcclxuXHJcblx0dGhpcy5vdXRwdXRQYXRoID0gXCJcIjtcclxuXHR0aGlzLm91dHB1dEZpbGVTeXN0ZW0gPSBudWxsO1xyXG5cdHRoaXMuaW5wdXRGaWxlU3lzdGVtID0gbnVsbDtcclxuXHJcblx0dGhpcy5yZWNvcmRzSW5wdXRQYXRoID0gbnVsbDtcclxuXHR0aGlzLnJlY29yZHNPdXRwdXRQYXRoID0gbnVsbDtcclxuXHR0aGlzLnJlY29yZHMgPSB7fTtcclxuXHJcblx0dGhpcy5maWxlVGltZXN0YW1wcyA9IHt9O1xyXG5cdHRoaXMuY29udGV4dFRpbWVzdGFtcHMgPSB7fTtcclxuXHJcblx0dGhpcy5yZXNvbHZlcnMgPSB7XHJcblx0XHRub3JtYWw6IG5ldyBSZXNvbHZlcihudWxsKSxcclxuXHRcdGxvYWRlcjogbmV3IFJlc29sdmVyKG51bGwpLFxyXG5cdFx0Y29udGV4dDogbmV3IFJlc29sdmVyKG51bGwpXHJcblx0fTtcclxuXHR0aGlzLnBhcnNlciA9IG5ldyBQYXJzZXIoKTtcclxuXHJcblx0dGhpcy5vcHRpb25zID0ge307XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBDb21waWxlcjtcclxuXHJcbkNvbXBpbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVGFwYWJsZS5wcm90b3R5cGUpO1xyXG5Db21waWxlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb21waWxlcjtcclxuXHJcbkNvbXBpbGVyLldhdGNoaW5nID0gV2F0Y2hpbmc7XHJcbkNvbXBpbGVyLnByb3RvdHlwZS53YXRjaCA9IGZ1bmN0aW9uKHdhdGNoT3B0aW9ucywgaGFuZGxlcikge1xyXG5cdHRoaXMuZmlsZVRpbWVzdGFtcHMgPSB7fTtcclxuXHR0aGlzLmNvbnRleHRUaW1lc3RhbXBzID0ge307XHJcblx0dmFyIHdhdGNoaW5nID0gbmV3IFdhdGNoaW5nKHRoaXMsIHdhdGNoT3B0aW9ucywgaGFuZGxlcik7XHJcblx0cmV0dXJuIHdhdGNoaW5nO1xyXG59O1xyXG5cclxuQ29tcGlsZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcblx0dmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG5cdHRoaXMuYXBwbHlQbHVnaW5zQXN5bmMoXCJydW5cIiwgdGhpcywgZnVuY3Rpb24oZXJyKSB7XHJcblx0XHRpZihlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG5cclxuXHRcdHRoaXMucmVhZFJlY29yZHMoZnVuY3Rpb24oZXJyKSB7XHJcblx0XHRcdGlmKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcblxyXG5cdFx0XHR0aGlzLmNvbXBpbGUoZnVuY3Rpb24oZXJyLCBjb21waWxhdGlvbikge1xyXG5cdFx0XHRcdGlmKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcblxyXG5cdFx0XHRcdGlmKHRoaXMuYXBwbHlQbHVnaW5zQmFpbFJlc3VsdChcInNob3VsZC1lbWl0XCIsIGNvbXBpbGF0aW9uKSA9PT0gZmFsc2UpIHtcclxuXHRcdFx0XHRcdHZhciBzdGF0cyA9IGNvbXBpbGF0aW9uLmdldFN0YXRzKCk7XHJcblx0XHRcdFx0XHRzdGF0cy5zdGFydFRpbWUgPSBzdGFydFRpbWU7XHJcblx0XHRcdFx0XHRzdGF0cy5lbmRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcblx0XHRcdFx0XHR0aGlzLmFwcGx5UGx1Z2lucyhcImRvbmVcIiwgc3RhdHMpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKG51bGwsIHN0YXRzKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuZW1pdEFzc2V0cyhjb21waWxhdGlvbiwgZnVuY3Rpb24oZXJyKSB7XHJcblx0XHRcdFx0XHRpZihlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMuZW1pdFJlY29yZHMoZnVuY3Rpb24oZXJyKSB7XHJcblx0XHRcdFx0XHRcdGlmKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgc3RhdHMgPSBjb21waWxhdGlvbi5nZXRTdGF0cygpO1xyXG5cdFx0XHRcdFx0XHRzdGF0cy5zdGFydFRpbWUgPSBzdGFydFRpbWU7XHJcblx0XHRcdFx0XHRcdHN0YXRzLmVuZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuXHRcdFx0XHRcdFx0dGhpcy5hcHBseVBsdWdpbnMoXCJkb25lXCIsIHN0YXRzKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKG51bGwsIHN0YXRzKTtcclxuXHRcdFx0XHRcdH0uYmluZCh0aGlzKSk7XHJcblx0XHRcdFx0fS5iaW5kKHRoaXMpKTtcclxuXHRcdFx0fS5iaW5kKHRoaXMpKTtcclxuXHRcdH0uYmluZCh0aGlzKSk7XHJcblx0fS5iaW5kKHRoaXMpKTtcclxufTtcclxuXHJcbkNvbXBpbGVyLnByb3RvdHlwZS5ydW5Bc0NoaWxkID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuXHR0aGlzLmNvbXBpbGUoZnVuY3Rpb24oZXJyLCBjb21waWxhdGlvbikge1xyXG5cdFx0aWYoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHJcblx0XHR0aGlzLnBhcmVudENvbXBpbGF0aW9uLmNoaWxkcmVuLnB1c2goY29tcGlsYXRpb24pO1xyXG5cdFx0T2JqZWN0LmtleXMoY29tcGlsYXRpb24uYXNzZXRzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcclxuXHRcdFx0dGhpcy5wYXJlbnRDb21waWxhdGlvbi5hc3NldHNbbmFtZV0gPSBjb21waWxhdGlvbi5hc3NldHNbbmFtZV07XHJcblx0XHR9LmJpbmQodGhpcykpO1xyXG5cclxuXHRcdHZhciBlbnRyaWVzID0gY29tcGlsYXRpb24uY2h1bmtzLmZpbHRlcihmdW5jdGlvbihjaHVuaykge1xyXG5cdFx0XHRyZXR1cm4gY2h1bmsuZW50cnk7XHJcblx0XHR9KTtcclxuXHRcdHJldHVybiBjYWxsYmFjayhudWxsLCBlbnRyaWVzLCBjb21waWxhdGlvbik7XHJcblx0fS5iaW5kKHRoaXMpKTtcclxufTtcclxuXHJcbkNvbXBpbGVyLnByb3RvdHlwZS5wdXJnZUlucHV0RmlsZVN5c3RlbSA9IGZ1bmN0aW9uKCkge1xyXG5cdGlmKHRoaXMuaW5wdXRGaWxlU3lzdGVtICYmIHRoaXMuaW5wdXRGaWxlU3lzdGVtLnB1cmdlKVxyXG5cdFx0dGhpcy5pbnB1dEZpbGVTeXN0ZW0ucHVyZ2UoKTtcclxufTtcclxuXHJcbkNvbXBpbGVyLnByb3RvdHlwZS5lbWl0QXNzZXRzID0gZnVuY3Rpb24oY29tcGlsYXRpb24sIGNhbGxiYWNrKSB7XHJcblx0dmFyIG91dHB1dFBhdGg7XHJcblxyXG5cdHRoaXMuYXBwbHlQbHVnaW5zQXN5bmMoXCJlbWl0XCIsIGNvbXBpbGF0aW9uLCBmdW5jdGlvbihlcnIpIHtcclxuXHRcdGlmKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcblx0XHRvdXRwdXRQYXRoID0gY29tcGlsYXRpb24uZ2V0UGF0aCh0aGlzLm91dHB1dFBhdGgpO1xyXG5cdFx0dGhpcy5vdXRwdXRGaWxlU3lzdGVtLm1rZGlycChvdXRwdXRQYXRoLCBlbWl0RmlsZXMuYmluZCh0aGlzKSk7XHJcblx0fS5iaW5kKHRoaXMpKTtcclxuXHJcblx0ZnVuY3Rpb24gZW1pdEZpbGVzKGVycikge1xyXG5cdFx0aWYoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHJcblx0XHRyZXF1aXJlKFwiYXN5bmNcIikuZm9yRWFjaChPYmplY3Qua2V5cyhjb21waWxhdGlvbi5hc3NldHMpLCBmdW5jdGlvbihmaWxlLCBjYWxsYmFjaykge1xyXG5cclxuXHRcdFx0dmFyIHRhcmdldEZpbGUgPSBmaWxlO1xyXG5cdFx0XHR2YXIgcXVlcnlTdHJpbmdJZHggPSB0YXJnZXRGaWxlLmluZGV4T2YoXCI/XCIpO1xyXG5cdFx0XHRpZihxdWVyeVN0cmluZ0lkeCA+PSAwKSB7XHJcblx0XHRcdFx0dGFyZ2V0RmlsZSA9IHRhcmdldEZpbGUuc3Vic3RyKDAsIHF1ZXJ5U3RyaW5nSWR4KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYodGFyZ2V0RmlsZS5tYXRjaCgvXFwvfFxcXFwvKSkge1xyXG5cdFx0XHRcdHZhciBkaXIgPSBwYXRoLmRpcm5hbWUodGFyZ2V0RmlsZSk7XHJcblx0XHRcdFx0dGhpcy5vdXRwdXRGaWxlU3lzdGVtLm1rZGlycCh0aGlzLm91dHB1dEZpbGVTeXN0ZW0uam9pbihvdXRwdXRQYXRoLCBkaXIpLCB3cml0ZU91dC5iaW5kKHRoaXMpKTtcclxuXHRcdFx0fSBlbHNlIHdyaXRlT3V0LmNhbGwodGhpcyk7XHJcblxyXG5cdFx0XHRmdW5jdGlvbiB3cml0ZU91dChlcnIpIHtcclxuXHRcdFx0XHRpZihlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG5cdFx0XHRcdHZhciB0YXJnZXRQYXRoID0gdGhpcy5vdXRwdXRGaWxlU3lzdGVtLmpvaW4ob3V0cHV0UGF0aCwgdGFyZ2V0RmlsZSk7XHJcblx0XHRcdFx0dmFyIHNvdXJjZSA9IGNvbXBpbGF0aW9uLmFzc2V0c1tmaWxlXTtcclxuXHRcdFx0XHRpZihzb3VyY2UuZXhpc3RzQXQgPT09IHRhcmdldFBhdGgpIHtcclxuXHRcdFx0XHRcdHNvdXJjZS5lbWl0dGVkID0gZmFsc2U7XHJcblx0XHRcdFx0XHRyZXR1cm4gY2FsbGJhY2soKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dmFyIGNvbnRlbnQgPSBzb3VyY2Uuc291cmNlKCk7XHJcblx0XHRcdFx0aWYoIUJ1ZmZlci5pc0J1ZmZlcihjb250ZW50KSlcclxuXHRcdFx0XHRcdGNvbnRlbnQgPSBuZXcgQnVmZmVyKGNvbnRlbnQsIFwidXRmLThcIik7XHJcblx0XHRcdFx0c291cmNlLmV4aXN0c0F0ID0gdGFyZ2V0UGF0aDtcclxuXHRcdFx0XHRzb3VyY2UuZW1pdHRlZCA9IHRydWU7XHJcblx0XHRcdFx0dGhpcy5vdXRwdXRGaWxlU3lzdGVtLndyaXRlRmlsZSh0YXJnZXRQYXRoLCBjb250ZW50LCBjYWxsYmFjayk7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9LmJpbmQodGhpcyksIGZ1bmN0aW9uKGVycikge1xyXG5cdFx0XHRpZihlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG5cclxuXHRcdFx0YWZ0ZXJFbWl0LmNhbGwodGhpcyk7XHJcblx0XHR9LmJpbmQodGhpcykpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gYWZ0ZXJFbWl0KCkge1xyXG5cdFx0dGhpcy5hcHBseVBsdWdpbnNBc3luYyhcImFmdGVyLWVtaXRcIiwgY29tcGlsYXRpb24sIGZ1bmN0aW9uKGVycikge1xyXG5cdFx0XHRpZihlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGNhbGxiYWNrKCk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG59O1xyXG5cclxuQ29tcGlsZXIucHJvdG90eXBlLmVtaXRSZWNvcmRzID0gZnVuY3Rpb24gZW1pdFJlY29yZHMoY2FsbGJhY2spIHtcclxuXHRpZighdGhpcy5yZWNvcmRzT3V0cHV0UGF0aCkgcmV0dXJuIGNhbGxiYWNrKCk7XHJcblx0dmFyIGlkeDEgPSB0aGlzLnJlY29yZHNPdXRwdXRQYXRoLmxhc3RJbmRleE9mKFwiL1wiKTtcclxuXHR2YXIgaWR4MiA9IHRoaXMucmVjb3Jkc091dHB1dFBhdGgubGFzdEluZGV4T2YoXCJcXFxcXCIpO1xyXG5cdHZhciByZWNvcmRzT3V0cHV0UGF0aERpcmVjdG9yeSA9IG51bGw7XHJcblx0aWYoaWR4MSA+IGlkeDIpIHJlY29yZHNPdXRwdXRQYXRoRGlyZWN0b3J5ID0gdGhpcy5yZWNvcmRzT3V0cHV0UGF0aC5zdWJzdHIoMCwgaWR4MSk7XHJcblx0aWYoaWR4MSA8IGlkeDIpIHJlY29yZHNPdXRwdXRQYXRoRGlyZWN0b3J5ID0gdGhpcy5yZWNvcmRzT3V0cHV0UGF0aC5zdWJzdHIoMCwgaWR4Mik7XHJcblx0aWYoIXJlY29yZHNPdXRwdXRQYXRoRGlyZWN0b3J5KSByZXR1cm4gd3JpdGVGaWxlLmNhbGwodGhpcyk7XHJcblx0dGhpcy5vdXRwdXRGaWxlU3lzdGVtLm1rZGlycChyZWNvcmRzT3V0cHV0UGF0aERpcmVjdG9yeSwgZnVuY3Rpb24oZXJyKSB7XHJcblx0XHRpZihlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG5cdFx0d3JpdGVGaWxlLmNhbGwodGhpcyk7XHJcblx0fS5iaW5kKHRoaXMpKTtcclxuXHJcblx0ZnVuY3Rpb24gd3JpdGVGaWxlKCkge1xyXG5cdFx0dGhpcy5vdXRwdXRGaWxlU3lzdGVtLndyaXRlRmlsZSh0aGlzLnJlY29yZHNPdXRwdXRQYXRoLCBKU09OLnN0cmluZ2lmeSh0aGlzLnJlY29yZHMsIHVuZGVmaW5lZCwgMiksIGNhbGxiYWNrKTtcclxuXHR9XHJcbn07XHJcblxyXG5Db21waWxlci5wcm90b3R5cGUucmVhZFJlY29yZHMgPSBmdW5jdGlvbiByZWFkUmVjb3JkcyhjYWxsYmFjaykge1xyXG5cdGlmKCF0aGlzLnJlY29yZHNJbnB1dFBhdGgpIHtcclxuXHRcdHRoaXMucmVjb3JkcyA9IHt9O1xyXG5cdFx0cmV0dXJuIGNhbGxiYWNrKCk7XHJcblx0fVxyXG5cdHRoaXMuaW5wdXRGaWxlU3lzdGVtLnN0YXQodGhpcy5yZWNvcmRzSW5wdXRQYXRoLCBmdW5jdGlvbihlcnIpIHtcclxuXHRcdC8vIEl0IGRvZXNuJ3QgZXhpc3RcclxuXHRcdC8vIFdlIGNhbiBpZ25vcmUgdGhpcy5cclxuXHRcdGlmKGVycikgcmV0dXJuIGNhbGxiYWNrKCk7XHJcblxyXG5cdFx0dGhpcy5pbnB1dEZpbGVTeXN0ZW0ucmVhZEZpbGUodGhpcy5yZWNvcmRzSW5wdXRQYXRoLCBmdW5jdGlvbihlcnIsIGNvbnRlbnQpIHtcclxuXHRcdFx0aWYoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0dGhpcy5yZWNvcmRzID0gSlNPTi5wYXJzZShjb250ZW50KTtcclxuXHRcdFx0fSBjYXRjaChlKSB7XHJcblx0XHRcdFx0ZS5tZXNzYWdlID0gXCJDYW5ub3QgcGFyc2UgcmVjb3JkczogXCIgKyBlLm1lc3NhZ2U7XHJcblx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKGUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gY2FsbGJhY2soKTtcclxuXHRcdH0uYmluZCh0aGlzKSk7XHJcblx0fS5iaW5kKHRoaXMpKTtcclxufTtcclxuXHJcbkNvbXBpbGVyLnByb3RvdHlwZS5jcmVhdGVDaGlsZENvbXBpbGVyID0gZnVuY3Rpb24oY29tcGlsYXRpb24sIGNvbXBpbGVyTmFtZSwgb3V0cHV0T3B0aW9ucykge1xyXG5cdHZhciBjaGlsZENvbXBpbGVyID0gbmV3IENvbXBpbGVyKCk7XHJcblx0Zm9yKHZhciBuYW1lIGluIHRoaXMuX3BsdWdpbnMpIHtcclxuXHRcdGlmKFtcIm1ha2VcIiwgXCJjb21waWxlXCIsIFwiZW1pdFwiLCBcImFmdGVyLWVtaXRcIiwgXCJpbnZhbGlkXCIsIFwiZG9uZVwiLCBcInRoaXMtY29tcGlsYXRpb25cIl0uaW5kZXhPZihuYW1lKSA8IDApXHJcblx0XHRcdGNoaWxkQ29tcGlsZXIuX3BsdWdpbnNbbmFtZV0gPSB0aGlzLl9wbHVnaW5zW25hbWVdLnNsaWNlKCk7XHJcblx0fVxyXG5cdGNoaWxkQ29tcGlsZXIubmFtZSA9IGNvbXBpbGVyTmFtZTtcclxuXHRjaGlsZENvbXBpbGVyLm91dHB1dFBhdGggPSB0aGlzLm91dHB1dFBhdGg7XHJcblx0Y2hpbGRDb21waWxlci5pbnB1dEZpbGVTeXN0ZW0gPSB0aGlzLmlucHV0RmlsZVN5c3RlbTtcclxuXHRjaGlsZENvbXBpbGVyLm91dHB1dEZpbGVTeXN0ZW0gPSBudWxsO1xyXG5cdGNoaWxkQ29tcGlsZXIucmVzb2x2ZXJzID0gdGhpcy5yZXNvbHZlcnM7XHJcblx0Y2hpbGRDb21waWxlci5wYXJzZXIgPSB0aGlzLnBhcnNlcjtcclxuXHRjaGlsZENvbXBpbGVyLmZpbGVUaW1lc3RhbXBzID0gdGhpcy5maWxlVGltZXN0YW1wcztcclxuXHRjaGlsZENvbXBpbGVyLmNvbnRleHRUaW1lc3RhbXBzID0gdGhpcy5jb250ZXh0VGltZXN0YW1wcztcclxuXHRpZighdGhpcy5yZWNvcmRzW2NvbXBpbGVyTmFtZV0pIHRoaXMucmVjb3Jkc1tjb21waWxlck5hbWVdID0gW107XHJcblx0dGhpcy5yZWNvcmRzW2NvbXBpbGVyTmFtZV0ucHVzaChjaGlsZENvbXBpbGVyLnJlY29yZHMgPSB7fSk7XHJcblx0Y2hpbGRDb21waWxlci5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh0aGlzLm9wdGlvbnMpO1xyXG5cdGNoaWxkQ29tcGlsZXIub3B0aW9ucy5vdXRwdXQgPSBPYmplY3QuY3JlYXRlKGNoaWxkQ29tcGlsZXIub3B0aW9ucy5vdXRwdXQpO1xyXG5cdGZvcihuYW1lIGluIG91dHB1dE9wdGlvbnMpIHtcclxuXHRcdGNoaWxkQ29tcGlsZXIub3B0aW9ucy5vdXRwdXRbbmFtZV0gPSBvdXRwdXRPcHRpb25zW25hbWVdO1xyXG5cdH1cclxuXHRjaGlsZENvbXBpbGVyLnBhcmVudENvbXBpbGF0aW9uID0gY29tcGlsYXRpb247XHJcblx0cmV0dXJuIGNoaWxkQ29tcGlsZXI7XHJcbn07XHJcblxyXG5Db21waWxlci5wcm90b3R5cGUuaXNDaGlsZCA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiAhIXRoaXMucGFyZW50Q29tcGlsYXRpb247XHJcbn07XHJcblxyXG5Db21waWxlci5wcm90b3R5cGUuY3JlYXRlQ29tcGlsYXRpb24gPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbmV3IENvbXBpbGF0aW9uKHRoaXMpO1xyXG59O1xyXG5cclxuQ29tcGlsZXIucHJvdG90eXBlLm5ld0NvbXBpbGF0aW9uID0gZnVuY3Rpb24ocGFyYW1zKSB7XHJcblx0dmFyIGNvbXBpbGF0aW9uID0gdGhpcy5jcmVhdGVDb21waWxhdGlvbigpO1xyXG5cdGNvbXBpbGF0aW9uLmZpbGVUaW1lc3RhbXBzID0gdGhpcy5maWxlVGltZXN0YW1wcztcclxuXHRjb21waWxhdGlvbi5jb250ZXh0VGltZXN0YW1wcyA9IHRoaXMuY29udGV4dFRpbWVzdGFtcHM7XHJcblx0Y29tcGlsYXRpb24ubmFtZSA9IHRoaXMubmFtZTtcclxuXHRjb21waWxhdGlvbi5yZWNvcmRzID0gdGhpcy5yZWNvcmRzO1xyXG5cdHRoaXMuYXBwbHlQbHVnaW5zKFwidGhpcy1jb21waWxhdGlvblwiLCBjb21waWxhdGlvbiwgcGFyYW1zKTtcclxuXHR0aGlzLmFwcGx5UGx1Z2lucyhcImNvbXBpbGF0aW9uXCIsIGNvbXBpbGF0aW9uLCBwYXJhbXMpO1xyXG5cdHJldHVybiBjb21waWxhdGlvbjtcclxufTtcclxuXHJcbkNvbXBpbGVyLnByb3RvdHlwZS5jcmVhdGVOb3JtYWxNb2R1bGVGYWN0b3J5ID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIG5vcm1hbE1vZHVsZUZhY3RvcnkgPSBuZXcgTm9ybWFsTW9kdWxlRmFjdG9yeSh0aGlzLm9wdGlvbnMuY29udGV4dCwgdGhpcy5yZXNvbHZlcnMsIHRoaXMucGFyc2VyLCB0aGlzLm9wdGlvbnMubW9kdWxlIHx8IHt9KTtcclxuXHR0aGlzLmFwcGx5UGx1Z2lucyhcIm5vcm1hbC1tb2R1bGUtZmFjdG9yeVwiLCBub3JtYWxNb2R1bGVGYWN0b3J5KTtcclxuXHRyZXR1cm4gbm9ybWFsTW9kdWxlRmFjdG9yeTtcclxufTtcclxuXHJcbkNvbXBpbGVyLnByb3RvdHlwZS5jcmVhdGVDb250ZXh0TW9kdWxlRmFjdG9yeSA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBjb250ZXh0TW9kdWxlRmFjdG9yeSA9IG5ldyBDb250ZXh0TW9kdWxlRmFjdG9yeSh0aGlzLnJlc29sdmVycywgdGhpcy5pbnB1dEZpbGVTeXN0ZW0pO1xyXG5cdHRoaXMuYXBwbHlQbHVnaW5zKFwiY29udGV4dC1tb2R1bGUtZmFjdG9yeVwiLCBjb250ZXh0TW9kdWxlRmFjdG9yeSk7XHJcblx0cmV0dXJuIGNvbnRleHRNb2R1bGVGYWN0b3J5O1xyXG59O1xyXG5cclxuQ29tcGlsZXIucHJvdG90eXBlLm5ld0NvbXBpbGF0aW9uUGFyYW1zID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIHBhcmFtcyA9IHtcclxuXHRcdG5vcm1hbE1vZHVsZUZhY3Rvcnk6IHRoaXMuY3JlYXRlTm9ybWFsTW9kdWxlRmFjdG9yeSgpLFxyXG5cdFx0Y29udGV4dE1vZHVsZUZhY3Rvcnk6IHRoaXMuY3JlYXRlQ29udGV4dE1vZHVsZUZhY3RvcnkoKVxyXG5cdH07XHJcblx0cmV0dXJuIHBhcmFtcztcclxufTtcclxuXHJcbkNvbXBpbGVyLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuXHR2YXIgcGFyYW1zID0gdGhpcy5uZXdDb21waWxhdGlvblBhcmFtcygpO1xyXG5cdHRoaXMuYXBwbHlQbHVnaW5zKFwiY29tcGlsZVwiLCBwYXJhbXMpO1xyXG5cclxuXHR2YXIgY29tcGlsYXRpb24gPSB0aGlzLm5ld0NvbXBpbGF0aW9uKHBhcmFtcyk7XHJcblxyXG5cdHRoaXMuYXBwbHlQbHVnaW5zUGFyYWxsZWwoXCJtYWtlXCIsIGNvbXBpbGF0aW9uLCBmdW5jdGlvbihlcnIpIHtcclxuXHRcdGlmKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcblxyXG5cdFx0Y29tcGlsYXRpb24uc2VhbChmdW5jdGlvbihlcnIpIHtcclxuXHRcdFx0aWYoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHJcblx0XHRcdHRoaXMuYXBwbHlQbHVnaW5zQXN5bmMoXCJhZnRlci1jb21waWxlXCIsIGNvbXBpbGF0aW9uLCBmdW5jdGlvbihlcnIpIHtcclxuXHRcdFx0XHRpZihlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gY2FsbGJhY2sobnVsbCwgY29tcGlsYXRpb24pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0uYmluZCh0aGlzKSk7XHJcblx0fS5iaW5kKHRoaXMpKTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9Db21waWxlci5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKSgxNCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgdmVuZG9yX2FlOTdiYTFjYjI0MTJjMWE4NjQ0XG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbmZ1bmN0aW9uIFRhcGFibGUoKSB7XHJcblx0dGhpcy5fcGx1Z2lucyA9IHt9O1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gVGFwYWJsZTtcclxuXHJcbmZ1bmN0aW9uIGNvcHlQcm9wZXJ0aWVzKGZyb20sIHRvKSB7XHJcblx0Zm9yKHZhciBrZXkgaW4gZnJvbSlcclxuXHRcdHRvW2tleV0gPSBmcm9tW2tleV07XHJcblx0cmV0dXJuIHRvO1xyXG59XHJcblxyXG5UYXBhYmxlLm1peGluID0gZnVuY3Rpb24gbWl4aW5UYXBhYmxlKHB0KSB7XHJcblx0Y29weVByb3BlcnRpZXMoVGFwYWJsZS5wcm90b3R5cGUsIHB0KTtcclxufVxyXG5cclxuVGFwYWJsZS5wcm90b3R5cGUuYXBwbHlQbHVnaW5zID0gZnVuY3Rpb24gYXBwbHlQbHVnaW5zKG5hbWUpIHtcclxuXHRpZighdGhpcy5fcGx1Z2luc1tuYW1lXSkgcmV0dXJuO1xyXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHR2YXIgcGx1Z2lucyA9IHRoaXMuX3BsdWdpbnNbbmFtZV07XHJcblx0dmFyIG9sZCA9IHRoaXMuX2N1cnJlbnRQbHVnaW5BcHBseTtcclxuXHRmb3IodGhpcy5fY3VycmVudFBsdWdpbkFwcGx5ID0gMDsgdGhpcy5fY3VycmVudFBsdWdpbkFwcGx5IDwgcGx1Z2lucy5sZW5ndGg7IHRoaXMuX2N1cnJlbnRQbHVnaW5BcHBseSsrKVxyXG5cdFx0cGx1Z2luc1t0aGlzLl9jdXJyZW50UGx1Z2luQXBwbHldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG5cdHRoaXMuX2N1cnJlbnRQbHVnaW5BcHBseSA9IG9sZDtcclxufTtcclxuXHJcblRhcGFibGUucHJvdG90eXBlLmFwcGx5UGx1Z2luc1dhdGVyZmFsbCA9IGZ1bmN0aW9uIGFwcGx5UGx1Z2lucyhuYW1lLCBpbml0KSB7XHJcblx0aWYoIXRoaXMuX3BsdWdpbnNbbmFtZV0pIHJldHVybiBpbml0O1xyXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcclxuXHR2YXIgcGx1Z2lucyA9IHRoaXMuX3BsdWdpbnNbbmFtZV07XHJcblx0dmFyIGN1cnJlbnQgPSBpbml0O1xyXG5cdHZhciBvbGQgPSB0aGlzLl9jdXJyZW50UGx1Z2luQXBwbHk7XHJcblx0Zm9yKHRoaXMuX2N1cnJlbnRQbHVnaW5BcHBseSA9IDA7IHRoaXMuX2N1cnJlbnRQbHVnaW5BcHBseSA8IHBsdWdpbnMubGVuZ3RoOyB0aGlzLl9jdXJyZW50UGx1Z2luQXBwbHkrKylcclxuXHRcdGN1cnJlbnQgPSBwbHVnaW5zW3RoaXMuX2N1cnJlbnRQbHVnaW5BcHBseV0uYXBwbHkodGhpcywgW2N1cnJlbnRdLmNvbmNhdChhcmdzKSk7XHJcblx0dGhpcy5fY3VycmVudFBsdWdpbkFwcGx5ID0gb2xkO1xyXG5cdHJldHVybiBjdXJyZW50O1xyXG59O1xyXG5cclxuVGFwYWJsZS5wcm90b3R5cGUuYXBwbHlQbHVnaW5zQmFpbFJlc3VsdCA9IGZ1bmN0aW9uIGFwcGx5UGx1Z2luc0JhaWxSZXN1bHQobmFtZSkge1xyXG5cdGlmKCF0aGlzLl9wbHVnaW5zW25hbWVdKSByZXR1cm47XHJcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cdHZhciBwbHVnaW5zID0gdGhpcy5fcGx1Z2luc1tuYW1lXTtcclxuXHR2YXIgb2xkID0gdGhpcy5fY3VycmVudFBsdWdpbkFwcGx5XHJcblx0Zm9yKHRoaXMuX2N1cnJlbnRQbHVnaW5BcHBseSA9IDA7IHRoaXMuX2N1cnJlbnRQbHVnaW5BcHBseSA8IHBsdWdpbnMubGVuZ3RoOyB0aGlzLl9jdXJyZW50UGx1Z2luQXBwbHkrKykge1xyXG5cdFx0dmFyIHJlc3VsdCA9IHBsdWdpbnNbdGhpcy5fY3VycmVudFBsdWdpbkFwcGx5XS5hcHBseSh0aGlzLCBhcmdzKTtcclxuXHRcdGlmKHR5cGVvZiByZXN1bHQgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdFx0dGhpcy5fY3VycmVudFBsdWdpbkFwcGx5ID0gb2xkO1xyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdFx0fVxyXG5cdH1cclxuXHR0aGlzLl9jdXJyZW50UGx1Z2luQXBwbHkgPSBvbGQ7XHJcbn07XHJcblxyXG5UYXBhYmxlLnByb3RvdHlwZS5hcHBseVBsdWdpbnNBc3luY1NlcmllcyA9IFRhcGFibGUucHJvdG90eXBlLmFwcGx5UGx1Z2luc0FzeW5jID0gZnVuY3Rpb24gYXBwbHlQbHVnaW5zQXN5bmMobmFtZSkge1xyXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHR2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xyXG5cdGlmKCF0aGlzLl9wbHVnaW5zW25hbWVdIHx8IHRoaXMuX3BsdWdpbnNbbmFtZV0ubGVuZ3RoID09IDApIHJldHVybiBjYWxsYmFjaygpO1xyXG5cdHZhciBwbHVnaW5zID0gdGhpcy5fcGx1Z2luc1tuYW1lXTtcclxuXHR2YXIgaSA9IDA7XHJcblx0YXJncy5wdXNoKGNvcHlQcm9wZXJ0aWVzKGNhbGxiYWNrLCBmdW5jdGlvbiBuZXh0KGVycikge1xyXG5cdFx0aWYoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHRcdGkrKztcclxuXHRcdGlmKGkgPj0gcGx1Z2lucy5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIGNhbGxiYWNrKCk7XHJcblx0XHR9XHJcblx0XHRwbHVnaW5zW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG5cdH0uYmluZCh0aGlzKSkpO1xyXG5cdHBsdWdpbnNbMF0uYXBwbHkodGhpcywgYXJncyk7XHJcbn07XHJcblxyXG5UYXBhYmxlLnByb3RvdHlwZS5hcHBseVBsdWdpbnNBc3luY1dhdGVyZmFsbCA9IGZ1bmN0aW9uIGFwcGx5UGx1Z2luc0FzeW5jV2F0ZXJmYWxsKG5hbWUsIGluaXQsIGNhbGxiYWNrKSB7XHJcblx0aWYoIXRoaXMuX3BsdWdpbnNbbmFtZV0gfHwgdGhpcy5fcGx1Z2luc1tuYW1lXS5sZW5ndGggPT0gMCkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGluaXQpO1xyXG5cdHZhciBwbHVnaW5zID0gdGhpcy5fcGx1Z2luc1tuYW1lXTtcclxuXHR2YXIgaSA9IDA7XHJcblx0dmFyIG5leHQgPSBjb3B5UHJvcGVydGllcyhjYWxsYmFjaywgZnVuY3Rpb24oZXJyLCB2YWx1ZSkge1xyXG5cdFx0aWYoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHRcdGkrKztcclxuXHRcdGlmKGkgPj0gcGx1Z2lucy5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIGNhbGxiYWNrKG51bGwsIHZhbHVlKTtcclxuXHRcdH1cclxuXHRcdHBsdWdpbnNbaV0uY2FsbCh0aGlzLCB2YWx1ZSwgbmV4dCk7XHJcblx0fS5iaW5kKHRoaXMpKTtcclxuXHRwbHVnaW5zWzBdLmNhbGwodGhpcywgaW5pdCwgbmV4dCk7XHJcbn07XHJcblxyXG5UYXBhYmxlLnByb3RvdHlwZS5hcHBseVBsdWdpbnNQYXJhbGxlbCA9IGZ1bmN0aW9uIGFwcGx5UGx1Z2luc1BhcmFsbGVsKG5hbWUpIHtcclxuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblx0dmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcclxuXHRpZighdGhpcy5fcGx1Z2luc1tuYW1lXSB8fCB0aGlzLl9wbHVnaW5zW25hbWVdLmxlbmd0aCA9PSAwKSByZXR1cm4gY2FsbGJhY2soKTtcclxuXHR2YXIgcGx1Z2lucyA9IHRoaXMuX3BsdWdpbnNbbmFtZV07XHJcblx0dmFyIHJlbWFpbmluZyA9IHBsdWdpbnMubGVuZ3RoO1xyXG5cdGFyZ3MucHVzaChjb3B5UHJvcGVydGllcyhjYWxsYmFjaywgZnVuY3Rpb24oZXJyKSB7XHJcblx0XHRpZihyZW1haW5pbmcgPCAwKSByZXR1cm47IC8vIGlnbm9yZVxyXG5cdFx0aWYoZXJyKSB7XHJcblx0XHRcdHJlbWFpbmluZyA9IC0xO1xyXG5cdFx0XHRyZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHRcdH1cclxuXHRcdHJlbWFpbmluZy0tO1xyXG5cdFx0aWYocmVtYWluaW5nID09IDApIHtcclxuXHRcdFx0cmV0dXJuIGNhbGxiYWNrKCk7XHJcblx0XHR9XHJcblx0fSkpO1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRwbHVnaW5zW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG5cdFx0aWYocmVtYWluaW5nIDwgMCkgcmV0dXJuO1xyXG5cdH1cclxufTtcclxuXHJcblRhcGFibGUucHJvdG90eXBlLmFwcGx5UGx1Z2luc1BhcmFsbGVsQmFpbFJlc3VsdCA9IGZ1bmN0aW9uIGFwcGx5UGx1Z2luc1BhcmFsbGVsQmFpbFJlc3VsdChuYW1lKSB7XHJcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cdHZhciBjYWxsYmFjayA9IGFyZ3NbYXJncy5sZW5ndGgtMV07XHJcblx0aWYoIXRoaXMuX3BsdWdpbnNbbmFtZV0gfHwgdGhpcy5fcGx1Z2luc1tuYW1lXS5sZW5ndGggPT0gMCkgcmV0dXJuIGNhbGxiYWNrKCk7XHJcblx0dmFyIHBsdWdpbnMgPSB0aGlzLl9wbHVnaW5zW25hbWVdO1xyXG5cdHZhciBjdXJyZW50UG9zID0gcGx1Z2lucy5sZW5ndGg7XHJcblx0dmFyIGN1cnJlbnRFcnJvciwgY3VycmVudFJlc3VsdDtcclxuXHR2YXIgZG9uZSA9IFtdO1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRhcmdzW2FyZ3MubGVuZ3RoLTFdID0gKGZ1bmN0aW9uKGkpIHtcclxuXHRcdFx0cmV0dXJuIGNvcHlQcm9wZXJ0aWVzKGNhbGxiYWNrLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xyXG5cdFx0XHRcdGlmKGkgPj0gY3VycmVudFBvcykgcmV0dXJuOyAvLyBpZ25vcmVcclxuXHRcdFx0XHRkb25lLnB1c2goaSk7XHJcblx0XHRcdFx0aWYoZXJyIHx8IHJlc3VsdCkge1xyXG5cdFx0XHRcdFx0Y3VycmVudFBvcyA9IGkgKyAxO1xyXG5cdFx0XHRcdFx0ZG9uZSA9IGRvbmUuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGl0ZW0gPD0gaTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0Y3VycmVudEVycm9yID0gZXJyO1xyXG5cdFx0XHRcdFx0Y3VycmVudFJlc3VsdCA9IHJlc3VsdDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoZG9uZS5sZW5ndGggPT0gY3VycmVudFBvcykge1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2soY3VycmVudEVycm9yLCBjdXJyZW50UmVzdWx0KTtcclxuXHRcdFx0XHRcdGN1cnJlbnRQb3MgPSAwO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9KGkpKTtcclxuXHRcdHBsdWdpbnNbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcblx0fVxyXG59O1xyXG5cclxuXHJcblRhcGFibGUucHJvdG90eXBlLnJlc3RhcnRBcHBseVBsdWdpbnMgPSBmdW5jdGlvbiByZXN0YXJ0QXBwbHlQbHVnaW5zKCkge1xyXG5cdGlmKHR5cGVvZiB0aGlzLl9jdXJyZW50UGx1Z2luQXBwbHkgIT09IFwibnVtYmVyXCIpXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJUYXBhYmxlLnByb3RvdHlwZS5yZXN0YXJ0QXBwbHlQbHVnaW5zIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIG9mIGFueSBzeW5jIHBsdWdpbnMgYXBwbGljYXRpb25cIik7XHJcblx0dGhpcy5fY3VycmVudFBsdWdpbkFwcGx5ID0gLTE7XHJcbn07XHJcblxyXG5cclxuVGFwYWJsZS5wcm90b3R5cGUucGx1Z2luID0gZnVuY3Rpb24gcGx1Z2luKG5hbWUsIGZuKSB7XHJcblx0aWYoQXJyYXkuaXNBcnJheShuYW1lKSkge1xyXG5cdFx0bmFtZS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcclxuXHRcdFx0dGhpcy5wbHVnaW4obmFtZSwgZm4pO1xyXG5cdFx0fSwgdGhpcyk7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cdGlmKCF0aGlzLl9wbHVnaW5zW25hbWVdKSB0aGlzLl9wbHVnaW5zW25hbWVdID0gW2ZuXTtcclxuXHRlbHNlIHRoaXMuX3BsdWdpbnNbbmFtZV0ucHVzaChmbik7XHJcbn07XHJcblxyXG5UYXBhYmxlLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIGFwcGx5KCkge1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGFyZ3VtZW50c1tpXS5hcHBseSh0aGlzKTtcclxuXHR9XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi90YXBhYmxlL2xpYi9UYXBhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBhc3luYyA9IHJlcXVpcmUoXCJhc3luY1wiKTtcclxuXHJcbnZhciBUYXBhYmxlID0gcmVxdWlyZShcInRhcGFibGVcIik7XHJcbnZhciBFbnRyeU1vZHVsZU5vdEZvdW5kRXJyb3IgPSByZXF1aXJlKFwiLi9FbnRyeU1vZHVsZU5vdEZvdW5kRXJyb3JcIik7XHJcbnZhciBNb2R1bGVOb3RGb3VuZEVycm9yID0gcmVxdWlyZShcIi4vTW9kdWxlTm90Rm91bmRFcnJvclwiKTtcclxudmFyIENyaXRpY2FsRGVwZW5kZW5jaWVzV2FybmluZyA9IHJlcXVpcmUoXCIuL0NyaXRpY2FsRGVwZW5kZW5jaWVzV2FybmluZ1wiKTtcclxudmFyIE1vZHVsZSA9IHJlcXVpcmUoXCIuL01vZHVsZVwiKTtcclxudmFyIEFycmF5TWFwID0gcmVxdWlyZShcIi4vQXJyYXlNYXBcIik7XHJcbnZhciBDaHVuayA9IHJlcXVpcmUoXCIuL0NodW5rXCIpO1xyXG52YXIgU3RhdHMgPSByZXF1aXJlKFwiLi9TdGF0c1wiKTtcclxudmFyIE1haW5UZW1wbGF0ZSA9IHJlcXVpcmUoXCIuL01haW5UZW1wbGF0ZVwiKTtcclxudmFyIENodW5rVGVtcGxhdGUgPSByZXF1aXJlKFwiLi9DaHVua1RlbXBsYXRlXCIpO1xyXG52YXIgSG90VXBkYXRlQ2h1bmtUZW1wbGF0ZSA9IHJlcXVpcmUoXCIuL0hvdFVwZGF0ZUNodW5rVGVtcGxhdGVcIik7XHJcbnZhciBNb2R1bGVUZW1wbGF0ZSA9IHJlcXVpcmUoXCIuL01vZHVsZVRlbXBsYXRlXCIpO1xyXG52YXIgRGVwZW5kZW5jeSA9IHJlcXVpcmUoXCIuL0RlcGVuZGVuY3lcIik7XHJcbnZhciBDaHVua1JlbmRlckVycm9yID0gcmVxdWlyZShcIi4vQ2h1bmtSZW5kZXJFcnJvclwiKTtcclxudmFyIENhY2hlZFNvdXJjZSA9IHJlcXVpcmUoXCJ3ZWJwYWNrLWNvcmUvbGliL0NhY2hlZFNvdXJjZVwiKTtcclxuXHJcbmZ1bmN0aW9uIENvbXBpbGF0aW9uKGNvbXBpbGVyKSB7XHJcblx0VGFwYWJsZS5jYWxsKHRoaXMpO1xyXG5cdHRoaXMuY29tcGlsZXIgPSBjb21waWxlcjtcclxuXHR0aGlzLnJlc29sdmVycyA9IGNvbXBpbGVyLnJlc29sdmVycztcclxuXHR0aGlzLmlucHV0RmlsZVN5c3RlbSA9IGNvbXBpbGVyLmlucHV0RmlsZVN5c3RlbTtcclxuXHJcblx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgPSBjb21waWxlci5vcHRpb25zO1xyXG5cdHRoaXMub3V0cHV0T3B0aW9ucyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vdXRwdXQ7XHJcblx0dGhpcy5iYWlsID0gb3B0aW9ucyAmJiBvcHRpb25zLmJhaWw7XHJcblx0dGhpcy5wcm9maWxlID0gb3B0aW9ucyAmJiBvcHRpb25zLnByb2ZpbGU7XHJcblxyXG5cdHRoaXMubWFpblRlbXBsYXRlID0gbmV3IE1haW5UZW1wbGF0ZSh0aGlzLm91dHB1dE9wdGlvbnMpO1xyXG5cdHRoaXMuY2h1bmtUZW1wbGF0ZSA9IG5ldyBDaHVua1RlbXBsYXRlKHRoaXMub3V0cHV0T3B0aW9ucywgdGhpcy5tYWluVGVtcGxhdGUpO1xyXG5cdHRoaXMuaG90VXBkYXRlQ2h1bmtUZW1wbGF0ZSA9IG5ldyBIb3RVcGRhdGVDaHVua1RlbXBsYXRlKHRoaXMub3V0cHV0T3B0aW9ucyk7XHJcblx0dGhpcy5tb2R1bGVUZW1wbGF0ZSA9IG5ldyBNb2R1bGVUZW1wbGF0ZSh0aGlzLm91dHB1dE9wdGlvbnMpO1xyXG5cclxuXHR0aGlzLmVudHJpZXMgPSBbXTtcclxuXHR0aGlzLnByZXBhcmVkQ2h1bmtzID0gW107XHJcblx0dGhpcy5jaHVua3MgPSBbXTtcclxuXHR0aGlzLm5hbWVkQ2h1bmtzID0ge307XHJcblx0dGhpcy5tb2R1bGVzID0gW107XHJcblx0dGhpcy5fbW9kdWxlcyA9IHt9O1xyXG5cdHRoaXMuY2FjaGUgPSBudWxsO1xyXG5cdHRoaXMucmVjb3JkcyA9IG51bGw7XHJcblx0dGhpcy5uZXh0RnJlZU1vZHVsZUlkID0gMTtcclxuXHR0aGlzLm5leHRGcmVlQ2h1bmtJZCA9IDA7XHJcblx0dGhpcy5uZXh0RnJlZU1vZHVsZUluZGV4ID0gMDtcclxuXHR0aGlzLm5leHRGcmVlTW9kdWxlSW5kZXgyID0gMDtcclxuXHR0aGlzLmFkZGl0aW9uYWxDaHVua0Fzc2V0cyA9IFtdO1xyXG5cdHRoaXMuYXNzZXRzID0ge307XHJcblx0dGhpcy5lcnJvcnMgPSBbXTtcclxuXHR0aGlzLndhcm5pbmdzID0gW107XHJcblx0dGhpcy5jaGlsZHJlbiA9IFtdO1xyXG5cdHRoaXMuZGVwZW5kZW5jeUZhY3RvcmllcyA9IG5ldyBBcnJheU1hcCgpO1xyXG5cdHRoaXMuZGVwZW5kZW5jeVRlbXBsYXRlcyA9IG5ldyBBcnJheU1hcCgpO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gQ29tcGlsYXRpb247XHJcblxyXG5Db21waWxhdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRhcGFibGUucHJvdG90eXBlKTtcclxuQ29tcGlsYXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29tcGlsYXRpb247XHJcblxyXG5Db21waWxhdGlvbi5wcm90b3R5cGUudGVtcGxhdGVzUGx1Z2luID0gZnVuY3Rpb24obmFtZSwgZm4pIHtcclxuXHR0aGlzLm1haW5UZW1wbGF0ZS5wbHVnaW4obmFtZSwgZm4pO1xyXG5cdHRoaXMuY2h1bmtUZW1wbGF0ZS5wbHVnaW4obmFtZSwgZm4pO1xyXG59O1xyXG5cclxuQ29tcGlsYXRpb24ucHJvdG90eXBlLmFkZE1vZHVsZSA9IGZ1bmN0aW9uKG1vZHVsZSwgY2FjaGVHcm91cCkge1xyXG5cdGNhY2hlR3JvdXAgPSBjYWNoZUdyb3VwIHx8IFwibVwiO1xyXG5cdHZhciBpZGVudGlmaWVyID0gbW9kdWxlLmlkZW50aWZpZXIoKTtcclxuXHRpZih0aGlzLl9tb2R1bGVzW2lkZW50aWZpZXJdKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cdGlmKHRoaXMuY2FjaGUgJiYgdGhpcy5jYWNoZVtjYWNoZUdyb3VwICsgaWRlbnRpZmllcl0pIHtcclxuXHRcdHZhciBjYWNoZU1vZHVsZSA9IHRoaXMuY2FjaGVbY2FjaGVHcm91cCArIGlkZW50aWZpZXJdO1xyXG5cclxuXHRcdHZhciByZWJ1aWxkID0gdHJ1ZTtcclxuXHRcdGlmKCFjYWNoZU1vZHVsZS5lcnJvciAmJiBjYWNoZU1vZHVsZS5jYWNoZWFibGUgJiYgdGhpcy5maWxlVGltZXN0YW1wcyAmJiB0aGlzLmNvbnRleHRUaW1lc3RhbXBzKSB7XHJcblx0XHRcdHJlYnVpbGQgPSBjYWNoZU1vZHVsZS5uZWVkUmVidWlsZCh0aGlzLmZpbGVUaW1lc3RhbXBzLCB0aGlzLmNvbnRleHRUaW1lc3RhbXBzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZighcmVidWlsZCkge1xyXG5cdFx0XHRjYWNoZU1vZHVsZS5kaXNjb25uZWN0KCk7XHJcblx0XHRcdHRoaXMuX21vZHVsZXNbaWRlbnRpZmllcl0gPSBjYWNoZU1vZHVsZTtcclxuXHRcdFx0dGhpcy5tb2R1bGVzLnB1c2goY2FjaGVNb2R1bGUpO1xyXG5cdFx0XHRjYWNoZU1vZHVsZS5lcnJvcnMuZm9yRWFjaChmdW5jdGlvbihlcnIpIHtcclxuXHRcdFx0XHR0aGlzLmVycm9ycy5wdXNoKGVycik7XHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0XHRjYWNoZU1vZHVsZS53YXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKGVycikge1xyXG5cdFx0XHRcdHRoaXMud2FybmluZ3MucHVzaChlcnIpO1xyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdFx0cmV0dXJuIGNhY2hlTW9kdWxlO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bW9kdWxlLmxhc3RJZCA9IGNhY2hlTW9kdWxlLmlkO1xyXG5cdFx0fVxyXG5cdH1cclxuXHR0aGlzLl9tb2R1bGVzW2lkZW50aWZpZXJdID0gbW9kdWxlO1xyXG5cdGlmKHRoaXMuY2FjaGUpIHtcclxuXHRcdHRoaXMuY2FjaGVbY2FjaGVHcm91cCArIGlkZW50aWZpZXJdID0gbW9kdWxlO1xyXG5cdH1cclxuXHR0aGlzLm1vZHVsZXMucHVzaChtb2R1bGUpO1xyXG5cdHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuQ29tcGlsYXRpb24ucHJvdG90eXBlLmdldE1vZHVsZSA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdHZhciBpZGVudGlmaWVyID0gbW9kdWxlLmlkZW50aWZpZXIoKTtcclxuXHRyZXR1cm4gdGhpcy5fbW9kdWxlc1tpZGVudGlmaWVyXTtcclxufTtcclxuXHJcbkNvbXBpbGF0aW9uLnByb3RvdHlwZS5maW5kTW9kdWxlID0gZnVuY3Rpb24oaWRlbnRpZmllcikge1xyXG5cdHJldHVybiB0aGlzLl9tb2R1bGVzW2lkZW50aWZpZXJdO1xyXG59O1xyXG5cclxuQ29tcGlsYXRpb24ucHJvdG90eXBlLmJ1aWxkTW9kdWxlID0gZnVuY3Rpb24obW9kdWxlLCB0aGlzQ2FsbGJhY2spIHtcclxuXHR0aGlzLmFwcGx5UGx1Z2lucyhcImJ1aWxkLW1vZHVsZVwiLCBtb2R1bGUpO1xyXG5cdGlmKG1vZHVsZS5idWlsZGluZykgcmV0dXJuIG1vZHVsZS5idWlsZGluZy5wdXNoKHRoaXNDYWxsYmFjayk7XHJcblx0dmFyIGJ1aWxkaW5nID0gbW9kdWxlLmJ1aWxkaW5nID0gW3RoaXNDYWxsYmFja107XHJcblxyXG5cdGZ1bmN0aW9uIGNhbGxiYWNrKGVycikge1xyXG5cdFx0bW9kdWxlLmJ1aWxkaW5nID0gdW5kZWZpbmVkO1xyXG5cdFx0YnVpbGRpbmcuZm9yRWFjaChmdW5jdGlvbihjYikge1xyXG5cdFx0XHRjYihlcnIpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cdG1vZHVsZS5idWlsZCh0aGlzLm9wdGlvbnMsIHRoaXMsIHRoaXMucmVzb2x2ZXJzLm5vcm1hbCwgdGhpcy5pbnB1dEZpbGVTeXN0ZW0sIGZ1bmN0aW9uKGVycikge1xyXG5cdFx0bW9kdWxlLmVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uKGVycikge1xyXG5cdFx0XHR0aGlzLmVycm9ycy5wdXNoKGVycik7XHJcblx0XHR9LCB0aGlzKTtcclxuXHRcdG1vZHVsZS53YXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKGVycikge1xyXG5cdFx0XHR0aGlzLndhcm5pbmdzLnB1c2goZXJyKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdFx0bW9kdWxlLmRlcGVuZGVuY2llcy5zb3J0KERlcGVuZGVuY3kuY29tcGFyZSk7XHJcblx0XHRpZihlcnIpIHtcclxuXHRcdFx0bW9kdWxlLmVycm9yID0gZXJyO1xyXG5cdFx0XHR0aGlzLmFwcGx5UGx1Z2lucyhcImZhaWxlZC1tb2R1bGVcIiwgbW9kdWxlKTtcclxuXHRcdFx0cmV0dXJuIGNhbGxiYWNrKGVycik7XHJcblx0XHR9XHJcblx0XHR0aGlzLmFwcGx5UGx1Z2lucyhcInN1Y2NlZWQtbW9kdWxlXCIsIG1vZHVsZSk7XHJcblx0XHRyZXR1cm4gY2FsbGJhY2soKTtcclxuXHR9LmJpbmQodGhpcykpO1xyXG59O1xyXG5cclxuQ29tcGlsYXRpb24ucHJvdG90eXBlLnByb2Nlc3NNb2R1bGVEZXBlbmRlbmNpZXMgPSBmdW5jdGlvbihtb2R1bGUsIGNhbGxiYWNrKSB7XHJcblx0dmFyIGRlcGVuZGVuY2llcyA9IFtdO1xyXG5cclxuXHRmdW5jdGlvbiBhZGREZXBlbmRlbmN5KGRlcCkge1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZihkZXAuaXNFcXVhbFJlc291cmNlKGRlcGVuZGVuY2llc1tpXVswXSkpIHtcclxuXHRcdFx0XHRyZXR1cm4gZGVwZW5kZW5jaWVzW2ldLnB1c2goZGVwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0ZGVwZW5kZW5jaWVzLnB1c2goW2RlcF0pO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gYWRkRGVwZW5kZW5jaWVzQmxvY2soYmxvY2spIHtcclxuXHRcdGlmKGJsb2NrLmRlcGVuZGVuY2llcykge1xyXG5cdFx0XHRibG9jay5kZXBlbmRlbmNpZXMuZm9yRWFjaChhZGREZXBlbmRlbmN5KTtcclxuXHRcdH1cclxuXHRcdGlmKGJsb2NrLmJsb2Nrcykge1xyXG5cdFx0XHRibG9jay5ibG9ja3MuZm9yRWFjaChhZGREZXBlbmRlbmNpZXNCbG9jayk7XHJcblx0XHR9XHJcblx0XHRpZihibG9jay52YXJpYWJsZXMpIHtcclxuXHRcdFx0YmxvY2sudmFyaWFibGVzLmZvckVhY2goZnVuY3Rpb24odikge1xyXG5cdFx0XHRcdHYuZGVwZW5kZW5jaWVzLmZvckVhY2goYWRkRGVwZW5kZW5jeSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRhZGREZXBlbmRlbmNpZXNCbG9jayhtb2R1bGUpO1xyXG5cdHRoaXMuYWRkTW9kdWxlRGVwZW5kZW5jaWVzKG1vZHVsZSwgZGVwZW5kZW5jaWVzLCB0aGlzLmJhaWwsIG51bGwsIHRydWUsIGNhbGxiYWNrKTtcclxufTtcclxuXHJcbkNvbXBpbGF0aW9uLnByb3RvdHlwZS5hZGRNb2R1bGVEZXBlbmRlbmNpZXMgPSBmdW5jdGlvbihtb2R1bGUsIGRlcGVuZGVuY2llcywgYmFpbCwgY2FjaGVHcm91cCwgcmVjdXJzaXZlLCBjYWxsYmFjaykge1xyXG5cdHZhciBfdGhpcyA9IHRoaXM7XHJcblx0dmFyIHN0YXJ0ID0gX3RoaXMucHJvZmlsZSAmJiArbmV3IERhdGUoKTtcclxuXHJcblx0dmFyIGZhY3RvcmllcyA9IFtdO1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBmYWN0b3J5ID0gX3RoaXMuZGVwZW5kZW5jeUZhY3Rvcmllcy5nZXQoZGVwZW5kZW5jaWVzW2ldWzBdLmNvbnN0cnVjdG9yKTtcclxuXHRcdGlmKCFmYWN0b3J5KSB7XHJcblx0XHRcdHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoXCJObyBtb2R1bGUgZmFjdG9yeSBhdmFpbGFibGUgZm9yIGRlcGVuZGVuY3kgdHlwZTogXCIgKyBkZXBlbmRlbmNpZXNbaV1bMF0uY29uc3RydWN0b3IubmFtZSkpO1xyXG5cdFx0fVxyXG5cdFx0ZmFjdG9yaWVzW2ldID0gW2ZhY3RvcnksIGRlcGVuZGVuY2llc1tpXV07XHJcblx0fVxyXG5cdGFzeW5jLmZvckVhY2goZmFjdG9yaWVzLCBmdW5jdGlvbihpdGVtLCBjYWxsYmFjaykge1xyXG5cdFx0dmFyIGRlcGVuZGVuY2llcyA9IGl0ZW1bMV07XHJcblx0XHR2YXIgY3JpdGljYWxEZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXMuZmlsdGVyKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0cmV0dXJuICEhZC5jcml0aWNhbDtcclxuXHRcdH0pO1xyXG5cdFx0aWYoY3JpdGljYWxEZXBlbmRlbmNpZXMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRfdGhpcy53YXJuaW5ncy5wdXNoKG5ldyBDcml0aWNhbERlcGVuZGVuY2llc1dhcm5pbmcobW9kdWxlLCBjcml0aWNhbERlcGVuZGVuY2llcykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBlcnJvckFuZENhbGxiYWNrID0gZnVuY3Rpb24gZXJyb3JBbmRDYWxsYmFjayhlcnIpIHtcclxuXHRcdFx0ZXJyLmRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcztcclxuXHRcdFx0ZXJyLm9yaWdpbiA9IG1vZHVsZTtcclxuXHRcdFx0bW9kdWxlLmRlcGVuZGVuY2llc0Vycm9ycy5wdXNoKGVycik7XHJcblx0XHRcdF90aGlzLmVycm9ycy5wdXNoKGVycik7XHJcblx0XHRcdGlmKGJhaWwpIHtcclxuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0XHR2YXIgd2FybmluZ0FuZENhbGxiYWNrID0gZnVuY3Rpb24gd2FybmluZ0FuZENhbGxiYWNrKGVycikge1xyXG5cdFx0XHRlcnIuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xyXG5cdFx0XHRlcnIub3JpZ2luID0gbW9kdWxlO1xyXG5cdFx0XHRtb2R1bGUuZGVwZW5kZW5jaWVzV2FybmluZ3MucHVzaChlcnIpO1xyXG5cdFx0XHRfdGhpcy53YXJuaW5ncy5wdXNoKGVycik7XHJcblx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciBmYWN0b3J5ID0gaXRlbVswXTtcclxuXHRcdGZhY3RvcnkuY3JlYXRlKG1vZHVsZS5jb250ZXh0LCBkZXBlbmRlbmNpZXNbMF0sIGZ1bmN0aW9uKGVyciwgZGVwZW5kYW50TW9kdWxlKSB7XHJcblx0XHRcdGZ1bmN0aW9uIGlzT3B0aW9uYWwoKSB7XHJcblx0XHRcdFx0cmV0dXJuIGRlcGVuZGVuY2llcy5maWx0ZXIoZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuICFkLm9wdGlvbmFsO1xyXG5cdFx0XHRcdH0pLmxlbmd0aCA9PT0gMDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZnVuY3Rpb24gZXJyb3JPcldhcm5pbmdBbmRDYWxsYmFjayhlcnIpIHtcclxuXHRcdFx0XHRpZihpc09wdGlvbmFsKCkpIHtcclxuXHRcdFx0XHRcdHJldHVybiB3YXJuaW5nQW5kQ2FsbGJhY2soZXJyKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGVycm9yQW5kQ2FsbGJhY2soZXJyKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoZXJyKSB7XHJcblx0XHRcdFx0cmV0dXJuIGVycm9yT3JXYXJuaW5nQW5kQ2FsbGJhY2sobmV3IE1vZHVsZU5vdEZvdW5kRXJyb3IobW9kdWxlLCBlcnIpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZighZGVwZW5kYW50TW9kdWxlKSB7XHJcblx0XHRcdFx0cmV0dXJuIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKF90aGlzLnByb2ZpbGUpIHtcclxuXHRcdFx0XHRpZighZGVwZW5kYW50TW9kdWxlLnByb2ZpbGUpIHtcclxuXHRcdFx0XHRcdGRlcGVuZGFudE1vZHVsZS5wcm9maWxlID0ge307XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHZhciBhZnRlckZhY3RvcnkgPSArbmV3IERhdGUoKTtcclxuXHRcdFx0XHRkZXBlbmRhbnRNb2R1bGUucHJvZmlsZS5mYWN0b3J5ID0gYWZ0ZXJGYWN0b3J5IC0gc3RhcnQ7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGRlcGVuZGFudE1vZHVsZS5pc3N1ZXIgPSBtb2R1bGUuaWRlbnRpZmllcigpO1xyXG5cdFx0XHR2YXIgbmV3TW9kdWxlID0gX3RoaXMuYWRkTW9kdWxlKGRlcGVuZGFudE1vZHVsZSwgY2FjaGVHcm91cCk7XHJcblxyXG5cdFx0XHRpZighbmV3TW9kdWxlKSB7IC8vIGZyb20gY2FjaGVcclxuXHRcdFx0XHRkZXBlbmRhbnRNb2R1bGUgPSBfdGhpcy5nZXRNb2R1bGUoZGVwZW5kYW50TW9kdWxlKTtcclxuXHJcblx0XHRcdFx0aWYoZGVwZW5kYW50TW9kdWxlLm9wdGlvbmFsKSB7XHJcblx0XHRcdFx0XHRkZXBlbmRhbnRNb2R1bGUub3B0aW9uYWwgPSBpc09wdGlvbmFsKCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZihkZXBlbmRhbnRNb2R1bGUuaWQgPT09IDApIHtcclxuXHRcdFx0XHRcdHJldHVybiBlcnJvck9yV2FybmluZ0FuZENhbGxiYWNrKFxyXG5cdFx0XHRcdFx0XHRuZXcgTW9kdWxlTm90Rm91bmRFcnJvcihtb2R1bGUsIG5ldyBFcnJvcihcImEgZGVwZW5kZW5jeSB0byBhbiBlbnRyeSBwb2ludCBpcyBub3QgYWxsb3dlZFwiKSlcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRkZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbihkZXApIHtcclxuXHRcdFx0XHRcdGRlcC5tb2R1bGUgPSBkZXBlbmRhbnRNb2R1bGU7XHJcblx0XHRcdFx0XHRkZXBlbmRhbnRNb2R1bGUuYWRkUmVhc29uKG1vZHVsZSwgZGVwKTtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0aWYoX3RoaXMucHJvZmlsZSkge1xyXG5cdFx0XHRcdFx0aWYoIW1vZHVsZS5wcm9maWxlKSB7XHJcblx0XHRcdFx0XHRcdG1vZHVsZS5wcm9maWxlID0ge307XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR2YXIgdGltZSA9ICtuZXcgRGF0ZSgpIC0gc3RhcnQ7XHJcblx0XHRcdFx0XHRpZighbW9kdWxlLnByb2ZpbGUuZGVwZW5kZW5jaWVzIHx8IHRpbWUgPiBtb2R1bGUucHJvZmlsZS5kZXBlbmRlbmNpZXMpIHtcclxuXHRcdFx0XHRcdFx0bW9kdWxlLnByb2ZpbGUuZGVwZW5kZW5jaWVzID0gdGltZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYobmV3TW9kdWxlIGluc3RhbmNlb2YgTW9kdWxlKSB7XHJcblx0XHRcdFx0aWYoX3RoaXMucHJvZmlsZSkge1xyXG5cdFx0XHRcdFx0bmV3TW9kdWxlLnByb2ZpbGUgPSBkZXBlbmRhbnRNb2R1bGUucHJvZmlsZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdG5ld01vZHVsZS5vcHRpb25hbCA9IGlzT3B0aW9uYWwoKTtcclxuXHRcdFx0XHRuZXdNb2R1bGUuaXNzdWVyID0gZGVwZW5kYW50TW9kdWxlLmlzc3VlcjtcclxuXHRcdFx0XHRkZXBlbmRhbnRNb2R1bGUgPSBuZXdNb2R1bGU7XHJcblxyXG5cdFx0XHRcdGRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uKGRlcCkge1xyXG5cdFx0XHRcdFx0ZGVwLm1vZHVsZSA9IGRlcGVuZGFudE1vZHVsZTtcclxuXHRcdFx0XHRcdGRlcGVuZGFudE1vZHVsZS5hZGRSZWFzb24obW9kdWxlLCBkZXApO1xyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRpZihfdGhpcy5wcm9maWxlKSB7XHJcblx0XHRcdFx0XHR2YXIgYWZ0ZXJCdWlsZGluZyA9ICtuZXcgRGF0ZSgpO1xyXG5cdFx0XHRcdFx0bW9kdWxlLnByb2ZpbGUuYnVpbGRpbmcgPSBhZnRlckJ1aWxkaW5nIC0gYWZ0ZXJGYWN0b3J5O1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYocmVjdXJzaXZlKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhfdGhpcy5wcm9jZXNzTW9kdWxlRGVwZW5kZW5jaWVzLmJpbmQoX3RoaXMsIGRlcGVuZGFudE1vZHVsZSwgY2FsbGJhY2spKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZGVwZW5kYW50TW9kdWxlLm9wdGlvbmFsID0gaXNPcHRpb25hbCgpO1xyXG5cclxuXHRcdFx0ZGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24oZGVwKSB7XHJcblx0XHRcdFx0ZGVwLm1vZHVsZSA9IGRlcGVuZGFudE1vZHVsZTtcclxuXHRcdFx0XHRkZXBlbmRhbnRNb2R1bGUuYWRkUmVhc29uKG1vZHVsZSwgZGVwKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRfdGhpcy5idWlsZE1vZHVsZShkZXBlbmRhbnRNb2R1bGUsIGZ1bmN0aW9uKGVycikge1xyXG5cdFx0XHRcdGlmKGVycikge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGVycm9yT3JXYXJuaW5nQW5kQ2FsbGJhY2soZXJyKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmKF90aGlzLnByb2ZpbGUpIHtcclxuXHRcdFx0XHRcdHZhciBhZnRlckJ1aWxkaW5nID0gK25ldyBEYXRlKCk7XHJcblx0XHRcdFx0XHRkZXBlbmRhbnRNb2R1bGUucHJvZmlsZS5idWlsZGluZyA9IGFmdGVyQnVpbGRpbmcgLSBhZnRlckZhY3Rvcnk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZihyZWN1cnNpdmUpIHtcclxuXHRcdFx0XHRcdF90aGlzLnByb2Nlc3NNb2R1bGVEZXBlbmRlbmNpZXMoZGVwZW5kYW50TW9kdWxlLCBjYWxsYmFjayk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHJldHVybiBjYWxsYmFjaygpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0fSk7XHJcblx0fSwgZnVuY3Rpb24oZXJyKSB7XHJcblx0XHRpZihlcnIpIHtcclxuXHRcdFx0cmV0dXJuIGNhbGxiYWNrKGVycik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNhbGxiYWNrKCk7XHJcblx0fSk7XHJcbn07XHJcblxyXG5Db21waWxhdGlvbi5wcm90b3R5cGUuX2FkZE1vZHVsZUNoYWluID0gZnVuY3Rpb24gcHJvY2Vzcyhjb250ZXh0LCBkZXBlbmRlbmN5LCBvbk1vZHVsZSwgY2FsbGJhY2spIHtcclxuXHR2YXIgc3RhcnQgPSB0aGlzLnByb2ZpbGUgJiYgK25ldyBEYXRlKCk7XHJcblxyXG5cdHZhciBlcnJvckFuZENhbGxiYWNrID0gdGhpcy5iYWlsID8gZnVuY3Rpb24gZXJyb3JBbmRDYWxsYmFjayhlcnIpIHtcclxuXHRcdGNhbGxiYWNrKGVycik7XHJcblx0fSA6IGZ1bmN0aW9uIGVycm9yQW5kQ2FsbGJhY2soZXJyKSB7XHJcblx0XHRlcnIuZGVwZW5kZW5jaWVzID0gW2RlcGVuZGVuY3ldO1xyXG5cdFx0dGhpcy5lcnJvcnMucHVzaChlcnIpO1xyXG5cdFx0Y2FsbGJhY2soKTtcclxuXHR9LmJpbmQodGhpcyk7XHJcblxyXG5cdGlmKHR5cGVvZiBkZXBlbmRlbmN5ICE9PSBcIm9iamVjdFwiIHx8IGRlcGVuZGVuY3kgPT09IG51bGwgfHwgIWRlcGVuZGVuY3kuY29uc3RydWN0b3IpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciAnZGVwZW5kZW5jeScgbXVzdCBiZSBhIERlcGVuZGVuY3lcIik7XHJcblx0fVxyXG5cclxuXHR2YXIgbW9kdWxlRmFjdG9yeSA9IHRoaXMuZGVwZW5kZW5jeUZhY3Rvcmllcy5nZXQoZGVwZW5kZW5jeS5jb25zdHJ1Y3Rvcik7XHJcblx0aWYoIW1vZHVsZUZhY3RvcnkpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIk5vIGRlcGVuZGVuY3kgZmFjdG9yeSBhdmFpbGFibGUgZm9yIHRoaXMgZGVwZW5kZW5jeSB0eXBlOiBcIiArIGRlcGVuZGVuY3kuY29uc3RydWN0b3IubmFtZSk7XHJcblx0fVxyXG5cclxuXHRtb2R1bGVGYWN0b3J5LmNyZWF0ZShjb250ZXh0LCBkZXBlbmRlbmN5LCBmdW5jdGlvbihlcnIsIG1vZHVsZSkge1xyXG5cdFx0aWYoZXJyKSB7XHJcblx0XHRcdHJldHVybiBlcnJvckFuZENhbGxiYWNrKG5ldyBFbnRyeU1vZHVsZU5vdEZvdW5kRXJyb3IoZXJyKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYodGhpcy5wcm9maWxlKSB7XHJcblx0XHRcdGlmKCFtb2R1bGUucHJvZmlsZSkge1xyXG5cdFx0XHRcdG1vZHVsZS5wcm9maWxlID0ge307XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGFmdGVyRmFjdG9yeSA9ICtuZXcgRGF0ZSgpO1xyXG5cdFx0XHRtb2R1bGUucHJvZmlsZS5mYWN0b3J5ID0gYWZ0ZXJGYWN0b3J5IC0gc3RhcnQ7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IHRoaXMuYWRkTW9kdWxlKG1vZHVsZSk7XHJcblx0XHRpZighcmVzdWx0KSB7XHJcblx0XHRcdG1vZHVsZSA9IHRoaXMuZ2V0TW9kdWxlKG1vZHVsZSk7XHJcblxyXG5cdFx0XHRvbk1vZHVsZShtb2R1bGUpO1xyXG5cclxuXHRcdFx0aWYodGhpcy5wcm9maWxlKSB7XHJcblx0XHRcdFx0dmFyIGFmdGVyQnVpbGRpbmcgPSArbmV3IERhdGUoKTtcclxuXHRcdFx0XHRtb2R1bGUucHJvZmlsZS5idWlsZGluZyA9IGFmdGVyQnVpbGRpbmcgLSBhZnRlckZhY3Rvcnk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBjYWxsYmFjayhudWxsLCBtb2R1bGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKHJlc3VsdCBpbnN0YW5jZW9mIE1vZHVsZSkge1xyXG5cdFx0XHRpZih0aGlzLnByb2ZpbGUpIHtcclxuXHRcdFx0XHRyZXN1bHQucHJvZmlsZSA9IG1vZHVsZS5wcm9maWxlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRtb2R1bGUgPSByZXN1bHQ7XHJcblxyXG5cdFx0XHRvbk1vZHVsZShtb2R1bGUpO1xyXG5cclxuXHRcdFx0bW9kdWxlUmVhZHkuY2FsbCh0aGlzKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdG9uTW9kdWxlKG1vZHVsZSk7XHJcblxyXG5cdFx0dGhpcy5idWlsZE1vZHVsZShtb2R1bGUsIGZ1bmN0aW9uKGVycikge1xyXG5cdFx0XHRpZihlcnIpIHtcclxuXHRcdFx0XHRyZXR1cm4gZXJyb3JBbmRDYWxsYmFjayhlcnIpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZih0aGlzLnByb2ZpbGUpIHtcclxuXHRcdFx0XHR2YXIgYWZ0ZXJCdWlsZGluZyA9ICtuZXcgRGF0ZSgpO1xyXG5cdFx0XHRcdG1vZHVsZS5wcm9maWxlLmJ1aWxkaW5nID0gYWZ0ZXJCdWlsZGluZyAtIGFmdGVyRmFjdG9yeTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bW9kdWxlUmVhZHkuY2FsbCh0aGlzKTtcclxuXHRcdH0uYmluZCh0aGlzKSk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gbW9kdWxlUmVhZHkoKSB7XHJcblx0XHRcdHRoaXMucHJvY2Vzc01vZHVsZURlcGVuZGVuY2llcyhtb2R1bGUsIGZ1bmN0aW9uKGVycikge1xyXG5cdFx0XHRcdGlmKGVycikge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKGVycik7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gY2FsbGJhY2sobnVsbCwgbW9kdWxlKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fS5iaW5kKHRoaXMpKTtcclxufTtcclxuXHJcbkNvbXBpbGF0aW9uLnByb3RvdHlwZS5hZGRFbnRyeSA9IGZ1bmN0aW9uIHByb2Nlc3MoY29udGV4dCwgZW50cnksIG5hbWUsIGNhbGxiYWNrKSB7XHJcblx0dGhpcy5fYWRkTW9kdWxlQ2hhaW4oY29udGV4dCwgZW50cnksIGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cclxuXHRcdGVudHJ5Lm1vZHVsZSA9IG1vZHVsZTtcclxuXHRcdHRoaXMuZW50cmllcy5wdXNoKG1vZHVsZSk7XHJcblx0XHRtb2R1bGUuaXNzdWVyID0gbnVsbDtcclxuXHRcdG1vZHVsZS5pZCA9IDA7XHJcblxyXG5cdH0uYmluZCh0aGlzKSwgZnVuY3Rpb24oZXJyLCBtb2R1bGUpIHtcclxuXHRcdGlmKGVycikge1xyXG5cdFx0XHRyZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZihtb2R1bGUpIHtcclxuXHRcdFx0aWYobW9kdWxlLnJlYXNvbnMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoXCJtb2R1bGUgY2Fubm90IGJlIGFkZGVkIGFzIGVudHJ5IHBvaW50LCBiZWNhdXNlIGl0J3MgYWxyZWFkeSBpbiB0aGUgYnVuZGxlXCIpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLnByZXBhcmVkQ2h1bmtzLnB1c2goe1xyXG5cdFx0XHRcdG5hbWU6IG5hbWUsXHJcblx0XHRcdFx0bW9kdWxlOiBtb2R1bGVcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gY2FsbGJhY2soKTtcclxuXHR9LmJpbmQodGhpcykpO1xyXG59O1xyXG5cclxuQ29tcGlsYXRpb24ucHJvdG90eXBlLnByZWZldGNoID0gZnVuY3Rpb24gcHJvY2Vzcyhjb250ZXh0LCBkZXBlbmRlbmN5LCBjYWxsYmFjaykge1xyXG5cdHRoaXMuX2FkZE1vZHVsZUNoYWluKGNvbnRleHQsIGRlcGVuZGVuY3ksIGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cclxuXHRcdG1vZHVsZS5wcmVmZXRjaGVkID0gdHJ1ZTtcclxuXHRcdG1vZHVsZS5pc3N1ZXIgPSBudWxsO1xyXG5cclxuXHR9LCBjYWxsYmFjayk7XHJcbn07XHJcblxyXG5Db21waWxhdGlvbi5wcm90b3R5cGUucmVidWlsZE1vZHVsZSA9IGZ1bmN0aW9uKG1vZHVsZSwgdGhpc0NhbGxiYWNrKSB7XHJcblx0aWYobW9kdWxlLnZhcmlhYmxlcy5sZW5ndGggfHwgbW9kdWxlLmJsb2Nrcy5sZW5ndGgpXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVidWlsZCBhIGNvbXBsZXggbW9kdWxlIHdpdGggdmFyaWFibGVzIG9yIGJsb2Nrc1wiKTtcclxuXHRpZihtb2R1bGUucmVidWlsZGluZykge1xyXG5cdFx0cmV0dXJuIG1vZHVsZS5yZWJ1aWxkaW5nLnB1c2godGhpc0NhbGxiYWNrKTtcclxuXHR9XHJcblx0dmFyIHJlYnVpbGRpbmcgPSBtb2R1bGUucmVidWlsZGluZyA9IFt0aGlzQ2FsbGJhY2tdO1xyXG5cclxuXHRmdW5jdGlvbiBjYWxsYmFjayhlcnIpIHtcclxuXHRcdG1vZHVsZS5yZWJ1aWxkaW5nID0gdW5kZWZpbmVkO1xyXG5cdFx0cmVidWlsZGluZy5mb3JFYWNoKGZ1bmN0aW9uKGNiKSB7XHJcblx0XHRcdGNiKGVycik7XHJcblx0XHR9KTtcclxuXHR9XHJcblx0dmFyIGRlcHMgPSBtb2R1bGUuZGVwZW5kZW5jaWVzLnNsaWNlKCk7XHJcblx0dGhpcy5idWlsZE1vZHVsZShtb2R1bGUsIGZ1bmN0aW9uKGVycikge1xyXG5cdFx0aWYoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHJcblx0XHR0aGlzLnByb2Nlc3NNb2R1bGVEZXBlbmRlbmNpZXMobW9kdWxlLCBmdW5jdGlvbihlcnIpIHtcclxuXHRcdFx0aWYoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHRcdFx0ZGVwcy5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRpZihkLm1vZHVsZSAmJiBkLm1vZHVsZS5yZW1vdmVSZWFzb24obW9kdWxlLCBkKSkge1xyXG5cdFx0XHRcdFx0bW9kdWxlLmNodW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGNodW5rKSB7XHJcblx0XHRcdFx0XHRcdGlmKCFkLm1vZHVsZS5oYXNSZWFzb25Gb3JDaHVuayhjaHVuaykpIHtcclxuXHRcdFx0XHRcdFx0XHRpZihkLm1vZHVsZS5yZW1vdmVDaHVuayhjaHVuaykpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRoaXMucmVtb3ZlQ2h1bmtGcm9tRGVwZW5kZW5jaWVzKGQubW9kdWxlLCBjaHVuayk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9LCB0aGlzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0fS5iaW5kKHRoaXMpKTtcclxuXHJcblx0fS5iaW5kKHRoaXMpKTtcclxufTtcclxuXHJcbkNvbXBpbGF0aW9uLnByb3RvdHlwZS5zZWFsID0gZnVuY3Rpb24gc2VhbChjYWxsYmFjaykge1xyXG5cdHRoaXMuYXBwbHlQbHVnaW5zKFwic2VhbFwiKTtcclxuXHR0aGlzLnByZXBhcmVkQ2h1bmtzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG5cdFx0aWYoYS5uYW1lIDwgYi5uYW1lKSByZXR1cm4gLTE7XHJcblx0XHRpZihhLm5hbWUgPiBiLm5hbWUpIHJldHVybiAxO1xyXG5cdFx0cmV0dXJuIDA7XHJcblx0fSk7XHJcblx0dGhpcy5wcmVwYXJlZENodW5rcy5mb3JFYWNoKGZ1bmN0aW9uKHByZXBhcmVkQ2h1bmspIHtcclxuXHRcdHZhciBtb2R1bGUgPSBwcmVwYXJlZENodW5rLm1vZHVsZTtcclxuXHRcdHZhciBjaHVuayA9IHRoaXMuYWRkQ2h1bmsocHJlcGFyZWRDaHVuay5uYW1lLCBtb2R1bGUpO1xyXG5cdFx0Y2h1bmsuaW5pdGlhbCA9IGNodW5rLmVudHJ5ID0gdHJ1ZTtcclxuXHRcdGNodW5rLmFkZE1vZHVsZShtb2R1bGUpO1xyXG5cdFx0bW9kdWxlLmFkZENodW5rKGNodW5rKTtcclxuXHRcdGlmKHR5cGVvZiBtb2R1bGUuaW5kZXggIT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0bW9kdWxlLmluZGV4ID0gdGhpcy5uZXh0RnJlZU1vZHVsZUluZGV4Kys7XHJcblx0XHR9XHJcblx0XHR0aGlzLnByb2Nlc3NEZXBlbmRlbmNpZXNCbG9ja0ZvckNodW5rKG1vZHVsZSwgY2h1bmspO1xyXG5cdFx0aWYodHlwZW9mIG1vZHVsZS5pbmRleDIgIT09IFwibnVtYmVyXCIpIHtcclxuXHRcdFx0bW9kdWxlLmluZGV4MiA9IHRoaXMubmV4dEZyZWVNb2R1bGVJbmRleDIrKztcclxuXHRcdH1cclxuXHR9LCB0aGlzKTtcclxuXHR0aGlzLnNvcnRNb2R1bGVzKHRoaXMubW9kdWxlcyk7XHJcblx0dGhpcy5hcHBseVBsdWdpbnMoXCJvcHRpbWl6ZVwiKTtcclxuXHJcblx0dGhpcy5hcHBseVBsdWdpbnMoXCJvcHRpbWl6ZS1tb2R1bGVzXCIsIHRoaXMubW9kdWxlcyk7XHJcblx0dGhpcy5hcHBseVBsdWdpbnMoXCJhZnRlci1vcHRpbWl6ZS1tb2R1bGVzXCIsIHRoaXMubW9kdWxlcyk7XHJcblxyXG5cdHRoaXMuYXBwbHlQbHVnaW5zKFwib3B0aW1pemUtY2h1bmtzXCIsIHRoaXMuY2h1bmtzKTtcclxuXHR0aGlzLmFwcGx5UGx1Z2lucyhcImFmdGVyLW9wdGltaXplLWNodW5rc1wiLCB0aGlzLmNodW5rcyk7XHJcblxyXG5cdHRoaXMuYXBwbHlQbHVnaW5zQXN5bmMoXCJvcHRpbWl6ZS10cmVlXCIsIHRoaXMuY2h1bmtzLCB0aGlzLm1vZHVsZXMsIGZ1bmN0aW9uKGVycikge1xyXG5cdFx0aWYoZXJyKSB7XHJcblx0XHRcdHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYXBwbHlQbHVnaW5zKFwiYWZ0ZXItb3B0aW1pemUtdHJlZVwiLCB0aGlzLmNodW5rcywgdGhpcy5tb2R1bGVzKTtcclxuXHJcblx0XHR2YXIgc2hvdWxkUmVjb3JkID0gdGhpcy5hcHBseVBsdWdpbnNCYWlsUmVzdWx0KFwic2hvdWxkLXJlY29yZFwiKSAhPT0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5hcHBseVBsdWdpbnMoXCJyZXZpdmUtbW9kdWxlc1wiLCB0aGlzLm1vZHVsZXMsIHRoaXMucmVjb3Jkcyk7XHJcblx0XHR0aGlzLmFwcGx5UGx1Z2lucyhcIm9wdGltaXplLW1vZHVsZS1vcmRlclwiLCB0aGlzLm1vZHVsZXMpO1xyXG5cdFx0dGhpcy5hcHBseVBsdWdpbnMoXCJiZWZvcmUtbW9kdWxlLWlkc1wiLCB0aGlzLm1vZHVsZXMpO1xyXG5cdFx0dGhpcy5hcHBseU1vZHVsZUlkcygpO1xyXG5cdFx0dGhpcy5hcHBseVBsdWdpbnMoXCJvcHRpbWl6ZS1tb2R1bGUtaWRzXCIsIHRoaXMubW9kdWxlcyk7XHJcblx0XHR0aGlzLmFwcGx5UGx1Z2lucyhcImFmdGVyLW9wdGltaXplLW1vZHVsZS1pZHNcIiwgdGhpcy5tb2R1bGVzKTtcclxuXHRcdGlmKHNob3VsZFJlY29yZClcclxuXHRcdFx0dGhpcy5hcHBseVBsdWdpbnMoXCJyZWNvcmQtbW9kdWxlc1wiLCB0aGlzLm1vZHVsZXMsIHRoaXMucmVjb3Jkcyk7XHJcblxyXG5cdFx0dGhpcy5hcHBseVBsdWdpbnMoXCJyZXZpdmUtY2h1bmtzXCIsIHRoaXMuY2h1bmtzLCB0aGlzLnJlY29yZHMpO1xyXG5cdFx0dGhpcy5hcHBseVBsdWdpbnMoXCJvcHRpbWl6ZS1jaHVuay1vcmRlclwiLCB0aGlzLmNodW5rcyk7XHJcblx0XHR0aGlzLmFwcGx5UGx1Z2lucyhcImJlZm9yZS1jaHVuay1pZHNcIiwgdGhpcy5jaHVua3MpO1xyXG5cdFx0dGhpcy5hcHBseUNodW5rSWRzKCk7XHJcblx0XHR0aGlzLmFwcGx5UGx1Z2lucyhcIm9wdGltaXplLWNodW5rLWlkc1wiLCB0aGlzLmNodW5rcyk7XHJcblx0XHR0aGlzLmFwcGx5UGx1Z2lucyhcImFmdGVyLW9wdGltaXplLWNodW5rLWlkc1wiLCB0aGlzLmNodW5rcyk7XHJcblx0XHRpZihzaG91bGRSZWNvcmQpXHJcblx0XHRcdHRoaXMuYXBwbHlQbHVnaW5zKFwicmVjb3JkLWNodW5rc1wiLCB0aGlzLmNodW5rcywgdGhpcy5yZWNvcmRzKTtcclxuXHJcblx0XHR0aGlzLnNvcnRJdGVtcygpO1xyXG5cdFx0dGhpcy5hcHBseVBsdWdpbnMoXCJiZWZvcmUtaGFzaFwiKTtcclxuXHRcdHRoaXMuY3JlYXRlSGFzaCgpO1xyXG5cdFx0dGhpcy5hcHBseVBsdWdpbnMoXCJhZnRlci1oYXNoXCIpO1xyXG5cdFx0dGhpcy5hcHBseVBsdWdpbnMoXCJiZWZvcmUtY2h1bmstYXNzZXRzXCIpO1xyXG5cdFx0dGhpcy5jcmVhdGVDaHVua0Fzc2V0cygpO1xyXG5cdFx0dGhpcy5hcHBseVBsdWdpbnMoXCJhZGRpdGlvbmFsLWNodW5rLWFzc2V0c1wiLCB0aGlzLmNodW5rcyk7XHJcblx0XHR0aGlzLnN1bW1hcml6ZURlcGVuZGVuY2llcygpO1xyXG5cdFx0aWYoc2hvdWxkUmVjb3JkKVxyXG5cdFx0XHR0aGlzLmFwcGx5UGx1Z2lucyhcInJlY29yZFwiLCB0aGlzLCB0aGlzLnJlY29yZHMpO1xyXG5cclxuXHRcdHRoaXMuYXBwbHlQbHVnaW5zQXN5bmMoXCJhZGRpdGlvbmFsLWFzc2V0c1wiLCBmdW5jdGlvbihlcnIpIHtcclxuXHRcdFx0aWYoZXJyKSB7XHJcblx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKGVycik7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5hcHBseVBsdWdpbnNBc3luYyhcIm9wdGltaXplLWNodW5rLWFzc2V0c1wiLCB0aGlzLmNodW5rcywgZnVuY3Rpb24oZXJyKSB7XHJcblx0XHRcdFx0aWYoZXJyKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy5hcHBseVBsdWdpbnMoXCJhZnRlci1vcHRpbWl6ZS1jaHVuay1hc3NldHNcIiwgdGhpcy5jaHVua3MpO1xyXG5cdFx0XHRcdHRoaXMuYXBwbHlQbHVnaW5zQXN5bmMoXCJvcHRpbWl6ZS1hc3NldHNcIiwgdGhpcy5hc3NldHMsIGZ1bmN0aW9uKGVycikge1xyXG5cdFx0XHRcdFx0aWYoZXJyKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dGhpcy5hcHBseVBsdWdpbnMoXCJhZnRlci1vcHRpbWl6ZS1hc3NldHNcIiwgdGhpcy5hc3NldHMpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKCk7XHJcblx0XHRcdFx0fS5iaW5kKHRoaXMpKTtcclxuXHRcdFx0fS5iaW5kKHRoaXMpKTtcclxuXHRcdH0uYmluZCh0aGlzKSk7XHJcblx0fS5iaW5kKHRoaXMpKTtcclxufTtcclxuXHJcbkNvbXBpbGF0aW9uLnByb3RvdHlwZS5zb3J0TW9kdWxlcyA9IGZ1bmN0aW9uIHNvcnRNb2R1bGVzKG1vZHVsZXMpIHtcclxuXHRtb2R1bGVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG5cdFx0aWYoYS5pbmRleCA8IGIuaW5kZXgpIHJldHVybiAtMTtcclxuXHRcdGlmKGEuaW5kZXggPiBiLmluZGV4KSByZXR1cm4gMTtcclxuXHRcdHJldHVybiAwO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuQ29tcGlsYXRpb24ucHJvdG90eXBlLmFkZENodW5rID0gZnVuY3Rpb24gYWRkQ2h1bmsobmFtZSwgbW9kdWxlLCBsb2MpIHtcclxuXHR2YXIgY2h1bms7XHJcblx0aWYobmFtZSkge1xyXG5cdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMubmFtZWRDaHVua3MsIG5hbWUpKSB7XHJcblx0XHRcdGNodW5rID0gdGhpcy5uYW1lZENodW5rc1tuYW1lXTtcclxuXHRcdFx0aWYobW9kdWxlKSB7XHJcblx0XHRcdFx0Y2h1bmsuYWRkT3JpZ2luKG1vZHVsZSwgbG9jKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gY2h1bms7XHJcblx0XHR9XHJcblx0fVxyXG5cdGNodW5rID0gbmV3IENodW5rKG5hbWUsIG1vZHVsZSwgbG9jKTtcclxuXHR0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcclxuXHRpZihuYW1lKSB7XHJcblx0XHR0aGlzLm5hbWVkQ2h1bmtzW25hbWVdID0gY2h1bms7XHJcblx0fVxyXG5cdHJldHVybiBjaHVuaztcclxufTtcclxuXHJcbkNvbXBpbGF0aW9uLnByb3RvdHlwZS5wcm9jZXNzRGVwZW5kZW5jaWVzQmxvY2tGb3JDaHVuayA9IGZ1bmN0aW9uIHByb2Nlc3NEZXBlbmRlbmNpZXNCbG9ja0ZvckNodW5rKGJsb2NrLCBjaHVuaykge1xyXG5cdGlmKGJsb2NrLnZhcmlhYmxlcykge1xyXG5cdFx0YmxvY2sudmFyaWFibGVzLmZvckVhY2goZnVuY3Rpb24odikge1xyXG5cdFx0XHR2LmRlcGVuZGVuY2llcy5mb3JFYWNoKGl0ZXJhdG9yRGVwZW5kZW5jeSwgdGhpcyk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9XHJcblx0aWYoYmxvY2suZGVwZW5kZW5jaWVzKSB7XHJcblx0XHRibG9jay5kZXBlbmRlbmNpZXMuZm9yRWFjaChpdGVyYXRvckRlcGVuZGVuY3ksIHRoaXMpO1xyXG5cdH1cclxuXHRpZihibG9jay5ibG9ja3MpIHtcclxuXHRcdGJsb2NrLmJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uKGIpIHtcclxuXHRcdFx0dmFyIGM7XHJcblx0XHRcdGlmKCFiLmNodW5rcykge1xyXG5cdFx0XHRcdGMgPSB0aGlzLmFkZENodW5rKGIuY2h1bmtOYW1lLCBiLm1vZHVsZSwgYi5sb2MpO1xyXG5cdFx0XHRcdGIuY2h1bmtzID0gW2NdO1xyXG5cdFx0XHRcdGMuYWRkQmxvY2soYik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0YyA9IGIuY2h1bmtzWzBdO1xyXG5cdFx0XHR9XHJcblx0XHRcdGNodW5rLmFkZENodW5rKGMpO1xyXG5cdFx0XHRjLmFkZFBhcmVudChjaHVuayk7XHJcblx0XHRcdHRoaXMucHJvY2Vzc0RlcGVuZGVuY2llc0Jsb2NrRm9yQ2h1bmsoYiwgYyk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGl0ZXJhdG9yRGVwZW5kZW5jeShkKSB7XHJcblx0XHRpZighZC5tb2R1bGUpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0aWYodHlwZW9mIGQubW9kdWxlLmluZGV4ICE9PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdGQubW9kdWxlLmluZGV4ID0gdGhpcy5uZXh0RnJlZU1vZHVsZUluZGV4Kys7XHJcblx0XHR9XHJcblx0XHRpZihkLndlYWspIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0aWYoZC5tb2R1bGUuZXJyb3IpIHtcclxuXHRcdFx0ZC5tb2R1bGUgPSBudWxsO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHRpZihjaHVuay5hZGRNb2R1bGUoZC5tb2R1bGUpKSB7XHJcblx0XHRcdGQubW9kdWxlLmFkZENodW5rKGNodW5rKTtcclxuXHRcdFx0dGhpcy5wcm9jZXNzRGVwZW5kZW5jaWVzQmxvY2tGb3JDaHVuayhkLm1vZHVsZSwgY2h1bmspO1xyXG5cdFx0fVxyXG5cdFx0aWYodHlwZW9mIGQubW9kdWxlLmluZGV4MiAhPT0gXCJudW1iZXJcIikge1xyXG5cdFx0XHRkLm1vZHVsZS5pbmRleDIgPSB0aGlzLm5leHRGcmVlTW9kdWxlSW5kZXgyKys7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuQ29tcGlsYXRpb24ucHJvdG90eXBlLnJlbW92ZUNodW5rRnJvbURlcGVuZGVuY2llcyA9IGZ1bmN0aW9uIHJlbW92ZUNodW5rRnJvbURlcGVuZGVuY2llcyhibG9jaywgY2h1bmspIHtcclxuXHRibG9jay5ibG9ja3MuZm9yRWFjaChmdW5jdGlvbihiKSB7XHJcblx0XHRiLmNodW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcclxuXHRcdFx0Y2h1bmsucmVtb3ZlQ2h1bmsoYyk7XHJcblx0XHRcdGMucmVtb3ZlUGFyZW50KGNodW5rKTtcclxuXHRcdFx0dGhpcy5yZW1vdmVDaHVua0Zyb21EZXBlbmRlbmNpZXMoYiwgYyk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9LCB0aGlzKTtcclxuXHJcblx0ZnVuY3Rpb24gaXRlcmF0b3JEZXBlbmRlbmN5KGQpIHtcclxuXHRcdGlmKCFkLm1vZHVsZSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHRpZighZC5tb2R1bGUuaGFzUmVhc29uRm9yQ2h1bmsoY2h1bmspKSB7XHJcblx0XHRcdGlmKGQubW9kdWxlLnJlbW92ZUNodW5rKGNodW5rKSkge1xyXG5cdFx0XHRcdHRoaXMucmVtb3ZlQ2h1bmtGcm9tRGVwZW5kZW5jaWVzKGQubW9kdWxlLCBjaHVuayk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0YmxvY2suZGVwZW5kZW5jaWVzLmZvckVhY2goaXRlcmF0b3JEZXBlbmRlbmN5LCB0aGlzKTtcclxuXHRibG9jay52YXJpYWJsZXMuZm9yRWFjaChmdW5jdGlvbih2KSB7XHJcblx0XHR2LmRlcGVuZGVuY2llcy5mb3JFYWNoKGl0ZXJhdG9yRGVwZW5kZW5jeSwgdGhpcyk7XHJcblx0fSwgdGhpcyk7XHJcblxyXG59O1xyXG5cclxuQ29tcGlsYXRpb24ucHJvdG90eXBlLmFwcGx5TW9kdWxlSWRzID0gZnVuY3Rpb24gYXBwbHlNb2R1bGVJZHMoKSB7XHJcblx0dGhpcy5tb2R1bGVzLmZvckVhY2goZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0XHRpZihtb2R1bGUuaWQgPT09IG51bGwpIHtcclxuXHRcdFx0bW9kdWxlLmlkID0gdGhpcy5uZXh0RnJlZU1vZHVsZUlkKys7XHJcblx0XHR9XHJcblx0fSwgdGhpcyk7XHJcbn07XHJcblxyXG5Db21waWxhdGlvbi5wcm90b3R5cGUuYXBwbHlDaHVua0lkcyA9IGZ1bmN0aW9uIGFwcGx5Q2h1bmtJZHMoKSB7XHJcblx0dGhpcy5jaHVua3MuZm9yRWFjaChmdW5jdGlvbihjaHVuaykge1xyXG5cdFx0aWYoY2h1bmsuaWQgPT09IG51bGwpIHtcclxuXHRcdFx0Y2h1bmsuaWQgPSB0aGlzLm5leHRGcmVlQ2h1bmtJZCsrO1xyXG5cdFx0fVxyXG5cdFx0aWYoIWNodW5rLmlkcykge1xyXG5cdFx0XHRjaHVuay5pZHMgPSBbY2h1bmsuaWRdO1xyXG5cdFx0fVxyXG5cdH0sIHRoaXMpO1xyXG59O1xyXG5cclxuQ29tcGlsYXRpb24ucHJvdG90eXBlLnNvcnRJdGVtcyA9IGZ1bmN0aW9uIHNvcnRJdGVtcygpIHtcclxuXHRmdW5jdGlvbiBieUlkKGEsIGIpIHtcclxuXHRcdHJldHVybiBhLmlkIC0gYi5pZDtcclxuXHR9XHJcblx0dGhpcy5jaHVua3Muc29ydChieUlkKTtcclxuXHR0aGlzLm1vZHVsZXMuc29ydChieUlkKTtcclxuXHR0aGlzLm1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRcdG1vZHVsZS5jaHVua3Muc29ydChieUlkKTtcclxuXHRcdG1vZHVsZS5yZWFzb25zLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG5cdFx0XHRyZXR1cm4gYnlJZChhLm1vZHVsZSwgYi5tb2R1bGUpO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcblx0dGhpcy5jaHVua3MuZm9yRWFjaChmdW5jdGlvbihjaHVuaykge1xyXG5cdFx0Y2h1bmsubW9kdWxlcy5zb3J0KGJ5SWQpO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuQ29tcGlsYXRpb24ucHJvdG90eXBlLnN1bW1hcml6ZURlcGVuZGVuY2llcyA9IGZ1bmN0aW9uIHN1bW1hcml6ZURlcGVuZGVuY2llcygpIHtcclxuXHRmdW5jdGlvbiBmaWx0ZXJEdXBzKGFycmF5KSB7XHJcblx0XHR2YXIgbmV3QXJyYXkgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZihpID09PSAwIHx8IGFycmF5W2kgLSAxXSAhPT0gYXJyYXlbaV0pXHJcblx0XHRcdFx0bmV3QXJyYXkucHVzaChhcnJheVtpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3QXJyYXk7XHJcblx0fVxyXG5cdHRoaXMuZmlsZURlcGVuZGVuY2llcyA9IFtdO1xyXG5cdHRoaXMuY29udGV4dERlcGVuZGVuY2llcyA9IFtdO1xyXG5cdHRoaXMubWlzc2luZ0RlcGVuZGVuY2llcyA9IFtdO1xyXG5cdHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xyXG5cdFx0dGhpcy5maWxlRGVwZW5kZW5jaWVzID0gdGhpcy5maWxlRGVwZW5kZW5jaWVzLmNvbmNhdChjaGlsZC5maWxlRGVwZW5kZW5jaWVzKTtcclxuXHRcdHRoaXMuY29udGV4dERlcGVuZGVuY2llcyA9IHRoaXMuY29udGV4dERlcGVuZGVuY2llcy5jb25jYXQoY2hpbGQuY29udGV4dERlcGVuZGVuY2llcyk7XHJcblx0XHR0aGlzLm1pc3NpbmdEZXBlbmRlbmNpZXMgPSB0aGlzLm1pc3NpbmdEZXBlbmRlbmNpZXMuY29uY2F0KGNoaWxkLm1pc3NpbmdEZXBlbmRlbmNpZXMpO1xyXG5cdH0uYmluZCh0aGlzKSk7XHJcblx0dGhpcy5tb2R1bGVzLmZvckVhY2goZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0XHRpZihtb2R1bGUuZmlsZURlcGVuZGVuY2llcykge1xyXG5cdFx0XHRtb2R1bGUuZmlsZURlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHRcdFx0XHR0aGlzLmZpbGVEZXBlbmRlbmNpZXMucHVzaChpdGVtKTtcclxuXHRcdFx0fSwgdGhpcyk7XHJcblx0XHR9XHJcblx0XHRpZihtb2R1bGUuY29udGV4dERlcGVuZGVuY2llcykge1xyXG5cdFx0XHRtb2R1bGUuY29udGV4dERlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHRcdFx0XHR0aGlzLmNvbnRleHREZXBlbmRlbmNpZXMucHVzaChpdGVtKTtcclxuXHRcdFx0fSwgdGhpcyk7XHJcblx0XHR9XHJcblx0fSwgdGhpcyk7XHJcblx0dGhpcy5lcnJvcnMuZm9yRWFjaChmdW5jdGlvbihlcnJvcikge1xyXG5cdFx0aWYoQXJyYXkuaXNBcnJheShlcnJvci5taXNzaW5nKSkge1xyXG5cdFx0XHRlcnJvci5taXNzaW5nLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xyXG5cdFx0XHRcdHRoaXMubWlzc2luZ0RlcGVuZGVuY2llcy5wdXNoKGl0ZW0pO1xyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH1cclxuXHR9LCB0aGlzKTtcclxuXHR0aGlzLmZpbGVEZXBlbmRlbmNpZXMuc29ydCgpO1xyXG5cdHRoaXMuZmlsZURlcGVuZGVuY2llcyA9IGZpbHRlckR1cHModGhpcy5maWxlRGVwZW5kZW5jaWVzKTtcclxuXHR0aGlzLmNvbnRleHREZXBlbmRlbmNpZXMuc29ydCgpO1xyXG5cdHRoaXMuY29udGV4dERlcGVuZGVuY2llcyA9IGZpbHRlckR1cHModGhpcy5jb250ZXh0RGVwZW5kZW5jaWVzKTtcclxuXHR0aGlzLm1pc3NpbmdEZXBlbmRlbmNpZXMuc29ydCgpO1xyXG5cdHRoaXMubWlzc2luZ0RlcGVuZGVuY2llcyA9IGZpbHRlckR1cHModGhpcy5taXNzaW5nRGVwZW5kZW5jaWVzKTtcclxufTtcclxuXHJcbkNvbXBpbGF0aW9uLnByb3RvdHlwZS5jcmVhdGVIYXNoID0gZnVuY3Rpb24gY3JlYXRlSGFzaCgpIHtcclxuXHR2YXIgb3V0cHV0T3B0aW9ucyA9IHRoaXMub3V0cHV0T3B0aW9ucztcclxuXHR2YXIgaGFzaEZ1bmN0aW9uID0gb3V0cHV0T3B0aW9ucy5oYXNoRnVuY3Rpb247XHJcblx0dmFyIGhhc2hEaWdlc3QgPSBvdXRwdXRPcHRpb25zLmhhc2hEaWdlc3Q7XHJcblx0dmFyIGhhc2hEaWdlc3RMZW5ndGggPSBvdXRwdXRPcHRpb25zLmhhc2hEaWdlc3RMZW5ndGg7XHJcblx0dmFyIGhhc2ggPSByZXF1aXJlKFwiY3J5cHRvXCIpLmNyZWF0ZUhhc2goaGFzaEZ1bmN0aW9uKTtcclxuXHR0aGlzLm1haW5UZW1wbGF0ZS51cGRhdGVIYXNoKGhhc2gpO1xyXG5cdHRoaXMuY2h1bmtUZW1wbGF0ZS51cGRhdGVIYXNoKGhhc2gpO1xyXG5cdHRoaXMubW9kdWxlVGVtcGxhdGUudXBkYXRlSGFzaChoYXNoKTtcclxuXHR2YXIgaSwgY2h1bms7XHJcblx0dmFyIGNodW5rcyA9IHRoaXMuY2h1bmtzLnNsaWNlKCk7XHJcblx0Y2h1bmtzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG5cdFx0aWYoYS5lbnRyeSAmJiAhYi5lbnRyeSkgcmV0dXJuIDE7XHJcblx0XHRpZighYS5lbnRyeSAmJiBiLmVudHJ5KSByZXR1cm4gLTE7XHJcblx0XHRyZXR1cm4gMDtcclxuXHR9KTtcclxuXHRmb3IoaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdGNodW5rID0gY2h1bmtzW2ldO1xyXG5cdFx0dmFyIGNodW5rSGFzaCA9IHJlcXVpcmUoXCJjcnlwdG9cIikuY3JlYXRlSGFzaChoYXNoRnVuY3Rpb24pO1xyXG5cdFx0Y2h1bmsudXBkYXRlSGFzaChjaHVua0hhc2gpO1xyXG5cdFx0aWYoY2h1bmsuZW50cnkpIHtcclxuXHRcdFx0dGhpcy5tYWluVGVtcGxhdGUudXBkYXRlSGFzaEZvckNodW5rKGNodW5rSGFzaCwgY2h1bmspO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5jaHVua1RlbXBsYXRlLnVwZGF0ZUhhc2hGb3JDaHVuayhjaHVua0hhc2gpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5hcHBseVBsdWdpbnMoXCJjaHVuay1oYXNoXCIsIGNodW5rLCBjaHVua0hhc2gpO1xyXG5cdFx0Y2h1bmsuaGFzaCA9IGNodW5rSGFzaC5kaWdlc3QoaGFzaERpZ2VzdCk7XHJcblx0XHRoYXNoLnVwZGF0ZShjaHVuay5oYXNoKTtcclxuXHRcdGNodW5rLnJlbmRlcmVkSGFzaCA9IGNodW5rLmhhc2guc3Vic3RyKDAsIGhhc2hEaWdlc3RMZW5ndGgpO1xyXG5cdH1cclxuXHR0aGlzLmZ1bGxIYXNoID0gaGFzaC5kaWdlc3QoaGFzaERpZ2VzdCk7XHJcblx0dGhpcy5oYXNoID0gdGhpcy5mdWxsSGFzaC5zdWJzdHIoMCwgaGFzaERpZ2VzdExlbmd0aCk7XHJcbn07XHJcblxyXG5Db21waWxhdGlvbi5wcm90b3R5cGUubW9kaWZ5SGFzaCA9IGZ1bmN0aW9uIG1vZGlmeUhhc2godXBkYXRlKSB7XHJcblx0dmFyIG91dHB1dE9wdGlvbnMgPSB0aGlzLm91dHB1dE9wdGlvbnM7XHJcblx0dmFyIGhhc2hGdW5jdGlvbiA9IG91dHB1dE9wdGlvbnMuaGFzaEZ1bmN0aW9uO1xyXG5cdHZhciBoYXNoRGlnZXN0ID0gb3V0cHV0T3B0aW9ucy5oYXNoRGlnZXN0O1xyXG5cdHZhciBoYXNoRGlnZXN0TGVuZ3RoID0gb3V0cHV0T3B0aW9ucy5oYXNoRGlnZXN0TGVuZ3RoO1xyXG5cdHZhciBoYXNoID0gcmVxdWlyZShcImNyeXB0b1wiKS5jcmVhdGVIYXNoKGhhc2hGdW5jdGlvbik7XHJcblx0aGFzaC51cGRhdGUodGhpcy5mdWxsSGFzaCk7XHJcblx0aGFzaC51cGRhdGUodXBkYXRlKTtcclxuXHR0aGlzLmZ1bGxIYXNoID0gaGFzaC5kaWdlc3QoaGFzaERpZ2VzdCk7XHJcblx0dGhpcy5oYXNoID0gdGhpcy5mdWxsSGFzaC5zdWJzdHIoMCwgaGFzaERpZ2VzdExlbmd0aCk7XHJcbn07XHJcblxyXG5Db21waWxhdGlvbi5wcm90b3R5cGUuY3JlYXRlQ2h1bmtBc3NldHMgPSBmdW5jdGlvbiBjcmVhdGVDaHVua0Fzc2V0cygpIHtcclxuXHR2YXIgb3V0cHV0T3B0aW9ucyA9IHRoaXMub3V0cHV0T3B0aW9ucztcclxuXHR2YXIgZmlsZW5hbWUgPSBvdXRwdXRPcHRpb25zLmZpbGVuYW1lIHx8IFwiYnVuZGxlLmpzXCI7XHJcblx0dmFyIGNodW5rRmlsZW5hbWUgPSBvdXRwdXRPcHRpb25zLmNodW5rRmlsZW5hbWUgfHwgXCJbaWRdLlwiICsgZmlsZW5hbWU7XHJcblx0dmFyIG5hbWVkQ2h1bmtGaWxlbmFtZSA9IG91dHB1dE9wdGlvbnMubmFtZWRDaHVua0ZpbGVuYW1lIHx8IG51bGw7XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIG1vZHVsZSA9IHRoaXMubW9kdWxlc1tpXTtcclxuXHRcdGlmKG1vZHVsZS5hc3NldHMpIHtcclxuXHRcdFx0T2JqZWN0LmtleXMobW9kdWxlLmFzc2V0cykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XHJcblx0XHRcdFx0dmFyIGZpbGUgPSB0aGlzLmdldFBhdGgobmFtZSk7XHJcblx0XHRcdFx0dGhpcy5hc3NldHNbZmlsZV0gPSBtb2R1bGUuYXNzZXRzW25hbWVdO1xyXG5cdFx0XHRcdHRoaXMuYXBwbHlQbHVnaW5zKFwibW9kdWxlLWFzc2V0XCIsIG1vZHVsZSwgZmlsZSk7XHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRmb3IoaSA9IDA7IGkgPCB0aGlzLmNodW5rcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGNodW5rID0gdGhpcy5jaHVua3NbaV07XHJcblx0XHRjaHVuay5maWxlcyA9IFtdO1xyXG5cdFx0dmFyIGNodW5rSGFzaCA9IGNodW5rLmhhc2g7XHJcblx0XHR2YXIgc291cmNlO1xyXG5cdFx0dmFyIGZpbGU7XHJcblx0XHR2YXIgZmlsZW5hbWVUZW1wbGF0ZSA9IGNodW5rLmZpbGVuYW1lVGVtcGxhdGUgPyBjaHVuay5maWxlbmFtZVRlbXBsYXRlIDpcclxuXHRcdFx0Y2h1bmsuaW5pdGlhbCA/IGZpbGVuYW1lIDpcclxuXHRcdFx0Y2h1bmtGaWxlbmFtZTtcclxuXHRcdHRyeSB7XHJcblx0XHRcdHZhciB1c2VDaHVua0hhc2ggPSAhY2h1bmsuZW50cnkgfHwgKHRoaXMubWFpblRlbXBsYXRlLnVzZUNodW5rSGFzaCAmJiB0aGlzLm1haW5UZW1wbGF0ZS51c2VDaHVua0hhc2goY2h1bmspKTtcclxuXHRcdFx0dmFyIHVzZWRIYXNoID0gdXNlQ2h1bmtIYXNoID8gY2h1bmtIYXNoIDogdGhpcy5mdWxsSGFzaDtcclxuXHRcdFx0aWYodGhpcy5jYWNoZSAmJiB0aGlzLmNhY2hlW1wiY1wiICsgY2h1bmsuaWRdICYmIHRoaXMuY2FjaGVbXCJjXCIgKyBjaHVuay5pZF0uaGFzaCA9PT0gdXNlZEhhc2gpIHtcclxuXHRcdFx0XHRzb3VyY2UgPSB0aGlzLmNhY2hlW1wiY1wiICsgY2h1bmsuaWRdLnNvdXJjZTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZihjaHVuay5lbnRyeSkge1xyXG5cdFx0XHRcdFx0c291cmNlID0gdGhpcy5tYWluVGVtcGxhdGUucmVuZGVyKHRoaXMuaGFzaCwgY2h1bmssIHRoaXMubW9kdWxlVGVtcGxhdGUsIHRoaXMuZGVwZW5kZW5jeVRlbXBsYXRlcyk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHNvdXJjZSA9IHRoaXMuY2h1bmtUZW1wbGF0ZS5yZW5kZXIoY2h1bmssIHRoaXMubW9kdWxlVGVtcGxhdGUsIHRoaXMuZGVwZW5kZW5jeVRlbXBsYXRlcyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHRoaXMuY2FjaGUpIHtcclxuXHRcdFx0XHRcdHRoaXMuY2FjaGVbXCJjXCIgKyBjaHVuay5pZF0gPSB7XHJcblx0XHRcdFx0XHRcdGhhc2g6IHVzZWRIYXNoLFxyXG5cdFx0XHRcdFx0XHRzb3VyY2U6IHNvdXJjZSA9IChzb3VyY2UgaW5zdGFuY2VvZiBDYWNoZWRTb3VyY2UgPyBzb3VyY2UgOiBuZXcgQ2FjaGVkU291cmNlKHNvdXJjZSkpXHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLmFzc2V0c1tcclxuXHRcdFx0XHRmaWxlID0gdGhpcy5nZXRQYXRoKGZpbGVuYW1lVGVtcGxhdGUsIHtcclxuXHRcdFx0XHRcdG5vQ2h1bmtIYXNoOiAhdXNlQ2h1bmtIYXNoLFxyXG5cdFx0XHRcdFx0Y2h1bms6IGNodW5rXHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XSA9IHNvdXJjZTtcclxuXHRcdFx0Y2h1bmsuZmlsZXMucHVzaChmaWxlKTtcclxuXHRcdFx0dGhpcy5hcHBseVBsdWdpbnMoXCJjaHVuay1hc3NldFwiLCBjaHVuaywgZmlsZSk7XHJcblx0XHRcdGZpbGUgPSB1bmRlZmluZWQ7XHJcblx0XHRcdGlmKGNodW5rLmlkICE9PSAwICYmIG5hbWVkQ2h1bmtGaWxlbmFtZSAmJiBjaHVuay5uYW1lKSB7XHJcblx0XHRcdFx0dGhpcy5hc3NldHNbXHJcblx0XHRcdFx0XHRmaWxlID0gdGhpcy5nZXRQYXRoKG5hbWVkQ2h1bmtGaWxlbmFtZSwge1xyXG5cdFx0XHRcdFx0XHRub0NodW5rSGFzaDogIXVzZUNodW5rSGFzaCxcclxuXHRcdFx0XHRcdFx0Y2h1bms6IGNodW5rXHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdF0gPSBzb3VyY2U7XHJcblx0XHRcdFx0Y2h1bmsuZmlsZXMucHVzaChmaWxlKTtcclxuXHRcdFx0XHR0aGlzLmFwcGx5UGx1Z2lucyhcImNodW5rLWFzc2V0XCIsIGNodW5rLCBmaWxlKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBjYXRjaChlcnIpIHtcclxuXHRcdFx0dGhpcy5lcnJvcnMucHVzaChuZXcgQ2h1bmtSZW5kZXJFcnJvcihjaHVuaywgZmlsZSB8fCBmaWxlbmFtZVRlbXBsYXRlLCBlcnIpKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG5Db21waWxhdGlvbi5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uKGZpbGVuYW1lLCBkYXRhKSB7XHJcblx0ZGF0YSA9IGRhdGEgfHwge307XHJcblx0ZGF0YS5oYXNoID0gZGF0YS5oYXNoIHx8IHRoaXMuaGFzaDtcclxuXHRyZXR1cm4gdGhpcy5tYWluVGVtcGxhdGUuYXBwbHlQbHVnaW5zV2F0ZXJmYWxsKFwiYXNzZXQtcGF0aFwiLCBmaWxlbmFtZSwgZGF0YSk7XHJcbn07XHJcblxyXG5Db21waWxhdGlvbi5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbmV3IFN0YXRzKHRoaXMpO1xyXG59O1xyXG5cclxuQ29tcGlsYXRpb24ucHJvdG90eXBlLmNyZWF0ZUNoaWxkQ29tcGlsZXIgPSBmdW5jdGlvbihuYW1lLCBvdXRwdXRPcHRpb25zKSB7XHJcblx0cmV0dXJuIHRoaXMuY29tcGlsZXIuY3JlYXRlQ2hpbGRDb21waWxlcih0aGlzLCBuYW1lLCBvdXRwdXRPcHRpb25zKTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9Db21waWxhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIGFzeW5jXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2FvbGFuL2FzeW5jXG4gKlxuICogQ29weXJpZ2h0IDIwMTAtMjAxNCBDYW9sYW4gTWNNYWhvblxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbihmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgYXN5bmMgPSB7fTtcbiAgICBmdW5jdGlvbiBub29wKCkge31cbiAgICBmdW5jdGlvbiBpZGVudGl0eSh2KSB7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b0Jvb2wodikge1xuICAgICAgICByZXR1cm4gISF2O1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3RJZCh2KSB7XG4gICAgICAgIHJldHVybiAhdjtcbiAgICB9XG5cbiAgICAvLyBnbG9iYWwgb24gdGhlIHNlcnZlciwgd2luZG93IGluIHRoZSBicm93c2VyXG4gICAgdmFyIHByZXZpb3VzX2FzeW5jO1xuXG4gICAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgKGBzZWxmYCkgaW4gdGhlIGJyb3dzZXIsIGBnbG9iYWxgXG4gICAgLy8gb24gdGhlIHNlcnZlciwgb3IgYHRoaXNgIGluIHNvbWUgdmlydHVhbCBtYWNoaW5lcy4gV2UgdXNlIGBzZWxmYFxuICAgIC8vIGluc3RlYWQgb2YgYHdpbmRvd2AgZm9yIGBXZWJXb3JrZXJgIHN1cHBvcnQuXG4gICAgdmFyIHJvb3QgPSB0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcgJiYgc2VsZi5zZWxmID09PSBzZWxmICYmIHNlbGYgfHxcbiAgICAgICAgICAgIHR5cGVvZiBnbG9iYWwgPT09ICdvYmplY3QnICYmIGdsb2JhbC5nbG9iYWwgPT09IGdsb2JhbCAmJiBnbG9iYWwgfHxcbiAgICAgICAgICAgIHRoaXM7XG5cbiAgICBpZiAocm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHByZXZpb3VzX2FzeW5jID0gcm9vdC5hc3luYztcbiAgICB9XG5cbiAgICBhc3luYy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByb290LmFzeW5jID0gcHJldmlvdXNfYXN5bmM7XG4gICAgICAgIHJldHVybiBhc3luYztcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gb25seV9vbmNlKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChmbiA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGJhY2sgd2FzIGFscmVhZHkgY2FsbGVkLlwiKTtcbiAgICAgICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBmbiA9IG51bGw7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX29uY2UoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGZuID09PSBudWxsKSByZXR1cm47XG4gICAgICAgICAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgZm4gPSBudWxsO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vLy8gY3Jvc3MtYnJvd3NlciBjb21wYXRpYmxpdHkgZnVuY3Rpb25zIC8vLy9cblxuICAgIHZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gICAgdmFyIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH07XG5cbiAgICAvLyBQb3J0ZWQgZnJvbSB1bmRlcnNjb3JlLmpzIGlzT2JqZWN0XG4gICAgdmFyIF9pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG4gICAgICAgIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGUgPT09ICdvYmplY3QnICYmICEhb2JqO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfaXNBcnJheUxpa2UoYXJyKSB7XG4gICAgICAgIHJldHVybiBfaXNBcnJheShhcnIpIHx8IChcbiAgICAgICAgICAgIC8vIGhhcyBhIHBvc2l0aXZlIGludGVnZXIgbGVuZ3RoIHByb3BlcnR5XG4gICAgICAgICAgICB0eXBlb2YgYXJyLmxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICAgICAgYXJyLmxlbmd0aCA+PSAwICYmXG4gICAgICAgICAgICBhcnIubGVuZ3RoICUgMSA9PT0gMFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9hcnJheUVhY2goYXJyLCBpdGVyYXRvcikge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGFyci5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKGFycltpbmRleF0sIGluZGV4LCBhcnIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX21hcChhcnIsIGl0ZXJhdG9yKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJyLmxlbmd0aCxcbiAgICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRvcihhcnJbaW5kZXhdLCBpbmRleCwgYXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9yYW5nZShjb3VudCkge1xuICAgICAgICByZXR1cm4gX21hcChBcnJheShjb3VudCksIGZ1bmN0aW9uICh2LCBpKSB7IHJldHVybiBpOyB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfcmVkdWNlKGFyciwgaXRlcmF0b3IsIG1lbW8pIHtcbiAgICAgICAgX2FycmF5RWFjaChhcnIsIGZ1bmN0aW9uICh4LCBpLCBhKSB7XG4gICAgICAgICAgICBtZW1vID0gaXRlcmF0b3IobWVtbywgeCwgaSwgYSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWVtbztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfZm9yRWFjaE9mKG9iamVjdCwgaXRlcmF0b3IpIHtcbiAgICAgICAgX2FycmF5RWFjaChfa2V5cyhvYmplY3QpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpdGVyYXRvcihvYmplY3Rba2V5XSwga2V5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2luZGV4T2YoYXJyLCBpdGVtKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXJyW2ldID09PSBpdGVtKSByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgdmFyIF9rZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2tleUl0ZXJhdG9yKGNvbGwpIHtcbiAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgdmFyIGxlbjtcbiAgICAgICAgdmFyIGtleXM7XG4gICAgICAgIGlmIChfaXNBcnJheUxpa2UoY29sbCkpIHtcbiAgICAgICAgICAgIGxlbiA9IGNvbGwubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIHJldHVybiBpIDwgbGVuID8gaSA6IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5cyA9IF9rZXlzKGNvbGwpO1xuICAgICAgICAgICAgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgPCBsZW4gPyBrZXlzW2ldIDogbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTaW1pbGFyIHRvIEVTNidzIHJlc3QgcGFyYW0gKGh0dHA6Ly9hcml5YS5vZmlsYWJzLmNvbS8yMDEzLzAzL2VzNi1hbmQtcmVzdC1wYXJhbWV0ZXIuaHRtbClcbiAgICAvLyBUaGlzIGFjY3VtdWxhdGVzIHRoZSBhcmd1bWVudHMgcGFzc2VkIGludG8gYW4gYXJyYXksIGFmdGVyIGEgZ2l2ZW4gaW5kZXguXG4gICAgLy8gRnJvbSB1bmRlcnNjb3JlLmpzIChodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8yMTQwKS5cbiAgICBmdW5jdGlvbiBfcmVzdFBhcmFtKGZ1bmMsIHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXggPT0gbnVsbCA/IGZ1bmMubGVuZ3RoIC0gMSA6ICtzdGFydEluZGV4O1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoYXJndW1lbnRzLmxlbmd0aCAtIHN0YXJ0SW5kZXgsIDApO1xuICAgICAgICAgICAgdmFyIHJlc3QgPSBBcnJheShsZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHJlc3RbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4ICsgc3RhcnRJbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpcywgcmVzdCk7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFyZ3VtZW50c1swXSwgcmVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDdXJyZW50bHkgdW51c2VkIGJ1dCBoYW5kbGUgY2FzZXMgb3V0c2lkZSBvZiB0aGUgc3dpdGNoIHN0YXRlbWVudDpcbiAgICAgICAgICAgIC8vIHZhciBhcmdzID0gQXJyYXkoc3RhcnRJbmRleCArIDEpO1xuICAgICAgICAgICAgLy8gZm9yIChpbmRleCA9IDA7IGluZGV4IDwgc3RhcnRJbmRleDsgaW5kZXgrKykge1xuICAgICAgICAgICAgLy8gICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIGFyZ3Nbc3RhcnRJbmRleF0gPSByZXN0O1xuICAgICAgICAgICAgLy8gcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3dpdGhvdXRJbmRleChpdGVyYXRvcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcih2YWx1ZSwgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vLy8gZXhwb3J0ZWQgYXN5bmMgbW9kdWxlIGZ1bmN0aW9ucyAvLy8vXG5cbiAgICAvLy8vIG5leHRUaWNrIGltcGxlbWVudGF0aW9uIHdpdGggYnJvd3Nlci1jb21wYXRpYmxlIGZhbGxiYWNrIC8vLy9cblxuICAgIC8vIGNhcHR1cmUgdGhlIGdsb2JhbCByZWZlcmVuY2UgdG8gZ3VhcmQgYWdhaW5zdCBmYWtlVGltZXIgbW9ja3NcbiAgICB2YXIgX3NldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicgJiYgc2V0SW1tZWRpYXRlO1xuXG4gICAgdmFyIF9kZWxheSA9IF9zZXRJbW1lZGlhdGUgPyBmdW5jdGlvbihmbikge1xuICAgICAgICAvLyBub3QgYSBkaXJlY3QgYWxpYXMgZm9yIElFMTAgY29tcGF0aWJpbGl0eVxuICAgICAgICBfc2V0SW1tZWRpYXRlKGZuKTtcbiAgICB9IDogZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb2Nlc3MubmV4dFRpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYXN5bmMubmV4dFRpY2sgPSBwcm9jZXNzLm5leHRUaWNrO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFzeW5jLm5leHRUaWNrID0gX2RlbGF5O1xuICAgIH1cbiAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBfc2V0SW1tZWRpYXRlID8gX2RlbGF5IDogYXN5bmMubmV4dFRpY2s7XG5cblxuICAgIGFzeW5jLmZvckVhY2ggPVxuICAgIGFzeW5jLmVhY2ggPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGFzeW5jLmVhY2hPZihhcnIsIF93aXRob3V0SW5kZXgoaXRlcmF0b3IpLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLmZvckVhY2hTZXJpZXMgPVxuICAgIGFzeW5jLmVhY2hTZXJpZXMgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGFzeW5jLmVhY2hPZlNlcmllcyhhcnIsIF93aXRob3V0SW5kZXgoaXRlcmF0b3IpLCBjYWxsYmFjayk7XG4gICAgfTtcblxuXG4gICAgYXN5bmMuZm9yRWFjaExpbWl0ID1cbiAgICBhc3luYy5lYWNoTGltaXQgPSBmdW5jdGlvbiAoYXJyLCBsaW1pdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfZWFjaE9mTGltaXQobGltaXQpKGFyciwgX3dpdGhvdXRJbmRleChpdGVyYXRvciksIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuZm9yRWFjaE9mID1cbiAgICBhc3luYy5lYWNoT2YgPSBmdW5jdGlvbiAob2JqZWN0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBfb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0IHx8IFtdO1xuXG4gICAgICAgIHZhciBpdGVyID0gX2tleUl0ZXJhdG9yKG9iamVjdCk7XG4gICAgICAgIHZhciBrZXksIGNvbXBsZXRlZCA9IDA7XG5cbiAgICAgICAgd2hpbGUgKChrZXkgPSBpdGVyKCkpICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbXBsZXRlZCArPSAxO1xuICAgICAgICAgICAgaXRlcmF0b3Iob2JqZWN0W2tleV0sIGtleSwgb25seV9vbmNlKGRvbmUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21wbGV0ZWQgPT09IDApIGNhbGxiYWNrKG51bGwpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGRvbmUoZXJyKSB7XG4gICAgICAgICAgICBjb21wbGV0ZWQtLTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sga2V5IGlzIG51bGwgaW4gY2FzZSBpdGVyYXRvciBpc24ndCBleGhhdXN0ZWRcbiAgICAgICAgICAgIC8vIGFuZCBkb25lIHJlc29sdmVkIHN5bmNocm9ub3VzbHkuXG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IG51bGwgJiYgY29tcGxldGVkIDw9IDApIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhc3luYy5mb3JFYWNoT2ZTZXJpZXMgPVxuICAgIGFzeW5jLmVhY2hPZlNlcmllcyA9IGZ1bmN0aW9uIChvYmosIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IF9vbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgICAgICBvYmogPSBvYmogfHwgW107XG4gICAgICAgIHZhciBuZXh0S2V5ID0gX2tleUl0ZXJhdG9yKG9iaik7XG4gICAgICAgIHZhciBrZXkgPSBuZXh0S2V5KCk7XG4gICAgICAgIGZ1bmN0aW9uIGl0ZXJhdGUoKSB7XG4gICAgICAgICAgICB2YXIgc3luYyA9IHRydWU7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlcmF0b3Iob2JqW2tleV0sIGtleSwgb25seV9vbmNlKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBuZXh0S2V5KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKGl0ZXJhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBzeW5jID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaXRlcmF0ZSgpO1xuICAgIH07XG5cblxuXG4gICAgYXN5bmMuZm9yRWFjaE9mTGltaXQgPVxuICAgIGFzeW5jLmVhY2hPZkxpbWl0ID0gZnVuY3Rpb24gKG9iaiwgbGltaXQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBfZWFjaE9mTGltaXQobGltaXQpKG9iaiwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2VhY2hPZkxpbWl0KGxpbWl0KSB7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBfb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgICAgICAgICAgIG9iaiA9IG9iaiB8fCBbXTtcbiAgICAgICAgICAgIHZhciBuZXh0S2V5ID0gX2tleUl0ZXJhdG9yKG9iaik7XG4gICAgICAgICAgICBpZiAobGltaXQgPD0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgcnVubmluZyA9IDA7XG4gICAgICAgICAgICB2YXIgZXJyb3JlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAoZnVuY3Rpb24gcmVwbGVuaXNoICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSAmJiBydW5uaW5nIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHdoaWxlIChydW5uaW5nIDwgbGltaXQgJiYgIWVycm9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IG5leHRLZXkoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVubmluZyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcnVubmluZyArPSAxO1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvcihvYmpba2V5XSwga2V5LCBvbmx5X29uY2UoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsZW5pc2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH07XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBkb1BhcmFsbGVsKGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBmbihhc3luYy5lYWNoT2YsIG9iaiwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZG9QYXJhbGxlbExpbWl0KGZuKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqLCBsaW1pdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4oX2VhY2hPZkxpbWl0KGxpbWl0KSwgb2JqLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkb1Nlcmllcyhmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4oYXN5bmMuZWFjaE9mU2VyaWVzLCBvYmosIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2FzeW5jTWFwKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBfb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgICAgICAgYXJyID0gYXJyIHx8IFtdO1xuICAgICAgICB2YXIgcmVzdWx0cyA9IF9pc0FycmF5TGlrZShhcnIpID8gW10gOiB7fTtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHZhbHVlLCBmdW5jdGlvbiAoZXJyLCB2KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSB2O1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMubWFwID0gZG9QYXJhbGxlbChfYXN5bmNNYXApO1xuICAgIGFzeW5jLm1hcFNlcmllcyA9IGRvU2VyaWVzKF9hc3luY01hcCk7XG4gICAgYXN5bmMubWFwTGltaXQgPSBkb1BhcmFsbGVsTGltaXQoX2FzeW5jTWFwKTtcblxuICAgIC8vIHJlZHVjZSBvbmx5IGhhcyBhIHNlcmllcyB2ZXJzaW9uLCBhcyBkb2luZyByZWR1Y2UgaW4gcGFyYWxsZWwgd29uJ3RcbiAgICAvLyB3b3JrIGluIG1hbnkgc2l0dWF0aW9ucy5cbiAgICBhc3luYy5pbmplY3QgPVxuICAgIGFzeW5jLmZvbGRsID1cbiAgICBhc3luYy5yZWR1Y2UgPSBmdW5jdGlvbiAoYXJyLCBtZW1vLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgYXN5bmMuZWFjaE9mU2VyaWVzKGFyciwgZnVuY3Rpb24gKHgsIGksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihtZW1vLCB4LCBmdW5jdGlvbiAoZXJyLCB2KSB7XG4gICAgICAgICAgICAgICAgbWVtbyA9IHY7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIG1lbW8pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYXN5bmMuZm9sZHIgPVxuICAgIGFzeW5jLnJlZHVjZVJpZ2h0ID0gZnVuY3Rpb24gKGFyciwgbWVtbywgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXZlcnNlZCA9IF9tYXAoYXJyLCBpZGVudGl0eSkucmV2ZXJzZSgpO1xuICAgICAgICBhc3luYy5yZWR1Y2UocmV2ZXJzZWQsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChhcnIsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBpdGVyYXRvcjtcbiAgICAgICAgICAgIGl0ZXJhdG9yID0gbWVtbztcbiAgICAgICAgICAgIG1lbW8gPSBfaXNBcnJheShhcnIpID8gW10gOiB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzeW5jLmVhY2hPZihhcnIsIGZ1bmN0aW9uKHYsIGssIGNiKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihtZW1vLCB2LCBrLCBjYik7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBtZW1vKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9maWx0ZXIoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgaW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7aW5kZXg6IGluZGV4LCB2YWx1ZTogeH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKF9tYXAocmVzdWx0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4O1xuICAgICAgICAgICAgfSksIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jLnNlbGVjdCA9XG4gICAgYXN5bmMuZmlsdGVyID0gZG9QYXJhbGxlbChfZmlsdGVyKTtcblxuICAgIGFzeW5jLnNlbGVjdExpbWl0ID1cbiAgICBhc3luYy5maWx0ZXJMaW1pdCA9IGRvUGFyYWxsZWxMaW1pdChfZmlsdGVyKTtcblxuICAgIGFzeW5jLnNlbGVjdFNlcmllcyA9XG4gICAgYXN5bmMuZmlsdGVyU2VyaWVzID0gZG9TZXJpZXMoX2ZpbHRlcik7XG5cbiAgICBmdW5jdGlvbiBfcmVqZWN0KGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgX2ZpbHRlcihlYWNoZm4sIGFyciwgZnVuY3Rpb24odmFsdWUsIGNiKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih2YWx1ZSwgZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgIGNiKCF2KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGFzeW5jLnJlamVjdCA9IGRvUGFyYWxsZWwoX3JlamVjdCk7XG4gICAgYXN5bmMucmVqZWN0TGltaXQgPSBkb1BhcmFsbGVsTGltaXQoX3JlamVjdCk7XG4gICAgYXN5bmMucmVqZWN0U2VyaWVzID0gZG9TZXJpZXMoX3JlamVjdCk7XG5cbiAgICBmdW5jdGlvbiBfY3JlYXRlVGVzdGVyKGVhY2hmbiwgY2hlY2ssIGdldFJlc3VsdCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oYXJyLCBsaW1pdCwgaXRlcmF0b3IsIGNiKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgICAgICAgICAgIGlmIChjYikgY2IoZ2V0UmVzdWx0KGZhbHNlLCB2b2lkIDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGl0ZXJhdGVlKHgsIF8sIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYikgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IoeCwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNiICYmIGNoZWNrKHYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYihnZXRSZXN1bHQodHJ1ZSwgeCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IgPSBpdGVyYXRvciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgICAgICBlYWNoZm4oYXJyLCBsaW1pdCwgaXRlcmF0ZWUsIGRvbmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYiA9IGl0ZXJhdG9yO1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gbGltaXQ7XG4gICAgICAgICAgICAgICAgZWFjaGZuKGFyciwgaXRlcmF0ZWUsIGRvbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jLmFueSA9XG4gICAgYXN5bmMuc29tZSA9IF9jcmVhdGVUZXN0ZXIoYXN5bmMuZWFjaE9mLCB0b0Jvb2wsIGlkZW50aXR5KTtcblxuICAgIGFzeW5jLnNvbWVMaW1pdCA9IF9jcmVhdGVUZXN0ZXIoYXN5bmMuZWFjaE9mTGltaXQsIHRvQm9vbCwgaWRlbnRpdHkpO1xuXG4gICAgYXN5bmMuYWxsID1cbiAgICBhc3luYy5ldmVyeSA9IF9jcmVhdGVUZXN0ZXIoYXN5bmMuZWFjaE9mLCBub3RJZCwgbm90SWQpO1xuXG4gICAgYXN5bmMuZXZlcnlMaW1pdCA9IF9jcmVhdGVUZXN0ZXIoYXN5bmMuZWFjaE9mTGltaXQsIG5vdElkLCBub3RJZCk7XG5cbiAgICBmdW5jdGlvbiBfZmluZEdldFJlc3VsdCh2LCB4KSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICBhc3luYy5kZXRlY3QgPSBfY3JlYXRlVGVzdGVyKGFzeW5jLmVhY2hPZiwgaWRlbnRpdHksIF9maW5kR2V0UmVzdWx0KTtcbiAgICBhc3luYy5kZXRlY3RTZXJpZXMgPSBfY3JlYXRlVGVzdGVyKGFzeW5jLmVhY2hPZlNlcmllcywgaWRlbnRpdHksIF9maW5kR2V0UmVzdWx0KTtcbiAgICBhc3luYy5kZXRlY3RMaW1pdCA9IF9jcmVhdGVUZXN0ZXIoYXN5bmMuZWFjaE9mTGltaXQsIGlkZW50aXR5LCBfZmluZEdldFJlc3VsdCk7XG5cbiAgICBhc3luYy5zb3J0QnkgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgYXN5bmMubWFwKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAoZXJyLCBjcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHt2YWx1ZTogeCwgY3JpdGVyaWE6IGNyaXRlcmlhfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIF9tYXAocmVzdWx0cy5zb3J0KGNvbXBhcmF0b3IpLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZnVuY3Rpb24gY29tcGFyYXRvcihsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhLCBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMuYXV0byA9IGZ1bmN0aW9uICh0YXNrcywgY29uY3VycmVuY3ksIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBjb25jdXJyZW5jeSBpcyBvcHRpb25hbCwgc2hpZnQgdGhlIGFyZ3MuXG4gICAgICAgICAgICBjYWxsYmFjayA9IGNvbmN1cnJlbmN5O1xuICAgICAgICAgICAgY29uY3VycmVuY3kgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrID0gX29uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgICAgIHZhciBrZXlzID0gX2tleXModGFza3MpO1xuICAgICAgICB2YXIgcmVtYWluaW5nVGFza3MgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgaWYgKCFyZW1haW5pbmdUYXNrcykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29uY3VycmVuY3kpIHtcbiAgICAgICAgICAgIGNvbmN1cnJlbmN5ID0gcmVtYWluaW5nVGFza3M7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuICAgICAgICB2YXIgcnVubmluZ1Rhc2tzID0gMDtcblxuICAgICAgICB2YXIgaGFzRXJyb3IgPSBmYWxzZTtcblxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gW107XG4gICAgICAgIGZ1bmN0aW9uIGFkZExpc3RlbmVyKGZuKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMudW5zaGlmdChmbik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZm4pIHtcbiAgICAgICAgICAgIHZhciBpZHggPSBfaW5kZXhPZihsaXN0ZW5lcnMsIGZuKTtcbiAgICAgICAgICAgIGlmIChpZHggPj0gMCkgbGlzdGVuZXJzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRhc2tDb21wbGV0ZSgpIHtcbiAgICAgICAgICAgIHJlbWFpbmluZ1Rhc2tzLS07XG4gICAgICAgICAgICBfYXJyYXlFYWNoKGxpc3RlbmVycy5zbGljZSgwKSwgZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRkTGlzdGVuZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFyZW1haW5pbmdUYXNrcykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBfYXJyYXlFYWNoKGtleXMsIGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBpZiAoaGFzRXJyb3IpIHJldHVybjtcbiAgICAgICAgICAgIHZhciB0YXNrID0gX2lzQXJyYXkodGFza3Nba10pID8gdGFza3Nba106IFt0YXNrc1trXV07XG4gICAgICAgICAgICB2YXIgdGFza0NhbGxiYWNrID0gX3Jlc3RQYXJhbShmdW5jdGlvbihlcnIsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICBydW5uaW5nVGFza3MtLTtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2FmZVJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgX2ZvckVhY2hPZihyZXN1bHRzLCBmdW5jdGlvbih2YWwsIHJrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhZmVSZXN1bHRzW3JrZXldID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2FmZVJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBoYXNFcnJvciA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBzYWZlUmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKHRhc2tDb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgcmVxdWlyZXMgPSB0YXNrLnNsaWNlKDAsIHRhc2subGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAvLyBwcmV2ZW50IGRlYWQtbG9ja3NcbiAgICAgICAgICAgIHZhciBsZW4gPSByZXF1aXJlcy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgZGVwO1xuICAgICAgICAgICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoZGVwID0gdGFza3NbcmVxdWlyZXNbbGVuXV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzIG5vbmV4aXN0ZW50IGRlcGVuZGVuY3kgaW4gJyArIHJlcXVpcmVzLmpvaW4oJywgJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX2lzQXJyYXkoZGVwKSAmJiBfaW5kZXhPZihkZXAsIGspID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXMgY3ljbGljIGRlcGVuZGVuY2llcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlYWR5KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBydW5uaW5nVGFza3MgPCBjb25jdXJyZW5jeSAmJiBfcmVkdWNlKHJlcXVpcmVzLCBmdW5jdGlvbiAoYSwgeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGEgJiYgcmVzdWx0cy5oYXNPd25Qcm9wZXJ0eSh4KSk7XG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSkgJiYgIXJlc3VsdHMuaGFzT3duUHJvcGVydHkoayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVhZHkoKSkge1xuICAgICAgICAgICAgICAgIHJ1bm5pbmdUYXNrcysrO1xuICAgICAgICAgICAgICAgIHRhc2tbdGFzay5sZW5ndGggLSAxXSh0YXNrQ2FsbGJhY2ssIHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRkTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gbGlzdGVuZXIoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlYWR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZ1Rhc2tzKys7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdGFza1t0YXNrLmxlbmd0aCAtIDFdKHRhc2tDYWxsYmFjaywgcmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG5cblxuICAgIGFzeW5jLnJldHJ5ID0gZnVuY3Rpb24odGltZXMsIHRhc2ssIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBERUZBVUxUX1RJTUVTID0gNTtcbiAgICAgICAgdmFyIERFRkFVTFRfSU5URVJWQUwgPSAwO1xuXG4gICAgICAgIHZhciBhdHRlbXB0cyA9IFtdO1xuXG4gICAgICAgIHZhciBvcHRzID0ge1xuICAgICAgICAgICAgdGltZXM6IERFRkFVTFRfVElNRVMsXG4gICAgICAgICAgICBpbnRlcnZhbDogREVGQVVMVF9JTlRFUlZBTFxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlVGltZXMoYWNjLCB0KXtcbiAgICAgICAgICAgIGlmKHR5cGVvZiB0ID09PSAnbnVtYmVyJyl7XG4gICAgICAgICAgICAgICAgYWNjLnRpbWVzID0gcGFyc2VJbnQodCwgMTApIHx8IERFRkFVTFRfVElNRVM7XG4gICAgICAgICAgICB9IGVsc2UgaWYodHlwZW9mIHQgPT09ICdvYmplY3QnKXtcbiAgICAgICAgICAgICAgICBhY2MudGltZXMgPSBwYXJzZUludCh0LnRpbWVzLCAxMCkgfHwgREVGQVVMVF9USU1FUztcbiAgICAgICAgICAgICAgICBhY2MuaW50ZXJ2YWwgPSBwYXJzZUludCh0LmludGVydmFsLCAxMCkgfHwgREVGQVVMVF9JTlRFUlZBTDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBhcmd1bWVudCB0eXBlIGZvciBcXCd0aW1lc1xcJzogJyArIHR5cGVvZiB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoIDwgMSB8fCBsZW5ndGggPiAzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzIC0gbXVzdCBiZSBlaXRoZXIgKHRhc2spLCAodGFzaywgY2FsbGJhY2spLCAodGltZXMsIHRhc2spIG9yICh0aW1lcywgdGFzaywgY2FsbGJhY2spJyk7XG4gICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoIDw9IDIgJiYgdHlwZW9mIHRpbWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHRhc2s7XG4gICAgICAgICAgICB0YXNrID0gdGltZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aW1lcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcGFyc2VUaW1lcyhvcHRzLCB0aW1lcyk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0cy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICBvcHRzLnRhc2sgPSB0YXNrO1xuXG4gICAgICAgIGZ1bmN0aW9uIHdyYXBwZWRUYXNrKHdyYXBwZWRDYWxsYmFjaywgd3JhcHBlZFJlc3VsdHMpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJldHJ5QXR0ZW1wdCh0YXNrLCBmaW5hbEF0dGVtcHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oc2VyaWVzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGFzayhmdW5jdGlvbihlcnIsIHJlc3VsdCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpZXNDYWxsYmFjayghZXJyIHx8IGZpbmFsQXR0ZW1wdCwge2VycjogZXJyLCByZXN1bHQ6IHJlc3VsdH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCB3cmFwcGVkUmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gcmV0cnlJbnRlcnZhbChpbnRlcnZhbCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNlcmllc0NhbGxiYWNrKXtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWVzQ2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGludGVydmFsKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAob3B0cy50aW1lcykge1xuXG4gICAgICAgICAgICAgICAgdmFyIGZpbmFsQXR0ZW1wdCA9ICEob3B0cy50aW1lcy09MSk7XG4gICAgICAgICAgICAgICAgYXR0ZW1wdHMucHVzaChyZXRyeUF0dGVtcHQob3B0cy50YXNrLCBmaW5hbEF0dGVtcHQpKTtcbiAgICAgICAgICAgICAgICBpZighZmluYWxBdHRlbXB0ICYmIG9wdHMuaW50ZXJ2YWwgPiAwKXtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdHMucHVzaChyZXRyeUludGVydmFsKG9wdHMuaW50ZXJ2YWwpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFzeW5jLnNlcmllcyhhdHRlbXB0cywgZnVuY3Rpb24oZG9uZSwgZGF0YSl7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAod3JhcHBlZENhbGxiYWNrIHx8IG9wdHMuY2FsbGJhY2spKGRhdGEuZXJyLCBkYXRhLnJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGEgY2FsbGJhY2sgaXMgcGFzc2VkLCBydW4gdGhpcyBhcyBhIGNvbnRyb2xsIGZsb3dcbiAgICAgICAgcmV0dXJuIG9wdHMuY2FsbGJhY2sgPyB3cmFwcGVkVGFzaygpIDogd3JhcHBlZFRhc2s7XG4gICAgfTtcblxuICAgIGFzeW5jLndhdGVyZmFsbCA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBfb25jZShjYWxsYmFjayB8fCBub29wKTtcbiAgICAgICAgaWYgKCFfaXNBcnJheSh0YXNrcykpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIHdhdGVyZmFsbCBtdXN0IGJlIGFuIGFycmF5IG9mIGZ1bmN0aW9ucycpO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0YXNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHdyYXBJdGVyYXRvcihpdGVyYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIF9yZXN0UGFyYW0oZnVuY3Rpb24gKGVyciwgYXJncykge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgW2Vycl0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKHdyYXBJdGVyYXRvcihuZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVuc3VyZUFzeW5jKGl0ZXJhdG9yKS5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB3cmFwSXRlcmF0b3IoYXN5bmMuaXRlcmF0b3IodGFza3MpKSgpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfcGFyYWxsZWwoZWFjaGZuLCB0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuICAgICAgICB2YXIgcmVzdWx0cyA9IF9pc0FycmF5TGlrZSh0YXNrcykgPyBbXSA6IHt9O1xuXG4gICAgICAgIGVhY2hmbih0YXNrcywgZnVuY3Rpb24gKHRhc2ssIGtleSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRhc2soX3Jlc3RQYXJhbShmdW5jdGlvbiAoZXJyLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHNba2V5XSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMucGFyYWxsZWwgPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIF9wYXJhbGxlbChhc3luYy5lYWNoT2YsIHRhc2tzLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLnBhcmFsbGVsTGltaXQgPSBmdW5jdGlvbih0YXNrcywgbGltaXQsIGNhbGxiYWNrKSB7XG4gICAgICAgIF9wYXJhbGxlbChfZWFjaE9mTGltaXQobGltaXQpLCB0YXNrcywgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5zZXJpZXMgPSBmdW5jdGlvbih0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgX3BhcmFsbGVsKGFzeW5jLmVhY2hPZlNlcmllcywgdGFza3MsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuaXRlcmF0b3IgPSBmdW5jdGlvbiAodGFza3MpIHtcbiAgICAgICAgZnVuY3Rpb24gbWFrZUNhbGxiYWNrKGluZGV4KSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBmbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2tzW2luZGV4XS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZm4ubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm4ubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGluZGV4IDwgdGFza3MubGVuZ3RoIC0gMSkgPyBtYWtlQ2FsbGJhY2soaW5kZXggKyAxKTogbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ha2VDYWxsYmFjaygwKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuYXBwbHkgPSBfcmVzdFBhcmFtKGZ1bmN0aW9uIChmbiwgYXJncykge1xuICAgICAgICByZXR1cm4gX3Jlc3RQYXJhbShmdW5jdGlvbiAoY2FsbEFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShcbiAgICAgICAgICAgICAgICBudWxsLCBhcmdzLmNvbmNhdChjYWxsQXJncylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gX2NvbmNhdChlYWNoZm4sIGFyciwgZm4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGluZGV4LCBjYikge1xuICAgICAgICAgICAgZm4oeCwgZnVuY3Rpb24gKGVyciwgeSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoeSB8fCBbXSk7XG4gICAgICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYy5jb25jYXQgPSBkb1BhcmFsbGVsKF9jb25jYXQpO1xuICAgIGFzeW5jLmNvbmNhdFNlcmllcyA9IGRvU2VyaWVzKF9jb25jYXQpO1xuXG4gICAgYXN5bmMud2hpbHN0ID0gZnVuY3Rpb24gKHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gICAgICAgIGlmICh0ZXN0KCkpIHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gX3Jlc3RQYXJhbShmdW5jdGlvbihlcnIsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0ZXN0LmFwcGx5KHRoaXMsIGFyZ3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yKG5leHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIFtudWxsXS5jb25jYXQoYXJncykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaXRlcmF0b3IobmV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhc3luYy5kb1doaWxzdCA9IGZ1bmN0aW9uIChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGNhbGxzID0gMDtcbiAgICAgICAgcmV0dXJuIGFzeW5jLndoaWxzdChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiArK2NhbGxzIDw9IDEgfHwgdGVzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy51bnRpbCA9IGZ1bmN0aW9uICh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGFzeW5jLndoaWxzdChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGVzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5kb1VudGlsID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gYXN5bmMuZG9XaGlsc3QoaXRlcmF0b3IsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICF0ZXN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuZHVyaW5nID0gZnVuY3Rpb24gKHRlc3QsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG5cbiAgICAgICAgdmFyIG5leHQgPSBfcmVzdFBhcmFtKGZ1bmN0aW9uKGVyciwgYXJncykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChjaGVjayk7XG4gICAgICAgICAgICAgICAgdGVzdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGNoZWNrID0gZnVuY3Rpb24oZXJyLCB0cnV0aCkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRydXRoKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0b3IobmV4dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRlc3QoY2hlY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5kb0R1cmluZyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgdGVzdCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGNhbGxzID0gMDtcbiAgICAgICAgYXN5bmMuZHVyaW5nKGZ1bmN0aW9uKG5leHQpIHtcbiAgICAgICAgICAgIGlmIChjYWxscysrIDwgMSkge1xuICAgICAgICAgICAgICAgIG5leHQobnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRlc3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX3F1ZXVlKHdvcmtlciwgY29uY3VycmVuY3ksIHBheWxvYWQpIHtcbiAgICAgICAgaWYgKGNvbmN1cnJlbmN5ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmN1cnJlbmN5ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGNvbmN1cnJlbmN5ID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmN1cnJlbmN5IG11c3Qgbm90IGJlIHplcm8nKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBfaW5zZXJ0KHEsIGRhdGEsIHBvcywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsICYmIHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGFzayBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFfaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihkYXRhLmxlbmd0aCA9PT0gMCAmJiBxLmlkbGUoKSkge1xuICAgICAgICAgICAgICAgIC8vIGNhbGwgZHJhaW4gaW1tZWRpYXRlbHkgaWYgdGhlcmUgYXJlIG5vIHRhc2tzXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcS5kcmFpbigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2FycmF5RWFjaChkYXRhLCBmdW5jdGlvbih0YXNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHRhc2ssXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayB8fCBub29wXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcS50YXNrcy51bnNoaWZ0KGl0ZW0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHEudGFza3MucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocS50YXNrcy5sZW5ndGggPT09IHEuY29uY3VycmVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgcS5zYXR1cmF0ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShxLnByb2Nlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIF9uZXh0KHEsIHRhc2tzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICB3b3JrZXJzIC09IDE7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgIF9hcnJheUVhY2godGFza3MsIGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIF9hcnJheUVhY2god29ya2Vyc0xpc3QsIGZ1bmN0aW9uICh3b3JrZXIsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod29ya2VyID09PSB0YXNrICYmICFyZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2Vyc0xpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGFzay5jYWxsYmFjay5hcHBseSh0YXNrLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocS50YXNrcy5sZW5ndGggKyB3b3JrZXJzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHEuZHJhaW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcS5wcm9jZXNzKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdvcmtlcnMgPSAwO1xuICAgICAgICB2YXIgd29ya2Vyc0xpc3QgPSBbXTtcbiAgICAgICAgdmFyIHEgPSB7XG4gICAgICAgICAgICB0YXNrczogW10sXG4gICAgICAgICAgICBjb25jdXJyZW5jeTogY29uY3VycmVuY3ksXG4gICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICAgICAgc2F0dXJhdGVkOiBub29wLFxuICAgICAgICAgICAgZW1wdHk6IG5vb3AsXG4gICAgICAgICAgICBkcmFpbjogbm9vcCxcbiAgICAgICAgICAgIHN0YXJ0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgcGF1c2VkOiBmYWxzZSxcbiAgICAgICAgICAgIHB1c2g6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIF9pbnNlcnQocSwgZGF0YSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBraWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcS5kcmFpbiA9IG5vb3A7XG4gICAgICAgICAgICAgICAgcS50YXNrcyA9IFtdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuc2hpZnQ6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIF9pbnNlcnQocSwgZGF0YSwgdHJ1ZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSghcS5wYXVzZWQgJiYgd29ya2VycyA8IHEuY29uY3VycmVuY3kgJiYgcS50YXNrcy5sZW5ndGgpe1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXNrcyA9IHEucGF5bG9hZCA/XG4gICAgICAgICAgICAgICAgICAgICAgICBxLnRhc2tzLnNwbGljZSgwLCBxLnBheWxvYWQpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHEudGFza3Muc3BsaWNlKDAsIHEudGFza3MubGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IF9tYXAodGFza3MsIGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFzay5kYXRhO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocS50YXNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHEuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3b3JrZXJzICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlcnNMaXN0LnB1c2godGFza3NbMF0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2IgPSBvbmx5X29uY2UoX25leHQocSwgdGFza3MpKTtcbiAgICAgICAgICAgICAgICAgICAgd29ya2VyKGRhdGEsIGNiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHEudGFza3MubGVuZ3RoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJ1bm5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd29ya2VycztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3b3JrZXJzTGlzdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3b3JrZXJzTGlzdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZGxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcS50YXNrcy5sZW5ndGggKyB3b3JrZXJzID09PSAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcS5wYXVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChxLnBhdXNlZCA9PT0gZmFsc2UpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICAgICAgcS5wYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdW1lQ291bnQgPSBNYXRoLm1pbihxLmNvbmN1cnJlbmN5LCBxLnRhc2tzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gTmVlZCB0byBjYWxsIHEucHJvY2VzcyBvbmNlIHBlciBjb25jdXJyZW50XG4gICAgICAgICAgICAgICAgLy8gd29ya2VyIHRvIHByZXNlcnZlIGZ1bGwgY29uY3VycmVuY3kgYWZ0ZXIgcGF1c2VcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB3ID0gMTsgdyA8PSByZXN1bWVDb3VudDsgdysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShxLnByb2Nlc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgfVxuXG4gICAgYXN5bmMucXVldWUgPSBmdW5jdGlvbiAod29ya2VyLCBjb25jdXJyZW5jeSkge1xuICAgICAgICB2YXIgcSA9IF9xdWV1ZShmdW5jdGlvbiAoaXRlbXMsIGNiKSB7XG4gICAgICAgICAgICB3b3JrZXIoaXRlbXNbMF0sIGNiKTtcbiAgICAgICAgfSwgY29uY3VycmVuY3ksIDEpO1xuXG4gICAgICAgIHJldHVybiBxO1xuICAgIH07XG5cbiAgICBhc3luYy5wcmlvcml0eVF1ZXVlID0gZnVuY3Rpb24gKHdvcmtlciwgY29uY3VycmVuY3kpIHtcblxuICAgICAgICBmdW5jdGlvbiBfY29tcGFyZVRhc2tzKGEsIGIpe1xuICAgICAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gX2JpbmFyeVNlYXJjaChzZXF1ZW5jZSwgaXRlbSwgY29tcGFyZSkge1xuICAgICAgICAgICAgdmFyIGJlZyA9IC0xLFxuICAgICAgICAgICAgICAgIGVuZCA9IHNlcXVlbmNlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB3aGlsZSAoYmVnIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pZCA9IGJlZyArICgoZW5kIC0gYmVnICsgMSkgPj4+IDEpO1xuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKGl0ZW0sIHNlcXVlbmNlW21pZF0pID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYmVnID0gbWlkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IG1pZCAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJlZztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIF9pbnNlcnQocSwgZGF0YSwgcHJpb3JpdHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiB0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRhc2sgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcS5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghX2lzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gW2RhdGFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxsIGRyYWluIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyB0YXNrc1xuICAgICAgICAgICAgICAgIHJldHVybiBhc3luYy5zZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHEuZHJhaW4oKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9hcnJheUVhY2goZGF0YSwgZnVuY3Rpb24odGFzaykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB0YXNrLFxuICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogcHJpb3JpdHksXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBjYWxsYmFjayA6IG5vb3BcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcS50YXNrcy5zcGxpY2UoX2JpbmFyeVNlYXJjaChxLnRhc2tzLCBpdGVtLCBfY29tcGFyZVRhc2tzKSArIDEsIDAsIGl0ZW0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHEudGFza3MubGVuZ3RoID09PSBxLmNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgICAgICAgICAgIHEuc2F0dXJhdGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShxLnByb2Nlc3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCB3aXRoIGEgbm9ybWFsIHF1ZXVlXG4gICAgICAgIHZhciBxID0gYXN5bmMucXVldWUod29ya2VyLCBjb25jdXJyZW5jeSk7XG5cbiAgICAgICAgLy8gT3ZlcnJpZGUgcHVzaCB0byBhY2NlcHQgc2Vjb25kIHBhcmFtZXRlciByZXByZXNlbnRpbmcgcHJpb3JpdHlcbiAgICAgICAgcS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIHByaW9yaXR5LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgX2luc2VydChxLCBkYXRhLCBwcmlvcml0eSwgY2FsbGJhY2spO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJlbW92ZSB1bnNoaWZ0IGZ1bmN0aW9uXG4gICAgICAgIGRlbGV0ZSBxLnVuc2hpZnQ7XG5cbiAgICAgICAgcmV0dXJuIHE7XG4gICAgfTtcblxuICAgIGFzeW5jLmNhcmdvID0gZnVuY3Rpb24gKHdvcmtlciwgcGF5bG9hZCkge1xuICAgICAgICByZXR1cm4gX3F1ZXVlKHdvcmtlciwgMSwgcGF5bG9hZCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9jb25zb2xlX2ZuKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9yZXN0UGFyYW0oZnVuY3Rpb24gKGZuLCBhcmdzKSB7XG4gICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzLmNvbmNhdChbX3Jlc3RQYXJhbShmdW5jdGlvbiAoZXJyLCBhcmdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uc29sZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb25zb2xlW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYXJyYXlFYWNoKGFyZ3MsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZVtuYW1lXSh4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSldKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYy5sb2cgPSBfY29uc29sZV9mbignbG9nJyk7XG4gICAgYXN5bmMuZGlyID0gX2NvbnNvbGVfZm4oJ2RpcicpO1xuICAgIC8qYXN5bmMuaW5mbyA9IF9jb25zb2xlX2ZuKCdpbmZvJyk7XG4gICAgYXN5bmMud2FybiA9IF9jb25zb2xlX2ZuKCd3YXJuJyk7XG4gICAgYXN5bmMuZXJyb3IgPSBfY29uc29sZV9mbignZXJyb3InKTsqL1xuXG4gICAgYXN5bmMubWVtb2l6ZSA9IGZ1bmN0aW9uIChmbiwgaGFzaGVyKSB7XG4gICAgICAgIHZhciBtZW1vID0ge307XG4gICAgICAgIHZhciBxdWV1ZXMgPSB7fTtcbiAgICAgICAgdmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gICAgICAgIGhhc2hlciA9IGhhc2hlciB8fCBpZGVudGl0eTtcbiAgICAgICAgdmFyIG1lbW9pemVkID0gX3Jlc3RQYXJhbShmdW5jdGlvbiBtZW1vaXplZChhcmdzKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgdmFyIGtleSA9IGhhc2hlci5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgIGlmIChoYXMuY2FsbChtZW1vLCBrZXkpKSB7ICAgXG4gICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgbWVtb1trZXldKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhcy5jYWxsKHF1ZXVlcywga2V5KSkge1xuICAgICAgICAgICAgICAgIHF1ZXVlc1trZXldLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVldWVzW2tleV0gPSBbY2FsbGJhY2tdO1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MuY29uY2F0KFtfcmVzdFBhcmFtKGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbW9ba2V5XSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIHZhciBxID0gcXVldWVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBxdWV1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBxLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcVtpXS5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVtb2l6ZWQubWVtbyA9IG1lbW87XG4gICAgICAgIG1lbW9pemVkLnVubWVtb2l6ZWQgPSBmbjtcbiAgICAgICAgcmV0dXJuIG1lbW9pemVkO1xuICAgIH07XG5cbiAgICBhc3luYy51bm1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoZm4udW5tZW1vaXplZCB8fCBmbikuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX3RpbWVzKG1hcHBlcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvdW50LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIG1hcHBlcihfcmFuZ2UoY291bnQpLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jLnRpbWVzID0gX3RpbWVzKGFzeW5jLm1hcCk7XG4gICAgYXN5bmMudGltZXNTZXJpZXMgPSBfdGltZXMoYXN5bmMubWFwU2VyaWVzKTtcbiAgICBhc3luYy50aW1lc0xpbWl0ID0gZnVuY3Rpb24gKGNvdW50LCBsaW1pdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBhc3luYy5tYXBMaW1pdChfcmFuZ2UoY291bnQpLCBsaW1pdCwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuc2VxID0gZnVuY3Rpb24gKC8qIGZ1bmN0aW9ucy4uLiAqLykge1xuICAgICAgICB2YXIgZm5zID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3Jlc3RQYXJhbShmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFzeW5jLnJlZHVjZShmbnMsIGFyZ3MsIGZ1bmN0aW9uIChuZXdhcmdzLCBmbiwgY2IpIHtcbiAgICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBuZXdhcmdzLmNvbmNhdChbX3Jlc3RQYXJhbShmdW5jdGlvbiAoZXJyLCBuZXh0YXJncykge1xuICAgICAgICAgICAgICAgICAgICBjYihlcnIsIG5leHRhcmdzKTtcbiAgICAgICAgICAgICAgICB9KV0pKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodGhhdCwgW2Vycl0uY29uY2F0KHJlc3VsdHMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYXN5bmMuY29tcG9zZSA9IGZ1bmN0aW9uICgvKiBmdW5jdGlvbnMuLi4gKi8pIHtcbiAgICAgICAgcmV0dXJuIGFzeW5jLnNlcS5hcHBseShudWxsLCBBcnJheS5wcm90b3R5cGUucmV2ZXJzZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG5cblxuICAgIGZ1bmN0aW9uIF9hcHBseUVhY2goZWFjaGZuKSB7XG4gICAgICAgIHJldHVybiBfcmVzdFBhcmFtKGZ1bmN0aW9uKGZucywgYXJncykge1xuICAgICAgICAgICAgdmFyIGdvID0gX3Jlc3RQYXJhbShmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVhY2hmbihmbnMsIGZ1bmN0aW9uIChmbiwgXywgY2IpIHtcbiAgICAgICAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncy5jb25jYXQoW2NiXSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ28uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ287XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jLmFwcGx5RWFjaCA9IF9hcHBseUVhY2goYXN5bmMuZWFjaE9mKTtcbiAgICBhc3luYy5hcHBseUVhY2hTZXJpZXMgPSBfYXBwbHlFYWNoKGFzeW5jLmVhY2hPZlNlcmllcyk7XG5cblxuICAgIGFzeW5jLmZvcmV2ZXIgPSBmdW5jdGlvbiAoZm4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBkb25lID0gb25seV9vbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgICAgICB2YXIgdGFzayA9IGVuc3VyZUFzeW5jKGZuKTtcbiAgICAgICAgZnVuY3Rpb24gbmV4dChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZShlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFzayhuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGVuc3VyZUFzeW5jKGZuKSB7XG4gICAgICAgIHJldHVybiBfcmVzdFBhcmFtKGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5uZXJBcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBpbm5lckFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBpbm5lckFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICBzeW5jID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jLmVuc3VyZUFzeW5jID0gZW5zdXJlQXN5bmM7XG5cbiAgICBhc3luYy5jb25zdGFudCA9IF9yZXN0UGFyYW0oZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICAgIHZhciBhcmdzID0gW251bGxdLmNvbmNhdCh2YWx1ZXMpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBhc3luYy53cmFwU3luYyA9XG4gICAgYXN5bmMuYXN5bmNpZnkgPSBmdW5jdGlvbiBhc3luY2lmeShmdW5jKSB7XG4gICAgICAgIHJldHVybiBfcmVzdFBhcmFtKGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiByZXN1bHQgaXMgUHJvbWlzZSBvYmplY3RcbiAgICAgICAgICAgIGlmIChfaXNPYmplY3QocmVzdWx0KSAmJiB0eXBlb2YgcmVzdWx0LnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIubWVzc2FnZSA/IGVyciA6IG5ldyBFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIE5vZGUuanNcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBhc3luYztcbiAgICB9XG4gICAgLy8gQU1EIC8gUmVxdWlyZUpTXG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGFzeW5jO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gaW5jbHVkZWQgZGlyZWN0bHkgdmlhIDxzY3JpcHQ+IHRhZ1xuICAgIGVsc2Uge1xuICAgICAgICByb290LmFzeW5jID0gYXN5bmM7XG4gICAgfVxuXG59KCkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FzeW5jL2xpYi9hc3luYy5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygzKSkoMzkpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIGZyb20gZGxsLXJlZmVyZW5jZSB2ZW5kb3JfYWU5N2JhMWNiMjQxMmMxYTg2NDRcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbmZ1bmN0aW9uIEVudHJ5TW9kdWxlTm90Rm91bmRFcnJvcihlcnIpIHtcclxuXHRFcnJvci5jYWxsKHRoaXMpO1xyXG5cdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEVudHJ5TW9kdWxlTm90Rm91bmRFcnJvcik7XHJcblx0dGhpcy5uYW1lID0gXCJFbnRyeU1vZHVsZU5vdEZvdW5kRXJyb3JcIjtcclxuXHR0aGlzLm1lc3NhZ2UgPSBcIkVudHJ5IG1vZHVsZSBub3QgZm91bmQ6IFwiICsgZXJyO1xyXG5cdHRoaXMuZGV0YWlscyA9IGVyci5kZXRhaWxzO1xyXG5cdHRoaXMuZXJyb3IgPSBlcnI7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBFbnRyeU1vZHVsZU5vdEZvdW5kRXJyb3I7XHJcblxyXG5FbnRyeU1vZHVsZU5vdEZvdW5kRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL0VudHJ5TW9kdWxlTm90Rm91bmRFcnJvci5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuZnVuY3Rpb24gTW9kdWxlTm90Rm91bmRFcnJvcihtb2R1bGUsIGVycikge1xyXG5cdEVycm9yLmNhbGwodGhpcyk7XHJcblx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgTW9kdWxlTm90Rm91bmRFcnJvcik7XHJcblx0dGhpcy5uYW1lID0gXCJNb2R1bGVOb3RGb3VuZEVycm9yXCI7XHJcblx0dGhpcy5tZXNzYWdlID0gXCJNb2R1bGUgbm90IGZvdW5kOiBcIiArIGVycjtcclxuXHR0aGlzLmRldGFpbHMgPSBlcnIuZGV0YWlscztcclxuXHR0aGlzLm1pc3NpbmcgPSBlcnIubWlzc2luZztcclxuXHR0aGlzLm1vZHVsZSA9IG1vZHVsZTtcclxuXHR0aGlzLmVycm9yID0gZXJyO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gTW9kdWxlTm90Rm91bmRFcnJvcjtcclxuXHJcbk1vZHVsZU5vdEZvdW5kRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL01vZHVsZU5vdEZvdW5kRXJyb3IuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbmZ1bmN0aW9uIENyaXRpY2FsRGVwZW5kZW5jaWVzV2FybmluZyhtb2R1bGUsIGRlcGVuZGVuY2llcykge1xyXG5cdEVycm9yLmNhbGwodGhpcyk7XHJcblx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ3JpdGljYWxEZXBlbmRlbmNpZXNXYXJuaW5nKTtcclxuXHR0aGlzLm5hbWUgPSBcIkNyaXRpY2FsRGVwZW5kZW5jaWVzV2FybmluZ1wiO1xyXG5cdHRoaXMubWVzc2FnZSA9IFwiQ3JpdGljYWwgZGVwZW5kZW5jaWVzOlwiO1xyXG5cdHRoaXMubWVzc2FnZSArPSBkZXBlbmRlbmNpZXMuZmlsdGVyKGZ1bmN0aW9uKGQpIHtcclxuXHRcdHJldHVybiB0eXBlb2YgZC5jcml0aWNhbCA9PT0gXCJzdHJpbmdcIiB8fCBkLmxvYztcclxuXHR9KS5tYXAoZnVuY3Rpb24oZGVwKSB7XHJcblx0XHR2YXIgbGluZSA9IFtdO1xyXG5cdFx0aWYoZGVwLmxvYykgbGluZS5wdXNoKGRlcC5sb2Muc3RhcnQubGluZSArIFwiOlwiICsgZGVwLmxvYy5zdGFydC5jb2x1bW4gKyBcIi1cIiArXHJcblx0XHRcdChkZXAubG9jLnN0YXJ0LmxpbmUgIT09IGRlcC5sb2MuZW5kLmxpbmUgPyBkZXAubG9jLmVuZC5saW5lICsgXCI6XCIgOiBcIlwiKSArIGRlcC5sb2MuZW5kLmNvbHVtbik7XHJcblx0XHRpZih0eXBlb2YgZGVwLmNyaXRpY2FsID09PSBcInN0cmluZ1wiKSBsaW5lLnB1c2goZGVwLmNyaXRpY2FsKTtcclxuXHRcdHJldHVybiBcIlxcblwiICsgbGluZS5qb2luKFwiIFwiKTtcclxuXHR9KS5qb2luKFwiXCIpO1xyXG5cdHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xyXG5cdHRoaXMub3JpZ2luID0gdGhpcy5tb2R1bGUgPSBtb2R1bGU7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBDcml0aWNhbERlcGVuZGVuY2llc1dhcm5pbmc7XHJcblxyXG5Dcml0aWNhbERlcGVuZGVuY2llc1dhcm5pbmcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL0NyaXRpY2FsRGVwZW5kZW5jaWVzV2FybmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIERlcGVuZGVuY2llc0Jsb2NrID0gcmVxdWlyZShcIi4vRGVwZW5kZW5jaWVzQmxvY2tcIik7XHJcbnZhciBNb2R1bGVSZWFzb24gPSByZXF1aXJlKFwiLi9Nb2R1bGVSZWFzb25cIik7XHJcblxyXG52YXIgZGVidWdJZCA9IDEwMDA7XHJcblxyXG5mdW5jdGlvbiBNb2R1bGUoKSB7XHJcblx0RGVwZW5kZW5jaWVzQmxvY2suY2FsbCh0aGlzKTtcclxuXHR0aGlzLmNvbnRleHQgPSBudWxsO1xyXG5cdHRoaXMucmVhc29ucyA9IFtdO1xyXG5cdHRoaXMuZGVidWdJZCA9IGRlYnVnSWQrKztcclxuXHR0aGlzLmxhc3RJZCA9IC0xO1xyXG5cdHRoaXMuaWQgPSBudWxsO1xyXG5cdHRoaXMuaW5kZXggPSBudWxsO1xyXG5cdHRoaXMuaW5kZXgyID0gbnVsbDtcclxuXHR0aGlzLmNodW5rcyA9IFtdO1xyXG5cdHRoaXMud2FybmluZ3MgPSBbXTtcclxuXHR0aGlzLmRlcGVuZGVuY2llc1dhcm5pbmdzID0gW107XHJcblx0dGhpcy5lcnJvcnMgPSBbXTtcclxuXHR0aGlzLmRlcGVuZGVuY2llc0Vycm9ycyA9IFtdO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gTW9kdWxlO1xyXG5cclxuTW9kdWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRGVwZW5kZW5jaWVzQmxvY2sucHJvdG90eXBlKTtcclxuXHJcbk1vZHVsZS5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMucmVhc29ucy5sZW5ndGggPSAwO1xyXG5cdHRoaXMubGFzdElkID0gdGhpcy5pZDtcclxuXHR0aGlzLmlkID0gbnVsbDtcclxuXHR0aGlzLmluZGV4ID0gbnVsbDtcclxuXHR0aGlzLmluZGV4MiA9IG51bGw7XHJcblx0dGhpcy5jaHVua3MubGVuZ3RoID0gMDtcclxuXHREZXBlbmRlbmNpZXNCbG9jay5wcm90b3R5cGUuZGlzY29ubmVjdC5jYWxsKHRoaXMpO1xyXG59O1xyXG5cclxuTW9kdWxlLnByb3RvdHlwZS5hZGRDaHVuayA9IGZ1bmN0aW9uKGNodW5rKSB7XHJcblx0dmFyIGlkeCA9IHRoaXMuY2h1bmtzLmluZGV4T2YoY2h1bmspO1xyXG5cdGlmKGlkeCA8IDApXHJcblx0XHR0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcclxufTtcclxuXHJcbk1vZHVsZS5wcm90b3R5cGUuX3JlbW92ZUFuZERvID0gcmVxdWlyZShcIi4vcmVtb3ZlQW5kRG9cIik7XHJcblxyXG5Nb2R1bGUucHJvdG90eXBlLnJlbW92ZUNodW5rID0gZnVuY3Rpb24oY2h1bmspIHtcclxuXHRyZXR1cm4gdGhpcy5fcmVtb3ZlQW5kRG8oXCJjaHVua3NcIiwgY2h1bmssIFwicmVtb3ZlTW9kdWxlXCIpO1xyXG59O1xyXG5cclxuTW9kdWxlLnByb3RvdHlwZS5hZGRSZWFzb24gPSBmdW5jdGlvbihtb2R1bGUsIGRlcGVuZGVuY3kpIHtcclxuXHR0aGlzLnJlYXNvbnMucHVzaChuZXcgTW9kdWxlUmVhc29uKG1vZHVsZSwgZGVwZW5kZW5jeSkpO1xyXG59O1xyXG5cclxuTW9kdWxlLnByb3RvdHlwZS5yZW1vdmVSZWFzb24gPSBmdW5jdGlvbihtb2R1bGUsIGRlcGVuZGVuY3kpIHtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWFzb25zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgciA9IHRoaXMucmVhc29uc1tpXTtcclxuXHRcdGlmKHIubW9kdWxlID09PSBtb2R1bGUgJiYgci5kZXBlbmRlbmN5ID09PSBkZXBlbmRlbmN5KSB7XHJcblx0XHRcdHRoaXMucmVhc29ucy5zcGxpY2UoaSwgMSk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5Nb2R1bGUucHJvdG90eXBlLmhhc1JlYXNvbkZvckNodW5rID0gZnVuY3Rpb24oY2h1bmspIHtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWFzb25zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgciA9IHRoaXMucmVhc29uc1tpXTtcclxuXHRcdGlmKHIuY2h1bmtzKSB7XHJcblx0XHRcdGlmKHIuY2h1bmtzLmluZGV4T2YoY2h1bmspID49IDApXHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9IGVsc2UgaWYoci5tb2R1bGUuY2h1bmtzLmluZGV4T2YoY2h1bmspID49IDApXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHRyZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBhZGRUb1NldChzZXQsIGl0ZW1zKSB7XHJcblx0aXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRpZihzZXQuaW5kZXhPZihpdGVtKSA8IDApXHJcblx0XHRcdHNldC5wdXNoKGl0ZW0pO1xyXG5cdH0pO1xyXG59XHJcblxyXG5Nb2R1bGUucHJvdG90eXBlLnJld3JpdGVDaHVua0luUmVhc29ucyA9IGZ1bmN0aW9uKG9sZENodW5rLCBuZXdDaHVua3MpIHtcclxuXHR0aGlzLnJlYXNvbnMuZm9yRWFjaChmdW5jdGlvbihyKSB7XHJcblx0XHRpZighci5jaHVua3MpIHtcclxuXHRcdFx0aWYoci5tb2R1bGUuY2h1bmtzLmluZGV4T2Yob2xkQ2h1bmspIDwgMClcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdHIuY2h1bmtzID0gci5tb2R1bGUuY2h1bmtzO1xyXG5cdFx0fVxyXG5cdFx0ci5jaHVua3MgPSByLmNodW5rcy5yZWR1Y2UoZnVuY3Rpb24oYXJyLCBjKSB7XHJcblx0XHRcdGFkZFRvU2V0KGFyciwgYyAhPT0gb2xkQ2h1bmsgPyBbY10gOiBuZXdDaHVua3MpO1xyXG5cdFx0XHRyZXR1cm4gYXJyO1xyXG5cdFx0fSwgW10pO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuTW9kdWxlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcIk1vZHVsZVtcIiArICh0aGlzLmlkIHx8IHRoaXMuZGVidWdJZCkgKyBcIl1cIjtcclxufTtcclxuXHJcbk1vZHVsZS5wcm90b3R5cGUubmVlZFJlYnVpbGQgPSBmdW5jdGlvbiggLyogZmlsZVRpbWVzdGFtcHMsIGNvbnRleHRUaW1lc3RhbXBzICovICkge1xyXG5cdHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuTW9kdWxlLnByb3RvdHlwZS51cGRhdGVIYXNoID0gZnVuY3Rpb24oaGFzaCkge1xyXG5cdGhhc2gudXBkYXRlKHRoaXMuaWQgKyBcIlwiKTtcclxuXHREZXBlbmRlbmNpZXNCbG9jay5wcm90b3R5cGUudXBkYXRlSGFzaC5jYWxsKHRoaXMsIGhhc2gpO1xyXG59O1xyXG5cclxuTW9kdWxlLnByb3RvdHlwZS5pZGVudGlmaWVyID0gbnVsbDtcclxuTW9kdWxlLnByb3RvdHlwZS5yZWFkYWJsZUlkZW50aWZpZXIgPSBudWxsO1xyXG5Nb2R1bGUucHJvdG90eXBlLmJ1aWxkID0gbnVsbDtcclxuTW9kdWxlLnByb3RvdHlwZS5zb3VyY2UgPSBudWxsO1xyXG5Nb2R1bGUucHJvdG90eXBlLnNpemUgPSBudWxsO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL01vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIERlcGVuZGVuY2llc0Jsb2NrVmFyaWFibGUgPSByZXF1aXJlKFwiLi9EZXBlbmRlbmNpZXNCbG9ja1ZhcmlhYmxlXCIpO1xyXG5cclxuZnVuY3Rpb24gRGVwZW5kZW5jaWVzQmxvY2soKSB7XHJcblx0dGhpcy5kZXBlbmRlbmNpZXMgPSBbXTtcclxuXHR0aGlzLmJsb2NrcyA9IFtdO1xyXG5cdHRoaXMudmFyaWFibGVzID0gW107XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBEZXBlbmRlbmNpZXNCbG9jaztcclxuXHJcbkRlcGVuZGVuY2llc0Jsb2NrLnByb3RvdHlwZS5hZGRCbG9jayA9IGZ1bmN0aW9uKGJsb2NrKSB7XHJcblx0dGhpcy5ibG9ja3MucHVzaChibG9jayk7XHJcblx0YmxvY2sucGFyZW50ID0gdGhpcztcclxufTtcclxuXHJcbkRlcGVuZGVuY2llc0Jsb2NrLnByb3RvdHlwZS5hZGRWYXJpYWJsZSA9IGZ1bmN0aW9uKG5hbWUsIGV4cHJlc3Npb24sIGRlcGVuZGVuY2llcykge1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnZhcmlhYmxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIHYgPSB0aGlzLnZhcmlhYmxlc1tpXTtcclxuXHRcdGlmKHYubmFtZSA9PT0gbmFtZSAmJiB2LmV4cHJlc3Npb24gPT09IGV4cHJlc3Npb24pIHJldHVybjtcclxuXHR9XHJcblx0dGhpcy52YXJpYWJsZXMucHVzaChuZXcgRGVwZW5kZW5jaWVzQmxvY2tWYXJpYWJsZShuYW1lLCBleHByZXNzaW9uLCBkZXBlbmRlbmNpZXMpKTtcclxufTtcclxuXHJcbkRlcGVuZGVuY2llc0Jsb2NrLnByb3RvdHlwZS5hZGREZXBlbmRlbmN5ID0gZnVuY3Rpb24oZGVwZW5kZW5jeSkge1xyXG5cdHRoaXMuZGVwZW5kZW5jaWVzLnB1c2goZGVwZW5kZW5jeSk7XHJcbn07XHJcblxyXG5EZXBlbmRlbmNpZXNCbG9jay5wcm90b3R5cGUudXBkYXRlSGFzaCA9IGZ1bmN0aW9uKGhhc2gpIHtcclxuXHR0aGlzLmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdGQudXBkYXRlSGFzaChoYXNoKTtcclxuXHR9KTtcclxuXHR0aGlzLmJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uKGIpIHtcclxuXHRcdGIudXBkYXRlSGFzaChoYXNoKTtcclxuXHR9KTtcclxuXHR0aGlzLnZhcmlhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcclxuXHRcdHYudXBkYXRlSGFzaChoYXNoKTtcclxuXHR9KTtcclxufTtcclxuXHJcbkRlcGVuZGVuY2llc0Jsb2NrLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKSB7XHJcblx0ZnVuY3Rpb24gZGlzY29ubmVjdChpKSB7XHJcblx0XHRpLmRpc2Nvbm5lY3QoKTtcclxuXHR9XHJcblx0dGhpcy5kZXBlbmRlbmNpZXMuZm9yRWFjaChkaXNjb25uZWN0KTtcclxuXHR0aGlzLmJsb2Nrcy5mb3JFYWNoKGRpc2Nvbm5lY3QpO1xyXG5cdHRoaXMudmFyaWFibGVzLmZvckVhY2goZGlzY29ubmVjdCk7XHJcbn07XHJcblxyXG5EZXBlbmRlbmNpZXNCbG9jay5wcm90b3R5cGUuaGFzRGVwZW5kZW5jaWVzID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuZGVwZW5kZW5jaWVzLmxlbmd0aCA+IDAgfHxcclxuXHRcdHRoaXMuYmxvY2tzLmNvbmNhdCh0aGlzLnZhcmlhYmxlcykuc29tZShmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRcdHJldHVybiBpdGVtLmhhc0RlcGVuZGVuY2llcygpO1xyXG5cdFx0fSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvRGVwZW5kZW5jaWVzQmxvY2suanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBSZXBsYWNlU291cmNlID0gcmVxdWlyZShcIndlYnBhY2stY29yZS9saWIvUmVwbGFjZVNvdXJjZVwiKTtcclxudmFyIFJhd1NvdXJjZSA9IHJlcXVpcmUoXCJ3ZWJwYWNrLWNvcmUvbGliL1Jhd1NvdXJjZVwiKTtcclxuXHJcbmZ1bmN0aW9uIERlcGVuZGVuY2llc0Jsb2NrVmFyaWFibGUobmFtZSwgZXhwcmVzc2lvbiwgZGVwZW5kZW5jaWVzKSB7XHJcblx0dGhpcy5uYW1lID0gbmFtZTtcclxuXHR0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xyXG5cdHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzIHx8IFtdO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gRGVwZW5kZW5jaWVzQmxvY2tWYXJpYWJsZTtcclxuXHJcbkRlcGVuZGVuY2llc0Jsb2NrVmFyaWFibGUucHJvdG90eXBlLnVwZGF0ZUhhc2ggPSBmdW5jdGlvbihoYXNoKSB7XHJcblx0aGFzaC51cGRhdGUodGhpcy5uYW1lKTtcclxuXHRoYXNoLnVwZGF0ZSh0aGlzLmV4cHJlc3Npb24pO1xyXG5cdHRoaXMuZGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24oZCkge1xyXG5cdFx0ZC51cGRhdGVIYXNoKGhhc2gpO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuRGVwZW5kZW5jaWVzQmxvY2tWYXJpYWJsZS5wcm90b3R5cGUuZXhwcmVzc2lvblNvdXJjZSA9IGZ1bmN0aW9uKGRlcGVuZGVuY3lUZW1wbGF0ZXMsIG91dHB1dE9wdGlvbnMsIHJlcXVlc3RTaG9ydGVuZXIpIHtcclxuXHR2YXIgc291cmNlID0gbmV3IFJlcGxhY2VTb3VyY2UobmV3IFJhd1NvdXJjZSh0aGlzLmV4cHJlc3Npb24pKTtcclxuXHR0aGlzLmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uKGRlcCkge1xyXG5cdFx0dmFyIHRlbXBsYXRlID0gZGVwZW5kZW5jeVRlbXBsYXRlcy5nZXQoZGVwLmNvbnN0cnVjdG9yKTtcclxuXHRcdGlmKCF0ZW1wbGF0ZSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gdGVtcGxhdGUgZm9yIGRlcGVuZGVuY3k6IFwiICsgZGVwLmNvbnN0cnVjdG9yLm5hbWUpO1xyXG5cdFx0dGVtcGxhdGUuYXBwbHkoZGVwLCBzb3VyY2UsIG91dHB1dE9wdGlvbnMsIHJlcXVlc3RTaG9ydGVuZXIsIGRlcGVuZGVuY3lUZW1wbGF0ZXMpO1xyXG5cdH0pO1xyXG5cdHJldHVybiBzb3VyY2U7XHJcbn07XHJcblxyXG5EZXBlbmRlbmNpZXNCbG9ja1ZhcmlhYmxlLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5kZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRkLmRpc2Nvbm5lY3QoKTtcclxuXHR9KTtcclxufTtcclxuXHJcbkRlcGVuZGVuY2llc0Jsb2NrVmFyaWFibGUucHJvdG90eXBlLmhhc0RlcGVuZGVuY2llcyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLmRlcGVuZGVuY2llcy5sZW5ndGggPiAwO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL0RlcGVuZGVuY2llc0Jsb2NrVmFyaWFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBTb3VyY2UgPSByZXF1aXJlKFwiLi9Tb3VyY2VcIik7XHJcbnZhciBTb3VyY2VOb2RlID0gcmVxdWlyZShcInNvdXJjZS1tYXBcIikuU291cmNlTm9kZTtcclxudmFyIFNvdXJjZUxpc3RNYXAgPSByZXF1aXJlKFwic291cmNlLWxpc3QtbWFwXCIpLlNvdXJjZUxpc3RNYXA7XHJcbnZhciBmcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCA9IHJlcXVpcmUoXCJzb3VyY2UtbGlzdC1tYXBcIikuZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXA7XHJcbnZhciBTb3VyY2VNYXBDb25zdW1lciA9IHJlcXVpcmUoXCJzb3VyY2UtbWFwXCIpLlNvdXJjZU1hcENvbnN1bWVyO1xyXG5cclxuZnVuY3Rpb24gUmVwbGFjZVNvdXJjZShzb3VyY2UsIG5hbWUpIHtcclxuXHRTb3VyY2UuY2FsbCh0aGlzKTtcclxuXHR0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XHJcblx0dGhpcy5fbmFtZSA9IG5hbWU7XHJcblx0dGhpcy5yZXBsYWNlbWVudHMgPSBbXTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlcGxhY2VTb3VyY2U7XHJcblxyXG5SZXBsYWNlU291cmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlLnByb3RvdHlwZSk7XHJcblJlcGxhY2VTb3VyY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVwbGFjZVNvdXJjZTtcclxuXHJcblJlcGxhY2VTb3VyY2UucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kLCBuZXdWYWx1ZSkge1xyXG5cdHRoaXMucmVwbGFjZW1lbnRzLnB1c2goW3N0YXJ0LCBlbmQsIG5ld1ZhbHVlXSk7XHJcbn07XHJcblxyXG5SZXBsYWNlU291cmNlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihwb3MsIG5ld1ZhbHVlKSB7XHJcblx0dGhpcy5yZXBsYWNlbWVudHMucHVzaChbcG9zLCBwb3MtMSwgbmV3VmFsdWVdKTtcclxufTtcclxuXHJcblJlcGxhY2VTb3VyY2UucHJvdG90eXBlLnNvdXJjZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gdGhpcy5fcmVwbGFjZVN0cmluZyh0aGlzLl9zb3VyY2Uuc291cmNlKCkpO1xyXG59O1xyXG5cclxuUmVwbGFjZVNvdXJjZS5wcm90b3R5cGUuX3NvcnRSZXBsYWNlbWVudHMgPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLnJlcGxhY2VtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0sIGlkeCkge1xyXG5cdFx0aXRlbVszXSA9IGlkeDtcclxuXHR9KTtcclxuXHR0aGlzLnJlcGxhY2VtZW50cy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdHZhciBkaWZmID0gYlsxXSAtIGFbMV07XHJcblx0XHRpZihkaWZmICE9PSAwKVxyXG5cdFx0XHRyZXR1cm4gZGlmZjtcclxuXHRcdHJldHVybiBiWzNdIC0gYVszXTtcclxuXHR9KTtcclxuXHJcbn07XHJcblxyXG5SZXBsYWNlU291cmNlLnByb3RvdHlwZS5fcmVwbGFjZVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xyXG5cdHRoaXMuX3NvcnRSZXBsYWNlbWVudHMoKTtcclxuXHR2YXIgcmVzdWx0ID0gW3N0cl07XHJcblx0dGhpcy5yZXBsYWNlbWVudHMuZm9yRWFjaChmdW5jdGlvbihyZXBsKSB7XHJcblx0XHR2YXIgcmVtU291cmNlID0gcmVzdWx0LnBvcCgpO1xyXG5cdFx0dmFyIHNwbGl0dGVkMSA9IHRoaXMuX3NwbGl0U3RyaW5nKHJlbVNvdXJjZSwgTWF0aC5mbG9vcihyZXBsWzFdKzEpKTtcclxuXHRcdHZhciBzcGxpdHRlZDIgPSB0aGlzLl9zcGxpdFN0cmluZyhzcGxpdHRlZDFbMF0sIE1hdGguZmxvb3IocmVwbFswXSkpO1xyXG5cdFx0cmVzdWx0LnB1c2goc3BsaXR0ZWQxWzFdLCByZXBsWzJdLCBzcGxpdHRlZDJbMF0pO1xyXG5cdH0sIHRoaXMpO1xyXG5cdHJlc3VsdCA9IHJlc3VsdC5yZXZlcnNlKCk7XHJcblx0cmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xyXG59O1xyXG5cclxucmVxdWlyZShcIi4vU291cmNlQW5kTWFwTWl4aW5cIikoUmVwbGFjZVNvdXJjZS5wcm90b3R5cGUpO1xyXG5cclxuUmVwbGFjZVNvdXJjZS5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHR0aGlzLl9zb3J0UmVwbGFjZW1lbnRzKCk7XHJcblx0dmFyIHJlc3VsdCA9IFt0aGlzLl9zb3VyY2Uubm9kZShvcHRpb25zKV07XHJcblx0dGhpcy5yZXBsYWNlbWVudHMuZm9yRWFjaChmdW5jdGlvbihyZXBsKSB7XHJcblx0XHR2YXIgcmVtU291cmNlID0gcmVzdWx0LnBvcCgpO1xyXG5cdFx0dmFyIHNwbGl0dGVkMSA9IHRoaXMuX3NwbGl0U291cmNlTm9kZShyZW1Tb3VyY2UsIE1hdGguZmxvb3IocmVwbFsxXSsxKSk7XHJcblx0XHRpZihBcnJheS5pc0FycmF5KHNwbGl0dGVkMSkpIHtcclxuXHRcdFx0dmFyIHNwbGl0dGVkMiA9IHRoaXMuX3NwbGl0U291cmNlTm9kZShzcGxpdHRlZDFbMF0sIE1hdGguZmxvb3IocmVwbFswXSkpO1xyXG5cdFx0XHRpZihBcnJheS5pc0FycmF5KHNwbGl0dGVkMikpIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChzcGxpdHRlZDFbMV0sIHRoaXMuX3JlcGxhY2VtZW50VG9Tb3VyY2VOb2RlKHNwbGl0dGVkMlsxXSwgcmVwbFsyXSksIHNwbGl0dGVkMlswXSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goc3BsaXR0ZWQxWzFdLCB0aGlzLl9yZXBsYWNlbWVudFRvU291cmNlTm9kZShzcGxpdHRlZDFbMV0sIHJlcGxbMl0pLCBzcGxpdHRlZDFbMF0pO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgc3BsaXR0ZWQyID0gdGhpcy5fc3BsaXRTb3VyY2VOb2RlKHJlbVNvdXJjZSwgTWF0aC5mbG9vcihyZXBsWzBdKSk7XHJcblx0XHRcdGlmKEFycmF5LmlzQXJyYXkoc3BsaXR0ZWQyKSkge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKHRoaXMuX3JlcGxhY2VtZW50VG9Tb3VyY2VOb2RlKHNwbGl0dGVkMlsxXSwgcmVwbFsyXSksIHNwbGl0dGVkMlswXSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2gocmVwbFsyXSwgcmVtU291cmNlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sIHRoaXMpO1xyXG5cdHJlc3VsdCA9IHJlc3VsdC5yZXZlcnNlKCk7XHJcblx0cmV0dXJuIG5ldyBTb3VyY2VOb2RlKG51bGwsIG51bGwsIG51bGwsIHJlc3VsdCk7XHJcbn07XHJcblxyXG5SZXBsYWNlU291cmNlLnByb3RvdHlwZS5saXN0TWFwID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdHZhciBtYXAgPSB0aGlzLl9zb3VyY2UubGlzdE1hcChvcHRpb25zKTtcclxuXHRpZihtYXAuY2hpbGRyZW4ubGVuZ3RoICE9PSAxKSB7XHJcblx0XHR2YXIgY29kZSA9IG1hcC50b1N0cmluZygpO1xyXG5cdFx0Y29kZSA9IHRoaXMuX3JlcGxhY2VTdHJpbmcoY29kZSkuc3BsaXQoXCJcXG5cIik7XHJcblx0XHR2YXIgY3VycmVudEluZGV4ID0gMDtcclxuXHRcdG1hcC5tYXBHZW5lcmF0ZWRDb2RlKGZ1bmN0aW9uKHN0cikge1xyXG5cdFx0XHR2YXIgaWR4ID0gLTE7XHJcblx0XHRcdHZhciBjb3VudCA9IC0xO1xyXG5cdFx0XHRkbyB7XHJcblx0XHRcdFx0Y291bnQrKztcclxuXHRcdFx0XHRpZHggPSBzdHIuaW5kZXhPZihcIlxcblwiLCBpZHggKyAxKTtcclxuXHRcdFx0fSB3aGlsZShpZHggPj0gMCk7XHJcblx0XHRcdGlmKCFjb3VudCkgcmV0dXJuIFwiXCI7XHJcblx0XHRcdHZhciByZXN1bHQgPSBjb2RlLnNsaWNlKGN1cnJlbnRJbmRleCwgY3VycmVudEluZGV4ICsgY291bnQpLmpvaW4oXCJcXG5cIikgKyBcIlxcblwiO1xyXG5cdFx0XHRjdXJyZW50SW5kZXggKz0gY291bnQ7XHJcblx0XHRcdHJldHVybiByZXN1bHQ7XHJcblx0XHR9KTtcclxuXHRcdG1hcC5hZGQoY29kZS5zbGljZShjdXJyZW50SW5kZXgpLmpvaW4oXCJcXG5cIikpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRtYXAubWFwR2VuZXJhdGVkQ29kZSh0aGlzLl9yZXBsYWNlU3RyaW5nLmJpbmQodGhpcykpO1xyXG5cdH1cclxuXHRyZXR1cm4gbWFwO1xyXG59O1xyXG5cclxuUmVwbGFjZVNvdXJjZS5wcm90b3R5cGUuX3JlcGxhY2VtZW50VG9Tb3VyY2VOb2RlID0gZnVuY3Rpb24ob2xkTm9kZSwgbmV3U3RyaW5nKSB7XHJcblx0dmFyIG1hcCA9IG9sZE5vZGUudG9TdHJpbmdXaXRoU291cmNlTWFwKHsgZmlsZTogXCI/XCIgfSkubWFwO1xyXG5cdHZhciBvcmlnaW5hbCA9IG5ldyBTb3VyY2VNYXBDb25zdW1lcihtYXAudG9KU09OKCkpLm9yaWdpbmFsUG9zaXRpb25Gb3IoeyBsaW5lOiAxLCBjb2x1bW46IDAgfSk7XHJcblx0aWYob3JpZ2luYWwpIHtcclxuXHRcdHJldHVybiBuZXcgU291cmNlTm9kZShvcmlnaW5hbC5saW5lLCBvcmlnaW5hbC5jb2x1bW4sIG9yaWdpbmFsLnNvdXJjZSwgbmV3U3RyaW5nKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIG5ld1N0cmluZztcclxuXHR9XHJcbn07XHJcblxyXG5SZXBsYWNlU291cmNlLnByb3RvdHlwZS5fc3BsaXRTb3VyY2VOb2RlID0gZnVuY3Rpb24obm9kZSwgcG9zaXRpb24pIHtcclxuXHRpZih0eXBlb2Ygbm9kZSA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0aWYobm9kZS5sZW5ndGggPD0gcG9zaXRpb24pIHJldHVybiBwb3NpdGlvbiAtIG5vZGUubGVuZ3RoO1xyXG5cdFx0cmV0dXJuIFtub2RlLnN1YnN0cigwLCBwb3NpdGlvbiksIG5vZGUuc3Vic3RyKHBvc2l0aW9uKV07XHJcblx0fSBlbHNlIHtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHBvc2l0aW9uID0gdGhpcy5fc3BsaXRTb3VyY2VOb2RlKG5vZGUuY2hpbGRyZW5baV0sIHBvc2l0aW9uKTtcclxuXHRcdFx0aWYoQXJyYXkuaXNBcnJheShwb3NpdGlvbikpIHtcclxuXHRcdFx0XHR2YXIgbGVmdE5vZGUgPSBuZXcgU291cmNlTm9kZShcclxuXHRcdFx0XHRcdG5vZGUubGluZSxcclxuXHRcdFx0XHRcdG5vZGUuY29sdW1uLFxyXG5cdFx0XHRcdFx0bm9kZS5zb3VyY2UsXHJcblx0XHRcdFx0XHRub2RlLmNoaWxkcmVuLnNsaWNlKDAsIGkpLmNvbmNhdChbcG9zaXRpb25bMF1dKSxcclxuXHRcdFx0XHRcdG5vZGUubmFtZVxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdFx0dmFyIHJpZ2h0Tm9kZSA9IG5ldyBTb3VyY2VOb2RlKFxyXG5cdFx0XHRcdFx0bm9kZS5saW5lLFxyXG5cdFx0XHRcdFx0bm9kZS5jb2x1bW4sXHJcblx0XHRcdFx0XHRub2RlLnNvdXJjZSxcclxuXHRcdFx0XHRcdFtwb3NpdGlvblsxXV0uY29uY2F0KG5vZGUuY2hpbGRyZW4uc2xpY2UoaSsxKSksXHJcblx0XHRcdFx0XHRub2RlLm5hbWVcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHRcdGxlZnROb2RlLnNvdXJjZUNvbnRlbnRzID0gbm9kZS5zb3VyY2VDb250ZW50cztcclxuXHRcdFx0XHRyZXR1cm4gW2xlZnROb2RlLCByaWdodE5vZGVdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcG9zaXRpb247XHJcblx0fVxyXG59O1xyXG5cclxuUmVwbGFjZVNvdXJjZS5wcm90b3R5cGUuX3NwbGl0U3RyaW5nID0gZnVuY3Rpb24oc3RyLCBwb3NpdGlvbikge1xyXG5cdHJldHVybiBbc3RyLnN1YnN0cigwLCBwb3NpdGlvbiksIHN0ci5zdWJzdHIocG9zaXRpb24pXTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spLWNvcmUvbGliL1JlcGxhY2VTb3VyY2UuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBTb3VyY2VOb2RlID0gcmVxdWlyZShcInNvdXJjZS1tYXBcIikuU291cmNlTm9kZTtcclxudmFyIFNvdXJjZU1hcENvbnN1bWVyID0gcmVxdWlyZShcInNvdXJjZS1tYXBcIikuU291cmNlTWFwQ29uc3VtZXI7XHJcblxyXG5mdW5jdGlvbiBTb3VyY2UoKSB7fVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTb3VyY2U7XHJcblxyXG5Tb3VyY2UucHJvdG90eXBlLnNvdXJjZSA9IG51bGw7XHJcblxyXG5Tb3VyY2UucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5zb3VyY2UoKS5sZW5ndGg7XHJcbn07XHJcblxyXG5Tb3VyY2UucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbnVsbDtcclxufTtcclxuXHJcblNvdXJjZS5wcm90b3R5cGUuc291cmNlQW5kTWFwID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdHJldHVybiB7XHJcblx0XHRzb3VyY2U6IHRoaXMuc291cmNlKCksXHJcblx0XHRtYXA6IHRoaXMubWFwKClcclxuXHR9O1xyXG59O1xyXG5cclxuU291cmNlLnByb3RvdHlwZS5ub2RlID0gbnVsbDtcclxuXHJcblNvdXJjZS5wcm90b3R5cGUubGlzdE5vZGUgPSBudWxsO1xyXG5cclxuU291cmNlLnByb3RvdHlwZS51cGRhdGVIYXNoID0gZnVuY3Rpb24oaGFzaCkge1xyXG5cdHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZSgpO1xyXG5cdGhhc2gudXBkYXRlKHNvdXJjZSB8fCBcIlwiKTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spLWNvcmUvbGliL1NvdXJjZS5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAqIENvcHlyaWdodCAyMDA5LTIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLnR4dCBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAvc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwL3NvdXJjZS1tYXAtY29uc3VtZXInKS5Tb3VyY2VNYXBDb25zdW1lcjtcbmV4cG9ydHMuU291cmNlTm9kZSA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC9zb3VyY2Utbm9kZScpLlNvdXJjZU5vZGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjayktY29yZS9+L3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuICB2YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xuICB2YXIgTWFwcGluZ0xpc3QgPSByZXF1aXJlKCcuL21hcHBpbmctbGlzdCcpLk1hcHBpbmdMaXN0O1xuXG4gIC8qKlxuICAgKiBBbiBpbnN0YW5jZSBvZiB0aGUgU291cmNlTWFwR2VuZXJhdG9yIHJlcHJlc2VudHMgYSBzb3VyY2UgbWFwIHdoaWNoIGlzXG4gICAqIGJlaW5nIGJ1aWx0IGluY3JlbWVudGFsbHkuIFlvdSBtYXkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAqIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBmaWxlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqICAgLSBzb3VyY2VSb290OiBBIHJvb3QgZm9yIGFsbCByZWxhdGl2ZSBVUkxzIGluIHRoaXMgc291cmNlIG1hcC5cbiAgICovXG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncykge1xuICAgIGlmICghYUFyZ3MpIHtcbiAgICAgIGFBcmdzID0ge307XG4gICAgfVxuICAgIHRoaXMuX2ZpbGUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2ZpbGUnLCBudWxsKTtcbiAgICB0aGlzLl9zb3VyY2VSb290ID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2VSb290JywgbnVsbCk7XG4gICAgdGhpcy5fc2tpcFZhbGlkYXRpb24gPSB1dGlsLmdldEFyZyhhQXJncywgJ3NraXBWYWxpZGF0aW9uJywgZmFsc2UpO1xuICAgIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgICB0aGlzLl9uYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHRoaXMuX21hcHBpbmdzID0gbmV3IE1hcHBpbmdMaXN0KCk7XG4gICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbiAgfVxuXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFNvdXJjZU1hcEdlbmVyYXRvciBiYXNlZCBvbiBhIFNvdXJjZU1hcENvbnN1bWVyXG4gICAqXG4gICAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcC5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5mcm9tU291cmNlTWFwID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIpIHtcbiAgICAgIHZhciBzb3VyY2VSb290ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZVJvb3Q7XG4gICAgICB2YXIgZ2VuZXJhdG9yID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICAgIGZpbGU6IGFTb3VyY2VNYXBDb25zdW1lci5maWxlLFxuICAgICAgICBzb3VyY2VSb290OiBzb3VyY2VSb290XG4gICAgICB9KTtcbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgICB2YXIgbmV3TWFwcGluZyA9IHtcbiAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgIGxpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5ld01hcHBpbmcuc291cmNlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBuZXdNYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV3TWFwcGluZy5vcmlnaW5hbCA9IHtcbiAgICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChtYXBwaW5nLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3TWFwcGluZy5uYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdlbmVyYXRvci5hZGRNYXBwaW5nKG5ld01hcHBpbmcpO1xuICAgICAgfSk7XG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBnZW5lcmF0b3Iuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIHNpbmdsZSBtYXBwaW5nIGZyb20gb3JpZ2luYWwgc291cmNlIGxpbmUgYW5kIGNvbHVtbiB0byB0aGUgZ2VuZXJhdGVkXG4gICAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBmb3IgdGhpcyBzb3VyY2UgbWFwIGJlaW5nIGNyZWF0ZWQuIFRoZSBtYXBwaW5nXG4gICAqIG9iamVjdCBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBnZW5lcmF0ZWQ6IEFuIG9iamVjdCB3aXRoIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAgICogICAtIG9yaWdpbmFsOiBBbiBvYmplY3Qgd2l0aCB0aGUgb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAgICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlIChyZWxhdGl2ZSB0byB0aGUgc291cmNlUm9vdCkuXG4gICAqICAgLSBuYW1lOiBBbiBvcHRpb25hbCBvcmlnaW5hbCB0b2tlbiBuYW1lIGZvciB0aGlzIG1hcHBpbmcuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFkZE1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hZGRNYXBwaW5nKGFBcmdzKSB7XG4gICAgICB2YXIgZ2VuZXJhdGVkID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdnZW5lcmF0ZWQnKTtcbiAgICAgIHZhciBvcmlnaW5hbCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnb3JpZ2luYWwnLCBudWxsKTtcbiAgICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScsIG51bGwpO1xuICAgICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhhQXJncywgJ25hbWUnLCBudWxsKTtcblxuICAgICAgaWYgKCF0aGlzLl9za2lwVmFsaWRhdGlvbikge1xuICAgICAgICB0aGlzLl92YWxpZGF0ZU1hcHBpbmcoZ2VuZXJhdGVkLCBvcmlnaW5hbCwgc291cmNlLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmICF0aGlzLl9zb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lICE9IG51bGwgJiYgIXRoaXMuX25hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICB0aGlzLl9uYW1lcy5hZGQobmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX21hcHBpbmdzLmFkZCh7XG4gICAgICAgIGdlbmVyYXRlZExpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IGdlbmVyYXRlZC5jb2x1bW4sXG4gICAgICAgIG9yaWdpbmFsTGluZTogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5saW5lLFxuICAgICAgICBvcmlnaW5hbENvbHVtbjogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5jb2x1bW4sXG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICBuYW1lOiBuYW1lXG4gICAgICB9KTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNvdXJjZSBjb250ZW50IGZvciBhIHNvdXJjZSBmaWxlLlxuICAgKi9cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhU291cmNlRmlsZTtcbiAgICAgIGlmICh0aGlzLl9zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLl9zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYVNvdXJjZUNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAvLyBBZGQgdGhlIHNvdXJjZSBjb250ZW50IHRvIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IF9zb3VyY2VzQ29udGVudHMgbWFwIGlmIHRoZSBwcm9wZXJ0eSBpcyBudWxsLlxuICAgICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICAvLyBSZW1vdmUgdGhlIHNvdXJjZSBmaWxlIGZyb20gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgICAvLyBJZiB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAgaXMgZW1wdHksIHNldCB0aGUgcHJvcGVydHkgdG8gbnVsbC5cbiAgICAgICAgZGVsZXRlIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldO1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fc291cmNlc0NvbnRlbnRzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgbWFwcGluZ3Mgb2YgYSBzdWItc291cmNlLW1hcCBmb3IgYSBzcGVjaWZpYyBzb3VyY2UgZmlsZSB0byB0aGVcbiAgICogc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQuIEVhY2ggbWFwcGluZyB0byB0aGUgc3VwcGxpZWQgc291cmNlIGZpbGUgaXNcbiAgICogcmV3cml0dGVuIHVzaW5nIHRoZSBzdXBwbGllZCBzb3VyY2UgbWFwLiBOb3RlOiBUaGUgcmVzb2x1dGlvbiBmb3IgdGhlXG4gICAqIHJlc3VsdGluZyBtYXBwaW5ncyBpcyB0aGUgbWluaW1pdW0gb2YgdGhpcyBtYXAgYW5kIHRoZSBzdXBwbGllZCBtYXAuXG4gICAqXG4gICAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZC5cbiAgICogQHBhcmFtIGFTb3VyY2VGaWxlIE9wdGlvbmFsLiBUaGUgZmlsZW5hbWUgb2YgdGhlIHNvdXJjZSBmaWxlLlxuICAgKiAgICAgICAgSWYgb21pdHRlZCwgU291cmNlTWFwQ29uc3VtZXIncyBmaWxlIHByb3BlcnR5IHdpbGwgYmUgdXNlZC5cbiAgICogQHBhcmFtIGFTb3VyY2VNYXBQYXRoIE9wdGlvbmFsLiBUaGUgZGlybmFtZSBvZiB0aGUgcGF0aCB0byB0aGUgc291cmNlIG1hcFxuICAgKiAgICAgICAgdG8gYmUgYXBwbGllZC4gSWYgcmVsYXRpdmUsIGl0IGlzIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBDb25zdW1lci5cbiAgICogICAgICAgIFRoaXMgcGFyYW1ldGVyIGlzIG5lZWRlZCB3aGVuIHRoZSB0d28gc291cmNlIG1hcHMgYXJlbid0IGluIHRoZSBzYW1lXG4gICAqICAgICAgICBkaXJlY3RvcnksIGFuZCB0aGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkIGNvbnRhaW5zIHJlbGF0aXZlIHNvdXJjZVxuICAgKiAgICAgICAgcGF0aHMuIElmIHNvLCB0aG9zZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbmVlZCB0byBiZSByZXdyaXR0ZW5cbiAgICogICAgICAgIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYXBwbHlTb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyLCBhU291cmNlRmlsZSwgYVNvdXJjZU1hcFBhdGgpIHtcbiAgICAgIHZhciBzb3VyY2VGaWxlID0gYVNvdXJjZUZpbGU7XG4gICAgICAvLyBJZiBhU291cmNlRmlsZSBpcyBvbWl0dGVkLCB3ZSB3aWxsIHVzZSB0aGUgZmlsZSBwcm9wZXJ0eSBvZiB0aGUgU291cmNlTWFwXG4gICAgICBpZiAoYVNvdXJjZUZpbGUgPT0gbnVsbCkge1xuICAgICAgICBpZiAoYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwIHJlcXVpcmVzIGVpdGhlciBhbiBleHBsaWNpdCBzb3VyY2UgZmlsZSwgJyArXG4gICAgICAgICAgICAnb3IgdGhlIHNvdXJjZSBtYXBcXCdzIFwiZmlsZVwiIHByb3BlcnR5LiBCb3RoIHdlcmUgb21pdHRlZC4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2VGaWxlID0gYVNvdXJjZU1hcENvbnN1bWVyLmZpbGU7XG4gICAgICB9XG4gICAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgICAvLyBNYWtlIFwic291cmNlRmlsZVwiIHJlbGF0aXZlIGlmIGFuIGFic29sdXRlIFVybCBpcyBwYXNzZWQuXG4gICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgfVxuICAgICAgLy8gQXBwbHlpbmcgdGhlIFNvdXJjZU1hcCBjYW4gYWRkIGFuZCByZW1vdmUgaXRlbXMgZnJvbSB0aGUgc291cmNlcyBhbmRcbiAgICAgIC8vIHRoZSBuYW1lcyBhcnJheS5cbiAgICAgIHZhciBuZXdTb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgICB2YXIgbmV3TmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICAgICAgLy8gRmluZCBtYXBwaW5ncyBmb3IgdGhlIFwic291cmNlRmlsZVwiXG4gICAgICB0aGlzLl9tYXBwaW5ncy51bnNvcnRlZEZvckVhY2goZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBzb3VyY2VGaWxlICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDaGVjayBpZiBpdCBjYW4gYmUgbWFwcGVkIGJ5IHRoZSBzb3VyY2UgbWFwLCB0aGVuIHVwZGF0ZSB0aGUgbWFwcGluZy5cbiAgICAgICAgICB2YXIgb3JpZ2luYWwgPSBhU291cmNlTWFwQ29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChvcmlnaW5hbC5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29weSBtYXBwaW5nXG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgICAgICAgIGlmIChhU291cmNlTWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG1hcHBpbmcubmFtZSA9IG9yaWdpbmFsLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgIW5ld1NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgICBuZXdTb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICAgIGlmIChuYW1lICE9IG51bGwgJiYgIW5ld05hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICAgIG5ld05hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHRoaXMuX3NvdXJjZXMgPSBuZXdTb3VyY2VzO1xuICAgICAgdGhpcy5fbmFtZXMgPSBuZXdOYW1lcztcblxuICAgICAgLy8gQ29weSBzb3VyY2VzQ29udGVudHMgb2YgYXBwbGllZCBtYXAuXG4gICAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEEgbWFwcGluZyBjYW4gaGF2ZSBvbmUgb2YgdGhlIHRocmVlIGxldmVscyBvZiBkYXRhOlxuICAgKlxuICAgKiAgIDEuIEp1c3QgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbi5cbiAgICogICAyLiBUaGUgR2VuZXJhdGVkIHBvc2l0aW9uLCBvcmlnaW5hbCBwb3NpdGlvbiwgYW5kIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAzLiBHZW5lcmF0ZWQgYW5kIG9yaWdpbmFsIHBvc2l0aW9uLCBvcmlnaW5hbCBzb3VyY2UsIGFzIHdlbGwgYXMgYSBuYW1lXG4gICAqICAgICAgdG9rZW4uXG4gICAqXG4gICAqIFRvIG1haW50YWluIGNvbnNpc3RlbmN5LCB3ZSB2YWxpZGF0ZSB0aGF0IGFueSBuZXcgbWFwcGluZyBiZWluZyBhZGRlZCBmYWxsc1xuICAgKiBpbiB0byBvbmUgb2YgdGhlc2UgY2F0ZWdvcmllcy5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlTWFwcGluZyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3ZhbGlkYXRlTWFwcGluZyhhR2VuZXJhdGVkLCBhT3JpZ2luYWwsIGFTb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhTmFtZSkge1xuICAgICAgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAgICYmICFhT3JpZ2luYWwgJiYgIWFTb3VyY2UgJiYgIWFOYW1lKSB7XG4gICAgICAgIC8vIENhc2UgMS5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICAgICAgICAmJiBhT3JpZ2luYWwgJiYgJ2xpbmUnIGluIGFPcmlnaW5hbCAmJiAnY29sdW1uJyBpbiBhT3JpZ2luYWxcbiAgICAgICAgICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICAgJiYgYU9yaWdpbmFsLmxpbmUgPiAwICYmIGFPcmlnaW5hbC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICAgJiYgYVNvdXJjZSkge1xuICAgICAgICAvLyBDYXNlcyAyIGFuZCAzLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1hcHBpbmc6ICcgKyBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgZ2VuZXJhdGVkOiBhR2VuZXJhdGVkLFxuICAgICAgICAgIHNvdXJjZTogYVNvdXJjZSxcbiAgICAgICAgICBvcmlnaW5hbDogYU9yaWdpbmFsLFxuICAgICAgICAgIG5hbWU6IGFOYW1lXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgdGhlIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIHRvIHRoZSBzdHJlYW0gb2YgYmFzZSA2NCBWTFFzXG4gICAqIHNwZWNpZmllZCBieSB0aGUgc291cmNlIG1hcCBmb3JtYXQuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9zZXJpYWxpemVNYXBwaW5ncyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NlcmlhbGl6ZU1hcHBpbmdzKCkge1xuICAgICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZExpbmUgPSAxO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgIHZhciBtYXBwaW5nO1xuXG4gICAgICB2YXIgbWFwcGluZ3MgPSB0aGlzLl9tYXBwaW5ncy50b0FycmF5KCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgbWFwcGluZyA9IG1hcHBpbmdzW2ldO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICAgICAgICB3aGlsZSAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyc7XG4gICAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBpZiAoIXV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZywgbWFwcGluZ3NbaSAtIDFdKSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSAnLCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c0dlbmVyYXRlZENvbHVtbik7XG4gICAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQgKz0gYmFzZTY0VkxRLmVuY29kZSh0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c1NvdXJjZSk7XG4gICAgICAgICAgcHJldmlvdXNTb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2YobWFwcGluZy5zb3VyY2UpO1xuXG4gICAgICAgICAgLy8gbGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkIGluIFNvdXJjZU1hcCBzcGVjIHZlcnNpb24gM1xuICAgICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbExpbmUpO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmUgLSAxO1xuXG4gICAgICAgICAgcmVzdWx0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbENvbHVtbik7XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBiYXNlNjRWTFEuZW5jb2RlKHRoaXMuX25hbWVzLmluZGV4T2YobWFwcGluZy5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c05hbWUpO1xuICAgICAgICAgICAgcHJldmlvdXNOYW1lID0gdGhpcy5fbmFtZXMuaW5kZXhPZihtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudCA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoYVNvdXJjZXMsIGFTb3VyY2VSb290KSB7XG4gICAgICByZXR1cm4gYVNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYVNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUoYVNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleSA9IHV0aWwudG9TZXRTdHJpbmcoc291cmNlKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9zb3VyY2VzQ29udGVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5KVxuICAgICAgICAgID8gdGhpcy5fc291cmNlc0NvbnRlbnRzW2tleV1cbiAgICAgICAgICA6IG51bGw7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBFeHRlcm5hbGl6ZSB0aGUgc291cmNlIG1hcC5cbiAgICovXG4gIFNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9KU09OID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9KU09OKCkge1xuICAgICAgdmFyIG1hcCA9IHtcbiAgICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcbiAgICAgICAgc291cmNlczogdGhpcy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICAgIG5hbWVzOiB0aGlzLl9uYW1lcy50b0FycmF5KCksXG4gICAgICAgIG1hcHBpbmdzOiB0aGlzLl9zZXJpYWxpemVNYXBwaW5ncygpXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuX2ZpbGUgIT0gbnVsbCkge1xuICAgICAgICBtYXAuZmlsZSA9IHRoaXMuX2ZpbGU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIG1hcC5zb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgbWFwLnNvdXJjZXNDb250ZW50ID0gdGhpcy5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChtYXAuc291cmNlcywgbWFwLnNvdXJjZVJvb3QpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlciB0aGUgc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQgdG8gYSBzdHJpbmcuXG4gICAqL1xuICBTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSk7XG4gICAgfTtcblxuICBleHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IFNvdXJjZU1hcEdlbmVyYXRvcjtcblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjayktY29yZS9+L3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvc291cmNlLW1hcC1nZW5lcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKlxuICogQmFzZWQgb24gdGhlIEJhc2UgNjQgVkxRIGltcGxlbWVudGF0aW9uIGluIENsb3N1cmUgQ29tcGlsZXI6XG4gKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nsb3N1cmUtY29tcGlsZXIvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvY29tL2dvb2dsZS9kZWJ1Z2dpbmcvc291cmNlbWFwL0Jhc2U2NFZMUS5qYXZhXG4gKlxuICogQ29weXJpZ2h0IDIwMTEgVGhlIENsb3N1cmUgQ29tcGlsZXIgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gKiAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICogICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkXG4gKiAgICB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWRcbiAqICAgIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuICogREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gKiBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgdmFyIGJhc2U2NCA9IHJlcXVpcmUoJy4vYmFzZTY0Jyk7XG5cbiAgLy8gQSBzaW5nbGUgYmFzZSA2NCBkaWdpdCBjYW4gY29udGFpbiA2IGJpdHMgb2YgZGF0YS4gRm9yIHRoZSBiYXNlIDY0IHZhcmlhYmxlXG4gIC8vIGxlbmd0aCBxdWFudGl0aWVzIHdlIHVzZSBpbiB0aGUgc291cmNlIG1hcCBzcGVjLCB0aGUgZmlyc3QgYml0IGlzIHRoZSBzaWduLFxuICAvLyB0aGUgbmV4dCBmb3VyIGJpdHMgYXJlIHRoZSBhY3R1YWwgdmFsdWUsIGFuZCB0aGUgNnRoIGJpdCBpcyB0aGVcbiAgLy8gY29udGludWF0aW9uIGJpdC4gVGhlIGNvbnRpbnVhdGlvbiBiaXQgdGVsbHMgdXMgd2hldGhlciB0aGVyZSBhcmUgbW9yZVxuICAvLyBkaWdpdHMgaW4gdGhpcyB2YWx1ZSBmb2xsb3dpbmcgdGhpcyBkaWdpdC5cbiAgLy9cbiAgLy8gICBDb250aW51YXRpb25cbiAgLy8gICB8ICAgIFNpZ25cbiAgLy8gICB8ICAgIHxcbiAgLy8gICBWICAgIFZcbiAgLy8gICAxMDEwMTFcblxuICB2YXIgVkxRX0JBU0VfU0hJRlQgPSA1O1xuXG4gIC8vIGJpbmFyeTogMTAwMDAwXG4gIHZhciBWTFFfQkFTRSA9IDEgPDwgVkxRX0JBU0VfU0hJRlQ7XG5cbiAgLy8gYmluYXJ5OiAwMTExMTFcbiAgdmFyIFZMUV9CQVNFX01BU0sgPSBWTFFfQkFTRSAtIDE7XG5cbiAgLy8gYmluYXJ5OiAxMDAwMDBcbiAgdmFyIFZMUV9DT05USU5VQVRJT05fQklUID0gVkxRX0JBU0U7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGZyb20gYSB0d28tY29tcGxlbWVudCB2YWx1ZSB0byBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICAgKiBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAgICogICAxIGJlY29tZXMgMiAoMTAgYmluYXJ5KSwgLTEgYmVjb21lcyAzICgxMSBiaW5hcnkpXG4gICAqICAgMiBiZWNvbWVzIDQgKDEwMCBiaW5hcnkpLCAtMiBiZWNvbWVzIDUgKDEwMSBiaW5hcnkpXG4gICAqL1xuICBmdW5jdGlvbiB0b1ZMUVNpZ25lZChhVmFsdWUpIHtcbiAgICByZXR1cm4gYVZhbHVlIDwgMFxuICAgICAgPyAoKC1hVmFsdWUpIDw8IDEpICsgMVxuICAgICAgOiAoYVZhbHVlIDw8IDEpICsgMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0byBhIHR3by1jb21wbGVtZW50IHZhbHVlIGZyb20gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAgICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gICAqICAgMiAoMTAgYmluYXJ5KSBiZWNvbWVzIDEsIDMgKDExIGJpbmFyeSkgYmVjb21lcyAtMVxuICAgKiAgIDQgKDEwMCBiaW5hcnkpIGJlY29tZXMgMiwgNSAoMTAxIGJpbmFyeSkgYmVjb21lcyAtMlxuICAgKi9cbiAgZnVuY3Rpb24gZnJvbVZMUVNpZ25lZChhVmFsdWUpIHtcbiAgICB2YXIgaXNOZWdhdGl2ZSA9IChhVmFsdWUgJiAxKSA9PT0gMTtcbiAgICB2YXIgc2hpZnRlZCA9IGFWYWx1ZSA+PiAxO1xuICAgIHJldHVybiBpc05lZ2F0aXZlXG4gICAgICA/IC1zaGlmdGVkXG4gICAgICA6IHNoaWZ0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYmFzZSA2NCBWTFEgZW5jb2RlZCB2YWx1ZS5cbiAgICovXG4gIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2VuY29kZShhVmFsdWUpIHtcbiAgICB2YXIgZW5jb2RlZCA9IFwiXCI7XG4gICAgdmFyIGRpZ2l0O1xuXG4gICAgdmFyIHZscSA9IHRvVkxRU2lnbmVkKGFWYWx1ZSk7XG5cbiAgICBkbyB7XG4gICAgICBkaWdpdCA9IHZscSAmIFZMUV9CQVNFX01BU0s7XG4gICAgICB2bHEgPj4+PSBWTFFfQkFTRV9TSElGVDtcbiAgICAgIGlmICh2bHEgPiAwKSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSBzdGlsbCBtb3JlIGRpZ2l0cyBpbiB0aGlzIHZhbHVlLCBzbyB3ZSBtdXN0IG1ha2Ugc3VyZSB0aGVcbiAgICAgICAgLy8gY29udGludWF0aW9uIGJpdCBpcyBtYXJrZWQuXG4gICAgICAgIGRpZ2l0IHw9IFZMUV9DT05USU5VQVRJT05fQklUO1xuICAgICAgfVxuICAgICAgZW5jb2RlZCArPSBiYXNlNjQuZW5jb2RlKGRpZ2l0KTtcbiAgICB9IHdoaWxlICh2bHEgPiAwKTtcblxuICAgIHJldHVybiBlbmNvZGVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNvZGVzIHRoZSBuZXh0IGJhc2UgNjQgVkxRIHZhbHVlIGZyb20gdGhlIGdpdmVuIHN0cmluZyBhbmQgcmV0dXJucyB0aGVcbiAgICogdmFsdWUgYW5kIHRoZSByZXN0IG9mIHRoZSBzdHJpbmcgdmlhIHRoZSBvdXQgcGFyYW1ldGVyLlxuICAgKi9cbiAgZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZGVjb2RlKGFTdHIsIGFJbmRleCwgYU91dFBhcmFtKSB7XG4gICAgdmFyIHN0ckxlbiA9IGFTdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAwO1xuICAgIHZhciBzaGlmdCA9IDA7XG4gICAgdmFyIGNvbnRpbnVhdGlvbiwgZGlnaXQ7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoYUluZGV4ID49IHN0ckxlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBtb3JlIGRpZ2l0cyBpbiBiYXNlIDY0IFZMUSB2YWx1ZS5cIik7XG4gICAgICB9XG5cbiAgICAgIGRpZ2l0ID0gYmFzZTY0LmRlY29kZShhU3RyLmNoYXJDb2RlQXQoYUluZGV4KyspKTtcbiAgICAgIGlmIChkaWdpdCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBiYXNlNjQgZGlnaXQ6IFwiICsgYVN0ci5jaGFyQXQoYUluZGV4IC0gMSkpO1xuICAgICAgfVxuXG4gICAgICBjb250aW51YXRpb24gPSAhIShkaWdpdCAmIFZMUV9DT05USU5VQVRJT05fQklUKTtcbiAgICAgIGRpZ2l0ICY9IFZMUV9CQVNFX01BU0s7XG4gICAgICByZXN1bHQgPSByZXN1bHQgKyAoZGlnaXQgPDwgc2hpZnQpO1xuICAgICAgc2hpZnQgKz0gVkxRX0JBU0VfU0hJRlQ7XG4gICAgfSB3aGlsZSAoY29udGludWF0aW9uKTtcblxuICAgIGFPdXRQYXJhbS52YWx1ZSA9IGZyb21WTFFTaWduZWQocmVzdWx0KTtcbiAgICBhT3V0UGFyYW0ucmVzdCA9IGFJbmRleDtcbiAgfTtcblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjayktY29yZS9+L3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvYmFzZTY0LXZscS5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgaW50VG9DaGFyTWFwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nLnNwbGl0KCcnKTtcblxuICAvKipcbiAgICogRW5jb2RlIGFuIGludGVnZXIgaW4gdGhlIHJhbmdlIG9mIDAgdG8gNjMgdG8gYSBzaW5nbGUgYmFzZSA2NCBkaWdpdC5cbiAgICovXG4gIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKG51bWJlcikge1xuICAgIGlmICgwIDw9IG51bWJlciAmJiBudW1iZXIgPCBpbnRUb0NoYXJNYXAubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gaW50VG9DaGFyTWFwW251bWJlcl07XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNdXN0IGJlIGJldHdlZW4gMCBhbmQgNjM6IFwiICsgYU51bWJlcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHNpbmdsZSBiYXNlIDY0IGNoYXJhY3RlciBjb2RlIGRpZ2l0IHRvIGFuIGludGVnZXIuIFJldHVybnMgLTEgb25cbiAgICogZmFpbHVyZS5cbiAgICovXG4gIGV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKGNoYXJDb2RlKSB7XG4gICAgdmFyIGJpZ0EgPSA2NTsgICAgIC8vICdBJ1xuICAgIHZhciBiaWdaID0gOTA7ICAgICAvLyAnWidcblxuICAgIHZhciBsaXR0bGVBID0gOTc7ICAvLyAnYSdcbiAgICB2YXIgbGl0dGxlWiA9IDEyMjsgLy8gJ3onXG5cbiAgICB2YXIgemVybyA9IDQ4OyAgICAgLy8gJzAnXG4gICAgdmFyIG5pbmUgPSA1NzsgICAgIC8vICc5J1xuXG4gICAgdmFyIHBsdXMgPSA0MzsgICAgIC8vICcrJ1xuICAgIHZhciBzbGFzaCA9IDQ3OyAgICAvLyAnLydcblxuICAgIHZhciBsaXR0bGVPZmZzZXQgPSAyNjtcbiAgICB2YXIgbnVtYmVyT2Zmc2V0ID0gNTI7XG5cbiAgICAvLyAwIC0gMjU6IEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXG4gICAgaWYgKGJpZ0EgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gYmlnWikge1xuICAgICAgcmV0dXJuIChjaGFyQ29kZSAtIGJpZ0EpO1xuICAgIH1cblxuICAgIC8vIDI2IC0gNTE6IGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XG4gICAgaWYgKGxpdHRsZUEgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gbGl0dGxlWikge1xuICAgICAgcmV0dXJuIChjaGFyQ29kZSAtIGxpdHRsZUEgKyBsaXR0bGVPZmZzZXQpO1xuICAgIH1cblxuICAgIC8vIDUyIC0gNjE6IDAxMjM0NTY3ODlcbiAgICBpZiAoemVybyA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBuaW5lKSB7XG4gICAgICByZXR1cm4gKGNoYXJDb2RlIC0gemVybyArIG51bWJlck9mZnNldCk7XG4gICAgfVxuXG4gICAgLy8gNjI6ICtcbiAgICBpZiAoY2hhckNvZGUgPT0gcGx1cykge1xuICAgICAgcmV0dXJuIDYyO1xuICAgIH1cblxuICAgIC8vIDYzOiAvXG4gICAgaWYgKGNoYXJDb2RlID09IHNsYXNoKSB7XG4gICAgICByZXR1cm4gNjM7XG4gICAgfVxuXG4gICAgLy8gSW52YWxpZCBiYXNlNjQgZGlnaXQuXG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS1jb3JlL34vc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9iYXNlNjQuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmlmICh0eXBlb2YgZGVmaW5lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGRlZmluZSA9IHJlcXVpcmUoJ2FtZGVmaW5lJykobW9kdWxlLCByZXF1aXJlKTtcbn1cbmRlZmluZShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBoZWxwZXIgZnVuY3Rpb24gZm9yIGdldHRpbmcgdmFsdWVzIGZyb20gcGFyYW1ldGVyL29wdGlvbnNcbiAgICogb2JqZWN0cy5cbiAgICpcbiAgICogQHBhcmFtIGFyZ3MgVGhlIG9iamVjdCB3ZSBhcmUgZXh0cmFjdGluZyB2YWx1ZXMgZnJvbVxuICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2UgYXJlIGdldHRpbmcuXG4gICAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgQW4gb3B0aW9uYWwgdmFsdWUgdG8gcmV0dXJuIGlmIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nXG4gICAqIGZyb20gdGhlIG9iamVjdC4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkIGFuZCB0aGUgcHJvcGVydHkgaXMgbWlzc2luZywgYW5cbiAgICogZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAqL1xuICBmdW5jdGlvbiBnZXRBcmcoYUFyZ3MsIGFOYW1lLCBhRGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKGFOYW1lIGluIGFBcmdzKSB7XG4gICAgICByZXR1cm4gYUFyZ3NbYU5hbWVdO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgcmV0dXJuIGFEZWZhdWx0VmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYU5hbWUgKyAnXCIgaXMgYSByZXF1aXJlZCBhcmd1bWVudC4nKTtcbiAgICB9XG4gIH1cbiAgZXhwb3J0cy5nZXRBcmcgPSBnZXRBcmc7XG5cbiAgdmFyIHVybFJlZ2V4cCA9IC9eKD86KFtcXHcrXFwtLl0rKTopP1xcL1xcLyg/OihcXHcrOlxcdyspQCk/KFtcXHcuXSopKD86OihcXGQrKSk/KFxcUyopJC87XG4gIHZhciBkYXRhVXJsUmVnZXhwID0gL15kYXRhOi4rXFwsLiskLztcblxuICBmdW5jdGlvbiB1cmxQYXJzZShhVXJsKSB7XG4gICAgdmFyIG1hdGNoID0gYVVybC5tYXRjaCh1cmxSZWdleHApO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2NoZW1lOiBtYXRjaFsxXSxcbiAgICAgIGF1dGg6IG1hdGNoWzJdLFxuICAgICAgaG9zdDogbWF0Y2hbM10sXG4gICAgICBwb3J0OiBtYXRjaFs0XSxcbiAgICAgIHBhdGg6IG1hdGNoWzVdXG4gICAgfTtcbiAgfVxuICBleHBvcnRzLnVybFBhcnNlID0gdXJsUGFyc2U7XG5cbiAgZnVuY3Rpb24gdXJsR2VuZXJhdGUoYVBhcnNlZFVybCkge1xuICAgIHZhciB1cmwgPSAnJztcbiAgICBpZiAoYVBhcnNlZFVybC5zY2hlbWUpIHtcbiAgICAgIHVybCArPSBhUGFyc2VkVXJsLnNjaGVtZSArICc6JztcbiAgICB9XG4gICAgdXJsICs9ICcvLyc7XG4gICAgaWYgKGFQYXJzZWRVcmwuYXV0aCkge1xuICAgICAgdXJsICs9IGFQYXJzZWRVcmwuYXV0aCArICdAJztcbiAgICB9XG4gICAgaWYgKGFQYXJzZWRVcmwuaG9zdCkge1xuICAgICAgdXJsICs9IGFQYXJzZWRVcmwuaG9zdDtcbiAgICB9XG4gICAgaWYgKGFQYXJzZWRVcmwucG9ydCkge1xuICAgICAgdXJsICs9IFwiOlwiICsgYVBhcnNlZFVybC5wb3J0XG4gICAgfVxuICAgIGlmIChhUGFyc2VkVXJsLnBhdGgpIHtcbiAgICAgIHVybCArPSBhUGFyc2VkVXJsLnBhdGg7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgZXhwb3J0cy51cmxHZW5lcmF0ZSA9IHVybEdlbmVyYXRlO1xuXG4gIC8qKlxuICAgKiBOb3JtYWxpemVzIGEgcGF0aCwgb3IgdGhlIHBhdGggcG9ydGlvbiBvZiBhIFVSTDpcbiAgICpcbiAgICogLSBSZXBsYWNlcyBjb25zZXF1dGl2ZSBzbGFzaGVzIHdpdGggb25lIHNsYXNoLlxuICAgKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJy4nIHBhcnRzLlxuICAgKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJzxkaXI+Ly4uJyBwYXJ0cy5cbiAgICpcbiAgICogQmFzZWQgb24gY29kZSBpbiB0aGUgTm9kZS5qcyAncGF0aCcgY29yZSBtb2R1bGUuXG4gICAqXG4gICAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciB1cmwgdG8gbm9ybWFsaXplLlxuICAgKi9cbiAgZnVuY3Rpb24gbm9ybWFsaXplKGFQYXRoKSB7XG4gICAgdmFyIHBhdGggPSBhUGF0aDtcbiAgICB2YXIgdXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICAgIGlmICh1cmwpIHtcbiAgICAgIGlmICghdXJsLnBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGFQYXRoO1xuICAgICAgfVxuICAgICAgcGF0aCA9IHVybC5wYXRoO1xuICAgIH1cbiAgICB2YXIgaXNBYnNvbHV0ZSA9IChwYXRoLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoL1xcLysvKTtcbiAgICBmb3IgKHZhciBwYXJ0LCB1cCA9IDAsIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgaWYgKHBhcnQgPT09ICcuJykge1xuICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgICAgdXArKztcbiAgICAgIH0gZWxzZSBpZiAodXAgPiAwKSB7XG4gICAgICAgIGlmIChwYXJ0ID09PSAnJykge1xuICAgICAgICAgIC8vIFRoZSBmaXJzdCBwYXJ0IGlzIGJsYW5rIGlmIHRoZSBwYXRoIGlzIGFic29sdXRlLiBUcnlpbmcgdG8gZ29cbiAgICAgICAgICAvLyBhYm92ZSB0aGUgcm9vdCBpcyBhIG5vLW9wLiBUaGVyZWZvcmUgd2UgY2FuIHJlbW92ZSBhbGwgJy4uJyBwYXJ0c1xuICAgICAgICAgIC8vIGRpcmVjdGx5IGFmdGVyIHRoZSByb290LlxuICAgICAgICAgIHBhcnRzLnNwbGljZShpICsgMSwgdXApO1xuICAgICAgICAgIHVwID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMik7XG4gICAgICAgICAgdXAtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBwYXRoID0gcGFydHMuam9pbignLycpO1xuXG4gICAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgICBwYXRoID0gaXNBYnNvbHV0ZSA/ICcvJyA6ICcuJztcbiAgICB9XG5cbiAgICBpZiAodXJsKSB7XG4gICAgICB1cmwucGF0aCA9IHBhdGg7XG4gICAgICByZXR1cm4gdXJsR2VuZXJhdGUodXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5cbiAgLyoqXG4gICAqIEpvaW5zIHR3byBwYXRocy9VUkxzLlxuICAgKlxuICAgKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gICAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciBVUkwgdG8gYmUgam9pbmVkIHdpdGggdGhlIHJvb3QuXG4gICAqXG4gICAqIC0gSWYgYVBhdGggaXMgYSBVUkwgb3IgYSBkYXRhIFVSSSwgYVBhdGggaXMgcmV0dXJuZWQsIHVubGVzcyBhUGF0aCBpcyBhXG4gICAqICAgc2NoZW1lLXJlbGF0aXZlIFVSTDogVGhlbiB0aGUgc2NoZW1lIG9mIGFSb290LCBpZiBhbnksIGlzIHByZXBlbmRlZFxuICAgKiAgIGZpcnN0LlxuICAgKiAtIE90aGVyd2lzZSBhUGF0aCBpcyBhIHBhdGguIElmIGFSb290IGlzIGEgVVJMLCB0aGVuIGl0cyBwYXRoIHBvcnRpb25cbiAgICogICBpcyB1cGRhdGVkIHdpdGggdGhlIHJlc3VsdCBhbmQgYVJvb3QgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSB0aGUgcmVzdWx0XG4gICAqICAgaXMgcmV0dXJuZWQuXG4gICAqICAgLSBJZiBhUGF0aCBpcyBhYnNvbHV0ZSwgdGhlIHJlc3VsdCBpcyBhUGF0aC5cbiAgICogICAtIE90aGVyd2lzZSB0aGUgdHdvIHBhdGhzIGFyZSBqb2luZWQgd2l0aCBhIHNsYXNoLlxuICAgKiAtIEpvaW5pbmcgZm9yIGV4YW1wbGUgJ2h0dHA6Ly8nIGFuZCAnd3d3LmV4YW1wbGUuY29tJyBpcyBhbHNvIHN1cHBvcnRlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGpvaW4oYVJvb3QsIGFQYXRoKSB7XG4gICAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgICBhUm9vdCA9IFwiLlwiO1xuICAgIH1cbiAgICBpZiAoYVBhdGggPT09IFwiXCIpIHtcbiAgICAgIGFQYXRoID0gXCIuXCI7XG4gICAgfVxuICAgIHZhciBhUGF0aFVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgICB2YXIgYVJvb3RVcmwgPSB1cmxQYXJzZShhUm9vdCk7XG4gICAgaWYgKGFSb290VXJsKSB7XG4gICAgICBhUm9vdCA9IGFSb290VXJsLnBhdGggfHwgJy8nO1xuICAgIH1cblxuICAgIC8vIGBqb2luKGZvbywgJy8vd3d3LmV4YW1wbGUub3JnJylgXG4gICAgaWYgKGFQYXRoVXJsICYmICFhUGF0aFVybC5zY2hlbWUpIHtcbiAgICAgIGlmIChhUm9vdFVybCkge1xuICAgICAgICBhUGF0aFVybC5zY2hlbWUgPSBhUm9vdFVybC5zY2hlbWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVBhdGhVcmwpO1xuICAgIH1cblxuICAgIGlmIChhUGF0aFVybCB8fCBhUGF0aC5tYXRjaChkYXRhVXJsUmVnZXhwKSkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cblxuICAgIC8vIGBqb2luKCdodHRwOi8vJywgJ3d3dy5leGFtcGxlLmNvbScpYFxuICAgIGlmIChhUm9vdFVybCAmJiAhYVJvb3RVcmwuaG9zdCAmJiAhYVJvb3RVcmwucGF0aCkge1xuICAgICAgYVJvb3RVcmwuaG9zdCA9IGFQYXRoO1xuICAgICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgICB9XG5cbiAgICB2YXIgam9pbmVkID0gYVBhdGguY2hhckF0KDApID09PSAnLydcbiAgICAgID8gYVBhdGhcbiAgICAgIDogbm9ybWFsaXplKGFSb290LnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgYVBhdGgpO1xuXG4gICAgaWYgKGFSb290VXJsKSB7XG4gICAgICBhUm9vdFVybC5wYXRoID0gam9pbmVkO1xuICAgICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIGpvaW5lZDtcbiAgfVxuICBleHBvcnRzLmpvaW4gPSBqb2luO1xuXG4gIC8qKlxuICAgKiBNYWtlIGEgcGF0aCByZWxhdGl2ZSB0byBhIFVSTCBvciBhbm90aGVyIHBhdGguXG4gICAqXG4gICAqIEBwYXJhbSBhUm9vdCBUaGUgcm9vdCBwYXRoIG9yIFVSTC5cbiAgICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBtYWRlIHJlbGF0aXZlIHRvIGFSb290LlxuICAgKi9cbiAgZnVuY3Rpb24gcmVsYXRpdmUoYVJvb3QsIGFQYXRoKSB7XG4gICAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgICBhUm9vdCA9IFwiLlwiO1xuICAgIH1cblxuICAgIGFSb290ID0gYVJvb3QucmVwbGFjZSgvXFwvJC8sICcnKTtcblxuICAgIC8vIEl0IGlzIHBvc3NpYmxlIGZvciB0aGUgcGF0aCB0byBiZSBhYm92ZSB0aGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBzaW1wbHlcbiAgICAvLyBjaGVja2luZyB3aGV0aGVyIHRoZSByb290IGlzIGEgcHJlZml4IG9mIHRoZSBwYXRoIHdvbid0IHdvcmsuIEluc3RlYWQsIHdlXG4gICAgLy8gbmVlZCB0byByZW1vdmUgY29tcG9uZW50cyBmcm9tIHRoZSByb290IG9uZSBieSBvbmUsIHVudGlsIGVpdGhlciB3ZSBmaW5kXG4gICAgLy8gYSBwcmVmaXggdGhhdCBmaXRzLCBvciB3ZSBydW4gb3V0IG9mIGNvbXBvbmVudHMgdG8gcmVtb3ZlLlxuICAgIHZhciBsZXZlbCA9IDA7XG4gICAgd2hpbGUgKGFQYXRoLmluZGV4T2YoYVJvb3QgKyAnLycpICE9PSAwKSB7XG4gICAgICB2YXIgaW5kZXggPSBhUm9vdC5sYXN0SW5kZXhPZihcIi9cIik7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybiBhUGF0aDtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIG9ubHkgcGFydCBvZiB0aGUgcm9vdCB0aGF0IGlzIGxlZnQgaXMgdGhlIHNjaGVtZSAoaS5lLiBodHRwOi8vLFxuICAgICAgLy8gZmlsZTovLy8sIGV0Yy4pLCBvbmUgb3IgbW9yZSBzbGFzaGVzICgvKSwgb3Igc2ltcGx5IG5vdGhpbmcgYXQgYWxsLCB3ZVxuICAgICAgLy8gaGF2ZSBleGhhdXN0ZWQgYWxsIGNvbXBvbmVudHMsIHNvIHRoZSBwYXRoIGlzIG5vdCByZWxhdGl2ZSB0byB0aGUgcm9vdC5cbiAgICAgIGFSb290ID0gYVJvb3Quc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgaWYgKGFSb290Lm1hdGNoKC9eKFteXFwvXSs6XFwvKT9cXC8qJC8pKSB7XG4gICAgICAgIHJldHVybiBhUGF0aDtcbiAgICAgIH1cblxuICAgICAgKytsZXZlbDtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgd2UgYWRkIGEgXCIuLi9cIiBmb3IgZWFjaCBjb21wb25lbnQgd2UgcmVtb3ZlZCBmcm9tIHRoZSByb290LlxuICAgIHJldHVybiBBcnJheShsZXZlbCArIDEpLmpvaW4oXCIuLi9cIikgKyBhUGF0aC5zdWJzdHIoYVJvb3QubGVuZ3RoICsgMSk7XG4gIH1cbiAgZXhwb3J0cy5yZWxhdGl2ZSA9IHJlbGF0aXZlO1xuXG4gIC8qKlxuICAgKiBCZWNhdXNlIGJlaGF2aW9yIGdvZXMgd2Fja3kgd2hlbiB5b3Ugc2V0IGBfX3Byb3RvX19gIG9uIG9iamVjdHMsIHdlXG4gICAqIGhhdmUgdG8gcHJlZml4IGFsbCB0aGUgc3RyaW5ncyBpbiBvdXIgc2V0IHdpdGggYW4gYXJiaXRyYXJ5IGNoYXJhY3Rlci5cbiAgICpcbiAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvcHVsbC8zMSBhbmRcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMzBcbiAgICpcbiAgICogQHBhcmFtIFN0cmluZyBhU3RyXG4gICAqL1xuICBmdW5jdGlvbiB0b1NldFN0cmluZyhhU3RyKSB7XG4gICAgcmV0dXJuICckJyArIGFTdHI7XG4gIH1cbiAgZXhwb3J0cy50b1NldFN0cmluZyA9IHRvU2V0U3RyaW5nO1xuXG4gIGZ1bmN0aW9uIGZyb21TZXRTdHJpbmcoYVN0cikge1xuICAgIHJldHVybiBhU3RyLnN1YnN0cigxKTtcbiAgfVxuICBleHBvcnRzLmZyb21TZXRTdHJpbmcgPSBmcm9tU2V0U3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdoZXJlIHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICAgKlxuICAgKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gICAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uLCBidXQgZGlmZmVyZW50IGdlbmVyYXRlZFxuICAgKiBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYSBtYXBwaW5nIHdpdGggYVxuICAgKiBzdHViYmVkIG91dCBtYXBwaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gICAgdmFyIGNtcCA9IG1hcHBpbmdBLnNvdXJjZSAtIG1hcHBpbmdCLnNvdXJjZTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gICAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcHBpbmdBLm5hbWUgLSBtYXBwaW5nQi5uYW1lO1xuICB9O1xuICBleHBvcnRzLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zID0gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnM7XG5cbiAgLyoqXG4gICAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2l0aCBkZWZsYXRlZCBzb3VyY2UgYW5kIG5hbWUgaW5kaWNlcyB3aGVyZVxuICAgKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gICAqXG4gICAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAgICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uLCBidXQgZGlmZmVyZW50XG4gICAqIHNvdXJjZS9uYW1lL29yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhXG4gICAqIG1hcHBpbmcgd2l0aCBhIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gICAgdmFyIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICAgIGlmIChjbXAgIT09IDAgfHwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Euc291cmNlIC0gbWFwcGluZ0Iuc291cmNlO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIHJldHVybiBtYXBwaW5nQS5uYW1lIC0gbWFwcGluZ0IubmFtZTtcbiAgfTtcbiAgZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkO1xuXG4gIGZ1bmN0aW9uIHN0cmNtcChhU3RyMSwgYVN0cjIpIHtcbiAgICBpZiAoYVN0cjEgPT09IGFTdHIyKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoYVN0cjEgPiBhU3RyMikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2l0aCBpbmZsYXRlZCBzb3VyY2UgYW5kIG5hbWUgc3RyaW5ncyB3aGVyZVxuICAgKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IpIHtcbiAgICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gICAgaWYgKGNtcCAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNtcDtcbiAgICB9XG5cbiAgICBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICAgIGlmIChjbXAgIT09IDApIHtcbiAgICAgIHJldHVybiBjbXA7XG4gICAgfVxuXG4gICAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgICBpZiAoY21wICE9PSAwKSB7XG4gICAgICByZXR1cm4gY21wO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG4gIH07XG4gIGV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZDtcblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjayktY29yZS9+L3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4gIC8qKlxuICAgKiBBIGRhdGEgc3RydWN0dXJlIHdoaWNoIGlzIGEgY29tYmluYXRpb24gb2YgYW4gYXJyYXkgYW5kIGEgc2V0LiBBZGRpbmcgYSBuZXdcbiAgICogbWVtYmVyIGlzIE8oMSksIHRlc3RpbmcgZm9yIG1lbWJlcnNoaXAgaXMgTygxKSwgYW5kIGZpbmRpbmcgdGhlIGluZGV4IG9mIGFuXG4gICAqIGVsZW1lbnQgaXMgTygxKS4gUmVtb3ZpbmcgZWxlbWVudHMgZnJvbSB0aGUgc2V0IGlzIG5vdCBzdXBwb3J0ZWQuIE9ubHlcbiAgICogc3RyaW5ncyBhcmUgc3VwcG9ydGVkIGZvciBtZW1iZXJzaGlwLlxuICAgKi9cbiAgZnVuY3Rpb24gQXJyYXlTZXQoKSB7XG4gICAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgICB0aGlzLl9zZXQgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGF0aWMgbWV0aG9kIGZvciBjcmVhdGluZyBBcnJheVNldCBpbnN0YW5jZXMgZnJvbSBhbiBleGlzdGluZyBhcnJheS5cbiAgICovXG4gIEFycmF5U2V0LmZyb21BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X2Zyb21BcnJheShhQXJyYXksIGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICB2YXIgc2V0ID0gbmV3IEFycmF5U2V0KCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFBcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgc2V0LmFkZChhQXJyYXlbaV0sIGFBbGxvd0R1cGxpY2F0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gc2V0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gaG93IG1hbnkgdW5pcXVlIGl0ZW1zIGFyZSBpbiB0aGlzIEFycmF5U2V0LiBJZiBkdXBsaWNhdGVzIGhhdmUgYmVlblxuICAgKiBhZGRlZCwgdGhhbiB0aG9zZSBkbyBub3QgY291bnQgdG93YXJkcyB0aGUgc2l6ZS5cbiAgICpcbiAgICogQHJldHVybnMgTnVtYmVyXG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIEFycmF5U2V0X3NpemUoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuX3NldCkubGVuZ3RoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgdGhlIGdpdmVuIHN0cmluZyB0byB0aGlzIHNldC5cbiAgICpcbiAgICogQHBhcmFtIFN0cmluZyBhU3RyXG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gQXJyYXlTZXRfYWRkKGFTdHIsIGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICB2YXIgaXNEdXBsaWNhdGUgPSB0aGlzLmhhcyhhU3RyKTtcbiAgICB2YXIgaWR4ID0gdGhpcy5fYXJyYXkubGVuZ3RoO1xuICAgIGlmICghaXNEdXBsaWNhdGUgfHwgYUFsbG93RHVwbGljYXRlcykge1xuICAgICAgdGhpcy5fYXJyYXkucHVzaChhU3RyKTtcbiAgICB9XG4gICAgaWYgKCFpc0R1cGxpY2F0ZSkge1xuICAgICAgdGhpcy5fc2V0W3V0aWwudG9TZXRTdHJpbmcoYVN0cildID0gaWR4O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSXMgdGhlIGdpdmVuIHN0cmluZyBhIG1lbWJlciBvZiB0aGlzIHNldD9cbiAgICpcbiAgICogQHBhcmFtIFN0cmluZyBhU3RyXG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gQXJyYXlTZXRfaGFzKGFTdHIpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX3NldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwudG9TZXRTdHJpbmcoYVN0cikpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGF0IGlzIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gc3RyaW5nIGluIHRoZSBhcnJheT9cbiAgICpcbiAgICogQHBhcmFtIFN0cmluZyBhU3RyXG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIEFycmF5U2V0X2luZGV4T2YoYVN0cikge1xuICAgIGlmICh0aGlzLmhhcyhhU3RyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NldFt1dGlsLnRvU2V0U3RyaW5nKGFTdHIpXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU3RyICsgJ1wiIGlzIG5vdCBpbiB0aGUgc2V0LicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGF0IGlzIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleD9cbiAgICpcbiAgICogQHBhcmFtIE51bWJlciBhSWR4XG4gICAqL1xuICBBcnJheVNldC5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBBcnJheVNldF9hdChhSWR4KSB7XG4gICAgaWYgKGFJZHggPj0gMCAmJiBhSWR4IDwgdGhpcy5fYXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXJyYXlbYUlkeF07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm8gZWxlbWVudCBpbmRleGVkIGJ5ICcgKyBhSWR4KTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzZXQgKHdoaWNoIGhhcyB0aGUgcHJvcGVyIGluZGljZXNcbiAgICogaW5kaWNhdGVkIGJ5IGluZGV4T2YpLiBOb3RlIHRoYXQgdGhpcyBpcyBhIGNvcHkgb2YgdGhlIGludGVybmFsIGFycmF5IHVzZWRcbiAgICogZm9yIHN0b3JpbmcgdGhlIG1lbWJlcnMgc28gdGhhdCBubyBvbmUgY2FuIG1lc3Mgd2l0aCBpbnRlcm5hbCBzdGF0ZS5cbiAgICovXG4gIEFycmF5U2V0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfdG9BcnJheSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXJyYXkuc2xpY2UoKTtcbiAgfTtcblxuICBleHBvcnRzLkFycmF5U2V0ID0gQXJyYXlTZXQ7XG5cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spLWNvcmUvfi9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL2FycmF5LXNldC5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDE0IE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBtYXBwaW5nQiBpcyBhZnRlciBtYXBwaW5nQSB3aXRoIHJlc3BlY3QgdG8gZ2VuZXJhdGVkXG4gICAqIHBvc2l0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2VuZXJhdGVkUG9zaXRpb25BZnRlcihtYXBwaW5nQSwgbWFwcGluZ0IpIHtcbiAgICAvLyBPcHRpbWl6ZWQgZm9yIG1vc3QgY29tbW9uIGNhc2VcbiAgICB2YXIgbGluZUEgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lO1xuICAgIHZhciBsaW5lQiA9IG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gICAgdmFyIGNvbHVtbkEgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW47XG4gICAgdmFyIGNvbHVtbkIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gICAgcmV0dXJuIGxpbmVCID4gbGluZUEgfHwgbGluZUIgPT0gbGluZUEgJiYgY29sdW1uQiA+PSBjb2x1bW5BIHx8XG4gICAgICAgICAgIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCKSA8PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgZGF0YSBzdHJ1Y3R1cmUgdG8gcHJvdmlkZSBhIHNvcnRlZCB2aWV3IG9mIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIGFcbiAgICogcGVyZm9ybWFuY2UgY29uc2Npb3VzIG1hbm5lci4gSXQgdHJhZGVzIGEgbmVnbGliYWJsZSBvdmVyaGVhZCBpbiBnZW5lcmFsXG4gICAqIGNhc2UgZm9yIGEgbGFyZ2Ugc3BlZWR1cCBpbiBjYXNlIG9mIG1hcHBpbmdzIGJlaW5nIGFkZGVkIGluIG9yZGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gTWFwcGluZ0xpc3QoKSB7XG4gICAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICAgIC8vIFNlcnZlcyBhcyBpbmZpbXVtXG4gICAgdGhpcy5fbGFzdCA9IHtnZW5lcmF0ZWRMaW5lOiAtMSwgZ2VuZXJhdGVkQ29sdW1uOiAwfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlIHRocm91Z2ggaW50ZXJuYWwgaXRlbXMuIFRoaXMgbWV0aG9kIHRha2VzIHRoZSBzYW1lIGFyZ3VtZW50cyB0aGF0XG4gICAqIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgdGFrZXMuXG4gICAqXG4gICAqIE5PVEU6IFRoZSBvcmRlciBvZiB0aGUgbWFwcGluZ3MgaXMgTk9UIGd1YXJhbnRlZWQuXG4gICAqL1xuICBNYXBwaW5nTGlzdC5wcm90b3R5cGUudW5zb3J0ZWRGb3JFYWNoID1cbiAgICBmdW5jdGlvbiBNYXBwaW5nTGlzdF9mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpIHtcbiAgICAgIHRoaXMuX2FycmF5LmZvckVhY2goYUNhbGxiYWNrLCBhVGhpc0FyZyk7XG4gICAgfTtcblxuICAvKipcbiAgICogQWRkIHRoZSBnaXZlbiBzb3VyY2UgbWFwcGluZy5cbiAgICpcbiAgICogQHBhcmFtIE9iamVjdCBhTWFwcGluZ1xuICAgKi9cbiAgTWFwcGluZ0xpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2FkZChhTWFwcGluZykge1xuICAgIHZhciBtYXBwaW5nO1xuICAgIGlmIChnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKHRoaXMuX2xhc3QsIGFNYXBwaW5nKSkge1xuICAgICAgdGhpcy5fbGFzdCA9IGFNYXBwaW5nO1xuICAgICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NvcnRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmbGF0LCBzb3J0ZWQgYXJyYXkgb2YgbWFwcGluZ3MuIFRoZSBtYXBwaW5ncyBhcmUgc29ydGVkIGJ5XG4gICAqIGdlbmVyYXRlZCBwb3NpdGlvbi5cbiAgICpcbiAgICogV0FSTklORzogVGhpcyBtZXRob2QgcmV0dXJucyBpbnRlcm5hbCBkYXRhIHdpdGhvdXQgY29weWluZywgZm9yXG4gICAqIHBlcmZvcm1hbmNlLiBUaGUgcmV0dXJuIHZhbHVlIG11c3QgTk9UIGJlIG11dGF0ZWQsIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhc1xuICAgKiBhbiBpbW11dGFibGUgYm9ycm93LiBJZiB5b3Ugd2FudCB0byB0YWtlIG93bmVyc2hpcCwgeW91IG11c3QgbWFrZSB5b3VyIG93blxuICAgKiBjb3B5LlxuICAgKi9cbiAgTWFwcGluZ0xpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF90b0FycmF5KCkge1xuICAgIGlmICghdGhpcy5fc29ydGVkKSB7XG4gICAgICB0aGlzLl9hcnJheS5zb3J0KHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQpO1xuICAgICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5O1xuICB9O1xuXG4gIGV4cG9ydHMuTWFwcGluZ0xpc3QgPSBNYXBwaW5nTGlzdDtcblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjayktY29yZS9+L3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvbWFwcGluZy1saXN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIHZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG4gIHZhciBiaW5hcnlTZWFyY2ggPSByZXF1aXJlKCcuL2JpbmFyeS1zZWFyY2gnKTtcbiAgdmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbiAgdmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xuICB2YXIgcXVpY2tTb3J0ID0gcmVxdWlyZSgnLi9xdWljay1zb3J0JykucXVpY2tTb3J0O1xuXG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXApIHtcbiAgICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzb3VyY2VNYXAgPSBKU09OLnBhcnNlKGFTb3VyY2VNYXAucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICAgIH1cblxuICAgIHJldHVybiBzb3VyY2VNYXAuc2VjdGlvbnMgIT0gbnVsbFxuICAgICAgPyBuZXcgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyKHNvdXJjZU1hcClcbiAgICAgIDogbmV3IEJhc2ljU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwKTtcbiAgfVxuXG4gIFNvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPSBmdW5jdGlvbihhU291cmNlTWFwKSB7XG4gICAgcmV0dXJuIEJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcChhU291cmNlTWFwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4gIC8vIGBfX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmQgYF9fb3JpZ2luYWxNYXBwaW5nc2AgYXJlIGFycmF5cyB0aGF0IGhvbGQgdGhlXG4gIC8vIHBhcnNlZCBtYXBwaW5nIGNvb3JkaW5hdGVzIGZyb20gdGhlIHNvdXJjZSBtYXAncyBcIm1hcHBpbmdzXCIgYXR0cmlidXRlLiBUaGV5XG4gIC8vIGFyZSBsYXppbHkgaW5zdGFudGlhdGVkLCBhY2Nlc3NlZCB2aWEgdGhlIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICAvLyBgX29yaWdpbmFsTWFwcGluZ3NgIGdldHRlcnMgcmVzcGVjdGl2ZWx5LCBhbmQgd2Ugb25seSBwYXJzZSB0aGUgbWFwcGluZ3NcbiAgLy8gYW5kIGNyZWF0ZSB0aGVzZSBhcnJheXMgb25jZSBxdWVyaWVkIGZvciBhIHNvdXJjZSBsb2NhdGlvbi4gV2UganVtcCB0aHJvdWdoXG4gIC8vIHRoZXNlIGhvb3BzIGJlY2F1c2UgdGhlcmUgY2FuIGJlIG1hbnkgdGhvdXNhbmRzIG9mIG1hcHBpbmdzLCBhbmQgcGFyc2luZ1xuICAvLyB0aGVtIGlzIGV4cGVuc2l2ZSwgc28gd2Ugb25seSB3YW50IHRvIGRvIGl0IGlmIHdlIG11c3QuXG4gIC8vXG4gIC8vIEVhY2ggb2JqZWN0IGluIHRoZSBhcnJheXMgaXMgb2YgdGhlIGZvcm06XG4gIC8vXG4gIC8vICAgICB7XG4gIC8vICAgICAgIGdlbmVyYXRlZExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4gIC8vICAgICAgIGdlbmVyYXRlZENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuICAvLyAgICAgICBzb3VyY2U6IFRoZSBwYXRoIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSB0aGF0IGdlbmVyYXRlZCB0aGlzXG4gIC8vICAgICAgICAgICAgICAgY2h1bmsgb2YgY29kZSxcbiAgLy8gICAgICAgb3JpZ2luYWxMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4gIC8vICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbiAgLy8gICAgICAgb3JpZ2luYWxDb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UgdGhhdFxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbiAgLy8gICAgICAgbmFtZTogVGhlIG5hbWUgb2YgdGhlIG9yaWdpbmFsIHN5bWJvbCB3aGljaCBnZW5lcmF0ZWQgdGhpcyBjaHVuayBvZlxuICAvLyAgICAgICAgICAgICBjb2RlLlxuICAvLyAgICAgfVxuICAvL1xuICAvLyBBbGwgcHJvcGVydGllcyBleGNlcHQgZm9yIGBnZW5lcmF0ZWRMaW5lYCBhbmQgYGdlbmVyYXRlZENvbHVtbmAgY2FuIGJlXG4gIC8vIGBudWxsYC5cbiAgLy9cbiAgLy8gYF9nZW5lcmF0ZWRNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucy5cbiAgLy9cbiAgLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMuXG5cbiAgU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBudWxsO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX2dlbmVyYXRlZE1hcHBpbmdzJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MpIHtcbiAgICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICB9XG4gIH0pO1xuXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX29yaWdpbmFsTWFwcGluZ3MgPSBudWxsO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX29yaWdpbmFsTWFwcGluZ3MnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRoaXMuX19vcmlnaW5hbE1hcHBpbmdzKSB7XG4gICAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncztcbiAgICB9XG4gIH0pO1xuXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fY2hhcklzTWFwcGluZ1NlcGFyYXRvciA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyLCBpbmRleCkge1xuICAgICAgdmFyIGMgPSBhU3RyLmNoYXJBdChpbmRleCk7XG4gICAgICByZXR1cm4gYyA9PT0gXCI7XCIgfHwgYyA9PT0gXCIsXCI7XG4gICAgfTtcblxuICAvKipcbiAgICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICAgKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAgICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfcGFyc2VNYXBwaW5ncyhhU3RyLCBhU291cmNlUm9vdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudCBfcGFyc2VNYXBwaW5nc1wiKTtcbiAgICB9O1xuXG4gIFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUiA9IDE7XG4gIFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSID0gMjtcblxuICBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG4gIFNvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EID0gMjtcblxuICAvKipcbiAgICogSXRlcmF0ZSBvdmVyIGVhY2ggbWFwcGluZyBiZXR3ZWVuIGFuIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiBhbmQgYVxuICAgKiBnZW5lcmF0ZWQgbGluZS9jb2x1bW4gaW4gdGhpcyBzb3VyY2UgbWFwLlxuICAgKlxuICAgKiBAcGFyYW0gRnVuY3Rpb24gYUNhbGxiYWNrXG4gICAqICAgICAgICBUaGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2l0aCBlYWNoIG1hcHBpbmcuXG4gICAqIEBwYXJhbSBPYmplY3QgYUNvbnRleHRcbiAgICogICAgICAgIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIHZhbHVlIG9mIGB0aGlzYCBldmVyeVxuICAgKiAgICAgICAgdGltZSB0aGF0IGBhQ2FsbGJhY2tgIGlzIGNhbGxlZC5cbiAgICogQHBhcmFtIGFPcmRlclxuICAgKiAgICAgICAgRWl0aGVyIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgIG9yXG4gICAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVJgLiBTcGVjaWZpZXMgd2hldGhlciB5b3Ugd2FudCB0b1xuICAgKiAgICAgICAgaXRlcmF0ZSBvdmVyIHRoZSBtYXBwaW5ncyBzb3J0ZWQgYnkgdGhlIGdlbmVyYXRlZCBmaWxlJ3MgbGluZS9jb2x1bW5cbiAgICogICAgICAgIG9yZGVyIG9yIHRoZSBvcmlnaW5hbCdzIHNvdXJjZS9saW5lL2NvbHVtbiBvcmRlciwgcmVzcGVjdGl2ZWx5LiBEZWZhdWx0cyB0b1xuICAgKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUmAuXG4gICAqL1xuICBTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZWFjaE1hcHBpbmcgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2VhY2hNYXBwaW5nKGFDYWxsYmFjaywgYUNvbnRleHQsIGFPcmRlcikge1xuICAgICAgdmFyIGNvbnRleHQgPSBhQ29udGV4dCB8fCBudWxsO1xuICAgICAgdmFyIG9yZGVyID0gYU9yZGVyIHx8IFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjtcblxuICAgICAgdmFyIG1hcHBpbmdzO1xuICAgICAgc3dpdGNoIChvcmRlcikge1xuICAgICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI6XG4gICAgICAgIG1hcHBpbmdzID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUjpcbiAgICAgICAgbWFwcGluZ3MgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gb3JkZXIgb2YgaXRlcmF0aW9uLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLnNvdXJjZVJvb3Q7XG4gICAgICBtYXBwaW5ncy5tYXAoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlID09PSBudWxsID8gbnVsbCA6IHRoaXMuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbixcbiAgICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgIG5hbWU6IG1hcHBpbmcubmFtZSA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpXG4gICAgICAgIH07XG4gICAgICB9LCB0aGlzKS5mb3JFYWNoKGFDYWxsYmFjaywgY29udGV4dCk7XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAgICogbGluZSwgYW5kIGNvbHVtbiBwcm92aWRlZC4gSWYgbm8gY29sdW1uIGlzIHByb3ZpZGVkLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICAgKiBjb3JyZXNwb25kaW5nIHRvIGEgZWl0aGVyIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yIG9yIHRoZSBuZXh0XG4gICAqIGNsb3Nlc3QgbGluZSB0aGF0IGhhcyBhbnkgbWFwcGluZ3MuIE90aGVyd2lzZSwgcmV0dXJucyBhbGwgbWFwcGluZ3NcbiAgICogY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbGluZSBhbmQgZWl0aGVyIHRoZSBjb2x1bW4gd2UgYXJlIHNlYXJjaGluZyBmb3JcbiAgICogb3IgdGhlIG5leHQgY2xvc2VzdCBjb2x1bW4gdGhhdCBoYXMgYW55IG9mZnNldHMuXG4gICAqXG4gICAqIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGNvbHVtbjogT3B0aW9uYWwuIHRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqXG4gICAqIGFuZCBhbiBhcnJheSBvZiBvYmplY3RzIGlzIHJldHVybmVkLCBlYWNoIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICovXG4gIFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2FsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvcihhQXJncykge1xuICAgICAgdmFyIGxpbmUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKTtcblxuICAgICAgLy8gV2hlbiB0aGVyZSBpcyBubyBleGFjdCBtYXRjaCwgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nXG4gICAgICAvLyByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgY2xvc2VzdCBtYXBwaW5nIGxlc3MgdGhhbiB0aGUgbmVlZGxlLiBCeVxuICAgICAgLy8gc2V0dGluZyBuZWVkbGUub3JpZ2luYWxDb2x1bW4gdG8gMCwgd2UgdGh1cyBmaW5kIHRoZSBsYXN0IG1hcHBpbmcgZm9yXG4gICAgICAvLyB0aGUgZ2l2ZW4gbGluZSwgcHJvdmlkZWQgc3VjaCBhIG1hcHBpbmcgZXhpc3RzLlxuICAgICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgICAgc291cmNlOiB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpLFxuICAgICAgICBvcmlnaW5hbExpbmU6IGxpbmUsXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicsIDApXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgbmVlZGxlLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBuZWVkbGUuc291cmNlKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fc291cmNlcy5oYXMobmVlZGxlLnNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgbmVlZGxlLnNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihuZWVkbGUuc291cmNlKTtcblxuICAgICAgdmFyIG1hcHBpbmdzID0gW107XG5cbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKG5lZWRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCk7XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAgIGlmIChhQXJncy5jb2x1bW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBvcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcblxuICAgICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgICAgLy8gYSBtYXBwaW5nIGZvciBhIGRpZmZlcmVudCBsaW5lIHRoYW4gdGhlIG9uZSB3ZSBmb3VuZC4gU2luY2VcbiAgICAgICAgICAvLyBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4gICAgICAgICAgLy8gdGhlIGxpbmUgd2UgZm91bmQuXG4gICAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IG9yaWdpbmFsTGluZSkge1xuICAgICAgICAgICAgbWFwcGluZ3MucHVzaCh7XG4gICAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgICAvLyBJdGVyYXRlIHVudGlsIGVpdGhlciB3ZSBydW4gb3V0IG9mIG1hcHBpbmdzLCBvciB3ZSBydW4gaW50b1xuICAgICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2Ugd2VyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICAgIC8vIFNpbmNlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3JcbiAgICAgICAgICAvLyB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvci5cbiAgICAgICAgICB3aGlsZSAobWFwcGluZyAmJlxuICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gbGluZSAmJlxuICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID09IG9yaWdpbmFsQ29sdW1uKSB7XG4gICAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1srK2luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hcHBpbmdzO1xuICAgIH07XG5cbiAgZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4gIC8qKlxuICAgKiBBIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoIHdlIGNhblxuICAgKiBxdWVyeSBmb3IgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9yaWdpbmFsIGZpbGUgcG9zaXRpb25zIGJ5IGdpdmluZyBpdCBhIGZpbGVcbiAgICogcG9zaXRpb24gaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqXG4gICAqIFRoZSBvbmx5IHBhcmFtZXRlciBpcyB0aGUgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvclxuICAgKiBhbHJlYWR5IHBhcnNlZCB0byBhbiBvYmplY3QpLiBBY2NvcmRpbmcgdG8gdGhlIHNwZWMsIHNvdXJjZSBtYXBzIGhhdmUgdGhlXG4gICAqIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICAgKlxuICAgKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAgICogICAtIHNvdXJjZXM6IEFuIGFycmF5IG9mIFVSTHMgdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAgICogICAtIG5hbWVzOiBBbiBhcnJheSBvZiBpZGVudGlmaWVycyB3aGljaCBjYW4gYmUgcmVmZXJyZW5jZWQgYnkgaW5kaXZpZHVhbCBtYXBwaW5ncy5cbiAgICogICAtIHNvdXJjZVJvb3Q6IE9wdGlvbmFsLiBUaGUgVVJMIHJvb3QgZnJvbSB3aGljaCBhbGwgc291cmNlcyBhcmUgcmVsYXRpdmUuXG4gICAqICAgLSBzb3VyY2VzQ29udGVudDogT3B0aW9uYWwuIEFuIGFycmF5IG9mIGNvbnRlbnRzIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gICAqICAgLSBtYXBwaW5nczogQSBzdHJpbmcgb2YgYmFzZTY0IFZMUXMgd2hpY2ggY29udGFpbiB0aGUgYWN0dWFsIG1hcHBpbmdzLlxuICAgKiAgIC0gZmlsZTogT3B0aW9uYWwuIFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICAgKlxuICAgKiBIZXJlIGlzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdOlxuICAgKlxuICAgKiAgICAge1xuICAgKiAgICAgICB2ZXJzaW9uIDogMyxcbiAgICogICAgICAgZmlsZTogXCJvdXQuanNcIixcbiAgICogICAgICAgc291cmNlUm9vdCA6IFwiXCIsXG4gICAqICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAgICogICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gICAqICAgICAgIG1hcHBpbmdzOiBcIkFBLEFCOztBQkNERTtcIlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdD9wbGk9MSNcbiAgICovXG4gIGZ1bmN0aW9uIEJhc2ljU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCkge1xuICAgIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICAgIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNvdXJjZU1hcCA9IEpTT04ucGFyc2UoYVNvdXJjZU1hcC5yZXBsYWNlKC9eXFwpXFxdXFx9Jy8sICcnKSk7XG4gICAgfVxuXG4gICAgdmFyIHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICd2ZXJzaW9uJyk7XG4gICAgdmFyIHNvdXJjZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VzJyk7XG4gICAgLy8gU2FzcyAzLjMgbGVhdmVzIG91dCB0aGUgJ25hbWVzJyBhcnJheSwgc28gd2UgZGV2aWF0ZSBmcm9tIHRoZSBzcGVjICh3aGljaFxuICAgIC8vIHJlcXVpcmVzIHRoZSBhcnJheSkgdG8gcGxheSBuaWNlIGhlcmUuXG4gICAgdmFyIG5hbWVzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbmFtZXMnLCBbXSk7XG4gICAgdmFyIHNvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VSb290JywgbnVsbCk7XG4gICAgdmFyIHNvdXJjZXNDb250ZW50ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlc0NvbnRlbnQnLCBudWxsKTtcbiAgICB2YXIgbWFwcGluZ3MgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdtYXBwaW5ncycpO1xuICAgIHZhciBmaWxlID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnZmlsZScsIG51bGwpO1xuXG4gICAgLy8gT25jZSBhZ2FpbiwgU2FzcyBkZXZpYXRlcyBmcm9tIHRoZSBzcGVjIGFuZCBzdXBwbGllcyB0aGUgdmVyc2lvbiBhcyBhXG4gICAgLy8gc3RyaW5nIHJhdGhlciB0aGFuIGEgbnVtYmVyLCBzbyB3ZSB1c2UgbG9vc2UgZXF1YWxpdHkgY2hlY2tpbmcgaGVyZS5cbiAgICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgICB9XG5cbiAgICAvLyBTb21lIHNvdXJjZSBtYXBzIHByb2R1Y2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIGxpa2UgXCIuL2Zvby5qc1wiIGluc3RlYWQgb2ZcbiAgICAvLyBcImZvby5qc1wiLiAgTm9ybWFsaXplIHRoZXNlIGZpcnN0IHNvIHRoYXQgZnV0dXJlIGNvbXBhcmlzb25zIHdpbGwgc3VjY2VlZC5cbiAgICAvLyBTZWUgYnVnemlsLmxhLzEwOTA3NjguXG4gICAgc291cmNlcyA9IHNvdXJjZXMubWFwKHV0aWwubm9ybWFsaXplKTtcblxuICAgIC8vIFBhc3MgYHRydWVgIGJlbG93IHRvIGFsbG93IGR1cGxpY2F0ZSBuYW1lcyBhbmQgc291cmNlcy4gV2hpbGUgc291cmNlIG1hcHNcbiAgICAvLyBhcmUgaW50ZW5kZWQgdG8gYmUgY29tcHJlc3NlZCBhbmQgZGVkdXBsaWNhdGVkLCB0aGUgVHlwZVNjcmlwdCBjb21waWxlclxuICAgIC8vIHNvbWV0aW1lcyBnZW5lcmF0ZXMgc291cmNlIG1hcHMgd2l0aCBkdXBsaWNhdGVzIGluIHRoZW0uIFNlZSBHaXRodWIgaXNzdWVcbiAgICAvLyAjNzIgYW5kIGJ1Z3ppbC5sYS84ODk0OTIuXG4gICAgdGhpcy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkobmFtZXMsIHRydWUpO1xuICAgIHRoaXMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoc291cmNlcywgdHJ1ZSk7XG5cbiAgICB0aGlzLnNvdXJjZVJvb3QgPSBzb3VyY2VSb290O1xuICAgIHRoaXMuc291cmNlc0NvbnRlbnQgPSBzb3VyY2VzQ29udGVudDtcbiAgICB0aGlzLl9tYXBwaW5ncyA9IG1hcHBpbmdzO1xuICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gIH1cblxuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgQmFzaWNTb3VyY2VNYXBDb25zdW1lciBmcm9tIGEgU291cmNlTWFwR2VuZXJhdG9yLlxuICAgKlxuICAgKiBAcGFyYW0gU291cmNlTWFwR2VuZXJhdG9yIGFTb3VyY2VNYXBcbiAgICogICAgICAgIFRoZSBzb3VyY2UgbWFwIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbiAgICogQHJldHVybnMgQmFzaWNTb3VyY2VNYXBDb25zdW1lclxuICAgKi9cbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXApIHtcbiAgICAgIHZhciBzbWMgPSBPYmplY3QuY3JlYXRlKEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcblxuICAgICAgdmFyIG5hbWVzID0gc21jLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9uYW1lcy50b0FycmF5KCksIHRydWUpO1xuICAgICAgdmFyIHNvdXJjZXMgPSBzbWMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fc291cmNlcy50b0FycmF5KCksIHRydWUpO1xuICAgICAgc21jLnNvdXJjZVJvb3QgPSBhU291cmNlTWFwLl9zb3VyY2VSb290O1xuICAgICAgc21jLnNvdXJjZXNDb250ZW50ID0gYVNvdXJjZU1hcC5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChzbWMuX3NvdXJjZXMudG9BcnJheSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbWMuc291cmNlUm9vdCk7XG4gICAgICBzbWMuZmlsZSA9IGFTb3VyY2VNYXAuX2ZpbGU7XG5cbiAgICAgIC8vIEJlY2F1c2Ugd2UgYXJlIG1vZGlmeWluZyB0aGUgZW50cmllcyAoYnkgY29udmVydGluZyBzdHJpbmcgc291cmNlcyBhbmRcbiAgICAgIC8vIG5hbWVzIHRvIGluZGljZXMgaW50byB0aGUgc291cmNlcyBhbmQgbmFtZXMgQXJyYXlTZXRzKSwgd2UgaGF2ZSB0byBtYWtlXG4gICAgICAvLyBhIGNvcHkgb2YgdGhlIGVudHJ5IG9yIGVsc2UgYmFkIHRoaW5ncyBoYXBwZW4uIFNoYXJlZCBtdXRhYmxlIHN0YXRlXG4gICAgICAvLyBzdHJpa2VzIGFnYWluISBTZWUgZ2l0aHViIGlzc3VlICMxOTEuXG5cbiAgICAgIHZhciBnZW5lcmF0ZWRNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnRvQXJyYXkoKS5zbGljZSgpO1xuICAgICAgdmFyIGRlc3RHZW5lcmF0ZWRNYXBwaW5ncyA9IHNtYy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgICB2YXIgZGVzdE9yaWdpbmFsTWFwcGluZ3MgPSBzbWMuX19vcmlnaW5hbE1hcHBpbmdzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3JjTWFwcGluZyA9IGdlbmVyYXRlZE1hcHBpbmdzW2ldO1xuICAgICAgICB2YXIgZGVzdE1hcHBpbmcgPSBuZXcgTWFwcGluZztcbiAgICAgICAgZGVzdE1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkTGluZTtcbiAgICAgICAgZGVzdE1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gc3JjTWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgICAgaWYgKHNyY01hcHBpbmcuc291cmNlKSB7XG4gICAgICAgICAgZGVzdE1hcHBpbmcuc291cmNlID0gc291cmNlcy5pbmRleE9mKHNyY01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICBkZXN0TWFwcGluZy5vcmlnaW5hbExpbmUgPSBzcmNNYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgICBkZXN0TWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IHNyY01hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgICBpZiAoc3JjTWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgICBkZXN0TWFwcGluZy5uYW1lID0gbmFtZXMuaW5kZXhPZihzcmNNYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlc3RPcmlnaW5hbE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzdEdlbmVyYXRlZE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO1xuICAgICAgfVxuXG4gICAgICBxdWlja1NvcnQoc21jLl9fb3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG5cbiAgICAgIHJldHVybiBzbWM7XG4gICAgfTtcblxuICAvKipcbiAgICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICAgKi9cbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnc291cmNlcycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zb3VyY2VzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlUm9vdCAhPSBudWxsID8gdXRpbC5qb2luKHRoaXMuc291cmNlUm9vdCwgcykgOiBzO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogUHJvdmlkZSB0aGUgSklUIHdpdGggYSBuaWNlIHNoYXBlIC8gaGlkZGVuIGNsYXNzLlxuICAgKi9cbiAgZnVuY3Rpb24gTWFwcGluZygpIHtcbiAgICB0aGlzLmdlbmVyYXRlZExpbmUgPSAwO1xuICAgIHRoaXMuZ2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5hbExpbmUgPSBudWxsO1xuICAgIHRoaXMub3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICAgIHRoaXMubmFtZSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICAgKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAgICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgICB2YXIgZ2VuZXJhdGVkTGluZSA9IDE7XG4gICAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICAgIHZhciBwcmV2aW91c1NvdXJjZSA9IDA7XG4gICAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICAgIHZhciBsZW5ndGggPSBhU3RyLmxlbmd0aDtcbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICB2YXIgY2FjaGVkU2VnbWVudHMgPSB7fTtcbiAgICAgIHZhciB0ZW1wID0ge307XG4gICAgICB2YXIgb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgICAgdmFyIGdlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgICB2YXIgbWFwcGluZywgc3RyLCBzZWdtZW50LCBlbmQsIHZhbHVlO1xuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGFTdHIuY2hhckF0KGluZGV4KSA9PT0gJzsnKSB7XG4gICAgICAgICAgZ2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFTdHIuY2hhckF0KGluZGV4KSA9PT0gJywnKSB7XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBtYXBwaW5nID0gbmV3IE1hcHBpbmcoKTtcbiAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBnZW5lcmF0ZWRMaW5lO1xuXG4gICAgICAgICAgLy8gQmVjYXVzZSBlYWNoIG9mZnNldCBpcyBlbmNvZGVkIHJlbGF0aXZlIHRvIHRoZSBwcmV2aW91cyBvbmUsXG4gICAgICAgICAgLy8gbWFueSBzZWdtZW50cyBvZnRlbiBoYXZlIHRoZSBzYW1lIGVuY29kaW5nLiBXZSBjYW4gZXhwbG9pdCB0aGlzXG4gICAgICAgICAgLy8gZmFjdCBieSBjYWNoaW5nIHRoZSBwYXJzZWQgdmFyaWFibGUgbGVuZ3RoIGZpZWxkcyBvZiBlYWNoIHNlZ21lbnQsXG4gICAgICAgICAgLy8gYWxsb3dpbmcgdXMgdG8gYXZvaWQgYSBzZWNvbmQgcGFyc2UgaWYgd2UgZW5jb3VudGVyIHRoZSBzYW1lXG4gICAgICAgICAgLy8gc2VnbWVudCBhZ2Fpbi5cbiAgICAgICAgICBmb3IgKGVuZCA9IGluZGV4OyBlbmQgPCBsZW5ndGg7IGVuZCsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyLCBlbmQpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzdHIgPSBhU3RyLnNsaWNlKGluZGV4LCBlbmQpO1xuXG4gICAgICAgICAgc2VnbWVudCA9IGNhY2hlZFNlZ21lbnRzW3N0cl07XG4gICAgICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgICAgIGluZGV4ICs9IHN0ci5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IGVuZCkge1xuICAgICAgICAgICAgICBiYXNlNjRWTFEuZGVjb2RlKGFTdHIsIGluZGV4LCB0ZW1wKTtcbiAgICAgICAgICAgICAgdmFsdWUgPSB0ZW1wLnZhbHVlO1xuICAgICAgICAgICAgICBpbmRleCA9IHRlbXAucmVzdDtcbiAgICAgICAgICAgICAgc2VnbWVudC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UsIGJ1dCBubyBsaW5lIGFuZCBjb2x1bW4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UgYW5kIGxpbmUsIGJ1dCBubyBjb2x1bW4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FjaGVkU2VnbWVudHNbc3RyXSA9IHNlZ21lbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gR2VuZXJhdGVkIGNvbHVtbi5cbiAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uICsgc2VnbWVudFswXTtcbiAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgLy8gT3JpZ2luYWwgc291cmNlLlxuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBwcmV2aW91c1NvdXJjZSArIHNlZ21lbnRbMV07XG4gICAgICAgICAgICBwcmV2aW91c1NvdXJjZSArPSBzZWdtZW50WzFdO1xuXG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBsaW5lLlxuICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBwcmV2aW91c09yaWdpbmFsTGluZSArIHNlZ21lbnRbMl07XG4gICAgICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuICAgICAgICAgICAgLy8gTGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkXG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSArPSAxO1xuXG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBjb2x1bW4uXG4gICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gcHJldmlvdXNPcmlnaW5hbENvbHVtbiArIHNlZ21lbnRbM107XG4gICAgICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgICAvLyBPcmlnaW5hbCBuYW1lLlxuICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBwcmV2aW91c05hbWUgKyBzZWdtZW50WzRdO1xuICAgICAgICAgICAgICBwcmV2aW91c05hbWUgKz0gc2VnbWVudFs0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICAgIGlmICh0eXBlb2YgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBvcmlnaW5hbE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHF1aWNrU29ydChnZW5lcmF0ZWRNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCk7XG4gICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBnZW5lcmF0ZWRNYXBwaW5ncztcblxuICAgICAgcXVpY2tTb3J0KG9yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBvcmlnaW5hbE1hcHBpbmdzO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIG1hcHBpbmcgdGhhdCBiZXN0IG1hdGNoZXMgdGhlIGh5cG90aGV0aWNhbCBcIm5lZWRsZVwiIG1hcHBpbmcgdGhhdFxuICAgKiB3ZSBhcmUgc2VhcmNoaW5nIGZvciBpbiB0aGUgZ2l2ZW4gXCJoYXlzdGFja1wiIG9mIG1hcHBpbmdzLlxuICAgKi9cbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nID1cbiAgICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9maW5kTWFwcGluZyhhTmVlZGxlLCBhTWFwcGluZ3MsIGFMaW5lTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ29sdW1uTmFtZSwgYUNvbXBhcmF0b3IsIGFCaWFzKSB7XG4gICAgICAvLyBUbyByZXR1cm4gdGhlIHBvc2l0aW9uIHdlIGFyZSBzZWFyY2hpbmcgZm9yLCB3ZSBtdXN0IGZpcnN0IGZpbmQgdGhlXG4gICAgICAvLyBtYXBwaW5nIGZvciB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHRoZW4gcmV0dXJuIHRoZSBvcHBvc2l0ZSBwb3NpdGlvbiBpdFxuICAgICAgLy8gcG9pbnRzIHRvLiBCZWNhdXNlIHRoZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB3ZSBjYW4gdXNlIGJpbmFyeSBzZWFyY2ggdG9cbiAgICAgIC8vIGZpbmQgdGhlIGJlc3QgbWFwcGluZy5cblxuICAgICAgaWYgKGFOZWVkbGVbYUxpbmVOYW1lXSA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0xpbmUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMSwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGFOZWVkbGVbYUxpbmVOYW1lXSk7XG4gICAgICB9XG4gICAgICBpZiAoYU5lZWRsZVthQ29sdW1uTmFtZV0gPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbHVtbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwLCBnb3QgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthQ29sdW1uTmFtZV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmluYXJ5U2VhcmNoLnNlYXJjaChhTmVlZGxlLCBhTWFwcGluZ3MsIGFDb21wYXJhdG9yLCBhQmlhcyk7XG4gICAgfTtcblxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgbGFzdCBjb2x1bW4gZm9yIGVhY2ggZ2VuZXJhdGVkIG1hcHBpbmcuIFRoZSBsYXN0IGNvbHVtbiBpc1xuICAgKiBpbmNsdXNpdmUuXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb21wdXRlQ29sdW1uU3BhbnMgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NvbXB1dGVDb2x1bW5TcGFucygpIHtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgICAgLy8gTWFwcGluZ3MgZG8gbm90IGNvbnRhaW4gYSBmaWVsZCBmb3IgdGhlIGxhc3QgZ2VuZXJhdGVkIGNvbHVtbnQuIFdlXG4gICAgICAgIC8vIGNhbiBjb21lIHVwIHdpdGggYW4gb3B0aW1pc3RpYyBlc3RpbWF0ZSwgaG93ZXZlciwgYnkgYXNzdW1pbmcgdGhhdFxuICAgICAgICAvLyBtYXBwaW5ncyBhcmUgY29udGlndW91cyAoaS5lLiBnaXZlbiB0d28gY29uc2VjdXRpdmUgbWFwcGluZ3MsIHRoZVxuICAgICAgICAvLyBmaXJzdCBtYXBwaW5nIGVuZHMgd2hlcmUgdGhlIHNlY29uZCBvbmUgc3RhcnRzKS5cbiAgICAgICAgaWYgKGluZGV4ICsgMSA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBuZXh0TWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4ICsgMV07XG5cbiAgICAgICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLSAxO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGxhc3QgbWFwcGluZyBmb3IgZWFjaCBsaW5lIHNwYW5zIHRoZSBlbnRpcmUgbGluZS5cbiAgICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gSW5maW5pdHk7XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gICAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gICAqICAgLSBiaWFzOiBFaXRoZXIgJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICAgKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICAgKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICAgKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gICAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICAgKlxuICAgKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICAgKi9cbiAgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgICAgfTtcblxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICAgIG5lZWRsZSxcbiAgICAgICAgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MsXG4gICAgICAgIFwiZ2VuZXJhdGVkTGluZVwiLFxuICAgICAgICBcImdlbmVyYXRlZENvbHVtblwiLFxuICAgICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkLFxuICAgICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICAgICk7XG5cbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5lZWRsZS5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdzb3VyY2UnLCBudWxsKTtcbiAgICAgICAgICBpZiAoc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmF0KHNvdXJjZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHRoaXMuc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbmFtZScsIG51bGwpO1xuICAgICAgICAgIGlmIChuYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICBuYW1lID0gdGhpcy5fbmFtZXMuYXQobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbmFtZTogbnVsbFxuICAgICAgfTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAgICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5oYXNDb250ZW50c09mQWxsU291cmNlcyA9XG4gICAgZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcl9oYXNDb250ZW50c09mQWxsU291cmNlcygpIHtcbiAgICAgIGlmICghdGhpcy5zb3VyY2VzQ29udGVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudC5sZW5ndGggPj0gdGhpcy5fc291cmNlcy5zaXplKCkgJiZcbiAgICAgICAgIXRoaXMuc291cmNlc0NvbnRlbnQuc29tZShmdW5jdGlvbiAoc2MpIHsgcmV0dXJuIHNjID09IG51bGw7IH0pO1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICAgKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gICAqIGF2YWlsaWJsZS5cbiAgICovXG4gIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgYVNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBhU291cmNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3NvdXJjZXMuaGFzKGFTb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihhU291cmNlKV07XG4gICAgICB9XG5cbiAgICAgIHZhciB1cmw7XG4gICAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGxcbiAgICAgICAgICAmJiAodXJsID0gdXRpbC51cmxQYXJzZSh0aGlzLnNvdXJjZVJvb3QpKSkge1xuICAgICAgICAvLyBYWFg6IGZpbGU6Ly8gVVJJcyBhbmQgYWJzb2x1dGUgcGF0aHMgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yIGZvclxuICAgICAgICAvLyBtYW55IHVzZXJzLiBXZSBjYW4gaGVscCB0aGVtIG91dCB3aGVuIHRoZXkgZXhwZWN0IGZpbGU6Ly8gVVJJcyB0b1xuICAgICAgICAvLyBiZWhhdmUgbGlrZSBpdCB3b3VsZCBpZiB0aGV5IHdlcmUgcnVubmluZyBhIGxvY2FsIEhUVFAgc2VydmVyLiBTZWVcbiAgICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODg1NTk3LlxuICAgICAgICB2YXIgZmlsZVVyaUFic1BhdGggPSBhU291cmNlLnJlcGxhY2UoL15maWxlOlxcL1xcLy8sIFwiXCIpO1xuICAgICAgICBpZiAodXJsLnNjaGVtZSA9PSBcImZpbGVcIlxuICAgICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoZmlsZVVyaUFic1BhdGgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGZpbGVVcmlBYnNQYXRoKV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgoIXVybC5wYXRoIHx8IHVybC5wYXRoID09IFwiL1wiKVxuICAgICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoXCIvXCIgKyBhU291cmNlKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihcIi9cIiArIGFTb3VyY2UpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgcmVjdXJzaXZlbHkgZnJvbVxuICAgICAgLy8gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yLiBJbiB0aGF0IGNhc2UsIHdlXG4gICAgICAvLyBkb24ndCB3YW50IHRvIHRocm93IGlmIHdlIGNhbid0IGZpbmQgdGhlIHNvdXJjZSAtIHdlIGp1c3Qgd2FudCB0b1xuICAgICAgLy8gcmV0dXJuIG51bGwsIHNvIHdlIHByb3ZpZGUgYSBmbGFnIHRvIGV4aXQgZ3JhY2VmdWxseS5cbiAgICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICAgKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAgICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAgICogICAgICdTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAgICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAgICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICAgKiAgICAgRGVmYXVsdHMgdG8gJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAgICpcbiAgICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAgICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gICAqL1xuICBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gICAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpO1xuICAgICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG5cbiAgICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICBvcmlnaW5hbExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgICAgfTtcblxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICAgIG5lZWRsZSxcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcbiAgICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgICB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zLFxuICAgICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICAgICk7XG5cbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBuZWVkbGUuc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgICAgfTtcbiAgICB9O1xuXG4gIGV4cG9ydHMuQmFzaWNTb3VyY2VNYXBDb25zdW1lciA9IEJhc2ljU291cmNlTWFwQ29uc3VtZXI7XG5cbiAgLyoqXG4gICAqIEFuIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lciBpbnN0YW5jZSByZXByZXNlbnRzIGEgcGFyc2VkIHNvdXJjZSBtYXAgd2hpY2hcbiAgICogd2UgY2FuIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbi4gSXQgZGlmZmVycyBmcm9tIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5cbiAgICogdGhhdCBpdCB0YWtlcyBcImluZGV4ZWRcIiBzb3VyY2UgbWFwcyAoaS5lLiBvbmVzIHdpdGggYSBcInNlY3Rpb25zXCIgZmllbGQpIGFzXG4gICAqIGlucHV0LlxuICAgKlxuICAgKiBUaGUgb25seSBwYXJhbWV0ZXIgaXMgYSByYXcgc291cmNlIG1hcCAoZWl0aGVyIGFzIGEgSlNPTiBzdHJpbmcsIG9yIGFscmVhZHlcbiAgICogcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYyBmb3IgaW5kZXhlZCBzb3VyY2UgbWFwcywgdGhleVxuICAgKiBoYXZlIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAgICpcbiAgICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gICAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gICAqICAgLSBzZWN0aW9uczogQSBsaXN0IG9mIHNlY3Rpb24gZGVmaW5pdGlvbnMuXG4gICAqXG4gICAqIEVhY2ggdmFsdWUgdW5kZXIgdGhlIFwic2VjdGlvbnNcIiBmaWVsZCBoYXMgdHdvIGZpZWxkczpcbiAgICogICAtIG9mZnNldDogVGhlIG9mZnNldCBpbnRvIHRoZSBvcmlnaW5hbCBzcGVjaWZpZWQgYXQgd2hpY2ggdGhpcyBzZWN0aW9uXG4gICAqICAgICAgIGJlZ2lucyB0byBhcHBseSwgZGVmaW5lZCBhcyBhbiBvYmplY3Qgd2l0aCBhIFwibGluZVwiIGFuZCBcImNvbHVtblwiXG4gICAqICAgICAgIGZpZWxkLlxuICAgKiAgIC0gbWFwOiBBIHNvdXJjZSBtYXAgZGVmaW5pdGlvbi4gVGhpcyBzb3VyY2UgbWFwIGNvdWxkIGFsc28gYmUgaW5kZXhlZCxcbiAgICogICAgICAgYnV0IGRvZXNuJ3QgaGF2ZSB0byBiZS5cbiAgICpcbiAgICogSW5zdGVhZCBvZiB0aGUgXCJtYXBcIiBmaWVsZCwgaXQncyBhbHNvIHBvc3NpYmxlIHRvIGhhdmUgYSBcInVybFwiIGZpZWxkXG4gICAqIHNwZWNpZnlpbmcgYSBVUkwgdG8gcmV0cmlldmUgYSBzb3VyY2UgbWFwIGZyb20sIGJ1dCB0aGF0J3MgY3VycmVudGx5XG4gICAqIHVuc3VwcG9ydGVkLlxuICAgKlxuICAgKiBIZXJlJ3MgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF0sIGJ1dFxuICAgKiBtb2RpZmllZCB0byBvbWl0IGEgc2VjdGlvbiB3aGljaCB1c2VzIHRoZSBcInVybFwiIGZpZWxkLlxuICAgKlxuICAgKiAge1xuICAgKiAgICB2ZXJzaW9uIDogMyxcbiAgICogICAgZmlsZTogXCJhcHAuanNcIixcbiAgICogICAgc2VjdGlvbnM6IFt7XG4gICAqICAgICAgb2Zmc2V0OiB7bGluZToxMDAsIGNvbHVtbjoxMH0sXG4gICAqICAgICAgbWFwOiB7XG4gICAqICAgICAgICB2ZXJzaW9uIDogMyxcbiAgICogICAgICAgIGZpbGU6IFwic2VjdGlvbi5qc1wiLFxuICAgKiAgICAgICAgc291cmNlczogW1wiZm9vLmpzXCIsIFwiYmFyLmpzXCJdLFxuICAgKiAgICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gICAqICAgICAgICBtYXBwaW5nczogXCJBQUFBLEU7O0FCQ0RFO1wiXG4gICAqICAgICAgfVxuICAgKiAgICB9XSxcbiAgICogIH1cbiAgICpcbiAgICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQjaGVhZGluZz1oLjUzNWVzM3hlcHJndFxuICAgKi9cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXApIHtcbiAgICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzb3VyY2VNYXAgPSBKU09OLnBhcnNlKGFTb3VyY2VNYXAucmVwbGFjZSgvXlxcKVxcXVxcfScvLCAnJykpO1xuICAgIH1cblxuICAgIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICAgIHZhciBzZWN0aW9ucyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NlY3Rpb25zJyk7XG5cbiAgICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICAgIHZhciBsYXN0T2Zmc2V0ID0ge1xuICAgICAgbGluZTogLTEsXG4gICAgICBjb2x1bW46IDBcbiAgICB9O1xuICAgIHRoaXMuX3NlY3Rpb25zID0gc2VjdGlvbnMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICBpZiAocy51cmwpIHtcbiAgICAgICAgLy8gVGhlIHVybCBmaWVsZCB3aWxsIHJlcXVpcmUgc3VwcG9ydCBmb3IgYXN5bmNocm9uaWNpdHkuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8xNlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBvcnQgZm9yIHVybCBmaWVsZCBpbiBzZWN0aW9ucyBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgICB9XG4gICAgICB2YXIgb2Zmc2V0ID0gdXRpbC5nZXRBcmcocywgJ29mZnNldCcpO1xuICAgICAgdmFyIG9mZnNldExpbmUgPSB1dGlsLmdldEFyZyhvZmZzZXQsICdsaW5lJyk7XG4gICAgICB2YXIgb2Zmc2V0Q29sdW1uID0gdXRpbC5nZXRBcmcob2Zmc2V0LCAnY29sdW1uJyk7XG5cbiAgICAgIGlmIChvZmZzZXRMaW5lIDwgbGFzdE9mZnNldC5saW5lIHx8XG4gICAgICAgICAgKG9mZnNldExpbmUgPT09IGxhc3RPZmZzZXQubGluZSAmJiBvZmZzZXRDb2x1bW4gPCBsYXN0T2Zmc2V0LmNvbHVtbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWN0aW9uIG9mZnNldHMgbXVzdCBiZSBvcmRlcmVkIGFuZCBub24tb3ZlcmxhcHBpbmcuJyk7XG4gICAgICB9XG4gICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBnZW5lcmF0ZWRPZmZzZXQ6IHtcbiAgICAgICAgICAvLyBUaGUgb2Zmc2V0IGZpZWxkcyBhcmUgMC1iYXNlZCwgYnV0IHdlIHVzZSAxLWJhc2VkIGluZGljZXMgd2hlblxuICAgICAgICAgIC8vIGVuY29kaW5nL2RlY29kaW5nIGZyb20gVkxRLlxuICAgICAgICAgIGdlbmVyYXRlZExpbmU6IG9mZnNldExpbmUgKyAxLFxuICAgICAgICAgIGdlbmVyYXRlZENvbHVtbjogb2Zmc2V0Q29sdW1uICsgMVxuICAgICAgICB9LFxuICAgICAgICBjb25zdW1lcjogbmV3IFNvdXJjZU1hcENvbnN1bWVyKHV0aWwuZ2V0QXJnKHMsICdtYXAnKSlcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG4gIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuICAvKipcbiAgICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICAgKi9cbiAgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIG9yaWdpbmFsIHNvdXJjZXMuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ3NvdXJjZXMnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuX3NlY3Rpb25zW2ldLmNvbnN1bWVyLnNvdXJjZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBzb3VyY2VzLnB1c2godGhpcy5fc2VjdGlvbnNbaV0uY29uc3VtZXIuc291cmNlc1tqXSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gc291cmNlcztcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UsIGxpbmUsIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBnZW5lcmF0ZWRcbiAgICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gICAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICAgKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAgICpcbiAgICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gICAqICAgLSBuYW1lOiBUaGUgb3JpZ2luYWwgaWRlbnRpZmllciwgb3IgbnVsbC5cbiAgICovXG4gIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gICAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICAgIH07XG5cbiAgICAgIC8vIEZpbmQgdGhlIHNlY3Rpb24gY29udGFpbmluZyB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uIHdlJ3JlIHRyeWluZyB0byBtYXBcbiAgICAgIC8vIHRvIGFuIG9yaWdpbmFsIHBvc2l0aW9uLlxuICAgICAgdmFyIHNlY3Rpb25JbmRleCA9IGJpbmFyeVNlYXJjaC5zZWFyY2gobmVlZGxlLCB0aGlzLl9zZWN0aW9ucyxcbiAgICAgICAgZnVuY3Rpb24obmVlZGxlLCBzZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIGNtcCA9IG5lZWRsZS5nZW5lcmF0ZWRMaW5lIC0gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZTtcbiAgICAgICAgICBpZiAoY21wKSB7XG4gICAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAobmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICB9KTtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbc2VjdGlvbkluZGV4XTtcblxuICAgICAgaWYgKCFzZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICAgIG5hbWU6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlY3Rpb24uY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgIGxpbmU6IG5lZWRsZS5nZW5lcmF0ZWRMaW5lIC1cbiAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgICBjb2x1bW46IG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZVxuICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgOiAwKSxcbiAgICAgICAgYmlhczogYUFyZ3MuYmlhc1xuICAgICAgfSk7XG4gICAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRydWUgaWYgd2UgaGF2ZSB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGV2ZXJ5IHNvdXJjZSBpbiB0aGUgc291cmNlXG4gICAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5oYXNDb250ZW50c09mQWxsU291cmNlcyA9XG4gICAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlY3Rpb25zLmV2ZXJ5KGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiBzLmNvbnN1bWVyLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAgICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICAgKiBhdmFpbGFibGUuXG4gICAqL1xuICBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICAgIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcblxuICAgICAgICB2YXIgY29udGVudCA9IHNlY3Rpb24uY29uc3VtZXIuc291cmNlQ29udGVudEZvcihhU291cmNlLCB0cnVlKTtcbiAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU291cmNlICsgJ1wiIGlzIG5vdCBpbiB0aGUgU291cmNlTWFwLicpO1xuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gICAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICAgKiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICAgKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gICAqXG4gICAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gICAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICAgKi9cbiAgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gICAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgICAgLy8gT25seSBjb25zaWRlciB0aGlzIHNlY3Rpb24gaWYgdGhlIHJlcXVlc3RlZCBzb3VyY2UgaXMgaW4gdGhlIGxpc3Qgb2ZcbiAgICAgICAgLy8gc291cmNlcyBvZiB0aGUgY29uc3VtZXIuXG4gICAgICAgIGlmIChzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZXMuaW5kZXhPZih1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpKSA9PT0gLTEpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ2VuZXJhdGVkUG9zaXRpb24gPSBzZWN0aW9uLmNvbnN1bWVyLmdlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKTtcbiAgICAgICAgaWYgKGdlbmVyYXRlZFBvc2l0aW9uKSB7XG4gICAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmUgK1xuICAgICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWRQb3NpdGlvbi5jb2x1bW4gK1xuICAgICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gZ2VuZXJhdGVkUG9zaXRpb24ubGluZVxuICAgICAgICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICAgICAgICA6IDApXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbFxuICAgICAgfTtcbiAgICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gICAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICAgKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICAgKi9cbiAgSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gICAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcbiAgICAgICAgdmFyIHNlY3Rpb25NYXBwaW5ncyA9IHNlY3Rpb24uY29uc3VtZXIuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlY3Rpb25NYXBwaW5ncy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBtYXBwaW5nID0gc2VjdGlvbk1hcHBpbmdzW2ldO1xuXG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHNlY3Rpb24uY29uc3VtZXIuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgIGlmIChzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZVJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbihzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG5cbiAgICAgICAgICB2YXIgbmFtZSA9IHNlY3Rpb24uY29uc3VtZXIuX25hbWVzLmF0KG1hcHBpbmcubmFtZSk7XG4gICAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuXG4gICAgICAgICAgLy8gVGhlIG1hcHBpbmdzIGNvbWluZyBmcm9tIHRoZSBjb25zdW1lciBmb3IgdGhlIHNlY3Rpb24gaGF2ZVxuICAgICAgICAgIC8vIGdlbmVyYXRlZCBwb3NpdGlvbnMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBzZWN0aW9uLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gb2Zmc2V0IHRoZW0gdG8gYmUgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBjb25jYXRlbmF0ZWRcbiAgICAgICAgICAvLyBnZW5lcmF0ZWQgZmlsZS5cbiAgICAgICAgICB2YXIgYWRqdXN0ZWRNYXBwaW5nID0ge1xuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUgK1xuICAgICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSAtIDEpLFxuICAgICAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmNvbHVtbiArXG4gICAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBtYXBwaW5nLmdlbmVyYXRlZExpbmUpXG4gICAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncy5wdXNoKGFkanVzdGVkTWFwcGluZyk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBhZGp1c3RlZE1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIHF1aWNrU29ydCh0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgICAgcXVpY2tTb3J0KHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgICB9O1xuXG4gIGV4cG9ydHMuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyID0gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyO1xuXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS1jb3JlL34vc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9zb3VyY2UtbWFwLWNvbnN1bWVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIGV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuICBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EID0gMjtcblxuICAvKipcbiAgICogUmVjdXJzaXZlIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2guXG4gICAqXG4gICAqIEBwYXJhbSBhTG93IEluZGljZXMgaGVyZSBhbmQgbG93ZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAgICogQHBhcmFtIGFIaWdoIEluZGljZXMgaGVyZSBhbmQgaGlnaGVyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gICAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IGJlaW5nIHNlYXJjaGVkIGZvci5cbiAgICogQHBhcmFtIGFIYXlzdGFjayBUaGUgbm9uLWVtcHR5IGFycmF5IGJlaW5nIHNlYXJjaGVkLlxuICAgKiBAcGFyYW0gYUNvbXBhcmUgRnVuY3Rpb24gd2hpY2ggdGFrZXMgdHdvIGVsZW1lbnRzIGFuZCByZXR1cm5zIC0xLCAwLCBvciAxLlxuICAgKiBAcGFyYW0gYUJpYXMgRWl0aGVyICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gICAqICAgICAnYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICAgKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICAgKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gICAqL1xuICBmdW5jdGlvbiByZWN1cnNpdmVTZWFyY2goYUxvdywgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiB0ZXJtaW5hdGVzIHdoZW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZTpcbiAgICAvL1xuICAgIC8vICAgMS4gV2UgZmluZCB0aGUgZXhhY3QgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgLy9cbiAgICAvLyAgIDIuIFdlIGRpZCBub3QgZmluZCB0aGUgZXhhY3QgZWxlbWVudCwgYnV0IHdlIGNhbiByZXR1cm4gdGhlIGluZGV4IG9mXG4gICAgLy8gICAgICB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQuXG4gICAgLy9cbiAgICAvLyAgIDMuIFdlIGRpZCBub3QgZmluZCB0aGUgZXhhY3QgZWxlbWVudCwgYW5kIHRoZXJlIGlzIG5vIG5leHQtY2xvc2VzdFxuICAgIC8vICAgICAgZWxlbWVudCB0aGFuIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IsIHNvIHdlIHJldHVybiAtMS5cbiAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigoYUhpZ2ggLSBhTG93KSAvIDIpICsgYUxvdztcbiAgICB2YXIgY21wID0gYUNvbXBhcmUoYU5lZWRsZSwgYUhheXN0YWNrW21pZF0sIHRydWUpO1xuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIC8vIEZvdW5kIHRoZSBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgICAgIHJldHVybiBtaWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgIC8vIE91ciBuZWVkbGUgaXMgZ3JlYXRlciB0aGFuIGFIYXlzdGFja1ttaWRdLlxuICAgICAgaWYgKGFIaWdoIC0gbWlkID4gMSkge1xuICAgICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChtaWQsIGFIaWdoLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBleGFjdCBuZWVkbGUgZWxlbWVudCB3YXMgbm90IGZvdW5kIGluIHRoaXMgaGF5c3RhY2suIERldGVybWluZSBpZlxuICAgICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDMpIG9yICgyKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICAgIHJldHVybiBhSGlnaCA8IGFIYXlzdGFjay5sZW5ndGggPyBhSGlnaCA6IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1pZDtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBPdXIgbmVlZGxlIGlzIGxlc3MgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICAgIGlmIChtaWQgLSBhTG93ID4gMSkge1xuICAgICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgbG93ZXIgaGFsZi5cbiAgICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBtaWQsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICAgIH1cblxuICAgICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDMpIG9yICgyKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICAgIHJldHVybiBtaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYUxvdyA8IDAgPyAtMSA6IGFMb3c7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaCB3aGljaCB3aWxsIGFsd2F5cyB0cnkgYW5kIHJldHVyblxuICAgKiB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgZWxlbWVudCBpZiB0aGVyZSBpcyBubyBleGFjdCBoaXQuIFRoaXMgaXMgYmVjYXVzZVxuICAgKiBtYXBwaW5ncyBiZXR3ZWVuIG9yaWdpbmFsIGFuZCBnZW5lcmF0ZWQgbGluZS9jb2wgcGFpcnMgYXJlIHNpbmdsZSBwb2ludHMsXG4gICAqIGFuZCB0aGVyZSBpcyBhbiBpbXBsaWNpdCByZWdpb24gYmV0d2VlbiBlYWNoIG9mIHRoZW0sIHNvIGEgbWlzcyBqdXN0IG1lYW5zXG4gICAqIHRoYXQgeW91IGFyZW4ndCBvbiB0aGUgdmVyeSBzdGFydCBvZiBhIHJlZ2lvbi5cbiAgICpcbiAgICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgeW91IGFyZSBsb29raW5nIGZvci5cbiAgICogQHBhcmFtIGFIYXlzdGFjayBUaGUgYXJyYXkgdGhhdCBpcyBiZWluZyBzZWFyY2hlZC5cbiAgICogQHBhcmFtIGFDb21wYXJlIEEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgdGhlIG5lZWRsZSBhbmQgYW4gZWxlbWVudCBpbiB0aGVcbiAgICogICAgIGFycmF5IGFuZCByZXR1cm5zIC0xLCAwLCBvciAxIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBuZWVkbGUgaXMgbGVzc1xuICAgKiAgICAgdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhbiB0aGUgZWxlbWVudCwgcmVzcGVjdGl2ZWx5LlxuICAgKiBAcGFyYW0gYUJpYXMgRWl0aGVyICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gICAqICAgICAnYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICAgKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICAgKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gICAqICAgICBEZWZhdWx0cyB0byAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAgICovXG4gIGV4cG9ydHMuc2VhcmNoID0gZnVuY3Rpb24gc2VhcmNoKGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKSB7XG4gICAgaWYgKGFIYXlzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSByZWN1cnNpdmVTZWFyY2goLTEsIGFIYXlzdGFjay5sZW5ndGgsIGFOZWVkbGUsIGFIYXlzdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbXBhcmUsIGFCaWFzIHx8IGV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvLyBXZSBoYXZlIGZvdW5kIGVpdGhlciB0aGUgZXhhY3QgZWxlbWVudCwgb3IgdGhlIG5leHQtY2xvc2VzdCBlbGVtZW50IHRoYW5cbiAgICAvLyB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLiBIb3dldmVyLCB0aGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBzdWNoXG4gICAgLy8gZWxlbWVudC4gTWFrZSBzdXJlIHdlIGFsd2F5cyByZXR1cm4gdGhlIHNtYWxsZXN0IG9mIHRoZXNlLlxuICAgIHdoaWxlIChpbmRleCAtIDEgPj0gMCkge1xuICAgICAgaWYgKGFDb21wYXJlKGFIYXlzdGFja1tpbmRleF0sIGFIYXlzdGFja1tpbmRleCAtIDFdLCB0cnVlKSAhPT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC0taW5kZXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4O1xuICB9O1xuXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS1jb3JlL34vc291cmNlLW1hcC9saWIvc291cmNlLW1hcC9iaW5hcnktc2VhcmNoLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5pZiAodHlwZW9mIGRlZmluZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBkZWZpbmUgPSByZXF1aXJlKCdhbWRlZmluZScpKG1vZHVsZSwgcmVxdWlyZSk7XG59XG5kZWZpbmUoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4gIC8vIEl0IHR1cm5zIG91dCB0aGF0IHNvbWUgKG1vc3Q/KSBKYXZhU2NyaXB0IGVuZ2luZXMgZG9uJ3Qgc2VsZi1ob3N0XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuc29ydGAuIFRoaXMgbWFrZXMgc2Vuc2UgYmVjYXVzZSBDKysgd2lsbCBsaWtlbHkgcmVtYWluXG4gIC8vIGZhc3RlciB0aGFuIEpTIHdoZW4gZG9pbmcgcmF3IENQVS1pbnRlbnNpdmUgc29ydGluZy4gSG93ZXZlciwgd2hlbiB1c2luZyBhXG4gIC8vIGN1c3RvbSBjb21wYXJhdG9yIGZ1bmN0aW9uLCBjYWxsaW5nIGJhY2sgYW5kIGZvcnRoIGJldHdlZW4gdGhlIFZNJ3MgQysrIGFuZFxuICAvLyBKSVQnZCBKUyBpcyByYXRoZXIgc2xvdyAqYW5kKiBsb3NlcyBKSVQgdHlwZSBpbmZvcm1hdGlvbiwgcmVzdWx0aW5nIGluXG4gIC8vIHdvcnNlIGdlbmVyYXRlZCBjb2RlIGZvciB0aGUgY29tcGFyYXRvciBmdW5jdGlvbiB0aGFuIHdvdWxkIGJlIG9wdGltYWwuIEluXG4gIC8vIGZhY3QsIHdoZW4gc29ydGluZyB3aXRoIGEgY29tcGFyYXRvciwgdGhlc2UgY29zdHMgb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIG9mXG4gIC8vIHNvcnRpbmcgaW4gQysrLiBCeSB1c2luZyBvdXIgb3duIEpTLWltcGxlbWVudGVkIFF1aWNrIFNvcnQgKGJlbG93KSwgd2UgZ2V0XG4gIC8vIGEgfjM1MDBtcyBtZWFuIHNwZWVkLXVwIGluIGBiZW5jaC9iZW5jaC5odG1sYC5cblxuICAvKipcbiAgICogU3dhcCB0aGUgZWxlbWVudHMgaW5kZXhlZCBieSBgeGAgYW5kIGB5YCBpbiB0aGUgYXJyYXkgYGFyeWAuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICAgKiAgICAgICAgVGhlIGFycmF5LlxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpdGVtLlxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBzZWNvbmQgaXRlbS5cbiAgICovXG4gIGZ1bmN0aW9uIHN3YXAoYXJ5LCB4LCB5KSB7XG4gICAgdmFyIHRlbXAgPSBhcnlbeF07XG4gICAgYXJ5W3hdID0gYXJ5W3ldO1xuICAgIGFyeVt5XSA9IHRlbXA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIHdpdGhpbiB0aGUgcmFuZ2UgYGxvdyAuLiBoaWdoYCBpbmNsdXNpdmUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsb3dcbiAgICogICAgICAgIFRoZSBsb3dlciBib3VuZCBvbiB0aGUgcmFuZ2UuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoaWdoXG4gICAqICAgICAgICBUaGUgdXBwZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICAgKi9cbiAgZnVuY3Rpb24gcmFuZG9tSW50SW5SYW5nZShsb3csIGhpZ2gpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChsb3cgKyAoTWF0aC5yYW5kb20oKSAqIChoaWdoIC0gbG93KSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBRdWljayBTb3J0IGFsZ29yaXRobS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gICAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yXG4gICAqICAgICAgICBGdW5jdGlvbiB0byB1c2UgdG8gY29tcGFyZSB0d28gaXRlbXMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwXG4gICAqICAgICAgICBTdGFydCBpbmRleCBvZiB0aGUgYXJyYXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJcbiAgICogICAgICAgIEVuZCBpbmRleCBvZiB0aGUgYXJyYXlcbiAgICovXG4gIGZ1bmN0aW9uIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcCwgcikge1xuICAgIC8vIElmIG91ciBsb3dlciBib3VuZCBpcyBsZXNzIHRoYW4gb3VyIHVwcGVyIGJvdW5kLCB3ZSAoMSkgcGFydGl0aW9uIHRoZVxuICAgIC8vIGFycmF5IGludG8gdHdvIHBpZWNlcyBhbmQgKDIpIHJlY3Vyc2Ugb24gZWFjaCBoYWxmLiBJZiBpdCBpcyBub3QsIHRoaXMgaXNcbiAgICAvLyB0aGUgZW1wdHkgYXJyYXkgYW5kIG91ciBiYXNlIGNhc2UuXG5cbiAgICBpZiAocCA8IHIpIHtcbiAgICAgIC8vICgxKSBQYXJ0aXRpb25pbmcuXG4gICAgICAvL1xuICAgICAgLy8gVGhlIHBhcnRpdGlvbmluZyBjaG9vc2VzIGEgcGl2b3QgYmV0d2VlbiBgcGAgYW5kIGByYCBhbmQgbW92ZXMgYWxsXG4gICAgICAvLyBlbGVtZW50cyB0aGF0IGFyZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBpdm90IHRvIHRoZSBiZWZvcmUgaXQsIGFuZFxuICAgICAgLy8gYWxsIHRoZSBlbGVtZW50cyB0aGF0IGFyZSBncmVhdGVyIHRoYW4gaXQgYWZ0ZXIgaXQuIFRoZSBlZmZlY3QgaXMgdGhhdFxuICAgICAgLy8gb25jZSBwYXJ0aXRpb24gaXMgZG9uZSwgdGhlIHBpdm90IGlzIGluIHRoZSBleGFjdCBwbGFjZSBpdCB3aWxsIGJlIHdoZW5cbiAgICAgIC8vIHRoZSBhcnJheSBpcyBwdXQgaW4gc29ydGVkIG9yZGVyLCBhbmQgaXQgd2lsbCBub3QgbmVlZCB0byBiZSBtb3ZlZFxuICAgICAgLy8gYWdhaW4uIFRoaXMgcnVucyBpbiBPKG4pIHRpbWUuXG5cbiAgICAgIC8vIEFsd2F5cyBjaG9vc2UgYSByYW5kb20gcGl2b3Qgc28gdGhhdCBhbiBpbnB1dCBhcnJheSB3aGljaCBpcyByZXZlcnNlXG4gICAgICAvLyBzb3J0ZWQgZG9lcyBub3QgY2F1c2UgTyhuXjIpIHJ1bm5pbmcgdGltZS5cbiAgICAgIHZhciBwaXZvdEluZGV4ID0gcmFuZG9tSW50SW5SYW5nZShwLCByKTtcbiAgICAgIHZhciBpID0gcCAtIDE7XG5cbiAgICAgIHN3YXAoYXJ5LCBwaXZvdEluZGV4LCByKTtcbiAgICAgIHZhciBwaXZvdCA9IGFyeVtyXTtcblxuICAgICAgLy8gSW1tZWRpYXRlbHkgYWZ0ZXIgYGpgIGlzIGluY3JlbWVudGVkIGluIHRoaXMgbG9vcCwgdGhlIGZvbGxvd2luZyBob2xkXG4gICAgICAvLyB0cnVlOlxuICAgICAgLy9cbiAgICAgIC8vICAgKiBFdmVyeSBlbGVtZW50IGluIGBhcnlbcCAuLiBpXWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwaXZvdC5cbiAgICAgIC8vXG4gICAgICAvLyAgICogRXZlcnkgZWxlbWVudCBpbiBgYXJ5W2krMSAuLiBqLTFdYCBpcyBncmVhdGVyIHRoYW4gdGhlIHBpdm90LlxuICAgICAgZm9yICh2YXIgaiA9IHA7IGogPCByOyBqKyspIHtcbiAgICAgICAgaWYgKGNvbXBhcmF0b3IoYXJ5W2pdLCBwaXZvdCkgPD0gMCkge1xuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICBzd2FwKGFyeSwgaSwgaik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3dhcChhcnksIGkgKyAxLCBqKTtcbiAgICAgIHZhciBxID0gaSArIDE7XG5cbiAgICAgIC8vICgyKSBSZWN1cnNlIG9uIGVhY2ggaGFsZi5cblxuICAgICAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBwLCBxIC0gMSk7XG4gICAgICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHEgKyAxLCByKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU29ydCB0aGUgZ2l2ZW4gYXJyYXkgaW4tcGxhY2Ugd2l0aCB0aGUgZ2l2ZW4gY29tcGFyYXRvciBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gICAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yXG4gICAqICAgICAgICBGdW5jdGlvbiB0byB1c2UgdG8gY29tcGFyZSB0d28gaXRlbXMuXG4gICAqL1xuICBleHBvcnRzLnF1aWNrU29ydCA9IGZ1bmN0aW9uIChhcnksIGNvbXBhcmF0b3IpIHtcbiAgICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIDAsIGFyeS5sZW5ndGggLSAxKTtcbiAgfTtcblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjayktY29yZS9+L3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAvcXVpY2stc29ydC5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuaWYgKHR5cGVvZiBkZWZpbmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZGVmaW5lID0gcmVxdWlyZSgnYW1kZWZpbmUnKShtb2R1bGUsIHJlcXVpcmUpO1xufVxuZGVmaW5lKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblxuICB2YXIgU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbiAgdmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuICAvLyBNYXRjaGVzIGEgV2luZG93cy1zdHlsZSBgXFxyXFxuYCBuZXdsaW5lIG9yIGEgYFxcbmAgbmV3bGluZSB1c2VkIGJ5IGFsbCBvdGhlclxuICAvLyBvcGVyYXRpbmcgc3lzdGVtcyB0aGVzZSBkYXlzIChjYXB0dXJpbmcgdGhlIHJlc3VsdCkuXG4gIHZhciBSRUdFWF9ORVdMSU5FID0gLyhcXHI/XFxuKS87XG5cbiAgLy8gTmV3bGluZSBjaGFyYWN0ZXIgY29kZSBmb3IgY2hhckNvZGVBdCgpIGNvbXBhcmlzb25zXG4gIHZhciBORVdMSU5FX0NPREUgPSAxMDtcblxuICAvLyBQcml2YXRlIHN5bWJvbCBmb3IgaWRlbnRpZnlpbmcgYFNvdXJjZU5vZGVgcyB3aGVuIG11bHRpcGxlIHZlcnNpb25zIG9mXG4gIC8vIHRoZSBzb3VyY2UtbWFwIGxpYnJhcnkgYXJlIGxvYWRlZC4gVGhpcyBNVVNUIE5PVCBDSEFOR0UgYWNyb3NzXG4gIC8vIHZlcnNpb25zIVxuICB2YXIgaXNTb3VyY2VOb2RlID0gXCIkJCRpc1NvdXJjZU5vZGUkJCRcIjtcblxuICAvKipcbiAgICogU291cmNlTm9kZXMgcHJvdmlkZSBhIHdheSB0byBhYnN0cmFjdCBvdmVyIGludGVycG9sYXRpbmcvY29uY2F0ZW5hdGluZ1xuICAgKiBzbmlwcGV0cyBvZiBnZW5lcmF0ZWQgSmF2YVNjcmlwdCBzb3VyY2UgY29kZSB3aGlsZSBtYWludGFpbmluZyB0aGUgbGluZSBhbmRcbiAgICogY29sdW1uIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3JpZ2luYWwgc291cmNlIGNvZGUuXG4gICAqXG4gICAqIEBwYXJhbSBhTGluZSBUaGUgb3JpZ2luYWwgbGluZSBudW1iZXIuXG4gICAqIEBwYXJhbSBhQ29sdW1uIFRoZSBvcmlnaW5hbCBjb2x1bW4gbnVtYmVyLlxuICAgKiBAcGFyYW0gYVNvdXJjZSBUaGUgb3JpZ2luYWwgc291cmNlJ3MgZmlsZW5hbWUuXG4gICAqIEBwYXJhbSBhQ2h1bmtzIE9wdGlvbmFsLiBBbiBhcnJheSBvZiBzdHJpbmdzIHdoaWNoIGFyZSBzbmlwcGV0cyBvZlxuICAgKiAgICAgICAgZ2VuZXJhdGVkIEpTLCBvciBvdGhlciBTb3VyY2VOb2Rlcy5cbiAgICogQHBhcmFtIGFOYW1lIFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLlxuICAgKi9cbiAgZnVuY3Rpb24gU291cmNlTm9kZShhTGluZSwgYUNvbHVtbiwgYVNvdXJjZSwgYUNodW5rcywgYU5hbWUpIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdGhpcy5zb3VyY2VDb250ZW50cyA9IHt9O1xuICAgIHRoaXMubGluZSA9IGFMaW5lID09IG51bGwgPyBudWxsIDogYUxpbmU7XG4gICAgdGhpcy5jb2x1bW4gPSBhQ29sdW1uID09IG51bGwgPyBudWxsIDogYUNvbHVtbjtcbiAgICB0aGlzLnNvdXJjZSA9IGFTb3VyY2UgPT0gbnVsbCA/IG51bGwgOiBhU291cmNlO1xuICAgIHRoaXMubmFtZSA9IGFOYW1lID09IG51bGwgPyBudWxsIDogYU5hbWU7XG4gICAgdGhpc1tpc1NvdXJjZU5vZGVdID0gdHJ1ZTtcbiAgICBpZiAoYUNodW5rcyAhPSBudWxsKSB0aGlzLmFkZChhQ2h1bmtzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgU291cmNlTm9kZSBmcm9tIGdlbmVyYXRlZCBjb2RlIGFuZCBhIFNvdXJjZU1hcENvbnN1bWVyLlxuICAgKlxuICAgKiBAcGFyYW0gYUdlbmVyYXRlZENvZGUgVGhlIGdlbmVyYXRlZCBjb2RlXG4gICAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcCBmb3IgdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAqIEBwYXJhbSBhUmVsYXRpdmVQYXRoIE9wdGlvbmFsLiBUaGUgcGF0aCB0aGF0IHJlbGF0aXZlIHNvdXJjZXMgaW4gdGhlXG4gICAqICAgICAgICBTb3VyY2VNYXBDb25zdW1lciBzaG91bGQgYmUgcmVsYXRpdmUgdG8uXG4gICAqL1xuICBTb3VyY2VOb2RlLmZyb21TdHJpbmdXaXRoU291cmNlTWFwID1cbiAgICBmdW5jdGlvbiBTb3VyY2VOb2RlX2Zyb21TdHJpbmdXaXRoU291cmNlTWFwKGFHZW5lcmF0ZWRDb2RlLCBhU291cmNlTWFwQ29uc3VtZXIsIGFSZWxhdGl2ZVBhdGgpIHtcbiAgICAgIC8vIFRoZSBTb3VyY2VOb2RlIHdlIHdhbnQgdG8gZmlsbCB3aXRoIHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgICAgLy8gYW5kIHRoZSBTb3VyY2VNYXBcbiAgICAgIHZhciBub2RlID0gbmV3IFNvdXJjZU5vZGUoKTtcblxuICAgICAgLy8gQWxsIGV2ZW4gaW5kaWNlcyBvZiB0aGlzIGFycmF5IGFyZSBvbmUgbGluZSBvZiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4gICAgICAvLyB3aGlsZSBhbGwgb2RkIGluZGljZXMgYXJlIHRoZSBuZXdsaW5lcyBiZXR3ZWVuIHR3byBhZGphY2VudCBsaW5lc1xuICAgICAgLy8gKHNpbmNlIGBSRUdFWF9ORVdMSU5FYCBjYXB0dXJlcyBpdHMgbWF0Y2gpLlxuICAgICAgLy8gUHJvY2Vzc2VkIGZyYWdtZW50cyBhcmUgcmVtb3ZlZCBmcm9tIHRoaXMgYXJyYXksIGJ5IGNhbGxpbmcgYHNoaWZ0TmV4dExpbmVgLlxuICAgICAgdmFyIHJlbWFpbmluZ0xpbmVzID0gYUdlbmVyYXRlZENvZGUuc3BsaXQoUkVHRVhfTkVXTElORSk7XG4gICAgICB2YXIgc2hpZnROZXh0TGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGluZUNvbnRlbnRzID0gcmVtYWluaW5nTGluZXMuc2hpZnQoKTtcbiAgICAgICAgLy8gVGhlIGxhc3QgbGluZSBvZiBhIGZpbGUgbWlnaHQgbm90IGhhdmUgYSBuZXdsaW5lLlxuICAgICAgICB2YXIgbmV3TGluZSA9IHJlbWFpbmluZ0xpbmVzLnNoaWZ0KCkgfHwgXCJcIjtcbiAgICAgICAgcmV0dXJuIGxpbmVDb250ZW50cyArIG5ld0xpbmU7XG4gICAgICB9O1xuXG4gICAgICAvLyBXZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBwb3NpdGlvbiBvZiBcInJlbWFpbmluZ0xpbmVzXCJcbiAgICAgIHZhciBsYXN0R2VuZXJhdGVkTGluZSA9IDEsIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuXG4gICAgICAvLyBUaGUgZ2VuZXJhdGUgU291cmNlTm9kZXMgd2UgbmVlZCBhIGNvZGUgcmFuZ2UuXG4gICAgICAvLyBUbyBleHRyYWN0IGl0IGN1cnJlbnQgYW5kIGxhc3QgbWFwcGluZyBpcyB1c2VkLlxuICAgICAgLy8gSGVyZSB3ZSBzdG9yZSB0aGUgbGFzdCBtYXBwaW5nLlxuICAgICAgdmFyIGxhc3RNYXBwaW5nID0gbnVsbDtcblxuICAgICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICAgIGlmIChsYXN0TWFwcGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIGFkZCB0aGUgY29kZSBmcm9tIFwibGFzdE1hcHBpbmdcIiB0byBcIm1hcHBpbmdcIjpcbiAgICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGVyZSBpcyBhIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IFwiXCI7XG4gICAgICAgICAgICAvLyBBc3NvY2lhdGUgZmlyc3QgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICAgICAgLy8gVGhlIHJlbWFpbmluZyBjb2RlIGlzIGFkZGVkIHdpdGhvdXQgbWFwcGluZ1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSBjb2RlIGJldHdlZW4gXCJsYXN0R2VuZXJhdGVkQ29sdW1uXCIgYW5kXG4gICAgICAgICAgICAvLyBcIm1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXCIgd2l0aCBcImxhc3RNYXBwaW5nXCJcbiAgICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzWzBdO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgICByZW1haW5pbmdMaW5lc1swXSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgY29kZSk7XG4gICAgICAgICAgICAvLyBObyBtb3JlIHJlbWFpbmluZyBjb2RlLCBjb250aW51ZVxuICAgICAgICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBhZGQgdGhlIGdlbmVyYXRlZCBjb2RlIHVudGlsIHRoZSBmaXJzdCBtYXBwaW5nXG4gICAgICAgIC8vIHRvIHRoZSBTb3VyY2VOb2RlIHdpdGhvdXQgYW55IG1hcHBpbmcuXG4gICAgICAgIC8vIEVhY2ggbGluZSBpcyBhZGRlZCBhcyBzZXBhcmF0ZSBzdHJpbmcuXG4gICAgICAgIHdoaWxlIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIG5vZGUuYWRkKHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdEdlbmVyYXRlZENvbHVtbiA8IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSB7XG4gICAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbMF07XG4gICAgICAgICAgbm9kZS5hZGQobmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSk7XG4gICAgICAgICAgcmVtYWluaW5nTGluZXNbMF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBtYXBwaW5ncy5cbiAgICAgIGlmIChyZW1haW5pbmdMaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChsYXN0TWFwcGluZykge1xuICAgICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgcmVtYWluaW5nIGNvZGUgaW4gdGhlIGN1cnJlbnQgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbmQgYWRkIHRoZSByZW1haW5pbmcgbGluZXMgd2l0aG91dCBhbnkgbWFwcGluZ1xuICAgICAgICBub2RlLmFkZChyZW1haW5pbmdMaW5lcy5qb2luKFwiXCIpKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ29weSBzb3VyY2VzQ29udGVudCBpbnRvIFNvdXJjZU5vZGVcbiAgICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChhUmVsYXRpdmVQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBub2RlO1xuXG4gICAgICBmdW5jdGlvbiBhZGRNYXBwaW5nV2l0aENvZGUobWFwcGluZywgY29kZSkge1xuICAgICAgICBpZiAobWFwcGluZyA9PT0gbnVsbCB8fCBtYXBwaW5nLnNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbm9kZS5hZGQoY29kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IGFSZWxhdGl2ZVBhdGhcbiAgICAgICAgICAgID8gdXRpbC5qb2luKGFSZWxhdGl2ZVBhdGgsIG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgICAgOiBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgICBub2RlLmFkZChuZXcgU291cmNlTm9kZShtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcubmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAvKipcbiAgICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoaXMgc291cmNlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICAgKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfYWRkKGFDaHVuaykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICAgIGFDaHVuay5mb3JFYWNoKGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICB0aGlzLmFkZChjaHVuayk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKGFDaHVuaykge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goYUNodW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBzb3VyY2Ugbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gICAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcHJlcGVuZChhQ2h1bmspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgICBmb3IgKHZhciBpID0gYUNodW5rLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLnByZXBlbmQoYUNodW5rW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhpcy5jaGlsZHJlbi51bnNoaWZ0KGFDaHVuayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBKUyBzbmlwcGV0cyBpbiB0aGlzIG5vZGUgYW5kIGl0cyBjaGlsZHJlbi4gVGhlXG4gICAqIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIG9uY2UgZm9yIGVhY2ggc25pcHBldCBvZiBKUyBhbmQgaXMgcGFzc2VkIHRoYXRcbiAgICogc25pcHBldCBhbmQgdGhlIGl0cyBvcmlnaW5hbCBhc3NvY2lhdGVkIHNvdXJjZSdzIGxpbmUvY29sdW1uIGxvY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gU291cmNlTm9kZV93YWxrKGFGbikge1xuICAgIHZhciBjaHVuaztcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2h1bmsgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGNodW5rW2lzU291cmNlTm9kZV0pIHtcbiAgICAgICAgY2h1bmsud2FsayhhRm4pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChjaHVuayAhPT0gJycpIHtcbiAgICAgICAgICBhRm4oY2h1bmssIHsgc291cmNlOiB0aGlzLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIExpa2UgYFN0cmluZy5wcm90b3R5cGUuam9pbmAgZXhjZXB0IGZvciBTb3VyY2VOb2Rlcy4gSW5zZXJ0cyBgYVN0cmAgYmV0d2VlblxuICAgKiBlYWNoIG9mIGB0aGlzLmNoaWxkcmVuYC5cbiAgICpcbiAgICogQHBhcmFtIGFTZXAgVGhlIHNlcGFyYXRvci5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2pvaW4oYVNlcCkge1xuICAgIHZhciBuZXdDaGlsZHJlbjtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgIG5ld0NoaWxkcmVuID0gW107XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuLTE7IGkrKykge1xuICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgICAgICBuZXdDaGlsZHJlbi5wdXNoKGFTZXApO1xuICAgICAgfVxuICAgICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXdDaGlsZHJlbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGwgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlIG9uIHRoZSB2ZXJ5IHJpZ2h0LW1vc3Qgc291cmNlIHNuaXBwZXQuIFVzZWZ1bFxuICAgKiBmb3IgdHJpbW1pbmcgd2hpdGVzcGFjZSBmcm9tIHRoZSBlbmQgb2YgYSBzb3VyY2Ugbm9kZSwgZXRjLlxuICAgKlxuICAgKiBAcGFyYW0gYVBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gcmVwbGFjZS5cbiAgICogQHBhcmFtIGFSZXBsYWNlbWVudCBUaGUgdGhpbmcgdG8gcmVwbGFjZSB0aGUgcGF0dGVybiB3aXRoLlxuICAgKi9cbiAgU291cmNlTm9kZS5wcm90b3R5cGUucmVwbGFjZVJpZ2h0ID0gZnVuY3Rpb24gU291cmNlTm9kZV9yZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkge1xuICAgIHZhciBsYXN0Q2hpbGQgPSB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RDaGlsZFtpc1NvdXJjZU5vZGVdKSB7XG4gICAgICBsYXN0Q2hpbGQucmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbGFzdENoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdID0gbGFzdENoaWxkLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKCcnLnJlcGxhY2UoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS4gVGhpcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3JcbiAgICogaW4gdGhlIHNvdXJjZXNDb250ZW50IGZpZWxkLlxuICAgKlxuICAgKiBAcGFyYW0gYVNvdXJjZUZpbGUgVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZVxuICAgKiBAcGFyYW0gYVNvdXJjZUNvbnRlbnQgVGhlIGNvbnRlbnQgb2YgdGhlIHNvdXJjZSBmaWxlXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgICBmdW5jdGlvbiBTb3VyY2VOb2RlX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgICB0aGlzLnNvdXJjZUNvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoYVNvdXJjZUZpbGUpXSA9IGFTb3VyY2VDb250ZW50O1xuICAgIH07XG5cbiAgLyoqXG4gICAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBTb3VyY2VOb2Rlcy4gVGhlIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBlYWNoXG4gICAqIHNvdXJjZSBmaWxlIGNvbnRlbnQgYW5kIGlzIHBhc3NlZCB0aGUgZmlsZW5hbWUgYW5kIHNvdXJjZSBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS53YWxrU291cmNlQ29udGVudHMgPVxuICAgIGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2Fsa1NvdXJjZUNvbnRlbnRzKGFGbikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV1baXNTb3VyY2VOb2RlXSkge1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0ud2Fsa1NvdXJjZUNvbnRlbnRzKGFGbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZXMgPSBPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUNvbnRlbnRzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGFGbih1dGlsLmZyb21TZXRTdHJpbmcoc291cmNlc1tpXSksIHRoaXMuc291cmNlQ29udGVudHNbc291cmNlc1tpXV0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUuIFdhbGtzIG92ZXIgdGhlIHRyZWVcbiAgICogYW5kIGNvbmNhdGVuYXRlcyBhbGwgdGhlIHZhcmlvdXMgc25pcHBldHMgdG9nZXRoZXIgdG8gb25lIHN0cmluZy5cbiAgICovXG4gIFNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZygpIHtcbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICBzdHIgKz0gY2h1bms7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUgYWxvbmcgd2l0aCBhIHNvdXJjZVxuICAgKiBtYXAuXG4gICAqL1xuICBTb3VyY2VOb2RlLnByb3RvdHlwZS50b1N0cmluZ1dpdGhTb3VyY2VNYXAgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nV2l0aFNvdXJjZU1hcChhQXJncykge1xuICAgIHZhciBnZW5lcmF0ZWQgPSB7XG4gICAgICBjb2RlOiBcIlwiLFxuICAgICAgbGluZTogMSxcbiAgICAgIGNvbHVtbjogMFxuICAgIH07XG4gICAgdmFyIG1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IoYUFyZ3MpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgdmFyIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgdmFyIGxhc3RPcmlnaW5hbExpbmUgPSBudWxsO1xuICAgIHZhciBsYXN0T3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICAgIHZhciBsYXN0T3JpZ2luYWxOYW1lID0gbnVsbDtcbiAgICB0aGlzLndhbGsoZnVuY3Rpb24gKGNodW5rLCBvcmlnaW5hbCkge1xuICAgICAgZ2VuZXJhdGVkLmNvZGUgKz0gY2h1bms7XG4gICAgICBpZiAob3JpZ2luYWwuc291cmNlICE9PSBudWxsXG4gICAgICAgICAgJiYgb3JpZ2luYWwubGluZSAhPT0gbnVsbFxuICAgICAgICAgICYmIG9yaWdpbmFsLmNvbHVtbiAhPT0gbnVsbCkge1xuICAgICAgICBpZihsYXN0T3JpZ2luYWxTb3VyY2UgIT09IG9yaWdpbmFsLnNvdXJjZVxuICAgICAgICAgICB8fCBsYXN0T3JpZ2luYWxMaW5lICE9PSBvcmlnaW5hbC5saW5lXG4gICAgICAgICAgIHx8IGxhc3RPcmlnaW5hbENvbHVtbiAhPT0gb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgIHx8IGxhc3RPcmlnaW5hbE5hbWUgIT09IG9yaWdpbmFsLm5hbWUpIHtcbiAgICAgICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgIGxpbmU6IG9yaWdpbmFsLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgICBsYXN0T3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgICAgbGFzdE9yaWdpbmFsQ29sdW1uID0gb3JpZ2luYWwuY29sdW1uO1xuICAgICAgICBsYXN0T3JpZ2luYWxOYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpZHggPSAwLCBsZW5ndGggPSBjaHVuay5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgaWYgKGNodW5rLmNoYXJDb2RlQXQoaWR4KSA9PT0gTkVXTElORV9DT0RFKSB7XG4gICAgICAgICAgZ2VuZXJhdGVkLmxpbmUrKztcbiAgICAgICAgICBnZW5lcmF0ZWQuY29sdW1uID0gMDtcbiAgICAgICAgICAvLyBNYXBwaW5ncyBlbmQgYXQgZW9sXG4gICAgICAgICAgaWYgKGlkeCArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZU1hcHBpbmdBY3RpdmUpIHtcbiAgICAgICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdlbmVyYXRlZC5jb2x1bW4rKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMud2Fsa1NvdXJjZUNvbnRlbnRzKGZ1bmN0aW9uIChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KSB7XG4gICAgICBtYXAuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7IGNvZGU6IGdlbmVyYXRlZC5jb2RlLCBtYXA6IG1hcCB9O1xuICB9O1xuXG4gIGV4cG9ydHMuU291cmNlTm9kZSA9IFNvdXJjZU5vZGU7XG5cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spLWNvcmUvfi9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwL3NvdXJjZS1ub2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLlNvdXJjZUxpc3RNYXAgPSByZXF1aXJlKFwiLi9Tb3VyY2VMaXN0TWFwXCIpO1xyXG5leHBvcnRzLlNvdXJjZU5vZGUgPSByZXF1aXJlKFwiLi9Tb3VyY2VOb2RlXCIpO1xyXG5leHBvcnRzLkNvZGVOb2RlID0gcmVxdWlyZShcIi4vQ29kZU5vZGVcIik7XHJcbmV4cG9ydHMuTWFwcGluZ3NDb250ZXh0ID0gcmVxdWlyZShcIi4vTWFwcGluZ3NDb250ZXh0XCIpO1xyXG5leHBvcnRzLmZyb21TdHJpbmdXaXRoU291cmNlTWFwID0gcmVxdWlyZShcIi4vZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXBcIik7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zb3VyY2UtbGlzdC1tYXAvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgQ29kZU5vZGUgPSByZXF1aXJlKFwiLi9Db2RlTm9kZVwiKTtcclxudmFyIFNvdXJjZU5vZGUgPSByZXF1aXJlKFwiLi9Tb3VyY2VOb2RlXCIpO1xyXG52YXIgTWFwcGluZ3NDb250ZXh0ID0gcmVxdWlyZShcIi4vTWFwcGluZ3NDb250ZXh0XCIpO1xyXG5cclxuZnVuY3Rpb24gU291cmNlTGlzdE1hcChnZW5lcmF0ZWRDb2RlLCBzb3VyY2UsIG9yaWdpbmFsU291cmNlKSB7XHJcblx0aWYoQXJyYXkuaXNBcnJheShnZW5lcmF0ZWRDb2RlKSkge1xyXG5cdFx0dGhpcy5jaGlsZHJlbiA9IGdlbmVyYXRlZENvZGU7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuXHRcdGlmKGdlbmVyYXRlZENvZGUgfHwgc291cmNlKVxyXG5cdFx0XHR0aGlzLmFkZChnZW5lcmF0ZWRDb2RlLCBzb3VyY2UsIG9yaWdpbmFsU291cmNlKTtcclxuXHR9XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBTb3VyY2VMaXN0TWFwO1xyXG5cclxuU291cmNlTGlzdE1hcC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oZ2VuZXJhdGVkQ29kZSwgc291cmNlLCBvcmlnaW5hbFNvdXJjZSkge1xyXG5cdGlmKHR5cGVvZiBnZW5lcmF0ZWRDb2RlID09PSBcInN0cmluZ1wiKSB7XHJcblx0XHRpZihzb3VyY2UpIHtcclxuXHRcdFx0dGhpcy5jaGlsZHJlbi5wdXNoKG5ldyBTb3VyY2VOb2RlKGdlbmVyYXRlZENvZGUsIHNvdXJjZSwgb3JpZ2luYWxTb3VyY2UpKTtcclxuXHRcdH0gZWxzZSBpZih0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgdGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdLmFkZEdlbmVyYXRlZENvZGUpIHtcclxuXHRcdFx0dGhpcy5jaGlsZHJlblt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdLmFkZEdlbmVyYXRlZENvZGUoZ2VuZXJhdGVkQ29kZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLmNoaWxkcmVuLnB1c2gobmV3IENvZGVOb2RlKGdlbmVyYXRlZENvZGUpKTtcclxuXHRcdH1cclxuXHR9IGVsc2UgaWYoZ2VuZXJhdGVkQ29kZS5nZXRNYXBwaW5ncyAmJiBnZW5lcmF0ZWRDb2RlLmdldEdlbmVyYXRlZENvZGUpIHtcclxuXHRcdHRoaXMuY2hpbGRyZW4ucHVzaChnZW5lcmF0ZWRDb2RlKTtcclxuXHR9IGVsc2UgaWYoZ2VuZXJhdGVkQ29kZS5jaGlsZHJlbikge1xyXG5cdFx0Z2VuZXJhdGVkQ29kZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKHNsbikge1xyXG5cdFx0XHR0aGlzLmNoaWxkcmVuLnB1c2goc2xuKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50cyB0byBTb3VyY2VMaXN0TWFwLnByb3RvdHlwZS5hZGQ6IEV4cGVjdGVkIHN0cmluZywgTm9kZSBvciBTb3VyY2VMaXN0TWFwXCIpO1xyXG5cdH1cclxufTtcclxuXHJcblNvdXJjZUxpc3RNYXAucHJvdG90eXBlLnByZXByZW5kID0gZnVuY3Rpb24oc291cmNlKSB7XHJcblx0aWYodHlwZW9mIGdlbmVyYXRlZENvZGUgPT09IFwic3RyaW5nXCIpIHtcclxuXHRcdGlmKHNvdXJjZSkge1xyXG5cdFx0XHR0aGlzLmNoaWxkcmVuLnVuc2hpZnQobmV3IFNvdXJjZU5vZGUoZ2VuZXJhdGVkQ29kZSwgc291cmNlLCBvcmlnaW5hbFNvdXJjZSkpO1xyXG5cdFx0fSBlbHNlIGlmKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMCAmJiB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV0ucHJlcHJlbmRHZW5lcmF0ZWRDb2RlKSB7XHJcblx0XHRcdHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXS5wcmVwcmVuZEdlbmVyYXRlZENvZGUoZ2VuZXJhdGVkQ29kZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLmNoaWxkcmVuLnVuc2hpZnQobmV3IENvZGVOb2RlKGdlbmVyYXRlZENvZGUpKTtcclxuXHRcdH1cclxuXHR9IGVsc2UgaWYoZ2VuZXJhdGVkQ29kZS5nZXRNYXBwaW5ncyAmJiBnZW5lcmF0ZWRDb2RlLmdldEdlbmVyYXRlZENvZGUpIHtcclxuXHRcdHRoaXMuY2hpbGRyZW4udW5zaGlmdChnZW5lcmF0ZWRDb2RlKTtcclxuXHR9IGVsc2UgaWYoZ2VuZXJhdGVkQ29kZS5jaGlsZHJlbikge1xyXG5cdFx0Z2VuZXJhdGVkQ29kZS5jaGlsZHJlbi5zbGljZSgpLnJldmVyc2UoKS5mb3JFYWNoKGZ1bmN0aW9uKHNsbikge1xyXG5cdFx0XHR0aGlzLmNoaWxkcmVuLnVuc2hpZnQoc2xuKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50cyB0byBTb3VyY2VMaXN0TWFwLnByb3RvdHlwZS5wcmVyZW5kOiBFeHBlY3RlZCBzdHJpbmcsIE5vZGUgb3IgU291cmNlTGlzdE1hcFwiKTtcclxuXHR9XHJcbn07XHJcblxyXG5Tb3VyY2VMaXN0TWFwLnByb3RvdHlwZS5tYXBHZW5lcmF0ZWRDb2RlID0gZnVuY3Rpb24oZm4pIHtcclxuXHR0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oc2xuKSB7XHJcblx0XHRzbG4ubWFwR2VuZXJhdGVkQ29kZShmbik7XHJcblx0fSk7XHJcbn07XHJcblxyXG5Tb3VyY2VMaXN0TWFwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLmNoaWxkcmVuLm1hcChmdW5jdGlvbihzbG4pIHtcclxuXHRcdHJldHVybiBzbG4uZ2V0R2VuZXJhdGVkQ29kZSgpO1xyXG5cdH0pLmpvaW4oXCJcIik7XHJcbn07XHJcblxyXG5Tb3VyY2VMaXN0TWFwLnByb3RvdHlwZS50b1N0cmluZ1dpdGhTb3VyY2VNYXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0dmFyIG1hcHBpbmdzQ29udGV4dCA9IG5ldyBNYXBwaW5nc0NvbnRleHQoKTtcclxuXHR2YXIgc291cmNlID0gdGhpcy5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oc2xuKSB7XHJcblx0XHRyZXR1cm4gc2xuLmdlbmVyYXRlZENvZGU7XHJcblx0fSkuam9pbihcIlwiKTtcclxuXHR2YXIgbWFwcGluZ3MgPSB0aGlzLmNoaWxkcmVuLm1hcChmdW5jdGlvbihzbG4pIHtcclxuXHRcdHJldHVybiBzbG4uZ2V0TWFwcGluZ3MobWFwcGluZ3NDb250ZXh0KTtcclxuXHR9KS5qb2luKFwiXCIpO1xyXG5cdHJldHVybiB7XHJcblx0XHRzb3VyY2U6IHNvdXJjZSxcclxuXHRcdG1hcDoge1xyXG5cdFx0XHR2ZXJzaW9uOiAzLFxyXG5cdFx0XHRmaWxlOiBvcHRpb25zICYmIG9wdGlvbnMuZmlsZSxcclxuXHRcdFx0c291cmNlczogbWFwcGluZ3NDb250ZXh0LnNvdXJjZXMsXHJcblx0XHRcdHNvdXJjZXNDb250ZW50OiBtYXBwaW5nc0NvbnRleHQuaGFzU291cmNlQ29udGVudCA/IG1hcHBpbmdzQ29udGV4dC5zb3VyY2VzQ29udGVudCA6IHVuZGVmaW5lZCxcclxuXHRcdFx0bWFwcGluZ3M6IG1hcHBpbmdzXHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc291cmNlLWxpc3QtbWFwL2xpYi9Tb3VyY2VMaXN0TWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgZ2V0TnVtYmVyT2ZMaW5lcyA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIikuZ2V0TnVtYmVyT2ZMaW5lcztcclxuXHJcbmZ1bmN0aW9uIENvZGVOb2RlKGdlbmVyYXRlZENvZGUpIHtcclxuXHR0aGlzLmdlbmVyYXRlZENvZGUgPSBnZW5lcmF0ZWRDb2RlO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gQ29kZU5vZGU7XHJcblxyXG5Db2RlTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbmV3IENvZGVOb2RlKHRoaXMuZ2VuZXJhdGVkQ29kZSk7XHJcbn1cclxuXHJcbkNvZGVOb2RlLnByb3RvdHlwZS5nZXRHZW5lcmF0ZWRDb2RlID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuZ2VuZXJhdGVkQ29kZTtcclxufTtcclxuXHJcbkNvZGVOb2RlLnByb3RvdHlwZS5nZXRNYXBwaW5ncyA9IGZ1bmN0aW9uKG1hcHBpbmdzQ29udGV4dCkge1xyXG5cdHZhciBsaW5lcyA9IGdldE51bWJlck9mTGluZXModGhpcy5nZW5lcmF0ZWRDb2RlKTtcclxuXHRyZXR1cm4gQXJyYXkobGluZXMrMSkuam9pbihcIjtcIik7XHJcbn07XHJcblxyXG5Db2RlTm9kZS5wcm90b3R5cGUuYWRkR2VuZXJhdGVkQ29kZSA9IGZ1bmN0aW9uKGdlbmVyYXRlZENvZGUpIHtcclxuXHR0aGlzLmdlbmVyYXRlZENvZGUgKz0gZ2VuZXJhdGVkQ29kZTtcclxufTtcclxuXHJcbkNvZGVOb2RlLnByb3RvdHlwZS5tYXBHZW5lcmF0ZWRDb2RlID0gZnVuY3Rpb24oZm4pIHtcclxuXHR0aGlzLmdlbmVyYXRlZENvZGUgPSBmbih0aGlzLmdlbmVyYXRlZENvZGUpO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc291cmNlLWxpc3QtbWFwL2xpYi9Db2RlTm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuZXhwb3J0cy5nZXROdW1iZXJPZkxpbmVzID0gZnVuY3Rpb24gZ2V0TnVtYmVyT2ZMaW5lcyhzdHIpIHtcclxuXHR2YXIgbnIgPSAtMTtcclxuXHR2YXIgaWR4ID0gLTE7XHJcblx0ZG8ge1xyXG5cdFx0bnIrK1xyXG5cdFx0aWR4ID0gc3RyLmluZGV4T2YoXCJcXG5cIiwgaWR4ICsgMSk7XHJcblx0fSB3aGlsZShpZHggPj0gMCk7XHJcblx0cmV0dXJuIG5yO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc291cmNlLWxpc3QtbWFwL2xpYi9oZWxwZXJzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgYmFzZTY0VkxRID0gcmVxdWlyZShcIi4vYmFzZTY0LXZscVwiKTtcclxudmFyIGdldE51bWJlck9mTGluZXMgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpLmdldE51bWJlck9mTGluZXM7XHJcblxyXG5mdW5jdGlvbiBTb3VyY2VOb2RlKGdlbmVyYXRlZENvZGUsIHNvdXJjZSwgb3JpZ2luYWxTb3VyY2UsIHN0YXJ0aW5nTGluZSkge1xyXG5cdHRoaXMuZ2VuZXJhdGVkQ29kZSA9IGdlbmVyYXRlZENvZGU7XHJcblx0dGhpcy5vcmlnaW5hbFNvdXJjZSA9IG9yaWdpbmFsU291cmNlO1xyXG5cdHRoaXMuc291cmNlID0gc291cmNlO1xyXG5cdHRoaXMuc3RhcnRpbmdMaW5lID0gc3RhcnRpbmdMaW5lIHx8IDE7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBTb3VyY2VOb2RlO1xyXG5cclxuU291cmNlTm9kZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbmV3IFNvdXJjZU5vZGUodGhpcy5nZW5lcmF0ZWRDb2RlLCB0aGlzLnNvdXJjZSwgdGhpcy5vcmlnaW5hbFNvdXJjZSwgdGhpcy5zdGFydGluZ0xpbmUpO1xyXG59XHJcblxyXG52YXIgTElORV9NQVBQSU5HID0gXCJBQUNBO1wiO1xyXG52YXIgTEFTVF9MSU5FX01BUFBJTkcgPSBcIkFBQ0FcIjtcclxuXHJcblNvdXJjZU5vZGUucHJvdG90eXBlLmdldEdlbmVyYXRlZENvZGUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5nZW5lcmF0ZWRDb2RlO1xyXG59O1xyXG5cclxuU291cmNlTm9kZS5wcm90b3R5cGUuZ2V0TWFwcGluZ3MgPSBmdW5jdGlvbihtYXBwaW5nc0NvbnRleHQpIHtcclxuXHR2YXIgbGluZXMgPSBnZXROdW1iZXJPZkxpbmVzKHRoaXMuZ2VuZXJhdGVkQ29kZSk7XHJcblx0dmFyIHNvdXJjZUlkeCA9IG1hcHBpbmdzQ29udGV4dC5lbnN1cmVTb3VyY2UodGhpcy5zb3VyY2UsIHRoaXMub3JpZ2luYWxTb3VyY2UpO1xyXG5cdHZhciBtYXBwaW5ncyA9IFwiQVwiOyAvLyBnZW5lcmF0ZWQgY29sdW1uIDBcclxuXHRtYXBwaW5ncyArPSBiYXNlNjRWTFEuZW5jb2RlKHNvdXJjZUlkeCAtIG1hcHBpbmdzQ29udGV4dC5jdXJyZW50U291cmNlKTsgLy8gc291cmNlIGluZGV4XHJcblx0bWFwcGluZ3MgKz0gYmFzZTY0VkxRLmVuY29kZSh0aGlzLnN0YXJ0aW5nTGluZSAtIG1hcHBpbmdzQ29udGV4dC5jdXJyZW50T3JpZ2luYWxMaW5lKTsgLy8gb3JpZ2luYWwgbGluZSBpbmRleFxyXG5cdG1hcHBpbmdzICs9IFwiQVwiOyAvLyBvcmlnaW5hbCBjb2x1bW4gMFxyXG5cdGlmKGxpbmVzICE9PSAwKVxyXG5cdFx0bWFwcGluZ3MgKz0gXCI7XCJcclxuXHRtYXBwaW5nc0NvbnRleHQuY3VycmVudFNvdXJjZSA9IHNvdXJjZUlkeDtcclxuXHRtYXBwaW5nc0NvbnRleHQuY3VycmVudE9yaWdpbmFsTGluZSA9IChsaW5lcyB8fCAxKSArIHRoaXMuc3RhcnRpbmdMaW5lIC0gMTtcclxuXHRtYXBwaW5ncyArPSBBcnJheShsaW5lcykuam9pbihMSU5FX01BUFBJTkcpO1xyXG5cdGlmKGxpbmVzICE9PSAwICYmIHRoaXMuZ2VuZXJhdGVkQ29kZVt0aGlzLmdlbmVyYXRlZENvZGUubGVuZ3RoIC0gMV0gIT09IFwiXFxuXCIpIHtcclxuXHRcdG1hcHBpbmdzICs9IExBU1RfTElORV9NQVBQSU5HO1xyXG5cdFx0bWFwcGluZ3NDb250ZXh0LmN1cnJlbnRPcmlnaW5hbExpbmUrKztcclxuXHR9XHJcblx0cmV0dXJuIG1hcHBpbmdzO1xyXG59O1xyXG5cclxuU291cmNlTm9kZS5wcm90b3R5cGUubWFwR2VuZXJhdGVkQ29kZSA9IGZ1bmN0aW9uKGZuKSB7XHJcblx0dGhpcy5nZW5lcmF0ZWRDb2RlID0gZm4odGhpcy5nZW5lcmF0ZWRDb2RlKTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvdXJjZS1saXN0LW1hcC9saWIvU291cmNlTm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcclxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxyXG4gKlxyXG4gKiBCYXNlZCBvbiB0aGUgQmFzZSA2NCBWTFEgaW1wbGVtZW50YXRpb24gaW4gQ2xvc3VyZSBDb21waWxlcjpcclxuICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jbG9zdXJlLWNvbXBpbGVyL3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL2NvbS9nb29nbGUvZGVidWdnaW5nL3NvdXJjZW1hcC9CYXNlNjRWTFEuamF2YVxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgMjAxMSBUaGUgQ2xvc3VyZSBDb21waWxlciBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcclxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxyXG4gKiBtZXQ6XHJcbiAqXHJcbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XHJcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cclxuICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxyXG4gKiAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xyXG4gKiAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcclxuICogICAgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4gKiAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXHJcbiAqICAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZFxyXG4gKiAgICBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXHJcbiAqXHJcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcclxuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxyXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcclxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcclxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXHJcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcclxuICogTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXHJcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxyXG4gKiBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXHJcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxyXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxyXG4gKi9cclxuXHJcbi8qZXNsaW50IG5vLWJpdHdpc2U6MCxxdW90ZXM6MCxnbG9iYWwtc3RyaWN0OjAqL1xyXG5cclxudmFyIGNoYXJUb0ludE1hcCA9IHt9O1xyXG52YXIgaW50VG9DaGFyTWFwID0ge307XHJcblxyXG4nQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcclxuICAuc3BsaXQoJycpXHJcbiAgLmZvckVhY2goZnVuY3Rpb24gKGNoLCBpbmRleCkge1xyXG4gICAgY2hhclRvSW50TWFwW2NoXSA9IGluZGV4O1xyXG4gICAgaW50VG9DaGFyTWFwW2luZGV4XSA9IGNoO1xyXG4gIH0pO1xyXG5cclxudmFyIGJhc2U2NCA9IHt9O1xyXG4vKipcclxuICogRW5jb2RlIGFuIGludGVnZXIgaW4gdGhlIHJhbmdlIG9mIDAgdG8gNjMgdG8gYSBzaW5nbGUgYmFzZSA2NCBkaWdpdC5cclxuICovXHJcbmJhc2U2NC5lbmNvZGUgPSBmdW5jdGlvbiBiYXNlNjRfZW5jb2RlKGFOdW1iZXIpIHtcclxuICBpZiAoYU51bWJlciBpbiBpbnRUb0NoYXJNYXApIHtcclxuICAgIHJldHVybiBpbnRUb0NoYXJNYXBbYU51bWJlcl07XHJcbiAgfVxyXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNdXN0IGJlIGJldHdlZW4gMCBhbmQgNjM6IFwiICsgYU51bWJlcik7XHJcbn07XHJcblxyXG4vKipcclxuICogRGVjb2RlIGEgc2luZ2xlIGJhc2UgNjQgZGlnaXQgdG8gYW4gaW50ZWdlci5cclxuICovXHJcbmJhc2U2NC5kZWNvZGUgPSBmdW5jdGlvbiBiYXNlNjRfZGVjb2RlKGFDaGFyKSB7XHJcbiAgaWYgKGFDaGFyIGluIGNoYXJUb0ludE1hcCkge1xyXG4gICAgcmV0dXJuIGNoYXJUb0ludE1hcFthQ2hhcl07XHJcbiAgfVxyXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJOb3QgYSB2YWxpZCBiYXNlIDY0IGRpZ2l0OiBcIiArIGFDaGFyKTtcclxufTtcclxuXHJcblxyXG5cclxuLy8gQSBzaW5nbGUgYmFzZSA2NCBkaWdpdCBjYW4gY29udGFpbiA2IGJpdHMgb2YgZGF0YS4gRm9yIHRoZSBiYXNlIDY0IHZhcmlhYmxlXHJcbi8vIGxlbmd0aCBxdWFudGl0aWVzIHdlIHVzZSBpbiB0aGUgc291cmNlIG1hcCBzcGVjLCB0aGUgZmlyc3QgYml0IGlzIHRoZSBzaWduLFxyXG4vLyB0aGUgbmV4dCBmb3VyIGJpdHMgYXJlIHRoZSBhY3R1YWwgdmFsdWUsIGFuZCB0aGUgNnRoIGJpdCBpcyB0aGVcclxuLy8gY29udGludWF0aW9uIGJpdC4gVGhlIGNvbnRpbnVhdGlvbiBiaXQgdGVsbHMgdXMgd2hldGhlciB0aGVyZSBhcmUgbW9yZVxyXG4vLyBkaWdpdHMgaW4gdGhpcyB2YWx1ZSBmb2xsb3dpbmcgdGhpcyBkaWdpdC5cclxuLy9cclxuLy8gICBDb250aW51YXRpb25cclxuLy8gICB8ICAgIFNpZ25cclxuLy8gICB8ICAgIHxcclxuLy8gICBWICAgIFZcclxuLy8gICAxMDEwMTFcclxuXHJcbnZhciBWTFFfQkFTRV9TSElGVCA9IDU7XHJcblxyXG4vLyBiaW5hcnk6IDEwMDAwMFxyXG52YXIgVkxRX0JBU0UgPSAxIDw8IFZMUV9CQVNFX1NISUZUO1xyXG5cclxuLy8gYmluYXJ5OiAwMTExMTFcclxudmFyIFZMUV9CQVNFX01BU0sgPSBWTFFfQkFTRSAtIDE7XHJcblxyXG4vLyBiaW5hcnk6IDEwMDAwMFxyXG52YXIgVkxRX0NPTlRJTlVBVElPTl9CSVQgPSBWTFFfQkFTRTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBmcm9tIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgdG8gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcclxuICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XHJcbiAqICAgMSBiZWNvbWVzIDIgKDEwIGJpbmFyeSksIC0xIGJlY29tZXMgMyAoMTEgYmluYXJ5KVxyXG4gKiAgIDIgYmVjb21lcyA0ICgxMDAgYmluYXJ5KSwgLTIgYmVjb21lcyA1ICgxMDEgYmluYXJ5KVxyXG4gKi9cclxuZnVuY3Rpb24gdG9WTFFTaWduZWQoYVZhbHVlKSB7XHJcbiAgcmV0dXJuIGFWYWx1ZSA8IDBcclxuICAgID8gKCgtYVZhbHVlKSA8PCAxKSArIDFcclxuICAgIDogKGFWYWx1ZSA8PCAxKSArIDA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0byBhIHR3by1jb21wbGVtZW50IHZhbHVlIGZyb20gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcclxuICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XHJcbiAqICAgMiAoMTAgYmluYXJ5KSBiZWNvbWVzIDEsIDMgKDExIGJpbmFyeSkgYmVjb21lcyAtMVxyXG4gKiAgIDQgKDEwMCBiaW5hcnkpIGJlY29tZXMgMiwgNSAoMTAxIGJpbmFyeSkgYmVjb21lcyAtMlxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbVZMUVNpZ25lZChhVmFsdWUpIHtcclxuICB2YXIgaXNOZWdhdGl2ZSA9IChhVmFsdWUgJiAxKSA9PT0gMTtcclxuICB2YXIgc2hpZnRlZCA9IGFWYWx1ZSA+PiAxO1xyXG4gIHJldHVybiBpc05lZ2F0aXZlXHJcbiAgICA/IC1zaGlmdGVkXHJcbiAgICA6IHNoaWZ0ZWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiYXNlIDY0IFZMUSBlbmNvZGVkIHZhbHVlLlxyXG4gKi9cclxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZW5jb2RlKGFWYWx1ZSkge1xyXG4gIHZhciBlbmNvZGVkID0gXCJcIjtcclxuICB2YXIgZGlnaXQ7XHJcblxyXG4gIHZhciB2bHEgPSB0b1ZMUVNpZ25lZChhVmFsdWUpO1xyXG5cclxuICBkbyB7XHJcbiAgICBkaWdpdCA9IHZscSAmIFZMUV9CQVNFX01BU0s7XHJcbiAgICB2bHEgPj4+PSBWTFFfQkFTRV9TSElGVDtcclxuICAgIGlmICh2bHEgPiAwKSB7XHJcbiAgICAgIC8vIFRoZXJlIGFyZSBzdGlsbCBtb3JlIGRpZ2l0cyBpbiB0aGlzIHZhbHVlLCBzbyB3ZSBtdXN0IG1ha2Ugc3VyZSB0aGVcclxuICAgICAgLy8gY29udGludWF0aW9uIGJpdCBpcyBtYXJrZWQuXHJcbiAgICAgIGRpZ2l0IHw9IFZMUV9DT05USU5VQVRJT05fQklUO1xyXG4gICAgfVxyXG4gICAgZW5jb2RlZCArPSBiYXNlNjQuZW5jb2RlKGRpZ2l0KTtcclxuICB9IHdoaWxlICh2bHEgPiAwKTtcclxuXHJcbiAgcmV0dXJuIGVuY29kZWQ7XHJcbn07XHJcblxyXG4vKipcclxuICogRGVjb2RlcyB0aGUgbmV4dCBiYXNlIDY0IFZMUSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldHVybnMgdGhlXHJcbiAqIHZhbHVlIGFuZCB0aGUgcmVzdCBvZiB0aGUgc3RyaW5nIHZpYSB0aGUgb3V0IHBhcmFtZXRlci5cclxuICovXHJcbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2RlY29kZShhU3RyLCBhT3V0UGFyYW0pIHtcclxuICB2YXIgaSA9IDA7XHJcbiAgdmFyIHN0ckxlbiA9IGFTdHIubGVuZ3RoO1xyXG4gIHZhciByZXN1bHQgPSAwO1xyXG4gIHZhciBzaGlmdCA9IDA7XHJcbiAgdmFyIGNvbnRpbnVhdGlvbiwgZGlnaXQ7XHJcblxyXG4gIGRvIHtcclxuICAgIGlmIChpID49IHN0ckxlbikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBtb3JlIGRpZ2l0cyBpbiBiYXNlIDY0IFZMUSB2YWx1ZS5cIik7XHJcbiAgICB9XHJcbiAgICBkaWdpdCA9IGJhc2U2NC5kZWNvZGUoYVN0ci5jaGFyQXQoaSsrKSk7XHJcbiAgICBjb250aW51YXRpb24gPSAhIShkaWdpdCAmIFZMUV9DT05USU5VQVRJT05fQklUKTtcclxuICAgIGRpZ2l0ICY9IFZMUV9CQVNFX01BU0s7XHJcbiAgICByZXN1bHQgPSByZXN1bHQgKyAoZGlnaXQgPDwgc2hpZnQpO1xyXG4gICAgc2hpZnQgKz0gVkxRX0JBU0VfU0hJRlQ7XHJcbiAgfSB3aGlsZSAoY29udGludWF0aW9uKTtcclxuXHJcbiAgYU91dFBhcmFtLnZhbHVlID0gZnJvbVZMUVNpZ25lZChyZXN1bHQpO1xyXG4gIGFPdXRQYXJhbS5yZXN0ID0gYVN0ci5zbGljZShpKTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3NvdXJjZS1saXN0LW1hcC9saWIvYmFzZTY0LXZscS5qc1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuZnVuY3Rpb24gTWFwcGluZ3NDb250ZXh0KCkge1xyXG5cdHRoaXMuc291cmNlcyA9IFtdO1xyXG5cdHRoaXMuc291cmNlc0NvbnRlbnQgPSBbXTtcclxuXHR0aGlzLmhhc1NvdXJjZUNvbnRlbnQgPSBmYWxzZTtcclxuXHR0aGlzLmN1cnJlbnRPcmlnaW5hbExpbmUgPSAxO1xyXG5cdHRoaXMuY3VycmVudFNvdXJjZSA9IDA7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBNYXBwaW5nc0NvbnRleHQ7XHJcblxyXG5NYXBwaW5nc0NvbnRleHQucHJvdG90eXBlLmVuc3VyZVNvdXJjZSA9IGZ1bmN0aW9uKHNvdXJjZSwgb3JpZ2luYWxTb3VyY2UpIHtcclxuXHR2YXIgaWR4ID0gdGhpcy5zb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcclxuXHRpZihpZHggPj0gMClcclxuXHRcdHJldHVybiBpZHg7XHJcblx0aWR4ID0gdGhpcy5zb3VyY2VzLmxlbmd0aDtcclxuXHR0aGlzLnNvdXJjZXMucHVzaChzb3VyY2UpO1xyXG5cdHRoaXMuc291cmNlc0NvbnRlbnQucHVzaChvcmlnaW5hbFNvdXJjZSk7XHJcblx0aWYodHlwZW9mIG9yaWdpbmFsU291cmNlID09PSBcInN0cmluZ1wiKVxyXG5cdFx0dGhpcy5oYXNTb3VyY2VDb250ZW50ID0gdHJ1ZTtcclxuXHRyZXR1cm4gaWR4O1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc291cmNlLWxpc3QtbWFwL2xpYi9NYXBwaW5nc0NvbnRleHQuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBiYXNlNjRWTFEgPSByZXF1aXJlKFwiLi9iYXNlNjQtdmxxXCIpO1xyXG52YXIgU291cmNlTm9kZSA9IHJlcXVpcmUoXCIuL1NvdXJjZU5vZGVcIik7XHJcbnZhciBDb2RlTm9kZSA9IHJlcXVpcmUoXCIuL0NvZGVOb2RlXCIpO1xyXG52YXIgU291cmNlTGlzdE1hcCA9IHJlcXVpcmUoXCIuL1NvdXJjZUxpc3RNYXBcIik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZyb21TdHJpbmdXaXRoU291cmNlTWFwKGNvZGUsIG1hcCkge1xyXG5cdHZhciBzb3VyY2VzID0gbWFwLnNvdXJjZXM7XHJcblx0dmFyIHNvdXJjZXNDb250ZW50ID0gbWFwLnNvdXJjZXNDb250ZW50O1xyXG5cdHZhciBtYXBwaW5ncyA9IG1hcC5tYXBwaW5ncy5zcGxpdChcIjtcIik7XHJcblx0dmFyIGxpbmVzID0gY29kZS5zcGxpdChcIlxcblwiKTtcclxuXHR2YXIgbm9kZXMgPSBbXTtcclxuXHR2YXIgY3VycmVudE5vZGUgPSBudWxsO1xyXG5cdHZhciBjdXJyZW50TGluZSA9IDE7XHJcblx0dmFyIGN1cnJlbnRTb3VyY2VJZHggPSAwO1xyXG5cdHZhciBjdXJyZW50U291cmNlTm9kZUxpbmU7XHJcblx0bWFwcGluZ3MuZm9yRWFjaChmdW5jdGlvbihtYXBwaW5nLCBpZHgpIHtcclxuXHRcdHZhciBsaW5lID0gbGluZXNbaWR4XTtcclxuXHRcdGlmKHR5cGVvZiBsaW5lID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xyXG5cdFx0aWYoaWR4ICE9PSBsaW5lcy5sZW5ndGggLSAxKSBsaW5lICs9IFwiXFxuXCI7XHJcblx0XHRpZighbWFwcGluZylcclxuXHRcdFx0cmV0dXJuIGFkZENvZGUobGluZSk7XHJcblx0XHRtYXBwaW5nID0geyB2YWx1ZTogMCwgcmVzdDogbWFwcGluZyB9O1xyXG5cdFx0dmFyIGxpbmVBZGRlZCA9IGZhbHNlO1xyXG5cdFx0d2hpbGUobWFwcGluZy5yZXN0KVxyXG5cdFx0XHRsaW5lQWRkZWQgPSBwcm9jZXNzTWFwcGluZyhtYXBwaW5nLCBsaW5lLCBsaW5lQWRkZWQpIHx8IGxpbmVBZGRlZDtcclxuXHRcdGlmKCFsaW5lQWRkZWQpXHJcblx0XHRcdGFkZENvZGUobGluZSk7XHJcblx0fSk7XHJcblx0aWYobWFwcGluZ3MubGVuZ3RoIDwgbGluZXMubGVuZ3RoKSB7XHJcblx0XHR2YXIgaWR4ID0gbWFwcGluZ3MubGVuZ3RoO1xyXG5cdFx0d2hpbGUoIWxpbmVzW2lkeF0udHJpbSgpICYmIGlkeCA8IGxpbmVzLmxlbmd0aC0xKSB7XHJcblx0XHRcdGFkZENvZGUobGluZXNbaWR4XSArIFwiXFxuXCIpO1xyXG5cdFx0XHRpZHgrKztcclxuXHRcdH1cclxuXHRcdGFkZENvZGUobGluZXMuc2xpY2UoaWR4KS5qb2luKFwiXFxuXCIpKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBTb3VyY2VMaXN0TWFwKG5vZGVzKTtcclxuXHRmdW5jdGlvbiBwcm9jZXNzTWFwcGluZyhtYXBwaW5nLCBsaW5lLCBpZ25vcmUpIHtcclxuXHRcdGlmKG1hcHBpbmcucmVzdCAmJiBtYXBwaW5nLnJlc3RbMF0gIT09IFwiLFwiKSB7XHJcblx0XHRcdGJhc2U2NFZMUS5kZWNvZGUobWFwcGluZy5yZXN0LCBtYXBwaW5nKTtcclxuXHRcdH1cclxuXHRcdGlmKCFtYXBwaW5nLnJlc3QpXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdGlmKG1hcHBpbmcucmVzdFswXSA9PT0gXCIsXCIpIHtcclxuXHRcdFx0bWFwcGluZy5yZXN0ID0gbWFwcGluZy5yZXN0LnN1YnN0cigxKTtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGJhc2U2NFZMUS5kZWNvZGUobWFwcGluZy5yZXN0LCBtYXBwaW5nKTtcclxuXHRcdHZhciBzb3VyY2VJZHggPSBtYXBwaW5nLnZhbHVlICsgY3VycmVudFNvdXJjZUlkeDtcclxuXHRcdGN1cnJlbnRTb3VyY2VJZHggPSBzb3VyY2VJZHg7XHJcblxyXG5cdFx0aWYobWFwcGluZy5yZXN0ICYmIG1hcHBpbmcucmVzdFswXSAhPT0gXCIsXCIpIHtcclxuXHRcdFx0YmFzZTY0VkxRLmRlY29kZShtYXBwaW5nLnJlc3QsIG1hcHBpbmcpO1xyXG5cdFx0XHR2YXIgbGluZVBvc2l0aW9uID0gbWFwcGluZy52YWx1ZSArIGN1cnJlbnRMaW5lO1xyXG5cdFx0XHRjdXJyZW50TGluZSA9IGxpbmVQb3NpdGlvbjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciBsaW5lUG9zaXRpb24gPSBjdXJyZW50TGluZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZihtYXBwaW5nLnJlc3QpIHtcclxuXHRcdFx0dmFyIG5leHQgPSBtYXBwaW5nLnJlc3QuaW5kZXhPZihcIixcIik7XHJcblx0XHRcdG1hcHBpbmcucmVzdCA9IG5leHQgPT09IC0xID8gXCJcIiA6IG1hcHBpbmcucmVzdC5zdWJzdHIobmV4dCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoIWlnbm9yZSkge1xyXG5cdFx0XHRhZGRTb3VyY2UobGluZSwgc291cmNlcyA/IHNvdXJjZXNbc291cmNlSWR4XSA6IG51bGwsIHNvdXJjZXNDb250ZW50ID8gc291cmNlc0NvbnRlbnRbc291cmNlSWR4XSA6IG51bGwsIGxpbmVQb3NpdGlvbilcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblx0fVxyXG5cdGZ1bmN0aW9uIGFkZENvZGUoZ2VuZXJhdGVkQ29kZSkge1xyXG5cdFx0aWYoY3VycmVudE5vZGUgJiYgY3VycmVudE5vZGUgaW5zdGFuY2VvZiBDb2RlTm9kZSkge1xyXG5cdFx0XHRjdXJyZW50Tm9kZS5hZGRHZW5lcmF0ZWRDb2RlKGdlbmVyYXRlZENvZGUpO1xyXG5cdFx0fSBlbHNlIGlmKGN1cnJlbnROb2RlICYmIGN1cnJlbnROb2RlIGluc3RhbmNlb2YgU291cmNlTm9kZSAmJiAhZ2VuZXJhdGVkQ29kZS50cmltKCkpIHtcclxuXHRcdFx0Y3VycmVudE5vZGUuZ2VuZXJhdGVkQ29kZSArPSBnZW5lcmF0ZWRDb2RlO1xyXG5cdFx0XHRjdXJyZW50U291cmNlTm9kZUxpbmUrKztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGN1cnJlbnROb2RlID0gbmV3IENvZGVOb2RlKGdlbmVyYXRlZENvZGUpO1xyXG5cdFx0XHRub2Rlcy5wdXNoKGN1cnJlbnROb2RlKTtcclxuXHRcdH1cclxuXHR9XHJcblx0ZnVuY3Rpb24gYWRkU291cmNlKGdlbmVyYXRlZENvZGUsIHNvdXJjZSwgb3JpZ2luYWxTb3VyY2UsIGxpbmVQb3NpdGlvbikge1xyXG5cdFx0aWYoY3VycmVudE5vZGUgJiYgY3VycmVudE5vZGUgaW5zdGFuY2VvZiBTb3VyY2VOb2RlICYmXHJcblx0XHRcdGN1cnJlbnROb2RlLnNvdXJjZSA9PT0gc291cmNlICYmXHJcblx0XHRcdGN1cnJlbnRTb3VyY2VOb2RlTGluZSA9PT0gbGluZVBvc2l0aW9uXHJcblx0XHQpIHtcclxuXHRcdFx0Y3VycmVudE5vZGUuZ2VuZXJhdGVkQ29kZSArPSBnZW5lcmF0ZWRDb2RlO1xyXG5cdFx0XHRjdXJyZW50U291cmNlTm9kZUxpbmUrKztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGN1cnJlbnROb2RlID0gbmV3IFNvdXJjZU5vZGUoZ2VuZXJhdGVkQ29kZSwgc291cmNlLCBvcmlnaW5hbFNvdXJjZSwgbGluZVBvc2l0aW9uKTtcclxuXHRcdFx0Y3VycmVudFNvdXJjZU5vZGVMaW5lID0gbGluZVBvc2l0aW9uICsgMTtcclxuXHRcdFx0bm9kZXMucHVzaChjdXJyZW50Tm9kZSk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc291cmNlLWxpc3QtbWFwL2xpYi9mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcC5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtaXhpblNvdXJjZUFuZE1hcChwcm90bykge1xyXG5cdHByb3RvLm1hcCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdFx0aWYob3B0aW9ucy5jb2x1bW5zID09PSBmYWxzZSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5saXN0TWFwKG9wdGlvbnMpLnRvU3RyaW5nV2l0aFNvdXJjZU1hcCgpLm1hcDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5ub2RlKG9wdGlvbnMpLnRvU3RyaW5nV2l0aFNvdXJjZU1hcCh7ZmlsZTpcInhcIn0pLm1hcC50b0pTT04oKTtcclxuXHR9O1xyXG5cclxuXHRwcm90by5zb3VyY2VBbmRNYXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHRcdGlmKG9wdGlvbnMuY29sdW1ucyA9PT0gZmFsc2UpIHtcclxuXHRcdFx0Ly9jb25zb2xlLmxvZyh0aGlzLmxpc3RNYXAob3B0aW9ucykuZGVidWdJbmZvKCkpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5saXN0TWFwKG9wdGlvbnMpLnRvU3RyaW5nV2l0aFNvdXJjZU1hcCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciByZXMgPSB0aGlzLm5vZGUob3B0aW9ucykudG9TdHJpbmdXaXRoU291cmNlTWFwKHtmaWxlOlwieFwifSk7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRzb3VyY2U6IHJlcy5jb2RlLFxyXG5cdFx0XHRtYXA6IHJlcy5tYXAudG9KU09OKClcclxuXHRcdH07XHJcblx0fTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjayktY29yZS9saWIvU291cmNlQW5kTWFwTWl4aW4uanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBTb3VyY2UgPSByZXF1aXJlKFwiLi9Tb3VyY2VcIik7XHJcbnZhciBTb3VyY2VOb2RlID0gcmVxdWlyZShcInNvdXJjZS1tYXBcIikuU291cmNlTm9kZTtcclxudmFyIFNvdXJjZUxpc3RNYXAgPSByZXF1aXJlKFwic291cmNlLWxpc3QtbWFwXCIpLlNvdXJjZUxpc3RNYXA7XHJcblxyXG5mdW5jdGlvbiBSYXdTb3VyY2UodmFsdWUpIHtcclxuXHRTb3VyY2UuY2FsbCh0aGlzKTtcclxuXHR0aGlzLl92YWx1ZSA9IHZhbHVlO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gUmF3U291cmNlO1xyXG5cclxuUmF3U291cmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlLnByb3RvdHlwZSk7XHJcblJhd1NvdXJjZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSYXdTb3VyY2U7XHJcblxyXG5SYXdTb3VyY2UucHJvdG90eXBlLnNvdXJjZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLl92YWx1ZTtcclxufTtcclxuXHJcblJhd1NvdXJjZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuUmF3U291cmNlLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgU291cmNlTm9kZShudWxsLCBudWxsLCBudWxsLCB0aGlzLl92YWx1ZSk7XHJcbn07XHJcblxyXG5SYXdTb3VyY2UucHJvdG90eXBlLmxpc3RNYXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBTb3VyY2VMaXN0TWFwKHRoaXMuX3ZhbHVlKTtcclxufTtcclxuXHJcblJhd1NvdXJjZS5wcm90b3R5cGUudXBkYXRlSGFzaCA9IGZ1bmN0aW9uKGhhc2gpIHtcclxuXHRoYXNoLnVwZGF0ZSh0aGlzLl92YWx1ZSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS1jb3JlL2xpYi9SYXdTb3VyY2UuanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbmZ1bmN0aW9uIE1vZHVsZVJlYXNvbihtb2R1bGUsIGRlcGVuZGVuY3kpIHtcclxuXHR0aGlzLm1vZHVsZSA9IG1vZHVsZTtcclxuXHR0aGlzLmRlcGVuZGVuY3kgPSBkZXBlbmRlbmN5O1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gTW9kdWxlUmVhc29uO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL01vZHVsZVJlYXNvbi5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZW1vdmVBbmREbyhjb2xsZWN0aW9uLCB0aGluZywgYWN0aW9uKSB7XHJcblx0dmFyIGlkeCA9IHRoaXNbY29sbGVjdGlvbl0uaW5kZXhPZih0aGluZyk7XHJcblx0aWYoaWR4ID49IDApIHtcclxuXHRcdHRoaXNbY29sbGVjdGlvbl0uc3BsaWNlKGlkeCwgMSk7XHJcblx0XHR0aGluZ1thY3Rpb25dKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cdHJldHVybiBmYWxzZTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9yZW1vdmVBbmREby5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuZnVuY3Rpb24gQXJyYXlNYXAoKSB7XHJcblx0dGhpcy5rZXlzID0gW107XHJcblx0dGhpcy52YWx1ZXMgPSBbXTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5TWFwO1xyXG5cclxuQXJyYXlNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSkge1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmKHRoaXMua2V5c1tpXSA9PT0ga2V5KSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnZhbHVlc1tpXTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuO1xyXG59O1xyXG5cclxuQXJyYXlNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZih0aGlzLmtleXNbaV0gPT09IGtleSkge1xyXG5cdFx0XHR0aGlzLnZhbHVlc1tpXSA9IHZhbHVlO1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHR9XHJcblx0dGhpcy5rZXlzLnB1c2goa2V5KTtcclxuXHR0aGlzLnZhbHVlcy5wdXNoKHZhbHVlKTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcbkFycmF5TWFwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihrZXkpIHtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZih0aGlzLmtleXNbaV0gPT09IGtleSkge1xyXG5cdFx0XHR0aGlzLmtleXMuc3BsaWNlKGksIDEpO1xyXG5cdFx0XHR0aGlzLnZhbHVlcy5zcGxpY2UoaSwgMSk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5BcnJheU1hcC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgbmV3TWFwID0gbmV3IEFycmF5TWFwKCk7XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0bmV3TWFwLmtleXMucHVzaCh0aGlzLmtleXNbaV0pO1xyXG5cdFx0bmV3TWFwLnZhbHVlcy5wdXNoKHRoaXMudmFsdWVzW2ldKTtcclxuXHR9XHJcblx0cmV0dXJuIG5ld01hcDtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9BcnJheU1hcC5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuZnVuY3Rpb24gQ2h1bmsobmFtZSwgbW9kdWxlLCBsb2MpIHtcclxuXHR0aGlzLmlkID0gbnVsbDtcclxuXHR0aGlzLmlkcyA9IG51bGw7XHJcblx0dGhpcy5uYW1lID0gbmFtZTtcclxuXHR0aGlzLm1vZHVsZXMgPSBbXTtcclxuXHR0aGlzLmNodW5rcyA9IFtdO1xyXG5cdHRoaXMucGFyZW50cyA9IFtdO1xyXG5cdHRoaXMuYmxvY2tzID0gW107XHJcblx0dGhpcy5vcmlnaW5zID0gW107XHJcblx0dGhpcy5maWxlcyA9IFtdO1xyXG5cdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcclxuXHR0aGlzLmVudHJ5ID0gZmFsc2U7XHJcblx0dGhpcy5pbml0aWFsID0gZmFsc2U7XHJcblx0aWYobW9kdWxlKSB7XHJcblx0XHR0aGlzLm9yaWdpbnMucHVzaCh7XHJcblx0XHRcdG1vZHVsZTogbW9kdWxlLFxyXG5cdFx0XHRsb2M6IGxvYyxcclxuXHRcdFx0bmFtZTogbmFtZVxyXG5cdFx0fSk7XHJcblx0fVxyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gQ2h1bms7XHJcblxyXG5DaHVuay5wcm90b3R5cGUuYWRkTW9kdWxlID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYodGhpcy5tb2R1bGVzLmluZGV4T2YobW9kdWxlKSA+PSAwKSB7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fVxyXG5cdHRoaXMubW9kdWxlcy5wdXNoKG1vZHVsZSk7XHJcblx0cmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5DaHVuay5wcm90b3R5cGUuX3JlbW92ZUFuZERvID0gcmVxdWlyZShcIi4vcmVtb3ZlQW5kRG9cIik7XHJcblxyXG5DaHVuay5wcm90b3R5cGUucmVtb3ZlTW9kdWxlID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0dGhpcy5fcmVtb3ZlQW5kRG8oXCJtb2R1bGVzXCIsIG1vZHVsZSwgXCJyZW1vdmVDaHVua1wiKTtcclxufTtcclxuXHJcbkNodW5rLnByb3RvdHlwZS5yZW1vdmVDaHVuayA9IGZ1bmN0aW9uKGNodW5rKSB7XHJcblx0dGhpcy5fcmVtb3ZlQW5kRG8oXCJjaHVua3NcIiwgY2h1bmssIFwicmVtb3ZlUGFyZW50XCIpO1xyXG59O1xyXG5cclxuQ2h1bmsucHJvdG90eXBlLnJlbW92ZVBhcmVudCA9IGZ1bmN0aW9uKGNodW5rKSB7XHJcblx0dGhpcy5fcmVtb3ZlQW5kRG8oXCJwYXJlbnRzXCIsIGNodW5rLCBcInJlbW92ZUNodW5rXCIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gY3JlYXRlQWRkZXIoY29sbGVjdGlvbikge1xyXG5cdHJldHVybiBmdW5jdGlvbihjaHVuaykge1xyXG5cdFx0aWYoY2h1bmsgPT09IHRoaXMpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0aWYodGhpc1tjb2xsZWN0aW9uXS5pbmRleE9mKGNodW5rKSA+PSAwKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHRoaXNbY29sbGVjdGlvbl0ucHVzaChjaHVuayk7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9O1xyXG59XHJcblxyXG5DaHVuay5wcm90b3R5cGUuYWRkQ2h1bmsgPSBjcmVhdGVBZGRlcihcImNodW5rc1wiKTtcclxuXHJcbkNodW5rLnByb3RvdHlwZS5hZGRQYXJlbnQgPSBjcmVhdGVBZGRlcihcInBhcmVudHNcIik7XHJcblxyXG5DaHVuay5wcm90b3R5cGUuYWRkQmxvY2sgPSBmdW5jdGlvbihibG9jaykge1xyXG5cdGlmKHRoaXMuYmxvY2tzLmluZGV4T2YoYmxvY2spID49IDApIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblx0dGhpcy5ibG9ja3MucHVzaChibG9jayk7XHJcblx0cmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5DaHVuay5wcm90b3R5cGUuYWRkT3JpZ2luID0gZnVuY3Rpb24obW9kdWxlLCBsb2MpIHtcclxuXHR0aGlzLm9yaWdpbnMucHVzaCh7XHJcblx0XHRtb2R1bGU6IG1vZHVsZSxcclxuXHRcdGxvYzogbG9jLFxyXG5cdFx0bmFtZTogdGhpcy5uYW1lXHJcblx0fSk7XHJcbn07XHJcblxyXG5DaHVuay5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24ocmVhc29uKSB7XHJcblx0dGhpcy5tb2R1bGVzLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbihtKSB7XHJcblx0XHRtLnJlbW92ZUNodW5rKHRoaXMpO1xyXG5cdH0sIHRoaXMpO1xyXG5cdHRoaXMucGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcclxuXHRcdHZhciBpZHggPSBjLmNodW5rcy5pbmRleE9mKHRoaXMpO1xyXG5cdFx0aWYoaWR4ID49IDApIHtcclxuXHRcdFx0Yy5jaHVua3Muc3BsaWNlKGlkeCwgMSk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmNodW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGNjKSB7XHJcblx0XHRcdGNjLmFkZFBhcmVudChjKTtcclxuXHRcdH0pO1xyXG5cdH0sIHRoaXMpO1xyXG5cdHRoaXMuY2h1bmtzLmZvckVhY2goZnVuY3Rpb24oYykge1xyXG5cdFx0dmFyIGlkeCA9IGMucGFyZW50cy5pbmRleE9mKHRoaXMpO1xyXG5cdFx0aWYoaWR4ID49IDApIHtcclxuXHRcdFx0Yy5wYXJlbnRzLnNwbGljZShpZHgsIDEpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5wYXJlbnRzLmZvckVhY2goZnVuY3Rpb24oY2MpIHtcclxuXHRcdFx0Y2MuYWRkQ2h1bmsoYyk7XHJcblx0XHR9KTtcclxuXHR9LCB0aGlzKTtcclxuXHR0aGlzLmJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uKGIpIHtcclxuXHRcdHZhciBpZHggPSBiLmNodW5rcy5pbmRleE9mKHRoaXMpO1xyXG5cdFx0aWYoaWR4ID49IDApIHtcclxuXHRcdFx0Yi5jaHVua3Muc3BsaWNlKGlkeCwgMSk7XHJcblx0XHRcdGlmKGIuY2h1bmtzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRcdGIuY2h1bmtzID0gbnVsbDtcclxuXHRcdFx0XHRiLmNodW5rUmVhc29uID0gcmVhc29uO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSwgdGhpcyk7XHJcbn07XHJcblxyXG5DaHVuay5wcm90b3R5cGUuaW50ZWdyYXRlID0gZnVuY3Rpb24ob3RoZXIsIHJlYXNvbikge1xyXG5cdGlmKCF0aGlzLmNhbkJlSW50ZWdyYXRlZChvdGhlcikpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblxyXG5cdHZhciBvdGhlck1vZHVsZXMgPSBvdGhlci5tb2R1bGVzLnNsaWNlKCk7XHJcblx0b3RoZXJNb2R1bGVzLmZvckVhY2goZnVuY3Rpb24obSkge1xyXG5cdFx0bS5yZW1vdmVDaHVuayhvdGhlcik7XHJcblx0XHRtLmFkZENodW5rKHRoaXMpO1xyXG5cdFx0dGhpcy5hZGRNb2R1bGUobSk7XHJcblx0XHRtLnJld3JpdGVDaHVua0luUmVhc29ucyhvdGhlciwgW3RoaXNdKTtcclxuXHR9LCB0aGlzKTtcclxuXHRvdGhlci5tb2R1bGVzLmxlbmd0aCA9IDA7XHJcblxyXG5cdGZ1bmN0aW9uIG1vdmVDaHVua3MoY2h1bmtzLCBraW5kLCBvbkNodW5rKSB7XHJcblx0XHRjaHVua3MuZm9yRWFjaChmdW5jdGlvbihjKSB7XHJcblx0XHRcdHZhciBpZHggPSBjW2tpbmRdLmluZGV4T2Yob3RoZXIpO1xyXG5cdFx0XHRpZihpZHggPj0gMCkge1xyXG5cdFx0XHRcdGNba2luZF0uc3BsaWNlKGlkeCwgMSk7XHJcblx0XHRcdH1cclxuXHRcdFx0b25DaHVuayhjKTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHRtb3ZlQ2h1bmtzKG90aGVyLnBhcmVudHMsIFwiY2h1bmtzXCIsIGZ1bmN0aW9uKGMpIHtcclxuXHRcdGlmKGMgIT09IHRoaXMgJiYgdGhpcy5hZGRQYXJlbnQoYykpIHtcclxuXHRcdFx0Yy5hZGRDaHVuayh0aGlzKTtcclxuXHRcdH1cclxuXHR9LmJpbmQodGhpcykpO1xyXG5cdG90aGVyLnBhcmVudHMubGVuZ3RoID0gMDtcclxuXHRtb3ZlQ2h1bmtzKG90aGVyLmNodW5rcywgXCJwYXJlbnRzXCIsIGZ1bmN0aW9uKGMpIHtcclxuXHRcdGlmKGMgIT09IHRoaXMgJiYgdGhpcy5hZGRDaHVuayhjKSkge1xyXG5cdFx0XHRjLmFkZFBhcmVudCh0aGlzKTtcclxuXHRcdH1cclxuXHR9LmJpbmQodGhpcykpO1xyXG5cdG90aGVyLmNodW5rcy5sZW5ndGggPSAwO1xyXG5cdG90aGVyLmJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uKGIpIHtcclxuXHRcdGIuY2h1bmtzID0gKGIuY2h1bmtzIHx8IFt0aGlzXSkubWFwKGZ1bmN0aW9uKGMpIHtcclxuXHRcdFx0cmV0dXJuIGMgPT09IG90aGVyID8gdGhpcyA6IGM7XHJcblx0XHR9LCB0aGlzKTtcclxuXHRcdGIuY2h1bmtSZWFzb24gPSByZWFzb247XHJcblx0XHR0aGlzLmFkZEJsb2NrKGIpO1xyXG5cdH0sIHRoaXMpO1xyXG5cdG90aGVyLmJsb2Nrcy5sZW5ndGggPSAwO1xyXG5cdG90aGVyLm9yaWdpbnMuZm9yRWFjaChmdW5jdGlvbihvcmlnaW4pIHtcclxuXHRcdGlmKCFvcmlnaW4ucmVhc29ucykge1xyXG5cdFx0XHRvcmlnaW4ucmVhc29ucyA9IFtyZWFzb25dO1xyXG5cdFx0fSBlbHNlIGlmKG9yaWdpbi5yZWFzb25zWzBdICE9PSByZWFzb24pIHtcclxuXHRcdFx0b3JpZ2luLnJlYXNvbnMudW5zaGlmdChyZWFzb24pO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5vcmlnaW5zLnB1c2gob3JpZ2luKTtcclxuXHR9LCB0aGlzKTtcclxuXHRyZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbkNodW5rLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMubW9kdWxlcy5sZW5ndGggPT09IDA7XHJcbn07XHJcblxyXG5DaHVuay5wcm90b3R5cGUudXBkYXRlSGFzaCA9IGZ1bmN0aW9uKGhhc2gpIHtcclxuXHRoYXNoLnVwZGF0ZSh0aGlzLmlkICsgXCIgXCIpO1xyXG5cdGhhc2gudXBkYXRlKHRoaXMuaWRzID8gdGhpcy5pZHMuam9pbihcIixcIikgOiBcIlwiKTtcclxuXHRoYXNoLnVwZGF0ZSh0aGlzLm5hbWUgKyBcIlwiKTtcclxuXHR0aGlzLm1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbihtKSB7XHJcblx0XHRtLnVwZGF0ZUhhc2goaGFzaCk7XHJcblx0fSk7XHJcbn07XHJcblxyXG5DaHVuay5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHR2YXIgQ0hVTktfT1ZFUkhFQUQgPSBvcHRpb25zLmNodW5rT3ZlcmhlYWQgfHwgMTAwMDA7XHJcblx0dmFyIEVOVFJZX0NIVU5LX01VTFRJUExJQ0FUT1IgPSBvcHRpb25zLmVudHJ5Q2h1bmtNdWx0aXBsaWNhdG9yIHx8IDEwO1xyXG5cclxuXHR2YXIgbW9kdWxlc1NpemUgPSB0aGlzLm1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdHJldHVybiBhICsgYi5zaXplKCk7XHJcblx0fSwgMCk7XHJcblx0cmV0dXJuIG1vZHVsZXNTaXplICogKHRoaXMuaW5pdGlhbCA/IEVOVFJZX0NIVU5LX01VTFRJUExJQ0FUT1IgOiAxKSArIENIVU5LX09WRVJIRUFEO1xyXG59O1xyXG5cclxuQ2h1bmsucHJvdG90eXBlLmNhbkJlSW50ZWdyYXRlZCA9IGZ1bmN0aW9uKG90aGVyKSB7XHJcblx0aWYob3RoZXIuaW5pdGlhbCkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHRpZih0aGlzLmluaXRpYWwpIHtcclxuXHRcdGlmKG90aGVyLnBhcmVudHMubGVuZ3RoICE9PSAxIHx8IG90aGVyLnBhcmVudHNbMF0gIT09IHRoaXMpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbkNodW5rLnByb3RvdHlwZS5pbnRlZ3JhdGVkU2l6ZSA9IGZ1bmN0aW9uKG90aGVyLCBvcHRpb25zKSB7XHJcblx0Ly8gQ2h1bmsgaWYgaXQncyBwb3NzaWJsZSB0byBpbnRlZ3JhdGUgdGhpcyBjaHVua1xyXG5cdGlmKCF0aGlzLmNhbkJlSW50ZWdyYXRlZChvdGhlcikpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblxyXG5cdHZhciBDSFVOS19PVkVSSEVBRCA9IG9wdGlvbnMuY2h1bmtPdmVyaGVhZCB8fCAxMDAwMDtcclxuXHR2YXIgRU5UUllfQ0hVTktfTVVMVElQTElDQVRPUiA9IG9wdGlvbnMuZW50cnlDaHVua011bHRpcGxpY2F0b3IgfHwgMTA7XHJcblxyXG5cdHZhciBtZXJnZWRNb2R1bGVzID0gdGhpcy5tb2R1bGVzLnNsaWNlKCk7XHJcblx0b3RoZXIubW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uKG0pIHtcclxuXHRcdGlmKHRoaXMubW9kdWxlcy5pbmRleE9mKG0pIDwgMCkge1xyXG5cdFx0XHRtZXJnZWRNb2R1bGVzLnB1c2gobSk7XHJcblx0XHR9XHJcblx0fSwgdGhpcyk7XHJcblxyXG5cdHZhciBtb2R1bGVzU2l6ZSA9IG1lcmdlZE1vZHVsZXMubWFwKGZ1bmN0aW9uKG0pIHtcclxuXHRcdHJldHVybiBtLnNpemUoKTtcclxuXHR9KS5yZWR1Y2UoZnVuY3Rpb24oYSwgYikge1xyXG5cdFx0cmV0dXJuIGEgKyBiO1xyXG5cdH0sIDApO1xyXG5cdHJldHVybiBtb2R1bGVzU2l6ZSAqICh0aGlzLmluaXRpYWwgfHwgb3RoZXIuaW5pdGlhbCA/IEVOVFJZX0NIVU5LX01VTFRJUExJQ0FUT1IgOiAxKSArIENIVU5LX09WRVJIRUFEO1xyXG59O1xyXG5cclxuQ2h1bmsucHJvdG90eXBlLmdldENodW5rTWFwcyA9IGZ1bmN0aW9uKGluY2x1ZGVFbnRyaWVzLCByZWFsSGFzaCkge1xyXG5cdHZhciBjaHVua3NQcm9jZXNzZWQgPSBbXTtcclxuXHR2YXIgY2h1bmtIYXNoTWFwID0ge307XHJcblx0dmFyIGNodW5rTmFtZU1hcCA9IHt9O1xyXG5cdChmdW5jdGlvbiBhZGRDaHVuayhjKSB7XHJcblx0XHRpZihjaHVua3NQcm9jZXNzZWQuaW5kZXhPZihjKSA+PSAwKSByZXR1cm47XHJcblx0XHRjaHVua3NQcm9jZXNzZWQucHVzaChjKTtcclxuXHRcdGlmKCFjLmVudHJ5IHx8IGluY2x1ZGVFbnRyaWVzKSB7XHJcblx0XHRcdGNodW5rSGFzaE1hcFtjLmlkXSA9IHJlYWxIYXNoID8gYy5oYXNoIDogYy5yZW5kZXJlZEhhc2g7XHJcblx0XHRcdGlmKGMubmFtZSlcclxuXHRcdFx0XHRjaHVua05hbWVNYXBbYy5pZF0gPSBjLm5hbWU7XHJcblx0XHR9XHJcblx0XHRjLmNodW5rcy5mb3JFYWNoKGFkZENodW5rKTtcclxuXHR9KHRoaXMpKTtcclxuXHRyZXR1cm4ge1xyXG5cdFx0aGFzaDogY2h1bmtIYXNoTWFwLFxyXG5cdFx0bmFtZTogY2h1bmtOYW1lTWFwXHJcblx0fTtcclxufTtcclxuXHJcbkNodW5rLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcIkNodW5rW1wiICsgdGhpcy5tb2R1bGVzLmpvaW4oKSArIFwiXVwiO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL0NodW5rLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgUmVxdWVzdFNob3J0ZW5lciA9IHJlcXVpcmUoXCIuL1JlcXVlc3RTaG9ydGVuZXJcIik7XHJcblxyXG5mdW5jdGlvbiBTdGF0cyhjb21waWxhdGlvbikge1xyXG5cdHRoaXMuY29tcGlsYXRpb24gPSBjb21waWxhdGlvbjtcclxuXHR0aGlzLmhhc2ggPSBjb21waWxhdGlvbi5oYXNoO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gU3RhdHM7XHJcblxyXG5TdGF0cy5wcm90b3R5cGUuaGFzV2FybmluZ3MgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5jb21waWxhdGlvbi53YXJuaW5ncy5sZW5ndGggPiAwO1xyXG59O1xyXG5cclxuU3RhdHMucHJvdG90eXBlLmhhc0Vycm9ycyA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLmNvbXBpbGF0aW9uLmVycm9ycy5sZW5ndGggPiAwO1xyXG59O1xyXG5cclxuU3RhdHMucHJvdG90eXBlLnRvSnNvbiA9IGZ1bmN0aW9uIHRvSnNvbihvcHRpb25zLCBmb3JUb1N0cmluZykge1xyXG5cdGlmKHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIiB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0b3B0aW9ucyA9IFN0YXRzLnByZXNldFRvT3B0aW9ucyhvcHRpb25zKTtcclxuXHR9IGVsc2UgaWYoIW9wdGlvbnMpIHtcclxuXHRcdG9wdGlvbnMgPSB7fTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGQodiwgZGVmKSB7XHJcblx0XHRyZXR1cm4gdiA9PT0gdW5kZWZpbmVkID8gZGVmIDogdjtcclxuXHR9XHJcblx0dmFyIGNvbXBpbGF0aW9uID0gdGhpcy5jb21waWxhdGlvbjtcclxuXHR2YXIgcmVxdWVzdFNob3J0ZW5lciA9IG5ldyBSZXF1ZXN0U2hvcnRlbmVyKGQob3B0aW9ucy5jb250ZXh0LCBwcm9jZXNzLmN3ZCgpKSk7XHJcblx0dmFyIHNob3dIYXNoID0gZChvcHRpb25zLmhhc2gsIHRydWUpO1xyXG5cdHZhciBzaG93VmVyc2lvbiA9IGQob3B0aW9ucy52ZXJzaW9uLCB0cnVlKTtcclxuXHR2YXIgc2hvd1RpbWluZ3MgPSBkKG9wdGlvbnMudGltaW5ncywgdHJ1ZSk7XHJcblx0dmFyIHNob3dBc3NldHMgPSBkKG9wdGlvbnMuYXNzZXRzLCB0cnVlKTtcclxuXHR2YXIgc2hvd0NodW5rcyA9IGQob3B0aW9ucy5jaHVua3MsIHRydWUpO1xyXG5cdHZhciBzaG93Q2h1bmtNb2R1bGVzID0gZChvcHRpb25zLmNodW5rTW9kdWxlcywgISFmb3JUb1N0cmluZyk7XHJcblx0dmFyIHNob3dDaHVua09yaWdpbnMgPSBkKG9wdGlvbnMuY2h1bmtPcmlnaW5zLCAhZm9yVG9TdHJpbmcpO1xyXG5cdHZhciBzaG93TW9kdWxlcyA9IGQob3B0aW9ucy5tb2R1bGVzLCAhZm9yVG9TdHJpbmcpO1xyXG5cdHZhciBzaG93Q2FjaGVkTW9kdWxlcyA9IGQob3B0aW9ucy5jYWNoZWQsIHRydWUpO1xyXG5cdHZhciBzaG93Q2FjaGVkQXNzZXRzID0gZChvcHRpb25zLmNhY2hlZEFzc2V0cywgdHJ1ZSk7XHJcblx0dmFyIHNob3dSZWFzb25zID0gZChvcHRpb25zLnJlYXNvbnMsICFmb3JUb1N0cmluZyk7XHJcblx0dmFyIHNob3dDaGlsZHJlbiA9IGQob3B0aW9ucy5jaGlsZHJlbiwgdHJ1ZSk7XHJcblx0dmFyIHNob3dTb3VyY2UgPSBkKG9wdGlvbnMuc291cmNlLCAhZm9yVG9TdHJpbmcpO1xyXG5cdHZhciBzaG93RXJyb3JzID0gZChvcHRpb25zLmVycm9ycywgdHJ1ZSk7XHJcblx0dmFyIHNob3dFcnJvckRldGFpbHMgPSBkKG9wdGlvbnMuZXJyb3JEZXRhaWxzLCAhZm9yVG9TdHJpbmcpO1xyXG5cdHZhciBzaG93V2FybmluZ3MgPSBkKG9wdGlvbnMud2FybmluZ3MsIHRydWUpO1xyXG5cdHZhciBzaG93UHVibGljUGF0aCA9IGQob3B0aW9ucy5wdWJsaWNQYXRoLCAhZm9yVG9TdHJpbmcpO1xyXG5cdHZhciBleGNsdWRlTW9kdWxlcyA9IFtdLmNvbmNhdChkKG9wdGlvbnMuZXhjbHVkZSwgW10pKS5tYXAoZnVuY3Rpb24oc3RyKSB7XHJcblx0XHRpZih0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKSByZXR1cm4gc3RyO1xyXG5cdFx0cmV0dXJuIG5ldyBSZWdFeHAoXCJbXFxcXFxcXFwvXVwiICsgc3RyLnJlcGxhY2UoL1tcXC1cXFtcXF1cXC9cXHtcXH1cXChcXClcXCpcXCtcXD9cXC5cXFxcXFxeXFwkXFx8XS9nLCBcIlxcXFwkJlwiKSArIFwiKFtcXFxcXFxcXC9dfCR8IXxcXFxcPylcIik7XHJcblx0fSk7XHJcblx0dmFyIHNvcnRNb2R1bGVzID0gZChvcHRpb25zLm1vZHVsZXNTb3J0LCBcImlkXCIpO1xyXG5cdHZhciBzb3J0Q2h1bmtzID0gZChvcHRpb25zLmNodW5rc1NvcnQsIFwiaWRcIik7XHJcblx0dmFyIHNvcnRBc3NldHMgPSBkKG9wdGlvbnMuYXNzZXRzU29ydCwgXCJcIik7XHJcblxyXG5cdGZ1bmN0aW9uIG1vZHVsZUZpbHRlcihtb2R1bGUpIHtcclxuXHRcdGlmKCFzaG93Q2FjaGVkTW9kdWxlcyAmJiAhbW9kdWxlLmJ1aWx0KSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdGlmKGV4Y2x1ZGVNb2R1bGVzLmxlbmd0aCA9PT0gMClcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR2YXIgaWRlbnQgPSBtb2R1bGUuaWRlbnRpZmllcigpO1xyXG5cdFx0cmV0dXJuICFleGNsdWRlTW9kdWxlcy5zb21lKGZ1bmN0aW9uKHJlZ0V4cCkge1xyXG5cdFx0XHRyZXR1cm4gcmVnRXhwLnRlc3QoaWRlbnQpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzb3J0QnlGaWVsZChmaWVsZCkge1xyXG5cdFx0aWYoIWZpZWxkKSByZXR1cm4gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiAwO1xyXG5cdFx0fTtcclxuXHRcdGlmKGZpZWxkWzBdID09PSBcIiFcIikge1xyXG5cdFx0XHRmaWVsZCA9IGZpZWxkLnN1YnN0cigxKTtcclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdFx0XHRpZihhW2ZpZWxkXSA9PT0gYltmaWVsZF0pIHJldHVybiAwO1xyXG5cdFx0XHRcdHJldHVybiBhW2ZpZWxkXSA8IGJbZmllbGRdID8gMSA6IC0xO1xyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdFx0aWYoYVtmaWVsZF0gPT09IGJbZmllbGRdKSByZXR1cm4gMDtcclxuXHRcdFx0cmV0dXJuIGFbZmllbGRdIDwgYltmaWVsZF0gPyAtMSA6IDE7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZm9ybWF0RXJyb3IoZSkge1xyXG5cdFx0dmFyIHRleHQgPSBcIlwiO1xyXG5cdFx0aWYodHlwZW9mIGUgPT09IFwic3RyaW5nXCIpXHJcblx0XHRcdGUgPSB7XHJcblx0XHRcdFx0bWVzc2FnZTogZVxyXG5cdFx0XHR9O1xyXG5cdFx0aWYoZS5jaHVuaykge1xyXG5cdFx0XHR0ZXh0ICs9IFwiY2h1bmsgXCIgKyAoZS5jaHVuay5uYW1lIHx8IGUuY2h1bmsuaWQpICtcclxuXHRcdFx0XHQoZS5jaHVuay5lbnRyeSA/IFwiIFtlbnRyeV1cIiA6IGUuY2h1bmsuaW5pdGlhbCA/IFwiIFtpbml0aWFsXVwiIDogXCJcIikgKyBcIlxcblwiO1xyXG5cdFx0fVxyXG5cdFx0aWYoZS5maWxlKSB7XHJcblx0XHRcdHRleHQgKz0gZS5maWxlICsgXCJcXG5cIjtcclxuXHRcdH1cclxuXHRcdGlmKGUubW9kdWxlICYmIGUubW9kdWxlLnJlYWRhYmxlSWRlbnRpZmllciAmJiB0eXBlb2YgZS5tb2R1bGUucmVhZGFibGVJZGVudGlmaWVyID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdFx0dGV4dCArPSBlLm1vZHVsZS5yZWFkYWJsZUlkZW50aWZpZXIocmVxdWVzdFNob3J0ZW5lcikgKyBcIlxcblwiO1xyXG5cdFx0fVxyXG5cdFx0dGV4dCArPSBlLm1lc3NhZ2U7XHJcblx0XHRpZihzaG93RXJyb3JEZXRhaWxzICYmIGUuZGV0YWlscykgdGV4dCArPSBcIlxcblwiICsgZS5kZXRhaWxzO1xyXG5cdFx0aWYoc2hvd0Vycm9yRGV0YWlscyAmJiBlLm1pc3NpbmcpIHRleHQgKz0gZS5taXNzaW5nLm1hcChmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRcdHJldHVybiBcIlxcbltcIiArIGl0ZW0gKyBcIl1cIjtcclxuXHRcdH0pLmpvaW4oXCJcIik7XHJcblx0XHRpZihlLmRlcGVuZGVuY2llcyAmJiBlLm9yaWdpbikge1xyXG5cdFx0XHR0ZXh0ICs9IFwiXFxuIEAgXCIgKyBlLm9yaWdpbi5yZWFkYWJsZUlkZW50aWZpZXIocmVxdWVzdFNob3J0ZW5lcik7XHJcblx0XHRcdGUuZGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24oZGVwKSB7XHJcblx0XHRcdFx0aWYoIWRlcC5sb2MpIHJldHVybjtcclxuXHRcdFx0XHRpZih0eXBlb2YgZGVwLmxvYyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuO1xyXG5cdFx0XHRcdGlmKCFkZXAubG9jLnN0YXJ0KSByZXR1cm47XHJcblx0XHRcdFx0aWYoIWRlcC5sb2MuZW5kKSByZXR1cm47XHJcblx0XHRcdFx0dGV4dCArPSBcIiBcIiArIGRlcC5sb2Muc3RhcnQubGluZSArIFwiOlwiICsgZGVwLmxvYy5zdGFydC5jb2x1bW4gKyBcIi1cIiArXHJcblx0XHRcdFx0XHQoZGVwLmxvYy5zdGFydC5saW5lICE9PSBkZXAubG9jLmVuZC5saW5lID8gZGVwLmxvYy5lbmQubGluZSArIFwiOlwiIDogXCJcIikgKyBkZXAubG9jLmVuZC5jb2x1bW47XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRleHQ7XHJcblx0fVxyXG5cclxuXHR2YXIgb2JqID0ge1xyXG5cdFx0ZXJyb3JzOiBjb21waWxhdGlvbi5lcnJvcnMubWFwKGZvcm1hdEVycm9yKSxcclxuXHRcdHdhcm5pbmdzOiBjb21waWxhdGlvbi53YXJuaW5ncy5tYXAoZm9ybWF0RXJyb3IpXHJcblx0fTtcclxuXHJcblx0Ly9XZSBqdXN0IGhpbnQgb3RoZXIgcmVuZGVyZXJzIHNpbmNlIGFjdHVhbGx5IG9taXR0aW5nXHJcblx0Ly9lcnJvcnMvd2FybmluZ3MgZnJvbSB0aGUgSlNPTiB3b3VsZCBiZSBraW5kIG9mIHdlaXJkLlxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIFwiX3Nob3dXYXJuaW5nc1wiLCB7XHJcblx0XHR2YWx1ZTogc2hvd1dhcm5pbmdzLFxyXG5cdFx0ZW51bWVyYWJsZTogZmFsc2VcclxuXHR9KTtcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBcIl9zaG93RXJyb3JzXCIsIHtcclxuXHRcdHZhbHVlOiBzaG93RXJyb3JzLFxyXG5cdFx0ZW51bWVyYWJsZTogZmFsc2VcclxuXHR9KTtcclxuXHJcblx0aWYoc2hvd1ZlcnNpb24pIHtcclxuXHRcdG9iai52ZXJzaW9uID0gcmVxdWlyZShcIi4uL3BhY2thZ2UuanNvblwiKS52ZXJzaW9uO1xyXG5cdH1cclxuXHJcblx0aWYoc2hvd0hhc2gpIG9iai5oYXNoID0gdGhpcy5oYXNoO1xyXG5cdGlmKHNob3dUaW1pbmdzICYmIHRoaXMuc3RhcnRUaW1lICYmIHRoaXMuZW5kVGltZSkge1xyXG5cdFx0b2JqLnRpbWUgPSB0aGlzLmVuZFRpbWUgLSB0aGlzLnN0YXJ0VGltZTtcclxuXHR9XHJcblx0aWYoc2hvd1B1YmxpY1BhdGgpIHtcclxuXHRcdG9iai5wdWJsaWNQYXRoID0gdGhpcy5jb21waWxhdGlvbi5tYWluVGVtcGxhdGUuZ2V0UHVibGljUGF0aCh7XHJcblx0XHRcdGhhc2g6IHRoaXMuY29tcGlsYXRpb24uaGFzaFxyXG5cdFx0fSk7XHJcblx0fVxyXG5cdGlmKHNob3dBc3NldHMpIHtcclxuXHRcdHZhciBhc3NldHNCeUZpbGUgPSB7fTtcclxuXHRcdG9iai5hc3NldHNCeUNodW5rTmFtZSA9IHt9O1xyXG5cdFx0b2JqLmFzc2V0cyA9IE9iamVjdC5rZXlzKGNvbXBpbGF0aW9uLmFzc2V0cykubWFwKGZ1bmN0aW9uKGFzc2V0KSB7XHJcblx0XHRcdHZhciBvYmogPSB7XHJcblx0XHRcdFx0bmFtZTogYXNzZXQsXHJcblx0XHRcdFx0c2l6ZTogY29tcGlsYXRpb24uYXNzZXRzW2Fzc2V0XS5zaXplKCksXHJcblx0XHRcdFx0Y2h1bmtzOiBbXSxcclxuXHRcdFx0XHRjaHVua05hbWVzOiBbXSxcclxuXHRcdFx0XHRlbWl0dGVkOiBjb21waWxhdGlvbi5hc3NldHNbYXNzZXRdLmVtaXR0ZWRcclxuXHRcdFx0fTtcclxuXHRcdFx0YXNzZXRzQnlGaWxlW2Fzc2V0XSA9IG9iajtcclxuXHRcdFx0cmV0dXJuIG9iajtcclxuXHRcdH0pLmZpbHRlcihmdW5jdGlvbihhc3NldCkge1xyXG5cdFx0XHRyZXR1cm4gc2hvd0NhY2hlZEFzc2V0cyB8fCBhc3NldC5lbWl0dGVkO1xyXG5cdFx0fSk7XHJcblx0XHRjb21waWxhdGlvbi5jaHVua3MuZm9yRWFjaChmdW5jdGlvbihjaHVuaykge1xyXG5cdFx0XHRjaHVuay5maWxlcy5mb3JFYWNoKGZ1bmN0aW9uKGFzc2V0KSB7XHJcblx0XHRcdFx0aWYoYXNzZXRzQnlGaWxlW2Fzc2V0XSkge1xyXG5cdFx0XHRcdFx0Y2h1bmsuaWRzLmZvckVhY2goZnVuY3Rpb24oaWQpIHtcclxuXHRcdFx0XHRcdFx0YXNzZXRzQnlGaWxlW2Fzc2V0XS5jaHVua3MucHVzaChpZCk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdGlmKGNodW5rLm5hbWUpIHtcclxuXHRcdFx0XHRcdFx0YXNzZXRzQnlGaWxlW2Fzc2V0XS5jaHVua05hbWVzLnB1c2goY2h1bmsubmFtZSk7XHJcblx0XHRcdFx0XHRcdGlmKG9iai5hc3NldHNCeUNodW5rTmFtZVtjaHVuay5uYW1lXSlcclxuXHRcdFx0XHRcdFx0XHRvYmouYXNzZXRzQnlDaHVua05hbWVbY2h1bmsubmFtZV0gPSBbXS5jb25jYXQob2JqLmFzc2V0c0J5Q2h1bmtOYW1lW2NodW5rLm5hbWVdKS5jb25jYXQoW2Fzc2V0XSk7XHJcblx0XHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0XHRvYmouYXNzZXRzQnlDaHVua05hbWVbY2h1bmsubmFtZV0gPSBhc3NldDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0XHRvYmouYXNzZXRzLnNvcnQoc29ydEJ5RmllbGQoc29ydEFzc2V0cykpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZm5Nb2R1bGUobW9kdWxlKSB7XHJcblx0XHR2YXIgb2JqID0ge1xyXG5cdFx0XHRpZDogbW9kdWxlLmlkLFxyXG5cdFx0XHRpZGVudGlmaWVyOiBtb2R1bGUuaWRlbnRpZmllcigpLFxyXG5cdFx0XHRuYW1lOiBtb2R1bGUucmVhZGFibGVJZGVudGlmaWVyKHJlcXVlc3RTaG9ydGVuZXIpLFxyXG5cdFx0XHRpbmRleDogbW9kdWxlLmluZGV4LFxyXG5cdFx0XHRpbmRleDI6IG1vZHVsZS5pbmRleDIsXHJcblx0XHRcdHNpemU6IG1vZHVsZS5zaXplKCksXHJcblx0XHRcdGNhY2hlYWJsZTogISFtb2R1bGUuY2FjaGVhYmxlLFxyXG5cdFx0XHRidWlsdDogISFtb2R1bGUuYnVpbHQsXHJcblx0XHRcdG9wdGlvbmFsOiAhIW1vZHVsZS5vcHRpb25hbCxcclxuXHRcdFx0cHJlZmV0Y2hlZDogISFtb2R1bGUucHJlZmV0Y2hlZCxcclxuXHRcdFx0Y2h1bmtzOiBtb2R1bGUuY2h1bmtzLm1hcChmdW5jdGlvbihjaHVuaykge1xyXG5cdFx0XHRcdHJldHVybiBjaHVuay5pZDtcclxuXHRcdFx0fSksXHJcblx0XHRcdGFzc2V0czogT2JqZWN0LmtleXMobW9kdWxlLmFzc2V0cyB8fCB7fSksXHJcblx0XHRcdGlzc3VlcjogbW9kdWxlLmlzc3VlcixcclxuXHRcdFx0cHJvZmlsZTogbW9kdWxlLnByb2ZpbGUsXHJcblx0XHRcdGZhaWxlZDogISFtb2R1bGUuZXJyb3IsXHJcblx0XHRcdGVycm9yczogbW9kdWxlLmVycm9ycyAmJiBtb2R1bGUuZGVwZW5kZW5jaWVzRXJyb3JzICYmIChtb2R1bGUuZXJyb3JzLmxlbmd0aCArIG1vZHVsZS5kZXBlbmRlbmNpZXNFcnJvcnMubGVuZ3RoKSxcclxuXHRcdFx0d2FybmluZ3M6IG1vZHVsZS5lcnJvcnMgJiYgbW9kdWxlLmRlcGVuZGVuY2llc0Vycm9ycyAmJiAobW9kdWxlLndhcm5pbmdzLmxlbmd0aCArIG1vZHVsZS5kZXBlbmRlbmNpZXNXYXJuaW5ncy5sZW5ndGgpXHJcblx0XHR9O1xyXG5cdFx0aWYoc2hvd1JlYXNvbnMpIHtcclxuXHRcdFx0b2JqLnJlYXNvbnMgPSBtb2R1bGUucmVhc29ucy5maWx0ZXIoZnVuY3Rpb24ocmVhc29uKSB7XHJcblx0XHRcdFx0cmV0dXJuIHJlYXNvbi5kZXBlbmRlbmN5ICYmIHJlYXNvbi5tb2R1bGU7XHJcblx0XHRcdH0pLm1hcChmdW5jdGlvbihyZWFzb24pIHtcclxuXHRcdFx0XHR2YXIgb2JqID0ge1xyXG5cdFx0XHRcdFx0bW9kdWxlSWQ6IHJlYXNvbi5tb2R1bGUuaWQsXHJcblx0XHRcdFx0XHRtb2R1bGVJZGVudGlmaWVyOiByZWFzb24ubW9kdWxlLmlkZW50aWZpZXIoKSxcclxuXHRcdFx0XHRcdG1vZHVsZTogcmVhc29uLm1vZHVsZS5yZWFkYWJsZUlkZW50aWZpZXIocmVxdWVzdFNob3J0ZW5lciksXHJcblx0XHRcdFx0XHRtb2R1bGVOYW1lOiByZWFzb24ubW9kdWxlLnJlYWRhYmxlSWRlbnRpZmllcihyZXF1ZXN0U2hvcnRlbmVyKSxcclxuXHRcdFx0XHRcdHR5cGU6IHJlYXNvbi5kZXBlbmRlbmN5LnR5cGUsXHJcblx0XHRcdFx0XHR1c2VyUmVxdWVzdDogcmVhc29uLmRlcGVuZGVuY3kudXNlclJlcXVlc3RcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHRcdHZhciBkZXAgPSByZWFzb24uZGVwZW5kZW5jeTtcclxuXHRcdFx0XHRpZihkZXAudGVtcGxhdGVNb2R1bGVzKSBvYmoudGVtcGxhdGVNb2R1bGVzID0gZGVwLnRlbXBsYXRlTW9kdWxlcy5tYXAoZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gbW9kdWxlLmlkO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdGlmKHR5cGVvZiBkZXAubG9jID09PSBcIm9iamVjdFwiKSBvYmoubG9jID0gZGVwLmxvYy5zdGFydC5saW5lICsgXCI6XCIgKyBkZXAubG9jLnN0YXJ0LmNvbHVtbiArIFwiLVwiICtcclxuXHRcdFx0XHRcdChkZXAubG9jLnN0YXJ0LmxpbmUgIT09IGRlcC5sb2MuZW5kLmxpbmUgPyBkZXAubG9jLmVuZC5saW5lICsgXCI6XCIgOiBcIlwiKSArIGRlcC5sb2MuZW5kLmNvbHVtbjtcclxuXHRcdFx0XHRyZXR1cm4gb2JqO1xyXG5cdFx0XHR9KS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdFx0XHRyZXR1cm4gYS5tb2R1bGVJZCAtIGIubW9kdWxlSWQ7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdFx0aWYoc2hvd1NvdXJjZSAmJiBtb2R1bGUuX3NvdXJjZSkge1xyXG5cdFx0XHRvYmouc291cmNlID0gbW9kdWxlLl9zb3VyY2Uuc291cmNlKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gb2JqO1xyXG5cdH1cclxuXHRpZihzaG93Q2h1bmtzKSB7XHJcblx0XHRvYmouY2h1bmtzID0gY29tcGlsYXRpb24uY2h1bmtzLm1hcChmdW5jdGlvbihjaHVuaykge1xyXG5cdFx0XHR2YXIgb2JqID0ge1xyXG5cdFx0XHRcdGlkOiBjaHVuay5pZCxcclxuXHRcdFx0XHRyZW5kZXJlZDogY2h1bmsucmVuZGVyZWQsXHJcblx0XHRcdFx0aW5pdGlhbDogISFjaHVuay5pbml0aWFsLFxyXG5cdFx0XHRcdGVudHJ5OiAhIWNodW5rLmVudHJ5LFxyXG5cdFx0XHRcdGV4dHJhQXN5bmM6ICEhY2h1bmsuZXh0cmFBc3luYyxcclxuXHRcdFx0XHRzaXplOiBjaHVuay5tb2R1bGVzLnJlZHVjZShmdW5jdGlvbihzaXplLCBtb2R1bGUpIHtcclxuXHRcdFx0XHRcdHJldHVybiBzaXplICsgbW9kdWxlLnNpemUoKTtcclxuXHRcdFx0XHR9LCAwKSxcclxuXHRcdFx0XHRuYW1lczogY2h1bmsubmFtZSA/IFtjaHVuay5uYW1lXSA6IFtdLFxyXG5cdFx0XHRcdGZpbGVzOiBjaHVuay5maWxlcy5zbGljZSgpLFxyXG5cdFx0XHRcdGhhc2g6IGNodW5rLnJlbmRlcmVkSGFzaCxcclxuXHRcdFx0XHRwYXJlbnRzOiBjaHVuay5wYXJlbnRzLm1hcChmdW5jdGlvbihjKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gYy5pZDtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHR9O1xyXG5cdFx0XHRpZihzaG93Q2h1bmtNb2R1bGVzKSB7XHJcblx0XHRcdFx0b2JqLm1vZHVsZXMgPSBjaHVuay5tb2R1bGVzLmZpbHRlcihtb2R1bGVGaWx0ZXIpLm1hcChmbk1vZHVsZSk7XHJcblx0XHRcdFx0b2JqLmZpbHRlcmVkTW9kdWxlcyA9IGNodW5rLm1vZHVsZXMubGVuZ3RoIC0gb2JqLm1vZHVsZXMubGVuZ3RoO1xyXG5cdFx0XHRcdG9iai5tb2R1bGVzLnNvcnQoc29ydEJ5RmllbGQoc29ydE1vZHVsZXMpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihzaG93Q2h1bmtPcmlnaW5zKSB7XHJcblx0XHRcdFx0b2JqLm9yaWdpbnMgPSBjaHVuay5vcmlnaW5zLm1hcChmdW5jdGlvbihvcmlnaW4pIHtcclxuXHRcdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRcdG1vZHVsZUlkOiBvcmlnaW4ubW9kdWxlID8gb3JpZ2luLm1vZHVsZS5pZCA6IHVuZGVmaW5lZCxcclxuXHRcdFx0XHRcdFx0bW9kdWxlOiBvcmlnaW4ubW9kdWxlID8gb3JpZ2luLm1vZHVsZS5pZGVudGlmaWVyKCkgOiBcIlwiLFxyXG5cdFx0XHRcdFx0XHRtb2R1bGVJZGVudGlmaWVyOiBvcmlnaW4ubW9kdWxlID8gb3JpZ2luLm1vZHVsZS5pZGVudGlmaWVyKCkgOiBcIlwiLFxyXG5cdFx0XHRcdFx0XHRtb2R1bGVOYW1lOiBvcmlnaW4ubW9kdWxlID8gb3JpZ2luLm1vZHVsZS5yZWFkYWJsZUlkZW50aWZpZXIocmVxdWVzdFNob3J0ZW5lcikgOiBcIlwiLFxyXG5cdFx0XHRcdFx0XHRsb2M6IHR5cGVvZiBvcmlnaW4ubG9jID09PSBcIm9iamVjdFwiID8gb2JqLmxvYyA9IG9yaWdpbi5sb2Muc3RhcnQubGluZSArIFwiOlwiICsgb3JpZ2luLmxvYy5zdGFydC5jb2x1bW4gKyBcIi1cIiArXHJcblx0XHRcdFx0XHRcdFx0KG9yaWdpbi5sb2Muc3RhcnQubGluZSAhPT0gb3JpZ2luLmxvYy5lbmQubGluZSA/IG9yaWdpbi5sb2MuZW5kLmxpbmUgKyBcIjpcIiA6IFwiXCIpICsgb3JpZ2luLmxvYy5lbmQuY29sdW1uIDogXCJcIixcclxuXHRcdFx0XHRcdFx0bmFtZTogb3JpZ2luLm5hbWUsXHJcblx0XHRcdFx0XHRcdHJlYXNvbnM6IG9yaWdpbi5yZWFzb25zIHx8IFtdXHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBvYmo7XHJcblx0XHR9KTtcclxuXHRcdG9iai5jaHVua3Muc29ydChzb3J0QnlGaWVsZChzb3J0Q2h1bmtzKSk7XHJcblx0fVxyXG5cdGlmKHNob3dNb2R1bGVzKSB7XHJcblx0XHRvYmoubW9kdWxlcyA9IGNvbXBpbGF0aW9uLm1vZHVsZXMuZmlsdGVyKG1vZHVsZUZpbHRlcikubWFwKGZuTW9kdWxlKTtcclxuXHRcdG9iai5maWx0ZXJlZE1vZHVsZXMgPSBjb21waWxhdGlvbi5tb2R1bGVzLmxlbmd0aCAtIG9iai5tb2R1bGVzLmxlbmd0aDtcclxuXHRcdG9iai5tb2R1bGVzLnNvcnQoc29ydEJ5RmllbGQoc29ydE1vZHVsZXMpKTtcclxuXHR9XHJcblx0aWYoc2hvd0NoaWxkcmVuKSB7XHJcblx0XHRvYmouY2hpbGRyZW4gPSBjb21waWxhdGlvbi5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oY2hpbGQpIHtcclxuXHRcdFx0dmFyIG9iaiA9IG5ldyBTdGF0cyhjaGlsZCkudG9Kc29uKG9wdGlvbnMsIGZvclRvU3RyaW5nKTtcclxuXHRcdFx0ZGVsZXRlIG9iai5oYXNoO1xyXG5cdFx0XHRkZWxldGUgb2JqLnZlcnNpb247XHJcblx0XHRcdG9iai5uYW1lID0gY2hpbGQubmFtZTtcclxuXHRcdFx0cmV0dXJuIG9iajtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHRyZXR1cm4gb2JqO1xyXG59O1xyXG5cclxuU3RhdHMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xyXG5cdGlmKHR5cGVvZiBvcHRpb25zID09PSBcImJvb2xlYW5cIiB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0b3B0aW9ucyA9IFN0YXRzLnByZXNldFRvT3B0aW9ucyhvcHRpb25zKTtcclxuXHR9IGVsc2UgaWYoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcclxuXHJcblx0ZnVuY3Rpb24gZCh2LCBkZWYpIHtcclxuXHRcdHJldHVybiB2ID09PSB1bmRlZmluZWQgPyBkZWYgOiB2O1xyXG5cdH1cclxuXHR2YXIgdXNlQ29sb3JzID0gZChvcHRpb25zLmNvbG9ycywgZmFsc2UpO1xyXG5cclxuXHR2YXIgb2JqID0gdGhpcy50b0pzb24ob3B0aW9ucywgdHJ1ZSk7XHJcblxyXG5cdHJldHVybiBTdGF0cy5qc29uVG9TdHJpbmcob2JqLCB1c2VDb2xvcnMpO1xyXG59O1xyXG5cclxuU3RhdHMuanNvblRvU3RyaW5nID0gZnVuY3Rpb24ganNvblRvU3RyaW5nKG9iaiwgdXNlQ29sb3JzKSB7XHJcblx0dmFyIGJ1ZiA9IFtdO1xyXG5cclxuXHRmdW5jdGlvbiBub3JtYWwoc3RyKSB7XHJcblx0XHRidWYucHVzaChzdHIpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gYm9sZChzdHIpIHtcclxuXHRcdGlmKHVzZUNvbG9ycykgYnVmLnB1c2goXCJcXHUwMDFiWzFtXCIpO1xyXG5cdFx0YnVmLnB1c2goc3RyKTtcclxuXHRcdGlmKHVzZUNvbG9ycykgYnVmLnB1c2goXCJcXHUwMDFiWzIybVwiKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHllbGxvdyhzdHIpIHtcclxuXHRcdGlmKHVzZUNvbG9ycykgYnVmLnB1c2goXCJcXHUwMDFiWzFtXFx1MDAxYlszM21cIik7XHJcblx0XHRidWYucHVzaChzdHIpO1xyXG5cdFx0aWYodXNlQ29sb3JzKSBidWYucHVzaChcIlxcdTAwMWJbMzltXFx1MDAxYlsyMm1cIik7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZWQoc3RyKSB7XHJcblx0XHRpZih1c2VDb2xvcnMpIGJ1Zi5wdXNoKFwiXFx1MDAxYlsxbVxcdTAwMWJbMzFtXCIpO1xyXG5cdFx0YnVmLnB1c2goc3RyKTtcclxuXHRcdGlmKHVzZUNvbG9ycykgYnVmLnB1c2goXCJcXHUwMDFiWzM5bVxcdTAwMWJbMjJtXCIpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ3JlZW4oc3RyKSB7XHJcblx0XHRpZih1c2VDb2xvcnMpIGJ1Zi5wdXNoKFwiXFx1MDAxYlsxbVxcdTAwMWJbMzJtXCIpO1xyXG5cdFx0YnVmLnB1c2goc3RyKTtcclxuXHRcdGlmKHVzZUNvbG9ycykgYnVmLnB1c2goXCJcXHUwMDFiWzM5bVxcdTAwMWJbMjJtXCIpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gY3lhbihzdHIpIHtcclxuXHRcdGlmKHVzZUNvbG9ycykgYnVmLnB1c2goXCJcXHUwMDFiWzFtXFx1MDAxYlszNm1cIik7XHJcblx0XHRidWYucHVzaChzdHIpO1xyXG5cdFx0aWYodXNlQ29sb3JzKSBidWYucHVzaChcIlxcdTAwMWJbMzltXFx1MDAxYlsyMm1cIik7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBtYWdlbnRhKHN0cikge1xyXG5cdFx0aWYodXNlQ29sb3JzKSBidWYucHVzaChcIlxcdTAwMWJbMW1cXHUwMDFiWzM1bVwiKTtcclxuXHRcdGJ1Zi5wdXNoKHN0cik7XHJcblx0XHRpZih1c2VDb2xvcnMpIGJ1Zi5wdXNoKFwiXFx1MDAxYlszOW1cXHUwMDFiWzIybVwiKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNvbG9yZWRUaW1lKHRpbWUpIHtcclxuXHRcdHZhciB0aW1lcyA9IFs4MDAsIDQwMCwgMjAwLCAxMDBdO1xyXG5cdFx0aWYob2JqLnRpbWUpIHtcclxuXHRcdFx0dGltZXMgPSBbb2JqLnRpbWUgLyAyLCBvYmoudGltZSAvIDQsIG9iai50aW1lIC8gOCwgb2JqLnRpbWUgLyAxNl07XHJcblx0XHR9XHJcblx0XHRpZih0aW1lIDwgdGltZXNbM10pXHJcblx0XHRcdG5vcm1hbCh0aW1lICsgXCJtc1wiKTtcclxuXHRcdGVsc2UgaWYodGltZSA8IHRpbWVzWzJdKVxyXG5cdFx0XHRib2xkKHRpbWUgKyBcIm1zXCIpO1xyXG5cdFx0ZWxzZSBpZih0aW1lIDwgdGltZXNbMV0pXHJcblx0XHRcdGdyZWVuKHRpbWUgKyBcIm1zXCIpO1xyXG5cdFx0ZWxzZSBpZih0aW1lIDwgdGltZXNbMF0pXHJcblx0XHRcdHllbGxvdyh0aW1lICsgXCJtc1wiKTtcclxuXHRcdGVsc2VcclxuXHRcdFx0cmVkKHRpbWUgKyBcIm1zXCIpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gbmV3bGluZSgpIHtcclxuXHRcdGJ1Zi5wdXNoKFwiXFxuXCIpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdGFibGUoYXJyYXksIGZvcm1hdHMsIGFsaWduLCBzcGxpdHRlcikge1xyXG5cdFx0dmFyIHJvd3MgPSBhcnJheS5sZW5ndGg7XHJcblx0XHR2YXIgY29scyA9IGFycmF5WzBdLmxlbmd0aDtcclxuXHRcdHZhciBjb2xTaXplcyA9IG5ldyBBcnJheShjb2xzKTtcclxuXHRcdGZvcih2YXIgY29sID0gMDsgY29sIDwgY29sczsgY29sKyspXHJcblx0XHRcdGNvbFNpemVzW2NvbF0gPSAzO1xyXG5cdFx0Zm9yKHZhciByb3cgPSAwOyByb3cgPCByb3dzOyByb3crKykge1xyXG5cdFx0XHRmb3IodmFyIGNvbCA9IDA7IGNvbCA8IGNvbHM7IGNvbCsrKSB7XHJcblx0XHRcdFx0dmFyIHZhbHVlID0gYXJyYXlbcm93XVtjb2xdICsgXCJcIjtcclxuXHRcdFx0XHRpZih2YWx1ZS5sZW5ndGggPiBjb2xTaXplc1tjb2xdKSB7XHJcblx0XHRcdFx0XHRjb2xTaXplc1tjb2xdID0gdmFsdWUubGVuZ3RoO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Zm9yKHZhciByb3cgPSAwOyByb3cgPCByb3dzOyByb3crKykge1xyXG5cdFx0XHRmb3IodmFyIGNvbCA9IDA7IGNvbCA8IGNvbHM7IGNvbCsrKSB7XHJcblx0XHRcdFx0dmFyIGZvcm1hdCA9IHJvdyA9PT0gMCA/IGJvbGQgOiBmb3JtYXRzW2NvbF07XHJcblx0XHRcdFx0dmFyIHZhbHVlID0gYXJyYXlbcm93XVtjb2xdICsgXCJcIjtcclxuXHRcdFx0XHR2YXIgbCA9IHZhbHVlLmxlbmd0aDtcclxuXHRcdFx0XHRpZihhbGlnbltjb2xdID09PSBcImxcIilcclxuXHRcdFx0XHRcdGZvcm1hdCh2YWx1ZSk7XHJcblx0XHRcdFx0Zm9yKDsgbCA8IGNvbFNpemVzW2NvbF0gJiYgY29sICE9PSBjb2xzIC0gMTsgbCsrKVxyXG5cdFx0XHRcdFx0bm9ybWFsKFwiIFwiKTtcclxuXHRcdFx0XHRpZihhbGlnbltjb2xdID09PSBcInJcIilcclxuXHRcdFx0XHRcdGZvcm1hdCh2YWx1ZSk7XHJcblx0XHRcdFx0aWYoY29sICsgMSA8IGNvbHMpXHJcblx0XHRcdFx0XHRub3JtYWwoc3BsaXR0ZXIgfHwgXCIgIFwiKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRuZXdsaW5lKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBmb3JtYXRTaXplKHNpemUpIHtcclxuXHRcdGlmKHNpemUgPD0gMCkgcmV0dXJuIFwiMCBieXRlc1wiO1xyXG5cclxuXHRcdHZhciBhYmJyZXZpYXRpb25zID0gW1wiYnl0ZXNcIiwgXCJrQlwiLCBcIk1CXCIsIFwiR0JcIl07XHJcblx0XHR2YXIgaW5kZXggPSBNYXRoLmZsb29yKE1hdGgubG9nKHNpemUpIC8gTWF0aC5sb2coMTAwMCkpO1xyXG5cclxuXHRcdHJldHVybiArKHNpemUgLyBNYXRoLnBvdygxMDAwLCBpbmRleCkpXHJcblx0XHRcdC50b1ByZWNpc2lvbigzKSArIFwiIFwiICsgYWJicmV2aWF0aW9uc1tpbmRleF07XHJcblx0fVxyXG5cclxuXHRpZihvYmouaGFzaCkge1xyXG5cdFx0bm9ybWFsKFwiSGFzaDogXCIpO1xyXG5cdFx0Ym9sZChvYmouaGFzaCk7XHJcblx0XHRuZXdsaW5lKCk7XHJcblx0fVxyXG5cdGlmKG9iai52ZXJzaW9uKSB7XHJcblx0XHRub3JtYWwoXCJWZXJzaW9uOiB3ZWJwYWNrIFwiKTtcclxuXHRcdGJvbGQob2JqLnZlcnNpb24pO1xyXG5cdFx0bmV3bGluZSgpO1xyXG5cdH1cclxuXHRpZih0eXBlb2Ygb2JqLnRpbWUgPT09IFwibnVtYmVyXCIpIHtcclxuXHRcdG5vcm1hbChcIlRpbWU6IFwiKTtcclxuXHRcdGJvbGQob2JqLnRpbWUpO1xyXG5cdFx0bm9ybWFsKFwibXNcIik7XHJcblx0XHRuZXdsaW5lKCk7XHJcblx0fVxyXG5cdGlmKG9iai5wdWJsaWNQYXRoKSB7XHJcblx0XHRub3JtYWwoXCJQdWJsaWNQYXRoOiBcIik7XHJcblx0XHRib2xkKG9iai5wdWJsaWNQYXRoKTtcclxuXHRcdG5ld2xpbmUoKTtcclxuXHR9XHJcblx0aWYob2JqLmFzc2V0cyAmJiBvYmouYXNzZXRzLmxlbmd0aCA+IDApIHtcclxuXHRcdHZhciB0ID0gW1xyXG5cdFx0XHRbXCJBc3NldFwiLCBcIlNpemVcIiwgXCJDaHVua3NcIiwgXCJcIiwgXCJDaHVuayBOYW1lc1wiXVxyXG5cdFx0XTtcclxuXHRcdG9iai5hc3NldHMuZm9yRWFjaChmdW5jdGlvbihhc3NldCkge1xyXG5cdFx0XHR0LnB1c2goW1xyXG5cdFx0XHRcdGFzc2V0Lm5hbWUsXHJcblx0XHRcdFx0Zm9ybWF0U2l6ZShhc3NldC5zaXplKSxcclxuXHRcdFx0XHRhc3NldC5jaHVua3Muam9pbihcIiwgXCIpLFxyXG5cdFx0XHRcdGFzc2V0LmVtaXR0ZWQgPyBcIltlbWl0dGVkXVwiIDogXCJcIixcclxuXHRcdFx0XHRhc3NldC5jaHVua05hbWVzLmpvaW4oXCIsIFwiKVxyXG5cdFx0XHRdKTtcclxuXHRcdH0pO1xyXG5cdFx0dGFibGUodCwgW2dyZWVuLCBub3JtYWwsIGJvbGQsIGdyZWVuLCBub3JtYWxdLCBcInJycmxsXCIpO1xyXG5cdH1cclxuXHR2YXIgbW9kdWxlc0J5SWRlbnRpZmllciA9IHt9O1xyXG5cdGlmKG9iai5tb2R1bGVzKSB7XHJcblx0XHRvYmoubW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdFx0XHRtb2R1bGVzQnlJZGVudGlmaWVyW1wiJFwiICsgbW9kdWxlLmlkZW50aWZpZXJdID0gbW9kdWxlO1xyXG5cdFx0fSk7XHJcblx0fSBlbHNlIGlmKG9iai5jaHVua3MpIHtcclxuXHRcdG9iai5jaHVua3MuZm9yRWFjaChmdW5jdGlvbihjaHVuaykge1xyXG5cdFx0XHRpZihjaHVuay5tb2R1bGVzKSB7XHJcblx0XHRcdFx0Y2h1bmsubW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdFx0XHRcdFx0bW9kdWxlc0J5SWRlbnRpZmllcltcIiRcIiArIG1vZHVsZS5pZGVudGlmaWVyXSA9IG1vZHVsZTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBwcm9jZXNzUHJvZmlsZShtb2R1bGUpIHtcclxuXHRcdGlmKG1vZHVsZS5wcm9maWxlKSB7XHJcblx0XHRcdG5vcm1hbChcIiAgICAgIFwiKTtcclxuXHRcdFx0dmFyIHN1bSA9IDAsXHJcblx0XHRcdFx0YWxsb3dTdW0gPSB0cnVlO1xyXG5cdFx0XHR2YXIgcGF0aCA9IFtdO1xyXG5cdFx0XHR2YXIgY3VycmVudCA9IG1vZHVsZTtcclxuXHRcdFx0d2hpbGUoY3VycmVudC5pc3N1ZXIpIHtcclxuXHRcdFx0XHRpZighbW9kdWxlc0J5SWRlbnRpZmllcltcIiRcIiArIGN1cnJlbnQuaXNzdWVyXSkge1xyXG5cdFx0XHRcdFx0bm9ybWFsKFwiIC4uLiAtPlwiKTtcclxuXHRcdFx0XHRcdGFsbG93U3VtID0gZmFsc2U7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cGF0aC51bnNoaWZ0KGN1cnJlbnQgPSBtb2R1bGVzQnlJZGVudGlmaWVyW1wiJFwiICsgY3VycmVudC5pc3N1ZXJdKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRwYXRoLmZvckVhY2goZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0XHRcdFx0bm9ybWFsKFwiIFtcIik7XHJcblx0XHRcdFx0bm9ybWFsKG1vZHVsZS5pZCk7XHJcblx0XHRcdFx0bm9ybWFsKFwiXSBcIik7XHJcblx0XHRcdFx0aWYobW9kdWxlLnByb2ZpbGUpIHtcclxuXHRcdFx0XHRcdHZhciB0aW1lID0gKG1vZHVsZS5wcm9maWxlLmZhY3RvcnkgfHwgMCkgKyAobW9kdWxlLnByb2ZpbGUuYnVpbGRpbmcgfHwgMCk7XHJcblx0XHRcdFx0XHRjb2xvcmVkVGltZSh0aW1lKTtcclxuXHRcdFx0XHRcdHN1bSArPSB0aW1lO1xyXG5cdFx0XHRcdFx0bm9ybWFsKFwiIFwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bm9ybWFsKFwiLT5cIik7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRPYmplY3Qua2V5cyhtb2R1bGUucHJvZmlsZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcclxuXHRcdFx0XHRub3JtYWwoXCIgXCIgKyBrZXkgKyBcIjpcIik7XHJcblx0XHRcdFx0dmFyIHRpbWUgPSBtb2R1bGUucHJvZmlsZVtrZXldO1xyXG5cdFx0XHRcdGNvbG9yZWRUaW1lKHRpbWUpO1xyXG5cdFx0XHRcdHN1bSArPSB0aW1lO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0aWYoYWxsb3dTdW0pIHtcclxuXHRcdFx0XHRub3JtYWwoXCIgPSBcIik7XHJcblx0XHRcdFx0Y29sb3JlZFRpbWUoc3VtKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRuZXdsaW5lKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBwcm9jZXNzTW9kdWxlQXR0cmlidXRlcyhtb2R1bGUpIHtcclxuXHRcdG5vcm1hbChcIiBcIik7XHJcblx0XHRub3JtYWwoZm9ybWF0U2l6ZShtb2R1bGUuc2l6ZSkpO1xyXG5cdFx0aWYobW9kdWxlLmNodW5rcykge1xyXG5cdFx0XHRtb2R1bGUuY2h1bmtzLmZvckVhY2goZnVuY3Rpb24oY2h1bmspIHtcclxuXHRcdFx0XHRub3JtYWwoXCIge1wiKTtcclxuXHRcdFx0XHR5ZWxsb3coY2h1bmspO1xyXG5cdFx0XHRcdG5vcm1hbChcIn1cIik7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdFx0aWYoIW1vZHVsZS5jYWNoZWFibGUpIHtcclxuXHRcdFx0cmVkKFwiIFtub3QgY2FjaGVhYmxlXVwiKTtcclxuXHRcdH1cclxuXHRcdGlmKG1vZHVsZS5vcHRpb25hbCkge1xyXG5cdFx0XHR5ZWxsb3coXCIgW29wdGlvbmFsXVwiKTtcclxuXHRcdH1cclxuXHRcdGlmKG1vZHVsZS5idWlsdCkge1xyXG5cdFx0XHRncmVlbihcIiBbYnVpbHRdXCIpO1xyXG5cdFx0fVxyXG5cdFx0aWYobW9kdWxlLnByZWZldGNoZWQpIHtcclxuXHRcdFx0bWFnZW50YShcIiBbcHJlZmV0Y2hlZF1cIik7XHJcblx0XHR9XHJcblx0XHRpZihtb2R1bGUuZmFpbGVkKVxyXG5cdFx0XHRyZWQoXCIgW2ZhaWxlZF1cIik7XHJcblx0XHRpZihtb2R1bGUud2FybmluZ3MpXHJcblx0XHRcdHllbGxvdyhcIiBbXCIgKyBtb2R1bGUud2FybmluZ3MgKyBcIiB3YXJuaW5nXCIgKyAobW9kdWxlLndhcm5pbmdzID09PSAxID8gXCJcIiA6IFwic1wiKSArIFwiXVwiKTtcclxuXHRcdGlmKG1vZHVsZS5lcnJvcnMpXHJcblx0XHRcdHJlZChcIiBbXCIgKyBtb2R1bGUuZXJyb3JzICsgXCIgZXJyb3JcIiArIChtb2R1bGUuZXJyb3JzID09PSAxID8gXCJcIiA6IFwic1wiKSArIFwiXVwiKTtcclxuXHR9XHJcblx0aWYob2JqLmNodW5rcykge1xyXG5cdFx0b2JqLmNodW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGNodW5rKSB7XHJcblx0XHRcdG5vcm1hbChcImNodW5rIFwiKTtcclxuXHRcdFx0aWYoY2h1bmsuaWQgPCAxMDAwKSBub3JtYWwoXCIgXCIpO1xyXG5cdFx0XHRpZihjaHVuay5pZCA8IDEwMCkgbm9ybWFsKFwiIFwiKTtcclxuXHRcdFx0aWYoY2h1bmsuaWQgPCAxMCkgbm9ybWFsKFwiIFwiKTtcclxuXHRcdFx0bm9ybWFsKFwie1wiKTtcclxuXHRcdFx0eWVsbG93KGNodW5rLmlkKTtcclxuXHRcdFx0bm9ybWFsKFwifSBcIik7XHJcblx0XHRcdGdyZWVuKGNodW5rLmZpbGVzLmpvaW4oXCIsIFwiKSk7XHJcblx0XHRcdGlmKGNodW5rLm5hbWVzICYmIGNodW5rLm5hbWVzLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRub3JtYWwoXCIgKFwiKTtcclxuXHRcdFx0XHRub3JtYWwoY2h1bmsubmFtZXMuam9pbihcIiwgXCIpKTtcclxuXHRcdFx0XHRub3JtYWwoXCIpXCIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdG5vcm1hbChcIiBcIik7XHJcblx0XHRcdG5vcm1hbChmb3JtYXRTaXplKGNodW5rLnNpemUpKTtcclxuXHRcdFx0Y2h1bmsucGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGlkKSB7XHJcblx0XHRcdFx0bm9ybWFsKFwiIHtcIik7XHJcblx0XHRcdFx0eWVsbG93KGlkKTtcclxuXHRcdFx0XHRub3JtYWwoXCJ9XCIpO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0aWYoY2h1bmsucmVuZGVyZWQpIHtcclxuXHRcdFx0XHRncmVlbihcIiBbcmVuZGVyZWRdXCIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdG5ld2xpbmUoKTtcclxuXHRcdFx0aWYoY2h1bmsub3JpZ2lucykge1xyXG5cdFx0XHRcdGNodW5rLm9yaWdpbnMuZm9yRWFjaChmdW5jdGlvbihvcmlnaW4pIHtcclxuXHRcdFx0XHRcdG5vcm1hbChcIiAgICA+IFwiKTtcclxuXHRcdFx0XHRcdGlmKG9yaWdpbi5yZWFzb25zICYmIG9yaWdpbi5yZWFzb25zLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHR5ZWxsb3cob3JpZ2luLnJlYXNvbnMuam9pbihcIiBcIikpO1xyXG5cdFx0XHRcdFx0XHRub3JtYWwoXCIgXCIpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYob3JpZ2luLm5hbWUpIHtcclxuXHRcdFx0XHRcdFx0bm9ybWFsKG9yaWdpbi5uYW1lKTtcclxuXHRcdFx0XHRcdFx0bm9ybWFsKFwiIFwiKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKG9yaWdpbi5tb2R1bGUpIHtcclxuXHRcdFx0XHRcdFx0bm9ybWFsKFwiW1wiKTtcclxuXHRcdFx0XHRcdFx0bm9ybWFsKG9yaWdpbi5tb2R1bGVJZCk7XHJcblx0XHRcdFx0XHRcdG5vcm1hbChcIl0gXCIpO1xyXG5cdFx0XHRcdFx0XHR2YXIgbW9kdWxlID0gbW9kdWxlc0J5SWRlbnRpZmllcltcIiRcIiArIG9yaWdpbi5tb2R1bGVdO1xyXG5cdFx0XHRcdFx0XHRpZihtb2R1bGUpIHtcclxuXHRcdFx0XHRcdFx0XHRib2xkKG1vZHVsZS5uYW1lKTtcclxuXHRcdFx0XHRcdFx0XHRub3JtYWwoXCIgXCIpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGlmKG9yaWdpbi5sb2MpIHtcclxuXHRcdFx0XHRcdFx0XHRub3JtYWwob3JpZ2luLmxvYyk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdG5ld2xpbmUoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihjaHVuay5tb2R1bGVzKSB7XHJcblx0XHRcdFx0Y2h1bmsubW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdFx0XHRcdFx0bm9ybWFsKFwiIFwiKTtcclxuXHRcdFx0XHRcdGlmKG1vZHVsZS5pZCA8IDEwMDApIG5vcm1hbChcIiBcIik7XHJcblx0XHRcdFx0XHRpZihtb2R1bGUuaWQgPCAxMDApIG5vcm1hbChcIiBcIik7XHJcblx0XHRcdFx0XHRpZihtb2R1bGUuaWQgPCAxMCkgbm9ybWFsKFwiIFwiKTtcclxuXHRcdFx0XHRcdG5vcm1hbChcIltcIik7XHJcblx0XHRcdFx0XHRub3JtYWwobW9kdWxlLmlkKTtcclxuXHRcdFx0XHRcdG5vcm1hbChcIl0gXCIpO1xyXG5cdFx0XHRcdFx0Ym9sZChtb2R1bGUubmFtZSk7XHJcblx0XHRcdFx0XHRwcm9jZXNzTW9kdWxlQXR0cmlidXRlcyhtb2R1bGUpO1xyXG5cdFx0XHRcdFx0bmV3bGluZSgpO1xyXG5cdFx0XHRcdFx0aWYobW9kdWxlLnJlYXNvbnMpIHtcclxuXHRcdFx0XHRcdFx0bW9kdWxlLnJlYXNvbnMuZm9yRWFjaChmdW5jdGlvbihyZWFzb24pIHtcclxuXHRcdFx0XHRcdFx0XHRub3JtYWwoXCIgICAgICAgIFwiKTtcclxuXHRcdFx0XHRcdFx0XHRub3JtYWwocmVhc29uLnR5cGUpO1xyXG5cdFx0XHRcdFx0XHRcdG5vcm1hbChcIiBcIik7XHJcblx0XHRcdFx0XHRcdFx0Y3lhbihyZWFzb24udXNlclJlcXVlc3QpO1xyXG5cdFx0XHRcdFx0XHRcdGlmKHJlYXNvbi50ZW1wbGF0ZU1vZHVsZXMpIGN5YW4ocmVhc29uLnRlbXBsYXRlTW9kdWxlcy5qb2luKFwiIFwiKSk7XHJcblx0XHRcdFx0XHRcdFx0bm9ybWFsKFwiIFtcIik7XHJcblx0XHRcdFx0XHRcdFx0bm9ybWFsKHJlYXNvbi5tb2R1bGVJZCk7XHJcblx0XHRcdFx0XHRcdFx0bm9ybWFsKFwiXSBcIik7XHJcblx0XHRcdFx0XHRcdFx0bWFnZW50YShyZWFzb24ubW9kdWxlKTtcclxuXHRcdFx0XHRcdFx0XHRpZihyZWFzb24ubG9jKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRub3JtYWwoXCIgXCIpO1xyXG5cdFx0XHRcdFx0XHRcdFx0bm9ybWFsKHJlYXNvbi5sb2MpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRuZXdsaW5lKCk7XHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cHJvY2Vzc1Byb2ZpbGUobW9kdWxlKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRpZihjaHVuay5maWx0ZXJlZE1vZHVsZXMgPiAwKSB7XHJcblx0XHRcdFx0XHRub3JtYWwoXCIgICAgICsgXCIgKyBjaHVuay5maWx0ZXJlZE1vZHVsZXMgKyBcIiBoaWRkZW4gbW9kdWxlc1wiKTtcclxuXHRcdFx0XHRcdG5ld2xpbmUoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxuXHRpZihvYmoubW9kdWxlcykge1xyXG5cdFx0b2JqLm1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRcdFx0aWYobW9kdWxlLmlkIDwgMTAwMCkgbm9ybWFsKFwiIFwiKTtcclxuXHRcdFx0aWYobW9kdWxlLmlkIDwgMTAwKSBub3JtYWwoXCIgXCIpO1xyXG5cdFx0XHRpZihtb2R1bGUuaWQgPCAxMCkgbm9ybWFsKFwiIFwiKTtcclxuXHRcdFx0bm9ybWFsKFwiW1wiKTtcclxuXHRcdFx0bm9ybWFsKG1vZHVsZS5pZCk7XHJcblx0XHRcdG5vcm1hbChcIl0gXCIpO1xyXG5cdFx0XHRib2xkKG1vZHVsZS5uYW1lIHx8IG1vZHVsZS5pZGVudGlmaWVyKTtcclxuXHRcdFx0cHJvY2Vzc01vZHVsZUF0dHJpYnV0ZXMobW9kdWxlKTtcclxuXHRcdFx0bmV3bGluZSgpO1xyXG5cdFx0XHRpZihtb2R1bGUucmVhc29ucykge1xyXG5cdFx0XHRcdG1vZHVsZS5yZWFzb25zLmZvckVhY2goZnVuY3Rpb24ocmVhc29uKSB7XHJcblx0XHRcdFx0XHRub3JtYWwoXCIgICAgICAgXCIpO1xyXG5cdFx0XHRcdFx0bm9ybWFsKHJlYXNvbi50eXBlKTtcclxuXHRcdFx0XHRcdG5vcm1hbChcIiBcIik7XHJcblx0XHRcdFx0XHRjeWFuKHJlYXNvbi51c2VyUmVxdWVzdCk7XHJcblx0XHRcdFx0XHRpZihyZWFzb24udGVtcGxhdGVNb2R1bGVzKSBjeWFuKHJlYXNvbi50ZW1wbGF0ZU1vZHVsZXMuam9pbihcIiBcIikpO1xyXG5cdFx0XHRcdFx0bm9ybWFsKFwiIFtcIik7XHJcblx0XHRcdFx0XHRub3JtYWwocmVhc29uLm1vZHVsZUlkKTtcclxuXHRcdFx0XHRcdG5vcm1hbChcIl0gXCIpO1xyXG5cdFx0XHRcdFx0bWFnZW50YShyZWFzb24ubW9kdWxlKTtcclxuXHRcdFx0XHRcdGlmKHJlYXNvbi5sb2MpIHtcclxuXHRcdFx0XHRcdFx0bm9ybWFsKFwiIFwiKTtcclxuXHRcdFx0XHRcdFx0bm9ybWFsKHJlYXNvbi5sb2MpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0bmV3bGluZSgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHByb2Nlc3NQcm9maWxlKG1vZHVsZSk7XHJcblx0XHR9KTtcclxuXHRcdGlmKG9iai5maWx0ZXJlZE1vZHVsZXMgPiAwKSB7XHJcblx0XHRcdG5vcm1hbChcIiAgICArIFwiICsgb2JqLmZpbHRlcmVkTW9kdWxlcyArIFwiIGhpZGRlbiBtb2R1bGVzXCIpO1xyXG5cdFx0XHRuZXdsaW5lKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmKG9iai5fc2hvd1dhcm5pbmdzICYmIG9iai53YXJuaW5ncykge1xyXG5cdFx0b2JqLndhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24od2FybmluZykge1xyXG5cdFx0XHRuZXdsaW5lKCk7XHJcblx0XHRcdHllbGxvdyhcIldBUk5JTkcgaW4gXCIgKyB3YXJuaW5nKTtcclxuXHRcdFx0bmV3bGluZSgpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cdGlmKG9iai5fc2hvd0Vycm9ycyAmJiBvYmouZXJyb3JzKSB7XHJcblx0XHRvYmouZXJyb3JzLmZvckVhY2goZnVuY3Rpb24oZXJyb3IpIHtcclxuXHRcdFx0bmV3bGluZSgpO1xyXG5cdFx0XHRyZWQoXCJFUlJPUiBpbiBcIiArIGVycm9yKTtcclxuXHRcdFx0bmV3bGluZSgpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cdGlmKG9iai5jaGlsZHJlbikge1xyXG5cdFx0b2JqLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcclxuXHRcdFx0aWYoY2hpbGQubmFtZSkge1xyXG5cdFx0XHRcdG5vcm1hbChcIkNoaWxkIFwiKTtcclxuXHRcdFx0XHRib2xkKGNoaWxkLm5hbWUpO1xyXG5cdFx0XHRcdG5vcm1hbChcIjpcIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bm9ybWFsKFwiQ2hpbGRcIik7XHJcblx0XHRcdH1cclxuXHRcdFx0bmV3bGluZSgpO1xyXG5cdFx0XHRidWYucHVzaChcIiAgICBcIik7XHJcblx0XHRcdGJ1Zi5wdXNoKFN0YXRzLmpzb25Ub1N0cmluZyhjaGlsZCwgdXNlQ29sb3JzKS5yZXBsYWNlKC9cXG4vZywgXCJcXG4gICAgXCIpKTtcclxuXHRcdFx0bmV3bGluZSgpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHR3aGlsZShidWZbYnVmLmxlbmd0aCAtIDFdID09PSBcIlxcblwiKSBidWYucG9wKCk7XHJcblx0cmV0dXJuIGJ1Zi5qb2luKFwiXCIpO1xyXG59O1xyXG5cclxuU3RhdHMucHJlc2V0VG9PcHRpb25zID0gZnVuY3Rpb24obmFtZSkge1xyXG5cdC8vQWNjZXB0ZWQgdmFsdWVzOiBub25lLCBlcnJvcnMtb25seSwgbWluaW1hbCwgbm9ybWFsLCB2ZXJib3NlXHJcblx0Ly9Bbnkgb3RoZXIgZmFsc3kgdmFsdWUgd2lsbCBiZWhhdmUgYXMgJ25vbmUnLCB0cnV0aHkgdmFsdWVzIGFzICdub3JtYWwnXHJcblx0dmFyIHBuID0gKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSAmJiBuYW1lLnRvTG93ZXJDYXNlKCkgfHwgbmFtZTtcclxuXHRpZihwbiA9PT0gXCJub25lXCIgfHwgIXBuKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRoYXNoOiBmYWxzZSxcclxuXHRcdFx0dmVyc2lvbjogZmFsc2UsXHJcblx0XHRcdHRpbWluZ3M6IGZhbHNlLFxyXG5cdFx0XHRhc3NldHM6IGZhbHNlLFxyXG5cdFx0XHRjaHVua3M6IGZhbHNlLFxyXG5cdFx0XHRtb2R1bGVzOiBmYWxzZSxcclxuXHRcdFx0cmVhc29uczogZmFsc2UsXHJcblx0XHRcdGNoaWxkcmVuOiBmYWxzZSxcclxuXHRcdFx0c291cmNlOiBmYWxzZSxcclxuXHRcdFx0ZXJyb3JzOiBmYWxzZSxcclxuXHRcdFx0ZXJyb3JEZXRhaWxzOiBmYWxzZSxcclxuXHRcdFx0d2FybmluZ3M6IGZhbHNlLFxyXG5cdFx0XHRwdWJsaWNQYXRoOiBmYWxzZVxyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0YXNzZXRzOiBwbiA9PT0gXCJ2ZXJib3NlXCIsXHJcblx0XHRcdHZlcnNpb246IHBuID09PSBcInZlcmJvc2VcIixcclxuXHRcdFx0dGltaW5nczogcG4gIT09IFwiZXJyb3JzLW9ubHlcIiAmJiBwbiAhPT0gXCJtaW5pbWFsXCIsXHJcblx0XHRcdGhhc2g6IHBuICE9PSBcImVycm9ycy1vbmx5XCIgJiYgcG4gIT09IFwibWluaW1hbFwiLFxyXG5cdFx0XHRjaHVua3M6IHBuICE9PSBcImVycm9ycy1vbmx5XCIsXHJcblx0XHRcdGNodW5rTW9kdWxlczogcG4gPT09IFwidmVyYm9zZVwiLFxyXG5cdFx0XHQvL3dhcm5pbmdzOiBwbiAhPT0gXCJlcnJvcnMtb25seVwiLFxyXG5cdFx0XHRlcnJvckRldGFpbHM6IHBuICE9PSBcImVycm9ycy1vbmx5XCIgJiYgcG4gIT09IFwibWluaW1hbFwiLFxyXG5cdFx0XHRyZWFzb25zOiBwbiA9PT0gXCJ2ZXJib3NlXCIsXHJcblx0XHRcdGNvbG9yczogdHJ1ZVxyXG5cdFx0fTtcclxuXHR9XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvU3RhdHMuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcblxyXG5mdW5jdGlvbiBSZXF1ZXN0U2hvcnRlbmVyKGRpcmVjdG9yeSkge1xyXG5cdGRpcmVjdG9yeSA9IGRpcmVjdG9yeS5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKTtcclxuXHR2YXIgcGFyZW50RGlyZWN0b3J5ID0gcGF0aC5kaXJuYW1lKGRpcmVjdG9yeSk7XHJcblx0aWYoL1tcXC9cXFxcXSQvLnRlc3QoZGlyZWN0b3J5KSkgZGlyZWN0b3J5ID0gZGlyZWN0b3J5LnN1YnN0cigwLCBkaXJlY3RvcnkubGVuZ3RoIC0gMSk7XHJcblx0aWYoZGlyZWN0b3J5KSB7XHJcblx0XHR2YXIgY3VycmVudERpcmVjdG9yeVJlZ0V4cCA9IGRpcmVjdG9yeS5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZywgXCJcXFxcJCZcIik7XHJcblx0XHRjdXJyZW50RGlyZWN0b3J5UmVnRXhwID0gbmV3IFJlZ0V4cChcIl5cIiArIGN1cnJlbnREaXJlY3RvcnlSZWdFeHAgKyBcInwoISlcIiArIGN1cnJlbnREaXJlY3RvcnlSZWdFeHAsIFwiZ1wiKTtcclxuXHJcblx0XHR0aGlzLmN1cnJlbnREaXJlY3RvcnlSZWdFeHAgPSBjdXJyZW50RGlyZWN0b3J5UmVnRXhwO1xyXG5cdH1cclxuXHJcblx0aWYoL1tcXC9cXFxcXSQvLnRlc3QocGFyZW50RGlyZWN0b3J5KSkgcGFyZW50RGlyZWN0b3J5ID0gcGFyZW50RGlyZWN0b3J5LnN1YnN0cigwLCBwYXJlbnREaXJlY3RvcnkubGVuZ3RoIC0gMSk7XHJcblx0aWYocGFyZW50RGlyZWN0b3J5ICYmIHBhcmVudERpcmVjdG9yeSAhPT0gZGlyZWN0b3J5KSB7XHJcblx0XHR2YXIgcGFyZW50RGlyZWN0b3J5UmVnRXhwID0gcGFyZW50RGlyZWN0b3J5LnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCBcIlxcXFwkJlwiKTtcclxuXHRcdHBhcmVudERpcmVjdG9yeVJlZ0V4cCA9IG5ldyBSZWdFeHAoXCJeXCIgKyBwYXJlbnREaXJlY3RvcnlSZWdFeHAgKyBcInwoISlcIiArIHBhcmVudERpcmVjdG9yeVJlZ0V4cCwgXCJnXCIpO1xyXG5cclxuXHRcdHRoaXMucGFyZW50RGlyZWN0b3J5UmVnRXhwID0gcGFyZW50RGlyZWN0b3J5UmVnRXhwO1xyXG5cdH1cclxuXHJcblx0aWYoX19kaXJuYW1lLmxlbmd0aCA+PSAyKSB7XHJcblx0XHR2YXIgYnVpbGRpbnMgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCBcIi4uXCIpLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpO1xyXG5cdFx0dmFyIGJ1aWxkaW5zQXNNb2R1bGUgPSBjdXJyZW50RGlyZWN0b3J5UmVnRXhwICYmIGN1cnJlbnREaXJlY3RvcnlSZWdFeHAudGVzdChidWlsZGlucyk7XHJcblx0XHR2YXIgYnVpbGRpbnNSZWdFeHAgPSBidWlsZGlucy5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZywgXCJcXFxcJCZcIik7XHJcblx0XHRidWlsZGluc1JlZ0V4cCA9IG5ldyBSZWdFeHAoXCJeXCIgKyBidWlsZGluc1JlZ0V4cCArIFwifCghKVwiICsgYnVpbGRpbnNSZWdFeHAsIFwiZ1wiKTtcclxuXHJcblx0XHR0aGlzLmJ1aWxkaW5zQXNNb2R1bGUgPSBidWlsZGluc0FzTW9kdWxlO1xyXG5cdFx0dGhpcy5idWlsZGluc1JlZ0V4cCA9IGJ1aWxkaW5zUmVnRXhwO1xyXG5cdH1cclxuXHJcblx0dGhpcy5ub2RlTW9kdWxlc1JlZ0V4cCA9IC9cXC9ub2RlX21vZHVsZXNcXC8vZztcclxuXHR0aGlzLmluZGV4SnNSZWdFeHAgPSAvXFwvaW5kZXguanMoIXxcXD98XFwocXVlcnlcXCkpL2c7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBSZXF1ZXN0U2hvcnRlbmVyO1xyXG5cclxuUmVxdWVzdFNob3J0ZW5lci5wcm90b3R5cGUuc2hvcnRlbiA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcclxuXHRpZighcmVxdWVzdClcclxuXHRcdHJldHVybiByZXF1ZXN0O1xyXG5cdHJlcXVlc3QgPSByZXF1ZXN0LnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpO1xyXG5cdGlmKHRoaXMuYnVpbGRpbnNBc01vZHVsZSAmJiB0aGlzLmJ1aWxkaW5zUmVnRXhwKVxyXG5cdFx0cmVxdWVzdCA9IHJlcXVlc3QucmVwbGFjZSh0aGlzLmJ1aWxkaW5zUmVnRXhwLCBcIiEod2VicGFjaylcIik7XHJcblx0aWYodGhpcy5jdXJyZW50RGlyZWN0b3J5UmVnRXhwKVxyXG5cdFx0cmVxdWVzdCA9IHJlcXVlc3QucmVwbGFjZSh0aGlzLmN1cnJlbnREaXJlY3RvcnlSZWdFeHAsIFwiIS5cIik7XHJcblx0aWYodGhpcy5wYXJlbnREaXJlY3RvcnlSZWdFeHApXHJcblx0XHRyZXF1ZXN0ID0gcmVxdWVzdC5yZXBsYWNlKHRoaXMucGFyZW50RGlyZWN0b3J5UmVnRXhwLCBcIiEuLlwiKTtcclxuXHRpZighdGhpcy5idWlsZGluc0FzTW9kdWxlICYmIHRoaXMuYnVpbGRpbnNSZWdFeHApXHJcblx0XHRyZXF1ZXN0ID0gcmVxdWVzdC5yZXBsYWNlKHRoaXMuYnVpbGRpbnNSZWdFeHAsIFwiISh3ZWJwYWNrKVwiKTtcclxuXHRyZXF1ZXN0ID0gcmVxdWVzdC5yZXBsYWNlKHRoaXMubm9kZU1vZHVsZXNSZWdFeHAsIFwiL34vXCIpO1xyXG5cdHJlcXVlc3QgPSByZXF1ZXN0LnJlcGxhY2UodGhpcy5pbmRleEpzUmVnRXhwLCBcIiQxXCIpO1xyXG5cdHJldHVybiByZXF1ZXN0LnJlcGxhY2UoL14hfCEkLywgXCJcIik7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvUmVxdWVzdFNob3J0ZW5lci5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIENvbmNhdFNvdXJjZSA9IHJlcXVpcmUoXCJ3ZWJwYWNrLWNvcmUvbGliL0NvbmNhdFNvdXJjZVwiKTtcclxudmFyIE9yaWdpbmFsU291cmNlID0gcmVxdWlyZShcIndlYnBhY2stY29yZS9saWIvT3JpZ2luYWxTb3VyY2VcIik7XHJcbnZhciBQcmVmaXhTb3VyY2UgPSByZXF1aXJlKFwid2VicGFjay1jb3JlL2xpYi9QcmVmaXhTb3VyY2VcIik7XHJcbnZhciBUZW1wbGF0ZSA9IHJlcXVpcmUoXCIuL1RlbXBsYXRlXCIpO1xyXG5cclxuZnVuY3Rpb24gTWFpblRlbXBsYXRlKG91dHB1dE9wdGlvbnMpIHtcclxuXHRUZW1wbGF0ZS5jYWxsKHRoaXMsIG91dHB1dE9wdGlvbnMpO1xyXG5cdHRoaXMucGx1Z2luKFwic3RhcnR1cFwiLCBmdW5jdGlvbihzb3VyY2UsIGNodW5rLCBoYXNoKSB7XHJcblx0XHR2YXIgYnVmID0gW107XHJcblx0XHRpZihjaHVuay5tb2R1bGVzLnNvbWUoZnVuY3Rpb24obSkge1xyXG5cdFx0XHRcdHJldHVybiBtLmlkID09PSAwO1xyXG5cdFx0XHR9KSkge1xyXG5cdFx0XHRidWYucHVzaChcIlwiKTtcclxuXHRcdFx0YnVmLnB1c2goXCIvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcIik7XHJcblx0XHRcdGJ1Zi5wdXNoKFwicmV0dXJuIFwiICsgdGhpcy5yZW5kZXJSZXF1aXJlRnVuY3Rpb25Gb3JNb2R1bGUoaGFzaCwgY2h1bmssIFwiMFwiKSArIFwiKDApO1wiKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLmFzU3RyaW5nKGJ1Zik7XHJcblx0fSk7XHJcblx0dGhpcy5wbHVnaW4oXCJyZW5kZXJcIiwgZnVuY3Rpb24oYm9vdHN0cmFwU291cmNlLCBjaHVuaywgaGFzaCwgbW9kdWxlVGVtcGxhdGUsIGRlcGVuZGVuY3lUZW1wbGF0ZXMpIHtcclxuXHRcdHZhciBzb3VyY2UgPSBuZXcgQ29uY2F0U291cmNlKCk7XHJcblx0XHRzb3VyY2UuYWRkKFwiLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxcblwiKTtcclxuXHRcdHNvdXJjZS5hZGQobmV3IFByZWZpeFNvdXJjZShcIi8qKioqKiovXCIsIGJvb3RzdHJhcFNvdXJjZSkpO1xyXG5cdFx0c291cmNlLmFkZChcIi8qKioqKiovIH0pXFxuXCIpO1xyXG5cdFx0c291cmNlLmFkZChcIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuXCIpO1xyXG5cdFx0c291cmNlLmFkZChcIi8qKioqKiovIChcIik7XHJcblx0XHR2YXIgbW9kdWxlcyA9IHRoaXMucmVuZGVyQ2h1bmtNb2R1bGVzKGNodW5rLCBtb2R1bGVUZW1wbGF0ZSwgZGVwZW5kZW5jeVRlbXBsYXRlcywgXCIvKioqKioqLyBcIik7XHJcblx0XHRzb3VyY2UuYWRkKHRoaXMuYXBwbHlQbHVnaW5zV2F0ZXJmYWxsKFwibW9kdWxlc1wiLCBtb2R1bGVzLCBjaHVuaywgaGFzaCwgbW9kdWxlVGVtcGxhdGUsIGRlcGVuZGVuY3lUZW1wbGF0ZXMpKTtcclxuXHRcdHNvdXJjZS5hZGQoXCIpXCIpO1xyXG5cdFx0cmV0dXJuIHNvdXJjZTtcclxuXHR9KTtcclxuXHR0aGlzLnBsdWdpbihcImxvY2FsLXZhcnNcIiwgZnVuY3Rpb24oc291cmNlIC8qLCBjaHVuaywgaGFzaCovICkge1xyXG5cdFx0cmV0dXJuIHRoaXMuYXNTdHJpbmcoW1xyXG5cdFx0XHRzb3VyY2UsXHJcblx0XHRcdFwiLy8gVGhlIG1vZHVsZSBjYWNoZVwiLFxyXG5cdFx0XHRcInZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XCJcclxuXHRcdF0pO1xyXG5cdH0pO1xyXG5cdHRoaXMucGx1Z2luKFwicmVxdWlyZVwiLCBmdW5jdGlvbihzb3VyY2UsIGNodW5rLCBoYXNoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5hc1N0cmluZyhbXHJcblx0XHRcdHNvdXJjZSxcclxuXHRcdFx0XCIvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcIixcclxuXHRcdFx0XCJpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcIixcclxuXHRcdFx0dGhpcy5pbmRlbnQoXCJyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcIiksXHJcblx0XHRcdFwiXCIsXHJcblx0XHRcdFwiLy8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcIixcclxuXHRcdFx0XCJ2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XCIsXHJcblx0XHRcdHRoaXMuaW5kZW50KHRoaXMuYXBwbHlQbHVnaW5zV2F0ZXJmYWxsKFwibW9kdWxlLW9ialwiLCBcIlwiLCBjaHVuaywgaGFzaCwgXCJtb2R1bGVJZFwiKSksXHJcblx0XHRcdFwifTtcIixcclxuXHRcdFx0XCJcIixcclxuXHRcdFx0XCIvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cIixcclxuXHRcdFx0XCJtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBcIiArIHRoaXMucmVuZGVyUmVxdWlyZUZ1bmN0aW9uRm9yTW9kdWxlKGhhc2gsIGNodW5rLCBcIm1vZHVsZUlkXCIpICsgXCIpO1wiLFxyXG5cdFx0XHRcIlwiLFxyXG5cdFx0XHRcIi8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcIixcclxuXHRcdFx0XCJtb2R1bGUubG9hZGVkID0gdHJ1ZTtcIixcclxuXHRcdFx0XCJcIixcclxuXHRcdFx0XCIvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVwiLFxyXG5cdFx0XHRcInJldHVybiBtb2R1bGUuZXhwb3J0cztcIlxyXG5cdFx0XSk7XHJcblx0fSk7XHJcblx0dGhpcy5wbHVnaW4oXCJtb2R1bGUtb2JqXCIsIGZ1bmN0aW9uKCAvKnNvdXJjZSwgY2h1bmssIGhhc2gsIHZhck1vZHVsZUlkKi8gKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5hc1N0cmluZyhbXHJcblx0XHRcdFwiZXhwb3J0czoge30sXCIsXHJcblx0XHRcdFwiaWQ6IG1vZHVsZUlkLFwiLFxyXG5cdFx0XHRcImxvYWRlZDogZmFsc2VcIlxyXG5cdFx0XSk7XHJcblx0fSk7XHJcblx0dGhpcy5wbHVnaW4oXCJyZXF1aXJlLWV4dGVuc2lvbnNcIiwgZnVuY3Rpb24oc291cmNlLCBjaHVuaywgaGFzaCkge1xyXG5cdFx0dmFyIGJ1ZiA9IFtdO1xyXG5cdFx0aWYoY2h1bmsuY2h1bmtzLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0YnVmLnB1c2goXCIvLyBUaGlzIGZpbGUgY29udGFpbnMgb25seSB0aGUgZW50cnkgY2h1bmsuXCIpO1xyXG5cdFx0XHRidWYucHVzaChcIi8vIFRoZSBjaHVuayBsb2FkaW5nIGZ1bmN0aW9uIGZvciBhZGRpdGlvbmFsIGNodW5rc1wiKTtcclxuXHRcdFx0YnVmLnB1c2godGhpcy5yZXF1aXJlRm4gKyBcIi5lID0gZnVuY3Rpb24gcmVxdWlyZUVuc3VyZShjaHVua0lkLCBjYWxsYmFjaykge1wiKTtcclxuXHRcdFx0YnVmLnB1c2godGhpcy5pbmRlbnQodGhpcy5hcHBseVBsdWdpbnNXYXRlcmZhbGwoXCJyZXF1aXJlLWVuc3VyZVwiLCBcInRocm93IG5ldyBFcnJvcignTm90IGNodW5rIGxvYWRpbmcgYXZhaWxhYmxlJyk7XCIsIGNodW5rLCBoYXNoLCBcImNodW5rSWRcIikpKTtcclxuXHRcdFx0YnVmLnB1c2goXCJ9O1wiKTtcclxuXHRcdH1cclxuXHRcdGJ1Zi5wdXNoKFwiXCIpO1xyXG5cdFx0YnVmLnB1c2goXCIvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVwiKTtcclxuXHRcdGJ1Zi5wdXNoKHRoaXMucmVxdWlyZUZuICsgXCIubSA9IG1vZHVsZXM7XCIpO1xyXG5cclxuXHRcdGJ1Zi5wdXNoKFwiXCIpO1xyXG5cdFx0YnVmLnB1c2goXCIvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVwiKTtcclxuXHRcdGJ1Zi5wdXNoKHRoaXMucmVxdWlyZUZuICsgXCIuYyA9IGluc3RhbGxlZE1vZHVsZXM7XCIpO1xyXG5cclxuXHRcdHZhciBwdWJsaWNQYXRoID0gdGhpcy5nZXRQdWJsaWNQYXRoKHtcclxuXHRcdFx0aGFzaDogaGFzaFxyXG5cdFx0fSk7XHJcblx0XHRidWYucHVzaChcIlwiKTtcclxuXHRcdGJ1Zi5wdXNoKFwiLy8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cIik7XHJcblx0XHRidWYucHVzaCh0aGlzLnJlcXVpcmVGbiArIFwiLnAgPSBcIiArIEpTT04uc3RyaW5naWZ5KHB1YmxpY1BhdGgpICsgXCI7XCIpO1xyXG5cdFx0cmV0dXJuIHRoaXMuYXNTdHJpbmcoYnVmKTtcclxuXHR9KTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IE1haW5UZW1wbGF0ZTtcclxuXHJcbk1haW5UZW1wbGF0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRlbXBsYXRlLnByb3RvdHlwZSk7XHJcbk1haW5UZW1wbGF0ZS5wcm90b3R5cGUucmVxdWlyZUZuID0gXCJfX3dlYnBhY2tfcmVxdWlyZV9fXCI7XHJcbk1haW5UZW1wbGF0ZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oaGFzaCwgY2h1bmssIG1vZHVsZVRlbXBsYXRlLCBkZXBlbmRlbmN5VGVtcGxhdGVzKSB7XHJcblx0dmFyIGJ1ZiA9IFtdO1xyXG5cdGJ1Zi5wdXNoKHRoaXMuYXBwbHlQbHVnaW5zV2F0ZXJmYWxsKFwiYm9vdHN0cmFwXCIsIFwiXCIsIGNodW5rLCBoYXNoLCBtb2R1bGVUZW1wbGF0ZSwgZGVwZW5kZW5jeVRlbXBsYXRlcykpO1xyXG5cdGJ1Zi5wdXNoKHRoaXMuYXBwbHlQbHVnaW5zV2F0ZXJmYWxsKFwibG9jYWwtdmFyc1wiLCBcIlwiLCBjaHVuaywgaGFzaCkpO1xyXG5cdGJ1Zi5wdXNoKFwiXCIpO1xyXG5cdGJ1Zi5wdXNoKFwiLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cIik7XHJcblx0YnVmLnB1c2goXCJmdW5jdGlvbiBcIiArIHRoaXMucmVxdWlyZUZuICsgXCIobW9kdWxlSWQpIHtcIik7XHJcblx0YnVmLnB1c2godGhpcy5pbmRlbnQodGhpcy5hcHBseVBsdWdpbnNXYXRlcmZhbGwoXCJyZXF1aXJlXCIsIFwiXCIsIGNodW5rLCBoYXNoKSkpO1xyXG5cdGJ1Zi5wdXNoKFwifVwiKTtcclxuXHRidWYucHVzaChcIlwiKTtcclxuXHRidWYucHVzaCh0aGlzLmFzU3RyaW5nKHRoaXMuYXBwbHlQbHVnaW5zV2F0ZXJmYWxsKFwicmVxdWlyZS1leHRlbnNpb25zXCIsIFwiXCIsIGNodW5rLCBoYXNoKSkpO1xyXG5cdGJ1Zi5wdXNoKHRoaXMuYXNTdHJpbmcodGhpcy5hcHBseVBsdWdpbnNXYXRlcmZhbGwoXCJzdGFydHVwXCIsIFwiXCIsIGNodW5rLCBoYXNoKSkpO1xyXG5cdHZhciBzb3VyY2UgPSB0aGlzLmFwcGx5UGx1Z2luc1dhdGVyZmFsbChcInJlbmRlclwiLCBuZXcgT3JpZ2luYWxTb3VyY2UodGhpcy5wcmVmaXgoYnVmLCBcIiBcXHRcIikgKyBcIlxcblwiLCBcIndlYnBhY2svYm9vdHN0cmFwIFwiICsgaGFzaCksIGNodW5rLCBoYXNoLCBtb2R1bGVUZW1wbGF0ZSwgZGVwZW5kZW5jeVRlbXBsYXRlcyk7XHJcblx0aWYoY2h1bmsubW9kdWxlcy5zb21lKGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdFx0XHRyZXR1cm4gbW9kdWxlLmlkID09PSAwO1xyXG5cdFx0fSkpIHtcclxuXHRcdHNvdXJjZSA9IHRoaXMuYXBwbHlQbHVnaW5zV2F0ZXJmYWxsKFwicmVuZGVyLXdpdGgtZW50cnlcIiwgc291cmNlLCBjaHVuaywgaGFzaCk7XHJcblx0fVxyXG5cdGlmKCFzb3VyY2UpIHRocm93IG5ldyBFcnJvcihcIkNvbXBpbGVyIGVycm9yOiBNYWluVGVtcGxhdGUgcGx1Z2luICdyZW5kZXInIHNob3VsZCByZXR1cm4gc29tZXRoaW5nXCIpO1xyXG5cdGNodW5rLnJlbmRlcmVkID0gdHJ1ZTtcclxuXHRyZXR1cm4gbmV3IENvbmNhdFNvdXJjZShzb3VyY2UsIFwiO1wiKTtcclxufTtcclxuXHJcbk1haW5UZW1wbGF0ZS5wcm90b3R5cGUucmVuZGVyUmVxdWlyZUZ1bmN0aW9uRm9yTW9kdWxlID0gZnVuY3Rpb24oaGFzaCwgY2h1bmssIHZhck1vZHVsZUlkKSB7XHJcblx0cmV0dXJuIHRoaXMuYXBwbHlQbHVnaW5zV2F0ZXJmYWxsKFwibW9kdWxlLXJlcXVpcmVcIiwgdGhpcy5yZXF1aXJlRm4sIGNodW5rLCBoYXNoLCB2YXJNb2R1bGVJZCk7XHJcbn07XHJcblxyXG5NYWluVGVtcGxhdGUucHJvdG90eXBlLnJlbmRlckFkZE1vZHVsZSA9IGZ1bmN0aW9uKGhhc2gsIGNodW5rLCB2YXJNb2R1bGVJZCwgdmFyTW9kdWxlKSB7XHJcblx0cmV0dXJuIHRoaXMuYXBwbHlQbHVnaW5zV2F0ZXJmYWxsKFwiYWRkLW1vZHVsZVwiLCBcIm1vZHVsZXNbXCIgKyB2YXJNb2R1bGVJZCArIFwiXSA9IFwiICsgdmFyTW9kdWxlICsgXCI7XCIsIGNodW5rLCBoYXNoLCB2YXJNb2R1bGVJZCwgdmFyTW9kdWxlKTtcclxufTtcclxuXHJcbk1haW5UZW1wbGF0ZS5wcm90b3R5cGUucmVuZGVyQ3VycmVudEhhc2hDb2RlID0gZnVuY3Rpb24oaGFzaCwgbGVuZ3RoKSB7XHJcblx0bGVuZ3RoID0gbGVuZ3RoIHx8IEluZmluaXR5O1xyXG5cdHJldHVybiB0aGlzLmFwcGx5UGx1Z2luc1dhdGVyZmFsbChcImN1cnJlbnQtaGFzaFwiLCBKU09OLnN0cmluZ2lmeShoYXNoLnN1YnN0cigwLCBsZW5ndGgpKSwgbGVuZ3RoKTtcclxufTtcclxuXHJcbk1haW5UZW1wbGF0ZS5wcm90b3R5cGUuZW50cnlQb2ludEluQ2hpbGRyZW4gPSBmdW5jdGlvbihjaHVuaykge1xyXG5cdGZ1bmN0aW9uIGNoZWNrQ2hpbGRyZW4oY2h1bmssIGFscmVhZHlDaGVja2VkQ2h1bmtzKSB7XHJcblx0XHRyZXR1cm4gY2h1bmsuY2h1bmtzLnNvbWUoZnVuY3Rpb24oY2hpbGQpIHtcclxuXHRcdFx0aWYoYWxyZWFkeUNoZWNrZWRDaHVua3MuaW5kZXhPZihjaGlsZCkgPj0gMCkgcmV0dXJuO1xyXG5cdFx0XHRhbHJlYWR5Q2hlY2tlZENodW5rcy5wdXNoKGNoaWxkKTtcclxuXHRcdFx0cmV0dXJuIGNoaWxkLm1vZHVsZXMuc29tZShmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmlkID09PSAwO1xyXG5cdFx0XHR9KSB8fCBjaGVja0NoaWxkcmVuKGNoaWxkLCBhbHJlYWR5Q2hlY2tlZENodW5rcyk7XHJcblx0XHR9KTtcclxuXHR9XHJcblx0cmV0dXJuIGNoZWNrQ2hpbGRyZW4oY2h1bmssIFtdKTtcclxufTtcclxuXHJcbk1haW5UZW1wbGF0ZS5wcm90b3R5cGUuZ2V0UHVibGljUGF0aCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gdGhpcy5hcHBseVBsdWdpbnNXYXRlcmZhbGwoXCJhc3NldC1wYXRoXCIsIHRoaXMub3V0cHV0T3B0aW9ucy5wdWJsaWNQYXRoIHx8IFwiXCIsIG9wdGlvbnMpO1xyXG59O1xyXG5cclxuTWFpblRlbXBsYXRlLnByb3RvdHlwZS51cGRhdGVIYXNoID0gZnVuY3Rpb24oaGFzaCkge1xyXG5cdGhhc2gudXBkYXRlKFwibWFpbnRlbXBsYXRlXCIpO1xyXG5cdGhhc2gudXBkYXRlKFwiM1wiKTtcclxuXHRoYXNoLnVwZGF0ZSh0aGlzLm91dHB1dE9wdGlvbnMucHVibGljUGF0aCArIFwiXCIpO1xyXG5cdHRoaXMuYXBwbHlQbHVnaW5zKFwiaGFzaFwiLCBoYXNoKTtcclxufTtcclxuXHJcbk1haW5UZW1wbGF0ZS5wcm90b3R5cGUudXBkYXRlSGFzaEZvckNodW5rID0gZnVuY3Rpb24oaGFzaCwgY2h1bmspIHtcclxuXHR0aGlzLnVwZGF0ZUhhc2goaGFzaCk7XHJcblx0dGhpcy5hcHBseVBsdWdpbnMoXCJoYXNoLWZvci1jaHVua1wiLCBoYXNoLCBjaHVuayk7XHJcbn07XHJcblxyXG5NYWluVGVtcGxhdGUucHJvdG90eXBlLnVzZUNodW5rSGFzaCA9IGZ1bmN0aW9uKGNodW5rKSB7XHJcblx0dmFyIHBhdGhzID0gdGhpcy5hcHBseVBsdWdpbnNXYXRlcmZhbGwoXCJnbG9iYWwtaGFzaC1wYXRoc1wiLCBbXSk7XHJcblx0cmV0dXJuICF0aGlzLmFwcGx5UGx1Z2luc0JhaWxSZXN1bHQoXCJnbG9iYWwtaGFzaFwiLCBjaHVuaywgcGF0aHMpO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL01haW5UZW1wbGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIFNvdXJjZU5vZGUgPSByZXF1aXJlKFwic291cmNlLW1hcFwiKS5Tb3VyY2VOb2RlO1xyXG52YXIgU291cmNlTGlzdE1hcCA9IHJlcXVpcmUoXCJzb3VyY2UtbGlzdC1tYXBcIikuU291cmNlTGlzdE1hcDtcclxudmFyIFNvdXJjZSA9IHJlcXVpcmUoXCIuL1NvdXJjZVwiKTtcclxuXHJcbmZ1bmN0aW9uIENvbmNhdFNvdXJjZSgpIHtcclxuXHRTb3VyY2UuY2FsbCh0aGlzKTtcclxuXHR0aGlzLmNoaWxkcmVuID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbmNhdFNvdXJjZTtcclxuXHJcbkNvbmNhdFNvdXJjZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZS5wcm90b3R5cGUpO1xyXG5Db25jYXRTb3VyY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uY2F0U291cmNlO1xyXG5cclxuQ29uY2F0U291cmNlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihpdGVtKSB7XHJcblx0dGhpcy5jaGlsZHJlbi5wdXNoKGl0ZW0pO1xyXG59O1xyXG5cclxuQ29uY2F0U291cmNlLnByb3RvdHlwZS5zb3VyY2UgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oaXRlbSkge1xyXG5cdFx0cmV0dXJuIHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiID8gaXRlbSA6IGl0ZW0uc291cmNlKCk7XHJcblx0fSkuam9pbihcIlwiKTtcclxufTtcclxuXHJcbkNvbmNhdFNvdXJjZS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLmNoaWxkcmVuLm1hcChmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRyZXR1cm4gdHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIgPyBpdGVtLmxlbmd0aCA6IGl0ZW0uc2l6ZSgpO1xyXG5cdH0pLnJlZHVjZShmdW5jdGlvbihzdW0sIHMpIHsgcmV0dXJuIHN1bSArIHM7IH0sIDApO1xyXG59O1xyXG5cclxucmVxdWlyZShcIi4vU291cmNlQW5kTWFwTWl4aW5cIikoQ29uY2F0U291cmNlLnByb3RvdHlwZSk7XHJcblxyXG5Db25jYXRTb3VyY2UucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0dmFyIG5vZGUgPSBuZXcgU291cmNlTm9kZShudWxsLCBudWxsLCBudWxsLCB0aGlzLmNoaWxkcmVuLm1hcChmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRyZXR1cm4gdHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIgPyBpdGVtIDogaXRlbS5ub2RlKG9wdGlvbnMpO1xyXG5cdH0pKTtcclxuXHRyZXR1cm4gbm9kZTtcclxufTtcclxuXHJcbkNvbmNhdFNvdXJjZS5wcm90b3R5cGUubGlzdE1hcCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHR2YXIgbWFwID0gbmV3IFNvdXJjZUxpc3RNYXAoKTtcclxuXHR0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xyXG5cdFx0aWYodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpXHJcblx0XHRcdG1hcC5hZGQoaXRlbSk7XHJcblx0XHRlbHNlXHJcblx0XHRcdG1hcC5hZGQoaXRlbS5saXN0TWFwKG9wdGlvbnMpKTtcclxuXHR9KTtcclxuXHRyZXR1cm4gbWFwO1xyXG59O1xyXG5cclxuQ29uY2F0U291cmNlLnByb3RvdHlwZS51cGRhdGVIYXNoID0gZnVuY3Rpb24oaGFzaCkge1xyXG5cdHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpIHtcclxuXHRcdFx0aGFzaC51cGRhdGUoaXRlbSlcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGl0ZW0udXBkYXRlSGFzaChoYXNoKTtcclxuXHRcdH1cclxuXHR9KTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spLWNvcmUvbGliL0NvbmNhdFNvdXJjZS5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIFNvdXJjZU5vZGUgPSByZXF1aXJlKFwic291cmNlLW1hcFwiKS5Tb3VyY2VOb2RlO1xyXG52YXIgU291cmNlTWFwQ29uc3VtZXIgPSByZXF1aXJlKFwic291cmNlLW1hcFwiKS5Tb3VyY2VNYXBDb25zdW1lcjtcclxudmFyIFNvdXJjZUxpc3RNYXAgPSByZXF1aXJlKFwic291cmNlLWxpc3QtbWFwXCIpLlNvdXJjZUxpc3RNYXA7XHJcbnZhciBTb3VyY2UgPSByZXF1aXJlKFwiLi9Tb3VyY2VcIik7XHJcblxyXG5mdW5jdGlvbiBpc1NwbGl0dGVyKGMpIHtcclxuXHRzd2l0Y2goYykge1xyXG5cdGNhc2UgMTA6IC8vIFxcblxyXG5cdGNhc2UgMTM6IC8vIFxcclxyXG5cdGNhc2UgNTk6IC8vIDtcclxuXHRjYXNlIDEyMzogLy8ge1xyXG5cdGNhc2UgMTI1OiAvLyB9XHJcblx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cdHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBfc3BsaXRDb2RlKGNvZGUpIHtcclxuXHR2YXIgcmVzdWx0ID0gW107XHJcblx0dmFyIGkgPSAwLCBqID0gMDtcclxuXHRmb3IoOyBpIDwgY29kZS5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYoaXNTcGxpdHRlcihjb2RlLmNoYXJDb2RlQXQoaSkpKSB7XHJcblx0XHRcdHdoaWxlKGlzU3BsaXR0ZXIoY29kZS5jaGFyQ29kZUF0KCsraSkpKTtcclxuXHRcdFx0cmVzdWx0LnB1c2goY29kZS5zdWJzdHJpbmcoaiwgaSkpO1xyXG5cdFx0XHRqID0gaTtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYoaiA8IGNvZGUubGVuZ3RoKVxyXG5cdFx0cmVzdWx0LnB1c2goY29kZS5zdWJzdHIoaikpO1xyXG5cdHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIE9yaWdpbmFsU291cmNlKHZhbHVlLCBuYW1lKSB7XHJcblx0U291cmNlLmNhbGwodGhpcyk7XHJcblx0dGhpcy5fdmFsdWUgPSB2YWx1ZTtcclxuXHR0aGlzLl9uYW1lID0gbmFtZTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPcmlnaW5hbFNvdXJjZTtcclxuXHJcbk9yaWdpbmFsU291cmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlLnByb3RvdHlwZSk7XHJcbk9yaWdpbmFsU291cmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE9yaWdpbmFsU291cmNlO1xyXG5cclxuT3JpZ2luYWxTb3VyY2UucHJvdG90eXBlLnNvdXJjZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLl92YWx1ZTtcclxufTtcclxuXHJcbnJlcXVpcmUoXCIuL1NvdXJjZUFuZE1hcE1peGluXCIpKE9yaWdpbmFsU291cmNlLnByb3RvdHlwZSk7XHJcblxyXG5PcmlnaW5hbFNvdXJjZS5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHR2YXIgc291cmNlTWFwID0gdGhpcy5fc291cmNlTWFwO1xyXG5cdHZhciB2YWx1ZSA9IHRoaXMuX3ZhbHVlO1xyXG5cdHZhciBuYW1lID0gdGhpcy5fbmFtZTtcclxuXHR2YXIgbGluZXMgPSB2YWx1ZS5zcGxpdChcIlxcblwiKTtcclxuXHR2YXIgbm9kZSA9IG5ldyBTb3VyY2VOb2RlKG51bGwsIG51bGwsIG51bGwsXHJcblx0XHRsaW5lcy5tYXAoZnVuY3Rpb24obGluZSwgaWR4KSB7XHJcblx0XHRcdHZhciBwb3MgPSAwO1xyXG5cdFx0XHRpZihvcHRpb25zLmNvbHVtbnMgPT09IGZhbHNlKSB7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBTb3VyY2VOb2RlKGlkeCsxLCAwLCBuYW1lLFxyXG5cdFx0XHRcdFx0KGxpbmUgKyAoaWR4ICE9IGxpbmVzLmxlbmd0aC0xID8gXCJcXG5cIiA6IFwiXCIpKVxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG5ldyBTb3VyY2VOb2RlKG51bGwsIG51bGwsIG51bGwsXHJcblx0XHRcdFx0X3NwbGl0Q29kZShsaW5lICsgKGlkeCAhPSBsaW5lcy5sZW5ndGgtMSA/IFwiXFxuXCIgOiBcIlwiKSkubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHRcdFx0XHRcdGlmKC9eXFxzKiQvLnRlc3QoaXRlbSkpIHJldHVybiBpdGVtO1xyXG5cdFx0XHRcdFx0dmFyIHJlcyA9IG5ldyBTb3VyY2VOb2RlKGlkeCsxLCBwb3MsIG5hbWUsIGl0ZW0pO1xyXG5cdFx0XHRcdFx0cG9zICs9IGl0ZW0ubGVuZ3RoO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHJlcztcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHQpO1xyXG5cdFx0fSlcclxuXHQpO1xyXG5cdG5vZGUuc2V0U291cmNlQ29udGVudChuYW1lLCB2YWx1ZSk7XHJcblx0cmV0dXJuIG5vZGU7XHJcbn07XHJcblxyXG5PcmlnaW5hbFNvdXJjZS5wcm90b3R5cGUubGlzdE1hcCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IFNvdXJjZUxpc3RNYXAodGhpcy5fdmFsdWUsIHRoaXMuX25hbWUsIHRoaXMuX3ZhbHVlKVxyXG59O1xyXG5cclxuT3JpZ2luYWxTb3VyY2UucHJvdG90eXBlLnVwZGF0ZUhhc2ggPSBmdW5jdGlvbihoYXNoKSB7XHJcblx0aGFzaC51cGRhdGUodGhpcy5fdmFsdWUpO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjayktY29yZS9saWIvT3JpZ2luYWxTb3VyY2UuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBTb3VyY2UgPSByZXF1aXJlKFwiLi9Tb3VyY2VcIik7XHJcbnZhciBTb3VyY2VOb2RlID0gcmVxdWlyZShcInNvdXJjZS1tYXBcIikuU291cmNlTm9kZTtcclxuXHJcbmZ1bmN0aW9uIFByZWZpeFNvdXJjZShwcmVmaXgsIHNvdXJjZSkge1xyXG5cdFNvdXJjZS5jYWxsKHRoaXMpO1xyXG5cdHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcclxuXHR0aGlzLl9wcmVmaXggPSBwcmVmaXg7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBQcmVmaXhTb3VyY2U7XHJcblxyXG5QcmVmaXhTb3VyY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2UucHJvdG90eXBlKTtcclxuUHJlZml4U291cmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFByZWZpeFNvdXJjZTtcclxuXHJcblByZWZpeFNvdXJjZS5wcm90b3R5cGUuc291cmNlID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIG5vZGUgPSB0eXBlb2YgdGhpcy5fc291cmNlID09PSBcInN0cmluZ1wiID8gdGhpcy5fc291cmNlIDogdGhpcy5fc291cmNlLnNvdXJjZSgpO1xyXG5cdHZhciBwcmVmaXggPSB0aGlzLl9wcmVmaXg7XHJcblx0cmV0dXJuIHByZWZpeCArIG5vZGUucmVwbGFjZSgvXFxuKC4pL2csIFwiXFxuXCIgKyBwcmVmaXggKyBcIiQxXCIpO1xyXG59O1xyXG5cclxucmVxdWlyZShcIi4vU291cmNlQW5kTWFwTWl4aW5cIikoUHJlZml4U291cmNlLnByb3RvdHlwZSk7XHJcblxyXG5QcmVmaXhTb3VyY2UucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0dmFyIG5vZGUgPSB0aGlzLl9zb3VyY2Uubm9kZShvcHRpb25zKTtcclxuXHR2YXIgYXBwZW5kID0gW3RoaXMuX3ByZWZpeF07XHJcblx0cmV0dXJuIG5ldyBTb3VyY2VOb2RlKG51bGwsIG51bGwsIG51bGwsIFtcclxuXHRcdGNsb25lQW5kUHJlZml4KG5vZGUsIHRoaXMuX3ByZWZpeCwgYXBwZW5kKVxyXG5cdF0pO1xyXG59O1xyXG5cclxuUHJlZml4U291cmNlLnByb3RvdHlwZS5saXN0TWFwID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdHZhciBwcmVmaXggPSB0aGlzLl9wcmVmaXg7XHJcblx0dmFyIG1hcCA9IHRoaXMuX3NvdXJjZS5saXN0TWFwKG9wdGlvbnMpO1xyXG5cdG1hcC5tYXBHZW5lcmF0ZWRDb2RlKGZ1bmN0aW9uKGNvZGUpIHtcclxuXHRcdHJldHVybiBwcmVmaXggKyBjb2RlLnJlcGxhY2UoL1xcbiguKS9nLCBcIlxcblwiICsgcHJlZml4ICsgXCIkMVwiKTtcclxuXHR9KTtcclxuXHRyZXR1cm4gbWFwO1xyXG59O1xyXG5cclxuUHJlZml4U291cmNlLnByb3RvdHlwZS51cGRhdGVIYXNoID0gZnVuY3Rpb24oaGFzaCkge1xyXG5cdGlmKHR5cGVvZiB0aGlzLl9zb3VyY2UgPT09IFwic3RyaW5nXCIpXHJcblx0XHRoYXNoLnVwZGF0ZSh0aGlzLl9zb3VyY2UpO1xyXG5cdGVsc2VcclxuXHRcdHRoaXMuX3NvdXJjZS51cGRhdGVIYXNoKGhhc2gpO1xyXG5cdGlmKHR5cGVvZiB0aGlzLl9wcmVmaXggPT09IFwic3RyaW5nXCIpXHJcblx0XHRoYXNoLnVwZGF0ZSh0aGlzLl9wcmVmaXgpO1xyXG5cdGVsc2VcclxuXHRcdHRoaXMuX3ByZWZpeC51cGRhdGVIYXNoKGhhc2gpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gY2xvbmVBbmRQcmVmaXgobm9kZSwgcHJlZml4LCBhcHBlbmQpIHtcclxuXHRpZih0eXBlb2Ygbm9kZSA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0dmFyIHJlc3VsdCA9IG5vZGUucmVwbGFjZSgvXFxuKC4pL2csIFwiXFxuXCIgKyBwcmVmaXggKyBcIiQxXCIpO1xyXG5cdFx0aWYoYXBwZW5kLmxlbmd0aCA+IDApIHJlc3VsdCA9IGFwcGVuZC5wb3AoKSArIHJlc3VsdDtcclxuXHRcdGlmKC9cXG4kLy50ZXN0KG5vZGUpKSBhcHBlbmQucHVzaChwcmVmaXgpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dmFyIG5ld05vZGUgPSBuZXcgU291cmNlTm9kZShcclxuXHRcdFx0bm9kZS5saW5lLFxyXG5cdFx0XHRub2RlLmNvbHVtbixcclxuXHRcdFx0bm9kZS5zb3VyY2UsXHJcblx0XHRcdG5vZGUuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uKG5vZGUpIHtcclxuXHRcdFx0XHRyZXR1cm4gY2xvbmVBbmRQcmVmaXgobm9kZSwgcHJlZml4LCBhcHBlbmQpO1xyXG5cdFx0XHR9KSxcclxuXHRcdFx0bm9kZS5uYW1lXHJcblx0XHQpO1xyXG5cdFx0bmV3Tm9kZS5zb3VyY2VDb250ZW50cyA9IG5vZGUuc291cmNlQ29udGVudHM7XHJcblx0XHRyZXR1cm4gbmV3Tm9kZTtcclxuXHR9XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS1jb3JlL2xpYi9QcmVmaXhTb3VyY2UuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBUYXBhYmxlID0gcmVxdWlyZShcInRhcGFibGVcIik7XHJcbnZhciBDb25jYXRTb3VyY2UgPSByZXF1aXJlKFwid2VicGFjay1jb3JlL2xpYi9Db25jYXRTb3VyY2VcIik7XHJcblxyXG5mdW5jdGlvbiBUZW1wbGF0ZShvdXRwdXRPcHRpb25zKSB7XHJcblx0VGFwYWJsZS5jYWxsKHRoaXMpO1xyXG5cdHRoaXMub3V0cHV0T3B0aW9ucyA9IG91dHB1dE9wdGlvbnMgfHwge307XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBUZW1wbGF0ZTtcclxuXHJcblRlbXBsYXRlLmdldEZ1bmN0aW9uQ29udGVudCA9IGZ1bmN0aW9uKGZuKSB7XHJcblx0cmV0dXJuIGZuLnRvU3RyaW5nKCkucmVwbGFjZSgvXmZ1bmN0aW9uXFxzP1xcKFxcKVxccz9cXHtcXG4/fFxcbj9cXH0kL2csIFwiXCIpLnJlcGxhY2UoL15cXHQvbWcsIFwiXCIpO1xyXG59O1xyXG5cclxuVGVtcGxhdGUudG9JZGVudGlmaWVyID0gZnVuY3Rpb24oc3RyKSB7XHJcblx0aWYodHlwZW9mIHN0ciAhPT0gXCJzdHJpbmdcIikgcmV0dXJuIFwiXCI7XHJcblx0cmV0dXJuIHN0ci5yZXBsYWNlKC9eW15hLXpBLVokX10vLCBcIl9cIikucmVwbGFjZSgvW15hLXpBLVowLTkkX10vZywgXCJfXCIpO1xyXG59O1xyXG5cclxuVGVtcGxhdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUYXBhYmxlLnByb3RvdHlwZSk7XHJcblRlbXBsYXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRlbXBsYXRlO1xyXG5cclxuVGVtcGxhdGUucHJvdG90eXBlLmluZGVudCA9IGZ1bmN0aW9uIGluZGVudChzdHIpIHtcclxuXHRpZihBcnJheS5pc0FycmF5KHN0cikpIHtcclxuXHRcdHJldHVybiBzdHIubWFwKGluZGVudCkuam9pbihcIlxcblwiKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0c3RyID0gc3RyLnRyaW1SaWdodCgpO1xyXG5cdFx0aWYoIXN0cikgcmV0dXJuIFwiXCI7XHJcblx0XHR2YXIgaW5kID0gKHN0clswXSA9PT0gXCJcXG5cIiA/IFwiXCIgOiBcIlxcdFwiKTtcclxuXHRcdHJldHVybiBpbmQgKyBzdHIucmVwbGFjZSgvXFxuKFteXFxuXSkvZywgXCJcXG5cXHQkMVwiKTtcclxuXHR9XHJcbn07XHJcblxyXG5UZW1wbGF0ZS5wcm90b3R5cGUucHJlZml4ID0gZnVuY3Rpb24oc3RyLCBwcmVmaXgpIHtcclxuXHRpZihBcnJheS5pc0FycmF5KHN0cikpIHtcclxuXHRcdHN0ciA9IHN0ci5qb2luKFwiXFxuXCIpO1xyXG5cdH1cclxuXHRzdHIgPSBzdHIudHJpbSgpO1xyXG5cdGlmKCFzdHIpIHJldHVybiBcIlwiO1xyXG5cdHZhciBpbmQgPSAoc3RyWzBdID09PSBcIlxcblwiID8gXCJcIiA6IHByZWZpeCk7XHJcblx0cmV0dXJuIGluZCArIHN0ci5yZXBsYWNlKC9cXG4oW15cXG5dKS9nLCBcIlxcblwiICsgcHJlZml4ICsgXCIkMVwiKTtcclxufTtcclxuXHJcblRlbXBsYXRlLnByb3RvdHlwZS5hc1N0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xyXG5cdGlmKEFycmF5LmlzQXJyYXkoc3RyKSkge1xyXG5cdFx0cmV0dXJuIHN0ci5qb2luKFwiXFxuXCIpO1xyXG5cdH1cclxuXHRyZXR1cm4gc3RyO1xyXG59O1xyXG5cclxuVGVtcGxhdGUucHJvdG90eXBlLmdldE1vZHVsZXNBcnJheUJvdW5kcyA9IGZ1bmN0aW9uKG1vZHVsZXMpIHtcclxuXHRpZihtb2R1bGVzLnNvbWUoZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0XHRcdHJldHVybiB0eXBlb2YgbW9kdWxlLmlkICE9PSBcIm51bWJlclwiO1xyXG5cdFx0fSkpXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0dmFyIG1heElkID0gLUluZmluaXR5O1xyXG5cdHZhciBtaW5JZCA9IEluZmluaXR5O1xyXG5cdG1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRcdGlmKG1heElkIDwgbW9kdWxlLmlkKSBtYXhJZCA9IG1vZHVsZS5pZDtcclxuXHRcdGlmKG1pbklkID4gbW9kdWxlLmlkKSBtaW5JZCA9IG1vZHVsZS5pZDtcclxuXHR9KTtcclxuXHRpZihtaW5JZCA8IDE2ICsgKFwiXCIgKyBtaW5JZCkubGVuZ3RoKSB7XHJcblx0XHQvLyBhZGQgbWluSWQgeCAnLCcgaW5zdGVhZCBvZiAnQXJyYXkobWluSWQpLmNvbmNhdCguLi4pJ1xyXG5cdFx0bWluSWQgPSAwO1xyXG5cdH1cclxuXHR2YXIgb2JqZWN0T3ZlcmhlYWQgPSBtb2R1bGVzLm1hcChmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRcdHZhciBpZExlbmd0aCA9IChtb2R1bGUuaWQgKyBcIlwiKS5sZW5ndGg7XHJcblx0XHRyZXR1cm4gaWRMZW5ndGggKyAyO1xyXG5cdH0pLnJlZHVjZShmdW5jdGlvbihhLCBiKSB7XHJcblx0XHRyZXR1cm4gYSArIGI7XHJcblx0fSwgLTEpO1xyXG5cdHZhciBhcnJheU92ZXJoZWFkID0gbWluSWQgPT09IDAgPyBtYXhJZCA6IDE2ICsgKFwiXCIgKyBtaW5JZCkubGVuZ3RoICsgbWF4SWQ7XHJcblx0cmV0dXJuIGFycmF5T3ZlcmhlYWQgPCBvYmplY3RPdmVyaGVhZCA/IFttaW5JZCwgbWF4SWRdIDogZmFsc2U7XHJcbn07XHJcblxyXG5UZW1wbGF0ZS5wcm90b3R5cGUucmVuZGVyQ2h1bmtNb2R1bGVzID0gZnVuY3Rpb24oY2h1bmssIG1vZHVsZVRlbXBsYXRlLCBkZXBlbmRlbmN5VGVtcGxhdGVzLCBwcmVmaXgpIHtcclxuXHRpZighcHJlZml4KSBwcmVmaXggPSBcIlwiO1xyXG5cdHZhciBzb3VyY2UgPSBuZXcgQ29uY2F0U291cmNlKCk7XHJcblx0aWYoY2h1bmsubW9kdWxlcy5sZW5ndGggPT09IDApIHtcclxuXHRcdHNvdXJjZS5hZGQoXCJbXVwiKTtcclxuXHRcdHJldHVybiBzb3VyY2U7XHJcblx0fVxyXG5cdHZhciBib3VuZHMgPSB0aGlzLmdldE1vZHVsZXNBcnJheUJvdW5kcyhjaHVuay5tb2R1bGVzKTtcclxuXHRpZihib3VuZHMpIHtcclxuXHRcdC8vIFJlbmRlciBhIHNwYXJlIGFycmF5XHJcblx0XHR2YXIgbWluSWQgPSBib3VuZHNbMF07XHJcblx0XHR2YXIgbWF4SWQgPSBib3VuZHNbMV07XHJcblx0XHRpZihtaW5JZCAhPT0gMCkgc291cmNlLmFkZChcIkFycmF5KFwiICsgbWluSWQgKyBcIikuY29uY2F0KFwiKTtcclxuXHRcdHNvdXJjZS5hZGQoXCJbXFxuXCIpO1xyXG5cdFx0dmFyIG1vZHVsZXMgPSB7fTtcclxuXHRcdGNodW5rLm1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRcdFx0bW9kdWxlc1ttb2R1bGUuaWRdID0gbW9kdWxlO1xyXG5cdFx0fSk7XHJcblx0XHRmb3IodmFyIGlkeCA9IG1pbklkOyBpZHggPD0gbWF4SWQ7IGlkeCsrKSB7XHJcblx0XHRcdHZhciBtb2R1bGUgPSBtb2R1bGVzW2lkeF07XHJcblx0XHRcdGlmKGlkeCAhPT0gbWluSWQpIHNvdXJjZS5hZGQoXCIsXFxuXCIpO1xyXG5cdFx0XHRzb3VyY2UuYWRkKFwiLyogXCIgKyBpZHggKyBcIiAqL1wiKTtcclxuXHRcdFx0aWYobW9kdWxlKSB7XHJcblx0XHRcdFx0c291cmNlLmFkZChcIlxcblwiKTtcclxuXHRcdFx0XHRzb3VyY2UuYWRkKG1vZHVsZVRlbXBsYXRlLnJlbmRlcihtb2R1bGUsIGRlcGVuZGVuY3lUZW1wbGF0ZXMsIGNodW5rKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHNvdXJjZS5hZGQoXCJcXG5cIiArIHByZWZpeCArIFwiXVwiKTtcclxuXHRcdGlmKG1pbklkICE9PSAwKSBzb3VyY2UuYWRkKFwiKVwiKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Ly8gUmVuZGVyIGFuIG9iamVjdFxyXG5cdFx0c291cmNlLmFkZChcIntcXG5cIik7XHJcblx0XHRjaHVuay5tb2R1bGVzLmZvckVhY2goZnVuY3Rpb24obW9kdWxlLCBpZHgpIHtcclxuXHRcdFx0aWYoaWR4ICE9PSAwKSBzb3VyY2UuYWRkKFwiLFxcblwiKTtcclxuXHRcdFx0c291cmNlLmFkZChcIlxcbi8qKiovIFwiICsgSlNPTi5zdHJpbmdpZnkobW9kdWxlLmlkKSArIFwiOlxcblwiKTtcclxuXHRcdFx0c291cmNlLmFkZChtb2R1bGVUZW1wbGF0ZS5yZW5kZXIobW9kdWxlLCBkZXBlbmRlbmN5VGVtcGxhdGVzLCBjaHVuaykpO1xyXG5cdFx0fSk7XHJcblx0XHRzb3VyY2UuYWRkKFwiXFxuXFxuXCIgKyBwcmVmaXggKyBcIn1cIik7XHJcblx0fVxyXG5cdHJldHVybiBzb3VyY2U7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvVGVtcGxhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBDb25jYXRTb3VyY2UgPSByZXF1aXJlKFwid2VicGFjay1jb3JlL2xpYi9Db25jYXRTb3VyY2VcIik7XHJcbnZhciBUZW1wbGF0ZSA9IHJlcXVpcmUoXCIuL1RlbXBsYXRlXCIpO1xyXG5cclxuZnVuY3Rpb24gQ2h1bmtUZW1wbGF0ZShvdXRwdXRPcHRpb25zKSB7XHJcblx0VGVtcGxhdGUuY2FsbCh0aGlzLCBvdXRwdXRPcHRpb25zKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBDaHVua1RlbXBsYXRlO1xyXG5cclxuQ2h1bmtUZW1wbGF0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRlbXBsYXRlLnByb3RvdHlwZSk7XHJcbkNodW5rVGVtcGxhdGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKGNodW5rLCBtb2R1bGVUZW1wbGF0ZSwgZGVwZW5kZW5jeVRlbXBsYXRlcykge1xyXG5cdHZhciBtb2R1bGVzID0gdGhpcy5yZW5kZXJDaHVua01vZHVsZXMoY2h1bmssIG1vZHVsZVRlbXBsYXRlLCBkZXBlbmRlbmN5VGVtcGxhdGVzKTtcclxuXHR2YXIgY29yZSA9IHRoaXMuYXBwbHlQbHVnaW5zV2F0ZXJmYWxsKFwibW9kdWxlc1wiLCBtb2R1bGVzLCBjaHVuaywgbW9kdWxlVGVtcGxhdGUsIGRlcGVuZGVuY3lUZW1wbGF0ZXMpO1xyXG5cdHZhciBzb3VyY2UgPSB0aGlzLmFwcGx5UGx1Z2luc1dhdGVyZmFsbChcInJlbmRlclwiLCBjb3JlLCBjaHVuaywgbW9kdWxlVGVtcGxhdGUsIGRlcGVuZGVuY3lUZW1wbGF0ZXMpO1xyXG5cdGlmKGNodW5rLm1vZHVsZXMuc29tZShmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRcdFx0cmV0dXJuIG1vZHVsZS5pZCA9PT0gMDtcclxuXHRcdH0pKSB7XHJcblx0XHRzb3VyY2UgPSB0aGlzLmFwcGx5UGx1Z2luc1dhdGVyZmFsbChcInJlbmRlci13aXRoLWVudHJ5XCIsIHNvdXJjZSwgY2h1bmspO1xyXG5cdH1cclxuXHRjaHVuay5yZW5kZXJlZCA9IHRydWU7XHJcblx0cmV0dXJuIG5ldyBDb25jYXRTb3VyY2Uoc291cmNlLCBcIjtcIik7XHJcbn07XHJcblxyXG5DaHVua1RlbXBsYXRlLnByb3RvdHlwZS51cGRhdGVIYXNoID0gZnVuY3Rpb24oaGFzaCkge1xyXG5cdGhhc2gudXBkYXRlKFwiQ2h1bmtUZW1wbGF0ZVwiKTtcclxuXHRoYXNoLnVwZGF0ZShcIjJcIik7XHJcblx0dGhpcy5hcHBseVBsdWdpbnMoXCJoYXNoXCIsIGhhc2gpO1xyXG59O1xyXG5cclxuQ2h1bmtUZW1wbGF0ZS5wcm90b3R5cGUudXBkYXRlSGFzaEZvckNodW5rID0gZnVuY3Rpb24oaGFzaCwgY2h1bmspIHtcclxuXHR0aGlzLnVwZGF0ZUhhc2goaGFzaCk7XHJcblx0dGhpcy5hcHBseVBsdWdpbnMoXCJoYXNoLWZvci1jaHVua1wiLCBoYXNoLCBjaHVuayk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvQ2h1bmtUZW1wbGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIFRlbXBsYXRlID0gcmVxdWlyZShcIi4vVGVtcGxhdGVcIik7XHJcblxyXG5mdW5jdGlvbiBIb3RVcGRhdGVDaHVua1RlbXBsYXRlKG91dHB1dE9wdGlvbnMpIHtcclxuXHRUZW1wbGF0ZS5jYWxsKHRoaXMsIG91dHB1dE9wdGlvbnMpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEhvdFVwZGF0ZUNodW5rVGVtcGxhdGU7XHJcblxyXG5Ib3RVcGRhdGVDaHVua1RlbXBsYXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVGVtcGxhdGUucHJvdG90eXBlKTtcclxuSG90VXBkYXRlQ2h1bmtUZW1wbGF0ZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oaWQsIG1vZHVsZXMsIGhhc2gsIG1vZHVsZVRlbXBsYXRlLCBkZXBlbmRlbmN5VGVtcGxhdGVzKSB7XHJcblx0dmFyIG1vZHVsZXNTb3VyY2UgPSB0aGlzLnJlbmRlckNodW5rTW9kdWxlcyh7XHJcblx0XHRpZDogaWQsXHJcblx0XHRtb2R1bGVzOiBtb2R1bGVzXHJcblx0fSwgbW9kdWxlVGVtcGxhdGUsIGRlcGVuZGVuY3lUZW1wbGF0ZXMpO1xyXG5cdHZhciBjb3JlID0gdGhpcy5hcHBseVBsdWdpbnNXYXRlcmZhbGwoXCJtb2R1bGVzXCIsIG1vZHVsZXNTb3VyY2UsIG1vZHVsZXMsIG1vZHVsZVRlbXBsYXRlLCBkZXBlbmRlbmN5VGVtcGxhdGVzKTtcclxuXHR2YXIgc291cmNlID0gdGhpcy5hcHBseVBsdWdpbnNXYXRlcmZhbGwoXCJyZW5kZXJcIiwgY29yZSwgbW9kdWxlcywgaGFzaCwgaWQsIG1vZHVsZVRlbXBsYXRlLCBkZXBlbmRlbmN5VGVtcGxhdGVzKTtcclxuXHRyZXR1cm4gc291cmNlO1xyXG59O1xyXG5cclxuSG90VXBkYXRlQ2h1bmtUZW1wbGF0ZS5wcm90b3R5cGUudXBkYXRlSGFzaCA9IGZ1bmN0aW9uKGhhc2gpIHtcclxuXHRoYXNoLnVwZGF0ZShcIkhvdFVwZGF0ZUNodW5rVGVtcGxhdGVcIik7XHJcblx0aGFzaC51cGRhdGUoXCIxXCIpO1xyXG5cdHRoaXMuYXBwbHlQbHVnaW5zKFwiaGFzaFwiLCBoYXNoKTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9Ib3RVcGRhdGVDaHVua1RlbXBsYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgVGVtcGxhdGUgPSByZXF1aXJlKFwiLi9UZW1wbGF0ZVwiKTtcclxuXHJcbmZ1bmN0aW9uIE1vZHVsZVRlbXBsYXRlKG91dHB1dE9wdGlvbnMpIHtcclxuXHRUZW1wbGF0ZS5jYWxsKHRoaXMsIG91dHB1dE9wdGlvbnMpO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gTW9kdWxlVGVtcGxhdGU7XHJcblxyXG5Nb2R1bGVUZW1wbGF0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRlbXBsYXRlLnByb3RvdHlwZSk7XHJcbk1vZHVsZVRlbXBsYXRlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihtb2R1bGUsIGRlcGVuZGVuY3lUZW1wbGF0ZXMsIGNodW5rKSB7XHJcblx0dmFyIG1vZHVsZVNvdXJjZSA9IG1vZHVsZS5zb3VyY2UoZGVwZW5kZW5jeVRlbXBsYXRlcywgdGhpcy5vdXRwdXRPcHRpb25zLCB0aGlzLnJlcXVlc3RTaG9ydGVuZXIpO1xyXG5cdG1vZHVsZVNvdXJjZSA9IHRoaXMuYXBwbHlQbHVnaW5zV2F0ZXJmYWxsKFwibW9kdWxlXCIsIG1vZHVsZVNvdXJjZSwgbW9kdWxlLCBjaHVuaywgZGVwZW5kZW5jeVRlbXBsYXRlcyk7XHJcblx0bW9kdWxlU291cmNlID0gdGhpcy5hcHBseVBsdWdpbnNXYXRlcmZhbGwoXCJyZW5kZXJcIiwgbW9kdWxlU291cmNlLCBtb2R1bGUsIGNodW5rLCBkZXBlbmRlbmN5VGVtcGxhdGVzKTtcclxuXHRyZXR1cm4gdGhpcy5hcHBseVBsdWdpbnNXYXRlcmZhbGwoXCJwYWNrYWdlXCIsIG1vZHVsZVNvdXJjZSwgbW9kdWxlLCBjaHVuaywgZGVwZW5kZW5jeVRlbXBsYXRlcyk7XHJcbn07XHJcblxyXG5Nb2R1bGVUZW1wbGF0ZS5wcm90b3R5cGUudXBkYXRlSGFzaCA9IGZ1bmN0aW9uKGhhc2gpIHtcclxuXHRoYXNoLnVwZGF0ZShcIjFcIik7XHJcblx0dGhpcy5hcHBseVBsdWdpbnMoXCJoYXNoXCIsIGhhc2gpO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL01vZHVsZVRlbXBsYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5mdW5jdGlvbiBEZXBlbmRlbmN5KCkge1xyXG5cdHRoaXMubW9kdWxlID0gbnVsbDtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IERlcGVuZGVuY3k7XHJcblxyXG5EZXBlbmRlbmN5LnByb3RvdHlwZS5pc0VxdWFsUmVzb3VyY2UgPSBmdW5jdGlvbiggLyogb3RoZXIgKi8gKSB7XHJcblx0cmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuRGVwZW5kZW5jeS5wcm90b3R5cGUudXBkYXRlSGFzaCA9IGZ1bmN0aW9uKGhhc2gpIHtcclxuXHRoYXNoLnVwZGF0ZSgodGhpcy5tb2R1bGUgJiYgdGhpcy5tb2R1bGUuaWQpICsgXCJcIik7XHJcbn07XHJcblxyXG5EZXBlbmRlbmN5LnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5tb2R1bGUgPSBudWxsO1xyXG59O1xyXG5cclxuRGVwZW5kZW5jeS5jb21wYXJlID0gZnVuY3Rpb24oYSwgYikge1xyXG5cdHJldHVybiBEZXBlbmRlbmN5LmNvbXBhcmVMb2NhdGlvbnMoYS5sb2MsIGIubG9jKTtcclxufTtcclxuXHJcbkRlcGVuZGVuY3kuY29tcGFyZUxvY2F0aW9ucyA9IGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRpZih0eXBlb2YgYSA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0aWYodHlwZW9mIGIgPT09IFwic3RyaW5nXCIpIHtcclxuXHRcdFx0aWYoYSA8IGIpIHJldHVybiAtMTtcclxuXHRcdFx0aWYoYSA+IGIpIHJldHVybiAxO1xyXG5cdFx0XHRyZXR1cm4gMDtcclxuXHRcdH0gZWxzZSBpZih0eXBlb2YgYiA9PT0gXCJvYmplY3RcIikge1xyXG5cdFx0XHRyZXR1cm4gMTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiAwO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZih0eXBlb2YgYSA9PT0gXCJvYmplY3RcIikge1xyXG5cdFx0aWYodHlwZW9mIGIgPT09IFwic3RyaW5nXCIpIHtcclxuXHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0fSBlbHNlIGlmKHR5cGVvZiBiID09PSBcIm9iamVjdFwiKSB7XHJcblx0XHRcdGlmKGEuc3RhcnQpIGEgPSBhLnN0YXJ0O1xyXG5cdFx0XHRpZihiLnN0YXJ0KSBiID0gYi5zdGFydDtcclxuXHRcdFx0aWYoYS5saW5lIDwgYi5saW5lKSByZXR1cm4gLTE7XHJcblx0XHRcdGlmKGEubGluZSA+IGIubGluZSkgcmV0dXJuIDE7XHJcblx0XHRcdGlmKGEuY29sdW1uIDwgYi5jb2x1bW4pIHJldHVybiAtMTtcclxuXHRcdFx0aWYoYS5jb2x1bW4gPiBiLmNvbHVtbikgcmV0dXJuIDE7XHJcblx0XHRcdGlmKGEuaW5kZXggPCBiLmluZGV4KSByZXR1cm4gLTE7XHJcblx0XHRcdGlmKGEuaW5kZXggPiBiLmluZGV4KSByZXR1cm4gMTtcclxuXHRcdFx0cmV0dXJuIDA7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gMDtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvRGVwZW5kZW5jeS5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuZnVuY3Rpb24gQ2h1bmtSZW5kZXJFcnJvcihjaHVuaywgZmlsZSwgZXJyb3IpIHtcclxuXHRFcnJvci5jYWxsKHRoaXMpO1xyXG5cdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIENodW5rUmVuZGVyRXJyb3IpO1xyXG5cdHRoaXMubmFtZSA9IFwiQ2h1bmtSZW5kZXJFcnJvclwiO1xyXG5cdHRoaXMuZXJyb3IgPSBlcnJvcjtcclxuXHR0aGlzLm1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xyXG5cdHRoaXMuZGV0YWlscyA9IGVycm9yLnN0YWNrO1xyXG5cdHRoaXMuZmlsZSA9IGZpbGU7XHJcblx0dGhpcy5jaHVuayA9IGNodW5rO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gQ2h1bmtSZW5kZXJFcnJvcjtcclxuXHJcbkNodW5rUmVuZGVyRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL0NodW5rUmVuZGVyRXJyb3IuanNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbmZ1bmN0aW9uIENhY2hlZFNvdXJjZShzb3VyY2UpIHtcclxuXHR0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XHJcblx0dGhpcy5fY2FjaGVkU291cmNlID0gdW5kZWZpbmVkO1xyXG5cdHRoaXMuX2NhY2hlZFNpemUgPSB1bmRlZmluZWQ7XHJcblx0dGhpcy5fY2FjaGVkTWFwcyA9IHt9O1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gQ2FjaGVkU291cmNlO1xyXG5cclxuQ2FjaGVkU291cmNlLnByb3RvdHlwZS5zb3VyY2UgPSBmdW5jdGlvbigpIHtcclxuXHRpZih0eXBlb2YgdGhpcy5fY2FjaGVkU291cmNlICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gdGhpcy5fY2FjaGVkU291cmNlO1xyXG5cdHJldHVybiB0aGlzLl9jYWNoZWRTb3VyY2UgPSB0aGlzLl9zb3VyY2Uuc291cmNlKCk7XHJcbn07XHJcblxyXG5DYWNoZWRTb3VyY2UucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcclxuXHRpZih0eXBlb2YgdGhpcy5fY2FjaGVkU2l6ZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIHRoaXMuX2NhY2hlZFNpemU7XHJcblx0aWYodHlwZW9mIHRoaXMuX2NhY2hlZFNvdXJjZSAhPT0gXCJ1bmRlZmluZWRcIilcclxuXHRcdHJldHVybiB0aGlzLl9jYWNoZWRTaXplID0gdGhpcy5fY2FjaGVkU291cmNlLmxlbmd0aDtcclxuXHRyZXR1cm4gdGhpcy5fY2FjaGVkU2l6ZSA9IHRoaXMuX3NvdXJjZS5zaXplKCk7XHJcbn07XHJcblxyXG5DYWNoZWRTb3VyY2UucHJvdG90eXBlLnNvdXJjZUFuZE1hcCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHR2YXIga2V5ID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucyk7XHJcblx0aWYodHlwZW9mIHRoaXMuX2NhY2hlZFNvdXJjZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBrZXkgaW4gdGhpcy5fY2FjaGVkTWFwcylcclxuXHRcdHJldHVybiB7IHNvdXJjZTogdGhpcy5fY2FjaGVkU291cmNlLCBtYXA6IHRoaXMuX2NhY2hlZE1hcHNba2V5XSB9O1xyXG5cdGVsc2UgaWYodHlwZW9mIHRoaXMuX2NhY2hlZFNvdXJjZSAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0cmV0dXJuIHsgc291cmNlOiB0aGlzLl9jYWNoZWRTb3VyY2UsIG1hcDogdGhpcy5fY2FjaGVkTWFwc1trZXldID0gdGhpcy5fc291cmNlLm1hcChvcHRpb25zKSB9O1xyXG5cdH0gZWxzZSBpZihrZXkgaW4gdGhpcy5fY2FjaGVkTWFwcykge1xyXG5cdFx0cmV0dXJuIHsgc291cmNlOiB0aGlzLl9jYWNoZWRTb3VyY2UgPSB0aGlzLl9zb3VyY2Uuc291cmNlKCksIG1hcDogdGhpcy5fY2FjaGVkTWFwc1trZXldIH07XHJcblx0fVxyXG5cdHZhciByZXN1bHQgPSB0aGlzLl9zb3VyY2Uuc291cmNlQW5kTWFwKG9wdGlvbnMpO1xyXG5cdHRoaXMuX2NhY2hlZFNvdXJjZSA9IHJlc3VsdC5zb3VyY2U7XHJcblx0dGhpcy5fY2FjaGVkTWFwc1trZXldID0gcmVzdWx0Lm1hcDtcclxuXHRyZXR1cm4geyBzb3VyY2U6IHRoaXMuX2NhY2hlZFNvdXJjZSwgbWFwOiB0aGlzLl9jYWNoZWRNYXBzW2tleV0gfTtcclxufTtcclxuXHJcbkNhY2hlZFNvdXJjZS5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gdGhpcy5fc291cmNlLm5vZGUob3B0aW9ucyk7XHJcbn07XHJcblxyXG5DYWNoZWRTb3VyY2UucHJvdG90eXBlLmxpc3RNYXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0cmV0dXJuIHRoaXMuX3NvdXJjZS5saXN0TWFwKG9wdGlvbnMpO1xyXG59XHJcblxyXG5DYWNoZWRTb3VyY2UucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHRpZighb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xyXG5cdHZhciBrZXkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zKTtcclxuXHRpZihrZXkgaW4gdGhpcy5fY2FjaGVkTWFwcylcclxuXHRcdHJldHVybiB0aGlzLl9jYWNoZWRNYXBzW2tleV07XHJcblx0cmV0dXJuIHRoaXMuX2NhY2hlZE1hcHNba2V5XSA9IHRoaXMuX3NvdXJjZS5tYXAoKTtcclxufTtcclxuXHJcbkNhY2hlZFNvdXJjZS5wcm90b3R5cGUudXBkYXRlSGFzaCA9IGZ1bmN0aW9uKGhhc2gpIHtcclxuXHR0aGlzLl9zb3VyY2UudXBkYXRlSGFzaChoYXNoKTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spLWNvcmUvbGliL0NhY2hlZFNvdXJjZS5qc1xuLy8gbW9kdWxlIGlkID0gNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygzKSkoMTM3KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBkZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvaW5kZXguanMgZnJvbSBkbGwtcmVmZXJlbmNlIHZlbmRvcl9hZTk3YmExY2IyNDEyYzFhODY0NFxuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIGFjb3JuID0gcmVxdWlyZShcImFjb3JuXCIpO1xyXG52YXIgVGFwYWJsZSA9IHJlcXVpcmUoXCJ0YXBhYmxlXCIpO1xyXG52YXIgQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uID0gcmVxdWlyZShcIi4vQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uXCIpO1xyXG5cclxuZnVuY3Rpb24gUGFyc2VyKG9wdGlvbnMpIHtcclxuXHRUYXBhYmxlLmNhbGwodGhpcyk7XHJcblx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuXHR0aGlzLmluaXRpYWxpemVFdmFsdWF0aW5nKCk7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXI7XHJcblxyXG4vLyBTeW50YXg6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL1NwaWRlck1vbmtleS9QYXJzZXJfQVBJXHJcblxyXG5QYXJzZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUYXBhYmxlLnByb3RvdHlwZSk7XHJcblBhcnNlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYXJzZXI7XHJcblxyXG5QYXJzZXIucHJvdG90eXBlLmluaXRpYWxpemVFdmFsdWF0aW5nID0gZnVuY3Rpb24oKSB7XHJcblx0ZnVuY3Rpb24gam9pblJhbmdlcyhzdGFydFJhbmdlLCBlbmRSYW5nZSkge1xyXG5cdFx0aWYoIWVuZFJhbmdlKSByZXR1cm4gc3RhcnRSYW5nZTtcclxuXHRcdGlmKCFzdGFydFJhbmdlKSByZXR1cm4gZW5kUmFuZ2U7XHJcblx0XHRyZXR1cm4gW3N0YXJ0UmFuZ2VbMF0sIGVuZFJhbmdlWzFdXTtcclxuXHR9XHJcblx0dGhpcy5wbHVnaW4oXCJldmFsdWF0ZSBMaXRlcmFsXCIsIGZ1bmN0aW9uKGV4cHIpIHtcclxuXHRcdHN3aXRjaCh0eXBlb2YgZXhwci52YWx1ZSkge1xyXG5cdFx0XHRjYXNlIFwibnVtYmVyXCI6XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBCYXNpY0V2YWx1YXRlZEV4cHJlc3Npb24oKS5zZXROdW1iZXIoZXhwci52YWx1ZSkuc2V0UmFuZ2UoZXhwci5yYW5nZSk7XHJcblx0XHRcdGNhc2UgXCJzdHJpbmdcIjpcclxuXHRcdFx0XHRyZXR1cm4gbmV3IEJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbigpLnNldFN0cmluZyhleHByLnZhbHVlKS5zZXRSYW5nZShleHByLnJhbmdlKTtcclxuXHRcdFx0Y2FzZSBcImJvb2xlYW5cIjpcclxuXHRcdFx0XHRyZXR1cm4gbmV3IEJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbigpLnNldEJvb2xlYW4oZXhwci52YWx1ZSkuc2V0UmFuZ2UoZXhwci5yYW5nZSk7XHJcblx0XHR9XHJcblx0XHRpZihleHByLnZhbHVlID09PSBudWxsKVxyXG5cdFx0XHRyZXR1cm4gbmV3IEJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbigpLnNldE51bGwoKS5zZXRSYW5nZShleHByLnJhbmdlKTtcclxuXHRcdGlmKGV4cHIudmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApXHJcblx0XHRcdHJldHVybiBuZXcgQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uKCkuc2V0UmVnRXhwKGV4cHIudmFsdWUpLnNldFJhbmdlKGV4cHIucmFuZ2UpO1xyXG5cdH0pO1xyXG5cdHRoaXMucGx1Z2luKFwiZXZhbHVhdGUgTG9naWNhbEV4cHJlc3Npb25cIiwgZnVuY3Rpb24oZXhwcikge1xyXG5cdFx0dmFyIGxlZnQ7XHJcblx0XHR2YXIgbGVmdEFzQm9vbDtcclxuXHRcdHZhciByaWdodDtcclxuXHRcdGlmKGV4cHIub3BlcmF0b3IgPT09IFwiJiZcIikge1xyXG5cdFx0XHRsZWZ0ID0gdGhpcy5ldmFsdWF0ZUV4cHJlc3Npb24oZXhwci5sZWZ0KTtcclxuXHRcdFx0bGVmdEFzQm9vbCA9IGxlZnQgJiYgbGVmdC5hc0Jvb2woKTtcclxuXHRcdFx0aWYobGVmdEFzQm9vbCA9PT0gZmFsc2UpIHJldHVybiBsZWZ0LnNldFJhbmdlKGV4cHIucmFuZ2UpO1xyXG5cdFx0XHRpZihsZWZ0QXNCb29sICE9PSB0cnVlKSByZXR1cm47XHJcblx0XHRcdHJpZ2h0ID0gdGhpcy5ldmFsdWF0ZUV4cHJlc3Npb24oZXhwci5yaWdodCk7XHJcblx0XHRcdHJldHVybiByaWdodC5zZXRSYW5nZShleHByLnJhbmdlKTtcclxuXHRcdH0gZWxzZSBpZihleHByLm9wZXJhdG9yID09PSBcInx8XCIpIHtcclxuXHRcdFx0bGVmdCA9IHRoaXMuZXZhbHVhdGVFeHByZXNzaW9uKGV4cHIubGVmdCk7XHJcblx0XHRcdGxlZnRBc0Jvb2wgPSBsZWZ0ICYmIGxlZnQuYXNCb29sKCk7XHJcblx0XHRcdGlmKGxlZnRBc0Jvb2wgPT09IHRydWUpIHJldHVybiBsZWZ0LnNldFJhbmdlKGV4cHIucmFuZ2UpO1xyXG5cdFx0XHRpZihsZWZ0QXNCb29sICE9PSBmYWxzZSkgcmV0dXJuO1xyXG5cdFx0XHRyaWdodCA9IHRoaXMuZXZhbHVhdGVFeHByZXNzaW9uKGV4cHIucmlnaHQpO1xyXG5cdFx0XHRyZXR1cm4gcmlnaHQuc2V0UmFuZ2UoZXhwci5yYW5nZSk7XHJcblx0XHR9XHJcblx0fSk7XHJcblx0dGhpcy5wbHVnaW4oXCJldmFsdWF0ZSBCaW5hcnlFeHByZXNzaW9uXCIsIGZ1bmN0aW9uKGV4cHIpIHtcclxuXHRcdHZhciBsZWZ0O1xyXG5cdFx0dmFyIHJpZ2h0O1xyXG5cdFx0dmFyIHJlcztcclxuXHRcdGlmKGV4cHIub3BlcmF0b3IgPT09IFwiK1wiKSB7XHJcblx0XHRcdGxlZnQgPSB0aGlzLmV2YWx1YXRlRXhwcmVzc2lvbihleHByLmxlZnQpO1xyXG5cdFx0XHRyaWdodCA9IHRoaXMuZXZhbHVhdGVFeHByZXNzaW9uKGV4cHIucmlnaHQpO1xyXG5cdFx0XHRpZighbGVmdCB8fCAhcmlnaHQpIHJldHVybjtcclxuXHRcdFx0cmVzID0gbmV3IEJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbigpO1xyXG5cdFx0XHRpZihsZWZ0LmlzU3RyaW5nKCkpIHtcclxuXHRcdFx0XHRpZihyaWdodC5pc1N0cmluZygpKSB7XHJcblx0XHRcdFx0XHRyZXMuc2V0U3RyaW5nKGxlZnQuc3RyaW5nICsgcmlnaHQuc3RyaW5nKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYocmlnaHQuaXNOdW1iZXIoKSkge1xyXG5cdFx0XHRcdFx0cmVzLnNldFN0cmluZyhsZWZ0LnN0cmluZyArIHJpZ2h0Lm51bWJlcik7XHJcblx0XHRcdFx0fSBlbHNlIGlmKHJpZ2h0LmlzV3JhcHBlZCgpICYmIHJpZ2h0LnByZWZpeCAmJiByaWdodC5wcmVmaXguaXNTdHJpbmcoKSkge1xyXG5cdFx0XHRcdFx0cmVzLnNldFdyYXBwZWQoXHJcblx0XHRcdFx0XHRcdG5ldyBCYXNpY0V2YWx1YXRlZEV4cHJlc3Npb24oKVxyXG5cdFx0XHRcdFx0XHQuc2V0U3RyaW5nKGxlZnQuc3RyaW5nICsgcmlnaHQucHJlZml4LnN0cmluZylcclxuXHRcdFx0XHRcdFx0LnNldFJhbmdlKGpvaW5SYW5nZXMobGVmdC5yYW5nZSwgcmlnaHQucHJlZml4LnJhbmdlKSksXHJcblx0XHRcdFx0XHRcdHJpZ2h0LnBvc3RmaXgpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRyZXMuc2V0V3JhcHBlZChsZWZ0LCBudWxsKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZihsZWZ0LmlzTnVtYmVyKCkpIHtcclxuXHRcdFx0XHRpZihyaWdodC5pc1N0cmluZygpKSB7XHJcblx0XHRcdFx0XHRyZXMuc2V0U3RyaW5nKGxlZnQubnVtYmVyICsgcmlnaHQuc3RyaW5nKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYocmlnaHQuaXNOdW1iZXIoKSkge1xyXG5cdFx0XHRcdFx0cmVzLnNldE51bWJlcihsZWZ0Lm51bWJlciArIHJpZ2h0Lm51bWJlcik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYobGVmdC5pc1dyYXBwZWQoKSkge1xyXG5cdFx0XHRcdGlmKGxlZnQucG9zdGZpeCAmJiBsZWZ0LnBvc3RmaXguaXNTdHJpbmcoKSAmJiByaWdodC5pc1N0cmluZygpKSB7XHJcblx0XHRcdFx0XHRyZXMuc2V0V3JhcHBlZChsZWZ0LnByZWZpeCxcclxuXHRcdFx0XHRcdFx0bmV3IEJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbigpXHJcblx0XHRcdFx0XHRcdC5zZXRTdHJpbmcobGVmdC5wb3N0Zml4LnN0cmluZyArIHJpZ2h0LnN0cmluZylcclxuXHRcdFx0XHRcdFx0LnNldFJhbmdlKGpvaW5SYW5nZXMobGVmdC5wb3N0Zml4LnJhbmdlLCByaWdodC5yYW5nZSkpXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZihsZWZ0LnBvc3RmaXggJiYgbGVmdC5wb3N0Zml4LmlzU3RyaW5nKCkgJiYgcmlnaHQuaXNOdW1iZXIoKSkge1xyXG5cdFx0XHRcdFx0cmVzLnNldFdyYXBwZWQobGVmdC5wcmVmaXgsXHJcblx0XHRcdFx0XHRcdG5ldyBCYXNpY0V2YWx1YXRlZEV4cHJlc3Npb24oKVxyXG5cdFx0XHRcdFx0XHQuc2V0U3RyaW5nKGxlZnQucG9zdGZpeC5zdHJpbmcgKyByaWdodC5udW1iZXIpXHJcblx0XHRcdFx0XHRcdC5zZXRSYW5nZShqb2luUmFuZ2VzKGxlZnQucG9zdGZpeC5yYW5nZSwgcmlnaHQucmFuZ2UpKVxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHR9IGVsc2UgaWYocmlnaHQuaXNTdHJpbmcoKSkge1xyXG5cdFx0XHRcdFx0cmVzLnNldFdyYXBwZWQobGVmdC5wcmVmaXgsIHJpZ2h0KTtcclxuXHRcdFx0XHR9IGVsc2UgaWYocmlnaHQuaXNOdW1iZXIoKSkge1xyXG5cdFx0XHRcdFx0cmVzLnNldFdyYXBwZWQobGVmdC5wcmVmaXgsXHJcblx0XHRcdFx0XHRcdG5ldyBCYXNpY0V2YWx1YXRlZEV4cHJlc3Npb24oKVxyXG5cdFx0XHRcdFx0XHQuc2V0U3RyaW5nKHJpZ2h0Lm51bWJlciArIFwiXCIpXHJcblx0XHRcdFx0XHRcdC5zZXRSYW5nZShyaWdodC5yYW5nZSkpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRyZXMuc2V0V3JhcHBlZChsZWZ0LnByZWZpeCwgbmV3IEJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbigpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYocmlnaHQuaXNTdHJpbmcoKSkge1xyXG5cdFx0XHRcdFx0cmVzLnNldFdyYXBwZWQobnVsbCwgcmlnaHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXMuc2V0UmFuZ2UoZXhwci5yYW5nZSk7XHJcblx0XHRcdHJldHVybiByZXM7XHJcblx0XHR9IGVsc2UgaWYoZXhwci5vcGVyYXRvciA9PT0gXCItXCIpIHtcclxuXHRcdFx0bGVmdCA9IHRoaXMuZXZhbHVhdGVFeHByZXNzaW9uKGV4cHIubGVmdCk7XHJcblx0XHRcdHJpZ2h0ID0gdGhpcy5ldmFsdWF0ZUV4cHJlc3Npb24oZXhwci5yaWdodCk7XHJcblx0XHRcdGlmKCFsZWZ0IHx8ICFyaWdodCkgcmV0dXJuO1xyXG5cdFx0XHRpZighbGVmdC5pc051bWJlcigpIHx8ICFyaWdodC5pc051bWJlcigpKSByZXR1cm47XHJcblx0XHRcdHJlcyA9IG5ldyBCYXNpY0V2YWx1YXRlZEV4cHJlc3Npb24oKTtcclxuXHRcdFx0cmVzLnNldE51bWJlcihsZWZ0Lm51bWJlciAtIHJpZ2h0Lm51bWJlcik7XHJcblx0XHRcdHJlcy5zZXRSYW5nZShleHByLnJhbmdlKTtcclxuXHRcdFx0cmV0dXJuIHJlcztcclxuXHRcdH0gZWxzZSBpZihleHByLm9wZXJhdG9yID09PSBcIipcIikge1xyXG5cdFx0XHRsZWZ0ID0gdGhpcy5ldmFsdWF0ZUV4cHJlc3Npb24oZXhwci5sZWZ0KTtcclxuXHRcdFx0cmlnaHQgPSB0aGlzLmV2YWx1YXRlRXhwcmVzc2lvbihleHByLnJpZ2h0KTtcclxuXHRcdFx0aWYoIWxlZnQgfHwgIXJpZ2h0KSByZXR1cm47XHJcblx0XHRcdGlmKCFsZWZ0LmlzTnVtYmVyKCkgfHwgIXJpZ2h0LmlzTnVtYmVyKCkpIHJldHVybjtcclxuXHRcdFx0cmVzID0gbmV3IEJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbigpO1xyXG5cdFx0XHRyZXMuc2V0TnVtYmVyKGxlZnQubnVtYmVyICogcmlnaHQubnVtYmVyKTtcclxuXHRcdFx0cmVzLnNldFJhbmdlKGV4cHIucmFuZ2UpO1xyXG5cdFx0XHRyZXR1cm4gcmVzO1xyXG5cdFx0fSBlbHNlIGlmKGV4cHIub3BlcmF0b3IgPT09IFwiL1wiKSB7XHJcblx0XHRcdGxlZnQgPSB0aGlzLmV2YWx1YXRlRXhwcmVzc2lvbihleHByLmxlZnQpO1xyXG5cdFx0XHRyaWdodCA9IHRoaXMuZXZhbHVhdGVFeHByZXNzaW9uKGV4cHIucmlnaHQpO1xyXG5cdFx0XHRpZighbGVmdCB8fCAhcmlnaHQpIHJldHVybjtcclxuXHRcdFx0aWYoIWxlZnQuaXNOdW1iZXIoKSB8fCAhcmlnaHQuaXNOdW1iZXIoKSkgcmV0dXJuO1xyXG5cdFx0XHRyZXMgPSBuZXcgQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uKCk7XHJcblx0XHRcdHJlcy5zZXROdW1iZXIobGVmdC5udW1iZXIgLyByaWdodC5udW1iZXIpO1xyXG5cdFx0XHRyZXMuc2V0UmFuZ2UoZXhwci5yYW5nZSk7XHJcblx0XHRcdHJldHVybiByZXM7XHJcblx0XHR9IGVsc2UgaWYoZXhwci5vcGVyYXRvciA9PT0gXCI9PVwiIHx8IGV4cHIub3BlcmF0b3IgPT09IFwiPT09XCIpIHtcclxuXHRcdFx0bGVmdCA9IHRoaXMuZXZhbHVhdGVFeHByZXNzaW9uKGV4cHIubGVmdCk7XHJcblx0XHRcdHJpZ2h0ID0gdGhpcy5ldmFsdWF0ZUV4cHJlc3Npb24oZXhwci5yaWdodCk7XHJcblx0XHRcdGlmKCFsZWZ0IHx8ICFyaWdodCkgcmV0dXJuO1xyXG5cdFx0XHRyZXMgPSBuZXcgQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uKCk7XHJcblx0XHRcdHJlcy5zZXRSYW5nZShleHByLnJhbmdlKTtcclxuXHRcdFx0aWYobGVmdC5pc1N0cmluZygpICYmIHJpZ2h0LmlzU3RyaW5nKCkpIHtcclxuXHRcdFx0XHRyZXR1cm4gcmVzLnNldEJvb2xlYW4obGVmdC5zdHJpbmcgPT09IHJpZ2h0LnN0cmluZyk7XHJcblx0XHRcdH0gZWxzZSBpZihsZWZ0LmlzTnVtYmVyKCkgJiYgcmlnaHQuaXNOdW1iZXIoKSkge1xyXG5cdFx0XHRcdHJldHVybiByZXMuc2V0Qm9vbGVhbihsZWZ0Lm51bWJlciA9PT0gcmlnaHQubnVtYmVyKTtcclxuXHRcdFx0fSBlbHNlIGlmKGxlZnQuaXNCb29sZWFuKCkgJiYgcmlnaHQuaXNCb29sZWFuKCkpIHtcclxuXHRcdFx0XHRyZXR1cm4gcmVzLnNldEJvb2xlYW4obGVmdC5ib29sID09PSByaWdodC5ib29sKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmKGV4cHIub3BlcmF0b3IgPT09IFwiIT1cIiB8fCBleHByLm9wZXJhdG9yID09PSBcIiE9PVwiKSB7XHJcblx0XHRcdGxlZnQgPSB0aGlzLmV2YWx1YXRlRXhwcmVzc2lvbihleHByLmxlZnQpO1xyXG5cdFx0XHRyaWdodCA9IHRoaXMuZXZhbHVhdGVFeHByZXNzaW9uKGV4cHIucmlnaHQpO1xyXG5cdFx0XHRpZighbGVmdCB8fCAhcmlnaHQpIHJldHVybjtcclxuXHRcdFx0cmVzID0gbmV3IEJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbigpO1xyXG5cdFx0XHRyZXMuc2V0UmFuZ2UoZXhwci5yYW5nZSk7XHJcblx0XHRcdGlmKGxlZnQuaXNTdHJpbmcoKSAmJiByaWdodC5pc1N0cmluZygpKSB7XHJcblx0XHRcdFx0cmV0dXJuIHJlcy5zZXRCb29sZWFuKGxlZnQuc3RyaW5nICE9PSByaWdodC5zdHJpbmcpO1xyXG5cdFx0XHR9IGVsc2UgaWYobGVmdC5pc051bWJlcigpICYmIHJpZ2h0LmlzTnVtYmVyKCkpIHtcclxuXHRcdFx0XHRyZXR1cm4gcmVzLnNldEJvb2xlYW4obGVmdC5udW1iZXIgIT09IHJpZ2h0Lm51bWJlcik7XHJcblx0XHRcdH0gZWxzZSBpZihsZWZ0LmlzQm9vbGVhbigpICYmIHJpZ2h0LmlzQm9vbGVhbigpKSB7XHJcblx0XHRcdFx0cmV0dXJuIHJlcy5zZXRCb29sZWFuKGxlZnQuYm9vbCAhPT0gcmlnaHQuYm9vbCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9KTtcclxuXHR0aGlzLnBsdWdpbihcImV2YWx1YXRlIFVuYXJ5RXhwcmVzc2lvblwiLCBmdW5jdGlvbihleHByKSB7XHJcblx0XHRpZihleHByLm9wZXJhdG9yID09PSBcInR5cGVvZlwiKSB7XHJcblx0XHRcdHZhciByZXM7XHJcblx0XHRcdGlmKGV4cHIuYXJndW1lbnQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcclxuXHRcdFx0XHR2YXIgbmFtZSA9IHRoaXMuc2NvcGUucmVuYW1lc1tcIiRcIiArIGV4cHIuYXJndW1lbnQubmFtZV0gfHwgZXhwci5hcmd1bWVudC5uYW1lO1xyXG5cdFx0XHRcdGlmKHRoaXMuc2NvcGUuZGVmaW5pdGlvbnMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcclxuXHRcdFx0XHRcdHJlcyA9IHRoaXMuYXBwbHlQbHVnaW5zQmFpbFJlc3VsdChcImV2YWx1YXRlIHR5cGVvZiBcIiArIG5hbWUsIGV4cHIpO1xyXG5cdFx0XHRcdFx0aWYocmVzICE9PSB1bmRlZmluZWQpIHJldHVybiByZXM7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmKGV4cHIuYXJndW1lbnQudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHtcclxuXHRcdFx0XHR2YXIgZXhwcmVzc2lvbiA9IGV4cHIuYXJndW1lbnQ7XHJcblx0XHRcdFx0dmFyIGV4cHJOYW1lID0gW107XHJcblx0XHRcdFx0d2hpbGUoZXhwcmVzc2lvbi50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiAmJiAhZXhwcmVzc2lvbi5jb21wdXRlZCkge1xyXG5cdFx0XHRcdFx0ZXhwck5hbWUudW5zaGlmdCh0aGlzLnNjb3BlLnJlbmFtZXNbXCIkXCIgKyBleHByZXNzaW9uLnByb3BlcnR5Lm5hbWVdIHx8IGV4cHJlc3Npb24ucHJvcGVydHkubmFtZSk7XHJcblx0XHRcdFx0XHRleHByZXNzaW9uID0gZXhwcmVzc2lvbi5vYmplY3Q7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKGV4cHJlc3Npb24udHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcclxuXHRcdFx0XHRcdGV4cHJOYW1lLnVuc2hpZnQodGhpcy5zY29wZS5yZW5hbWVzW1wiJFwiICsgZXhwcmVzc2lvbi5uYW1lXSB8fCBleHByZXNzaW9uLm5hbWUpO1xyXG5cdFx0XHRcdFx0aWYodGhpcy5zY29wZS5kZWZpbml0aW9ucy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xyXG5cdFx0XHRcdFx0XHRleHByTmFtZSA9IGV4cHJOYW1lLmpvaW4oXCIuXCIpO1xyXG5cdFx0XHRcdFx0XHRyZXMgPSB0aGlzLmFwcGx5UGx1Z2luc0JhaWxSZXN1bHQoXCJldmFsdWF0ZSB0eXBlb2YgXCIgKyBleHByTmFtZSwgZXhwcik7XHJcblx0XHRcdFx0XHRcdGlmKHJlcyAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcmVzO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZihleHByLmFyZ3VtZW50LnR5cGUgPT09IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpIHtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IEJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbigpLnNldFN0cmluZyhcImZ1bmN0aW9uXCIpLnNldFJhbmdlKGV4cHIucmFuZ2UpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBhcmcgPSB0aGlzLmV2YWx1YXRlRXhwcmVzc2lvbihleHByLmFyZ3VtZW50KTtcclxuXHRcdFx0aWYoYXJnLmlzU3RyaW5nKCkgfHwgYXJnLmlzV3JhcHBlZCgpKSByZXR1cm4gbmV3IEJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbigpLnNldFN0cmluZyhcInN0cmluZ1wiKS5zZXRSYW5nZShleHByLnJhbmdlKTtcclxuXHRcdFx0ZWxzZSBpZihhcmcuaXNOdW1iZXIoKSkgcmV0dXJuIG5ldyBCYXNpY0V2YWx1YXRlZEV4cHJlc3Npb24oKS5zZXRTdHJpbmcoXCJudW1iZXJcIikuc2V0UmFuZ2UoZXhwci5yYW5nZSk7XHJcblx0XHRcdGVsc2UgaWYoYXJnLmlzQm9vbGVhbigpKSByZXR1cm4gbmV3IEJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbigpLnNldFN0cmluZyhcImJvb2xlYW5cIikuc2V0UmFuZ2UoZXhwci5yYW5nZSk7XHJcblx0XHRcdGVsc2UgaWYoYXJnLmlzQXJyYXkoKSB8fCBhcmcuaXNDb25zdEFycmF5KCkgfHwgYXJnLmlzUmVnRXhwKCkpIHJldHVybiBuZXcgQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uKCkuc2V0U3RyaW5nKFwib2JqZWN0XCIpLnNldFJhbmdlKGV4cHIucmFuZ2UpO1xyXG5cdFx0fSBlbHNlIGlmKGV4cHIub3BlcmF0b3IgPT09IFwiIVwiKSB7XHJcblx0XHRcdHZhciBhcmd1bWVudCA9IHRoaXMuZXZhbHVhdGVFeHByZXNzaW9uKGV4cHIuYXJndW1lbnQpO1xyXG5cdFx0XHRpZighYXJndW1lbnQpIHJldHVybjtcclxuXHRcdFx0aWYoYXJndW1lbnQuaXNCb29sZWFuKCkpIHtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IEJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbigpLnNldEJvb2xlYW4oIWFyZ3VtZW50LmJvb2wpLnNldFJhbmdlKGV4cHIucmFuZ2UpO1xyXG5cdFx0XHR9IGVsc2UgaWYoYXJndW1lbnQuaXNTdHJpbmcoKSkge1xyXG5cdFx0XHRcdHJldHVybiBuZXcgQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uKCkuc2V0Qm9vbGVhbighYXJndW1lbnQuc3RyaW5nKS5zZXRSYW5nZShleHByLnJhbmdlKTtcclxuXHRcdFx0fSBlbHNlIGlmKGFyZ3VtZW50LmlzTnVtYmVyKCkpIHtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IEJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbigpLnNldEJvb2xlYW4oIWFyZ3VtZW50Lm51bWJlcikuc2V0UmFuZ2UoZXhwci5yYW5nZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9KTtcclxuXHR0aGlzLnBsdWdpbihcImV2YWx1YXRlIHR5cGVvZiB1bmRlZmluZWRcIiwgZnVuY3Rpb24oZXhwcikge1xyXG5cdFx0cmV0dXJuIG5ldyBCYXNpY0V2YWx1YXRlZEV4cHJlc3Npb24oKS5zZXRTdHJpbmcoXCJ1bmRlZmluZWRcIikuc2V0UmFuZ2UoZXhwci5yYW5nZSk7XHJcblx0fSk7XHJcblx0dGhpcy5wbHVnaW4oXCJldmFsdWF0ZSBJZGVudGlmaWVyXCIsIGZ1bmN0aW9uKGV4cHIpIHtcclxuXHRcdHZhciBuYW1lID0gdGhpcy5zY29wZS5yZW5hbWVzW1wiJFwiICsgZXhwci5uYW1lXSB8fCBleHByLm5hbWU7XHJcblx0XHRpZih0aGlzLnNjb3BlLmRlZmluaXRpb25zLmluZGV4T2YoZXhwci5uYW1lKSA9PT0gLTEpIHtcclxuXHRcdFx0dmFyIHJlc3VsdCA9IHRoaXMuYXBwbHlQbHVnaW5zQmFpbFJlc3VsdChcImV2YWx1YXRlIElkZW50aWZpZXIgXCIgKyBuYW1lLCBleHByKTtcclxuXHRcdFx0aWYocmVzdWx0KSByZXR1cm4gcmVzdWx0O1xyXG5cdFx0XHRyZXR1cm4gbmV3IEJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbigpLnNldElkZW50aWZpZXIobmFtZSkuc2V0UmFuZ2UoZXhwci5yYW5nZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hcHBseVBsdWdpbnNCYWlsUmVzdWx0KFwiZXZhbHVhdGUgZGVmaW5lZCBJZGVudGlmaWVyIFwiICsgbmFtZSwgZXhwcik7XHJcblx0XHR9XHJcblx0fSk7XHJcblx0dGhpcy5wbHVnaW4oXCJldmFsdWF0ZSBNZW1iZXJFeHByZXNzaW9uXCIsIGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcclxuXHRcdHZhciBleHByID0gZXhwcmVzc2lvbjtcclxuXHRcdHZhciBleHByTmFtZSA9IFtdO1xyXG5cdFx0d2hpbGUoZXhwci50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiAmJiAhZXhwci5jb21wdXRlZCkge1xyXG5cdFx0XHRleHByTmFtZS51bnNoaWZ0KGV4cHIucHJvcGVydHkubmFtZSk7XHJcblx0XHRcdGV4cHIgPSBleHByLm9iamVjdDtcclxuXHRcdH1cclxuXHRcdGlmKGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcclxuXHRcdFx0dmFyIG5hbWUgPSB0aGlzLnNjb3BlLnJlbmFtZXNbXCIkXCIgKyBleHByLm5hbWVdIHx8IGV4cHIubmFtZTtcclxuXHRcdFx0aWYodGhpcy5zY29wZS5kZWZpbml0aW9ucy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xyXG5cdFx0XHRcdGV4cHJOYW1lLnVuc2hpZnQobmFtZSk7XHJcblx0XHRcdFx0ZXhwck5hbWUgPSBleHByTmFtZS5qb2luKFwiLlwiKTtcclxuXHRcdFx0XHRpZih0aGlzLnNjb3BlLmRlZmluaXRpb25zLmluZGV4T2YoZXhwci5uYW1lKSA9PT0gLTEpIHtcclxuXHRcdFx0XHRcdHZhciByZXN1bHQgPSB0aGlzLmFwcGx5UGx1Z2luc0JhaWxSZXN1bHQoXCJldmFsdWF0ZSBJZGVudGlmaWVyIFwiICsgZXhwck5hbWUsIGV4cHJlc3Npb24pO1xyXG5cdFx0XHRcdFx0aWYocmVzdWx0KSByZXR1cm4gcmVzdWx0O1xyXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBCYXNpY0V2YWx1YXRlZEV4cHJlc3Npb24oKS5zZXRJZGVudGlmaWVyKGV4cHJOYW1lKS5zZXRSYW5nZShleHByZXNzaW9uLnJhbmdlKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYXBwbHlQbHVnaW5zQmFpbFJlc3VsdChcImV2YWx1YXRlIGRlZmluZWQgSWRlbnRpZmllciBcIiArIGV4cHJOYW1lLCBleHByZXNzaW9uKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9KTtcclxuXHR0aGlzLnBsdWdpbihcImV2YWx1YXRlIENhbGxFeHByZXNzaW9uXCIsIGZ1bmN0aW9uKGV4cHIpIHtcclxuXHRcdGlmKGV4cHIuY2FsbGVlLnR5cGUgIT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSByZXR1cm47XHJcblx0XHRpZihleHByLmNhbGxlZS5jb21wdXRlZCkgcmV0dXJuO1xyXG5cdFx0dmFyIHBhcmFtID0gdGhpcy5ldmFsdWF0ZUV4cHJlc3Npb24oZXhwci5jYWxsZWUub2JqZWN0KTtcclxuXHRcdGlmKCFwYXJhbSkgcmV0dXJuO1xyXG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlQbHVnaW5zQmFpbFJlc3VsdChcImV2YWx1YXRlIENhbGxFeHByZXNzaW9uIC5cIiArIGV4cHIuY2FsbGVlLnByb3BlcnR5Lm5hbWUsIGV4cHIsIHBhcmFtKTtcclxuXHR9KTtcclxuXHR0aGlzLnBsdWdpbihcImV2YWx1YXRlIENhbGxFeHByZXNzaW9uIC5yZXBsYWNlXCIsIGZ1bmN0aW9uKGV4cHIsIHBhcmFtKSB7XHJcblx0XHRpZighcGFyYW0uaXNTdHJpbmcoKSkgcmV0dXJuO1xyXG5cdFx0aWYoZXhwci5hcmd1bWVudHMubGVuZ3RoICE9PSAyKSByZXR1cm47XHJcblx0XHR2YXIgYXJnMSA9IHRoaXMuZXZhbHVhdGVFeHByZXNzaW9uKGV4cHIuYXJndW1lbnRzWzBdKTtcclxuXHRcdHZhciBhcmcyID0gdGhpcy5ldmFsdWF0ZUV4cHJlc3Npb24oZXhwci5hcmd1bWVudHNbMV0pO1xyXG5cdFx0aWYoIWFyZzEuaXNTdHJpbmcoKSAmJiAhYXJnMS5pc1JlZ0V4cCgpKSByZXR1cm47XHJcblx0XHRhcmcxID0gYXJnMS5yZWdFeHAgfHwgYXJnMS5zdHJpbmc7XHJcblx0XHRpZighYXJnMi5pc1N0cmluZygpKSByZXR1cm47XHJcblx0XHRhcmcyID0gYXJnMi5zdHJpbmc7XHJcblx0XHRyZXR1cm4gbmV3IEJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbigpLnNldFN0cmluZyhwYXJhbS5zdHJpbmcucmVwbGFjZShhcmcxLCBhcmcyKSkuc2V0UmFuZ2UoZXhwci5yYW5nZSk7XHJcblx0fSk7XHJcblx0W1wic3Vic3RyXCIsIFwic3Vic3RyaW5nXCJdLmZvckVhY2goZnVuY3Rpb24oZm4pIHtcclxuXHRcdHRoaXMucGx1Z2luKFwiZXZhbHVhdGUgQ2FsbEV4cHJlc3Npb24gLlwiICsgZm4sIGZ1bmN0aW9uKGV4cHIsIHBhcmFtKSB7XHJcblx0XHRcdGlmKCFwYXJhbS5pc1N0cmluZygpKSByZXR1cm47XHJcblx0XHRcdHZhciBhcmcxO1xyXG5cdFx0XHR2YXIgcmVzdWx0LCBzdHIgPSBwYXJhbS5zdHJpbmc7XHJcblx0XHRcdHN3aXRjaChleHByLmFyZ3VtZW50cy5sZW5ndGgpIHtcclxuXHRcdFx0XHRjYXNlIDE6XHJcblx0XHRcdFx0XHRhcmcxID0gdGhpcy5ldmFsdWF0ZUV4cHJlc3Npb24oZXhwci5hcmd1bWVudHNbMF0pO1xyXG5cdFx0XHRcdFx0aWYoIWFyZzEuaXNOdW1iZXIoKSkgcmV0dXJuO1xyXG5cdFx0XHRcdFx0cmVzdWx0ID0gc3RyW2ZuXShhcmcxLm51bWJlcik7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIDI6XHJcblx0XHRcdFx0XHRhcmcxID0gdGhpcy5ldmFsdWF0ZUV4cHJlc3Npb24oZXhwci5hcmd1bWVudHNbMF0pO1xyXG5cdFx0XHRcdFx0dmFyIGFyZzIgPSB0aGlzLmV2YWx1YXRlRXhwcmVzc2lvbihleHByLmFyZ3VtZW50c1sxXSk7XHJcblx0XHRcdFx0XHRpZighYXJnMS5pc051bWJlcigpKSByZXR1cm47XHJcblx0XHRcdFx0XHRpZighYXJnMi5pc051bWJlcigpKSByZXR1cm47XHJcblx0XHRcdFx0XHRyZXN1bHQgPSBzdHJbZm5dKGFyZzEubnVtYmVyLCBhcmcyLm51bWJlcik7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBuZXcgQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uKCkuc2V0U3RyaW5nKHJlc3VsdCkuc2V0UmFuZ2UoZXhwci5yYW5nZSk7XHJcblx0XHR9KTtcclxuXHR9LCB0aGlzKTtcclxuXHR0aGlzLnBsdWdpbihcImV2YWx1YXRlIENhbGxFeHByZXNzaW9uIC5zcGxpdFwiLCBmdW5jdGlvbihleHByLCBwYXJhbSkge1xyXG5cdFx0aWYoIXBhcmFtLmlzU3RyaW5nKCkpIHJldHVybjtcclxuXHRcdGlmKGV4cHIuYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkgcmV0dXJuO1xyXG5cdFx0dmFyIHJlc3VsdDtcclxuXHRcdHZhciBhcmcgPSB0aGlzLmV2YWx1YXRlRXhwcmVzc2lvbihleHByLmFyZ3VtZW50c1swXSk7XHJcblx0XHRpZihhcmcuaXNTdHJpbmcoKSkge1xyXG5cdFx0XHRyZXN1bHQgPSBwYXJhbS5zdHJpbmcuc3BsaXQoYXJnLnN0cmluZyk7XHJcblx0XHR9IGVsc2UgaWYoYXJnLmlzUmVnRXhwKCkpIHtcclxuXHRcdFx0cmVzdWx0ID0gcGFyYW0uc3RyaW5nLnNwbGl0KGFyZy5yZWdFeHApO1xyXG5cdFx0fSBlbHNlIHJldHVybjtcclxuXHRcdHJldHVybiBuZXcgQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uKCkuc2V0QXJyYXkocmVzdWx0KS5zZXRSYW5nZShleHByLnJhbmdlKTtcclxuXHR9KTtcclxuXHR0aGlzLnBsdWdpbihcImV2YWx1YXRlIENvbmRpdGlvbmFsRXhwcmVzc2lvblwiLCBmdW5jdGlvbihleHByKSB7XHJcblx0XHR2YXIgY29uZGl0aW9uID0gdGhpcy5ldmFsdWF0ZUV4cHJlc3Npb24oZXhwci50ZXN0KTtcclxuXHRcdHZhciBjb25kaXRpb25WYWx1ZSA9IGNvbmRpdGlvbi5hc0Jvb2woKTtcclxuXHRcdHZhciByZXM7XHJcblx0XHRpZihjb25kaXRpb25WYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHZhciBjb25zZXF1ZW50ID0gdGhpcy5ldmFsdWF0ZUV4cHJlc3Npb24oZXhwci5jb25zZXF1ZW50KTtcclxuXHRcdFx0dmFyIGFsdGVybmF0ZSA9IHRoaXMuZXZhbHVhdGVFeHByZXNzaW9uKGV4cHIuYWx0ZXJuYXRlKTtcclxuXHRcdFx0aWYoIWNvbnNlcXVlbnQgfHwgIWFsdGVybmF0ZSkgcmV0dXJuO1xyXG5cdFx0XHRyZXMgPSBuZXcgQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uKCk7XHJcblx0XHRcdGlmKGNvbnNlcXVlbnQuaXNDb25kaXRpb25hbCgpKVxyXG5cdFx0XHRcdHJlcy5zZXRPcHRpb25zKGNvbnNlcXVlbnQub3B0aW9ucyk7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHRyZXMuc2V0T3B0aW9ucyhbY29uc2VxdWVudF0pO1xyXG5cdFx0XHRpZihhbHRlcm5hdGUuaXNDb25kaXRpb25hbCgpKVxyXG5cdFx0XHRcdHJlcy5hZGRPcHRpb25zKGFsdGVybmF0ZS5vcHRpb25zKTtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHJlcy5hZGRPcHRpb25zKFthbHRlcm5hdGVdKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJlcyA9IHRoaXMuZXZhbHVhdGVFeHByZXNzaW9uKGNvbmRpdGlvblZhbHVlID8gZXhwci5jb25zZXF1ZW50IDogZXhwci5hbHRlcm5hdGUpO1xyXG5cdFx0fVxyXG5cdFx0cmVzLnNldFJhbmdlKGV4cHIucmFuZ2UpO1xyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9KTtcclxuXHR0aGlzLnBsdWdpbihcImV2YWx1YXRlIEFycmF5RXhwcmVzc2lvblwiLCBmdW5jdGlvbihleHByKSB7XHJcblx0XHR2YXIgaXRlbXMgPSBleHByLmVsZW1lbnRzLm1hcChmdW5jdGlvbihlbGVtZW50KSB7XHJcblx0XHRcdHJldHVybiBlbGVtZW50ICE9PSBudWxsICYmIHRoaXMuZXZhbHVhdGVFeHByZXNzaW9uKGVsZW1lbnQpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblx0XHRpZihpdGVtcy5maWx0ZXIoZnVuY3Rpb24oaSkge1xyXG5cdFx0XHRcdHJldHVybiAhaTtcclxuXHRcdFx0fSkubGVuZ3RoID4gMCkgcmV0dXJuO1xyXG5cdFx0cmV0dXJuIG5ldyBCYXNpY0V2YWx1YXRlZEV4cHJlc3Npb24oKS5zZXRJdGVtcyhpdGVtcykuc2V0UmFuZ2UoZXhwci5yYW5nZSk7XHJcblx0fSk7XHJcbn07XHJcblxyXG5QYXJzZXIucHJvdG90eXBlLmdldFJlbmFtZUlkZW50aWZpZXIgPSBmdW5jdGlvbiBnZXRSZW5hbWVJZGVudGlmaWVyKGV4cHIpIHtcclxuXHR2YXIgcmVzdWx0ID0gdGhpcy5ldmFsdWF0ZUV4cHJlc3Npb24oZXhwcik7XHJcblx0aWYoIXJlc3VsdCkgcmV0dXJuO1xyXG5cdGlmKHJlc3VsdC5pc0lkZW50aWZpZXIoKSkgcmV0dXJuIHJlc3VsdC5pZGVudGlmaWVyO1xyXG5cdHJldHVybjtcclxufTtcclxuXHJcblBhcnNlci5wcm90b3R5cGUud2Fsa0NsYXNzID0gZnVuY3Rpb24gd2Fsa0NsYXNzKGNsYXNzeSkge1xyXG5cdGlmKGNsYXNzeS5zdXBlckNsYXNzKVxyXG5cdFx0dGhpcy53YWxrRXhwcmVzc2lvbihjbGFzc3kuc3VwZXJDbGFzcyk7XHJcblx0aWYoY2xhc3N5LmJvZHkgJiYgY2xhc3N5LmJvZHkudHlwZSA9PT0gXCJDbGFzc0JvZHlcIikge1xyXG5cdFx0Y2xhc3N5LmJvZHkuYm9keS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZERlZmluaXRpb24pIHtcclxuXHRcdFx0aWYobWV0aG9kRGVmaW5pdGlvbi50eXBlID09PSBcIk1ldGhvZERlZmluaXRpb25cIilcclxuXHRcdFx0XHR0aGlzLndhbGtNZXRob2REZWZpbml0aW9uKG1ldGhvZERlZmluaXRpb24pO1xyXG5cdFx0fSwgdGhpcyk7XHJcblx0fVxyXG59O1xyXG5cclxuUGFyc2VyLnByb3RvdHlwZS53YWxrTWV0aG9kRGVmaW5pdGlvbiA9IGZ1bmN0aW9uIHdhbGtNZXRob2REZWZpbml0aW9uKG1ldGhvZERlZmluaXRpb24pIHtcclxuXHRpZihtZXRob2REZWZpbml0aW9uLmNvbXB1dGVkICYmIG1ldGhvZERlZmluaXRpb24ua2V5KVxyXG5cdFx0dGhpcy53YWxrRXhwcmVzc2lvbihtZXRob2REZWZpbml0aW9uLmtleSk7XHJcblx0aWYobWV0aG9kRGVmaW5pdGlvbi52YWx1ZSlcclxuXHRcdHRoaXMud2Fsa0V4cHJlc3Npb24obWV0aG9kRGVmaW5pdGlvbi52YWx1ZSk7XHJcbn07XHJcblxyXG5QYXJzZXIucHJvdG90eXBlLndhbGtTdGF0ZW1lbnRzID0gZnVuY3Rpb24gd2Fsa1N0YXRlbWVudHMoc3RhdGVtZW50cykge1xyXG5cdHN0YXRlbWVudHMuZm9yRWFjaChmdW5jdGlvbihzdGF0ZW1lbnQpIHtcclxuXHRcdHRoaXMud2Fsa1N0YXRlbWVudChzdGF0ZW1lbnQpO1xyXG5cdH0sIHRoaXMpO1xyXG59O1xyXG5cclxuUGFyc2VyLnByb3RvdHlwZS53YWxrU3RhdGVtZW50ID0gZnVuY3Rpb24gd2Fsa1N0YXRlbWVudChzdGF0ZW1lbnQpIHtcclxuXHRpZih0aGlzLmFwcGx5UGx1Z2luc0JhaWxSZXN1bHQoXCJzdGF0ZW1lbnRcIiwgc3RhdGVtZW50KSAhPT0gdW5kZWZpbmVkKSByZXR1cm47XHJcblx0aWYodGhpc1tcIndhbGtcIiArIHN0YXRlbWVudC50eXBlXSlcclxuXHRcdHRoaXNbXCJ3YWxrXCIgKyBzdGF0ZW1lbnQudHlwZV0oc3RhdGVtZW50KTtcclxufTtcclxuXHJcbi8vIFJlYWwgU3RhdGVtZW50c1xyXG5QYXJzZXIucHJvdG90eXBlLndhbGtCbG9ja1N0YXRlbWVudCA9IGZ1bmN0aW9uIHdhbGtCbG9ja1N0YXRlbWVudChzdGF0ZW1lbnQpIHtcclxuXHR0aGlzLndhbGtTdGF0ZW1lbnRzKHN0YXRlbWVudC5ib2R5KTtcclxufTtcclxuXHJcblBhcnNlci5wcm90b3R5cGUud2Fsa0V4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbiB3YWxrRXhwcmVzc2lvblN0YXRlbWVudChzdGF0ZW1lbnQpIHtcclxuXHR0aGlzLndhbGtFeHByZXNzaW9uKHN0YXRlbWVudC5leHByZXNzaW9uKTtcclxufTtcclxuXHJcblBhcnNlci5wcm90b3R5cGUud2Fsa0lmU3RhdGVtZW50ID0gZnVuY3Rpb24gd2Fsa0lmU3RhdGVtZW50KHN0YXRlbWVudCkge1xyXG5cdHZhciByZXN1bHQgPSB0aGlzLmFwcGx5UGx1Z2luc0JhaWxSZXN1bHQoXCJzdGF0ZW1lbnQgaWZcIiwgc3RhdGVtZW50KTtcclxuXHRpZihyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0dGhpcy53YWxrRXhwcmVzc2lvbihzdGF0ZW1lbnQudGVzdCk7XHJcblx0XHR0aGlzLndhbGtTdGF0ZW1lbnQoc3RhdGVtZW50LmNvbnNlcXVlbnQpO1xyXG5cdFx0aWYoc3RhdGVtZW50LmFsdGVybmF0ZSlcclxuXHRcdFx0dGhpcy53YWxrU3RhdGVtZW50KHN0YXRlbWVudC5hbHRlcm5hdGUpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRpZihyZXN1bHQpXHJcblx0XHRcdHRoaXMud2Fsa1N0YXRlbWVudChzdGF0ZW1lbnQuY29uc2VxdWVudCk7XHJcblx0XHRlbHNlIGlmKHN0YXRlbWVudC5hbHRlcm5hdGUpXHJcblx0XHRcdHRoaXMud2Fsa1N0YXRlbWVudChzdGF0ZW1lbnQuYWx0ZXJuYXRlKTtcclxuXHR9XHJcbn07XHJcblxyXG5QYXJzZXIucHJvdG90eXBlLndhbGtMYWJlbGVkU3RhdGVtZW50ID0gZnVuY3Rpb24gd2Fsa0xhYmVsZWRTdGF0ZW1lbnQoc3RhdGVtZW50KSB7XHJcblx0dmFyIHJlc3VsdCA9IHRoaXMuYXBwbHlQbHVnaW5zQmFpbFJlc3VsdChcImxhYmVsIFwiICsgc3RhdGVtZW50LmxhYmVsLm5hbWUsIHN0YXRlbWVudCk7XHJcblx0aWYocmVzdWx0ICE9PSB0cnVlKVxyXG5cdFx0dGhpcy53YWxrU3RhdGVtZW50KHN0YXRlbWVudC5ib2R5KTtcclxufTtcclxuXHJcblBhcnNlci5wcm90b3R5cGUud2Fsa1dpdGhTdGF0ZW1lbnQgPSBmdW5jdGlvbiB3YWxrV2l0aFN0YXRlbWVudChzdGF0ZW1lbnQpIHtcclxuXHR0aGlzLndhbGtFeHByZXNzaW9uKHN0YXRlbWVudC5vYmplY3QpO1xyXG5cdHRoaXMud2Fsa1N0YXRlbWVudChzdGF0ZW1lbnQuYm9keSk7XHJcbn07XHJcblxyXG5QYXJzZXIucHJvdG90eXBlLndhbGtTd2l0Y2hTdGF0ZW1lbnQgPSBmdW5jdGlvbiB3YWxrU3dpdGNoU3RhdGVtZW50KHN0YXRlbWVudCkge1xyXG5cdHRoaXMud2Fsa0V4cHJlc3Npb24oc3RhdGVtZW50LmRpc2NyaW1pbmFudCk7XHJcblx0dGhpcy53YWxrU3dpdGNoQ2FzZXMoc3RhdGVtZW50LmNhc2VzKTtcclxufTtcclxuXHJcblBhcnNlci5wcm90b3R5cGUud2Fsa1JldHVyblN0YXRlbWVudCA9XHJcblx0UGFyc2VyLnByb3RvdHlwZS53YWxrVGhyb3dTdGF0ZW1lbnQgPSBmdW5jdGlvbiB3YWxrQXJndW1lbnRTdGF0ZW1lbnQoc3RhdGVtZW50KSB7XHJcblx0XHRpZihzdGF0ZW1lbnQuYXJndW1lbnQpXHJcblx0XHRcdHRoaXMud2Fsa0V4cHJlc3Npb24oc3RhdGVtZW50LmFyZ3VtZW50KTtcclxuXHR9O1xyXG5cclxuUGFyc2VyLnByb3RvdHlwZS53YWxrVHJ5U3RhdGVtZW50ID0gZnVuY3Rpb24gd2Fsa1RyeVN0YXRlbWVudChzdGF0ZW1lbnQpIHtcclxuXHRpZih0aGlzLnNjb3BlLmluVHJ5KSB7XHJcblx0XHR0aGlzLndhbGtTdGF0ZW1lbnQoc3RhdGVtZW50LmJsb2NrKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhpcy5zY29wZS5pblRyeSA9IHRydWU7XHJcblx0XHR0aGlzLndhbGtTdGF0ZW1lbnQoc3RhdGVtZW50LmJsb2NrKTtcclxuXHRcdHRoaXMuc2NvcGUuaW5UcnkgPSBmYWxzZTtcclxuXHR9XHJcblx0aWYoc3RhdGVtZW50LmhhbmRsZXIpXHJcblx0XHR0aGlzLndhbGtDYXRjaENsYXVzZShzdGF0ZW1lbnQuaGFuZGxlcik7XHJcblx0aWYoc3RhdGVtZW50LmZpbmFsaXplcilcclxuXHRcdHRoaXMud2Fsa1N0YXRlbWVudChzdGF0ZW1lbnQuZmluYWxpemVyKTtcclxufTtcclxuXHJcblBhcnNlci5wcm90b3R5cGUud2Fsa1doaWxlU3RhdGVtZW50ID1cclxuXHRQYXJzZXIucHJvdG90eXBlLndhbGtEb1doaWxlU3RhdGVtZW50ID0gZnVuY3Rpb24gd2Fsa0xvb3BTdGF0ZW1lbnQoc3RhdGVtZW50KSB7XHJcblx0XHR0aGlzLndhbGtFeHByZXNzaW9uKHN0YXRlbWVudC50ZXN0KTtcclxuXHRcdHRoaXMud2Fsa1N0YXRlbWVudChzdGF0ZW1lbnQuYm9keSk7XHJcblx0fTtcclxuXHJcblBhcnNlci5wcm90b3R5cGUud2Fsa0ZvclN0YXRlbWVudCA9IGZ1bmN0aW9uIHdhbGtGb3JTdGF0ZW1lbnQoc3RhdGVtZW50KSB7XHJcblx0aWYoc3RhdGVtZW50LmluaXQpIHtcclxuXHRcdGlmKHN0YXRlbWVudC5pbml0LnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKVxyXG5cdFx0XHR0aGlzLndhbGtTdGF0ZW1lbnQoc3RhdGVtZW50LmluaXQpO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHR0aGlzLndhbGtFeHByZXNzaW9uKHN0YXRlbWVudC5pbml0KTtcclxuXHR9XHJcblx0aWYoc3RhdGVtZW50LnRlc3QpXHJcblx0XHR0aGlzLndhbGtFeHByZXNzaW9uKHN0YXRlbWVudC50ZXN0KTtcclxuXHRpZihzdGF0ZW1lbnQudXBkYXRlKVxyXG5cdFx0dGhpcy53YWxrRXhwcmVzc2lvbihzdGF0ZW1lbnQudXBkYXRlKTtcclxuXHR0aGlzLndhbGtTdGF0ZW1lbnQoc3RhdGVtZW50LmJvZHkpO1xyXG59O1xyXG5cclxuUGFyc2VyLnByb3RvdHlwZS53YWxrRm9ySW5TdGF0ZW1lbnQgPSBmdW5jdGlvbiB3YWxrRm9ySW5TdGF0ZW1lbnQoc3RhdGVtZW50KSB7XHJcblx0aWYoc3RhdGVtZW50LmxlZnQudHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpXHJcblx0XHR0aGlzLndhbGtTdGF0ZW1lbnQoc3RhdGVtZW50LmxlZnQpO1xyXG5cdGVsc2VcclxuXHRcdHRoaXMud2Fsa0V4cHJlc3Npb24oc3RhdGVtZW50LmxlZnQpO1xyXG5cdHRoaXMud2Fsa0V4cHJlc3Npb24oc3RhdGVtZW50LnJpZ2h0KTtcclxuXHR0aGlzLndhbGtTdGF0ZW1lbnQoc3RhdGVtZW50LmJvZHkpO1xyXG59O1xyXG5cclxuUGFyc2VyLnByb3RvdHlwZS53YWxrRm9yT2ZTdGF0ZW1lbnQgPSBmdW5jdGlvbiB3YWxrRm9yT2ZTdGF0ZW1lbnQoc3RhdGVtZW50KSB7XHJcblx0aWYoc3RhdGVtZW50LmxlZnQudHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpXHJcblx0XHR0aGlzLndhbGtTdGF0ZW1lbnQoc3RhdGVtZW50LmxlZnQpO1xyXG5cdGVsc2VcclxuXHRcdHRoaXMud2Fsa0V4cHJlc3Npb24oc3RhdGVtZW50LmxlZnQpO1xyXG5cdHRoaXMud2Fsa0V4cHJlc3Npb24oc3RhdGVtZW50LnJpZ2h0KTtcclxuXHR0aGlzLndhbGtTdGF0ZW1lbnQoc3RhdGVtZW50LmJvZHkpO1xyXG59O1xyXG5cclxuLy8gRGVjbGFyYXRpb25zXHJcblBhcnNlci5wcm90b3R5cGUud2Fsa0Z1bmN0aW9uRGVjbGFyYXRpb24gPSBmdW5jdGlvbiB3YWxrRnVuY3Rpb25EZWNsYXJhdGlvbihzdGF0ZW1lbnQpIHtcclxuXHR0aGlzLnNjb3BlLnJlbmFtZXNbXCIkXCIgKyBzdGF0ZW1lbnQuaWQubmFtZV0gPSB1bmRlZmluZWQ7XHJcblx0dGhpcy5zY29wZS5kZWZpbml0aW9ucy5wdXNoKHN0YXRlbWVudC5pZC5uYW1lKTtcclxuXHR0aGlzLmluU2NvcGUoc3RhdGVtZW50LnBhcmFtcywgZnVuY3Rpb24oKSB7XHJcblx0XHRpZihzdGF0ZW1lbnQuYm9keS50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIpXHJcblx0XHRcdHRoaXMud2Fsa1N0YXRlbWVudChzdGF0ZW1lbnQuYm9keSk7XHJcblx0XHRlbHNlXHJcblx0XHRcdHRoaXMud2Fsa0V4cHJlc3Npb24oc3RhdGVtZW50LmJvZHkpO1xyXG5cdH0uYmluZCh0aGlzKSk7XHJcbn07XHJcblxyXG5QYXJzZXIucHJvdG90eXBlLndhbGtWYXJpYWJsZURlY2xhcmF0aW9uID0gZnVuY3Rpb24gd2Fsa1ZhcmlhYmxlRGVjbGFyYXRpb24oc3RhdGVtZW50KSB7XHJcblx0aWYoc3RhdGVtZW50LmRlY2xhcmF0aW9ucylcclxuXHRcdHRoaXMud2Fsa1ZhcmlhYmxlRGVjbGFyYXRvcnMoc3RhdGVtZW50LmRlY2xhcmF0aW9ucyk7XHJcbn07XHJcblxyXG5QYXJzZXIucHJvdG90eXBlLndhbGtDbGFzc0RlY2xhcmF0aW9uID0gZnVuY3Rpb24gd2Fsa0NsYXNzRGVjbGFyYXRpb24oc3RhdGVtZW50KSB7XHJcblx0dGhpcy53YWxrQ2xhc3Moc3RhdGVtZW50KTtcclxufTtcclxuXHJcblBhcnNlci5wcm90b3R5cGUud2Fsa1N3aXRjaENhc2VzID0gZnVuY3Rpb24gd2Fsa1N3aXRjaENhc2VzKHN3aXRjaENhc2VzKSB7XHJcblx0c3dpdGNoQ2FzZXMuZm9yRWFjaChmdW5jdGlvbihzd2l0Y2hDYXNlKSB7XHJcblx0XHRpZihzd2l0Y2hDYXNlLnRlc3QpXHJcblx0XHRcdHRoaXMud2Fsa0V4cHJlc3Npb24oc3dpdGNoQ2FzZS50ZXN0KTtcclxuXHRcdHRoaXMud2Fsa1N0YXRlbWVudHMoc3dpdGNoQ2FzZS5jb25zZXF1ZW50KTtcclxuXHR9LCB0aGlzKTtcclxufTtcclxuXHJcblBhcnNlci5wcm90b3R5cGUud2Fsa0NhdGNoQ2xhdXNlID0gZnVuY3Rpb24gd2Fsa0NhdGNoQ2xhdXNlKGNhdGNoQ2xhdXNlKSB7XHJcblx0aWYoY2F0Y2hDbGF1c2UuZ3VhcmQpXHJcblx0XHR0aGlzLndhbGtFeHByZXNzaW9uKGNhdGNoQ2xhdXNlLmd1YXJkKTtcclxuXHR0aGlzLmluU2NvcGUoW2NhdGNoQ2xhdXNlLnBhcmFtXSwgZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLndhbGtTdGF0ZW1lbnQoY2F0Y2hDbGF1c2UuYm9keSk7XHJcblx0fS5iaW5kKHRoaXMpKTtcclxufTtcclxuXHJcblBhcnNlci5wcm90b3R5cGUud2Fsa1ZhcmlhYmxlRGVjbGFyYXRvcnMgPSBmdW5jdGlvbiB3YWxrVmFyaWFibGVEZWNsYXJhdG9ycyhkZWNsYXJhdG9ycykge1xyXG5cdGRlY2xhcmF0b3JzLmZvckVhY2goZnVuY3Rpb24oZGVjbGFyYXRvcikge1xyXG5cdFx0c3dpdGNoKGRlY2xhcmF0b3IudHlwZSkge1xyXG5cdFx0XHRjYXNlIFwiVmFyaWFibGVEZWNsYXJhdG9yXCI6XHJcblx0XHRcdFx0dmFyIHJlbmFtZUlkZW50aWZpZXIgPSBkZWNsYXJhdG9yLmluaXQgJiYgdGhpcy5nZXRSZW5hbWVJZGVudGlmaWVyKGRlY2xhcmF0b3IuaW5pdCk7XHJcblx0XHRcdFx0aWYocmVuYW1lSWRlbnRpZmllciAmJiBkZWNsYXJhdG9yLmlkLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHRoaXMuYXBwbHlQbHVnaW5zQmFpbFJlc3VsdChcImNhbi1yZW5hbWUgXCIgKyByZW5hbWVJZGVudGlmaWVyLCBkZWNsYXJhdG9yLmluaXQpKSB7XHJcblx0XHRcdFx0XHQvLyByZW5hbWluZyB3aXRoIFwidmFyIGEgPSBiO1wiXHJcblx0XHRcdFx0XHRpZighdGhpcy5hcHBseVBsdWdpbnNCYWlsUmVzdWx0KFwicmVuYW1lIFwiICsgcmVuYW1lSWRlbnRpZmllciwgZGVjbGFyYXRvci5pbml0KSkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnNjb3BlLnJlbmFtZXNbXCIkXCIgKyBkZWNsYXJhdG9yLmlkLm5hbWVdID0gdGhpcy5zY29wZS5yZW5hbWVzW1wiJFwiICsgcmVuYW1lSWRlbnRpZmllcl0gfHwgcmVuYW1lSWRlbnRpZmllcjtcclxuXHRcdFx0XHRcdFx0dmFyIGlkeCA9IHRoaXMuc2NvcGUuZGVmaW5pdGlvbnMuaW5kZXhPZihkZWNsYXJhdG9yLmlkLm5hbWUpO1xyXG5cdFx0XHRcdFx0XHRpZihpZHggPj0gMCkgdGhpcy5zY29wZS5kZWZpbml0aW9ucy5zcGxpY2UoaWR4LCAxKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2UgaWYoZGVjbGFyYXRvci5pZC50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiAhdGhpcy5hcHBseVBsdWdpbnNCYWlsUmVzdWx0KFwidmFyIFwiICsgZGVjbGFyYXRvci5pZC5uYW1lLCBkZWNsYXJhdG9yKSkge1xyXG5cdFx0XHRcdFx0dGhpcy5zY29wZS5yZW5hbWVzW1wiJFwiICsgZGVjbGFyYXRvci5pZC5uYW1lXSA9IHVuZGVmaW5lZDtcclxuXHRcdFx0XHRcdHRoaXMuc2NvcGUuZGVmaW5pdGlvbnMucHVzaChkZWNsYXJhdG9yLmlkLm5hbWUpO1xyXG5cdFx0XHRcdFx0aWYoZGVjbGFyYXRvci5pbml0KVxyXG5cdFx0XHRcdFx0XHR0aGlzLndhbGtFeHByZXNzaW9uKGRlY2xhcmF0b3IuaW5pdCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRoaXMud2Fsa0V4cHJlc3Npb24oZGVjbGFyYXRvci5pZCk7XHJcblx0XHRcdFx0XHRpZihkZWNsYXJhdG9yLmluaXQpXHJcblx0XHRcdFx0XHRcdHRoaXMud2Fsa0V4cHJlc3Npb24oZGVjbGFyYXRvci5pbml0KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblx0fSwgdGhpcyk7XHJcbn07XHJcblxyXG5QYXJzZXIucHJvdG90eXBlLndhbGtFeHByZXNzaW9ucyA9IGZ1bmN0aW9uIHdhbGtFeHByZXNzaW9ucyhleHByZXNzaW9ucykge1xyXG5cdGV4cHJlc3Npb25zLmZvckVhY2goZnVuY3Rpb24oZXhwcmVzc2lvbikge1xyXG5cdFx0aWYoZXhwcmVzc2lvbilcclxuXHRcdFx0dGhpcy53YWxrRXhwcmVzc2lvbihleHByZXNzaW9uKTtcclxuXHR9LCB0aGlzKTtcclxufTtcclxuXHJcblBhcnNlci5wcm90b3R5cGUud2Fsa0V4cHJlc3Npb24gPSBmdW5jdGlvbiB3YWxrRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XHJcblx0aWYodGhpc1tcIndhbGtcIiArIGV4cHJlc3Npb24udHlwZV0pXHJcblx0XHRyZXR1cm4gdGhpc1tcIndhbGtcIiArIGV4cHJlc3Npb24udHlwZV0oZXhwcmVzc2lvbik7XHJcbn07XHJcblxyXG5QYXJzZXIucHJvdG90eXBlLndhbGtBcnJheUV4cHJlc3Npb24gPSBmdW5jdGlvbiB3YWxrQXJyYXlFeHByZXNzaW9uKGV4cHJlc3Npb24pIHtcclxuXHRpZihleHByZXNzaW9uLmVsZW1lbnRzKVxyXG5cdFx0dGhpcy53YWxrRXhwcmVzc2lvbnMoZXhwcmVzc2lvbi5lbGVtZW50cyk7XHJcbn07XHJcblxyXG5QYXJzZXIucHJvdG90eXBlLndhbGtTcHJlYWRFbGVtZW50ID0gZnVuY3Rpb24gd2Fsa1NwcmVhZEVsZW1lbnQoZXhwcmVzc2lvbikge1xyXG5cdGlmKGV4cHJlc3Npb24uYXJndW1lbnQpXHJcblx0XHR0aGlzLndhbGtFeHByZXNzaW9uKGV4cHJlc3Npb24uYXJndW1lbnQpO1xyXG59O1xyXG5cclxuUGFyc2VyLnByb3RvdHlwZS53YWxrT2JqZWN0RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIHdhbGtPYmplY3RFeHByZXNzaW9uKGV4cHJlc3Npb24pIHtcclxuXHRleHByZXNzaW9uLnByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XHJcblx0XHRpZihwcm9wLmNvbXB1dGVkKVxyXG5cdFx0XHR0aGlzLndhbGtFeHByZXNzaW9uKHByb3Aua2V5KVxyXG5cdFx0dGhpcy53YWxrRXhwcmVzc2lvbihwcm9wLnZhbHVlKTtcclxuXHR9LCB0aGlzKTtcclxufTtcclxuXHJcblBhcnNlci5wcm90b3R5cGUud2Fsa0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIHdhbGtGdW5jdGlvbkV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xyXG5cdHRoaXMuaW5TY29wZShleHByZXNzaW9uLnBhcmFtcywgZnVuY3Rpb24oKSB7XHJcblx0XHRpZihleHByZXNzaW9uLmJvZHkudHlwZSA9PT0gXCJCbG9ja1N0YXRlbWVudFwiKVxyXG5cdFx0XHR0aGlzLndhbGtTdGF0ZW1lbnQoZXhwcmVzc2lvbi5ib2R5KTtcclxuXHRcdGVsc2VcclxuXHRcdFx0dGhpcy53YWxrRXhwcmVzc2lvbihleHByZXNzaW9uLmJvZHkpO1xyXG5cdH0uYmluZCh0aGlzKSk7XHJcbn07XHJcblxyXG5QYXJzZXIucHJvdG90eXBlLndhbGtBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIHdhbGtBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XHJcblx0dGhpcy5pblNjb3BlKGV4cHJlc3Npb24ucGFyYW1zLCBmdW5jdGlvbigpIHtcclxuXHRcdGlmKGV4cHJlc3Npb24uYm9keS50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIpXHJcblx0XHRcdHRoaXMud2Fsa1N0YXRlbWVudChleHByZXNzaW9uLmJvZHkpO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHR0aGlzLndhbGtFeHByZXNzaW9uKGV4cHJlc3Npb24uYm9keSk7XHJcblx0fS5iaW5kKHRoaXMpKTtcclxufTtcclxuXHJcblBhcnNlci5wcm90b3R5cGUud2Fsa1NlcXVlbmNlRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIHdhbGtTZXF1ZW5jZUV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xyXG5cdGlmKGV4cHJlc3Npb24uZXhwcmVzc2lvbnMpXHJcblx0XHR0aGlzLndhbGtFeHByZXNzaW9ucyhleHByZXNzaW9uLmV4cHJlc3Npb25zKTtcclxufTtcclxuXHJcblBhcnNlci5wcm90b3R5cGUud2Fsa1VwZGF0ZUV4cHJlc3Npb24gPSBmdW5jdGlvbiB3YWxrVXBkYXRlRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XHJcblx0dGhpcy53YWxrRXhwcmVzc2lvbihleHByZXNzaW9uLmFyZ3VtZW50KTtcclxufTtcclxuXHJcblBhcnNlci5wcm90b3R5cGUud2Fsa1VuYXJ5RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIHdhbGtVbmFyeUV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xyXG5cdGlmKGV4cHJlc3Npb24ub3BlcmF0b3IgPT09IFwidHlwZW9mXCIpIHtcclxuXHRcdHZhciBleHByID0gZXhwcmVzc2lvbi5hcmd1bWVudDtcclxuXHRcdHZhciBleHByTmFtZSA9IFtdO1xyXG5cdFx0d2hpbGUoZXhwci50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIiAmJiAhZXhwci5jb21wdXRlZCkge1xyXG5cdFx0XHRleHByTmFtZS51bnNoaWZ0KGV4cHIucHJvcGVydHkubmFtZSk7XHJcblx0XHRcdGV4cHIgPSBleHByLm9iamVjdDtcclxuXHRcdH1cclxuXHRcdGlmKGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgdGhpcy5zY29wZS5kZWZpbml0aW9ucy5pbmRleE9mKGV4cHIubmFtZSkgPT09IC0xKSB7XHJcblx0XHRcdGV4cHJOYW1lLnVuc2hpZnQodGhpcy5zY29wZS5yZW5hbWVzW1wiJFwiICsgZXhwci5uYW1lXSB8fCBleHByLm5hbWUpO1xyXG5cdFx0XHRleHByTmFtZSA9IGV4cHJOYW1lLmpvaW4oXCIuXCIpO1xyXG5cdFx0XHR2YXIgcmVzdWx0ID0gdGhpcy5hcHBseVBsdWdpbnNCYWlsUmVzdWx0KFwidHlwZW9mIFwiICsgZXhwck5hbWUsIGV4cHJlc3Npb24pO1xyXG5cdFx0XHRpZihyZXN1bHQgPT09IHRydWUpXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdH1cclxuXHR0aGlzLndhbGtFeHByZXNzaW9uKGV4cHJlc3Npb24uYXJndW1lbnQpO1xyXG59O1xyXG5cclxuUGFyc2VyLnByb3RvdHlwZS53YWxrQmluYXJ5RXhwcmVzc2lvbiA9XHJcblx0UGFyc2VyLnByb3RvdHlwZS53YWxrTG9naWNhbEV4cHJlc3Npb24gPSBmdW5jdGlvbiB3YWxrTGVmdFJpZ2h0RXhwcmVzc2lvbihleHByZXNzaW9uKSB7XHJcblx0XHR0aGlzLndhbGtFeHByZXNzaW9uKGV4cHJlc3Npb24ubGVmdCk7XHJcblx0XHR0aGlzLndhbGtFeHByZXNzaW9uKGV4cHJlc3Npb24ucmlnaHQpO1xyXG5cdH07XHJcblxyXG5QYXJzZXIucHJvdG90eXBlLndhbGtBc3NpZ25tZW50RXhwcmVzc2lvbiA9IGZ1bmN0aW9uIHdhbGtBc3NpZ25tZW50RXhwcmVzc2lvbihleHByZXNzaW9uKSB7XHJcblx0dmFyIHJlbmFtZUlkZW50aWZpZXIgPSB0aGlzLmdldFJlbmFtZUlkZW50aWZpZXIoZXhwcmVzc2lvbi5yaWdodCk7XHJcblx0aWYoZXhwcmVzc2lvbi5sZWZ0LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHJlbmFtZUlkZW50aWZpZXIgJiYgdGhpcy5hcHBseVBsdWdpbnNCYWlsUmVzdWx0KFwiY2FuLXJlbmFtZSBcIiArIHJlbmFtZUlkZW50aWZpZXIsIGV4cHJlc3Npb24ucmlnaHQpKSB7XHJcblx0XHQvLyByZW5hbWluZyBcImEgPSBiO1wiXHJcblx0XHRpZighdGhpcy5hcHBseVBsdWdpbnNCYWlsUmVzdWx0KFwicmVuYW1lIFwiICsgcmVuYW1lSWRlbnRpZmllciwgZXhwcmVzc2lvbi5yaWdodCkpIHtcclxuXHRcdFx0dGhpcy5zY29wZS5yZW5hbWVzW1wiJFwiICsgZXhwcmVzc2lvbi5sZWZ0Lm5hbWVdID0gcmVuYW1lSWRlbnRpZmllcjtcclxuXHRcdFx0dmFyIGlkeCA9IHRoaXMuc2NvcGUuZGVmaW5pdGlvbnMuaW5kZXhPZihleHByZXNzaW9uLmxlZnQubmFtZSk7XHJcblx0XHRcdGlmKGlkeCA+PSAwKSB0aGlzLnNjb3BlLmRlZmluaXRpb25zLnNwbGljZShpZHgsIDEpO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZihleHByZXNzaW9uLmxlZnQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcclxuXHRcdGlmKCF0aGlzLmFwcGx5UGx1Z2luc0JhaWxSZXN1bHQoXCJhc3NpZ25lZCBcIiArIGV4cHJlc3Npb24ubGVmdC5uYW1lLCBleHByZXNzaW9uKSkge1xyXG5cdFx0XHR0aGlzLndhbGtFeHByZXNzaW9uKGV4cHJlc3Npb24ucmlnaHQpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5zY29wZS5yZW5hbWVzW1wiJFwiICsgZXhwcmVzc2lvbi5sZWZ0Lm5hbWVdID0gdW5kZWZpbmVkO1xyXG5cdFx0aWYoIXRoaXMuYXBwbHlQbHVnaW5zQmFpbFJlc3VsdChcImFzc2lnbiBcIiArIGV4cHJlc3Npb24ubGVmdC5uYW1lLCBleHByZXNzaW9uKSkge1xyXG5cdFx0XHR0aGlzLndhbGtFeHByZXNzaW9uKGV4cHJlc3Npb24ubGVmdCk7XHJcblx0XHR9XHJcblx0fSBlbHNlIHtcclxuXHRcdHRoaXMud2Fsa0V4cHJlc3Npb24oZXhwcmVzc2lvbi5yaWdodCk7XHJcblx0XHR0aGlzLnNjb3BlLnJlbmFtZXNbXCIkXCIgKyBleHByZXNzaW9uLmxlZnQubmFtZV0gPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLndhbGtFeHByZXNzaW9uKGV4cHJlc3Npb24ubGVmdCk7XHJcblx0fVxyXG59O1xyXG5cclxuUGFyc2VyLnByb3RvdHlwZS53YWxrQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gZnVuY3Rpb24gd2Fsa0NvbmRpdGlvbmFsRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XHJcblx0dmFyIHJlc3VsdCA9IHRoaXMuYXBwbHlQbHVnaW5zQmFpbFJlc3VsdChcImV4cHJlc3Npb24gPzpcIiwgZXhwcmVzc2lvbik7XHJcblx0aWYocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdHRoaXMud2Fsa0V4cHJlc3Npb24oZXhwcmVzc2lvbi50ZXN0KTtcclxuXHRcdHRoaXMud2Fsa0V4cHJlc3Npb24oZXhwcmVzc2lvbi5jb25zZXF1ZW50KTtcclxuXHRcdGlmKGV4cHJlc3Npb24uYWx0ZXJuYXRlKVxyXG5cdFx0XHR0aGlzLndhbGtFeHByZXNzaW9uKGV4cHJlc3Npb24uYWx0ZXJuYXRlKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0aWYocmVzdWx0KVxyXG5cdFx0XHR0aGlzLndhbGtFeHByZXNzaW9uKGV4cHJlc3Npb24uY29uc2VxdWVudCk7XHJcblx0XHRlbHNlIGlmKGV4cHJlc3Npb24uYWx0ZXJuYXRlKVxyXG5cdFx0XHR0aGlzLndhbGtFeHByZXNzaW9uKGV4cHJlc3Npb24uYWx0ZXJuYXRlKTtcclxuXHR9XHJcbn07XHJcblxyXG5QYXJzZXIucHJvdG90eXBlLndhbGtOZXdFeHByZXNzaW9uID0gZnVuY3Rpb24gd2Fsa05ld0V4cHJlc3Npb24oZXhwcmVzc2lvbikge1xyXG5cdHRoaXMud2Fsa0V4cHJlc3Npb24oZXhwcmVzc2lvbi5jYWxsZWUpO1xyXG5cdGlmKGV4cHJlc3Npb24uYXJndW1lbnRzKVxyXG5cdFx0dGhpcy53YWxrRXhwcmVzc2lvbnMoZXhwcmVzc2lvbi5hcmd1bWVudHMpO1xyXG59O1xyXG5cclxuUGFyc2VyLnByb3RvdHlwZS53YWxrWWllbGRFeHByZXNzaW9uID0gZnVuY3Rpb24gd2Fsa1lpZWxkRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XHJcblx0aWYoZXhwcmVzc2lvbi5hcmd1bWVudClcclxuXHRcdHRoaXMud2Fsa0V4cHJlc3Npb24oZXhwcmVzc2lvbi5hcmd1bWVudCk7XHJcbn07XHJcblxyXG5QYXJzZXIucHJvdG90eXBlLndhbGtUZW1wbGF0ZUxpdGVyYWwgPSBmdW5jdGlvbiB3YWxrVGVtcGxhdGVMaXRlcmFsKGV4cHJlc3Npb24pIHtcclxuXHRpZihleHByZXNzaW9uLmV4cHJlc3Npb25zKVxyXG5cdFx0dGhpcy53YWxrRXhwcmVzc2lvbnMoZXhwcmVzc2lvbi5leHByZXNzaW9ucyk7XHJcbn07XHJcblxyXG5QYXJzZXIucHJvdG90eXBlLndhbGtUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24gPSBmdW5jdGlvbiB3YWxrVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKGV4cHJlc3Npb24pIHtcclxuXHRpZihleHByZXNzaW9uLnRhZylcclxuXHRcdHRoaXMud2Fsa0V4cHJlc3Npb24oZXhwcmVzc2lvbi50YWcpO1xyXG5cdGlmKGV4cHJlc3Npb24ucXVhc2kgJiYgZXhwcmVzc2lvbi5xdWFzaS5leHByZXNzaW9ucylcclxuXHRcdHRoaXMud2Fsa0V4cHJlc3Npb25zKGV4cHJlc3Npb24ucXVhc2kuZXhwcmVzc2lvbnMpO1xyXG59O1xyXG5cclxuUGFyc2VyLnByb3RvdHlwZS53YWxrQ2xhc3NFeHByZXNzaW9uID0gZnVuY3Rpb24gd2Fsa0NsYXNzRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XHJcblx0dGhpcy53YWxrQ2xhc3MoZXhwcmVzc2lvbik7XHJcbn07XHJcblxyXG5QYXJzZXIucHJvdG90eXBlLndhbGtDYWxsRXhwcmVzc2lvbiA9IGZ1bmN0aW9uIHdhbGtDYWxsRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XHJcblx0ZnVuY3Rpb24gd2Fsa0lJRkUoZnVuY3Rpb25FeHByZXNzaW9uLCBhcmdzKSB7XHJcblx0XHR2YXIgcGFyYW1zID0gZnVuY3Rpb25FeHByZXNzaW9uLnBhcmFtcztcclxuXHRcdHZhciBhcmdzID0gYXJncy5tYXAoZnVuY3Rpb24oYXJnKSB7XHJcblx0XHRcdHZhciByZW5hbWVJZGVudGlmaWVyID0gdGhpcy5nZXRSZW5hbWVJZGVudGlmaWVyKGFyZyk7XHJcblx0XHRcdGlmKHJlbmFtZUlkZW50aWZpZXIgJiYgdGhpcy5hcHBseVBsdWdpbnNCYWlsUmVzdWx0KFwiY2FuLXJlbmFtZSBcIiArIHJlbmFtZUlkZW50aWZpZXIsIGFyZykpIHtcclxuXHRcdFx0XHRpZighdGhpcy5hcHBseVBsdWdpbnNCYWlsUmVzdWx0KFwicmVuYW1lIFwiICsgcmVuYW1lSWRlbnRpZmllciwgYXJnKSlcclxuXHRcdFx0XHRcdHJldHVybiByZW5hbWVJZGVudGlmaWVyO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMud2Fsa0V4cHJlc3Npb24oYXJnKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdFx0dGhpcy5pblNjb3BlKHBhcmFtcy5maWx0ZXIoZnVuY3Rpb24oaWRlbnRpZmllciwgaWR4KSB7XHJcblx0XHRcdHJldHVybiAhYXJnc1tpZHhdO1xyXG5cdFx0fSksIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRhcmdzLmZvckVhY2goZnVuY3Rpb24oYXJnLCBpZHgpIHtcclxuXHRcdFx0XHRpZighYXJnKSByZXR1cm47XHJcblx0XHRcdFx0aWYoIXBhcmFtc1tpZHhdIHx8IHBhcmFtc1tpZHhdLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSByZXR1cm47XHJcblx0XHRcdFx0dGhpcy5zY29wZS5yZW5hbWVzW1wiJFwiICsgcGFyYW1zW2lkeF0ubmFtZV0gPSBhcmc7XHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0XHRpZihmdW5jdGlvbkV4cHJlc3Npb24uYm9keS50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIpXHJcblx0XHRcdFx0dGhpcy53YWxrU3RhdGVtZW50KGZ1bmN0aW9uRXhwcmVzc2lvbi5ib2R5KTtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHRoaXMud2Fsa0V4cHJlc3Npb24oZnVuY3Rpb25FeHByZXNzaW9uLmJvZHkpO1xyXG5cdFx0fS5iaW5kKHRoaXMpKTtcclxuXHR9XHJcblx0aWYoZXhwcmVzc2lvbi5jYWxsZWUudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgZXhwcmVzc2lvbi5jYWxsZWUub2JqZWN0LnR5cGUgPT09IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgIWV4cHJlc3Npb24uY2FsbGVlLmNvbXB1dGVkICYmIFtcImNhbGxcIiwgXCJiaW5kXCJdLmluZGV4T2YoZXhwcmVzc2lvbi5jYWxsZWUucHJvcGVydHkubmFtZSkgPj0gMCAmJiBleHByZXNzaW9uLmFyZ3VtZW50cyAmJiBleHByZXNzaW9uLmFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XHJcblx0XHQvLyAoZnVuY3Rpb24oLi4uKSB7IH0uY2FsbC9iaW5kKD8sIC4uLikpXHJcblx0XHR3YWxrSUlGRS5jYWxsKHRoaXMsIGV4cHJlc3Npb24uY2FsbGVlLm9iamVjdCwgZXhwcmVzc2lvbi5hcmd1bWVudHMuc2xpY2UoMSkpO1xyXG5cdFx0dGhpcy53YWxrRXhwcmVzc2lvbihleHByZXNzaW9uLmFyZ3VtZW50c1swXSk7XHJcblx0fSBlbHNlIGlmKGV4cHJlc3Npb24uY2FsbGVlLnR5cGUgPT09IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgZXhwcmVzc2lvbi5hcmd1bWVudHMpIHtcclxuXHRcdC8vIChmdW5jdGlvbiguLi4pIHsgfSguLi4pKVxyXG5cdFx0d2Fsa0lJRkUuY2FsbCh0aGlzLCBleHByZXNzaW9uLmNhbGxlZSwgZXhwcmVzc2lvbi5hcmd1bWVudHMpO1xyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0dmFyIGNhbGxlZSA9IHRoaXMuZXZhbHVhdGVFeHByZXNzaW9uKGV4cHJlc3Npb24uY2FsbGVlKTtcclxuXHRcdGlmKGNhbGxlZS5pc0lkZW50aWZpZXIoKSkge1xyXG5cdFx0XHR2YXIgcmVzdWx0ID0gdGhpcy5hcHBseVBsdWdpbnNCYWlsUmVzdWx0KFwiY2FsbCBcIiArIGNhbGxlZS5pZGVudGlmaWVyLCBleHByZXNzaW9uKTtcclxuXHRcdFx0aWYocmVzdWx0ID09PSB0cnVlKVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZihleHByZXNzaW9uLmNhbGxlZSlcclxuXHRcdFx0dGhpcy53YWxrRXhwcmVzc2lvbihleHByZXNzaW9uLmNhbGxlZSk7XHJcblx0XHRpZihleHByZXNzaW9uLmFyZ3VtZW50cylcclxuXHRcdFx0dGhpcy53YWxrRXhwcmVzc2lvbnMoZXhwcmVzc2lvbi5hcmd1bWVudHMpO1xyXG5cdH1cclxufTtcclxuXHJcblBhcnNlci5wcm90b3R5cGUud2Fsa01lbWJlckV4cHJlc3Npb24gPSBmdW5jdGlvbiB3YWxrTWVtYmVyRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XHJcblx0dmFyIGV4cHIgPSBleHByZXNzaW9uO1xyXG5cdHZhciBleHByTmFtZSA9IFtdO1xyXG5cdHdoaWxlKGV4cHIudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgIWV4cHIuY29tcHV0ZWQpIHtcclxuXHRcdGV4cHJOYW1lLnVuc2hpZnQoZXhwci5wcm9wZXJ0eS5uYW1lKTtcclxuXHRcdGV4cHIgPSBleHByLm9iamVjdDtcclxuXHR9XHJcblx0aWYoZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiB0aGlzLnNjb3BlLmRlZmluaXRpb25zLmluZGV4T2YoZXhwci5uYW1lKSA9PT0gLTEpIHtcclxuXHRcdGV4cHJOYW1lLnVuc2hpZnQodGhpcy5zY29wZS5yZW5hbWVzW1wiJFwiICsgZXhwci5uYW1lXSB8fCBleHByLm5hbWUpO1xyXG5cdFx0ZXhwck5hbWUgPSBleHByTmFtZS5qb2luKFwiLlwiKTtcclxuXHRcdHZhciByZXN1bHQgPSB0aGlzLmFwcGx5UGx1Z2luc0JhaWxSZXN1bHQoXCJleHByZXNzaW9uIFwiICsgZXhwck5hbWUsIGV4cHJlc3Npb24pO1xyXG5cdFx0aWYocmVzdWx0ID09PSB0cnVlKVxyXG5cdFx0XHRyZXR1cm47XHJcblx0fVxyXG5cdHRoaXMud2Fsa0V4cHJlc3Npb24oZXhwcmVzc2lvbi5vYmplY3QpO1xyXG5cdGlmKGV4cHJlc3Npb24uY29tcHV0ZWQgPT09IHRydWUpXHJcblx0XHR0aGlzLndhbGtFeHByZXNzaW9uKGV4cHJlc3Npb24ucHJvcGVydHkpO1xyXG59O1xyXG5cclxuUGFyc2VyLnByb3RvdHlwZS53YWxrSWRlbnRpZmllciA9IGZ1bmN0aW9uIHdhbGtJZGVudGlmaWVyKGV4cHJlc3Npb24pIHtcclxuXHRpZih0aGlzLnNjb3BlLmRlZmluaXRpb25zLmluZGV4T2YoZXhwcmVzc2lvbi5uYW1lKSA9PT0gLTEpIHtcclxuXHRcdHZhciByZXN1bHQgPSB0aGlzLmFwcGx5UGx1Z2luc0JhaWxSZXN1bHQoXCJleHByZXNzaW9uIFwiICsgKHRoaXMuc2NvcGUucmVuYW1lc1tcIiRcIiArIGV4cHJlc3Npb24ubmFtZV0gfHwgZXhwcmVzc2lvbi5uYW1lKSwgZXhwcmVzc2lvbik7XHJcblx0XHRpZihyZXN1bHQgPT09IHRydWUpXHJcblx0XHRcdHJldHVybjtcclxuXHR9XHJcbn07XHJcblxyXG5QYXJzZXIucHJvdG90eXBlLmluU2NvcGUgPSBmdW5jdGlvbiBpblNjb3BlKHBhcmFtcywgZm4pIHtcclxuXHR2YXIgb2xkU2NvcGUgPSB0aGlzLnNjb3BlO1xyXG5cdHRoaXMuc2NvcGUgPSB7XHJcblx0XHRpblRyeTogZmFsc2UsXHJcblx0XHRkZWZpbml0aW9uczogb2xkU2NvcGUuZGVmaW5pdGlvbnMuc2xpY2UoKSxcclxuXHRcdHJlbmFtZXM6IE9iamVjdC5jcmVhdGUob2xkU2NvcGUucmVuYW1lcylcclxuXHR9O1xyXG5cdHBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtKSB7XHJcblx0XHRpZih0eXBlb2YgcGFyYW0gIT09IFwic3RyaW5nXCIpIHtcclxuXHRcdFx0aWYocGFyYW0udHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRwYXJhbSA9IHBhcmFtLm5hbWU7XHJcblx0XHR9XHJcblx0XHR0aGlzLnNjb3BlLnJlbmFtZXNbXCIkXCIgKyBwYXJhbV0gPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLnNjb3BlLmRlZmluaXRpb25zLnB1c2gocGFyYW0pO1xyXG5cdH0sIHRoaXMpO1xyXG5cdGZuKCk7XHJcblx0dGhpcy5zY29wZSA9IG9sZFNjb3BlO1xyXG59O1xyXG5cclxuUGFyc2VyLnByb3RvdHlwZS5ldmFsdWF0ZUV4cHJlc3Npb24gPSBmdW5jdGlvbiBldmFsdWF0ZUV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xyXG5cdHZhciByZXN1bHQgPSB0aGlzLmFwcGx5UGx1Z2luc0JhaWxSZXN1bHQoXCJldmFsdWF0ZSBcIiArIGV4cHJlc3Npb24udHlwZSwgZXhwcmVzc2lvbik7XHJcblx0aWYocmVzdWx0ICE9PSB1bmRlZmluZWQpXHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdHJldHVybiBuZXcgQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uKCkuc2V0UmFuZ2UoZXhwcmVzc2lvbi5yYW5nZSk7XHJcbn07XHJcblxyXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU3RyaW5nID0gZnVuY3Rpb24gcGFyc2VTdHJpbmcoZXhwcmVzc2lvbikge1xyXG5cdHN3aXRjaChleHByZXNzaW9uLnR5cGUpIHtcclxuXHRcdGNhc2UgXCJCaW5hcnlFeHByZXNzaW9uXCI6XHJcblx0XHRcdGlmKGV4cHJlc3Npb24ub3BlcmF0b3IgPT09IFwiK1wiKVxyXG5cdFx0XHRcdHJldHVybiB0aGlzLnBhcnNlU3RyaW5nKGV4cHJlc3Npb24ubGVmdCkgKyB0aGlzLnBhcnNlU3RyaW5nKGV4cHJlc3Npb24ucmlnaHQpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgXCJMaXRlcmFsXCI6XHJcblx0XHRcdHJldHVybiBleHByZXNzaW9uLnZhbHVlICsgXCJcIjtcclxuXHR9XHJcblx0dGhyb3cgbmV3IEVycm9yKGV4cHJlc3Npb24udHlwZSArIFwiIGlzIG5vdCBzdXBwb3J0ZWQgYXMgcGFyYW1ldGVyIGZvciByZXF1aXJlXCIpO1xyXG59O1xyXG5cclxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNhbGN1bGF0ZWRTdHJpbmcgPSBmdW5jdGlvbiBwYXJzZUNhbGN1bGF0ZWRTdHJpbmcoZXhwcmVzc2lvbikge1xyXG5cdHN3aXRjaChleHByZXNzaW9uLnR5cGUpIHtcclxuXHRcdGNhc2UgXCJCaW5hcnlFeHByZXNzaW9uXCI6XHJcblx0XHRcdGlmKGV4cHJlc3Npb24ub3BlcmF0b3IgPT09IFwiK1wiKSB7XHJcblx0XHRcdFx0dmFyIGxlZnQgPSB0aGlzLnBhcnNlQ2FsY3VsYXRlZFN0cmluZyhleHByZXNzaW9uLmxlZnQpO1xyXG5cdFx0XHRcdHZhciByaWdodCA9IHRoaXMucGFyc2VDYWxjdWxhdGVkU3RyaW5nKGV4cHJlc3Npb24ucmlnaHQpO1xyXG5cdFx0XHRcdGlmKGxlZnQuY29kZSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdFx0cmFuZ2U6IGxlZnQucmFuZ2UsXHJcblx0XHRcdFx0XHRcdHZhbHVlOiBsZWZ0LnZhbHVlLFxyXG5cdFx0XHRcdFx0XHRjb2RlOiB0cnVlXHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdH0gZWxzZSBpZihyaWdodC5jb2RlKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0XHRyYW5nZTogW2xlZnQucmFuZ2VbMF0sIHJpZ2h0LnJhbmdlID8gcmlnaHQucmFuZ2VbMV0gOiBsZWZ0LnJhbmdlWzFdXSxcclxuXHRcdFx0XHRcdFx0dmFsdWU6IGxlZnQudmFsdWUgKyByaWdodC52YWx1ZSxcclxuXHRcdFx0XHRcdFx0Y29kZTogdHJ1ZVxyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdFx0cmFuZ2U6IFtsZWZ0LnJhbmdlWzBdLCByaWdodC5yYW5nZVsxXV0sXHJcblx0XHRcdFx0XHRcdHZhbHVlOiBsZWZ0LnZhbHVlICsgcmlnaHQudmFsdWVcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOlxyXG5cdFx0XHR2YXIgY29uc2VxdWVudCA9IHRoaXMucGFyc2VDYWxjdWxhdGVkU3RyaW5nKGV4cHJlc3Npb24uY29uc2VxdWVudCk7XHJcblx0XHRcdHZhciBhbHRlcm5hdGUgPSB0aGlzLnBhcnNlQ2FsY3VsYXRlZFN0cmluZyhleHByZXNzaW9uLmFsdGVybmF0ZSk7XHJcblx0XHRcdHZhciBpdGVtcyA9IFtdO1xyXG5cdFx0XHRpZihjb25zZXF1ZW50LmNvbmRpdGlvbmFsKVxyXG5cdFx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGl0ZW1zLCBjb25zZXF1ZW50LmNvbmRpdGlvbmFsKTtcclxuXHRcdFx0ZWxzZSBpZighY29uc2VxdWVudC5jb2RlKVxyXG5cdFx0XHRcdGl0ZW1zLnB1c2goY29uc2VxdWVudCk7XHJcblx0XHRcdGVsc2UgYnJlYWs7XHJcblx0XHRcdGlmKGFsdGVybmF0ZS5jb25kaXRpb25hbClcclxuXHRcdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShpdGVtcywgYWx0ZXJuYXRlLmNvbmRpdGlvbmFsKTtcclxuXHRcdFx0ZWxzZSBpZighYWx0ZXJuYXRlLmNvZGUpXHJcblx0XHRcdFx0aXRlbXMucHVzaChhbHRlcm5hdGUpO1xyXG5cdFx0XHRlbHNlIGJyZWFrO1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHZhbHVlOiBcIlwiLFxyXG5cdFx0XHRcdGNvZGU6IHRydWUsXHJcblx0XHRcdFx0Y29uZGl0aW9uYWw6IGl0ZW1zXHJcblx0XHRcdH07XHJcblx0XHRjYXNlIFwiTGl0ZXJhbFwiOlxyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHJhbmdlOiBleHByZXNzaW9uLnJhbmdlLFxyXG5cdFx0XHRcdHZhbHVlOiBleHByZXNzaW9uLnZhbHVlICsgXCJcIlxyXG5cdFx0XHR9O1xyXG5cdH1cclxuXHRyZXR1cm4ge1xyXG5cdFx0dmFsdWU6IFwiXCIsXHJcblx0XHRjb2RlOiB0cnVlXHJcblx0fTtcclxufTtcclxuXHJcbltcInBhcnNlU3RyaW5nXCIsIFwicGFyc2VDYWxjdWxhdGVkU3RyaW5nXCJdLmZvckVhY2goZnVuY3Rpb24oZm4pIHtcclxuXHRQYXJzZXIucHJvdG90eXBlW2ZuICsgXCJBcnJheVwiXSA9IGZ1bmN0aW9uIHBhcnNlWFhYQXJyYXkoZXhwcmVzc2lvbikge1xyXG5cdFx0c3dpdGNoKGV4cHJlc3Npb24udHlwZSkge1xyXG5cdFx0XHRjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XHJcblx0XHRcdFx0dmFyIGFyciA9IFtdO1xyXG5cdFx0XHRcdGlmKGV4cHJlc3Npb24uZWxlbWVudHMpXHJcblx0XHRcdFx0XHRleHByZXNzaW9uLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZXhwcikge1xyXG5cdFx0XHRcdFx0XHRhcnIucHVzaCh0aGlzW2ZuXShleHByKSk7XHJcblx0XHRcdFx0XHR9LCB0aGlzKTtcclxuXHRcdFx0XHRyZXR1cm4gYXJyO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIFt0aGlzW2ZuXShleHByZXNzaW9uKV07XHJcblx0fTtcclxufSk7XHJcblxyXG52YXIgUE9TU0lCTEVfQVNUX09QVElPTlMgPSBbe1xyXG5cdHJhbmdlczogdHJ1ZSxcclxuXHRsb2NhdGlvbnM6IHRydWUsXHJcblx0ZWNtYVZlcnNpb246IDYsXHJcblx0c291cmNlVHlwZTogXCJtb2R1bGVcIlxyXG59LCB7XHJcblx0cmFuZ2VzOiB0cnVlLFxyXG5cdGxvY2F0aW9uczogdHJ1ZSxcclxuXHRlY21hVmVyc2lvbjogNixcclxuXHRzb3VyY2VUeXBlOiBcInNjcmlwdFwiXHJcbn1dXHJcblxyXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2Uoc291cmNlLCBpbml0aWFsU3RhdGUpIHtcclxuXHR2YXIgYXN0O1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBQT1NTSUJMRV9BU1RfT1BUSU9OUy5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYoIWFzdCkge1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGFzdCA9IGFjb3JuLnBhcnNlKHNvdXJjZSwgUE9TU0lCTEVfQVNUX09QVElPTlNbaV0pO1xyXG5cdFx0XHR9IGNhdGNoKGUpIHtcclxuXHRcdFx0XHQvLyBpZ25vcmUgdGhlIGVycm9yXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0aWYoIWFzdCkge1xyXG5cdFx0Ly8gZm9yIHRoZSBlcnJvclxyXG5cdFx0YXN0ID0gYWNvcm4ucGFyc2Uoc291cmNlLCB7XHJcblx0XHRcdHJhbmdlczogdHJ1ZSxcclxuXHRcdFx0bG9jYXRpb25zOiB0cnVlLFxyXG5cdFx0XHRlY21hVmVyc2lvbjogNixcclxuXHRcdFx0c291cmNlVHlwZTogXCJtb2R1bGVcIlxyXG5cdFx0fSk7XHJcblx0fVxyXG5cdGlmKCFhc3QgfHwgdHlwZW9mIGFzdCAhPT0gXCJvYmplY3RcIilcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIlNvdXJjZSBjb3VsZG4ndCBiZSBwYXJzZWRcIik7XHJcblx0dmFyIG9sZFNjb3BlID0gdGhpcy5zY29wZTtcclxuXHR2YXIgb2xkU3RhdGUgPSB0aGlzLnN0YXRlO1xyXG5cdHRoaXMuc2NvcGUgPSB7XHJcblx0XHRpblRyeTogZmFsc2UsXHJcblx0XHRkZWZpbml0aW9uczogW10sXHJcblx0XHRyZW5hbWVzOiB7fVxyXG5cdH07XHJcblx0dmFyIHN0YXRlID0gdGhpcy5zdGF0ZSA9IGluaXRpYWxTdGF0ZSB8fCB7fTtcclxuXHRpZih0aGlzLmFwcGx5UGx1Z2luc0JhaWxSZXN1bHQoXCJwcm9ncmFtXCIsIGFzdCkgPT09IHVuZGVmaW5lZClcclxuXHRcdHRoaXMud2Fsa1N0YXRlbWVudHMoYXN0LmJvZHkpO1xyXG5cdHRoaXMuc2NvcGUgPSBvbGRTY29wZTtcclxuXHR0aGlzLnN0YXRlID0gb2xkU3RhdGU7XHJcblx0cmV0dXJuIHN0YXRlO1xyXG59O1xyXG5cclxuUGFyc2VyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlKHNvdXJjZSkge1xyXG5cdHZhciBhc3QgPSBhY29ybi5wYXJzZShcIihcIiArIHNvdXJjZSArIFwiKVwiLCB7XHJcblx0XHRyYW5nZXM6IHRydWUsXHJcblx0XHRsb2NhdGlvbnM6IHRydWUsXHJcblx0XHRlY21hVmVyc2lvbjogNixcclxuXHRcdHNvdXJjZVR5cGU6IFwibW9kdWxlXCJcclxuXHR9KTtcclxuXHRpZighYXN0IHx8IHR5cGVvZiBhc3QgIT09IFwib2JqZWN0XCIgfHwgYXN0LnR5cGUgIT09IFwiUHJvZ3JhbVwiKVxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiZXZhbHVhdGU6IFNvdXJjZSBjb3VsZG4ndCBiZSBwYXJzZWRcIik7XHJcblx0aWYoYXN0LmJvZHkubGVuZ3RoICE9PSAxIHx8IGFzdC5ib2R5WzBdLnR5cGUgIT09IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiKVxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiZXZhbHVhdGU6IFNvdXJjZSBpcyBub3QgYSBleHByZXNzaW9uXCIpO1xyXG5cdHJldHVybiB0aGlzLmV2YWx1YXRlRXhwcmVzc2lvbihhc3QuYm9keVswXS5leHByZXNzaW9uKTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9QYXJzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKGdsb2JhbC5hY29ybiA9IGdsb2JhbC5hY29ybiB8fCB7fSkpKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFJlc2VydmVkIHdvcmQgbGlzdHMgZm9yIHZhcmlvdXMgZGlhbGVjdHMgb2YgdGhlIGxhbmd1YWdlXG5cbiAgdmFyIHJlc2VydmVkV29yZHMgPSB7XG4gICAgMzogXCJhYnN0cmFjdCBib29sZWFuIGJ5dGUgY2hhciBjbGFzcyBkb3VibGUgZW51bSBleHBvcnQgZXh0ZW5kcyBmaW5hbCBmbG9hdCBnb3RvIGltcGxlbWVudHMgaW1wb3J0IGludCBpbnRlcmZhY2UgbG9uZyBuYXRpdmUgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc2hvcnQgc3RhdGljIHN1cGVyIHN5bmNocm9uaXplZCB0aHJvd3MgdHJhbnNpZW50IHZvbGF0aWxlXCIsXG4gICAgNTogXCJjbGFzcyBlbnVtIGV4dGVuZHMgc3VwZXIgY29uc3QgZXhwb3J0IGltcG9ydFwiLFxuICAgIDY6IFwiZW51bVwiLFxuICAgIDc6IFwiZW51bVwiLFxuICAgIHN0cmljdDogXCJpbXBsZW1lbnRzIGludGVyZmFjZSBsZXQgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc3RhdGljIHlpZWxkXCIsXG4gICAgc3RyaWN0QmluZDogXCJldmFsIGFyZ3VtZW50c1wiXG4gIH1cblxuICAvLyBBbmQgdGhlIGtleXdvcmRzXG5cbiAgdmFyIGVjbWE1QW5kTGVzc0tleXdvcmRzID0gXCJicmVhayBjYXNlIGNhdGNoIGNvbnRpbnVlIGRlYnVnZ2VyIGRlZmF1bHQgZG8gZWxzZSBmaW5hbGx5IGZvciBmdW5jdGlvbiBpZiByZXR1cm4gc3dpdGNoIHRocm93IHRyeSB2YXIgd2hpbGUgd2l0aCBudWxsIHRydWUgZmFsc2UgaW5zdGFuY2VvZiB0eXBlb2Ygdm9pZCBkZWxldGUgbmV3IGluIHRoaXNcIlxuXG4gIHZhciBrZXl3b3JkcyA9IHtcbiAgICA1OiBlY21hNUFuZExlc3NLZXl3b3JkcyxcbiAgICA2OiBlY21hNUFuZExlc3NLZXl3b3JkcyArIFwiIGNvbnN0IGNsYXNzIGV4dGVuZHMgZXhwb3J0IGltcG9ydCBzdXBlclwiXG4gIH1cblxuICAvLyAjIyBDaGFyYWN0ZXIgY2F0ZWdvcmllc1xuXG4gIC8vIEJpZyB1Z2x5IHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBtYXRjaCBjaGFyYWN0ZXJzIGluIHRoZVxuICAvLyB3aGl0ZXNwYWNlLCBpZGVudGlmaWVyLCBhbmQgaWRlbnRpZmllci1zdGFydCBjYXRlZ29yaWVzLiBUaGVzZVxuICAvLyBhcmUgb25seSBhcHBsaWVkIHdoZW4gYSBjaGFyYWN0ZXIgaXMgZm91bmQgdG8gYWN0dWFsbHkgaGF2ZSBhXG4gIC8vIGNvZGUgcG9pbnQgYWJvdmUgMTI4LlxuICAvLyBHZW5lcmF0ZWQgYnkgYGJpbi9nZW5lcmF0ZS1pZGVudGlmaWVyLXJlZ2V4LmpzYC5cblxuICB2YXIgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IFwiXFx4YWFcXHhiNVxceGJhXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyYzFcXHUwMmM2LVxcdTAyZDFcXHUwMmUwLVxcdTAyZTRcXHUwMmVjXFx1MDJlZVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3YS1cXHUwMzdkXFx1MDM3ZlxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTJmXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1ZDAtXFx1MDVlYVxcdTA1ZjAtXFx1MDVmMlxcdTA2MjAtXFx1MDY0YVxcdTA2NmVcXHUwNjZmXFx1MDY3MS1cXHUwNmQzXFx1MDZkNVxcdTA2ZTVcXHUwNmU2XFx1MDZlZVxcdTA2ZWZcXHUwNmZhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2NhLVxcdTA3ZWFcXHUwN2Y0XFx1MDdmNVxcdTA3ZmFcXHUwODAwLVxcdTA4MTVcXHUwODFhXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOGEwLVxcdTA4YjRcXHUwOGI2LVxcdTA4YmRcXHUwOTA0LVxcdTA5MzlcXHUwOTNkXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Y1xcdTA5OGZcXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmRcXHUwOWNlXFx1MDlkY1xcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWYwXFx1MDlmMVxcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGE1OS1cXHUwYTVjXFx1MGE1ZVxcdTBhNzItXFx1MGE3NFxcdTBhODUtXFx1MGE4ZFxcdTBhOGYtXFx1MGE5MVxcdTBhOTMtXFx1MGFhOFxcdTBhYWEtXFx1MGFiMFxcdTBhYjJcXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwXFx1MGFlMVxcdTBhZjlcXHUwYjA1LVxcdTBiMGNcXHUwYjBmXFx1MGIxMFxcdTBiMTMtXFx1MGIyOFxcdTBiMmEtXFx1MGIzMFxcdTBiMzJcXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzZFxcdTBiNWNcXHUwYjVkXFx1MGI1Zi1cXHUwYjYxXFx1MGI3MVxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5XFx1MGI5YVxcdTBiOWNcXHUwYjllXFx1MGI5ZlxcdTBiYTNcXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJkMFxcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzOVxcdTBjM2RcXHUwYzU4LVxcdTBjNWFcXHUwYzYwXFx1MGM2MVxcdTBjODBcXHUwYzg1LVxcdTBjOGNcXHUwYzhlLVxcdTBjOTBcXHUwYzkyLVxcdTBjYThcXHUwY2FhLVxcdTBjYjNcXHUwY2I1LVxcdTBjYjlcXHUwY2JkXFx1MGNkZVxcdTBjZTBcXHUwY2UxXFx1MGNmMVxcdTBjZjJcXHUwZDA1LVxcdTBkMGNcXHUwZDBlLVxcdTBkMTBcXHUwZDEyLVxcdTBkM2FcXHUwZDNkXFx1MGQ0ZVxcdTBkNTQtXFx1MGQ1NlxcdTBkNWYtXFx1MGQ2MVxcdTBkN2EtXFx1MGQ3ZlxcdTBkODUtXFx1MGQ5NlxcdTBkOWEtXFx1MGRiMVxcdTBkYjMtXFx1MGRiYlxcdTBkYmRcXHUwZGMwLVxcdTBkYzZcXHUwZTAxLVxcdTBlMzBcXHUwZTMyXFx1MGUzM1xcdTBlNDAtXFx1MGU0NlxcdTBlODFcXHUwZTgyXFx1MGU4NFxcdTBlODdcXHUwZTg4XFx1MGU4YVxcdTBlOGRcXHUwZTk0LVxcdTBlOTdcXHUwZTk5LVxcdTBlOWZcXHUwZWExLVxcdTBlYTNcXHUwZWE1XFx1MGVhN1xcdTBlYWFcXHUwZWFiXFx1MGVhZC1cXHUwZWIwXFx1MGViMlxcdTBlYjNcXHUwZWJkXFx1MGVjMC1cXHUwZWM0XFx1MGVjNlxcdTBlZGMtXFx1MGVkZlxcdTBmMDBcXHUwZjQwLVxcdTBmNDdcXHUwZjQ5LVxcdTBmNmNcXHUwZjg4LVxcdTBmOGNcXHUxMDAwLVxcdTEwMmFcXHUxMDNmXFx1MTA1MC1cXHUxMDU1XFx1MTA1YS1cXHUxMDVkXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2ZS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4ZVxcdTEwYTAtXFx1MTBjNVxcdTEwYzdcXHUxMGNkXFx1MTBkMC1cXHUxMGZhXFx1MTBmYy1cXHUxMjQ4XFx1MTI0YS1cXHUxMjRkXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNWEtXFx1MTI1ZFxcdTEyNjAtXFx1MTI4OFxcdTEyOGEtXFx1MTI4ZFxcdTEyOTAtXFx1MTJiMFxcdTEyYjItXFx1MTJiNVxcdTEyYjgtXFx1MTJiZVxcdTEyYzBcXHUxMmMyLVxcdTEyYzVcXHUxMmM4LVxcdTEyZDZcXHUxMmQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNWFcXHUxMzgwLVxcdTEzOGZcXHUxM2EwLVxcdTEzZjVcXHUxM2Y4LVxcdTEzZmRcXHUxNDAxLVxcdTE2NmNcXHUxNjZmLVxcdTE2N2ZcXHUxNjgxLVxcdTE2OWFcXHUxNmEwLVxcdTE2ZWFcXHUxNmVlLVxcdTE2ZjhcXHUxNzAwLVxcdTE3MGNcXHUxNzBlLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NmNcXHUxNzZlLVxcdTE3NzBcXHUxNzgwLVxcdTE3YjNcXHUxN2Q3XFx1MTdkY1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThhOFxcdTE4YWFcXHUxOGIwLVxcdTE4ZjVcXHUxOTAwLVxcdTE5MWVcXHUxOTUwLVxcdTE5NmRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5YWJcXHUxOWIwLVxcdTE5YzlcXHUxYTAwLVxcdTFhMTZcXHUxYTIwLVxcdTFhNTRcXHUxYWE3XFx1MWIwNS1cXHUxYjMzXFx1MWI0NS1cXHUxYjRiXFx1MWI4My1cXHUxYmEwXFx1MWJhZVxcdTFiYWZcXHUxYmJhLVxcdTFiZTVcXHUxYzAwLVxcdTFjMjNcXHUxYzRkLVxcdTFjNGZcXHUxYzVhLVxcdTFjN2RcXHUxYzgwLVxcdTFjODhcXHUxY2U5LVxcdTFjZWNcXHUxY2VlLVxcdTFjZjFcXHUxY2Y1XFx1MWNmNlxcdTFkMDAtXFx1MWRiZlxcdTFlMDAtXFx1MWYxNVxcdTFmMTgtXFx1MWYxZFxcdTFmMjAtXFx1MWY0NVxcdTFmNDgtXFx1MWY0ZFxcdTFmNTAtXFx1MWY1N1xcdTFmNTlcXHUxZjViXFx1MWY1ZFxcdTFmNWYtXFx1MWY3ZFxcdTFmODAtXFx1MWZiNFxcdTFmYjYtXFx1MWZiY1xcdTFmYmVcXHUxZmMyLVxcdTFmYzRcXHUxZmM2LVxcdTFmY2NcXHUxZmQwLVxcdTFmZDNcXHUxZmQ2LVxcdTFmZGJcXHUxZmUwLVxcdTFmZWNcXHUxZmYyLVxcdTFmZjRcXHUxZmY2LVxcdTFmZmNcXHUyMDcxXFx1MjA3ZlxcdTIwOTAtXFx1MjA5Y1xcdTIxMDJcXHUyMTA3XFx1MjEwYS1cXHUyMTEzXFx1MjExNVxcdTIxMTgtXFx1MjExZFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMmEtXFx1MjEzOVxcdTIxM2MtXFx1MjEzZlxcdTIxNDUtXFx1MjE0OVxcdTIxNGVcXHUyMTYwLVxcdTIxODhcXHUyYzAwLVxcdTJjMmVcXHUyYzMwLVxcdTJjNWVcXHUyYzYwLVxcdTJjZTRcXHUyY2ViLVxcdTJjZWVcXHUyY2YyXFx1MmNmM1xcdTJkMDAtXFx1MmQyNVxcdTJkMjdcXHUyZDJkXFx1MmQzMC1cXHUyZDY3XFx1MmQ2ZlxcdTJkODAtXFx1MmQ5NlxcdTJkYTAtXFx1MmRhNlxcdTJkYTgtXFx1MmRhZVxcdTJkYjAtXFx1MmRiNlxcdTJkYjgtXFx1MmRiZVxcdTJkYzAtXFx1MmRjNlxcdTJkYzgtXFx1MmRjZVxcdTJkZDAtXFx1MmRkNlxcdTJkZDgtXFx1MmRkZVxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzY1xcdTMwNDEtXFx1MzA5NlxcdTMwOWItXFx1MzA5ZlxcdTMwYTEtXFx1MzBmYVxcdTMwZmMtXFx1MzBmZlxcdTMxMDUtXFx1MzEyZFxcdTMxMzEtXFx1MzE4ZVxcdTMxYTAtXFx1MzFiYVxcdTMxZjAtXFx1MzFmZlxcdTM0MDAtXFx1NGRiNVxcdTRlMDAtXFx1OWZkNVxcdWEwMDAtXFx1YTQ4Y1xcdWE0ZDAtXFx1YTRmZFxcdWE1MDAtXFx1YTYwY1xcdWE2MTAtXFx1YTYxZlxcdWE2MmFcXHVhNjJiXFx1YTY0MC1cXHVhNjZlXFx1YTY3Zi1cXHVhNjlkXFx1YTZhMC1cXHVhNmVmXFx1YTcxNy1cXHVhNzFmXFx1YTcyMi1cXHVhNzg4XFx1YTc4Yi1cXHVhN2FlXFx1YTdiMC1cXHVhN2I3XFx1YTdmNy1cXHVhODAxXFx1YTgwMy1cXHVhODA1XFx1YTgwNy1cXHVhODBhXFx1YTgwYy1cXHVhODIyXFx1YTg0MC1cXHVhODczXFx1YTg4Mi1cXHVhOGIzXFx1YThmMi1cXHVhOGY3XFx1YThmYlxcdWE4ZmRcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YTllMC1cXHVhOWU0XFx1YTllNi1cXHVhOWVmXFx1YTlmYS1cXHVhOWZlXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhN2UtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWIzMC1cXHVhYjVhXFx1YWI1Yy1cXHVhYjY1XFx1YWI3MC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCJcbiAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gXCJcXHUyMDBjXFx1MjAwZFxceGI3XFx1MDMwMC1cXHUwMzZmXFx1MDM4N1xcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2NGItXFx1MDY2OVxcdTA2NzBcXHUwNmQ2LVxcdTA2ZGNcXHUwNmRmLVxcdTA2ZTRcXHUwNmU3XFx1MDZlOFxcdTA2ZWEtXFx1MDZlZFxcdTA2ZjAtXFx1MDZmOVxcdTA3MTFcXHUwNzMwLVxcdTA3NGFcXHUwN2E2LVxcdTA3YjBcXHUwN2MwLVxcdTA3YzlcXHUwN2ViLVxcdTA3ZjNcXHUwODE2LVxcdTA4MTlcXHUwODFiLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MmRcXHUwODU5LVxcdTA4NWJcXHUwOGQ0LVxcdTA4ZTFcXHUwOGUzLVxcdTA5MDNcXHUwOTNhLVxcdTA5M2NcXHUwOTNlLVxcdTA5NGZcXHUwOTUxLVxcdTA5NTdcXHUwOTYyXFx1MDk2M1xcdTA5NjYtXFx1MDk2ZlxcdTA5ODEtXFx1MDk4M1xcdTA5YmNcXHUwOWJlLVxcdTA5YzRcXHUwOWM3XFx1MDljOFxcdTA5Y2ItXFx1MDljZFxcdTA5ZDdcXHUwOWUyXFx1MDllM1xcdTA5ZTYtXFx1MDllZlxcdTBhMDEtXFx1MGEwM1xcdTBhM2NcXHUwYTNlLVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTY2LVxcdTBhNzFcXHUwYTc1XFx1MGE4MS1cXHUwYTgzXFx1MGFiY1xcdTBhYmUtXFx1MGFjNVxcdTBhYzctXFx1MGFjOVxcdTBhY2ItXFx1MGFjZFxcdTBhZTJcXHUwYWUzXFx1MGFlNi1cXHUwYWVmXFx1MGIwMS1cXHUwYjAzXFx1MGIzY1xcdTBiM2UtXFx1MGI0NFxcdTBiNDdcXHUwYjQ4XFx1MGI0Yi1cXHUwYjRkXFx1MGI1NlxcdTBiNTdcXHUwYjYyXFx1MGI2M1xcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMC1cXHUwYzAzXFx1MGMzZS1cXHUwYzQ0XFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzYyXFx1MGM2M1xcdTBjNjYtXFx1MGM2ZlxcdTBjODEtXFx1MGM4M1xcdTBjYmNcXHUwY2JlLVxcdTBjYzRcXHUwY2M2LVxcdTBjYzhcXHUwY2NhLVxcdTBjY2RcXHUwY2Q1XFx1MGNkNlxcdTBjZTJcXHUwY2UzXFx1MGNlNi1cXHUwY2VmXFx1MGQwMS1cXHUwZDAzXFx1MGQzZS1cXHUwZDQ0XFx1MGQ0Ni1cXHUwZDQ4XFx1MGQ0YS1cXHUwZDRkXFx1MGQ1N1xcdTBkNjJcXHUwZDYzXFx1MGQ2Ni1cXHUwZDZmXFx1MGQ4MlxcdTBkODNcXHUwZGNhXFx1MGRjZi1cXHUwZGQ0XFx1MGRkNlxcdTBkZDgtXFx1MGRkZlxcdTBkZTYtXFx1MGRlZlxcdTBkZjJcXHUwZGYzXFx1MGUzMVxcdTBlMzQtXFx1MGUzYVxcdTBlNDctXFx1MGU0ZVxcdTBlNTAtXFx1MGU1OVxcdTBlYjFcXHUwZWI0LVxcdTBlYjlcXHUwZWJiXFx1MGViY1xcdTBlYzgtXFx1MGVjZFxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGYzZVxcdTBmM2ZcXHUwZjcxLVxcdTBmODRcXHUwZjg2XFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJiLVxcdTEwM2VcXHUxMDQwLVxcdTEwNDlcXHUxMDU2LVxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDYyLVxcdTEwNjRcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxMzY5LVxcdTEzNzFcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdiNC1cXHUxN2QzXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MTAtXFx1MTgxOVxcdTE4YTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTQ2LVxcdTE5NGZcXHUxOWQwLVxcdTE5ZGFcXHUxYTE3LVxcdTFhMWJcXHUxYTU1LVxcdTFhNWVcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYWIwLVxcdTFhYmRcXHUxYjAwLVxcdTFiMDRcXHUxYjM0LVxcdTFiNDRcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYjgwLVxcdTFiODJcXHUxYmExLVxcdTFiYWRcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzI0LVxcdTFjMzdcXHUxYzQwLVxcdTFjNDlcXHUxYzUwLVxcdTFjNTlcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZThcXHUxY2VkXFx1MWNmMi1cXHUxY2Y0XFx1MWNmOFxcdTFjZjlcXHUxZGMwLVxcdTFkZjVcXHUxZGZiLVxcdTFkZmZcXHUyMDNmXFx1MjA0MFxcdTIwNTRcXHUyMGQwLVxcdTIwZGNcXHUyMGUxXFx1MjBlNS1cXHUyMGYwXFx1MmNlZi1cXHUyY2YxXFx1MmQ3ZlxcdTJkZTAtXFx1MmRmZlxcdTMwMmEtXFx1MzAyZlxcdTMwOTlcXHUzMDlhXFx1YTYyMC1cXHVhNjI5XFx1YTY2ZlxcdWE2NzQtXFx1YTY3ZFxcdWE2OWVcXHVhNjlmXFx1YTZmMFxcdWE2ZjFcXHVhODAyXFx1YTgwNlxcdWE4MGJcXHVhODIzLVxcdWE4MjdcXHVhODgwXFx1YTg4MVxcdWE4YjQtXFx1YThjNVxcdWE4ZDAtXFx1YThkOVxcdWE4ZTAtXFx1YThmMVxcdWE5MDAtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5NDctXFx1YTk1M1xcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWE5ZDAtXFx1YTlkOVxcdWE5ZTVcXHVhOWYwLVxcdWE5ZjlcXHVhYTI5LVxcdWFhMzZcXHVhYTQzXFx1YWE0Y1xcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiLVxcdWFhN2RcXHVhYWIwXFx1YWFiMi1cXHVhYWI0XFx1YWFiN1xcdWFhYjhcXHVhYWJlXFx1YWFiZlxcdWFhYzFcXHVhYWViLVxcdWFhZWZcXHVhYWY1XFx1YWFmNlxcdWFiZTMtXFx1YWJlYVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1ZmIxZVxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyZlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlwiXG5cbiAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIilcbiAgdmFyIG5vbkFTQ0lJaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoXCJbXCIgKyBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzICsgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgKyBcIl1cIilcblxuICBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBudWxsXG5cbiAgLy8gVGhlc2UgYXJlIGEgcnVuLWxlbmd0aCBhbmQgb2Zmc2V0IGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4gIC8vID4weGZmZmYgY29kZSBwb2ludHMgdGhhdCBhcmUgYSB2YWxpZCBwYXJ0IG9mIGlkZW50aWZpZXJzLiBUaGVcbiAgLy8gb2Zmc2V0IHN0YXJ0cyBhdCAweDEwMDAwLCBhbmQgZWFjaCBwYWlyIG9mIG51bWJlcnMgcmVwcmVzZW50cyBhblxuICAvLyBvZmZzZXQgdG8gdGhlIG5leHQgcmFuZ2UsIGFuZCB0aGVuIGEgc2l6ZSBvZiB0aGUgcmFuZ2UuIFRoZXkgd2VyZVxuICAvLyBnZW5lcmF0ZWQgYnkgYmluL2dlbmVyYXRlLWlkZW50aWZpZXItcmVnZXguanNcbiAgdmFyIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzID0gWzAsMTEsMiwyNSwyLDE4LDIsMSwyLDE0LDMsMTMsMzUsMTIyLDcwLDUyLDI2OCwyOCw0LDQ4LDQ4LDMxLDE3LDI2LDYsMzcsMTEsMjksMywzNSw1LDcsMiw0LDQzLDE1NywxOSwzNSw1LDM1LDUsMzksOSw1MSwxNTcsMzEwLDEwLDIxLDExLDcsMTUzLDUsMywwLDIsNDMsMiwxLDQsMCwzLDIyLDExLDIyLDEwLDMwLDY2LDE4LDIsMSwxMSwyMSwxMSwyNSw3MSw1NSw3LDEsNjUsMCwxNiwzLDIsMiwyLDI2LDQ1LDI4LDQsMjgsMzYsNywyLDI3LDI4LDUzLDExLDIxLDExLDE4LDE0LDE3LDExMSw3Miw1Niw1MCwxNCw1MCw3ODUsNTIsNzYsNDQsMzMsMjQsMjcsMzUsNDIsMzQsNCwwLDEzLDQ3LDE1LDMsMjIsMCwyLDAsMzYsMTcsMiwyNCw4NSw2LDIsMCwyLDMsMiwxNCwyLDksOCw0NiwzOSw3LDMsMSwzLDIxLDIsNiwyLDEsMiw0LDQsMCwxOSwwLDEzLDQsMTU5LDUyLDE5LDMsNTQsNDcsMjEsMSwyLDAsMTg1LDQ2LDQyLDMsMzcsNDcsMjEsMCw2MCw0Miw4NiwyNSwzOTEsNjMsMzIsMCw0NDksNTYsMjY0LDgsMiwzNiwxOCwwLDUwLDI5LDg4MSw5MjEsMTAzLDExMCwxOCwxOTUsMjc0OSwxMDcwLDQwNTAsNTgyLDg2MzQsNTY4LDgsMzAsMTE0LDI5LDE5LDQ3LDE3LDMsMzIsMjAsNiwxOCw4ODEsNjgsMTIsMCw2NywxMiw2NSwwLDMyLDYxMjQsMjAsNzU0LDk0ODYsMSwzMDcxLDEwNiw2LDEyLDQsOCw4LDksNTk5MSw4NCwyLDcwLDIsMSwzLDAsMywxLDMsMywyLDExLDIsMCwyLDYsMiw2NCwyLDMsMyw3LDIsNiwyLDI3LDIsMywyLDQsMiwwLDQsNiwyLDMzOSwzLDI0LDIsMjQsMiwzMCwyLDI0LDIsMzAsMiwyNCwyLDMwLDIsMjQsMiwzMCwyLDI0LDIsNyw0MTQ5LDE5Niw2MCw2NywxMjEzLDMsMiwyNiwyLDEsMiwwLDMsMCwyLDksMiwzLDIsMCwyLDAsNywwLDUsMCwyLDAsMiwwLDIsMiwyLDEsMiwwLDMsMCwyLDAsMiwwLDIsMCwyLDAsMiwxLDIsMCwzLDMsMiw2LDIsMywyLDMsMiwwLDIsOSwyLDE2LDYsMiwyLDQsMiwxNiw0NDIxLDQyNzEwLDQyLDQxNDgsMTIsMjIxLDMsNTc2MSwxMDU5MSw1NDFdXG4gIHZhciBhc3RyYWxJZGVudGlmaWVyQ29kZXMgPSBbNTA5LDAsMjI3LDAsMTUwLDQsMjk0LDksMTM2OCwyLDIsMSw2LDMsNDEsMiw1LDAsMTY2LDEsMTMwNiwyLDU0LDE0LDMyLDksMTYsMyw0NiwxMCw1NCw5LDcsMiwzNywxMywyLDksNTIsMCwxMywyLDQ5LDEzLDEwLDIsNCw5LDgzLDExLDcsMCwxNjEsMTEsNiw5LDcsMyw1NywwLDIsNiwzLDEsMywyLDEwLDAsMTEsMSwzLDYsNCw0LDE5MywxNywxMCw5LDg3LDE5LDEzLDksMjE0LDYsMyw4LDI4LDEsODMsMTYsMTYsOSw4MiwxMiw5LDksODQsMTQsNSw5LDQyMyw5LDgzOCw3LDIsNywxNyw5LDU3LDIxLDIsMTMsMTk4ODIsOSwxMzUsNCw2MCw2LDI2LDksMTAxNiw0NSwxNywzLDE5NzIzLDEsNTMxOSw0LDQsNSw5LDcsMyw2LDMxLDMsMTQ5LDIsMTQxOCw0OSw1MTMsNTQsNSw0OSw5LDAsMTUsMCwyMyw0LDIsMTQsMTM2MSw2LDIsMTYsMyw2LDIsMSwyLDQsMjIxNCw2LDExMCw2LDYsOSw3OTI0ODcsMjM5XVxuXG4gIC8vIFRoaXMgaGFzIGEgY29tcGxleGl0eSBsaW5lYXIgdG8gdGhlIHZhbHVlIG9mIHRoZSBjb2RlLiBUaGVcbiAgLy8gYXNzdW1wdGlvbiBpcyB0aGF0IGxvb2tpbmcgdXAgYXN0cmFsIGlkZW50aWZpZXIgY2hhcmFjdGVycyBpc1xuICAvLyByYXJlLlxuICBmdW5jdGlvbiBpc0luQXN0cmFsU2V0KGNvZGUsIHNldCkge1xuICAgIHZhciBwb3MgPSAweDEwMDAwXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHBvcyArPSBzZXRbaV1cbiAgICAgIGlmIChwb3MgPiBjb2RlKSByZXR1cm4gZmFsc2VcbiAgICAgIHBvcyArPSBzZXRbaSArIDFdXG4gICAgICBpZiAocG9zID49IGNvZGUpIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgLy8gVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gY2hhcmFjdGVyIGNvZGUgc3RhcnRzIGFuIGlkZW50aWZpZXIuXG5cbiAgZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY29kZSwgYXN0cmFsKSB7XG4gICAgaWYgKGNvZGUgPCA2NSkgcmV0dXJuIGNvZGUgPT09IDM2XG4gICAgaWYgKGNvZGUgPCA5MSkgcmV0dXJuIHRydWVcbiAgICBpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTVcbiAgICBpZiAoY29kZSA8IDEyMykgcmV0dXJuIHRydWVcbiAgICBpZiAoY29kZSA8PSAweGZmZmYpIHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKVxuICAgIGlmIChhc3RyYWwgPT09IGZhbHNlKSByZXR1cm4gZmFsc2VcbiAgICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcylcbiAgfVxuXG4gIC8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBpcyBwYXJ0IG9mIGFuIGlkZW50aWZpZXIuXG5cbiAgZnVuY3Rpb24gaXNJZGVudGlmaWVyQ2hhcihjb2RlLCBhc3RyYWwpIHtcbiAgICBpZiAoY29kZSA8IDQ4KSByZXR1cm4gY29kZSA9PT0gMzZcbiAgICBpZiAoY29kZSA8IDU4KSByZXR1cm4gdHJ1ZVxuICAgIGlmIChjb2RlIDwgNjUpIHJldHVybiBmYWxzZVxuICAgIGlmIChjb2RlIDwgOTEpIHJldHVybiB0cnVlXG4gICAgaWYgKGNvZGUgPCA5NykgcmV0dXJuIGNvZGUgPT09IDk1XG4gICAgaWYgKGNvZGUgPCAxMjMpIHJldHVybiB0cnVlXG4gICAgaWYgKGNvZGUgPD0gMHhmZmZmKSByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllci50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpXG4gICAgaWYgKGFzdHJhbCA9PT0gZmFsc2UpIHJldHVybiBmYWxzZVxuICAgIHJldHVybiBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzKSB8fCBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJDb2RlcylcbiAgfVxuXG4gIC8vICMjIFRva2VuIHR5cGVzXG5cbiAgLy8gVGhlIGFzc2lnbm1lbnQgb2YgZmluZS1ncmFpbmVkLCBpbmZvcm1hdGlvbi1jYXJyeWluZyB0eXBlIG9iamVjdHNcbiAgLy8gYWxsb3dzIHRoZSB0b2tlbml6ZXIgdG8gc3RvcmUgdGhlIGluZm9ybWF0aW9uIGl0IGhhcyBhYm91dCBhXG4gIC8vIHRva2VuIGluIGEgd2F5IHRoYXQgaXMgdmVyeSBjaGVhcCBmb3IgdGhlIHBhcnNlciB0byBsb29rIHVwLlxuXG4gIC8vIEFsbCB0b2tlbiB0eXBlIHZhcmlhYmxlcyBzdGFydCB3aXRoIGFuIHVuZGVyc2NvcmUsIHRvIG1ha2UgdGhlbVxuICAvLyBlYXN5IHRvIHJlY29nbml6ZS5cblxuICAvLyBUaGUgYGJlZm9yZUV4cHJgIHByb3BlcnR5IGlzIHVzZWQgdG8gZGlzYW1iaWd1YXRlIGJldHdlZW4gcmVndWxhclxuICAvLyBleHByZXNzaW9ucyBhbmQgZGl2aXNpb25zLiBJdCBpcyBzZXQgb24gYWxsIHRva2VuIHR5cGVzIHRoYXQgY2FuXG4gIC8vIGJlIGZvbGxvd2VkIGJ5IGFuIGV4cHJlc3Npb24gKHRodXMsIGEgc2xhc2ggYWZ0ZXIgdGhlbSB3b3VsZCBiZSBhXG4gIC8vIHJlZ3VsYXIgZXhwcmVzc2lvbikuXG4gIC8vXG4gIC8vIFRoZSBgc3RhcnRzRXhwcmAgcHJvcGVydHkgaXMgdXNlZCB0byBjaGVjayBpZiB0aGUgdG9rZW4gZW5kcyBhXG4gIC8vIGB5aWVsZGAgZXhwcmVzc2lvbi4gSXQgaXMgc2V0IG9uIGFsbCB0b2tlbiB0eXBlcyB0aGF0IGVpdGhlciBjYW5cbiAgLy8gZGlyZWN0bHkgc3RhcnQgYW4gZXhwcmVzc2lvbiAobGlrZSBhIHF1b3RhdGlvbiBtYXJrKSBvciBjYW5cbiAgLy8gY29udGludWUgYW4gZXhwcmVzc2lvbiAobGlrZSB0aGUgYm9keSBvZiBhIHN0cmluZykuXG4gIC8vXG4gIC8vIGBpc0xvb3BgIG1hcmtzIGEga2V5d29yZCBhcyBzdGFydGluZyBhIGxvb3AsIHdoaWNoIGlzIGltcG9ydGFudFxuICAvLyB0byBrbm93IHdoZW4gcGFyc2luZyBhIGxhYmVsLCBpbiBvcmRlciB0byBhbGxvdyBvciBkaXNhbGxvd1xuICAvLyBjb250aW51ZSBqdW1wcyB0byB0aGF0IGxhYmVsLlxuXG4gIHZhciBUb2tlblR5cGUgPSBmdW5jdGlvbiBUb2tlblR5cGUobGFiZWwsIGNvbmYpIHtcbiAgICBpZiAoIGNvbmYgPT09IHZvaWQgMCApIGNvbmYgPSB7fTtcblxuICAgIHRoaXMubGFiZWwgPSBsYWJlbFxuICAgIHRoaXMua2V5d29yZCA9IGNvbmYua2V5d29yZFxuICAgIHRoaXMuYmVmb3JlRXhwciA9ICEhY29uZi5iZWZvcmVFeHByXG4gICAgdGhpcy5zdGFydHNFeHByID0gISFjb25mLnN0YXJ0c0V4cHJcbiAgICB0aGlzLmlzTG9vcCA9ICEhY29uZi5pc0xvb3BcbiAgICB0aGlzLmlzQXNzaWduID0gISFjb25mLmlzQXNzaWduXG4gICAgdGhpcy5wcmVmaXggPSAhIWNvbmYucHJlZml4XG4gICAgdGhpcy5wb3N0Zml4ID0gISFjb25mLnBvc3RmaXhcbiAgICB0aGlzLmJpbm9wID0gY29uZi5iaW5vcCB8fCBudWxsXG4gICAgdGhpcy51cGRhdGVDb250ZXh0ID0gbnVsbFxuICB9O1xuXG4gIGZ1bmN0aW9uIGJpbm9wKG5hbWUsIHByZWMpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuVHlwZShuYW1lLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IHByZWN9KVxuICB9XG4gIHZhciBiZWZvcmVFeHByID0ge2JlZm9yZUV4cHI6IHRydWV9O1xuICB2YXIgc3RhcnRzRXhwciA9IHtzdGFydHNFeHByOiB0cnVlfTtcbiAgLy8gTWFwIGtleXdvcmQgbmFtZXMgdG8gdG9rZW4gdHlwZXMuXG5cbiAgdmFyIGtleXdvcmRUeXBlcyA9IHt9XG5cbiAgLy8gU3VjY2luY3QgZGVmaW5pdGlvbnMgb2Yga2V5d29yZCB0b2tlbiB0eXBlc1xuICBmdW5jdGlvbiBrdyhuYW1lLCBvcHRpb25zKSB7XG4gICAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgICBvcHRpb25zLmtleXdvcmQgPSBuYW1lXG4gICAgcmV0dXJuIGtleXdvcmRUeXBlc1tuYW1lXSA9IG5ldyBUb2tlblR5cGUobmFtZSwgb3B0aW9ucylcbiAgfVxuXG4gIHZhciB0dCA9IHtcbiAgICBudW06IG5ldyBUb2tlblR5cGUoXCJudW1cIiwgc3RhcnRzRXhwciksXG4gICAgcmVnZXhwOiBuZXcgVG9rZW5UeXBlKFwicmVnZXhwXCIsIHN0YXJ0c0V4cHIpLFxuICAgIHN0cmluZzogbmV3IFRva2VuVHlwZShcInN0cmluZ1wiLCBzdGFydHNFeHByKSxcbiAgICBuYW1lOiBuZXcgVG9rZW5UeXBlKFwibmFtZVwiLCBzdGFydHNFeHByKSxcbiAgICBlb2Y6IG5ldyBUb2tlblR5cGUoXCJlb2ZcIiksXG5cbiAgICAvLyBQdW5jdHVhdGlvbiB0b2tlbiB0eXBlcy5cbiAgICBicmFja2V0TDogbmV3IFRva2VuVHlwZShcIltcIiwge2JlZm9yZUV4cHI6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgICBicmFja2V0UjogbmV3IFRva2VuVHlwZShcIl1cIiksXG4gICAgYnJhY2VMOiBuZXcgVG9rZW5UeXBlKFwie1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIGJyYWNlUjogbmV3IFRva2VuVHlwZShcIn1cIiksXG4gICAgcGFyZW5MOiBuZXcgVG9rZW5UeXBlKFwiKFwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIHBhcmVuUjogbmV3IFRva2VuVHlwZShcIilcIiksXG4gICAgY29tbWE6IG5ldyBUb2tlblR5cGUoXCIsXCIsIGJlZm9yZUV4cHIpLFxuICAgIHNlbWk6IG5ldyBUb2tlblR5cGUoXCI7XCIsIGJlZm9yZUV4cHIpLFxuICAgIGNvbG9uOiBuZXcgVG9rZW5UeXBlKFwiOlwiLCBiZWZvcmVFeHByKSxcbiAgICBkb3Q6IG5ldyBUb2tlblR5cGUoXCIuXCIpLFxuICAgIHF1ZXN0aW9uOiBuZXcgVG9rZW5UeXBlKFwiP1wiLCBiZWZvcmVFeHByKSxcbiAgICBhcnJvdzogbmV3IFRva2VuVHlwZShcIj0+XCIsIGJlZm9yZUV4cHIpLFxuICAgIHRlbXBsYXRlOiBuZXcgVG9rZW5UeXBlKFwidGVtcGxhdGVcIiksXG4gICAgZWxsaXBzaXM6IG5ldyBUb2tlblR5cGUoXCIuLi5cIiwgYmVmb3JlRXhwciksXG4gICAgYmFja1F1b3RlOiBuZXcgVG9rZW5UeXBlKFwiYFwiLCBzdGFydHNFeHByKSxcbiAgICBkb2xsYXJCcmFjZUw6IG5ldyBUb2tlblR5cGUoXCIke1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuXG4gICAgLy8gT3BlcmF0b3JzLiBUaGVzZSBjYXJyeSBzZXZlcmFsIGtpbmRzIG9mIHByb3BlcnRpZXMgdG8gaGVscCB0aGVcbiAgICAvLyBwYXJzZXIgdXNlIHRoZW0gcHJvcGVybHkgKHRoZSBwcmVzZW5jZSBvZiB0aGVzZSBwcm9wZXJ0aWVzIGlzXG4gICAgLy8gd2hhdCBjYXRlZ29yaXplcyB0aGVtIGFzIG9wZXJhdG9ycykuXG4gICAgLy9cbiAgICAvLyBgYmlub3BgLCB3aGVuIHByZXNlbnQsIHNwZWNpZmllcyB0aGF0IHRoaXMgb3BlcmF0b3IgaXMgYSBiaW5hcnlcbiAgICAvLyBvcGVyYXRvciwgYW5kIHdpbGwgcmVmZXIgdG8gaXRzIHByZWNlZGVuY2UuXG4gICAgLy9cbiAgICAvLyBgcHJlZml4YCBhbmQgYHBvc3RmaXhgIG1hcmsgdGhlIG9wZXJhdG9yIGFzIGEgcHJlZml4IG9yIHBvc3RmaXhcbiAgICAvLyB1bmFyeSBvcGVyYXRvci5cbiAgICAvL1xuICAgIC8vIGBpc0Fzc2lnbmAgbWFya3MgYWxsIG9mIGA9YCwgYCs9YCwgYC09YCBldGNldGVyYSwgd2hpY2ggYWN0IGFzXG4gICAgLy8gYmluYXJ5IG9wZXJhdG9ycyB3aXRoIGEgdmVyeSBsb3cgcHJlY2VkZW5jZSwgdGhhdCBzaG91bGQgcmVzdWx0XG4gICAgLy8gaW4gQXNzaWdubWVudEV4cHJlc3Npb24gbm9kZXMuXG5cbiAgICBlcTogbmV3IFRva2VuVHlwZShcIj1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGlzQXNzaWduOiB0cnVlfSksXG4gICAgYXNzaWduOiBuZXcgVG9rZW5UeXBlKFwiXz1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGlzQXNzaWduOiB0cnVlfSksXG4gICAgaW5jRGVjOiBuZXcgVG9rZW5UeXBlKFwiKysvLS1cIiwge3ByZWZpeDogdHJ1ZSwgcG9zdGZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICAgIHByZWZpeDogbmV3IFRva2VuVHlwZShcInByZWZpeFwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgbG9naWNhbE9SOiBiaW5vcChcInx8XCIsIDEpLFxuICAgIGxvZ2ljYWxBTkQ6IGJpbm9wKFwiJiZcIiwgMiksXG4gICAgYml0d2lzZU9SOiBiaW5vcChcInxcIiwgMyksXG4gICAgYml0d2lzZVhPUjogYmlub3AoXCJeXCIsIDQpLFxuICAgIGJpdHdpc2VBTkQ6IGJpbm9wKFwiJlwiLCA1KSxcbiAgICBlcXVhbGl0eTogYmlub3AoXCI9PS8hPVwiLCA2KSxcbiAgICByZWxhdGlvbmFsOiBiaW5vcChcIjwvPlwiLCA3KSxcbiAgICBiaXRTaGlmdDogYmlub3AoXCI8PC8+PlwiLCA4KSxcbiAgICBwbHVzTWluOiBuZXcgVG9rZW5UeXBlKFwiKy8tXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBiaW5vcDogOSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgbW9kdWxvOiBiaW5vcChcIiVcIiwgMTApLFxuICAgIHN0YXI6IGJpbm9wKFwiKlwiLCAxMCksXG4gICAgc2xhc2g6IGJpbm9wKFwiL1wiLCAxMCksXG4gICAgc3RhcnN0YXI6IG5ldyBUb2tlblR5cGUoXCIqKlwiLCB7YmVmb3JlRXhwcjogdHJ1ZX0pLFxuXG4gICAgLy8gS2V5d29yZCB0b2tlbiB0eXBlcy5cbiAgICBfYnJlYWs6IGt3KFwiYnJlYWtcIiksXG4gICAgX2Nhc2U6IGt3KFwiY2FzZVwiLCBiZWZvcmVFeHByKSxcbiAgICBfY2F0Y2g6IGt3KFwiY2F0Y2hcIiksXG4gICAgX2NvbnRpbnVlOiBrdyhcImNvbnRpbnVlXCIpLFxuICAgIF9kZWJ1Z2dlcjoga3coXCJkZWJ1Z2dlclwiKSxcbiAgICBfZGVmYXVsdDoga3coXCJkZWZhdWx0XCIsIGJlZm9yZUV4cHIpLFxuICAgIF9kbzoga3coXCJkb1wiLCB7aXNMb29wOiB0cnVlLCBiZWZvcmVFeHByOiB0cnVlfSksXG4gICAgX2Vsc2U6IGt3KFwiZWxzZVwiLCBiZWZvcmVFeHByKSxcbiAgICBfZmluYWxseToga3coXCJmaW5hbGx5XCIpLFxuICAgIF9mb3I6IGt3KFwiZm9yXCIsIHtpc0xvb3A6IHRydWV9KSxcbiAgICBfZnVuY3Rpb246IGt3KFwiZnVuY3Rpb25cIiwgc3RhcnRzRXhwciksXG4gICAgX2lmOiBrdyhcImlmXCIpLFxuICAgIF9yZXR1cm46IGt3KFwicmV0dXJuXCIsIGJlZm9yZUV4cHIpLFxuICAgIF9zd2l0Y2g6IGt3KFwic3dpdGNoXCIpLFxuICAgIF90aHJvdzoga3coXCJ0aHJvd1wiLCBiZWZvcmVFeHByKSxcbiAgICBfdHJ5OiBrdyhcInRyeVwiKSxcbiAgICBfdmFyOiBrdyhcInZhclwiKSxcbiAgICBfY29uc3Q6IGt3KFwiY29uc3RcIiksXG4gICAgX3doaWxlOiBrdyhcIndoaWxlXCIsIHtpc0xvb3A6IHRydWV9KSxcbiAgICBfd2l0aDoga3coXCJ3aXRoXCIpLFxuICAgIF9uZXc6IGt3KFwibmV3XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgX3RoaXM6IGt3KFwidGhpc1wiLCBzdGFydHNFeHByKSxcbiAgICBfc3VwZXI6IGt3KFwic3VwZXJcIiwgc3RhcnRzRXhwciksXG4gICAgX2NsYXNzOiBrdyhcImNsYXNzXCIpLFxuICAgIF9leHRlbmRzOiBrdyhcImV4dGVuZHNcIiwgYmVmb3JlRXhwciksXG4gICAgX2V4cG9ydDoga3coXCJleHBvcnRcIiksXG4gICAgX2ltcG9ydDoga3coXCJpbXBvcnRcIiksXG4gICAgX251bGw6IGt3KFwibnVsbFwiLCBzdGFydHNFeHByKSxcbiAgICBfdHJ1ZToga3coXCJ0cnVlXCIsIHN0YXJ0c0V4cHIpLFxuICAgIF9mYWxzZToga3coXCJmYWxzZVwiLCBzdGFydHNFeHByKSxcbiAgICBfaW46IGt3KFwiaW5cIiwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiA3fSksXG4gICAgX2luc3RhbmNlb2Y6IGt3KFwiaW5zdGFuY2VvZlwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IDd9KSxcbiAgICBfdHlwZW9mOiBrdyhcInR5cGVvZlwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgX3ZvaWQ6IGt3KFwidm9pZFwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgcHJlZml4OiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gICAgX2RlbGV0ZToga3coXCJkZWxldGVcIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pXG4gIH1cblxuICAvLyBNYXRjaGVzIGEgd2hvbGUgbGluZSBicmVhayAod2hlcmUgQ1JMRiBpcyBjb25zaWRlcmVkIGEgc2luZ2xlXG4gIC8vIGxpbmUgYnJlYWspLiBVc2VkIHRvIGNvdW50IGxpbmVzLlxuXG4gIHZhciBsaW5lQnJlYWsgPSAvXFxyXFxuP3xcXG58XFx1MjAyOHxcXHUyMDI5L1xuICB2YXIgbGluZUJyZWFrRyA9IG5ldyBSZWdFeHAobGluZUJyZWFrLnNvdXJjZSwgXCJnXCIpXG5cbiAgZnVuY3Rpb24gaXNOZXdMaW5lKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PT0gMTAgfHwgY29kZSA9PT0gMTMgfHwgY29kZSA9PT0gMHgyMDI4IHx8IGNvZGUgPT0gMHgyMDI5XG4gIH1cblxuICB2YXIgbm9uQVNDSUl3aGl0ZXNwYWNlID0gL1tcXHUxNjgwXFx1MTgwZVxcdTIwMDAtXFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmZdL1xuXG4gIHZhciBza2lwV2hpdGVTcGFjZSA9IC8oPzpcXHN8XFwvXFwvLip8XFwvXFwqW15dKj9cXCpcXC8pKi9nXG5cbiAgZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIlxuICB9XG5cbiAgLy8gQ2hlY2tzIGlmIGFuIG9iamVjdCBoYXMgYSBwcm9wZXJ0eS5cblxuICBmdW5jdGlvbiBoYXMob2JqLCBwcm9wTmFtZSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wTmFtZSlcbiAgfVxuXG4gIC8vIFRoZXNlIGFyZSB1c2VkIHdoZW4gYG9wdGlvbnMubG9jYXRpb25zYCBpcyBvbiwgZm9yIHRoZVxuICAvLyBgc3RhcnRMb2NgIGFuZCBgZW5kTG9jYCBwcm9wZXJ0aWVzLlxuXG4gIHZhciBQb3NpdGlvbiA9IGZ1bmN0aW9uIFBvc2l0aW9uKGxpbmUsIGNvbCkge1xuICAgIHRoaXMubGluZSA9IGxpbmVcbiAgICB0aGlzLmNvbHVtbiA9IGNvbFxuICB9O1xuXG4gIFBvc2l0aW9uLnByb3RvdHlwZS5vZmZzZXQgPSBmdW5jdGlvbiBvZmZzZXQgKG4pIHtcbiAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMubGluZSwgdGhpcy5jb2x1bW4gKyBuKVxuICB9O1xuXG4gIHZhciBTb3VyY2VMb2NhdGlvbiA9IGZ1bmN0aW9uIFNvdXJjZUxvY2F0aW9uKHAsIHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnRcbiAgICB0aGlzLmVuZCA9IGVuZFxuICAgIGlmIChwLnNvdXJjZUZpbGUgIT09IG51bGwpIHRoaXMuc291cmNlID0gcC5zb3VyY2VGaWxlXG4gIH07XG5cbiAgLy8gVGhlIGBnZXRMaW5lSW5mb2AgZnVuY3Rpb24gaXMgbW9zdGx5IHVzZWZ1bCB3aGVuIHRoZVxuICAvLyBgbG9jYXRpb25zYCBvcHRpb24gaXMgb2ZmIChmb3IgcGVyZm9ybWFuY2UgcmVhc29ucykgYW5kIHlvdVxuICAvLyB3YW50IHRvIGZpbmQgdGhlIGxpbmUvY29sdW1uIHBvc2l0aW9uIGZvciBhIGdpdmVuIGNoYXJhY3RlclxuICAvLyBvZmZzZXQuIGBpbnB1dGAgc2hvdWxkIGJlIHRoZSBjb2RlIHN0cmluZyB0aGF0IHRoZSBvZmZzZXQgcmVmZXJzXG4gIC8vIGludG8uXG5cbiAgZnVuY3Rpb24gZ2V0TGluZUluZm8oaW5wdXQsIG9mZnNldCkge1xuICAgIGZvciAodmFyIGxpbmUgPSAxLCBjdXIgPSAwOzspIHtcbiAgICAgIGxpbmVCcmVha0cubGFzdEluZGV4ID0gY3VyXG4gICAgICB2YXIgbWF0Y2ggPSBsaW5lQnJlYWtHLmV4ZWMoaW5wdXQpXG4gICAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPCBvZmZzZXQpIHtcbiAgICAgICAgKytsaW5lXG4gICAgICAgIGN1ciA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKGxpbmUsIG9mZnNldCAtIGN1cilcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBBIHNlY29uZCBvcHRpb25hbCBhcmd1bWVudCBjYW4gYmUgZ2l2ZW4gdG8gZnVydGhlciBjb25maWd1cmVcbiAgLy8gdGhlIHBhcnNlciBwcm9jZXNzLiBUaGVzZSBvcHRpb25zIGFyZSByZWNvZ25pemVkOlxuXG4gIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAvLyBgZWNtYVZlcnNpb25gIGluZGljYXRlcyB0aGUgRUNNQVNjcmlwdCB2ZXJzaW9uIHRvIHBhcnNlLiBNdXN0XG4gICAgLy8gYmUgZWl0aGVyIDMsIG9yIDUsIG9yIDYuIFRoaXMgaW5mbHVlbmNlcyBzdXBwb3J0IGZvciBzdHJpY3RcbiAgICAvLyBtb2RlLCB0aGUgc2V0IG9mIHJlc2VydmVkIHdvcmRzLCBzdXBwb3J0IGZvciBnZXR0ZXJzIGFuZFxuICAgIC8vIHNldHRlcnMgYW5kIG90aGVyIGZlYXR1cmVzLiBUaGUgZGVmYXVsdCBpcyA2LlxuICAgIGVjbWFWZXJzaW9uOiA2LFxuICAgIC8vIFNvdXJjZSB0eXBlIChcInNjcmlwdFwiIG9yIFwibW9kdWxlXCIpIGZvciBkaWZmZXJlbnQgc2VtYW50aWNzXG4gICAgc291cmNlVHlwZTogXCJzY3JpcHRcIixcbiAgICAvLyBgb25JbnNlcnRlZFNlbWljb2xvbmAgY2FuIGJlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZFxuICAgIC8vIHdoZW4gYSBzZW1pY29sb24gaXMgYXV0b21hdGljYWxseSBpbnNlcnRlZC4gSXQgd2lsbCBiZSBwYXNzZWRcbiAgICAvLyB0aCBwb3NpdGlvbiBvZiB0aGUgY29tbWEgYXMgYW4gb2Zmc2V0LCBhbmQgaWYgYGxvY2F0aW9uc2AgaXNcbiAgICAvLyBlbmFibGVkLCBpdCBpcyBnaXZlbiB0aGUgbG9jYXRpb24gYXMgYSBge2xpbmUsIGNvbHVtbn1gIG9iamVjdFxuICAgIC8vIGFzIHNlY29uZCBhcmd1bWVudC5cbiAgICBvbkluc2VydGVkU2VtaWNvbG9uOiBudWxsLFxuICAgIC8vIGBvblRyYWlsaW5nQ29tbWFgIGlzIHNpbWlsYXIgdG8gYG9uSW5zZXJ0ZWRTZW1pY29sb25gLCBidXQgZm9yXG4gICAgLy8gdHJhaWxpbmcgY29tbWFzLlxuICAgIG9uVHJhaWxpbmdDb21tYTogbnVsbCxcbiAgICAvLyBCeSBkZWZhdWx0LCByZXNlcnZlZCB3b3JkcyBhcmUgb25seSBlbmZvcmNlZCBpZiBlY21hVmVyc2lvbiA+PSA1LlxuICAgIC8vIFNldCBgYWxsb3dSZXNlcnZlZGAgdG8gYSBib29sZWFuIHZhbHVlIHRvIGV4cGxpY2l0bHkgdHVybiB0aGlzIG9uXG4gICAgLy8gYW4gb2ZmLiBXaGVuIHRoaXMgb3B0aW9uIGhhcyB0aGUgdmFsdWUgXCJuZXZlclwiLCByZXNlcnZlZCB3b3Jkc1xuICAgIC8vIGFuZCBrZXl3b3JkcyBjYW4gYWxzbyBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eSBuYW1lcy5cbiAgICBhbGxvd1Jlc2VydmVkOiBudWxsLFxuICAgIC8vIFdoZW4gZW5hYmxlZCwgYSByZXR1cm4gYXQgdGhlIHRvcCBsZXZlbCBpcyBub3QgY29uc2lkZXJlZCBhblxuICAgIC8vIGVycm9yLlxuICAgIGFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uOiBmYWxzZSxcbiAgICAvLyBXaGVuIGVuYWJsZWQsIGltcG9ydC9leHBvcnQgc3RhdGVtZW50cyBhcmUgbm90IGNvbnN0cmFpbmVkIHRvXG4gICAgLy8gYXBwZWFyaW5nIGF0IHRoZSB0b3Agb2YgdGhlIHByb2dyYW0uXG4gICAgYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlOiBmYWxzZSxcbiAgICAvLyBXaGVuIGVuYWJsZWQsIGhhc2hiYW5nIGRpcmVjdGl2ZSBpbiB0aGUgYmVnaW5uaW5nIG9mIGZpbGVcbiAgICAvLyBpcyBhbGxvd2VkIGFuZCB0cmVhdGVkIGFzIGEgbGluZSBjb21tZW50LlxuICAgIGFsbG93SGFzaEJhbmc6IGZhbHNlLFxuICAgIC8vIFdoZW4gYGxvY2F0aW9uc2AgaXMgb24sIGBsb2NgIHByb3BlcnRpZXMgaG9sZGluZyBvYmplY3RzIHdpdGhcbiAgICAvLyBgc3RhcnRgIGFuZCBgZW5kYCBwcm9wZXJ0aWVzIGluIGB7bGluZSwgY29sdW1ufWAgZm9ybSAod2l0aFxuICAgIC8vIGxpbmUgYmVpbmcgMS1iYXNlZCBhbmQgY29sdW1uIDAtYmFzZWQpIHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlXG4gICAgLy8gbm9kZXMuXG4gICAgbG9jYXRpb25zOiBmYWxzZSxcbiAgICAvLyBBIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgYXMgYG9uVG9rZW5gIG9wdGlvbiwgd2hpY2ggd2lsbFxuICAgIC8vIGNhdXNlIEFjb3JuIHRvIGNhbGwgdGhhdCBmdW5jdGlvbiB3aXRoIG9iamVjdCBpbiB0aGUgc2FtZVxuICAgIC8vIGZvcm1hdCBhcyB0b2tlbnMgcmV0dXJuZWQgZnJvbSBgdG9rZW5pemVyKCkuZ2V0VG9rZW4oKWAuIE5vdGVcbiAgICAvLyB0aGF0IHlvdSBhcmUgbm90IGFsbG93ZWQgdG8gY2FsbCB0aGUgcGFyc2VyIGZyb20gdGhlXG4gICAgLy8gY2FsbGJhY2vigJR0aGF0IHdpbGwgY29ycnVwdCBpdHMgaW50ZXJuYWwgc3RhdGUuXG4gICAgb25Ub2tlbjogbnVsbCxcbiAgICAvLyBBIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgYXMgYG9uQ29tbWVudGAgb3B0aW9uLCB3aGljaCB3aWxsXG4gICAgLy8gY2F1c2UgQWNvcm4gdG8gY2FsbCB0aGF0IGZ1bmN0aW9uIHdpdGggYChibG9jaywgdGV4dCwgc3RhcnQsXG4gICAgLy8gZW5kKWAgcGFyYW1ldGVycyB3aGVuZXZlciBhIGNvbW1lbnQgaXMgc2tpcHBlZC4gYGJsb2NrYCBpcyBhXG4gICAgLy8gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBpcyBhIGJsb2NrIChgLyogKi9gKSBjb21tZW50LFxuICAgIC8vIGB0ZXh0YCBpcyB0aGUgY29udGVudCBvZiB0aGUgY29tbWVudCwgYW5kIGBzdGFydGAgYW5kIGBlbmRgIGFyZVxuICAgIC8vIGNoYXJhY3RlciBvZmZzZXRzIHRoYXQgZGVub3RlIHRoZSBzdGFydCBhbmQgZW5kIG9mIHRoZSBjb21tZW50LlxuICAgIC8vIFdoZW4gdGhlIGBsb2NhdGlvbnNgIG9wdGlvbiBpcyBvbiwgdHdvIG1vcmUgcGFyYW1ldGVycyBhcmVcbiAgICAvLyBwYXNzZWQsIHRoZSBmdWxsIGB7bGluZSwgY29sdW1ufWAgbG9jYXRpb25zIG9mIHRoZSBzdGFydCBhbmRcbiAgICAvLyBlbmQgb2YgdGhlIGNvbW1lbnRzLiBOb3RlIHRoYXQgeW91IGFyZSBub3QgYWxsb3dlZCB0byBjYWxsIHRoZVxuICAgIC8vIHBhcnNlciBmcm9tIHRoZSBjYWxsYmFja+KAlHRoYXQgd2lsbCBjb3JydXB0IGl0cyBpbnRlcm5hbCBzdGF0ZS5cbiAgICBvbkNvbW1lbnQ6IG51bGwsXG4gICAgLy8gTm9kZXMgaGF2ZSB0aGVpciBzdGFydCBhbmQgZW5kIGNoYXJhY3RlcnMgb2Zmc2V0cyByZWNvcmRlZCBpblxuICAgIC8vIGBzdGFydGAgYW5kIGBlbmRgIHByb3BlcnRpZXMgKGRpcmVjdGx5IG9uIHRoZSBub2RlLCByYXRoZXIgdGhhblxuICAgIC8vIHRoZSBgbG9jYCBvYmplY3QsIHdoaWNoIGhvbGRzIGxpbmUvY29sdW1uIGRhdGEuIFRvIGFsc28gYWRkIGFcbiAgICAvLyBbc2VtaS1zdGFuZGFyZGl6ZWRdW3JhbmdlXSBgcmFuZ2VgIHByb3BlcnR5IGhvbGRpbmcgYSBgW3N0YXJ0LFxuICAgIC8vIGVuZF1gIGFycmF5IHdpdGggdGhlIHNhbWUgbnVtYmVycywgc2V0IHRoZSBgcmFuZ2VzYCBvcHRpb24gdG9cbiAgICAvLyBgdHJ1ZWAuXG4gICAgLy9cbiAgICAvLyBbcmFuZ2VdOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03NDU2NzhcbiAgICByYW5nZXM6IGZhbHNlLFxuICAgIC8vIEl0IGlzIHBvc3NpYmxlIHRvIHBhcnNlIG11bHRpcGxlIGZpbGVzIGludG8gYSBzaW5nbGUgQVNUIGJ5XG4gICAgLy8gcGFzc2luZyB0aGUgdHJlZSBwcm9kdWNlZCBieSBwYXJzaW5nIHRoZSBmaXJzdCBmaWxlIGFzXG4gICAgLy8gYHByb2dyYW1gIG9wdGlvbiBpbiBzdWJzZXF1ZW50IHBhcnNlcy4gVGhpcyB3aWxsIGFkZCB0aGVcbiAgICAvLyB0b3BsZXZlbCBmb3JtcyBvZiB0aGUgcGFyc2VkIGZpbGUgdG8gdGhlIGBQcm9ncmFtYCAodG9wKSBub2RlXG4gICAgLy8gb2YgYW4gZXhpc3RpbmcgcGFyc2UgdHJlZS5cbiAgICBwcm9ncmFtOiBudWxsLFxuICAgIC8vIFdoZW4gYGxvY2F0aW9uc2AgaXMgb24sIHlvdSBjYW4gcGFzcyB0aGlzIHRvIHJlY29yZCB0aGUgc291cmNlXG4gICAgLy8gZmlsZSBpbiBldmVyeSBub2RlJ3MgYGxvY2Agb2JqZWN0LlxuICAgIHNvdXJjZUZpbGU6IG51bGwsXG4gICAgLy8gVGhpcyB2YWx1ZSwgaWYgZ2l2ZW4sIGlzIHN0b3JlZCBpbiBldmVyeSBub2RlLCB3aGV0aGVyXG4gICAgLy8gYGxvY2F0aW9uc2AgaXMgb24gb3Igb2ZmLlxuICAgIGRpcmVjdFNvdXJjZUZpbGU6IG51bGwsXG4gICAgLy8gV2hlbiBlbmFibGVkLCBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb25zIGFyZSByZXByZXNlbnRlZCBieVxuICAgIC8vIChub24tc3RhbmRhcmQpIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uIG5vZGVzXG4gICAgcHJlc2VydmVQYXJlbnM6IGZhbHNlLFxuICAgIHBsdWdpbnM6IHt9XG4gIH1cblxuICAvLyBJbnRlcnByZXQgYW5kIGRlZmF1bHQgYW4gb3B0aW9ucyBvYmplY3RcblxuICBmdW5jdGlvbiBnZXRPcHRpb25zKG9wdHMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHt9XG4gICAgZm9yICh2YXIgb3B0IGluIGRlZmF1bHRPcHRpb25zKVxuICAgICAgb3B0aW9uc1tvcHRdID0gb3B0cyAmJiBoYXMob3B0cywgb3B0KSA/IG9wdHNbb3B0XSA6IGRlZmF1bHRPcHRpb25zW29wdF1cbiAgICBpZiAob3B0aW9ucy5hbGxvd1Jlc2VydmVkID09IG51bGwpXG4gICAgICBvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPSBvcHRpb25zLmVjbWFWZXJzaW9uIDwgNVxuXG4gICAgaWYgKGlzQXJyYXkob3B0aW9ucy5vblRva2VuKSkge1xuICAgICAgdmFyIHRva2VucyA9IG9wdGlvbnMub25Ub2tlblxuICAgICAgb3B0aW9ucy5vblRva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiB0b2tlbnMucHVzaCh0b2tlbik7IH1cbiAgICB9XG4gICAgaWYgKGlzQXJyYXkob3B0aW9ucy5vbkNvbW1lbnQpKVxuICAgICAgb3B0aW9ucy5vbkNvbW1lbnQgPSBwdXNoQ29tbWVudChvcHRpb25zLCBvcHRpb25zLm9uQ29tbWVudClcblxuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICBmdW5jdGlvbiBwdXNoQ29tbWVudChvcHRpb25zLCBhcnJheSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYmxvY2ssIHRleHQsIHN0YXJ0LCBlbmQsIHN0YXJ0TG9jLCBlbmRMb2MpIHtcbiAgICAgIHZhciBjb21tZW50ID0ge1xuICAgICAgICB0eXBlOiBibG9jayA/ICdCbG9jaycgOiAnTGluZScsXG4gICAgICAgIHZhbHVlOiB0ZXh0LFxuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGVuZDogZW5kXG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgICAgIGNvbW1lbnQubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHRoaXMsIHN0YXJ0TG9jLCBlbmRMb2MpXG4gICAgICBpZiAob3B0aW9ucy5yYW5nZXMpXG4gICAgICAgIGNvbW1lbnQucmFuZ2UgPSBbc3RhcnQsIGVuZF1cbiAgICAgIGFycmF5LnB1c2goY29tbWVudClcbiAgICB9XG4gIH1cblxuICAvLyBSZWdpc3RlcmVkIHBsdWdpbnNcbiAgdmFyIHBsdWdpbnMgPSB7fVxuXG4gIGZ1bmN0aW9uIGtleXdvcmRSZWdleHAod29yZHMpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oXCIgKyB3b3Jkcy5yZXBsYWNlKC8gL2csIFwifFwiKSArIFwiKSRcIilcbiAgfVxuXG4gIHZhciBQYXJzZXIgPSBmdW5jdGlvbiBQYXJzZXIob3B0aW9ucywgaW5wdXQsIHN0YXJ0UG9zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyA9IGdldE9wdGlvbnMob3B0aW9ucylcbiAgICB0aGlzLnNvdXJjZUZpbGUgPSBvcHRpb25zLnNvdXJjZUZpbGVcbiAgICB0aGlzLmtleXdvcmRzID0ga2V5d29yZFJlZ2V4cChrZXl3b3Jkc1tvcHRpb25zLmVjbWFWZXJzaW9uID49IDYgPyA2IDogNV0pXG4gICAgdmFyIHJlc2VydmVkID0gb3B0aW9ucy5hbGxvd1Jlc2VydmVkID8gXCJcIiA6XG4gICAgICAgIHJlc2VydmVkV29yZHNbb3B0aW9ucy5lY21hVmVyc2lvbl0gKyAob3B0aW9ucy5zb3VyY2VUeXBlID09IFwibW9kdWxlXCIgPyBcIiBhd2FpdFwiIDogXCJcIilcbiAgICB0aGlzLnJlc2VydmVkV29yZHMgPSBrZXl3b3JkUmVnZXhwKHJlc2VydmVkKVxuICAgIHZhciByZXNlcnZlZFN0cmljdCA9IChyZXNlcnZlZCA/IHJlc2VydmVkICsgXCIgXCIgOiBcIlwiKSArIHJlc2VydmVkV29yZHMuc3RyaWN0XG4gICAgdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0ID0ga2V5d29yZFJlZ2V4cChyZXNlcnZlZFN0cmljdClcbiAgICB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3RCaW5kID0ga2V5d29yZFJlZ2V4cChyZXNlcnZlZFN0cmljdCArIFwiIFwiICsgcmVzZXJ2ZWRXb3Jkcy5zdHJpY3RCaW5kKVxuICAgIHRoaXMuaW5wdXQgPSBTdHJpbmcoaW5wdXQpXG5cbiAgICAvLyBVc2VkIHRvIHNpZ25hbCB0byBjYWxsZXJzIG9mIGByZWFkV29yZDFgIHdoZXRoZXIgdGhlIHdvcmRcbiAgICAvLyBjb250YWluZWQgYW55IGVzY2FwZSBzZXF1ZW5jZXMuIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2Ugd29yZHMgd2l0aFxuICAgIC8vIGVzY2FwZSBzZXF1ZW5jZXMgbXVzdCBub3QgYmUgaW50ZXJwcmV0ZWQgYXMga2V5d29yZHMuXG4gICAgdGhpcy5jb250YWluc0VzYyA9IGZhbHNlXG5cbiAgICAvLyBMb2FkIHBsdWdpbnNcbiAgICB0aGlzLmxvYWRQbHVnaW5zKG9wdGlvbnMucGx1Z2lucylcblxuICAgIC8vIFNldCB1cCB0b2tlbiBzdGF0ZVxuXG4gICAgLy8gVGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHRva2VuaXplciBpbiB0aGUgaW5wdXQuXG4gICAgaWYgKHN0YXJ0UG9zKSB7XG4gICAgICB0aGlzLnBvcyA9IHN0YXJ0UG9zXG4gICAgICB0aGlzLmxpbmVTdGFydCA9IE1hdGgubWF4KDAsIHRoaXMuaW5wdXQubGFzdEluZGV4T2YoXCJcXG5cIiwgc3RhcnRQb3MpKVxuICAgICAgdGhpcy5jdXJMaW5lID0gdGhpcy5pbnB1dC5zbGljZSgwLCB0aGlzLmxpbmVTdGFydCkuc3BsaXQobGluZUJyZWFrKS5sZW5ndGhcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wb3MgPSB0aGlzLmxpbmVTdGFydCA9IDBcbiAgICAgIHRoaXMuY3VyTGluZSA9IDFcbiAgICB9XG5cbiAgICAvLyBQcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHRva2VuOlxuICAgIC8vIEl0cyB0eXBlXG4gICAgdGhpcy50eXBlID0gdHQuZW9mXG4gICAgLy8gRm9yIHRva2VucyB0aGF0IGluY2x1ZGUgbW9yZSBpbmZvcm1hdGlvbiB0aGFuIHRoZWlyIHR5cGUsIHRoZSB2YWx1ZVxuICAgIHRoaXMudmFsdWUgPSBudWxsXG4gICAgLy8gSXRzIHN0YXJ0IGFuZCBlbmQgb2Zmc2V0XG4gICAgdGhpcy5zdGFydCA9IHRoaXMuZW5kID0gdGhpcy5wb3NcbiAgICAvLyBBbmQsIGlmIGxvY2F0aW9ucyBhcmUgdXNlZCwgdGhlIHtsaW5lLCBjb2x1bW59IG9iamVjdFxuICAgIC8vIGNvcnJlc3BvbmRpbmcgdG8gdGhvc2Ugb2Zmc2V0c1xuICAgIHRoaXMuc3RhcnRMb2MgPSB0aGlzLmVuZExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKVxuXG4gICAgLy8gUG9zaXRpb24gaW5mb3JtYXRpb24gZm9yIHRoZSBwcmV2aW91cyB0b2tlblxuICAgIHRoaXMubGFzdFRva0VuZExvYyA9IHRoaXMubGFzdFRva1N0YXJ0TG9jID0gbnVsbFxuICAgIHRoaXMubGFzdFRva1N0YXJ0ID0gdGhpcy5sYXN0VG9rRW5kID0gdGhpcy5wb3NcblxuICAgIC8vIFRoZSBjb250ZXh0IHN0YWNrIGlzIHVzZWQgdG8gc3VwZXJmaWNpYWxseSB0cmFjayBzeW50YWN0aWNcbiAgICAvLyBjb250ZXh0IHRvIHByZWRpY3Qgd2hldGhlciBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBhbGxvd2VkIGluIGFcbiAgICAvLyBnaXZlbiBwb3NpdGlvbi5cbiAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmluaXRpYWxDb250ZXh0KClcbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZVxuXG4gICAgLy8gRmlndXJlIG91dCBpZiBpdCdzIGEgbW9kdWxlIGNvZGUuXG4gICAgdGhpcy5zdHJpY3QgPSB0aGlzLmluTW9kdWxlID0gb3B0aW9ucy5zb3VyY2VUeXBlID09PSBcIm1vZHVsZVwiXG5cbiAgICAvLyBVc2VkIHRvIHNpZ25pZnkgdGhlIHN0YXJ0IG9mIGEgcG90ZW50aWFsIGFycm93IGZ1bmN0aW9uXG4gICAgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID0gLTFcblxuICAgIC8vIEZsYWdzIHRvIHRyYWNrIHdoZXRoZXIgd2UgYXJlIGluIGEgZnVuY3Rpb24sIGEgZ2VuZXJhdG9yLlxuICAgIHRoaXMuaW5GdW5jdGlvbiA9IHRoaXMuaW5HZW5lcmF0b3IgPSBmYWxzZVxuICAgIC8vIExhYmVscyBpbiBzY29wZS5cbiAgICB0aGlzLmxhYmVscyA9IFtdXG5cbiAgICAvLyBJZiBlbmFibGVkLCBza2lwIGxlYWRpbmcgaGFzaGJhbmcgbGluZS5cbiAgICBpZiAodGhpcy5wb3MgPT09IDAgJiYgb3B0aW9ucy5hbGxvd0hhc2hCYW5nICYmIHRoaXMuaW5wdXQuc2xpY2UoMCwgMikgPT09ICcjIScpXG4gICAgICB0aGlzLnNraXBMaW5lQ29tbWVudCgyKVxuICB9O1xuXG4gIC8vIERFUFJFQ0FURUQgS2VwdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgdW50aWwgMy4wIGluIGNhc2UgYSBwbHVnaW4gdXNlcyB0aGVtXG4gIFBhcnNlci5wcm90b3R5cGUuaXNLZXl3b3JkID0gZnVuY3Rpb24gaXNLZXl3b3JkICh3b3JkKSB7IHJldHVybiB0aGlzLmtleXdvcmRzLnRlc3Qod29yZCkgfTtcbiAgUGFyc2VyLnByb3RvdHlwZS5pc1Jlc2VydmVkV29yZCA9IGZ1bmN0aW9uIGlzUmVzZXJ2ZWRXb3JkICh3b3JkKSB7IHJldHVybiB0aGlzLnJlc2VydmVkV29yZHMudGVzdCh3b3JkKSB9O1xuXG4gIFBhcnNlci5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kIChuYW1lLCBmKSB7XG4gICAgdGhpc1tuYW1lXSA9IGYodGhpc1tuYW1lXSlcbiAgfTtcblxuICBQYXJzZXIucHJvdG90eXBlLmxvYWRQbHVnaW5zID0gZnVuY3Rpb24gbG9hZFBsdWdpbnMgKHBsdWdpbkNvbmZpZ3MpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBwbHVnaW5Db25maWdzKSB7XG4gICAgICB2YXIgcGx1Z2luID0gcGx1Z2luc1tuYW1lXVxuICAgICAgaWYgKCFwbHVnaW4pIHRocm93IG5ldyBFcnJvcihcIlBsdWdpbiAnXCIgKyBuYW1lICsgXCInIG5vdCBmb3VuZFwiKVxuICAgICAgcGx1Z2luKHRoaXMkMSwgcGx1Z2luQ29uZmlnc1tuYW1lXSlcbiAgICB9XG4gIH07XG5cbiAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlICgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMub3B0aW9ucy5wcm9ncmFtIHx8IHRoaXMuc3RhcnROb2RlKClcbiAgICB0aGlzLm5leHRUb2tlbigpXG4gICAgcmV0dXJuIHRoaXMucGFyc2VUb3BMZXZlbChub2RlKVxuICB9O1xuXG4gIHZhciBwcCA9IFBhcnNlci5wcm90b3R5cGVcblxuICAvLyAjIyBQYXJzZXIgdXRpbGl0aWVzXG5cbiAgLy8gVGVzdCB3aGV0aGVyIGEgc3RhdGVtZW50IG5vZGUgaXMgdGhlIHN0cmluZyBsaXRlcmFsIGBcInVzZSBzdHJpY3RcImAuXG5cbiAgcHAuaXNVc2VTdHJpY3QgPSBmdW5jdGlvbihzdG10KSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmIHN0bXQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiZcbiAgICAgIHN0bXQuZXhwcmVzc2lvbi50eXBlID09PSBcIkxpdGVyYWxcIiAmJlxuICAgICAgc3RtdC5leHByZXNzaW9uLnJhdy5zbGljZSgxLCAtMSkgPT09IFwidXNlIHN0cmljdFwiXG4gIH1cblxuICAvLyBQcmVkaWNhdGUgdGhhdCB0ZXN0cyB3aGV0aGVyIHRoZSBuZXh0IHRva2VuIGlzIG9mIHRoZSBnaXZlblxuICAvLyB0eXBlLCBhbmQgaWYgeWVzLCBjb25zdW1lcyBpdCBhcyBhIHNpZGUgZWZmZWN0LlxuXG4gIHBwLmVhdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSB0eXBlKSB7XG4gICAgICB0aGlzLm5leHQoKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gVGVzdHMgd2hldGhlciBwYXJzZWQgdG9rZW4gaXMgYSBjb250ZXh0dWFsIGtleXdvcmQuXG5cbiAgcHAuaXNDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IHR0Lm5hbWUgJiYgdGhpcy52YWx1ZSA9PT0gbmFtZVxuICB9XG5cbiAgLy8gQ29uc3VtZXMgY29udGV4dHVhbCBrZXl3b3JkIGlmIHBvc3NpYmxlLlxuXG4gIHBwLmVhdENvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IG5hbWUgJiYgdGhpcy5lYXQodHQubmFtZSlcbiAgfVxuXG4gIC8vIEFzc2VydHMgdGhhdCBmb2xsb3dpbmcgdG9rZW4gaXMgZ2l2ZW4gY29udGV4dHVhbCBrZXl3b3JkLlxuXG4gIHBwLmV4cGVjdENvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgaWYgKCF0aGlzLmVhdENvbnRleHR1YWwobmFtZSkpIHRoaXMudW5leHBlY3RlZCgpXG4gIH1cblxuICAvLyBUZXN0IHdoZXRoZXIgYSBzZW1pY29sb24gY2FuIGJlIGluc2VydGVkIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuXG4gIHBwLmNhbkluc2VydFNlbWljb2xvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IHR0LmVvZiB8fFxuICAgICAgdGhpcy50eXBlID09PSB0dC5icmFjZVIgfHxcbiAgICAgIGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSlcbiAgfVxuXG4gIHBwLmluc2VydFNlbWljb2xvbiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm9uSW5zZXJ0ZWRTZW1pY29sb24pXG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkluc2VydGVkU2VtaWNvbG9uKHRoaXMubGFzdFRva0VuZCwgdGhpcy5sYXN0VG9rRW5kTG9jKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICAvLyBDb25zdW1lIGEgc2VtaWNvbG9uLCBvciwgZmFpbGluZyB0aGF0LCBzZWUgaWYgd2UgYXJlIGFsbG93ZWQgdG9cbiAgLy8gcHJldGVuZCB0aGF0IHRoZXJlIGlzIGEgc2VtaWNvbG9uIGF0IHRoaXMgcG9zaXRpb24uXG5cbiAgcHAuc2VtaWNvbG9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmVhdCh0dC5zZW1pKSAmJiAhdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgdGhpcy51bmV4cGVjdGVkKClcbiAgfVxuXG4gIHBwLmFmdGVyVHJhaWxpbmdDb21tYSA9IGZ1bmN0aW9uKHRva1R5cGUpIHtcbiAgICBpZiAodGhpcy50eXBlID09IHRva1R5cGUpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub25UcmFpbGluZ0NvbW1hKVxuICAgICAgICB0aGlzLm9wdGlvbnMub25UcmFpbGluZ0NvbW1hKHRoaXMubGFzdFRva1N0YXJ0LCB0aGlzLmxhc3RUb2tTdGFydExvYylcbiAgICAgIHRoaXMubmV4dCgpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIC8vIEV4cGVjdCBhIHRva2VuIG9mIGEgZ2l2ZW4gdHlwZS4gSWYgZm91bmQsIGNvbnN1bWUgaXQsIG90aGVyd2lzZSxcbiAgLy8gcmFpc2UgYW4gdW5leHBlY3RlZCB0b2tlbiBlcnJvci5cblxuICBwcC5leHBlY3QgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgdGhpcy5lYXQodHlwZSkgfHwgdGhpcy51bmV4cGVjdGVkKClcbiAgfVxuXG4gIC8vIFJhaXNlIGFuIHVuZXhwZWN0ZWQgdG9rZW4gZXJyb3IuXG5cbiAgcHAudW5leHBlY3RlZCA9IGZ1bmN0aW9uKHBvcykge1xuICAgIHRoaXMucmFpc2UocG9zICE9IG51bGwgPyBwb3MgOiB0aGlzLnN0YXJ0LCBcIlVuZXhwZWN0ZWQgdG9rZW5cIilcbiAgfVxuXG4gIHZhciBEZXN0cnVjdHVyaW5nRXJyb3JzID0gZnVuY3Rpb24gRGVzdHJ1Y3R1cmluZ0Vycm9ycygpIHtcbiAgICB0aGlzLnNob3J0aGFuZEFzc2lnbiA9IDBcbiAgICB0aGlzLnRyYWlsaW5nQ29tbWEgPSAwXG4gIH07XG5cbiAgcHAuY2hlY2tQYXR0ZXJuRXJyb3JzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgYW5kVGhyb3cpIHtcbiAgICB2YXIgdHJhaWxpbmcgPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYVxuICAgIGlmICghYW5kVGhyb3cpIHJldHVybiAhIXRyYWlsaW5nXG4gICAgaWYgKHRyYWlsaW5nKSB0aGlzLnJhaXNlKHRyYWlsaW5nLCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKVxuICB9XG5cbiAgcHAuY2hlY2tFeHByZXNzaW9uRXJyb3JzID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgYW5kVGhyb3cpIHtcbiAgICB2YXIgcG9zID0gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnblxuICAgIGlmICghYW5kVGhyb3cpIHJldHVybiAhIXBvc1xuICAgIGlmIChwb3MpIHRoaXMucmFpc2UocG9zLCBcIlNob3J0aGFuZCBwcm9wZXJ0eSBhc3NpZ25tZW50cyBhcmUgdmFsaWQgb25seSBpbiBkZXN0cnVjdHVyaW5nIHBhdHRlcm5zXCIpXG4gIH1cblxuICB2YXIgcHAkMSA9IFBhcnNlci5wcm90b3R5cGVcblxuICAvLyAjIyMgU3RhdGVtZW50IHBhcnNpbmdcblxuICAvLyBQYXJzZSBhIHByb2dyYW0uIEluaXRpYWxpemVzIHRoZSBwYXJzZXIsIHJlYWRzIGFueSBudW1iZXIgb2ZcbiAgLy8gc3RhdGVtZW50cywgYW5kIHdyYXBzIHRoZW0gaW4gYSBQcm9ncmFtIG5vZGUuICBPcHRpb25hbGx5IHRha2VzIGFcbiAgLy8gYHByb2dyYW1gIGFyZ3VtZW50LiAgSWYgcHJlc2VudCwgdGhlIHN0YXRlbWVudHMgd2lsbCBiZSBhcHBlbmRlZFxuICAvLyB0byBpdHMgYm9keSBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IG5vZGUuXG5cbiAgcHAkMS5wYXJzZVRvcExldmVsID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGZpcnN0ID0gdHJ1ZVxuICAgIGlmICghbm9kZS5ib2R5KSBub2RlLmJvZHkgPSBbXVxuICAgIHdoaWxlICh0aGlzLnR5cGUgIT09IHR0LmVvZikge1xuICAgICAgdmFyIHN0bXQgPSB0aGlzJDEucGFyc2VTdGF0ZW1lbnQodHJ1ZSwgdHJ1ZSlcbiAgICAgIG5vZGUuYm9keS5wdXNoKHN0bXQpXG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgaWYgKHRoaXMkMS5pc1VzZVN0cmljdChzdG10KSkgdGhpcyQxLnNldFN0cmljdCh0cnVlKVxuICAgICAgICBmaXJzdCA9IGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubmV4dCgpXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBub2RlLnNvdXJjZVR5cGUgPSB0aGlzLm9wdGlvbnMuc291cmNlVHlwZVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUHJvZ3JhbVwiKVxuICB9XG5cbiAgdmFyIGxvb3BMYWJlbCA9IHtraW5kOiBcImxvb3BcIn07XG4gIHZhciBzd2l0Y2hMYWJlbCA9IHtraW5kOiBcInN3aXRjaFwifTtcbiAgcHAkMS5pc0xldCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnR5cGUgIT09IHR0Lm5hbWUgfHwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNiB8fCB0aGlzLnZhbHVlICE9IFwibGV0XCIpIHJldHVybiBmYWxzZVxuICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHRoaXMucG9zXG4gICAgdmFyIHNraXAgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpXG4gICAgdmFyIG5leHQgPSB0aGlzLnBvcyArIHNraXBbMF0ubGVuZ3RoLCBuZXh0Q2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dClcbiAgICBpZiAobmV4dENoID09PSA5MSB8fCBuZXh0Q2ggPT0gMTIzKSByZXR1cm4gdHJ1ZSAvLyAneycgYW5kICdbJ1xuICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChuZXh0Q2gsIHRydWUpKSB7XG4gICAgICBmb3IgKHZhciBwb3MgPSBuZXh0ICsgMTsgaXNJZGVudGlmaWVyQ2hhcih0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zKSwgdHJ1ZSk7ICsrcG9zKSB7fVxuICAgICAgdmFyIGlkZW50ID0gdGhpcy5pbnB1dC5zbGljZShuZXh0LCBwb3MpXG4gICAgICBpZiAoIXRoaXMuaXNLZXl3b3JkKGlkZW50KSkgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBQYXJzZSBhIHNpbmdsZSBzdGF0ZW1lbnQuXG4gIC8vXG4gIC8vIElmIGV4cGVjdGluZyBhIHN0YXRlbWVudCBhbmQgZmluZGluZyBhIHNsYXNoIG9wZXJhdG9yLCBwYXJzZSBhXG4gIC8vIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsLiBUaGlzIGlzIHRvIGhhbmRsZSBjYXNlcyBsaWtlXG4gIC8vIGBpZiAoZm9vKSAvYmxhaC8uZXhlYyhmb28pYCwgd2hlcmUgbG9va2luZyBhdCB0aGUgcHJldmlvdXMgdG9rZW5cbiAgLy8gZG9lcyBub3QgaGVscC5cblxuICBwcCQxLnBhcnNlU3RhdGVtZW50ID0gZnVuY3Rpb24oZGVjbGFyYXRpb24sIHRvcExldmVsKSB7XG4gICAgdmFyIHN0YXJ0dHlwZSA9IHRoaXMudHlwZSwgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIGtpbmRcblxuICAgIGlmICh0aGlzLmlzTGV0KCkpIHtcbiAgICAgIHN0YXJ0dHlwZSA9IHR0Ll92YXJcbiAgICAgIGtpbmQgPSBcImxldFwiXG4gICAgfVxuXG4gICAgLy8gTW9zdCB0eXBlcyBvZiBzdGF0ZW1lbnRzIGFyZSByZWNvZ25pemVkIGJ5IHRoZSBrZXl3b3JkIHRoZXlcbiAgICAvLyBzdGFydCB3aXRoLiBNYW55IGFyZSB0cml2aWFsIHRvIHBhcnNlLCBzb21lIHJlcXVpcmUgYSBiaXQgb2ZcbiAgICAvLyBjb21wbGV4aXR5LlxuXG4gICAgc3dpdGNoIChzdGFydHR5cGUpIHtcbiAgICBjYXNlIHR0Ll9icmVhazogY2FzZSB0dC5fY29udGludWU6IHJldHVybiB0aGlzLnBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudChub2RlLCBzdGFydHR5cGUua2V5d29yZClcbiAgICBjYXNlIHR0Ll9kZWJ1Z2dlcjogcmV0dXJuIHRoaXMucGFyc2VEZWJ1Z2dlclN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHQuX2RvOiByZXR1cm4gdGhpcy5wYXJzZURvU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0dC5fZm9yOiByZXR1cm4gdGhpcy5wYXJzZUZvclN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHQuX2Z1bmN0aW9uOlxuICAgICAgaWYgKCFkZWNsYXJhdGlvbiAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgdGhpcy51bmV4cGVjdGVkKClcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR0Ll9jbGFzczpcbiAgICAgIGlmICghZGVjbGFyYXRpb24pIHRoaXMudW5leHBlY3RlZCgpXG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKG5vZGUsIHRydWUpXG4gICAgY2FzZSB0dC5faWY6IHJldHVybiB0aGlzLnBhcnNlSWZTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR0Ll9yZXR1cm46IHJldHVybiB0aGlzLnBhcnNlUmV0dXJuU3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0dC5fc3dpdGNoOiByZXR1cm4gdGhpcy5wYXJzZVN3aXRjaFN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHQuX3Rocm93OiByZXR1cm4gdGhpcy5wYXJzZVRocm93U3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0dC5fdHJ5OiByZXR1cm4gdGhpcy5wYXJzZVRyeVN0YXRlbWVudChub2RlKVxuICAgIGNhc2UgdHQuX2NvbnN0OiBjYXNlIHR0Ll92YXI6XG4gICAgICBraW5kID0ga2luZCB8fCB0aGlzLnZhbHVlXG4gICAgICBpZiAoIWRlY2xhcmF0aW9uICYmIGtpbmQgIT0gXCJ2YXJcIikgdGhpcy51bmV4cGVjdGVkKClcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlVmFyU3RhdGVtZW50KG5vZGUsIGtpbmQpXG4gICAgY2FzZSB0dC5fd2hpbGU6IHJldHVybiB0aGlzLnBhcnNlV2hpbGVTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR0Ll93aXRoOiByZXR1cm4gdGhpcy5wYXJzZVdpdGhTdGF0ZW1lbnQobm9kZSlcbiAgICBjYXNlIHR0LmJyYWNlTDogcmV0dXJuIHRoaXMucGFyc2VCbG9jaygpXG4gICAgY2FzZSB0dC5zZW1pOiByZXR1cm4gdGhpcy5wYXJzZUVtcHR5U3RhdGVtZW50KG5vZGUpXG4gICAgY2FzZSB0dC5fZXhwb3J0OlxuICAgIGNhc2UgdHQuX2ltcG9ydDpcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZSkge1xuICAgICAgICBpZiAoIXRvcExldmVsKVxuICAgICAgICAgIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInaW1wb3J0JyBhbmQgJ2V4cG9ydCcgbWF5IG9ubHkgYXBwZWFyIGF0IHRoZSB0b3AgbGV2ZWxcIilcbiAgICAgICAgaWYgKCF0aGlzLmluTW9kdWxlKVxuICAgICAgICAgIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInaW1wb3J0JyBhbmQgJ2V4cG9ydCcgbWF5IGFwcGVhciBvbmx5IHdpdGggJ3NvdXJjZVR5cGU6IG1vZHVsZSdcIilcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGFydHR5cGUgPT09IHR0Ll9pbXBvcnQgPyB0aGlzLnBhcnNlSW1wb3J0KG5vZGUpIDogdGhpcy5wYXJzZUV4cG9ydChub2RlKVxuXG4gICAgICAvLyBJZiB0aGUgc3RhdGVtZW50IGRvZXMgbm90IHN0YXJ0IHdpdGggYSBzdGF0ZW1lbnQga2V5d29yZCBvciBhXG4gICAgICAvLyBicmFjZSwgaXQncyBhbiBFeHByZXNzaW9uU3RhdGVtZW50IG9yIExhYmVsZWRTdGF0ZW1lbnQuIFdlXG4gICAgICAvLyBzaW1wbHkgc3RhcnQgcGFyc2luZyBhbiBleHByZXNzaW9uLCBhbmQgYWZ0ZXJ3YXJkcywgaWYgdGhlXG4gICAgICAvLyBuZXh0IHRva2VuIGlzIGEgY29sb24gYW5kIHRoZSBleHByZXNzaW9uIHdhcyBhIHNpbXBsZVxuICAgICAgLy8gSWRlbnRpZmllciBub2RlLCB3ZSBzd2l0Y2ggdG8gaW50ZXJwcmV0aW5nIGl0IGFzIGEgbGFiZWwuXG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBtYXliZU5hbWUgPSB0aGlzLnZhbHVlLCBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKVxuICAgICAgaWYgKHN0YXJ0dHlwZSA9PT0gdHQubmFtZSAmJiBleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHRoaXMuZWF0KHR0LmNvbG9uKSlcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMYWJlbGVkU3RhdGVtZW50KG5vZGUsIG1heWJlTmFtZSwgZXhwcilcbiAgICAgIGVsc2UgcmV0dXJuIHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIpXG4gICAgfVxuICB9XG5cbiAgcHAkMS5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBrZXl3b3JkKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgaXNCcmVhayA9IGtleXdvcmQgPT0gXCJicmVha1wiXG4gICAgdGhpcy5uZXh0KClcbiAgICBpZiAodGhpcy5lYXQodHQuc2VtaSkgfHwgdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgbm9kZS5sYWJlbCA9IG51bGxcbiAgICBlbHNlIGlmICh0aGlzLnR5cGUgIT09IHR0Lm5hbWUpIHRoaXMudW5leHBlY3RlZCgpXG4gICAgZWxzZSB7XG4gICAgICBub2RlLmxhYmVsID0gdGhpcy5wYXJzZUlkZW50KClcbiAgICAgIHRoaXMuc2VtaWNvbG9uKClcbiAgICB9XG5cbiAgICAvLyBWZXJpZnkgdGhhdCB0aGVyZSBpcyBhbiBhY3R1YWwgZGVzdGluYXRpb24gdG8gYnJlYWsgb3JcbiAgICAvLyBjb250aW51ZSB0by5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgbGFiID0gdGhpcyQxLmxhYmVsc1tpXVxuICAgICAgaWYgKG5vZGUubGFiZWwgPT0gbnVsbCB8fCBsYWIubmFtZSA9PT0gbm9kZS5sYWJlbC5uYW1lKSB7XG4gICAgICAgIGlmIChsYWIua2luZCAhPSBudWxsICYmIChpc0JyZWFrIHx8IGxhYi5raW5kID09PSBcImxvb3BcIikpIGJyZWFrXG4gICAgICAgIGlmIChub2RlLmxhYmVsICYmIGlzQnJlYWspIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpID09PSB0aGlzLmxhYmVscy5sZW5ndGgpIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJVbnN5bnRhY3RpYyBcIiArIGtleXdvcmQpXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc0JyZWFrID8gXCJCcmVha1N0YXRlbWVudFwiIDogXCJDb250aW51ZVN0YXRlbWVudFwiKVxuICB9XG5cbiAgcHAkMS5wYXJzZURlYnVnZ2VyU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpXG4gICAgdGhpcy5zZW1pY29sb24oKVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWJ1Z2dlclN0YXRlbWVudFwiKVxuICB9XG5cbiAgcHAkMS5wYXJzZURvU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpXG4gICAgdGhpcy5sYWJlbHMucHVzaChsb29wTGFiZWwpXG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChmYWxzZSlcbiAgICB0aGlzLmxhYmVscy5wb3AoKVxuICAgIHRoaXMuZXhwZWN0KHR0Ll93aGlsZSlcbiAgICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKClcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpXG4gICAgICB0aGlzLmVhdCh0dC5zZW1pKVxuICAgIGVsc2VcbiAgICAgIHRoaXMuc2VtaWNvbG9uKClcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRG9XaGlsZVN0YXRlbWVudFwiKVxuICB9XG5cbiAgLy8gRGlzYW1iaWd1YXRpbmcgYmV0d2VlbiBhIGBmb3JgIGFuZCBhIGBmb3JgL2BpbmAgb3IgYGZvcmAvYG9mYFxuICAvLyBsb29wIGlzIG5vbi10cml2aWFsLiBCYXNpY2FsbHksIHdlIGhhdmUgdG8gcGFyc2UgdGhlIGluaXQgYHZhcmBcbiAgLy8gc3RhdGVtZW50IG9yIGV4cHJlc3Npb24sIGRpc2FsbG93aW5nIHRoZSBgaW5gIG9wZXJhdG9yIChzZWVcbiAgLy8gdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gYHBhcnNlRXhwcmVzc2lvbmApLCBhbmQgdGhlbiBjaGVja1xuICAvLyB3aGV0aGVyIHRoZSBuZXh0IHRva2VuIGlzIGBpbmAgb3IgYG9mYC4gV2hlbiB0aGVyZSBpcyBubyBpbml0XG4gIC8vIHBhcnQgKHNlbWljb2xvbiBpbW1lZGlhdGVseSBhZnRlciB0aGUgb3BlbmluZyBwYXJlbnRoZXNpcyksIGl0XG4gIC8vIGlzIGEgcmVndWxhciBgZm9yYCBsb29wLlxuXG4gIHBwJDEucGFyc2VGb3JTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KClcbiAgICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbClcbiAgICB0aGlzLmV4cGVjdCh0dC5wYXJlbkwpXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHQuc2VtaSkgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgbnVsbClcbiAgICB2YXIgaXNMZXQgPSB0aGlzLmlzTGV0KClcbiAgICBpZiAodGhpcy50eXBlID09PSB0dC5fdmFyIHx8IHRoaXMudHlwZSA9PT0gdHQuX2NvbnN0IHx8IGlzTGV0KSB7XG4gICAgICB2YXIgaW5pdCQxID0gdGhpcy5zdGFydE5vZGUoKSwga2luZCA9IGlzTGV0ID8gXCJsZXRcIiA6IHRoaXMudmFsdWVcbiAgICAgIHRoaXMubmV4dCgpXG4gICAgICB0aGlzLnBhcnNlVmFyKGluaXQkMSwgdHJ1ZSwga2luZClcbiAgICAgIHRoaXMuZmluaXNoTm9kZShpbml0JDEsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKVxuICAgICAgaWYgKCh0aGlzLnR5cGUgPT09IHR0Ll9pbiB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpICYmIGluaXQkMS5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgIShraW5kICE9PSBcInZhclwiICYmIGluaXQkMS5kZWNsYXJhdGlvbnNbMF0uaW5pdCkpXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9ySW4obm9kZSwgaW5pdCQxKVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdCQxKVxuICAgIH1cbiAgICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzXG4gICAgdmFyIGluaXQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbih0cnVlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKVxuICAgIGlmICh0aGlzLnR5cGUgPT09IHR0Ll9pbiB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpIHtcbiAgICAgIHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpXG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShpbml0KVxuICAgICAgdGhpcy5jaGVja0xWYWwoaW5pdClcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9ySW4obm9kZSwgaW5pdClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdClcbiAgfVxuXG4gIHBwJDEucGFyc2VGdW5jdGlvblN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKVxuICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24obm9kZSwgdHJ1ZSlcbiAgfVxuXG4gIHBwJDEucGFyc2VJZlN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKVxuICAgIG5vZGUudGVzdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKVxuICAgIG5vZGUuY29uc2VxdWVudCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoZmFsc2UpXG4gICAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLmVhdCh0dC5fZWxzZSkgPyB0aGlzLnBhcnNlU3RhdGVtZW50KGZhbHNlKSA6IG51bGxcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSWZTdGF0ZW1lbnRcIilcbiAgfVxuXG4gIHBwJDEucGFyc2VSZXR1cm5TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCF0aGlzLmluRnVuY3Rpb24gJiYgIXRoaXMub3B0aW9ucy5hbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbilcbiAgICAgIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCIncmV0dXJuJyBvdXRzaWRlIG9mIGZ1bmN0aW9uXCIpXG4gICAgdGhpcy5uZXh0KClcblxuICAgIC8vIEluIGByZXR1cm5gIChhbmQgYGJyZWFrYC9gY29udGludWVgKSwgdGhlIGtleXdvcmRzIHdpdGhcbiAgICAvLyBvcHRpb25hbCBhcmd1bWVudHMsIHdlIGVhZ2VybHkgbG9vayBmb3IgYSBzZW1pY29sb24gb3IgdGhlXG4gICAgLy8gcG9zc2liaWxpdHkgdG8gaW5zZXJ0IG9uZS5cblxuICAgIGlmICh0aGlzLmVhdCh0dC5zZW1pKSB8fCB0aGlzLmluc2VydFNlbWljb2xvbigpKSBub2RlLmFyZ3VtZW50ID0gbnVsbFxuICAgIGVsc2UgeyBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTsgdGhpcy5zZW1pY29sb24oKSB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlJldHVyblN0YXRlbWVudFwiKVxuICB9XG5cbiAgcHAkMS5wYXJzZVN3aXRjaFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMubmV4dCgpXG4gICAgbm9kZS5kaXNjcmltaW5hbnQgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKClcbiAgICBub2RlLmNhc2VzID0gW11cbiAgICB0aGlzLmV4cGVjdCh0dC5icmFjZUwpXG4gICAgdGhpcy5sYWJlbHMucHVzaChzd2l0Y2hMYWJlbClcblxuICAgIC8vIFN0YXRlbWVudHMgdW5kZXIgbXVzdCBiZSBncm91cGVkIChieSBsYWJlbCkgaW4gU3dpdGNoQ2FzZVxuICAgIC8vIG5vZGVzLiBgY3VyYCBpcyB1c2VkIHRvIGtlZXAgdGhlIG5vZGUgdGhhdCB3ZSBhcmUgY3VycmVudGx5XG4gICAgLy8gYWRkaW5nIHN0YXRlbWVudHMgdG8uXG5cbiAgICBmb3IgKHZhciBjdXIsIHNhd0RlZmF1bHQgPSBmYWxzZTsgdGhpcy50eXBlICE9IHR0LmJyYWNlUjspIHtcbiAgICAgIGlmICh0aGlzJDEudHlwZSA9PT0gdHQuX2Nhc2UgfHwgdGhpcyQxLnR5cGUgPT09IHR0Ll9kZWZhdWx0KSB7XG4gICAgICAgIHZhciBpc0Nhc2UgPSB0aGlzJDEudHlwZSA9PT0gdHQuX2Nhc2VcbiAgICAgICAgaWYgKGN1cikgdGhpcyQxLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIilcbiAgICAgICAgbm9kZS5jYXNlcy5wdXNoKGN1ciA9IHRoaXMkMS5zdGFydE5vZGUoKSlcbiAgICAgICAgY3VyLmNvbnNlcXVlbnQgPSBbXVxuICAgICAgICB0aGlzJDEubmV4dCgpXG4gICAgICAgIGlmIChpc0Nhc2UpIHtcbiAgICAgICAgICBjdXIudGVzdCA9IHRoaXMkMS5wYXJzZUV4cHJlc3Npb24oKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzYXdEZWZhdWx0KSB0aGlzJDEucmFpc2VSZWNvdmVyYWJsZSh0aGlzJDEubGFzdFRva1N0YXJ0LCBcIk11bHRpcGxlIGRlZmF1bHQgY2xhdXNlc1wiKVxuICAgICAgICAgIHNhd0RlZmF1bHQgPSB0cnVlXG4gICAgICAgICAgY3VyLnRlc3QgPSBudWxsXG4gICAgICAgIH1cbiAgICAgICAgdGhpcyQxLmV4cGVjdCh0dC5jb2xvbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghY3VyKSB0aGlzJDEudW5leHBlY3RlZCgpXG4gICAgICAgIGN1ci5jb25zZXF1ZW50LnB1c2godGhpcyQxLnBhcnNlU3RhdGVtZW50KHRydWUpKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3VyKSB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIilcbiAgICB0aGlzLm5leHQoKSAvLyBDbG9zaW5nIGJyYWNlXG4gICAgdGhpcy5sYWJlbHMucG9wKClcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3dpdGNoU3RhdGVtZW50XCIpXG4gIH1cblxuICBwcCQxLnBhcnNlVGhyb3dTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KClcbiAgICBpZiAobGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKSlcbiAgICAgIHRoaXMucmFpc2UodGhpcy5sYXN0VG9rRW5kLCBcIklsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvd1wiKVxuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpXG4gICAgdGhpcy5zZW1pY29sb24oKVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUaHJvd1N0YXRlbWVudFwiKVxuICB9XG5cbiAgLy8gUmV1c2VkIGVtcHR5IGFycmF5IGFkZGVkIGZvciBub2RlIGZpZWxkcyB0aGF0IGFyZSBhbHdheXMgZW1wdHkuXG5cbiAgdmFyIGVtcHR5ID0gW11cblxuICBwcCQxLnBhcnNlVHJ5U3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpXG4gICAgbm9kZS5ibG9jayA9IHRoaXMucGFyc2VCbG9jaygpXG4gICAgbm9kZS5oYW5kbGVyID0gbnVsbFxuICAgIGlmICh0aGlzLnR5cGUgPT09IHR0Ll9jYXRjaCkge1xuICAgICAgdmFyIGNsYXVzZSA9IHRoaXMuc3RhcnROb2RlKClcbiAgICAgIHRoaXMubmV4dCgpXG4gICAgICB0aGlzLmV4cGVjdCh0dC5wYXJlbkwpXG4gICAgICBjbGF1c2UucGFyYW0gPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKVxuICAgICAgdGhpcy5jaGVja0xWYWwoY2xhdXNlLnBhcmFtLCB0cnVlKVxuICAgICAgdGhpcy5leHBlY3QodHQucGFyZW5SKVxuICAgICAgY2xhdXNlLmJvZHkgPSB0aGlzLnBhcnNlQmxvY2soKVxuICAgICAgbm9kZS5oYW5kbGVyID0gdGhpcy5maW5pc2hOb2RlKGNsYXVzZSwgXCJDYXRjaENsYXVzZVwiKVxuICAgIH1cbiAgICBub2RlLmZpbmFsaXplciA9IHRoaXMuZWF0KHR0Ll9maW5hbGx5KSA/IHRoaXMucGFyc2VCbG9jaygpIDogbnVsbFxuICAgIGlmICghbm9kZS5oYW5kbGVyICYmICFub2RlLmZpbmFsaXplcilcbiAgICAgIHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgY2xhdXNlXCIpXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRyeVN0YXRlbWVudFwiKVxuICB9XG5cbiAgcHAkMS5wYXJzZVZhclN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIGtpbmQpIHtcbiAgICB0aGlzLm5leHQoKVxuICAgIHRoaXMucGFyc2VWYXIobm9kZSwgZmFsc2UsIGtpbmQpXG4gICAgdGhpcy5zZW1pY29sb24oKVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpXG4gIH1cblxuICBwcCQxLnBhcnNlV2hpbGVTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KClcbiAgICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKClcbiAgICB0aGlzLmxhYmVscy5wdXNoKGxvb3BMYWJlbClcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KGZhbHNlKVxuICAgIHRoaXMubGFiZWxzLnBvcCgpXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIldoaWxlU3RhdGVtZW50XCIpXG4gIH1cblxuICBwcCQxLnBhcnNlV2l0aFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAodGhpcy5zdHJpY3QpIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInd2l0aCcgaW4gc3RyaWN0IG1vZGVcIilcbiAgICB0aGlzLm5leHQoKVxuICAgIG5vZGUub2JqZWN0ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpXG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChmYWxzZSlcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2l0aFN0YXRlbWVudFwiKVxuICB9XG5cbiAgcHAkMS5wYXJzZUVtcHR5U3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVtcHR5U3RhdGVtZW50XCIpXG4gIH1cblxuICBwcCQxLnBhcnNlTGFiZWxlZFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUsIG1heWJlTmFtZSwgZXhwcikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxhYmVscy5sZW5ndGg7ICsraSlcbiAgICAgIGlmICh0aGlzJDEubGFiZWxzW2ldLm5hbWUgPT09IG1heWJlTmFtZSkgdGhpcyQxLnJhaXNlKGV4cHIuc3RhcnQsIFwiTGFiZWwgJ1wiICsgbWF5YmVOYW1lICsgXCInIGlzIGFscmVhZHkgZGVjbGFyZWRcIilcbiAgICB2YXIga2luZCA9IHRoaXMudHlwZS5pc0xvb3AgPyBcImxvb3BcIiA6IHRoaXMudHlwZSA9PT0gdHQuX3N3aXRjaCA/IFwic3dpdGNoXCIgOiBudWxsXG4gICAgZm9yICh2YXIgaSQxID0gdGhpcy5sYWJlbHMubGVuZ3RoIC0gMTsgaSQxID49IDA7IGkkMS0tKSB7XG4gICAgICB2YXIgbGFiZWwgPSB0aGlzJDEubGFiZWxzW2kkMV1cbiAgICAgIGlmIChsYWJlbC5zdGF0ZW1lbnRTdGFydCA9PSBub2RlLnN0YXJ0KSB7XG4gICAgICAgIGxhYmVsLnN0YXRlbWVudFN0YXJ0ID0gdGhpcyQxLnN0YXJ0XG4gICAgICAgIGxhYmVsLmtpbmQgPSBraW5kXG4gICAgICB9IGVsc2UgYnJlYWtcbiAgICB9XG4gICAgdGhpcy5sYWJlbHMucHVzaCh7bmFtZTogbWF5YmVOYW1lLCBraW5kOiBraW5kLCBzdGF0ZW1lbnRTdGFydDogdGhpcy5zdGFydH0pXG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudCh0cnVlKVxuICAgIHRoaXMubGFiZWxzLnBvcCgpXG4gICAgbm9kZS5sYWJlbCA9IGV4cHJcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGFiZWxlZFN0YXRlbWVudFwiKVxuICB9XG5cbiAgcHAkMS5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBleHByKSB7XG4gICAgbm9kZS5leHByZXNzaW9uID0gZXhwclxuICAgIHRoaXMuc2VtaWNvbG9uKClcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiKVxuICB9XG5cbiAgLy8gUGFyc2UgYSBzZW1pY29sb24tZW5jbG9zZWQgYmxvY2sgb2Ygc3RhdGVtZW50cywgaGFuZGxpbmcgYFwidXNlXG4gIC8vIHN0cmljdFwiYCBkZWNsYXJhdGlvbnMgd2hlbiBgYWxsb3dTdHJpY3RgIGlzIHRydWUgKHVzZWQgZm9yXG4gIC8vIGZ1bmN0aW9uIGJvZGllcykuXG5cbiAgcHAkMS5wYXJzZUJsb2NrID0gZnVuY3Rpb24oYWxsb3dTdHJpY3QpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgZmlyc3QgPSB0cnVlLCBvbGRTdHJpY3RcbiAgICBub2RlLmJvZHkgPSBbXVxuICAgIHRoaXMuZXhwZWN0KHR0LmJyYWNlTClcbiAgICB3aGlsZSAoIXRoaXMuZWF0KHR0LmJyYWNlUikpIHtcbiAgICAgIHZhciBzdG10ID0gdGhpcyQxLnBhcnNlU3RhdGVtZW50KHRydWUpXG4gICAgICBub2RlLmJvZHkucHVzaChzdG10KVxuICAgICAgaWYgKGZpcnN0ICYmIGFsbG93U3RyaWN0ICYmIHRoaXMkMS5pc1VzZVN0cmljdChzdG10KSkge1xuICAgICAgICBvbGRTdHJpY3QgPSB0aGlzJDEuc3RyaWN0XG4gICAgICAgIHRoaXMkMS5zZXRTdHJpY3QodGhpcyQxLnN0cmljdCA9IHRydWUpXG4gICAgICB9XG4gICAgICBmaXJzdCA9IGZhbHNlXG4gICAgfVxuICAgIGlmIChvbGRTdHJpY3QgPT09IGZhbHNlKSB0aGlzLnNldFN0cmljdChmYWxzZSlcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQmxvY2tTdGF0ZW1lbnRcIilcbiAgfVxuXG4gIC8vIFBhcnNlIGEgcmVndWxhciBgZm9yYCBsb29wLiBUaGUgZGlzYW1iaWd1YXRpb24gY29kZSBpblxuICAvLyBgcGFyc2VTdGF0ZW1lbnRgIHdpbGwgYWxyZWFkeSBoYXZlIHBhcnNlZCB0aGUgaW5pdCBzdGF0ZW1lbnQgb3JcbiAgLy8gZXhwcmVzc2lvbi5cblxuICBwcCQxLnBhcnNlRm9yID0gZnVuY3Rpb24obm9kZSwgaW5pdCkge1xuICAgIG5vZGUuaW5pdCA9IGluaXRcbiAgICB0aGlzLmV4cGVjdCh0dC5zZW1pKVxuICAgIG5vZGUudGVzdCA9IHRoaXMudHlwZSA9PT0gdHQuc2VtaSA/IG51bGwgOiB0aGlzLnBhcnNlRXhwcmVzc2lvbigpXG4gICAgdGhpcy5leHBlY3QodHQuc2VtaSlcbiAgICBub2RlLnVwZGF0ZSA9IHRoaXMudHlwZSA9PT0gdHQucGFyZW5SID8gbnVsbCA6IHRoaXMucGFyc2VFeHByZXNzaW9uKClcbiAgICB0aGlzLmV4cGVjdCh0dC5wYXJlblIpXG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChmYWxzZSlcbiAgICB0aGlzLmxhYmVscy5wb3AoKVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGb3JTdGF0ZW1lbnRcIilcbiAgfVxuXG4gIC8vIFBhcnNlIGEgYGZvcmAvYGluYCBhbmQgYGZvcmAvYG9mYCBsb29wLCB3aGljaCBhcmUgYWxtb3N0XG4gIC8vIHNhbWUgZnJvbSBwYXJzZXIncyBwZXJzcGVjdGl2ZS5cblxuICBwcCQxLnBhcnNlRm9ySW4gPSBmdW5jdGlvbihub2RlLCBpbml0KSB7XG4gICAgdmFyIHR5cGUgPSB0aGlzLnR5cGUgPT09IHR0Ll9pbiA/IFwiRm9ySW5TdGF0ZW1lbnRcIiA6IFwiRm9yT2ZTdGF0ZW1lbnRcIlxuICAgIHRoaXMubmV4dCgpXG4gICAgbm9kZS5sZWZ0ID0gaW5pdFxuICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpXG4gICAgdGhpcy5leHBlY3QodHQucGFyZW5SKVxuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoZmFsc2UpXG4gICAgdGhpcy5sYWJlbHMucG9wKClcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIHR5cGUpXG4gIH1cblxuICAvLyBQYXJzZSBhIGxpc3Qgb2YgdmFyaWFibGUgZGVjbGFyYXRpb25zLlxuXG4gIHBwJDEucGFyc2VWYXIgPSBmdW5jdGlvbihub2RlLCBpc0Zvciwga2luZCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgbm9kZS5kZWNsYXJhdGlvbnMgPSBbXVxuICAgIG5vZGUua2luZCA9IGtpbmRcbiAgICBmb3IgKDs7KSB7XG4gICAgICB2YXIgZGVjbCA9IHRoaXMkMS5zdGFydE5vZGUoKVxuICAgICAgdGhpcyQxLnBhcnNlVmFySWQoZGVjbClcbiAgICAgIGlmICh0aGlzJDEuZWF0KHR0LmVxKSkge1xuICAgICAgICBkZWNsLmluaXQgPSB0aGlzJDEucGFyc2VNYXliZUFzc2lnbihpc0ZvcilcbiAgICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gXCJjb25zdFwiICYmICEodGhpcyQxLnR5cGUgPT09IHR0Ll9pbiB8fCAodGhpcyQxLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiB0aGlzJDEuaXNDb250ZXh0dWFsKFwib2ZcIikpKSkge1xuICAgICAgICB0aGlzJDEudW5leHBlY3RlZCgpXG4gICAgICB9IGVsc2UgaWYgKGRlY2wuaWQudHlwZSAhPSBcIklkZW50aWZpZXJcIiAmJiAhKGlzRm9yICYmICh0aGlzJDEudHlwZSA9PT0gdHQuX2luIHx8IHRoaXMkMS5pc0NvbnRleHR1YWwoXCJvZlwiKSkpKSB7XG4gICAgICAgIHRoaXMkMS5yYWlzZSh0aGlzJDEubGFzdFRva0VuZCwgXCJDb21wbGV4IGJpbmRpbmcgcGF0dGVybnMgcmVxdWlyZSBhbiBpbml0aWFsaXphdGlvbiB2YWx1ZVwiKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVjbC5pbml0ID0gbnVsbFxuICAgICAgfVxuICAgICAgbm9kZS5kZWNsYXJhdGlvbnMucHVzaCh0aGlzJDEuZmluaXNoTm9kZShkZWNsLCBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSlcbiAgICAgIGlmICghdGhpcyQxLmVhdCh0dC5jb21tYSkpIGJyZWFrXG4gICAgfVxuICAgIHJldHVybiBub2RlXG4gIH1cblxuICBwcCQxLnBhcnNlVmFySWQgPSBmdW5jdGlvbihkZWNsKSB7XG4gICAgZGVjbC5pZCA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpXG4gICAgdGhpcy5jaGVja0xWYWwoZGVjbC5pZCwgdHJ1ZSlcbiAgfVxuXG4gIC8vIFBhcnNlIGEgZnVuY3Rpb24gZGVjbGFyYXRpb24gb3IgbGl0ZXJhbCAoZGVwZW5kaW5nIG9uIHRoZVxuICAvLyBgaXNTdGF0ZW1lbnRgIHBhcmFtZXRlcikuXG5cbiAgcHAkMS5wYXJzZUZ1bmN0aW9uID0gZnVuY3Rpb24obm9kZSwgaXNTdGF0ZW1lbnQsIGFsbG93RXhwcmVzc2lvbkJvZHkpIHtcbiAgICB0aGlzLmluaXRGdW5jdGlvbihub2RlKVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNilcbiAgICAgIG5vZGUuZ2VuZXJhdG9yID0gdGhpcy5lYXQodHQuc3RhcilcbiAgICB2YXIgb2xkSW5HZW4gPSB0aGlzLmluR2VuZXJhdG9yXG4gICAgdGhpcy5pbkdlbmVyYXRvciA9IG5vZGUuZ2VuZXJhdG9yXG4gICAgaWYgKGlzU3RhdGVtZW50IHx8IHRoaXMudHlwZSA9PT0gdHQubmFtZSlcbiAgICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnQoKVxuICAgIHRoaXMucGFyc2VGdW5jdGlvblBhcmFtcyhub2RlKVxuICAgIHRoaXMucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgYWxsb3dFeHByZXNzaW9uQm9keSlcbiAgICB0aGlzLmluR2VuZXJhdG9yID0gb2xkSW5HZW5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzU3RhdGVtZW50ID8gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgOiBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKVxuICB9XG5cbiAgcHAkMS5wYXJzZUZ1bmN0aW9uUGFyYW1zID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMuZXhwZWN0KHR0LnBhcmVuTClcbiAgICBub2RlLnBhcmFtcyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0dC5wYXJlblIsIGZhbHNlLCBmYWxzZSwgdHJ1ZSlcbiAgfVxuXG4gIC8vIFBhcnNlIGEgY2xhc3MgZGVjbGFyYXRpb24gb3IgbGl0ZXJhbCAoZGVwZW5kaW5nIG9uIHRoZVxuICAvLyBgaXNTdGF0ZW1lbnRgIHBhcmFtZXRlcikuXG5cbiAgcHAkMS5wYXJzZUNsYXNzID0gZnVuY3Rpb24obm9kZSwgaXNTdGF0ZW1lbnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMubmV4dCgpXG4gICAgdGhpcy5wYXJzZUNsYXNzSWQobm9kZSwgaXNTdGF0ZW1lbnQpXG4gICAgdGhpcy5wYXJzZUNsYXNzU3VwZXIobm9kZSlcbiAgICB2YXIgY2xhc3NCb2R5ID0gdGhpcy5zdGFydE5vZGUoKVxuICAgIHZhciBoYWRDb25zdHJ1Y3RvciA9IGZhbHNlXG4gICAgY2xhc3NCb2R5LmJvZHkgPSBbXVxuICAgIHRoaXMuZXhwZWN0KHR0LmJyYWNlTClcbiAgICB3aGlsZSAoIXRoaXMuZWF0KHR0LmJyYWNlUikpIHtcbiAgICAgIGlmICh0aGlzJDEuZWF0KHR0LnNlbWkpKSBjb250aW51ZVxuICAgICAgdmFyIG1ldGhvZCA9IHRoaXMkMS5zdGFydE5vZGUoKVxuICAgICAgdmFyIGlzR2VuZXJhdG9yID0gdGhpcyQxLmVhdCh0dC5zdGFyKVxuICAgICAgdmFyIGlzTWF5YmVTdGF0aWMgPSB0aGlzJDEudHlwZSA9PT0gdHQubmFtZSAmJiB0aGlzJDEudmFsdWUgPT09IFwic3RhdGljXCJcbiAgICAgIHRoaXMkMS5wYXJzZVByb3BlcnR5TmFtZShtZXRob2QpXG4gICAgICBtZXRob2Quc3RhdGljID0gaXNNYXliZVN0YXRpYyAmJiB0aGlzJDEudHlwZSAhPT0gdHQucGFyZW5MXG4gICAgICBpZiAobWV0aG9kLnN0YXRpYykge1xuICAgICAgICBpZiAoaXNHZW5lcmF0b3IpIHRoaXMkMS51bmV4cGVjdGVkKClcbiAgICAgICAgaXNHZW5lcmF0b3IgPSB0aGlzJDEuZWF0KHR0LnN0YXIpXG4gICAgICAgIHRoaXMkMS5wYXJzZVByb3BlcnR5TmFtZShtZXRob2QpXG4gICAgICB9XG4gICAgICBtZXRob2Qua2luZCA9IFwibWV0aG9kXCJcbiAgICAgIHZhciBpc0dldFNldCA9IGZhbHNlXG4gICAgICBpZiAoIW1ldGhvZC5jb21wdXRlZCkge1xuICAgICAgICB2YXIga2V5ID0gbWV0aG9kLmtleTtcbiAgICAgICAgaWYgKCFpc0dlbmVyYXRvciAmJiBrZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgdGhpcyQxLnR5cGUgIT09IHR0LnBhcmVuTCAmJiAoa2V5Lm5hbWUgPT09IFwiZ2V0XCIgfHwga2V5Lm5hbWUgPT09IFwic2V0XCIpKSB7XG4gICAgICAgICAgaXNHZXRTZXQgPSB0cnVlXG4gICAgICAgICAgbWV0aG9kLmtpbmQgPSBrZXkubmFtZVxuICAgICAgICAgIGtleSA9IHRoaXMkMS5wYXJzZVByb3BlcnR5TmFtZShtZXRob2QpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtZXRob2Quc3RhdGljICYmIChrZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYga2V5Lm5hbWUgPT09IFwiY29uc3RydWN0b3JcIiB8fFxuICAgICAgICAgICAga2V5LnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIGtleS52YWx1ZSA9PT0gXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgICAgICAgIGlmIChoYWRDb25zdHJ1Y3RvcikgdGhpcyQxLnJhaXNlKGtleS5zdGFydCwgXCJEdXBsaWNhdGUgY29uc3RydWN0b3IgaW4gdGhlIHNhbWUgY2xhc3NcIilcbiAgICAgICAgICBpZiAoaXNHZXRTZXQpIHRoaXMkMS5yYWlzZShrZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgaGF2ZSBnZXQvc2V0IG1vZGlmaWVyXCIpXG4gICAgICAgICAgaWYgKGlzR2VuZXJhdG9yKSB0aGlzJDEucmFpc2Uoa2V5LnN0YXJ0LCBcIkNvbnN0cnVjdG9yIGNhbid0IGJlIGEgZ2VuZXJhdG9yXCIpXG4gICAgICAgICAgbWV0aG9kLmtpbmQgPSBcImNvbnN0cnVjdG9yXCJcbiAgICAgICAgICBoYWRDb25zdHJ1Y3RvciA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcyQxLnBhcnNlQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yKVxuICAgICAgaWYgKGlzR2V0U2V0KSB7XG4gICAgICAgIHZhciBwYXJhbUNvdW50ID0gbWV0aG9kLmtpbmQgPT09IFwiZ2V0XCIgPyAwIDogMVxuICAgICAgICBpZiAobWV0aG9kLnZhbHVlLnBhcmFtcy5sZW5ndGggIT09IHBhcmFtQ291bnQpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBtZXRob2QudmFsdWUuc3RhcnRcbiAgICAgICAgICBpZiAobWV0aG9kLmtpbmQgPT09IFwiZ2V0XCIpXG4gICAgICAgICAgICB0aGlzJDEucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJnZXR0ZXIgc2hvdWxkIGhhdmUgbm8gcGFyYW1zXCIpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcyQxLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwic2V0dGVyIHNob3VsZCBoYXZlIGV4YWN0bHkgb25lIHBhcmFtXCIpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZC5raW5kID09PSBcInNldFwiICYmIG1ldGhvZC52YWx1ZS5wYXJhbXNbMF0udHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgICAgICAgIHRoaXMkMS5yYWlzZShtZXRob2QudmFsdWUucGFyYW1zWzBdLnN0YXJ0LCBcIlNldHRlciBjYW5ub3QgdXNlIHJlc3QgcGFyYW1zXCIpXG4gICAgICB9XG4gICAgfVxuICAgIG5vZGUuYm9keSA9IHRoaXMuZmluaXNoTm9kZShjbGFzc0JvZHksIFwiQ2xhc3NCb2R5XCIpXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1N0YXRlbWVudCA/IFwiQ2xhc3NEZWNsYXJhdGlvblwiIDogXCJDbGFzc0V4cHJlc3Npb25cIilcbiAgfVxuXG4gIHBwJDEucGFyc2VDbGFzc01ldGhvZCA9IGZ1bmN0aW9uKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvcikge1xuICAgIG1ldGhvZC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoaXNHZW5lcmF0b3IpXG4gICAgY2xhc3NCb2R5LmJvZHkucHVzaCh0aGlzLmZpbmlzaE5vZGUobWV0aG9kLCBcIk1ldGhvZERlZmluaXRpb25cIikpXG4gIH1cblxuICBwcCQxLnBhcnNlQ2xhc3NJZCA9IGZ1bmN0aW9uKG5vZGUsIGlzU3RhdGVtZW50KSB7XG4gICAgbm9kZS5pZCA9IHRoaXMudHlwZSA9PT0gdHQubmFtZSA/IHRoaXMucGFyc2VJZGVudCgpIDogaXNTdGF0ZW1lbnQgPyB0aGlzLnVuZXhwZWN0ZWQoKSA6IG51bGxcbiAgfVxuXG4gIHBwJDEucGFyc2VDbGFzc1N1cGVyID0gZnVuY3Rpb24obm9kZSkge1xuICAgIG5vZGUuc3VwZXJDbGFzcyA9IHRoaXMuZWF0KHR0Ll9leHRlbmRzKSA/IHRoaXMucGFyc2VFeHByU3Vic2NyaXB0cygpIDogbnVsbFxuICB9XG5cbiAgLy8gUGFyc2VzIG1vZHVsZSBleHBvcnQgZGVjbGFyYXRpb24uXG5cbiAgcHAkMS5wYXJzZUV4cG9ydCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMubmV4dCgpXG4gICAgLy8gZXhwb3J0ICogZnJvbSAnLi4uJ1xuICAgIGlmICh0aGlzLmVhdCh0dC5zdGFyKSkge1xuICAgICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiZnJvbVwiKVxuICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnR5cGUgPT09IHR0LnN0cmluZyA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy51bmV4cGVjdGVkKClcbiAgICAgIHRoaXMuc2VtaWNvbG9uKClcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiKVxuICAgIH1cbiAgICBpZiAodGhpcy5lYXQodHQuX2RlZmF1bHQpKSB7IC8vIGV4cG9ydCBkZWZhdWx0IC4uLlxuICAgICAgdmFyIHBhcmVucyA9IHRoaXMudHlwZSA9PSB0dC5wYXJlbkxcbiAgICAgIHZhciBleHByID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKClcbiAgICAgIHZhciBuZWVkc1NlbWkgPSB0cnVlXG4gICAgICBpZiAoIXBhcmVucyAmJiAoZXhwci50eXBlID09IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICBleHByLnR5cGUgPT0gXCJDbGFzc0V4cHJlc3Npb25cIikpIHtcbiAgICAgICAgbmVlZHNTZW1pID0gZmFsc2VcbiAgICAgICAgaWYgKGV4cHIuaWQpIHtcbiAgICAgICAgICBleHByLnR5cGUgPSBleHByLnR5cGUgPT0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIlxuICAgICAgICAgICAgPyBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIlxuICAgICAgICAgICAgOiBcIkNsYXNzRGVjbGFyYXRpb25cIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gZXhwclxuICAgICAgaWYgKG5lZWRzU2VtaSkgdGhpcy5zZW1pY29sb24oKVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiKVxuICAgIH1cbiAgICAvLyBleHBvcnQgdmFyfGNvbnN0fGxldHxmdW5jdGlvbnxjbGFzcyAuLi5cbiAgICBpZiAodGhpcy5zaG91bGRQYXJzZUV4cG9ydFN0YXRlbWVudCgpKSB7XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZVN0YXRlbWVudCh0cnVlKVxuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gW11cbiAgICAgIG5vZGUuc291cmNlID0gbnVsbFxuICAgIH0gZWxzZSB7IC8vIGV4cG9ydCB7IHgsIHkgYXMgeiB9IFtmcm9tICcuLi4nXVxuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IG51bGxcbiAgICAgIG5vZGUuc3BlY2lmaWVycyA9IHRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXJzKClcbiAgICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoXCJmcm9tXCIpKSB7XG4gICAgICAgIG5vZGUuc291cmNlID0gdGhpcy50eXBlID09PSB0dC5zdHJpbmcgPyB0aGlzLnBhcnNlRXhwckF0b20oKSA6IHRoaXMudW5leHBlY3RlZCgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjaGVjayBmb3Iga2V5d29yZHMgdXNlZCBhcyBsb2NhbCBuYW1lc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuc3BlY2lmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzJDEua2V5d29yZHMudGVzdChub2RlLnNwZWNpZmllcnNbaV0ubG9jYWwubmFtZSkgfHwgdGhpcyQxLnJlc2VydmVkV29yZHMudGVzdChub2RlLnNwZWNpZmllcnNbaV0ubG9jYWwubmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMkMS51bmV4cGVjdGVkKG5vZGUuc3BlY2lmaWVyc1tpXS5sb2NhbC5zdGFydClcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLnNvdXJjZSA9IG51bGxcbiAgICAgIH1cbiAgICAgIHRoaXMuc2VtaWNvbG9uKClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIilcbiAgfVxuXG4gIHBwJDEuc2hvdWxkUGFyc2VFeHBvcnRTdGF0ZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlLmtleXdvcmQgfHwgdGhpcy5pc0xldCgpXG4gIH1cblxuICAvLyBQYXJzZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBtb2R1bGUgZXhwb3J0cy5cblxuICBwcCQxLnBhcnNlRXhwb3J0U3BlY2lmaWVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIG5vZGVzID0gW10sIGZpcnN0ID0gdHJ1ZVxuICAgIC8vIGV4cG9ydCB7IHgsIHkgYXMgeiB9IFtmcm9tICcuLi4nXVxuICAgIHRoaXMuZXhwZWN0KHR0LmJyYWNlTClcbiAgICB3aGlsZSAoIXRoaXMuZWF0KHR0LmJyYWNlUikpIHtcbiAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgdGhpcyQxLmV4cGVjdCh0dC5jb21tYSlcbiAgICAgICAgaWYgKHRoaXMkMS5hZnRlclRyYWlsaW5nQ29tbWEodHQuYnJhY2VSKSkgYnJlYWtcbiAgICAgIH0gZWxzZSBmaXJzdCA9IGZhbHNlXG5cbiAgICAgIHZhciBub2RlID0gdGhpcyQxLnN0YXJ0Tm9kZSgpXG4gICAgICBub2RlLmxvY2FsID0gdGhpcyQxLnBhcnNlSWRlbnQodGhpcyQxLnR5cGUgPT09IHR0Ll9kZWZhdWx0KVxuICAgICAgbm9kZS5leHBvcnRlZCA9IHRoaXMkMS5lYXRDb250ZXh0dWFsKFwiYXNcIikgPyB0aGlzJDEucGFyc2VJZGVudCh0cnVlKSA6IG5vZGUubG9jYWxcbiAgICAgIG5vZGVzLnB1c2godGhpcyQxLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRTcGVjaWZpZXJcIikpXG4gICAgfVxuICAgIHJldHVybiBub2Rlc1xuICB9XG5cbiAgLy8gUGFyc2VzIGltcG9ydCBkZWNsYXJhdGlvbi5cblxuICBwcCQxLnBhcnNlSW1wb3J0ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHRoaXMubmV4dCgpXG4gICAgLy8gaW1wb3J0ICcuLi4nXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gdHQuc3RyaW5nKSB7XG4gICAgICBub2RlLnNwZWNpZmllcnMgPSBlbXB0eVxuICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlRXhwckF0b20oKVxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnNwZWNpZmllcnMgPSB0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVycygpXG4gICAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJmcm9tXCIpXG4gICAgICBub2RlLnNvdXJjZSA9IHRoaXMudHlwZSA9PT0gdHQuc3RyaW5nID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnVuZXhwZWN0ZWQoKVxuICAgIH1cbiAgICB0aGlzLnNlbWljb2xvbigpXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydERlY2xhcmF0aW9uXCIpXG4gIH1cblxuICAvLyBQYXJzZXMgYSBjb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBtb2R1bGUgaW1wb3J0cy5cblxuICBwcCQxLnBhcnNlSW1wb3J0U3BlY2lmaWVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIG5vZGVzID0gW10sIGZpcnN0ID0gdHJ1ZVxuICAgIGlmICh0aGlzLnR5cGUgPT09IHR0Lm5hbWUpIHtcbiAgICAgIC8vIGltcG9ydCBkZWZhdWx0T2JqLCB7IHgsIHkgYXMgeiB9IGZyb20gJy4uLidcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKVxuICAgICAgbm9kZS5sb2NhbCA9IHRoaXMucGFyc2VJZGVudCgpXG4gICAgICB0aGlzLmNoZWNrTFZhbChub2RlLmxvY2FsLCB0cnVlKVxuICAgICAgbm9kZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpKVxuICAgICAgaWYgKCF0aGlzLmVhdCh0dC5jb21tYSkpIHJldHVybiBub2Rlc1xuICAgIH1cbiAgICBpZiAodGhpcy50eXBlID09PSB0dC5zdGFyKSB7XG4gICAgICB2YXIgbm9kZSQxID0gdGhpcy5zdGFydE5vZGUoKVxuICAgICAgdGhpcy5uZXh0KClcbiAgICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImFzXCIpXG4gICAgICBub2RlJDEubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQoKVxuICAgICAgdGhpcy5jaGVja0xWYWwobm9kZSQxLmxvY2FsLCB0cnVlKVxuICAgICAgbm9kZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSQxLCBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKSlcbiAgICAgIHJldHVybiBub2Rlc1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdCh0dC5icmFjZUwpXG4gICAgd2hpbGUgKCF0aGlzLmVhdCh0dC5icmFjZVIpKSB7XG4gICAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIHRoaXMkMS5leHBlY3QodHQuY29tbWEpXG4gICAgICAgIGlmICh0aGlzJDEuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR0LmJyYWNlUikpIGJyZWFrXG4gICAgICB9IGVsc2UgZmlyc3QgPSBmYWxzZVxuXG4gICAgICB2YXIgbm9kZSQyID0gdGhpcyQxLnN0YXJ0Tm9kZSgpXG4gICAgICBub2RlJDIuaW1wb3J0ZWQgPSB0aGlzJDEucGFyc2VJZGVudCh0cnVlKVxuICAgICAgaWYgKHRoaXMkMS5lYXRDb250ZXh0dWFsKFwiYXNcIikpIHtcbiAgICAgICAgbm9kZSQyLmxvY2FsID0gdGhpcyQxLnBhcnNlSWRlbnQoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSQyLmxvY2FsID0gbm9kZSQyLmltcG9ydGVkXG4gICAgICAgIGlmICh0aGlzJDEuaXNLZXl3b3JkKG5vZGUkMi5sb2NhbC5uYW1lKSkgdGhpcyQxLnVuZXhwZWN0ZWQobm9kZSQyLmxvY2FsLnN0YXJ0KVxuICAgICAgICBpZiAodGhpcyQxLnJlc2VydmVkV29yZHNTdHJpY3QudGVzdChub2RlJDIubG9jYWwubmFtZSkpIHRoaXMkMS5yYWlzZShub2RlJDIubG9jYWwuc3RhcnQsIFwiVGhlIGtleXdvcmQgJ1wiICsgbm9kZSQyLmxvY2FsLm5hbWUgKyBcIicgaXMgcmVzZXJ2ZWRcIilcbiAgICAgIH1cbiAgICAgIHRoaXMkMS5jaGVja0xWYWwobm9kZSQyLmxvY2FsLCB0cnVlKVxuICAgICAgbm9kZXMucHVzaCh0aGlzJDEuZmluaXNoTm9kZShub2RlJDIsIFwiSW1wb3J0U3BlY2lmaWVyXCIpKVxuICAgIH1cbiAgICByZXR1cm4gbm9kZXNcbiAgfVxuXG4gIHZhciBwcCQyID0gUGFyc2VyLnByb3RvdHlwZVxuXG4gIC8vIENvbnZlcnQgZXhpc3RpbmcgZXhwcmVzc2lvbiBhdG9tIHRvIGFzc2lnbmFibGUgcGF0dGVyblxuICAvLyBpZiBwb3NzaWJsZS5cblxuICBwcCQyLnRvQXNzaWduYWJsZSA9IGZ1bmN0aW9uKG5vZGUsIGlzQmluZGluZykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIG5vZGUpIHtcbiAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgICAgbm9kZS50eXBlID0gXCJPYmplY3RQYXR0ZXJuXCJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcHJvcCA9IG5vZGUucHJvcGVydGllc1tpXVxuICAgICAgICAgIGlmIChwcm9wLmtpbmQgIT09IFwiaW5pdFwiKSB0aGlzJDEucmFpc2UocHJvcC5rZXkuc3RhcnQsIFwiT2JqZWN0IHBhdHRlcm4gY2FuJ3QgY29udGFpbiBnZXR0ZXIgb3Igc2V0dGVyXCIpXG4gICAgICAgICAgdGhpcyQxLnRvQXNzaWduYWJsZShwcm9wLnZhbHVlLCBpc0JpbmRpbmcpXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgICAgICBub2RlLnR5cGUgPSBcIkFycmF5UGF0dGVyblwiXG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlTGlzdChub2RlLmVsZW1lbnRzLCBpc0JpbmRpbmcpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgICAgICBpZiAobm9kZS5vcGVyYXRvciA9PT0gXCI9XCIpIHtcbiAgICAgICAgICBub2RlLnR5cGUgPSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCJcbiAgICAgICAgICBkZWxldGUgbm9kZS5vcGVyYXRvclxuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2ggdG8gQXNzaWdubWVudFBhdHRlcm5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKG5vZGUubGVmdC5lbmQsIFwiT25seSAnPScgb3BlcmF0b3IgY2FuIGJlIHVzZWQgZm9yIHNwZWNpZnlpbmcgZGVmYXVsdCB2YWx1ZS5cIilcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgICBpZiAobm9kZS5yaWdodC50eXBlID09PSBcIllpZWxkRXhwcmVzc2lvblwiKVxuICAgICAgICAgIHRoaXMucmFpc2Uobm9kZS5yaWdodC5zdGFydCwgXCJZaWVsZCBleHByZXNzaW9uIGNhbm5vdCBiZSBhIGRlZmF1bHQgdmFsdWVcIilcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUuZXhwcmVzc2lvbiwgaXNCaW5kaW5nKVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICBpZiAoIWlzQmluZGluZykgYnJlYWtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIkFzc2lnbmluZyB0byBydmFsdWVcIilcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfVxuXG4gIC8vIENvbnZlcnQgbGlzdCBvZiBleHByZXNzaW9uIGF0b21zIHRvIGJpbmRpbmcgbGlzdC5cblxuICBwcCQyLnRvQXNzaWduYWJsZUxpc3QgPSBmdW5jdGlvbihleHByTGlzdCwgaXNCaW5kaW5nKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgZW5kID0gZXhwckxpc3QubGVuZ3RoXG4gICAgaWYgKGVuZCkge1xuICAgICAgdmFyIGxhc3QgPSBleHByTGlzdFtlbmQgLSAxXVxuICAgICAgaWYgKGxhc3QgJiYgbGFzdC50eXBlID09IFwiUmVzdEVsZW1lbnRcIikge1xuICAgICAgICAtLWVuZFxuICAgICAgfSBlbHNlIGlmIChsYXN0ICYmIGxhc3QudHlwZSA9PSBcIlNwcmVhZEVsZW1lbnRcIikge1xuICAgICAgICBsYXN0LnR5cGUgPSBcIlJlc3RFbGVtZW50XCJcbiAgICAgICAgdmFyIGFyZyA9IGxhc3QuYXJndW1lbnRcbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUoYXJnLCBpc0JpbmRpbmcpXG4gICAgICAgIGlmIChhcmcudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIgJiYgYXJnLnR5cGUgIT09IFwiTWVtYmVyRXhwcmVzc2lvblwiICYmIGFyZy50eXBlICE9PSBcIkFycmF5UGF0dGVyblwiKVxuICAgICAgICAgIHRoaXMudW5leHBlY3RlZChhcmcuc3RhcnQpXG4gICAgICAgIC0tZW5kXG4gICAgICB9XG5cbiAgICAgIGlmIChpc0JpbmRpbmcgJiYgbGFzdCAmJiBsYXN0LnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIiAmJiBsYXN0LmFyZ3VtZW50LnR5cGUgIT09IFwiSWRlbnRpZmllclwiKVxuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQobGFzdC5hcmd1bWVudC5zdGFydClcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdmFyIGVsdCA9IGV4cHJMaXN0W2ldXG4gICAgICBpZiAoZWx0KSB0aGlzJDEudG9Bc3NpZ25hYmxlKGVsdCwgaXNCaW5kaW5nKVxuICAgIH1cbiAgICByZXR1cm4gZXhwckxpc3RcbiAgfVxuXG4gIC8vIFBhcnNlcyBzcHJlYWQgZWxlbWVudC5cblxuICBwcCQyLnBhcnNlU3ByZWFkID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKVxuICAgIHRoaXMubmV4dCgpXG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycylcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3ByZWFkRWxlbWVudFwiKVxuICB9XG5cbiAgcHAkMi5wYXJzZVJlc3QgPSBmdW5jdGlvbihhbGxvd05vbklkZW50KSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpXG4gICAgdGhpcy5uZXh0KClcblxuICAgIC8vIFJlc3RFbGVtZW50IGluc2lkZSBvZiBhIGZ1bmN0aW9uIHBhcmFtZXRlciBtdXN0IGJlIGFuIGlkZW50aWZpZXJcbiAgICBpZiAoYWxsb3dOb25JZGVudCkgbm9kZS5hcmd1bWVudCA9IHRoaXMudHlwZSA9PT0gdHQubmFtZSA/IHRoaXMucGFyc2VJZGVudCgpIDogdGhpcy51bmV4cGVjdGVkKClcbiAgICBlbHNlIG5vZGUuYXJndW1lbnQgPSB0aGlzLnR5cGUgPT09IHR0Lm5hbWUgfHwgdGhpcy50eXBlID09PSB0dC5icmFja2V0TCA/IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpIDogdGhpcy51bmV4cGVjdGVkKClcblxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXN0RWxlbWVudFwiKVxuICB9XG5cbiAgLy8gUGFyc2VzIGx2YWx1ZSAoYXNzaWduYWJsZSkgYXRvbS5cblxuICBwcCQyLnBhcnNlQmluZGluZ0F0b20gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNikgcmV0dXJuIHRoaXMucGFyc2VJZGVudCgpXG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICBjYXNlIHR0Lm5hbWU6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUlkZW50KClcblxuICAgIGNhc2UgdHQuYnJhY2tldEw6XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKClcbiAgICAgIHRoaXMubmV4dCgpXG4gICAgICBub2RlLmVsZW1lbnRzID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR0LmJyYWNrZXRSLCB0cnVlLCB0cnVlKVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycmF5UGF0dGVyblwiKVxuXG4gICAgY2FzZSB0dC5icmFjZUw6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZU9iaih0cnVlKVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpXG4gICAgfVxuICB9XG5cbiAgcHAkMi5wYXJzZUJpbmRpbmdMaXN0ID0gZnVuY3Rpb24oY2xvc2UsIGFsbG93RW1wdHksIGFsbG93VHJhaWxpbmdDb21tYSwgYWxsb3dOb25JZGVudCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGVsdHMgPSBbXSwgZmlyc3QgPSB0cnVlXG4gICAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICAgIGlmIChmaXJzdCkgZmlyc3QgPSBmYWxzZVxuICAgICAgZWxzZSB0aGlzJDEuZXhwZWN0KHR0LmNvbW1hKVxuICAgICAgaWYgKGFsbG93RW1wdHkgJiYgdGhpcyQxLnR5cGUgPT09IHR0LmNvbW1hKSB7XG4gICAgICAgIGVsdHMucHVzaChudWxsKVxuICAgICAgfSBlbHNlIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcyQxLmFmdGVyVHJhaWxpbmdDb21tYShjbG9zZSkpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSBpZiAodGhpcyQxLnR5cGUgPT09IHR0LmVsbGlwc2lzKSB7XG4gICAgICAgIHZhciByZXN0ID0gdGhpcyQxLnBhcnNlUmVzdChhbGxvd05vbklkZW50KVxuICAgICAgICB0aGlzJDEucGFyc2VCaW5kaW5nTGlzdEl0ZW0ocmVzdClcbiAgICAgICAgZWx0cy5wdXNoKHJlc3QpXG4gICAgICAgIGlmICh0aGlzJDEudHlwZSA9PT0gdHQuY29tbWEpIHRoaXMkMS5yYWlzZSh0aGlzJDEuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpXG4gICAgICAgIHRoaXMkMS5leHBlY3QoY2xvc2UpXG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZWxlbSA9IHRoaXMkMS5wYXJzZU1heWJlRGVmYXVsdCh0aGlzJDEuc3RhcnQsIHRoaXMkMS5zdGFydExvYylcbiAgICAgICAgdGhpcyQxLnBhcnNlQmluZGluZ0xpc3RJdGVtKGVsZW0pXG4gICAgICAgIGVsdHMucHVzaChlbGVtKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWx0c1xuICB9XG5cbiAgcHAkMi5wYXJzZUJpbmRpbmdMaXN0SXRlbSA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgcmV0dXJuIHBhcmFtXG4gIH1cblxuICAvLyBQYXJzZXMgYXNzaWdubWVudCBwYXR0ZXJuIGFyb3VuZCBnaXZlbiBhdG9tIGlmIHBvc3NpYmxlLlxuXG4gIHBwJDIucGFyc2VNYXliZURlZmF1bHQgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGxlZnQpIHtcbiAgICBsZWZ0ID0gbGVmdCB8fCB0aGlzLnBhcnNlQmluZGluZ0F0b20oKVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2IHx8ICF0aGlzLmVhdCh0dC5lcSkpIHJldHVybiBsZWZ0XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYylcbiAgICBub2RlLmxlZnQgPSBsZWZ0XG4gICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpXG4gIH1cblxuICAvLyBWZXJpZnkgdGhhdCBhIG5vZGUgaXMgYW4gbHZhbCDigJQgc29tZXRoaW5nIHRoYXQgY2FuIGJlIGFzc2lnbmVkXG4gIC8vIHRvLlxuXG4gIHBwJDIuY2hlY2tMVmFsID0gZnVuY3Rpb24oZXhwciwgaXNCaW5kaW5nLCBjaGVja0NsYXNoZXMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHN3aXRjaCAoZXhwci50eXBlKSB7XG4gICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgIGlmICh0aGlzLnN0cmljdCAmJiB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3RCaW5kLnRlc3QoZXhwci5uYW1lKSlcbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIChpc0JpbmRpbmcgPyBcIkJpbmRpbmcgXCIgOiBcIkFzc2lnbmluZyB0byBcIikgKyBleHByLm5hbWUgKyBcIiBpbiBzdHJpY3QgbW9kZVwiKVxuICAgICAgaWYgKGNoZWNrQ2xhc2hlcykge1xuICAgICAgICBpZiAoaGFzKGNoZWNrQ2xhc2hlcywgZXhwci5uYW1lKSlcbiAgICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgXCJBcmd1bWVudCBuYW1lIGNsYXNoXCIpXG4gICAgICAgIGNoZWNrQ2xhc2hlc1tleHByLm5hbWVdID0gdHJ1ZVxuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICBpZiAoaXNCaW5kaW5nKSB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgKGlzQmluZGluZyA/IFwiQmluZGluZ1wiIDogXCJBc3NpZ25pbmcgdG9cIikgKyBcIiBtZW1iZXIgZXhwcmVzc2lvblwiKVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHIucHJvcGVydGllcy5sZW5ndGg7IGkrKylcbiAgICAgICAgdGhpcyQxLmNoZWNrTFZhbChleHByLnByb3BlcnRpZXNbaV0udmFsdWUsIGlzQmluZGluZywgY2hlY2tDbGFzaGVzKVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGV4cHIuZWxlbWVudHMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICB2YXIgZWxlbSA9IGV4cHIuZWxlbWVudHNbaSQxXVxuICAgICAgICBpZiAoZWxlbSkgdGhpcyQxLmNoZWNrTFZhbChlbGVtLCBpc0JpbmRpbmcsIGNoZWNrQ2xhc2hlcylcbiAgICAgIH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIubGVmdCwgaXNCaW5kaW5nLCBjaGVja0NsYXNoZXMpXG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICB0aGlzLmNoZWNrTFZhbChleHByLmFyZ3VtZW50LCBpc0JpbmRpbmcsIGNoZWNrQ2xhc2hlcylcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGV4cHIuZXhwcmVzc2lvbiwgaXNCaW5kaW5nLCBjaGVja0NsYXNoZXMpXG4gICAgICBicmVha1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMucmFpc2UoZXhwci5zdGFydCwgKGlzQmluZGluZyA/IFwiQmluZGluZ1wiIDogXCJBc3NpZ25pbmcgdG9cIikgKyBcIiBydmFsdWVcIilcbiAgICB9XG4gIH1cblxuICB2YXIgcHAkMyA9IFBhcnNlci5wcm90b3R5cGVcblxuICAvLyBDaGVjayBpZiBwcm9wZXJ0eSBuYW1lIGNsYXNoZXMgd2l0aCBhbHJlYWR5IGFkZGVkLlxuICAvLyBPYmplY3QvY2xhc3MgZ2V0dGVycyBhbmQgc2V0dGVycyBhcmUgbm90IGFsbG93ZWQgdG8gY2xhc2gg4oCUXG4gIC8vIGVpdGhlciB3aXRoIGVhY2ggb3RoZXIgb3Igd2l0aCBhbiBpbml0IHByb3BlcnR5IOKAlCBhbmQgaW5cbiAgLy8gc3RyaWN0IG1vZGUsIGluaXQgcHJvcGVydGllcyBhcmUgYWxzbyBub3QgYWxsb3dlZCB0byBiZSByZXBlYXRlZC5cblxuICBwcCQzLmNoZWNrUHJvcENsYXNoID0gZnVuY3Rpb24ocHJvcCwgcHJvcEhhc2gpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgKHByb3AuY29tcHV0ZWQgfHwgcHJvcC5tZXRob2QgfHwgcHJvcC5zaG9ydGhhbmQpKVxuICAgICAgcmV0dXJuXG4gICAgdmFyIGtleSA9IHByb3Aua2V5O1xuICAgIHZhciBuYW1lXG4gICAgc3dpdGNoIChrZXkudHlwZSkge1xuICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6IG5hbWUgPSBrZXkubmFtZTsgYnJlYWtcbiAgICBjYXNlIFwiTGl0ZXJhbFwiOiBuYW1lID0gU3RyaW5nKGtleS52YWx1ZSk7IGJyZWFrXG4gICAgZGVmYXVsdDogcmV0dXJuXG4gICAgfVxuICAgIHZhciBraW5kID0gcHJvcC5raW5kO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgaWYgKG5hbWUgPT09IFwiX19wcm90b19fXCIgJiYga2luZCA9PT0gXCJpbml0XCIpIHtcbiAgICAgICAgaWYgKHByb3BIYXNoLnByb3RvKSB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoa2V5LnN0YXJ0LCBcIlJlZGVmaW5pdGlvbiBvZiBfX3Byb3RvX18gcHJvcGVydHlcIilcbiAgICAgICAgcHJvcEhhc2gucHJvdG8gPSB0cnVlXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgbmFtZSA9IFwiJFwiICsgbmFtZVxuICAgIHZhciBvdGhlciA9IHByb3BIYXNoW25hbWVdXG4gICAgaWYgKG90aGVyKSB7XG4gICAgICB2YXIgaXNHZXRTZXQgPSBraW5kICE9PSBcImluaXRcIlxuICAgICAgaWYgKCh0aGlzLnN0cmljdCB8fCBpc0dldFNldCkgJiYgb3RoZXJba2luZF0gfHwgIShpc0dldFNldCBeIG90aGVyLmluaXQpKVxuICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoa2V5LnN0YXJ0LCBcIlJlZGVmaW5pdGlvbiBvZiBwcm9wZXJ0eVwiKVxuICAgIH0gZWxzZSB7XG4gICAgICBvdGhlciA9IHByb3BIYXNoW25hbWVdID0ge1xuICAgICAgICBpbml0OiBmYWxzZSxcbiAgICAgICAgZ2V0OiBmYWxzZSxcbiAgICAgICAgc2V0OiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBvdGhlcltraW5kXSA9IHRydWVcbiAgfVxuXG4gIC8vICMjIyBFeHByZXNzaW9uIHBhcnNpbmdcblxuICAvLyBUaGVzZSBuZXN0LCBmcm9tIHRoZSBtb3N0IGdlbmVyYWwgZXhwcmVzc2lvbiB0eXBlIGF0IHRoZSB0b3AgdG9cbiAgLy8gJ2F0b21pYycsIG5vbmRpdmlzaWJsZSBleHByZXNzaW9uIHR5cGVzIGF0IHRoZSBib3R0b20uIE1vc3Qgb2ZcbiAgLy8gdGhlIGZ1bmN0aW9ucyB3aWxsIHNpbXBseSBsZXQgdGhlIGZ1bmN0aW9uKHMpIGJlbG93IHRoZW0gcGFyc2UsXG4gIC8vIGFuZCwgKmlmKiB0aGUgc3ludGFjdGljIGNvbnN0cnVjdCB0aGV5IGhhbmRsZSBpcyBwcmVzZW50LCB3cmFwXG4gIC8vIHRoZSBBU1Qgbm9kZSB0aGF0IHRoZSBpbm5lciBwYXJzZXIgZ2F2ZSB0aGVtIGluIGFub3RoZXIgbm9kZS5cblxuICAvLyBQYXJzZSBhIGZ1bGwgZXhwcmVzc2lvbi4gVGhlIG9wdGlvbmFsIGFyZ3VtZW50cyBhcmUgdXNlZCB0b1xuICAvLyBmb3JiaWQgdGhlIGBpbmAgb3BlcmF0b3IgKGluIGZvciBsb29wcyBpbml0YWxpemF0aW9uIGV4cHJlc3Npb25zKVxuICAvLyBhbmQgcHJvdmlkZSByZWZlcmVuY2UgZm9yIHN0b3JpbmcgJz0nIG9wZXJhdG9yIGluc2lkZSBzaG9ydGhhbmRcbiAgLy8gcHJvcGVydHkgYXNzaWdubWVudCBpbiBjb250ZXh0cyB3aGVyZSBib3RoIG9iamVjdCBleHByZXNzaW9uXG4gIC8vIGFuZCBvYmplY3QgcGF0dGVybiBtaWdodCBhcHBlYXIgKHNvIGl0J3MgcG9zc2libGUgdG8gcmFpc2VcbiAgLy8gZGVsYXllZCBzeW50YXggZXJyb3IgYXQgY29ycmVjdCBwb3NpdGlvbikuXG5cbiAgcHAkMy5wYXJzZUV4cHJlc3Npb24gPSBmdW5jdGlvbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2NcbiAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VNYXliZUFzc2lnbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKVxuICAgIGlmICh0aGlzLnR5cGUgPT09IHR0LmNvbW1hKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKVxuICAgICAgbm9kZS5leHByZXNzaW9ucyA9IFtleHByXVxuICAgICAgd2hpbGUgKHRoaXMuZWF0KHR0LmNvbW1hKSkgbm9kZS5leHByZXNzaW9ucy5wdXNoKHRoaXMkMS5wYXJzZU1heWJlQXNzaWduKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpKVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgICByZXR1cm4gZXhwclxuICB9XG5cbiAgLy8gUGFyc2UgYW4gYXNzaWdubWVudCBleHByZXNzaW9uLiBUaGlzIGluY2x1ZGVzIGFwcGxpY2F0aW9ucyBvZlxuICAvLyBvcGVyYXRvcnMgbGlrZSBgKz1gLlxuXG4gIHBwJDMucGFyc2VNYXliZUFzc2lnbiA9IGZ1bmN0aW9uKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSB7XG4gICAgaWYgKHRoaXMuaW5HZW5lcmF0b3IgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJ5aWVsZFwiKSkgcmV0dXJuIHRoaXMucGFyc2VZaWVsZCgpXG5cbiAgICB2YXIgb3duRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IGZhbHNlXG4gICAgaWYgKCFyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnNcbiAgICAgIG93bkRlc3RydWN0dXJpbmdFcnJvcnMgPSB0cnVlXG4gICAgfVxuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvY1xuICAgIGlmICh0aGlzLnR5cGUgPT0gdHQucGFyZW5MIHx8IHRoaXMudHlwZSA9PSB0dC5uYW1lKVxuICAgICAgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGFydFxuICAgIHZhciBsZWZ0ID0gdGhpcy5wYXJzZU1heWJlQ29uZGl0aW9uYWwobm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycylcbiAgICBpZiAoYWZ0ZXJMZWZ0UGFyc2UpIGxlZnQgPSBhZnRlckxlZnRQYXJzZS5jYWxsKHRoaXMsIGxlZnQsIHN0YXJ0UG9zLCBzdGFydExvYylcbiAgICBpZiAodGhpcy50eXBlLmlzQXNzaWduKSB7XG4gICAgICB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKVxuICAgICAgaWYgKCFvd25EZXN0cnVjdHVyaW5nRXJyb3JzKSBEZXN0cnVjdHVyaW5nRXJyb3JzLmNhbGwocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycylcbiAgICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpXG4gICAgICBub2RlLm9wZXJhdG9yID0gdGhpcy52YWx1ZVxuICAgICAgbm9kZS5sZWZ0ID0gdGhpcy50eXBlID09PSB0dC5lcSA/IHRoaXMudG9Bc3NpZ25hYmxlKGxlZnQpIDogbGVmdFxuICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24gPSAwIC8vIHJlc2V0IGJlY2F1c2Ugc2hvcnRoYW5kIGRlZmF1bHQgd2FzIHVzZWQgY29ycmVjdGx5XG4gICAgICB0aGlzLmNoZWNrTFZhbChsZWZ0KVxuICAgICAgdGhpcy5uZXh0KClcbiAgICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9JbilcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3duRGVzdHJ1Y3R1cmluZ0Vycm9ycykgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSlcbiAgICB9XG4gICAgcmV0dXJuIGxlZnRcbiAgfVxuXG4gIC8vIFBhcnNlIGEgdGVybmFyeSBjb25kaXRpb25hbCAoYD86YCkgb3BlcmF0b3IuXG5cbiAgcHAkMy5wYXJzZU1heWJlQ29uZGl0aW9uYWwgPSBmdW5jdGlvbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jXG4gICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwck9wcyhub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKVxuICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgcmV0dXJuIGV4cHJcbiAgICBpZiAodGhpcy5lYXQodHQucXVlc3Rpb24pKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKVxuICAgICAgbm9kZS50ZXN0ID0gZXhwclxuICAgICAgbm9kZS5jb25zZXF1ZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKClcbiAgICAgIHRoaXMuZXhwZWN0KHR0LmNvbG9uKVxuICAgICAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9JbilcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIilcbiAgICB9XG4gICAgcmV0dXJuIGV4cHJcbiAgfVxuXG4gIC8vIFN0YXJ0IHRoZSBwcmVjZWRlbmNlIHBhcnNlci5cblxuICBwcCQzLnBhcnNlRXhwck9wcyA9IGZ1bmN0aW9uKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2NcbiAgICB2YXIgZXhwciA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZhbHNlKVxuICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgcmV0dXJuIGV4cHJcbiAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJPcChleHByLCBzdGFydFBvcywgc3RhcnRMb2MsIC0xLCBub0luKVxuICB9XG5cbiAgLy8gUGFyc2UgYmluYXJ5IG9wZXJhdG9ycyB3aXRoIHRoZSBvcGVyYXRvciBwcmVjZWRlbmNlIHBhcnNpbmdcbiAgLy8gYWxnb3JpdGhtLiBgbGVmdGAgaXMgdGhlIGxlZnQtaGFuZCBzaWRlIG9mIHRoZSBvcGVyYXRvci5cbiAgLy8gYG1pblByZWNgIHByb3ZpZGVzIGNvbnRleHQgdGhhdCBhbGxvd3MgdGhlIGZ1bmN0aW9uIHRvIHN0b3AgYW5kXG4gIC8vIGRlZmVyIGZ1cnRoZXIgcGFyc2VyIHRvIG9uZSBvZiBpdHMgY2FsbGVycyB3aGVuIGl0IGVuY291bnRlcnMgYW5cbiAgLy8gb3BlcmF0b3IgdGhhdCBoYXMgYSBsb3dlciBwcmVjZWRlbmNlIHRoYW4gdGhlIHNldCBpdCBpcyBwYXJzaW5nLlxuXG4gIHBwJDMucGFyc2VFeHByT3AgPSBmdW5jdGlvbihsZWZ0LCBsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbWluUHJlYywgbm9Jbikge1xuICAgIHZhciBwcmVjID0gdGhpcy50eXBlLmJpbm9wXG4gICAgaWYgKHByZWMgIT0gbnVsbCAmJiAoIW5vSW4gfHwgdGhpcy50eXBlICE9PSB0dC5faW4pKSB7XG4gICAgICBpZiAocHJlYyA+IG1pblByZWMpIHtcbiAgICAgICAgdmFyIGxvZ2ljYWwgPSB0aGlzLnR5cGUgPT09IHR0LmxvZ2ljYWxPUiB8fCB0aGlzLnR5cGUgPT09IHR0LmxvZ2ljYWxBTkRcbiAgICAgICAgdmFyIG9wID0gdGhpcy52YWx1ZVxuICAgICAgICB0aGlzLm5leHQoKVxuICAgICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2NcbiAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5wYXJzZUV4cHJPcCh0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCBmYWxzZSksIHN0YXJ0UG9zLCBzdGFydExvYywgcHJlYywgbm9JbilcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJ1aWxkQmluYXJ5KGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBsZWZ0LCByaWdodCwgb3AsIGxvZ2ljYWwpXG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwck9wKG5vZGUsIGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjLCBub0luKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVmdFxuICB9XG5cbiAgcHAkMy5idWlsZEJpbmFyeSA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgbGVmdCwgcmlnaHQsIG9wLCBsb2dpY2FsKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYylcbiAgICBub2RlLmxlZnQgPSBsZWZ0XG4gICAgbm9kZS5vcGVyYXRvciA9IG9wXG4gICAgbm9kZS5yaWdodCA9IHJpZ2h0XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBsb2dpY2FsID8gXCJMb2dpY2FsRXhwcmVzc2lvblwiIDogXCJCaW5hcnlFeHByZXNzaW9uXCIpXG4gIH1cblxuICAvLyBQYXJzZSB1bmFyeSBvcGVyYXRvcnMsIGJvdGggcHJlZml4IGFuZCBwb3N0Zml4LlxuXG4gIHBwJDMucGFyc2VNYXliZVVuYXJ5ID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgc2F3VW5hcnkpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYywgZXhwclxuICAgIGlmICh0aGlzLnR5cGUucHJlZml4KSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIHVwZGF0ZSA9IHRoaXMudHlwZSA9PT0gdHQuaW5jRGVjXG4gICAgICBub2RlLm9wZXJhdG9yID0gdGhpcy52YWx1ZVxuICAgICAgbm9kZS5wcmVmaXggPSB0cnVlXG4gICAgICB0aGlzLm5leHQoKVxuICAgICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIHRydWUpXG4gICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKVxuICAgICAgaWYgKHVwZGF0ZSkgdGhpcy5jaGVja0xWYWwobm9kZS5hcmd1bWVudClcbiAgICAgIGVsc2UgaWYgKHRoaXMuc3RyaWN0ICYmIG5vZGUub3BlcmF0b3IgPT09IFwiZGVsZXRlXCIgJiZcbiAgICAgICAgICAgICAgIG5vZGUuYXJndW1lbnQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpXG4gICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShub2RlLnN0YXJ0LCBcIkRlbGV0aW5nIGxvY2FsIHZhcmlhYmxlIGluIHN0cmljdCBtb2RlXCIpXG4gICAgICBlbHNlIHNhd1VuYXJ5ID0gdHJ1ZVxuICAgICAgZXhwciA9IHRoaXMuZmluaXNoTm9kZShub2RlLCB1cGRhdGUgPyBcIlVwZGF0ZUV4cHJlc3Npb25cIiA6IFwiVW5hcnlFeHByZXNzaW9uXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cHIgPSB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycylcbiAgICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSkgcmV0dXJuIGV4cHJcbiAgICAgIHdoaWxlICh0aGlzLnR5cGUucG9zdGZpeCAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgICB2YXIgbm9kZSQxID0gdGhpcyQxLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYylcbiAgICAgICAgbm9kZSQxLm9wZXJhdG9yID0gdGhpcyQxLnZhbHVlXG4gICAgICAgIG5vZGUkMS5wcmVmaXggPSBmYWxzZVxuICAgICAgICBub2RlJDEuYXJndW1lbnQgPSBleHByXG4gICAgICAgIHRoaXMkMS5jaGVja0xWYWwoZXhwcilcbiAgICAgICAgdGhpcyQxLm5leHQoKVxuICAgICAgICBleHByID0gdGhpcyQxLmZpbmlzaE5vZGUobm9kZSQxLCBcIlVwZGF0ZUV4cHJlc3Npb25cIilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXNhd1VuYXJ5ICYmIHRoaXMuZWF0KHR0LnN0YXJzdGFyKSlcbiAgICAgIHJldHVybiB0aGlzLmJ1aWxkQmluYXJ5KHN0YXJ0UG9zLCBzdGFydExvYywgZXhwciwgdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgZmFsc2UpLCBcIioqXCIsIGZhbHNlKVxuICAgIGVsc2VcbiAgICAgIHJldHVybiBleHByXG4gIH1cblxuICAvLyBQYXJzZSBjYWxsLCBkb3QsIGFuZCBgW11gLXN1YnNjcmlwdCBleHByZXNzaW9ucy5cblxuICBwcCQzLnBhcnNlRXhwclN1YnNjcmlwdHMgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jXG4gICAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwckF0b20ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycylcbiAgICB2YXIgc2tpcEFycm93U3Vic2NyaXB0cyA9IGV4cHIudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiICYmIHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rU3RhcnQsIHRoaXMubGFzdFRva0VuZCkgIT09IFwiKVwiXG4gICAgaWYgKHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHx8IHNraXBBcnJvd1N1YnNjcmlwdHMpIHJldHVybiBleHByXG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdWJzY3JpcHRzKGV4cHIsIHN0YXJ0UG9zLCBzdGFydExvYylcbiAgfVxuXG4gIHBwJDMucGFyc2VTdWJzY3JpcHRzID0gZnVuY3Rpb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAodGhpcyQxLmVhdCh0dC5kb3QpKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcyQxLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYylcbiAgICAgICAgbm9kZS5vYmplY3QgPSBiYXNlXG4gICAgICAgIG5vZGUucHJvcGVydHkgPSB0aGlzJDEucGFyc2VJZGVudCh0cnVlKVxuICAgICAgICBub2RlLmNvbXB1dGVkID0gZmFsc2VcbiAgICAgICAgYmFzZSA9IHRoaXMkMS5maW5pc2hOb2RlKG5vZGUsIFwiTWVtYmVyRXhwcmVzc2lvblwiKVxuICAgICAgfSBlbHNlIGlmICh0aGlzJDEuZWF0KHR0LmJyYWNrZXRMKSkge1xuICAgICAgICB2YXIgbm9kZSQxID0gdGhpcyQxLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYylcbiAgICAgICAgbm9kZSQxLm9iamVjdCA9IGJhc2VcbiAgICAgICAgbm9kZSQxLnByb3BlcnR5ID0gdGhpcyQxLnBhcnNlRXhwcmVzc2lvbigpXG4gICAgICAgIG5vZGUkMS5jb21wdXRlZCA9IHRydWVcbiAgICAgICAgdGhpcyQxLmV4cGVjdCh0dC5icmFja2V0UilcbiAgICAgICAgYmFzZSA9IHRoaXMkMS5maW5pc2hOb2RlKG5vZGUkMSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpXG4gICAgICB9IGVsc2UgaWYgKCFub0NhbGxzICYmIHRoaXMkMS5lYXQodHQucGFyZW5MKSkge1xuICAgICAgICB2YXIgbm9kZSQyID0gdGhpcyQxLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYylcbiAgICAgICAgbm9kZSQyLmNhbGxlZSA9IGJhc2VcbiAgICAgICAgbm9kZSQyLmFyZ3VtZW50cyA9IHRoaXMkMS5wYXJzZUV4cHJMaXN0KHR0LnBhcmVuUiwgZmFsc2UpXG4gICAgICAgIGJhc2UgPSB0aGlzJDEuZmluaXNoTm9kZShub2RlJDIsIFwiQ2FsbEV4cHJlc3Npb25cIilcbiAgICAgIH0gZWxzZSBpZiAodGhpcyQxLnR5cGUgPT09IHR0LmJhY2tRdW90ZSkge1xuICAgICAgICB2YXIgbm9kZSQzID0gdGhpcyQxLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYylcbiAgICAgICAgbm9kZSQzLnRhZyA9IGJhc2VcbiAgICAgICAgbm9kZSQzLnF1YXNpID0gdGhpcyQxLnBhcnNlVGVtcGxhdGUoKVxuICAgICAgICBiYXNlID0gdGhpcyQxLmZpbmlzaE5vZGUobm9kZSQzLCBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJhc2VcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBQYXJzZSBhbiBhdG9taWMgZXhwcmVzc2lvbiDigJQgZWl0aGVyIGEgc2luZ2xlIHRva2VuIHRoYXQgaXMgYW5cbiAgLy8gZXhwcmVzc2lvbiwgYW4gZXhwcmVzc2lvbiBzdGFydGVkIGJ5IGEga2V5d29yZCBsaWtlIGBmdW5jdGlvbmAgb3JcbiAgLy8gYG5ld2AsIG9yIGFuIGV4cHJlc3Npb24gd3JhcHBlZCBpbiBwdW5jdHVhdGlvbiBsaWtlIGAoKWAsIGBbXWAsXG4gIC8vIG9yIGB7fWAuXG5cbiAgcHAkMy5wYXJzZUV4cHJBdG9tID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciBub2RlLCBjYW5CZUFycm93ID0gdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID09IHRoaXMuc3RhcnRcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgIGNhc2UgdHQuX3N1cGVyOlxuICAgICAgaWYgKCF0aGlzLmluRnVuY3Rpb24pXG4gICAgICAgIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInc3VwZXInIG91dHNpZGUgb2YgZnVuY3Rpb24gb3IgY2xhc3NcIilcblxuICAgIGNhc2UgdHQuX3RoaXM6XG4gICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZSA9PT0gdHQuX3RoaXMgPyBcIlRoaXNFeHByZXNzaW9uXCIgOiBcIlN1cGVyXCJcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpXG4gICAgICB0aGlzLm5leHQoKVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCB0eXBlKVxuXG4gICAgY2FzZSB0dC5uYW1lOlxuICAgICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jXG4gICAgICB2YXIgaWQgPSB0aGlzLnBhcnNlSWRlbnQodGhpcy50eXBlICE9PSB0dC5uYW1lKVxuICAgICAgaWYgKGNhbkJlQXJyb3cgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgJiYgdGhpcy5lYXQodHQuYXJyb3cpKVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIFtpZF0pXG4gICAgICByZXR1cm4gaWRcblxuICAgIGNhc2UgdHQucmVnZXhwOlxuICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZVxuICAgICAgbm9kZSA9IHRoaXMucGFyc2VMaXRlcmFsKHZhbHVlLnZhbHVlKVxuICAgICAgbm9kZS5yZWdleCA9IHtwYXR0ZXJuOiB2YWx1ZS5wYXR0ZXJuLCBmbGFnczogdmFsdWUuZmxhZ3N9XG4gICAgICByZXR1cm4gbm9kZVxuXG4gICAgY2FzZSB0dC5udW06IGNhc2UgdHQuc3RyaW5nOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHRoaXMudmFsdWUpXG5cbiAgICBjYXNlIHR0Ll9udWxsOiBjYXNlIHR0Ll90cnVlOiBjYXNlIHR0Ll9mYWxzZTpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpXG4gICAgICBub2RlLnZhbHVlID0gdGhpcy50eXBlID09PSB0dC5fbnVsbCA/IG51bGwgOiB0aGlzLnR5cGUgPT09IHR0Ll90cnVlXG4gICAgICBub2RlLnJhdyA9IHRoaXMudHlwZS5rZXl3b3JkXG4gICAgICB0aGlzLm5leHQoKVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIilcblxuICAgIGNhc2UgdHQucGFyZW5MOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93KVxuXG4gICAgY2FzZSB0dC5icmFja2V0TDpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpXG4gICAgICB0aGlzLm5leHQoKVxuICAgICAgbm9kZS5lbGVtZW50cyA9IHRoaXMucGFyc2VFeHByTGlzdCh0dC5icmFja2V0UiwgdHJ1ZSwgdHJ1ZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycylcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJheUV4cHJlc3Npb25cIilcblxuICAgIGNhc2UgdHQuYnJhY2VMOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmooZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpXG5cbiAgICBjYXNlIHR0Ll9mdW5jdGlvbjpcbiAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpXG4gICAgICB0aGlzLm5leHQoKVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCBmYWxzZSlcblxuICAgIGNhc2UgdHQuX2NsYXNzOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyh0aGlzLnN0YXJ0Tm9kZSgpLCBmYWxzZSlcblxuICAgIGNhc2UgdHQuX25ldzpcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlTmV3KClcblxuICAgIGNhc2UgdHQuYmFja1F1b3RlOlxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VUZW1wbGF0ZSgpXG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy51bmV4cGVjdGVkKClcbiAgICB9XG4gIH1cblxuICBwcCQzLnBhcnNlTGl0ZXJhbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpXG4gICAgbm9kZS52YWx1ZSA9IHZhbHVlXG4gICAgbm9kZS5yYXcgPSB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKVxuICAgIHRoaXMubmV4dCgpXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIilcbiAgfVxuXG4gIHBwJDMucGFyc2VQYXJlbkV4cHJlc3Npb24gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmV4cGVjdCh0dC5wYXJlbkwpXG4gICAgdmFyIHZhbCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKClcbiAgICB0aGlzLmV4cGVjdCh0dC5wYXJlblIpXG4gICAgcmV0dXJuIHZhbFxuICB9XG5cbiAgcHAkMy5wYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uID0gZnVuY3Rpb24oY2FuQmVBcnJvdykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jLCB2YWxcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgIHRoaXMubmV4dCgpXG5cbiAgICAgIHZhciBpbm5lclN0YXJ0UG9zID0gdGhpcy5zdGFydCwgaW5uZXJTdGFydExvYyA9IHRoaXMuc3RhcnRMb2NcbiAgICAgIHZhciBleHByTGlzdCA9IFtdLCBmaXJzdCA9IHRydWVcbiAgICAgIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnMsIHNwcmVhZFN0YXJ0LCBpbm5lclBhcmVuU3RhcnRcbiAgICAgIHdoaWxlICh0aGlzLnR5cGUgIT09IHR0LnBhcmVuUikge1xuICAgICAgICBmaXJzdCA/IGZpcnN0ID0gZmFsc2UgOiB0aGlzJDEuZXhwZWN0KHR0LmNvbW1hKVxuICAgICAgICBpZiAodGhpcyQxLnR5cGUgPT09IHR0LmVsbGlwc2lzKSB7XG4gICAgICAgICAgc3ByZWFkU3RhcnQgPSB0aGlzJDEuc3RhcnRcbiAgICAgICAgICBleHByTGlzdC5wdXNoKHRoaXMkMS5wYXJzZVBhcmVuSXRlbSh0aGlzJDEucGFyc2VSZXN0KCkpKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMkMS50eXBlID09PSB0dC5wYXJlbkwgJiYgIWlubmVyUGFyZW5TdGFydCkge1xuICAgICAgICAgICAgaW5uZXJQYXJlblN0YXJ0ID0gdGhpcyQxLnN0YXJ0XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cHJMaXN0LnB1c2godGhpcyQxLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRoaXMkMS5wYXJzZVBhcmVuSXRlbSkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBpbm5lckVuZFBvcyA9IHRoaXMuc3RhcnQsIGlubmVyRW5kTG9jID0gdGhpcy5zdGFydExvY1xuICAgICAgdGhpcy5leHBlY3QodHQucGFyZW5SKVxuXG4gICAgICBpZiAoY2FuQmVBcnJvdyAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiB0aGlzLmVhdCh0dC5hcnJvdykpIHtcbiAgICAgICAgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSlcbiAgICAgICAgaWYgKGlubmVyUGFyZW5TdGFydCkgdGhpcy51bmV4cGVjdGVkKGlubmVyUGFyZW5TdGFydClcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQYXJlbkFycm93TGlzdChzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJMaXN0KVxuICAgICAgfVxuXG4gICAgICBpZiAoIWV4cHJMaXN0Lmxlbmd0aCkgdGhpcy51bmV4cGVjdGVkKHRoaXMubGFzdFRva1N0YXJ0KVxuICAgICAgaWYgKHNwcmVhZFN0YXJ0KSB0aGlzLnVuZXhwZWN0ZWQoc3ByZWFkU3RhcnQpXG4gICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKVxuXG4gICAgICBpZiAoZXhwckxpc3QubGVuZ3RoID4gMSkge1xuICAgICAgICB2YWwgPSB0aGlzLnN0YXJ0Tm9kZUF0KGlubmVyU3RhcnRQb3MsIGlubmVyU3RhcnRMb2MpXG4gICAgICAgIHZhbC5leHByZXNzaW9ucyA9IGV4cHJMaXN0XG4gICAgICAgIHRoaXMuZmluaXNoTm9kZUF0KHZhbCwgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIiwgaW5uZXJFbmRQb3MsIGlubmVyRW5kTG9jKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gZXhwckxpc3RbMF1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5wcmVzZXJ2ZVBhcmVucykge1xuICAgICAgdmFyIHBhciA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKVxuICAgICAgcGFyLmV4cHJlc3Npb24gPSB2YWxcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocGFyLCBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWxcbiAgICB9XG4gIH1cblxuICBwcCQzLnBhcnNlUGFyZW5JdGVtID0gZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiBpdGVtXG4gIH1cblxuICBwcCQzLnBhcnNlUGFyZW5BcnJvd0xpc3QgPSBmdW5jdGlvbihzdGFydFBvcywgc3RhcnRMb2MsIGV4cHJMaXN0KSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBleHByTGlzdClcbiAgfVxuXG4gIC8vIE5ldydzIHByZWNlZGVuY2UgaXMgc2xpZ2h0bHkgdHJpY2t5LiBJdCBtdXN0IGFsbG93IGl0cyBhcmd1bWVudCB0b1xuICAvLyBiZSBhIGBbXWAgb3IgZG90IHN1YnNjcmlwdCBleHByZXNzaW9uLCBidXQgbm90IGEgY2FsbCDigJQgYXQgbGVhc3QsXG4gIC8vIG5vdCB3aXRob3V0IHdyYXBwaW5nIGl0IGluIHBhcmVudGhlc2VzLiBUaHVzLCBpdCB1c2VzIHRoZSBub0NhbGxzXG4gIC8vIGFyZ3VtZW50IHRvIHBhcnNlU3Vic2NyaXB0cyB0byBwcmV2ZW50IGl0IGZyb20gY29uc3VtaW5nIHRoZVxuICAvLyBhcmd1bWVudCBsaXN0LlxuXG4gIHZhciBlbXB0eSQxID0gW11cblxuICBwcCQzLnBhcnNlTmV3ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpXG4gICAgdmFyIG1ldGEgPSB0aGlzLnBhcnNlSWRlbnQodHJ1ZSlcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5lYXQodHQuZG90KSkge1xuICAgICAgbm9kZS5tZXRhID0gbWV0YVxuICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudCh0cnVlKVxuICAgICAgaWYgKG5vZGUucHJvcGVydHkubmFtZSAhPT0gXCJ0YXJnZXRcIilcbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUucHJvcGVydHkuc3RhcnQsIFwiVGhlIG9ubHkgdmFsaWQgbWV0YSBwcm9wZXJ0eSBmb3IgbmV3IGlzIG5ldy50YXJnZXRcIilcbiAgICAgIGlmICghdGhpcy5pbkZ1bmN0aW9uKVxuICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJuZXcudGFyZ2V0IGNhbiBvbmx5IGJlIHVzZWQgaW4gZnVuY3Rpb25zXCIpXG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWV0YVByb3BlcnR5XCIpXG4gICAgfVxuICAgIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvY1xuICAgIG5vZGUuY2FsbGVlID0gdGhpcy5wYXJzZVN1YnNjcmlwdHModGhpcy5wYXJzZUV4cHJBdG9tKCksIHN0YXJ0UG9zLCBzdGFydExvYywgdHJ1ZSlcbiAgICBpZiAodGhpcy5lYXQodHQucGFyZW5MKSkgbm9kZS5hcmd1bWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QodHQucGFyZW5SLCBmYWxzZSlcbiAgICBlbHNlIG5vZGUuYXJndW1lbnRzID0gZW1wdHkkMVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJOZXdFeHByZXNzaW9uXCIpXG4gIH1cblxuICAvLyBQYXJzZSB0ZW1wbGF0ZSBleHByZXNzaW9uLlxuXG4gIHBwJDMucGFyc2VUZW1wbGF0ZUVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZWxlbSA9IHRoaXMuc3RhcnROb2RlKClcbiAgICBlbGVtLnZhbHVlID0ge1xuICAgICAgcmF3OiB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKS5yZXBsYWNlKC9cXHJcXG4/L2csICdcXG4nKSxcbiAgICAgIGNvb2tlZDogdGhpcy52YWx1ZVxuICAgIH1cbiAgICB0aGlzLm5leHQoKVxuICAgIGVsZW0udGFpbCA9IHRoaXMudHlwZSA9PT0gdHQuYmFja1F1b3RlXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShlbGVtLCBcIlRlbXBsYXRlRWxlbWVudFwiKVxuICB9XG5cbiAgcHAkMy5wYXJzZVRlbXBsYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKClcbiAgICB0aGlzLm5leHQoKVxuICAgIG5vZGUuZXhwcmVzc2lvbnMgPSBbXVxuICAgIHZhciBjdXJFbHQgPSB0aGlzLnBhcnNlVGVtcGxhdGVFbGVtZW50KClcbiAgICBub2RlLnF1YXNpcyA9IFtjdXJFbHRdXG4gICAgd2hpbGUgKCFjdXJFbHQudGFpbCkge1xuICAgICAgdGhpcyQxLmV4cGVjdCh0dC5kb2xsYXJCcmFjZUwpXG4gICAgICBub2RlLmV4cHJlc3Npb25zLnB1c2godGhpcyQxLnBhcnNlRXhwcmVzc2lvbigpKVxuICAgICAgdGhpcyQxLmV4cGVjdCh0dC5icmFjZVIpXG4gICAgICBub2RlLnF1YXNpcy5wdXNoKGN1ckVsdCA9IHRoaXMkMS5wYXJzZVRlbXBsYXRlRWxlbWVudCgpKVxuICAgIH1cbiAgICB0aGlzLm5leHQoKVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUZW1wbGF0ZUxpdGVyYWxcIilcbiAgfVxuXG4gIC8vIFBhcnNlIGFuIG9iamVjdCBsaXRlcmFsIG9yIGJpbmRpbmcgcGF0dGVybi5cblxuICBwcCQzLnBhcnNlT2JqID0gZnVuY3Rpb24oaXNQYXR0ZXJuLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIGZpcnN0ID0gdHJ1ZSwgcHJvcEhhc2ggPSB7fVxuICAgIG5vZGUucHJvcGVydGllcyA9IFtdXG4gICAgdGhpcy5uZXh0KClcbiAgICB3aGlsZSAoIXRoaXMuZWF0KHR0LmJyYWNlUikpIHtcbiAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgdGhpcyQxLmV4cGVjdCh0dC5jb21tYSlcbiAgICAgICAgaWYgKHRoaXMkMS5hZnRlclRyYWlsaW5nQ29tbWEodHQuYnJhY2VSKSkgYnJlYWtcbiAgICAgIH0gZWxzZSBmaXJzdCA9IGZhbHNlXG5cbiAgICAgIHZhciBwcm9wID0gdGhpcyQxLnN0YXJ0Tm9kZSgpLCBpc0dlbmVyYXRvciwgc3RhcnRQb3MsIHN0YXJ0TG9jXG4gICAgICBpZiAodGhpcyQxLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgICAgICBwcm9wLm1ldGhvZCA9IGZhbHNlXG4gICAgICAgIHByb3Auc2hvcnRoYW5kID0gZmFsc2VcbiAgICAgICAgaWYgKGlzUGF0dGVybiB8fCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgICAgc3RhcnRQb3MgPSB0aGlzJDEuc3RhcnRcbiAgICAgICAgICBzdGFydExvYyA9IHRoaXMkMS5zdGFydExvY1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNQYXR0ZXJuKVxuICAgICAgICAgIGlzR2VuZXJhdG9yID0gdGhpcyQxLmVhdCh0dC5zdGFyKVxuICAgICAgfVxuICAgICAgdGhpcyQxLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApXG4gICAgICB0aGlzJDEucGFyc2VQcm9wZXJ0eVZhbHVlKHByb3AsIGlzUGF0dGVybiwgaXNHZW5lcmF0b3IsIHN0YXJ0UG9zLCBzdGFydExvYywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycylcbiAgICAgIHRoaXMkMS5jaGVja1Byb3BDbGFzaChwcm9wLCBwcm9wSGFzaClcbiAgICAgIG5vZGUucHJvcGVydGllcy5wdXNoKHRoaXMkMS5maW5pc2hOb2RlKHByb3AsIFwiUHJvcGVydHlcIikpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNQYXR0ZXJuID8gXCJPYmplY3RQYXR0ZXJuXCIgOiBcIk9iamVjdEV4cHJlc3Npb25cIilcbiAgfVxuXG4gIHBwJDMucGFyc2VQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24ocHJvcCwgaXNQYXR0ZXJuLCBpc0dlbmVyYXRvciwgc3RhcnRQb3MsIHN0YXJ0TG9jLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgaWYgKHRoaXMuZWF0KHR0LmNvbG9uKSkge1xuICAgICAgcHJvcC52YWx1ZSA9IGlzUGF0dGVybiA/IHRoaXMucGFyc2VNYXliZURlZmF1bHQodGhpcy5zdGFydCwgdGhpcy5zdGFydExvYykgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpXG4gICAgICBwcm9wLmtpbmQgPSBcImluaXRcIlxuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy50eXBlID09PSB0dC5wYXJlbkwpIHtcbiAgICAgIGlmIChpc1BhdHRlcm4pIHRoaXMudW5leHBlY3RlZCgpXG4gICAgICBwcm9wLmtpbmQgPSBcImluaXRcIlxuICAgICAgcHJvcC5tZXRob2QgPSB0cnVlXG4gICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChpc0dlbmVyYXRvcilcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmXG4gICAgICAgICAgICAgICAocHJvcC5rZXkubmFtZSA9PT0gXCJnZXRcIiB8fCBwcm9wLmtleS5uYW1lID09PSBcInNldFwiKSAmJlxuICAgICAgICAgICAgICAgKHRoaXMudHlwZSAhPSB0dC5jb21tYSAmJiB0aGlzLnR5cGUgIT0gdHQuYnJhY2VSKSkge1xuICAgICAgaWYgKGlzR2VuZXJhdG9yIHx8IGlzUGF0dGVybikgdGhpcy51bmV4cGVjdGVkKClcbiAgICAgIHByb3Aua2luZCA9IHByb3Aua2V5Lm5hbWVcbiAgICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcClcbiAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGZhbHNlKVxuICAgICAgdmFyIHBhcmFtQ291bnQgPSBwcm9wLmtpbmQgPT09IFwiZ2V0XCIgPyAwIDogMVxuICAgICAgaWYgKHByb3AudmFsdWUucGFyYW1zLmxlbmd0aCAhPT0gcGFyYW1Db3VudCkge1xuICAgICAgICB2YXIgc3RhcnQgPSBwcm9wLnZhbHVlLnN0YXJ0XG4gICAgICAgIGlmIChwcm9wLmtpbmQgPT09IFwiZ2V0XCIpXG4gICAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcImdldHRlciBzaG91bGQgaGF2ZSBubyBwYXJhbXNcIilcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJzZXR0ZXIgc2hvdWxkIGhhdmUgZXhhY3RseSBvbmUgcGFyYW1cIilcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wLmtpbmQgPT09IFwic2V0XCIgJiYgcHJvcC52YWx1ZS5wYXJhbXNbMF0udHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocHJvcC52YWx1ZS5wYXJhbXNbMF0uc3RhcnQsIFwiU2V0dGVyIGNhbm5vdCB1c2UgcmVzdCBwYXJhbXNcIilcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICBpZiAodGhpcy5rZXl3b3Jkcy50ZXN0KHByb3Aua2V5Lm5hbWUpIHx8XG4gICAgICAgICAgKHRoaXMuc3RyaWN0ID8gdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0QmluZCA6IHRoaXMucmVzZXJ2ZWRXb3JkcykudGVzdChwcm9wLmtleS5uYW1lKSB8fFxuICAgICAgICAgICh0aGlzLmluR2VuZXJhdG9yICYmIHByb3Aua2V5Lm5hbWUgPT0gXCJ5aWVsZFwiKSlcbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHByb3Aua2V5LnN0YXJ0LCBcIidcIiArIHByb3Aua2V5Lm5hbWUgKyBcIicgY2FuIG5vdCBiZSB1c2VkIGFzIHNob3J0aGFuZCBwcm9wZXJ0eVwiKVxuICAgICAgcHJvcC5raW5kID0gXCJpbml0XCJcbiAgICAgIGlmIChpc1BhdHRlcm4pIHtcbiAgICAgICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQoc3RhcnRQb3MsIHN0YXJ0TG9jLCBwcm9wLmtleSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSB0dC5lcSAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICAgIGlmICghcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24pXG4gICAgICAgICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24gPSB0aGlzLnN0YXJ0XG4gICAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgcHJvcC5rZXkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wLnZhbHVlID0gcHJvcC5rZXlcbiAgICAgIH1cbiAgICAgIHByb3Auc2hvcnRoYW5kID0gdHJ1ZVxuICAgIH0gZWxzZSB0aGlzLnVuZXhwZWN0ZWQoKVxuICB9XG5cbiAgcHAkMy5wYXJzZVByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgIGlmICh0aGlzLmVhdCh0dC5icmFja2V0TCkpIHtcbiAgICAgICAgcHJvcC5jb21wdXRlZCA9IHRydWVcbiAgICAgICAgcHJvcC5rZXkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKVxuICAgICAgICB0aGlzLmV4cGVjdCh0dC5icmFja2V0UilcbiAgICAgICAgcmV0dXJuIHByb3Aua2V5XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wLmNvbXB1dGVkID0gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3Aua2V5ID0gdGhpcy50eXBlID09PSB0dC5udW0gfHwgdGhpcy50eXBlID09PSB0dC5zdHJpbmcgPyB0aGlzLnBhcnNlRXhwckF0b20oKSA6IHRoaXMucGFyc2VJZGVudCh0cnVlKVxuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBlbXB0eSBmdW5jdGlvbiBub2RlLlxuXG4gIHBwJDMuaW5pdEZ1bmN0aW9uID0gZnVuY3Rpb24obm9kZSkge1xuICAgIG5vZGUuaWQgPSBudWxsXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICBub2RlLmdlbmVyYXRvciA9IGZhbHNlXG4gICAgICBub2RlLmV4cHJlc3Npb24gPSBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIFBhcnNlIG9iamVjdCBvciBjbGFzcyBtZXRob2QuXG5cbiAgcHAkMy5wYXJzZU1ldGhvZCA9IGZ1bmN0aW9uKGlzR2VuZXJhdG9yKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCBvbGRJbkdlbiA9IHRoaXMuaW5HZW5lcmF0b3JcbiAgICB0aGlzLmluR2VuZXJhdG9yID0gaXNHZW5lcmF0b3JcbiAgICB0aGlzLmluaXRGdW5jdGlvbihub2RlKVxuICAgIHRoaXMuZXhwZWN0KHR0LnBhcmVuTClcbiAgICBub2RlLnBhcmFtcyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCh0dC5wYXJlblIsIGZhbHNlLCBmYWxzZSlcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpXG4gICAgICBub2RlLmdlbmVyYXRvciA9IGlzR2VuZXJhdG9yXG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCBmYWxzZSlcbiAgICB0aGlzLmluR2VuZXJhdG9yID0gb2xkSW5HZW5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpXG4gIH1cblxuICAvLyBQYXJzZSBhcnJvdyBmdW5jdGlvbiBleHByZXNzaW9uIHdpdGggZ2l2ZW4gcGFyYW1ldGVycy5cblxuICBwcCQzLnBhcnNlQXJyb3dFeHByZXNzaW9uID0gZnVuY3Rpb24obm9kZSwgcGFyYW1zKSB7XG4gICAgdmFyIG9sZEluR2VuID0gdGhpcy5pbkdlbmVyYXRvclxuICAgIHRoaXMuaW5HZW5lcmF0b3IgPSBmYWxzZVxuICAgIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpXG4gICAgbm9kZS5wYXJhbXMgPSB0aGlzLnRvQXNzaWduYWJsZUxpc3QocGFyYW1zLCB0cnVlKVxuICAgIHRoaXMucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgdHJ1ZSlcbiAgICB0aGlzLmluR2VuZXJhdG9yID0gb2xkSW5HZW5cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIilcbiAgfVxuXG4gIC8vIFBhcnNlIGZ1bmN0aW9uIGJvZHkgYW5kIGNoZWNrIHBhcmFtZXRlcnMuXG5cbiAgcHAkMy5wYXJzZUZ1bmN0aW9uQm9keSA9IGZ1bmN0aW9uKG5vZGUsIGlzQXJyb3dGdW5jdGlvbikge1xuICAgIHZhciBpc0V4cHJlc3Npb24gPSBpc0Fycm93RnVuY3Rpb24gJiYgdGhpcy50eXBlICE9PSB0dC5icmFjZUxcblxuICAgIGlmIChpc0V4cHJlc3Npb24pIHtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpXG4gICAgICBub2RlLmV4cHJlc3Npb24gPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0YXJ0IGEgbmV3IHNjb3BlIHdpdGggcmVnYXJkIHRvIGxhYmVscyBhbmQgdGhlIGBpbkZ1bmN0aW9uYFxuICAgICAgLy8gZmxhZyAocmVzdG9yZSB0aGVtIHRvIHRoZWlyIG9sZCB2YWx1ZSBhZnRlcndhcmRzKS5cbiAgICAgIHZhciBvbGRJbkZ1bmMgPSB0aGlzLmluRnVuY3Rpb24sIG9sZExhYmVscyA9IHRoaXMubGFiZWxzXG4gICAgICB0aGlzLmluRnVuY3Rpb24gPSB0cnVlOyB0aGlzLmxhYmVscyA9IFtdXG4gICAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlQmxvY2sodHJ1ZSlcbiAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IGZhbHNlXG4gICAgICB0aGlzLmluRnVuY3Rpb24gPSBvbGRJbkZ1bmM7IHRoaXMubGFiZWxzID0gb2xkTGFiZWxzXG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyBpcyBhIHN0cmljdCBtb2RlIGZ1bmN0aW9uLCB2ZXJpZnkgdGhhdCBhcmd1bWVudCBuYW1lc1xuICAgIC8vIGFyZSBub3QgcmVwZWF0ZWQsIGFuZCBpdCBkb2VzIG5vdCB0cnkgdG8gYmluZCB0aGUgd29yZHMgYGV2YWxgXG4gICAgLy8gb3IgYGFyZ3VtZW50c2AuXG4gICAgdmFyIHVzZVN0cmljdCA9ICghaXNFeHByZXNzaW9uICYmIG5vZGUuYm9keS5ib2R5Lmxlbmd0aCAmJiB0aGlzLmlzVXNlU3RyaWN0KG5vZGUuYm9keS5ib2R5WzBdKSkgPyBub2RlLmJvZHkuYm9keVswXSA6IG51bGw7XG4gICAgaWYgKHRoaXMuc3RyaWN0IHx8IHVzZVN0cmljdCkge1xuICAgICAgdmFyIG9sZFN0cmljdCA9IHRoaXMuc3RyaWN0XG4gICAgICB0aGlzLnN0cmljdCA9IHRydWVcbiAgICAgIGlmIChub2RlLmlkKVxuICAgICAgICB0aGlzLmNoZWNrTFZhbChub2RlLmlkLCB0cnVlKVxuICAgICAgdGhpcy5jaGVja1BhcmFtcyhub2RlLCB1c2VTdHJpY3QpXG4gICAgICB0aGlzLnN0cmljdCA9IG9sZFN0cmljdFxuICAgIH0gZWxzZSBpZiAoaXNBcnJvd0Z1bmN0aW9uKSB7XG4gICAgICB0aGlzLmNoZWNrUGFyYW1zKG5vZGUsIHVzZVN0cmljdClcbiAgICB9XG4gIH1cblxuICAvLyBDaGVja3MgZnVuY3Rpb24gcGFyYW1zIGZvciB2YXJpb3VzIGRpc2FsbG93ZWQgcGF0dGVybnMgc3VjaCBhcyB1c2luZyBcImV2YWxcIlxuICAvLyBvciBcImFyZ3VtZW50c1wiIGFuZCBkdXBsaWNhdGUgcGFyYW1ldGVycy5cblxuICBwcCQzLmNoZWNrUGFyYW1zID0gZnVuY3Rpb24obm9kZSwgdXNlU3RyaWN0KSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdmFyIG5hbWVIYXNoID0ge31cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5wYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHVzZVN0cmljdCAmJiB0aGlzJDEub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA3ICYmIG5vZGUucGFyYW1zW2ldLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKVxuICAgICAgICAgIHRoaXMkMS5yYWlzZVJlY292ZXJhYmxlKHVzZVN0cmljdC5zdGFydCwgXCJJbGxlZ2FsICd1c2Ugc3RyaWN0JyBkaXJlY3RpdmUgaW4gZnVuY3Rpb24gd2l0aCBub24tc2ltcGxlIHBhcmFtZXRlciBsaXN0XCIpO1xuICAgICAgICB0aGlzJDEuY2hlY2tMVmFsKG5vZGUucGFyYW1zW2ldLCB0cnVlLCBuYW1lSGFzaClcbiAgICAgIH1cbiAgfVxuXG4gIC8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGV4cHJlc3Npb25zLCBhbmQgcmV0dXJucyB0aGVtIGFzXG4gIC8vIGFuIGFycmF5LiBgY2xvc2VgIGlzIHRoZSB0b2tlbiB0eXBlIHRoYXQgZW5kcyB0aGUgbGlzdCwgYW5kXG4gIC8vIGBhbGxvd0VtcHR5YCBjYW4gYmUgdHVybmVkIG9uIHRvIGFsbG93IHN1YnNlcXVlbnQgY29tbWFzIHdpdGhcbiAgLy8gbm90aGluZyBpbiBiZXR3ZWVuIHRoZW0gdG8gYmUgcGFyc2VkIGFzIGBudWxsYCAod2hpY2ggaXMgbmVlZGVkXG4gIC8vIGZvciBhcnJheSBsaXRlcmFscykuXG5cbiAgcHAkMy5wYXJzZUV4cHJMaXN0ID0gZnVuY3Rpb24oY2xvc2UsIGFsbG93VHJhaWxpbmdDb21tYSwgYWxsb3dFbXB0eSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGVsdHMgPSBbXSwgZmlyc3QgPSB0cnVlXG4gICAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgdGhpcyQxLmV4cGVjdCh0dC5jb21tYSlcbiAgICAgICAgaWYgKGFsbG93VHJhaWxpbmdDb21tYSAmJiB0aGlzJDEuYWZ0ZXJUcmFpbGluZ0NvbW1hKGNsb3NlKSkgYnJlYWtcbiAgICAgIH0gZWxzZSBmaXJzdCA9IGZhbHNlXG5cbiAgICAgIHZhciBlbHRcbiAgICAgIGlmIChhbGxvd0VtcHR5ICYmIHRoaXMkMS50eXBlID09PSB0dC5jb21tYSlcbiAgICAgICAgZWx0ID0gbnVsbFxuICAgICAgZWxzZSBpZiAodGhpcyQxLnR5cGUgPT09IHR0LmVsbGlwc2lzKSB7XG4gICAgICAgIGVsdCA9IHRoaXMkMS5wYXJzZVNwcmVhZChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKVxuICAgICAgICBpZiAodGhpcyQxLnR5cGUgPT09IHR0LmNvbW1hICYmIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgJiYgIXJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSkge1xuICAgICAgICAgIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IHRoaXMkMS5sYXN0VG9rU3RhcnRcbiAgICAgICAgfVxuICAgICAgfSBlbHNlXG4gICAgICAgIGVsdCA9IHRoaXMkMS5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKVxuICAgICAgZWx0cy5wdXNoKGVsdClcbiAgICB9XG4gICAgcmV0dXJuIGVsdHNcbiAgfVxuXG4gIC8vIFBhcnNlIHRoZSBuZXh0IHRva2VuIGFzIGFuIGlkZW50aWZpZXIuIElmIGBsaWJlcmFsYCBpcyB0cnVlICh1c2VkXG4gIC8vIHdoZW4gcGFyc2luZyBwcm9wZXJ0aWVzKSwgaXQgd2lsbCBhbHNvIGNvbnZlcnQga2V5d29yZHMgaW50b1xuICAvLyBpZGVudGlmaWVycy5cblxuICBwcCQzLnBhcnNlSWRlbnQgPSBmdW5jdGlvbihsaWJlcmFsKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpXG4gICAgaWYgKGxpYmVyYWwgJiYgdGhpcy5vcHRpb25zLmFsbG93UmVzZXJ2ZWQgPT0gXCJuZXZlclwiKSBsaWJlcmFsID0gZmFsc2VcbiAgICBpZiAodGhpcy50eXBlID09PSB0dC5uYW1lKSB7XG4gICAgICBpZiAoIWxpYmVyYWwgJiYgKHRoaXMuc3RyaWN0ID8gdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0IDogdGhpcy5yZXNlcnZlZFdvcmRzKS50ZXN0KHRoaXMudmFsdWUpICYmXG4gICAgICAgICAgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2IHx8XG4gICAgICAgICAgIHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5lbmQpLmluZGV4T2YoXCJcXFxcXCIpID09IC0xKSlcbiAgICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiVGhlIGtleXdvcmQgJ1wiICsgdGhpcy52YWx1ZSArIFwiJyBpcyByZXNlcnZlZFwiKVxuICAgICAgaWYgKCFsaWJlcmFsICYmIHRoaXMuaW5HZW5lcmF0b3IgJiYgdGhpcy52YWx1ZSA9PT0gXCJ5aWVsZFwiKVxuICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJDYW4gbm90IHVzZSAneWllbGQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGEgZ2VuZXJhdG9yXCIpXG4gICAgICBub2RlLm5hbWUgPSB0aGlzLnZhbHVlXG4gICAgfSBlbHNlIGlmIChsaWJlcmFsICYmIHRoaXMudHlwZS5rZXl3b3JkKSB7XG4gICAgICBub2RlLm5hbWUgPSB0aGlzLnR5cGUua2V5d29yZFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKVxuICAgIH1cbiAgICB0aGlzLm5leHQoKVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZGVudGlmaWVyXCIpXG4gIH1cblxuICAvLyBQYXJzZXMgeWllbGQgZXhwcmVzc2lvbiBpbnNpZGUgZ2VuZXJhdG9yLlxuXG4gIHBwJDMucGFyc2VZaWVsZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKVxuICAgIHRoaXMubmV4dCgpXG4gICAgaWYgKHRoaXMudHlwZSA9PSB0dC5zZW1pIHx8IHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgfHwgKHRoaXMudHlwZSAhPSB0dC5zdGFyICYmICF0aGlzLnR5cGUuc3RhcnRzRXhwcikpIHtcbiAgICAgIG5vZGUuZGVsZWdhdGUgPSBmYWxzZVxuICAgICAgbm9kZS5hcmd1bWVudCA9IG51bGxcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5kZWxlZ2F0ZSA9IHRoaXMuZWF0KHR0LnN0YXIpXG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIllpZWxkRXhwcmVzc2lvblwiKVxuICB9XG5cbiAgdmFyIHBwJDQgPSBQYXJzZXIucHJvdG90eXBlXG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHJhaXNlIGV4Y2VwdGlvbnMgb24gcGFyc2UgZXJyb3JzLiBJdFxuICAvLyB0YWtlcyBhbiBvZmZzZXQgaW50ZWdlciAoaW50byB0aGUgY3VycmVudCBgaW5wdXRgKSB0byBpbmRpY2F0ZVxuICAvLyB0aGUgbG9jYXRpb24gb2YgdGhlIGVycm9yLCBhdHRhY2hlcyB0aGUgcG9zaXRpb24gdG8gdGhlIGVuZFxuICAvLyBvZiB0aGUgZXJyb3IgbWVzc2FnZSwgYW5kIHRoZW4gcmFpc2VzIGEgYFN5bnRheEVycm9yYCB3aXRoIHRoYXRcbiAgLy8gbWVzc2FnZS5cblxuICBwcCQ0LnJhaXNlID0gZnVuY3Rpb24ocG9zLCBtZXNzYWdlKSB7XG4gICAgdmFyIGxvYyA9IGdldExpbmVJbmZvKHRoaXMuaW5wdXQsIHBvcylcbiAgICBtZXNzYWdlICs9IFwiIChcIiArIGxvYy5saW5lICsgXCI6XCIgKyBsb2MuY29sdW1uICsgXCIpXCJcbiAgICB2YXIgZXJyID0gbmV3IFN5bnRheEVycm9yKG1lc3NhZ2UpXG4gICAgZXJyLnBvcyA9IHBvczsgZXJyLmxvYyA9IGxvYzsgZXJyLnJhaXNlZEF0ID0gdGhpcy5wb3NcbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIHBwJDQucmFpc2VSZWNvdmVyYWJsZSA9IHBwJDQucmFpc2VcblxuICBwcCQ0LmN1clBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5jdXJMaW5lLCB0aGlzLnBvcyAtIHRoaXMubGluZVN0YXJ0KVxuICAgIH1cbiAgfVxuXG4gIHZhciBOb2RlID0gZnVuY3Rpb24gTm9kZShwYXJzZXIsIHBvcywgbG9jKSB7XG4gICAgdGhpcy50eXBlID0gXCJcIlxuICAgIHRoaXMuc3RhcnQgPSBwb3NcbiAgICB0aGlzLmVuZCA9IDBcbiAgICBpZiAocGFyc2VyLm9wdGlvbnMubG9jYXRpb25zKVxuICAgICAgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24ocGFyc2VyLCBsb2MpXG4gICAgaWYgKHBhcnNlci5vcHRpb25zLmRpcmVjdFNvdXJjZUZpbGUpXG4gICAgICB0aGlzLnNvdXJjZUZpbGUgPSBwYXJzZXIub3B0aW9ucy5kaXJlY3RTb3VyY2VGaWxlXG4gICAgaWYgKHBhcnNlci5vcHRpb25zLnJhbmdlcylcbiAgICAgIHRoaXMucmFuZ2UgPSBbcG9zLCAwXVxuICB9O1xuXG4gIC8vIFN0YXJ0IGFuIEFTVCBub2RlLCBhdHRhY2hpbmcgYSBzdGFydCBvZmZzZXQuXG5cbiAgdmFyIHBwJDUgPSBQYXJzZXIucHJvdG90eXBlXG5cbiAgcHAkNS5zdGFydE5vZGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgdGhpcy5zdGFydCwgdGhpcy5zdGFydExvYylcbiAgfVxuXG4gIHBwJDUuc3RhcnROb2RlQXQgPSBmdW5jdGlvbihwb3MsIGxvYykge1xuICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCBwb3MsIGxvYylcbiAgfVxuXG4gIC8vIEZpbmlzaCBhbiBBU1Qgbm9kZSwgYWRkaW5nIGB0eXBlYCBhbmQgYGVuZGAgcHJvcGVydGllcy5cblxuICBmdW5jdGlvbiBmaW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgcG9zLCBsb2MpIHtcbiAgICBub2RlLnR5cGUgPSB0eXBlXG4gICAgbm9kZS5lbmQgPSBwb3NcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucylcbiAgICAgIG5vZGUubG9jLmVuZCA9IGxvY1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKVxuICAgICAgbm9kZS5yYW5nZVsxXSA9IHBvc1xuICAgIHJldHVybiBub2RlXG4gIH1cblxuICBwcCQ1LmZpbmlzaE5vZGUgPSBmdW5jdGlvbihub2RlLCB0eXBlKSB7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGVBdC5jYWxsKHRoaXMsIG5vZGUsIHR5cGUsIHRoaXMubGFzdFRva0VuZCwgdGhpcy5sYXN0VG9rRW5kTG9jKVxuICB9XG5cbiAgLy8gRmluaXNoIG5vZGUgYXQgZ2l2ZW4gcG9zaXRpb25cblxuICBwcCQ1LmZpbmlzaE5vZGVBdCA9IGZ1bmN0aW9uKG5vZGUsIHR5cGUsIHBvcywgbG9jKSB7XG4gICAgcmV0dXJuIGZpbmlzaE5vZGVBdC5jYWxsKHRoaXMsIG5vZGUsIHR5cGUsIHBvcywgbG9jKVxuICB9XG5cbiAgdmFyIFRva0NvbnRleHQgPSBmdW5jdGlvbiBUb2tDb250ZXh0KHRva2VuLCBpc0V4cHIsIHByZXNlcnZlU3BhY2UsIG92ZXJyaWRlKSB7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuXG4gICAgdGhpcy5pc0V4cHIgPSAhIWlzRXhwclxuICAgIHRoaXMucHJlc2VydmVTcGFjZSA9ICEhcHJlc2VydmVTcGFjZVxuICAgIHRoaXMub3ZlcnJpZGUgPSBvdmVycmlkZVxuICB9O1xuXG4gIHZhciB0eXBlcyA9IHtcbiAgICBiX3N0YXQ6IG5ldyBUb2tDb250ZXh0KFwie1wiLCBmYWxzZSksXG4gICAgYl9leHByOiBuZXcgVG9rQ29udGV4dChcIntcIiwgdHJ1ZSksXG4gICAgYl90bXBsOiBuZXcgVG9rQ29udGV4dChcIiR7XCIsIHRydWUpLFxuICAgIHBfc3RhdDogbmV3IFRva0NvbnRleHQoXCIoXCIsIGZhbHNlKSxcbiAgICBwX2V4cHI6IG5ldyBUb2tDb250ZXh0KFwiKFwiLCB0cnVlKSxcbiAgICBxX3RtcGw6IG5ldyBUb2tDb250ZXh0KFwiYFwiLCB0cnVlLCB0cnVlLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5yZWFkVG1wbFRva2VuKCk7IH0pLFxuICAgIGZfZXhwcjogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCB0cnVlKVxuICB9XG5cbiAgdmFyIHBwJDYgPSBQYXJzZXIucHJvdG90eXBlXG5cbiAgcHAkNi5pbml0aWFsQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBbdHlwZXMuYl9zdGF0XVxuICB9XG5cbiAgcHAkNi5icmFjZUlzQmxvY2sgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIGlmIChwcmV2VHlwZSA9PT0gdHQuY29sb24pIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmN1ckNvbnRleHQoKVxuICAgICAgaWYgKHBhcmVudCA9PT0gdHlwZXMuYl9zdGF0IHx8IHBhcmVudCA9PT0gdHlwZXMuYl9leHByKVxuICAgICAgICByZXR1cm4gIXBhcmVudC5pc0V4cHJcbiAgICB9XG4gICAgaWYgKHByZXZUeXBlID09PSB0dC5fcmV0dXJuKVxuICAgICAgcmV0dXJuIGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSlcbiAgICBpZiAocHJldlR5cGUgPT09IHR0Ll9lbHNlIHx8IHByZXZUeXBlID09PSB0dC5zZW1pIHx8IHByZXZUeXBlID09PSB0dC5lb2YgfHwgcHJldlR5cGUgPT09IHR0LnBhcmVuUilcbiAgICAgIHJldHVybiB0cnVlXG4gICAgaWYgKHByZXZUeXBlID09IHR0LmJyYWNlTClcbiAgICAgIHJldHVybiB0aGlzLmN1ckNvbnRleHQoKSA9PT0gdHlwZXMuYl9zdGF0XG4gICAgcmV0dXJuICF0aGlzLmV4cHJBbGxvd2VkXG4gIH1cblxuICBwcCQ2LnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHZhciB1cGRhdGUsIHR5cGUgPSB0aGlzLnR5cGVcbiAgICBpZiAodHlwZS5rZXl3b3JkICYmIHByZXZUeXBlID09IHR0LmRvdClcbiAgICAgIHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZVxuICAgIGVsc2UgaWYgKHVwZGF0ZSA9IHR5cGUudXBkYXRlQ29udGV4dClcbiAgICAgIHVwZGF0ZS5jYWxsKHRoaXMsIHByZXZUeXBlKVxuICAgIGVsc2VcbiAgICAgIHRoaXMuZXhwckFsbG93ZWQgPSB0eXBlLmJlZm9yZUV4cHJcbiAgfVxuXG4gIC8vIFRva2VuLXNwZWNpZmljIGNvbnRleHQgdXBkYXRlIGNvZGVcblxuICB0dC5wYXJlblIudXBkYXRlQ29udGV4dCA9IHR0LmJyYWNlUi51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY29udGV4dC5sZW5ndGggPT0gMSkge1xuICAgICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWVcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgb3V0ID0gdGhpcy5jb250ZXh0LnBvcCgpXG4gICAgaWYgKG91dCA9PT0gdHlwZXMuYl9zdGF0ICYmIHRoaXMuY3VyQ29udGV4dCgpID09PSB0eXBlcy5mX2V4cHIpIHtcbiAgICAgIHRoaXMuY29udGV4dC5wb3AoKVxuICAgICAgdGhpcy5leHByQWxsb3dlZCA9IGZhbHNlXG4gICAgfSBlbHNlIGlmIChvdXQgPT09IHR5cGVzLmJfdG1wbCkge1xuICAgICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5leHByQWxsb3dlZCA9ICFvdXQuaXNFeHByXG4gICAgfVxuICB9XG5cbiAgdHQuYnJhY2VMLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICAgIHRoaXMuY29udGV4dC5wdXNoKHRoaXMuYnJhY2VJc0Jsb2NrKHByZXZUeXBlKSA/IHR5cGVzLmJfc3RhdCA6IHR5cGVzLmJfZXhwcilcbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZVxuICB9XG5cbiAgdHQuZG9sbGFyQnJhY2VMLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbnRleHQucHVzaCh0eXBlcy5iX3RtcGwpXG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWVcbiAgfVxuXG4gIHR0LnBhcmVuTC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgICB2YXIgc3RhdGVtZW50UGFyZW5zID0gcHJldlR5cGUgPT09IHR0Ll9pZiB8fCBwcmV2VHlwZSA9PT0gdHQuX2ZvciB8fCBwcmV2VHlwZSA9PT0gdHQuX3dpdGggfHwgcHJldlR5cGUgPT09IHR0Ll93aGlsZVxuICAgIHRoaXMuY29udGV4dC5wdXNoKHN0YXRlbWVudFBhcmVucyA/IHR5cGVzLnBfc3RhdCA6IHR5cGVzLnBfZXhwcilcbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZVxuICB9XG5cbiAgdHQuaW5jRGVjLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB0b2tFeHByQWxsb3dlZCBzdGF5cyB1bmNoYW5nZWRcbiAgfVxuXG4gIHR0Ll9mdW5jdGlvbi51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgICBpZiAocHJldlR5cGUuYmVmb3JlRXhwciAmJiBwcmV2VHlwZSAhPT0gdHQuc2VtaSAmJiBwcmV2VHlwZSAhPT0gdHQuX2Vsc2UgJiZcbiAgICAgICAgISgocHJldlR5cGUgPT09IHR0LmNvbG9uIHx8IHByZXZUeXBlID09PSB0dC5icmFjZUwpICYmIHRoaXMuY3VyQ29udGV4dCgpID09PSB0eXBlcy5iX3N0YXQpKVxuICAgICAgdGhpcy5jb250ZXh0LnB1c2godHlwZXMuZl9leHByKVxuICAgIHRoaXMuZXhwckFsbG93ZWQgPSBmYWxzZVxuICB9XG5cbiAgdHQuYmFja1F1b3RlLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzLnFfdG1wbClcbiAgICAgIHRoaXMuY29udGV4dC5wb3AoKVxuICAgIGVsc2VcbiAgICAgIHRoaXMuY29udGV4dC5wdXNoKHR5cGVzLnFfdG1wbClcbiAgICB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2VcbiAgfVxuXG4gIC8vIE9iamVjdCB0eXBlIHVzZWQgdG8gcmVwcmVzZW50IHRva2Vucy4gTm90ZSB0aGF0IG5vcm1hbGx5LCB0b2tlbnNcbiAgLy8gc2ltcGx5IGV4aXN0IGFzIHByb3BlcnRpZXMgb24gdGhlIHBhcnNlciBvYmplY3QuIFRoaXMgaXMgb25seVxuICAvLyB1c2VkIGZvciB0aGUgb25Ub2tlbiBjYWxsYmFjayBhbmQgdGhlIGV4dGVybmFsIHRva2VuaXplci5cblxuICB2YXIgVG9rZW4gPSBmdW5jdGlvbiBUb2tlbihwKSB7XG4gICAgdGhpcy50eXBlID0gcC50eXBlXG4gICAgdGhpcy52YWx1ZSA9IHAudmFsdWVcbiAgICB0aGlzLnN0YXJ0ID0gcC5zdGFydFxuICAgIHRoaXMuZW5kID0gcC5lbmRcbiAgICBpZiAocC5vcHRpb25zLmxvY2F0aW9ucylcbiAgICAgIHRoaXMubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHAsIHAuc3RhcnRMb2MsIHAuZW5kTG9jKVxuICAgIGlmIChwLm9wdGlvbnMucmFuZ2VzKVxuICAgICAgdGhpcy5yYW5nZSA9IFtwLnN0YXJ0LCBwLmVuZF1cbiAgfTtcblxuICAvLyAjIyBUb2tlbml6ZXJcblxuICB2YXIgcHAkNyA9IFBhcnNlci5wcm90b3R5cGVcblxuICAvLyBBcmUgd2UgcnVubmluZyB1bmRlciBSaGlubz9cbiAgdmFyIGlzUmhpbm8gPSB0eXBlb2YgUGFja2FnZXMgPT0gXCJvYmplY3RcIiAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUGFja2FnZXMpID09IFwiW29iamVjdCBKYXZhUGFja2FnZV1cIlxuXG4gIC8vIE1vdmUgdG8gdGhlIG5leHQgdG9rZW5cblxuICBwcCQ3Lm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9uVG9rZW4pXG4gICAgICB0aGlzLm9wdGlvbnMub25Ub2tlbihuZXcgVG9rZW4odGhpcykpXG5cbiAgICB0aGlzLmxhc3RUb2tFbmQgPSB0aGlzLmVuZFxuICAgIHRoaXMubGFzdFRva1N0YXJ0ID0gdGhpcy5zdGFydFxuICAgIHRoaXMubGFzdFRva0VuZExvYyA9IHRoaXMuZW5kTG9jXG4gICAgdGhpcy5sYXN0VG9rU3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jXG4gICAgdGhpcy5uZXh0VG9rZW4oKVxuICB9XG5cbiAgcHAkNy5nZXRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubmV4dCgpXG4gICAgcmV0dXJuIG5ldyBUb2tlbih0aGlzKVxuICB9XG5cbiAgLy8gSWYgd2UncmUgaW4gYW4gRVM2IGVudmlyb25tZW50LCBtYWtlIHBhcnNlcnMgaXRlcmFibGVcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgcHAkN1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICByZXR1cm4ge25leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRva2VuID0gc2VsZi5nZXRUb2tlbigpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogdG9rZW4udHlwZSA9PT0gdHQuZW9mLFxuICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICB9XG4gICAgICB9fVxuICAgIH1cblxuICAvLyBUb2dnbGUgc3RyaWN0IG1vZGUuIFJlLXJlYWRzIHRoZSBuZXh0IG51bWJlciBvciBzdHJpbmcgdG8gcGxlYXNlXG4gIC8vIHBlZGFudGljIHRlc3RzIChgXCJ1c2Ugc3RyaWN0XCI7IDAxMDtgIHNob3VsZCBmYWlsKS5cblxuICBwcCQ3LnNldFN0cmljdCA9IGZ1bmN0aW9uKHN0cmljdCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy5zdHJpY3QgPSBzdHJpY3RcbiAgICBpZiAodGhpcy50eXBlICE9PSB0dC5udW0gJiYgdGhpcy50eXBlICE9PSB0dC5zdHJpbmcpIHJldHVyblxuICAgIHRoaXMucG9zID0gdGhpcy5zdGFydFxuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmxpbmVTdGFydCkge1xuICAgICAgICB0aGlzJDEubGluZVN0YXJ0ID0gdGhpcyQxLmlucHV0Lmxhc3RJbmRleE9mKFwiXFxuXCIsIHRoaXMkMS5saW5lU3RhcnQgLSAyKSArIDFcbiAgICAgICAgLS10aGlzJDEuY3VyTGluZVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm5leHRUb2tlbigpXG4gIH1cblxuICBwcCQ3LmN1ckNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0W3RoaXMuY29udGV4dC5sZW5ndGggLSAxXVxuICB9XG5cbiAgLy8gUmVhZCBhIHNpbmdsZSB0b2tlbiwgdXBkYXRpbmcgdGhlIHBhcnNlciBvYmplY3QncyB0b2tlbi1yZWxhdGVkXG4gIC8vIHByb3BlcnRpZXMuXG5cbiAgcHAkNy5uZXh0VG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3VyQ29udGV4dCA9IHRoaXMuY3VyQ29udGV4dCgpXG4gICAgaWYgKCFjdXJDb250ZXh0IHx8ICFjdXJDb250ZXh0LnByZXNlcnZlU3BhY2UpIHRoaXMuc2tpcFNwYWNlKClcblxuICAgIHRoaXMuc3RhcnQgPSB0aGlzLnBvc1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB0aGlzLnN0YXJ0TG9jID0gdGhpcy5jdXJQb3NpdGlvbigpXG4gICAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0dC5lb2YpXG5cbiAgICBpZiAoY3VyQ29udGV4dC5vdmVycmlkZSkgcmV0dXJuIGN1ckNvbnRleHQub3ZlcnJpZGUodGhpcylcbiAgICBlbHNlIHRoaXMucmVhZFRva2VuKHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSlcbiAgfVxuXG4gIHBwJDcucmVhZFRva2VuID0gZnVuY3Rpb24oY29kZSkge1xuICAgIC8vIElkZW50aWZpZXIgb3Iga2V5d29yZC4gJ1xcdVhYWFgnIHNlcXVlbmNlcyBhcmUgYWxsb3dlZCBpblxuICAgIC8vIGlkZW50aWZpZXJzLCBzbyAnXFwnIGFsc28gZGlzcGF0Y2hlcyB0byB0aGF0LlxuICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjb2RlLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgfHwgY29kZSA9PT0gOTIgLyogJ1xcJyAqLylcbiAgICAgIHJldHVybiB0aGlzLnJlYWRXb3JkKClcblxuICAgIHJldHVybiB0aGlzLmdldFRva2VuRnJvbUNvZGUoY29kZSlcbiAgfVxuXG4gIHBwJDcuZnVsbENoYXJDb2RlQXRQb3MgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29kZSA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcylcbiAgICBpZiAoY29kZSA8PSAweGQ3ZmYgfHwgY29kZSA+PSAweGUwMDApIHJldHVybiBjb2RlXG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKVxuICAgIHJldHVybiAoY29kZSA8PCAxMCkgKyBuZXh0IC0gMHgzNWZkYzAwXG4gIH1cblxuICBwcCQ3LnNraXBCbG9ja0NvbW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBzdGFydExvYyA9IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQgJiYgdGhpcy5jdXJQb3NpdGlvbigpXG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3MsIGVuZCA9IHRoaXMuaW5wdXQuaW5kZXhPZihcIiovXCIsIHRoaXMucG9zICs9IDIpXG4gICAgaWYgKGVuZCA9PT0gLTEpIHRoaXMucmFpc2UodGhpcy5wb3MgLSAyLCBcIlVudGVybWluYXRlZCBjb21tZW50XCIpXG4gICAgdGhpcy5wb3MgPSBlbmQgKyAyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgIGxpbmVCcmVha0cubGFzdEluZGV4ID0gc3RhcnRcbiAgICAgIHZhciBtYXRjaFxuICAgICAgd2hpbGUgKChtYXRjaCA9IGxpbmVCcmVha0cuZXhlYyh0aGlzLmlucHV0KSkgJiYgbWF0Y2guaW5kZXggPCB0aGlzLnBvcykge1xuICAgICAgICArK3RoaXMkMS5jdXJMaW5lXG4gICAgICAgIHRoaXMkMS5saW5lU3RhcnQgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aFxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLm9uQ29tbWVudClcbiAgICAgIHRoaXMub3B0aW9ucy5vbkNvbW1lbnQodHJ1ZSwgdGhpcy5pbnB1dC5zbGljZShzdGFydCArIDIsIGVuZCksIHN0YXJ0LCB0aGlzLnBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRMb2MsIHRoaXMuY3VyUG9zaXRpb24oKSlcbiAgfVxuXG4gIHBwJDcuc2tpcExpbmVDb21tZW50ID0gZnVuY3Rpb24oc3RhcnRTa2lwKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvc1xuICAgIHZhciBzdGFydExvYyA9IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQgJiYgdGhpcy5jdXJQb3NpdGlvbigpXG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKz1zdGFydFNraXApXG4gICAgd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGggJiYgY2ggIT09IDEwICYmIGNoICE9PSAxMyAmJiBjaCAhPT0gODIzMiAmJiBjaCAhPT0gODIzMykge1xuICAgICAgKyt0aGlzJDEucG9zXG4gICAgICBjaCA9IHRoaXMkMS5pbnB1dC5jaGFyQ29kZUF0KHRoaXMkMS5wb3MpXG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMub25Db21tZW50KVxuICAgICAgdGhpcy5vcHRpb25zLm9uQ29tbWVudChmYWxzZSwgdGhpcy5pbnB1dC5zbGljZShzdGFydCArIHN0YXJ0U2tpcCwgdGhpcy5wb3MpLCBzdGFydCwgdGhpcy5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TG9jLCB0aGlzLmN1clBvc2l0aW9uKCkpXG4gIH1cblxuICAvLyBDYWxsZWQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBwYXJzZSBhbmQgYWZ0ZXIgZXZlcnkgdG9rZW4uIFNraXBzXG4gIC8vIHdoaXRlc3BhY2UgYW5kIGNvbW1lbnRzLCBhbmQuXG5cbiAgcHAkNy5za2lwU3BhY2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGxvb3A6IHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICB2YXIgY2ggPSB0aGlzJDEuaW5wdXQuY2hhckNvZGVBdCh0aGlzJDEucG9zKVxuICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlIDMyOiBjYXNlIDE2MDogLy8gJyAnXG4gICAgICAgICAgKyt0aGlzJDEucG9zXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBpZiAodGhpcyQxLmlucHV0LmNoYXJDb2RlQXQodGhpcyQxLnBvcyArIDEpID09PSAxMCkge1xuICAgICAgICAgICAgKyt0aGlzJDEucG9zXG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDEwOiBjYXNlIDgyMzI6IGNhc2UgODIzMzpcbiAgICAgICAgICArK3RoaXMkMS5wb3NcbiAgICAgICAgICBpZiAodGhpcyQxLm9wdGlvbnMubG9jYXRpb25zKSB7XG4gICAgICAgICAgICArK3RoaXMkMS5jdXJMaW5lXG4gICAgICAgICAgICB0aGlzJDEubGluZVN0YXJ0ID0gdGhpcyQxLnBvc1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ3OiAvLyAnLydcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMkMS5pbnB1dC5jaGFyQ29kZUF0KHRoaXMkMS5wb3MgKyAxKSkge1xuICAgICAgICAgICAgY2FzZSA0MjogLy8gJyonXG4gICAgICAgICAgICAgIHRoaXMkMS5za2lwQmxvY2tDb21tZW50KClcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgICAgIHRoaXMkMS5za2lwTGluZUNvbW1lbnQoMilcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGJyZWFrIGxvb3BcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoY2ggPiA4ICYmIGNoIDwgMTQgfHwgY2ggPj0gNTc2MCAmJiBub25BU0NJSXdoaXRlc3BhY2UudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSkpIHtcbiAgICAgICAgICAgICsrdGhpcyQxLnBvc1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhayBsb29wXG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENhbGxlZCBhdCB0aGUgZW5kIG9mIGV2ZXJ5IHRva2VuLiBTZXRzIGBlbmRgLCBgdmFsYCwgYW5kXG4gIC8vIG1haW50YWlucyBgY29udGV4dGAgYW5kIGBleHByQWxsb3dlZGAsIGFuZCBza2lwcyB0aGUgc3BhY2UgYWZ0ZXJcbiAgLy8gdGhlIHRva2VuLCBzbyB0aGF0IHRoZSBuZXh0IG9uZSdzIGBzdGFydGAgd2lsbCBwb2ludCBhdCB0aGVcbiAgLy8gcmlnaHQgcG9zaXRpb24uXG5cbiAgcHAkNy5maW5pc2hUb2tlbiA9IGZ1bmN0aW9uKHR5cGUsIHZhbCkge1xuICAgIHRoaXMuZW5kID0gdGhpcy5wb3NcbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykgdGhpcy5lbmRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKClcbiAgICB2YXIgcHJldlR5cGUgPSB0aGlzLnR5cGVcbiAgICB0aGlzLnR5cGUgPSB0eXBlXG4gICAgdGhpcy52YWx1ZSA9IHZhbFxuXG4gICAgdGhpcy51cGRhdGVDb250ZXh0KHByZXZUeXBlKVxuICB9XG5cbiAgLy8gIyMjIFRva2VuIHJlYWRpbmdcblxuICAvLyBUaGlzIGlzIHRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB0byBmZXRjaCB0aGUgbmV4dCB0b2tlbi4gSXRcbiAgLy8gaXMgc29tZXdoYXQgb2JzY3VyZSwgYmVjYXVzZSBpdCB3b3JrcyBpbiBjaGFyYWN0ZXIgY29kZXMgcmF0aGVyXG4gIC8vIHRoYW4gY2hhcmFjdGVycywgYW5kIGJlY2F1c2Ugb3BlcmF0b3IgcGFyc2luZyBoYXMgYmVlbiBpbmxpbmVkXG4gIC8vIGludG8gaXQuXG4gIC8vXG4gIC8vIEFsbCBpbiB0aGUgbmFtZSBvZiBzcGVlZC5cbiAgLy9cbiAgcHAkNy5yZWFkVG9rZW5fZG90ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKVxuICAgIGlmIChuZXh0ID49IDQ4ICYmIG5leHQgPD0gNTcpIHJldHVybiB0aGlzLnJlYWROdW1iZXIodHJ1ZSlcbiAgICB2YXIgbmV4dDIgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiBuZXh0ID09PSA0NiAmJiBuZXh0MiA9PT0gNDYpIHsgLy8gNDYgPSBkb3QgJy4nXG4gICAgICB0aGlzLnBvcyArPSAzXG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0dC5lbGxpcHNpcylcbiAgICB9IGVsc2Uge1xuICAgICAgKyt0aGlzLnBvc1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHQuZG90KVxuICAgIH1cbiAgfVxuXG4gIHBwJDcucmVhZFRva2VuX3NsYXNoID0gZnVuY3Rpb24oKSB7IC8vICcvJ1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSlcbiAgICBpZiAodGhpcy5leHByQWxsb3dlZCkgeysrdGhpcy5wb3M7IHJldHVybiB0aGlzLnJlYWRSZWdleHAoKX1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHJldHVybiB0aGlzLmZpbmlzaE9wKHR0LmFzc2lnbiwgMilcbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0dC5zbGFzaCwgMSlcbiAgfVxuXG4gIHBwJDcucmVhZFRva2VuX211bHRfbW9kdWxvX2V4cCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJyUqJ1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSlcbiAgICB2YXIgc2l6ZSA9IDFcbiAgICB2YXIgdG9rZW50eXBlID0gY29kZSA9PT0gNDIgPyB0dC5zdGFyIDogdHQubW9kdWxvXG5cbiAgICAvLyBleHBvbmVudGlhdGlvbiBvcGVyYXRvciAqKiBhbmQgKio9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA3ICYmIG5leHQgPT09IDQyKSB7XG4gICAgICArK3NpemVcbiAgICAgIHRva2VudHlwZSA9IHR0LnN0YXJzdGFyXG4gICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMilcbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gNjEpIHJldHVybiB0aGlzLmZpbmlzaE9wKHR0LmFzc2lnbiwgc2l6ZSArIDEpXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodG9rZW50eXBlLCBzaXplKVxuICB9XG5cbiAgcHAkNy5yZWFkVG9rZW5fcGlwZV9hbXAgPSBmdW5jdGlvbihjb2RlKSB7IC8vICd8JidcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpXG4gICAgaWYgKG5leHQgPT09IGNvZGUpIHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IHR0LmxvZ2ljYWxPUiA6IHR0LmxvZ2ljYWxBTkQsIDIpXG4gICAgaWYgKG5leHQgPT09IDYxKSByZXR1cm4gdGhpcy5maW5pc2hPcCh0dC5hc3NpZ24sIDIpXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gdHQuYml0d2lzZU9SIDogdHQuYml0d2lzZUFORCwgMSlcbiAgfVxuXG4gIHBwJDcucmVhZFRva2VuX2NhcmV0ID0gZnVuY3Rpb24oKSB7IC8vICdeJ1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSlcbiAgICBpZiAobmV4dCA9PT0gNjEpIHJldHVybiB0aGlzLmZpbmlzaE9wKHR0LmFzc2lnbiwgMilcbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0dC5iaXR3aXNlWE9SLCAxKVxuICB9XG5cbiAgcHAkNy5yZWFkVG9rZW5fcGx1c19taW4gPSBmdW5jdGlvbihjb2RlKSB7IC8vICcrLSdcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpXG4gICAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICAgIGlmIChuZXh0ID09IDQ1ICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09IDYyICYmXG4gICAgICAgICAgbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMucG9zKSkpIHtcbiAgICAgICAgLy8gQSBgLS0+YCBsaW5lIGNvbW1lbnRcbiAgICAgICAgdGhpcy5za2lwTGluZUNvbW1lbnQoMylcbiAgICAgICAgdGhpcy5za2lwU3BhY2UoKVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW4oKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHQuaW5jRGVjLCAyKVxuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHJldHVybiB0aGlzLmZpbmlzaE9wKHR0LmFzc2lnbiwgMilcbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0dC5wbHVzTWluLCAxKVxuICB9XG5cbiAgcHAkNy5yZWFkVG9rZW5fbHRfZ3QgPSBmdW5jdGlvbihjb2RlKSB7IC8vICc8PidcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpXG4gICAgdmFyIHNpemUgPSAxXG4gICAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICAgIHNpemUgPSBjb2RlID09PSA2MiAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNjIgPyAzIDogMlxuICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIHNpemUpID09PSA2MSkgcmV0dXJuIHRoaXMuZmluaXNoT3AodHQuYXNzaWduLCBzaXplICsgMSlcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR0LmJpdFNoaWZ0LCBzaXplKVxuICAgIH1cbiAgICBpZiAobmV4dCA9PSAzMyAmJiBjb2RlID09IDYwICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09IDQ1ICYmXG4gICAgICAgIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDMpID09IDQ1KSB7XG4gICAgICBpZiAodGhpcy5pbk1vZHVsZSkgdGhpcy51bmV4cGVjdGVkKClcbiAgICAgIC8vIGA8IS0tYCwgYW4gWE1MLXN0eWxlIGNvbW1lbnQgdGhhdCBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYSBsaW5lIGNvbW1lbnRcbiAgICAgIHRoaXMuc2tpcExpbmVDb21tZW50KDQpXG4gICAgICB0aGlzLnNraXBTcGFjZSgpXG4gICAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW4oKVxuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHNpemUgPSAyXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHQucmVsYXRpb25hbCwgc2l6ZSlcbiAgfVxuXG4gIHBwJDcucmVhZFRva2VuX2VxX2V4Y2wgPSBmdW5jdGlvbihjb2RlKSB7IC8vICc9ISdcbiAgICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpXG4gICAgaWYgKG5leHQgPT09IDYxKSByZXR1cm4gdGhpcy5maW5pc2hPcCh0dC5lcXVhbGl0eSwgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT09IDYxID8gMyA6IDIpXG4gICAgaWYgKGNvZGUgPT09IDYxICYmIG5leHQgPT09IDYyICYmIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7IC8vICc9PidcbiAgICAgIHRoaXMucG9zICs9IDJcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR0LmFycm93KVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcChjb2RlID09PSA2MSA/IHR0LmVxIDogdHQucHJlZml4LCAxKVxuICB9XG5cbiAgcHAkNy5nZXRUb2tlbkZyb21Db2RlID0gZnVuY3Rpb24oY29kZSkge1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgLy8gVGhlIGludGVycHJldGF0aW9uIG9mIGEgZG90IGRlcGVuZHMgb24gd2hldGhlciBpdCBpcyBmb2xsb3dlZFxuICAgICAgLy8gYnkgYSBkaWdpdCBvciBhbm90aGVyIHR3byBkb3RzLlxuICAgIGNhc2UgNDY6IC8vICcuJ1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2RvdCgpXG5cbiAgICAgIC8vIFB1bmN0dWF0aW9uIHRva2Vucy5cbiAgICBjYXNlIDQwOiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0dC5wYXJlbkwpXG4gICAgY2FzZSA0MTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHQucGFyZW5SKVxuICAgIGNhc2UgNTk6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR0LnNlbWkpXG4gICAgY2FzZSA0NDogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHQuY29tbWEpXG4gICAgY2FzZSA5MTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHQuYnJhY2tldEwpXG4gICAgY2FzZSA5MzogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHQuYnJhY2tldFIpXG4gICAgY2FzZSAxMjM6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR0LmJyYWNlTClcbiAgICBjYXNlIDEyNTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHQuYnJhY2VSKVxuICAgIGNhc2UgNTg6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR0LmNvbG9uKVxuICAgIGNhc2UgNjM6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR0LnF1ZXN0aW9uKVxuXG4gICAgY2FzZSA5NjogLy8gJ2AnXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uIDwgNikgYnJlYWtcbiAgICAgICsrdGhpcy5wb3NcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR0LmJhY2tRdW90ZSlcblxuICAgIGNhc2UgNDg6IC8vICcwJ1xuICAgICAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKVxuICAgICAgaWYgKG5leHQgPT09IDEyMCB8fCBuZXh0ID09PSA4OCkgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDE2KSAvLyAnMHgnLCAnMFgnIC0gaGV4IG51bWJlclxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgICAgIGlmIChuZXh0ID09PSAxMTEgfHwgbmV4dCA9PT0gNzkpIHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcig4KSAvLyAnMG8nLCAnME8nIC0gb2N0YWwgbnVtYmVyXG4gICAgICAgIGlmIChuZXh0ID09PSA5OCB8fCBuZXh0ID09PSA2NikgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDIpIC8vICcwYicsICcwQicgLSBiaW5hcnkgbnVtYmVyXG4gICAgICB9XG4gICAgICAvLyBBbnl0aGluZyBlbHNlIGJlZ2lubmluZyB3aXRoIGEgZGlnaXQgaXMgYW4gaW50ZWdlciwgb2N0YWxcbiAgICAgIC8vIG51bWJlciwgb3IgZmxvYXQuXG4gICAgY2FzZSA0OTogY2FzZSA1MDogY2FzZSA1MTogY2FzZSA1MjogY2FzZSA1MzogY2FzZSA1NDogY2FzZSA1NTogY2FzZSA1NjogY2FzZSA1NzogLy8gMS05XG4gICAgICByZXR1cm4gdGhpcy5yZWFkTnVtYmVyKGZhbHNlKVxuXG4gICAgICAvLyBRdW90ZXMgcHJvZHVjZSBzdHJpbmdzLlxuICAgIGNhc2UgMzQ6IGNhc2UgMzk6IC8vICdcIicsIFwiJ1wiXG4gICAgICByZXR1cm4gdGhpcy5yZWFkU3RyaW5nKGNvZGUpXG5cbiAgICAgIC8vIE9wZXJhdG9ycyBhcmUgcGFyc2VkIGlubGluZSBpbiB0aW55IHN0YXRlIG1hY2hpbmVzLiAnPScgKDYxKSBpc1xuICAgICAgLy8gb2Z0ZW4gcmVmZXJyZWQgdG8uIGBmaW5pc2hPcGAgc2ltcGx5IHNraXBzIHRoZSBhbW91bnQgb2ZcbiAgICAgIC8vIGNoYXJhY3RlcnMgaXQgaXMgZ2l2ZW4gYXMgc2Vjb25kIGFyZ3VtZW50LCBhbmQgcmV0dXJucyBhIHRva2VuXG4gICAgICAvLyBvZiB0aGUgdHlwZSBnaXZlbiBieSBpdHMgZmlyc3QgYXJndW1lbnQuXG5cbiAgICBjYXNlIDQ3OiAvLyAnLydcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9zbGFzaCgpXG5cbiAgICBjYXNlIDM3OiBjYXNlIDQyOiAvLyAnJSonXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fbXVsdF9tb2R1bG9fZXhwKGNvZGUpXG5cbiAgICBjYXNlIDEyNDogY2FzZSAzODogLy8gJ3wmJ1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3BpcGVfYW1wKGNvZGUpXG5cbiAgICBjYXNlIDk0OiAvLyAnXidcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9jYXJldCgpXG5cbiAgICBjYXNlIDQzOiBjYXNlIDQ1OiAvLyAnKy0nXG4gICAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fcGx1c19taW4oY29kZSlcblxuICAgIGNhc2UgNjA6IGNhc2UgNjI6IC8vICc8PidcbiAgICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9sdF9ndChjb2RlKVxuXG4gICAgY2FzZSA2MTogY2FzZSAzMzogLy8gJz0hJ1xuICAgICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2VxX2V4Y2woY29kZSlcblxuICAgIGNhc2UgMTI2OiAvLyAnfidcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR0LnByZWZpeCwgMSlcbiAgICB9XG5cbiAgICB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIiArIGNvZGVQb2ludFRvU3RyaW5nKGNvZGUpICsgXCInXCIpXG4gIH1cblxuICBwcCQ3LmZpbmlzaE9wID0gZnVuY3Rpb24odHlwZSwgc2l6ZSkge1xuICAgIHZhciBzdHIgPSB0aGlzLmlucHV0LnNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyArIHNpemUpXG4gICAgdGhpcy5wb3MgKz0gc2l6ZVxuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGUsIHN0cilcbiAgfVxuXG4gIC8vIFBhcnNlIGEgcmVndWxhciBleHByZXNzaW9uLiBTb21lIGNvbnRleHQtYXdhcmVuZXNzIGlzIG5lY2Vzc2FyeSxcbiAgLy8gc2luY2UgYSAnLycgaW5zaWRlIGEgJ1tdJyBzZXQgZG9lcyBub3QgZW5kIHRoZSBleHByZXNzaW9uLlxuXG4gIGZ1bmN0aW9uIHRyeUNyZWF0ZVJlZ2V4cChzcmMsIGZsYWdzLCB0aHJvd0Vycm9yQXQsIHBhcnNlcikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChzcmMsIGZsYWdzKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICh0aHJvd0Vycm9yQXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFN5bnRheEVycm9yKSBwYXJzZXIucmFpc2UodGhyb3dFcnJvckF0LCBcIkVycm9yIHBhcnNpbmcgcmVndWxhciBleHByZXNzaW9uOiBcIiArIGUubWVzc2FnZSlcbiAgICAgICAgdGhyb3cgZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciByZWdleHBVbmljb2RlU3VwcG9ydCA9ICEhdHJ5Q3JlYXRlUmVnZXhwKFwiXFx1ZmZmZlwiLCBcInVcIilcblxuICBwcCQ3LnJlYWRSZWdleHAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBlc2NhcGVkLCBpbkNsYXNzLCBzdGFydCA9IHRoaXMucG9zXG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRoaXMkMS5wb3MgPj0gdGhpcyQxLmlucHV0Lmxlbmd0aCkgdGhpcyQxLnJhaXNlKHN0YXJ0LCBcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIilcbiAgICAgIHZhciBjaCA9IHRoaXMkMS5pbnB1dC5jaGFyQXQodGhpcyQxLnBvcylcbiAgICAgIGlmIChsaW5lQnJlYWsudGVzdChjaCkpIHRoaXMkMS5yYWlzZShzdGFydCwgXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpXG4gICAgICBpZiAoIWVzY2FwZWQpIHtcbiAgICAgICAgaWYgKGNoID09PSBcIltcIikgaW5DbGFzcyA9IHRydWVcbiAgICAgICAgZWxzZSBpZiAoY2ggPT09IFwiXVwiICYmIGluQ2xhc3MpIGluQ2xhc3MgPSBmYWxzZVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gXCIvXCIgJiYgIWluQ2xhc3MpIGJyZWFrXG4gICAgICAgIGVzY2FwZWQgPSBjaCA9PT0gXCJcXFxcXCJcbiAgICAgIH0gZWxzZSBlc2NhcGVkID0gZmFsc2VcbiAgICAgICsrdGhpcyQxLnBvc1xuICAgIH1cbiAgICB2YXIgY29udGVudCA9IHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMucG9zKVxuICAgICsrdGhpcy5wb3NcbiAgICAvLyBOZWVkIHRvIHVzZSBgcmVhZFdvcmQxYCBiZWNhdXNlICdcXHVYWFhYJyBzZXF1ZW5jZXMgYXJlIGFsbG93ZWRcbiAgICAvLyBoZXJlIChkb24ndCBhc2spLlxuICAgIHZhciBtb2RzID0gdGhpcy5yZWFkV29yZDEoKVxuICAgIHZhciB0bXAgPSBjb250ZW50LCB0bXBGbGFncyA9IFwiXCJcbiAgICBpZiAobW9kcykge1xuICAgICAgdmFyIHZhbGlkRmxhZ3MgPSAvXltnaW1dKiQvXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHZhbGlkRmxhZ3MgPSAvXltnaW11eV0qJC9cbiAgICAgIGlmICghdmFsaWRGbGFncy50ZXN0KG1vZHMpKSB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uIGZsYWdcIilcbiAgICAgIGlmIChtb2RzLmluZGV4T2YoXCJ1XCIpID49IDApIHtcbiAgICAgICAgaWYgKHJlZ2V4cFVuaWNvZGVTdXBwb3J0KSB7XG4gICAgICAgICAgdG1wRmxhZ3MgPSBcInVcIlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlcGxhY2UgZWFjaCBhc3RyYWwgc3ltYm9sIGFuZCBldmVyeSBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZSB0aGF0XG4gICAgICAgICAgLy8gcG9zc2libHkgcmVwcmVzZW50cyBhbiBhc3RyYWwgc3ltYm9sIG9yIGEgcGFpcmVkIHN1cnJvZ2F0ZSB3aXRoIGFcbiAgICAgICAgICAvLyBzaW5nbGUgQVNDSUkgc3ltYm9sIHRvIGF2b2lkIHRocm93aW5nIG9uIHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdFxuICAgICAgICAgIC8vIGFyZSBvbmx5IHZhbGlkIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIGAvdWAgZmxhZy5cbiAgICAgICAgICAvLyBOb3RlOiByZXBsYWNpbmcgd2l0aCB0aGUgQVNDSUkgc3ltYm9sIGB4YCBtaWdodCBjYXVzZSBmYWxzZVxuICAgICAgICAgIC8vIG5lZ2F0aXZlcyBpbiB1bmxpa2VseSBzY2VuYXJpb3MuIEZvciBleGFtcGxlLCBgW1xcdXs2MX0tYl1gIGlzIGFcbiAgICAgICAgICAvLyBwZXJmZWN0bHkgdmFsaWQgcGF0dGVybiB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gYFthLWJdYCwgYnV0IGl0IHdvdWxkXG4gICAgICAgICAgLy8gYmUgcmVwbGFjZWQgYnkgYFt4LWJdYCB3aGljaCB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICAgICAgdG1wID0gdG1wLnJlcGxhY2UoL1xcXFx1XFx7KFswLTlhLWZBLUZdKylcXH0vZywgZnVuY3Rpb24gKF9tYXRjaCwgY29kZSwgb2Zmc2V0KSB7XG4gICAgICAgICAgICBjb2RlID0gTnVtYmVyKFwiMHhcIiArIGNvZGUpXG4gICAgICAgICAgICBpZiAoY29kZSA+IDB4MTBGRkZGKSB0aGlzJDEucmFpc2Uoc3RhcnQgKyBvZmZzZXQgKyAzLCBcIkNvZGUgcG9pbnQgb3V0IG9mIGJvdW5kc1wiKVxuICAgICAgICAgICAgcmV0dXJuIFwieFwiXG4gICAgICAgICAgfSlcbiAgICAgICAgICB0bXAgPSB0bXAucmVwbGFjZSgvXFxcXHUoW2EtZkEtRjAtOV17NH0pfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vZywgXCJ4XCIpXG4gICAgICAgICAgdG1wRmxhZ3MgPSB0bXBGbGFncy5yZXBsYWNlKFwidVwiLCBcIlwiKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIERldGVjdCBpbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gICAgdmFyIHZhbHVlID0gbnVsbFxuICAgIC8vIFJoaW5vJ3MgcmVndWxhciBleHByZXNzaW9uIHBhcnNlciBpcyBmbGFreSBhbmQgdGhyb3dzIHVuY2F0Y2hhYmxlIGV4Y2VwdGlvbnMsXG4gICAgLy8gc28gZG9uJ3QgZG8gZGV0ZWN0aW9uIGlmIHdlIGFyZSBydW5uaW5nIHVuZGVyIFJoaW5vXG4gICAgaWYgKCFpc1JoaW5vKSB7XG4gICAgICB0cnlDcmVhdGVSZWdleHAodG1wLCB0bXBGbGFncywgc3RhcnQsIHRoaXMpXG4gICAgICAvLyBHZXQgYSByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IGZvciB0aGlzIHBhdHRlcm4tZmxhZyBwYWlyLCBvciBgbnVsbGAgaW5cbiAgICAgIC8vIGNhc2UgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lc24ndCBzdXBwb3J0IHRoZSBmbGFncyBpdCB1c2VzLlxuICAgICAgdmFsdWUgPSB0cnlDcmVhdGVSZWdleHAoY29udGVudCwgbW9kcylcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHQucmVnZXhwLCB7cGF0dGVybjogY29udGVudCwgZmxhZ3M6IG1vZHMsIHZhbHVlOiB2YWx1ZX0pXG4gIH1cblxuICAvLyBSZWFkIGFuIGludGVnZXIgaW4gdGhlIGdpdmVuIHJhZGl4LiBSZXR1cm4gbnVsbCBpZiB6ZXJvIGRpZ2l0c1xuICAvLyB3ZXJlIHJlYWQsIHRoZSBpbnRlZ2VyIHZhbHVlIG90aGVyd2lzZS4gV2hlbiBgbGVuYCBpcyBnaXZlbiwgdGhpc1xuICAvLyB3aWxsIHJldHVybiBgbnVsbGAgdW5sZXNzIHRoZSBpbnRlZ2VyIGhhcyBleGFjdGx5IGBsZW5gIGRpZ2l0cy5cblxuICBwcCQ3LnJlYWRJbnQgPSBmdW5jdGlvbihyYWRpeCwgbGVuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc3RhcnQgPSB0aGlzLnBvcywgdG90YWwgPSAwXG4gICAgZm9yICh2YXIgaSA9IDAsIGUgPSBsZW4gPT0gbnVsbCA/IEluZmluaXR5IDogbGVuOyBpIDwgZTsgKytpKSB7XG4gICAgICB2YXIgY29kZSA9IHRoaXMkMS5pbnB1dC5jaGFyQ29kZUF0KHRoaXMkMS5wb3MpLCB2YWxcbiAgICAgIGlmIChjb2RlID49IDk3KSB2YWwgPSBjb2RlIC0gOTcgKyAxMCAvLyBhXG4gICAgICBlbHNlIGlmIChjb2RlID49IDY1KSB2YWwgPSBjb2RlIC0gNjUgKyAxMCAvLyBBXG4gICAgICBlbHNlIGlmIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHZhbCA9IGNvZGUgLSA0OCAvLyAwLTlcbiAgICAgIGVsc2UgdmFsID0gSW5maW5pdHlcbiAgICAgIGlmICh2YWwgPj0gcmFkaXgpIGJyZWFrXG4gICAgICArK3RoaXMkMS5wb3NcbiAgICAgIHRvdGFsID0gdG90YWwgKiByYWRpeCArIHZhbFxuICAgIH1cbiAgICBpZiAodGhpcy5wb3MgPT09IHN0YXJ0IHx8IGxlbiAhPSBudWxsICYmIHRoaXMucG9zIC0gc3RhcnQgIT09IGxlbikgcmV0dXJuIG51bGxcblxuICAgIHJldHVybiB0b3RhbFxuICB9XG5cbiAgcHAkNy5yZWFkUmFkaXhOdW1iZXIgPSBmdW5jdGlvbihyYWRpeCkge1xuICAgIHRoaXMucG9zICs9IDIgLy8gMHhcbiAgICB2YXIgdmFsID0gdGhpcy5yZWFkSW50KHJhZGl4KVxuICAgIGlmICh2YWwgPT0gbnVsbCkgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0ICsgMiwgXCJFeHBlY3RlZCBudW1iZXIgaW4gcmFkaXggXCIgKyByYWRpeClcbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSkgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKVxuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR0Lm51bSwgdmFsKVxuICB9XG5cbiAgLy8gUmVhZCBhbiBpbnRlZ2VyLCBvY3RhbCBpbnRlZ2VyLCBvciBmbG9hdGluZy1wb2ludCBudW1iZXIuXG5cbiAgcHAkNy5yZWFkTnVtYmVyID0gZnVuY3Rpb24oc3RhcnRzV2l0aERvdCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMucG9zLCBpc0Zsb2F0ID0gZmFsc2UsIG9jdGFsID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSA9PT0gNDhcbiAgICBpZiAoIXN0YXJ0c1dpdGhEb3QgJiYgdGhpcy5yZWFkSW50KDEwKSA9PT0gbnVsbCkgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKVxuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKVxuICAgIGlmIChuZXh0ID09PSA0NikgeyAvLyAnLidcbiAgICAgICsrdGhpcy5wb3NcbiAgICAgIHRoaXMucmVhZEludCgxMClcbiAgICAgIGlzRmxvYXQgPSB0cnVlXG4gICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKVxuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gNjkgfHwgbmV4dCA9PT0gMTAxKSB7IC8vICdlRSdcbiAgICAgIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcylcbiAgICAgIGlmIChuZXh0ID09PSA0MyB8fCBuZXh0ID09PSA0NSkgKyt0aGlzLnBvcyAvLyAnKy0nXG4gICAgICBpZiAodGhpcy5yZWFkSW50KDEwKSA9PT0gbnVsbCkgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKVxuICAgICAgaXNGbG9hdCA9IHRydWVcbiAgICB9XG4gICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSkpIHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIilcblxuICAgIHZhciBzdHIgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcyksIHZhbFxuICAgIGlmIChpc0Zsb2F0KSB2YWwgPSBwYXJzZUZsb2F0KHN0cilcbiAgICBlbHNlIGlmICghb2N0YWwgfHwgc3RyLmxlbmd0aCA9PT0gMSkgdmFsID0gcGFyc2VJbnQoc3RyLCAxMClcbiAgICBlbHNlIGlmICgvWzg5XS8udGVzdChzdHIpIHx8IHRoaXMuc3RyaWN0KSB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpXG4gICAgZWxzZSB2YWwgPSBwYXJzZUludChzdHIsIDgpXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHQubnVtLCB2YWwpXG4gIH1cblxuICAvLyBSZWFkIGEgc3RyaW5nIHZhbHVlLCBpbnRlcnByZXRpbmcgYmFja3NsYXNoLWVzY2FwZXMuXG5cbiAgcHAkNy5yZWFkQ29kZVBvaW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSwgY29kZVxuXG4gICAgaWYgKGNoID09PSAxMjMpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2KSB0aGlzLnVuZXhwZWN0ZWQoKVxuICAgICAgdmFyIGNvZGVQb3MgPSArK3RoaXMucG9zXG4gICAgICBjb2RlID0gdGhpcy5yZWFkSGV4Q2hhcih0aGlzLmlucHV0LmluZGV4T2YoJ30nLCB0aGlzLnBvcykgLSB0aGlzLnBvcylcbiAgICAgICsrdGhpcy5wb3NcbiAgICAgIGlmIChjb2RlID4gMHgxMEZGRkYpIHRoaXMucmFpc2UoY29kZVBvcywgXCJDb2RlIHBvaW50IG91dCBvZiBib3VuZHNcIilcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSA9IHRoaXMucmVhZEhleENoYXIoNClcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvZGVQb2ludFRvU3RyaW5nKGNvZGUpIHtcbiAgICAvLyBVVEYtMTYgRGVjb2RpbmdcbiAgICBpZiAoY29kZSA8PSAweEZGRkYpIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpXG4gICAgY29kZSAtPSAweDEwMDAwXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKGNvZGUgPj4gMTApICsgMHhEODAwLCAoY29kZSAmIDEwMjMpICsgMHhEQzAwKVxuICB9XG5cbiAgcHAkNy5yZWFkU3RyaW5nID0gZnVuY3Rpb24ocXVvdGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBvdXQgPSBcIlwiLCBjaHVua1N0YXJ0ID0gKyt0aGlzLnBvc1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzJDEucG9zID49IHRoaXMkMS5pbnB1dC5sZW5ndGgpIHRoaXMkMS5yYWlzZSh0aGlzJDEuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKVxuICAgICAgdmFyIGNoID0gdGhpcyQxLmlucHV0LmNoYXJDb2RlQXQodGhpcyQxLnBvcylcbiAgICAgIGlmIChjaCA9PT0gcXVvdGUpIGJyZWFrXG4gICAgICBpZiAoY2ggPT09IDkyKSB7IC8vICdcXCdcbiAgICAgICAgb3V0ICs9IHRoaXMkMS5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzJDEucG9zKVxuICAgICAgICBvdXQgKz0gdGhpcyQxLnJlYWRFc2NhcGVkQ2hhcihmYWxzZSlcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMkMS5wb3NcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc05ld0xpbmUoY2gpKSB0aGlzJDEucmFpc2UodGhpcyQxLnN0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIilcbiAgICAgICAgKyt0aGlzJDEucG9zXG4gICAgICB9XG4gICAgfVxuICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKyspXG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHQuc3RyaW5nLCBvdXQpXG4gIH1cblxuICAvLyBSZWFkcyB0ZW1wbGF0ZSBzdHJpbmcgdG9rZW5zLlxuXG4gIHBwJDcucmVhZFRtcGxUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIG91dCA9IFwiXCIsIGNodW5rU3RhcnQgPSB0aGlzLnBvc1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzJDEucG9zID49IHRoaXMkMS5pbnB1dC5sZW5ndGgpIHRoaXMkMS5yYWlzZSh0aGlzJDEuc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlXCIpXG4gICAgICB2YXIgY2ggPSB0aGlzJDEuaW5wdXQuY2hhckNvZGVBdCh0aGlzJDEucG9zKVxuICAgICAgaWYgKGNoID09PSA5NiB8fCBjaCA9PT0gMzYgJiYgdGhpcyQxLmlucHV0LmNoYXJDb2RlQXQodGhpcyQxLnBvcyArIDEpID09PSAxMjMpIHsgLy8gJ2AnLCAnJHsnXG4gICAgICAgIGlmICh0aGlzJDEucG9zID09PSB0aGlzJDEuc3RhcnQgJiYgdGhpcyQxLnR5cGUgPT09IHR0LnRlbXBsYXRlKSB7XG4gICAgICAgICAgaWYgKGNoID09PSAzNikge1xuICAgICAgICAgICAgdGhpcyQxLnBvcyArPSAyXG4gICAgICAgICAgICByZXR1cm4gdGhpcyQxLmZpbmlzaFRva2VuKHR0LmRvbGxhckJyYWNlTClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKyt0aGlzJDEucG9zXG4gICAgICAgICAgICByZXR1cm4gdGhpcyQxLmZpbmlzaFRva2VuKHR0LmJhY2tRdW90ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9IHRoaXMkMS5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzJDEucG9zKVxuICAgICAgICByZXR1cm4gdGhpcyQxLmZpbmlzaFRva2VuKHR0LnRlbXBsYXRlLCBvdXQpXG4gICAgICB9XG4gICAgICBpZiAoY2ggPT09IDkyKSB7IC8vICdcXCdcbiAgICAgICAgb3V0ICs9IHRoaXMkMS5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzJDEucG9zKVxuICAgICAgICBvdXQgKz0gdGhpcyQxLnJlYWRFc2NhcGVkQ2hhcih0cnVlKVxuICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcyQxLnBvc1xuICAgICAgfSBlbHNlIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICAgIG91dCArPSB0aGlzJDEuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcyQxLnBvcylcbiAgICAgICAgKyt0aGlzJDEucG9zXG4gICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgaWYgKHRoaXMkMS5pbnB1dC5jaGFyQ29kZUF0KHRoaXMkMS5wb3MpID09PSAxMCkgKyt0aGlzJDEucG9zXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIG91dCArPSBcIlxcblwiXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaClcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMkMS5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgICAgICAgICsrdGhpcyQxLmN1ckxpbmVcbiAgICAgICAgICB0aGlzJDEubGluZVN0YXJ0ID0gdGhpcyQxLnBvc1xuICAgICAgICB9XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzJDEucG9zXG4gICAgICB9IGVsc2Uge1xuICAgICAgICArK3RoaXMkMS5wb3NcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBVc2VkIHRvIHJlYWQgZXNjYXBlZCBjaGFyYWN0ZXJzXG5cbiAgcHAkNy5yZWFkRXNjYXBlZENoYXIgPSBmdW5jdGlvbihpblRlbXBsYXRlKSB7XG4gICAgdmFyIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpXG4gICAgKyt0aGlzLnBvc1xuICAgIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlIDExMDogcmV0dXJuIFwiXFxuXCIgLy8gJ24nIC0+ICdcXG4nXG4gICAgY2FzZSAxMTQ6IHJldHVybiBcIlxcclwiIC8vICdyJyAtPiAnXFxyJ1xuICAgIGNhc2UgMTIwOiByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLnJlYWRIZXhDaGFyKDIpKSAvLyAneCdcbiAgICBjYXNlIDExNzogcmV0dXJuIGNvZGVQb2ludFRvU3RyaW5nKHRoaXMucmVhZENvZGVQb2ludCgpKSAvLyAndSdcbiAgICBjYXNlIDExNjogcmV0dXJuIFwiXFx0XCIgLy8gJ3QnIC0+ICdcXHQnXG4gICAgY2FzZSA5ODogcmV0dXJuIFwiXFxiXCIgLy8gJ2InIC0+ICdcXGInXG4gICAgY2FzZSAxMTg6IHJldHVybiBcIlxcdTAwMGJcIiAvLyAndicgLT4gJ1xcdTAwMGInXG4gICAgY2FzZSAxMDI6IHJldHVybiBcIlxcZlwiIC8vICdmJyAtPiAnXFxmJ1xuICAgIGNhc2UgMTM6IGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSAxMCkgKyt0aGlzLnBvcyAvLyAnXFxyXFxuJ1xuICAgIGNhc2UgMTA6IC8vICcgXFxuJ1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHsgdGhpcy5saW5lU3RhcnQgPSB0aGlzLnBvczsgKyt0aGlzLmN1ckxpbmUgfVxuICAgICAgcmV0dXJuIFwiXCJcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKGNoID49IDQ4ICYmIGNoIDw9IDU1KSB7XG4gICAgICAgIHZhciBvY3RhbFN0ciA9IHRoaXMuaW5wdXQuc3Vic3RyKHRoaXMucG9zIC0gMSwgMykubWF0Y2goL15bMC03XSsvKVswXVxuICAgICAgICB2YXIgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOClcbiAgICAgICAgaWYgKG9jdGFsID4gMjU1KSB7XG4gICAgICAgICAgb2N0YWxTdHIgPSBvY3RhbFN0ci5zbGljZSgwLCAtMSlcbiAgICAgICAgICBvY3RhbCA9IHBhcnNlSW50KG9jdGFsU3RyLCA4KVxuICAgICAgICB9XG4gICAgICAgIGlmIChvY3RhbFN0ciAhPT0gXCIwXCIgJiYgKHRoaXMuc3RyaWN0IHx8IGluVGVtcGxhdGUpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZSh0aGlzLnBvcyAtIDIsIFwiT2N0YWwgbGl0ZXJhbCBpbiBzdHJpY3QgbW9kZVwiKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zICs9IG9jdGFsU3RyLmxlbmd0aCAtIDFcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUob2N0YWwpXG4gICAgICB9XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjaClcbiAgICB9XG4gIH1cblxuICAvLyBVc2VkIHRvIHJlYWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZXMgKCdcXHgnLCAnXFx1JywgJ1xcVScpLlxuXG4gIHBwJDcucmVhZEhleENoYXIgPSBmdW5jdGlvbihsZW4pIHtcbiAgICB2YXIgY29kZVBvcyA9IHRoaXMucG9zXG4gICAgdmFyIG4gPSB0aGlzLnJlYWRJbnQoMTYsIGxlbilcbiAgICBpZiAobiA9PT0gbnVsbCkgdGhpcy5yYWlzZShjb2RlUG9zLCBcIkJhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlXCIpXG4gICAgcmV0dXJuIG5cbiAgfVxuXG4gIC8vIFJlYWQgYW4gaWRlbnRpZmllciwgYW5kIHJldHVybiBpdCBhcyBhIHN0cmluZy4gU2V0cyBgdGhpcy5jb250YWluc0VzY2BcbiAgLy8gdG8gd2hldGhlciB0aGUgd29yZCBjb250YWluZWQgYSAnXFx1JyBlc2NhcGUuXG4gIC8vXG4gIC8vIEluY3JlbWVudGFsbHkgYWRkcyBvbmx5IGVzY2FwZWQgY2hhcnMsIGFkZGluZyBvdGhlciBjaHVua3MgYXMtaXNcbiAgLy8gYXMgYSBtaWNyby1vcHRpbWl6YXRpb24uXG5cbiAgcHAkNy5yZWFkV29yZDEgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMuY29udGFpbnNFc2MgPSBmYWxzZVxuICAgIHZhciB3b3JkID0gXCJcIiwgZmlyc3QgPSB0cnVlLCBjaHVua1N0YXJ0ID0gdGhpcy5wb3NcbiAgICB2YXIgYXN0cmFsID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDZcbiAgICB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgICAgdmFyIGNoID0gdGhpcyQxLmZ1bGxDaGFyQ29kZUF0UG9zKClcbiAgICAgIGlmIChpc0lkZW50aWZpZXJDaGFyKGNoLCBhc3RyYWwpKSB7XG4gICAgICAgIHRoaXMkMS5wb3MgKz0gY2ggPD0gMHhmZmZmID8gMSA6IDJcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDkyKSB7IC8vIFwiXFxcIlxuICAgICAgICB0aGlzJDEuY29udGFpbnNFc2MgPSB0cnVlXG4gICAgICAgIHdvcmQgKz0gdGhpcyQxLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMkMS5wb3MpXG4gICAgICAgIHZhciBlc2NTdGFydCA9IHRoaXMkMS5wb3NcbiAgICAgICAgaWYgKHRoaXMkMS5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcyQxLnBvcykgIT0gMTE3KSAvLyBcInVcIlxuICAgICAgICAgIHRoaXMkMS5yYWlzZSh0aGlzJDEucG9zLCBcIkV4cGVjdGluZyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZSBcXFxcdVhYWFhcIilcbiAgICAgICAgKyt0aGlzJDEucG9zXG4gICAgICAgIHZhciBlc2MgPSB0aGlzJDEucmVhZENvZGVQb2ludCgpXG4gICAgICAgIGlmICghKGZpcnN0ID8gaXNJZGVudGlmaWVyU3RhcnQgOiBpc0lkZW50aWZpZXJDaGFyKShlc2MsIGFzdHJhbCkpXG4gICAgICAgICAgdGhpcyQxLnJhaXNlKGVzY1N0YXJ0LCBcIkludmFsaWQgVW5pY29kZSBlc2NhcGVcIilcbiAgICAgICAgd29yZCArPSBjb2RlUG9pbnRUb1N0cmluZyhlc2MpXG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzJDEucG9zXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgZmlyc3QgPSBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gd29yZCArIHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5wb3MpXG4gIH1cblxuICAvLyBSZWFkIGFuIGlkZW50aWZpZXIgb3Iga2V5d29yZCB0b2tlbi4gV2lsbCBjaGVjayBmb3IgcmVzZXJ2ZWRcbiAgLy8gd29yZHMgd2hlbiBuZWNlc3NhcnkuXG5cbiAgcHAkNy5yZWFkV29yZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB3b3JkID0gdGhpcy5yZWFkV29yZDEoKVxuICAgIHZhciB0eXBlID0gdHQubmFtZVxuICAgIGlmICgodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgfHwgIXRoaXMuY29udGFpbnNFc2MpICYmIHRoaXMua2V5d29yZHMudGVzdCh3b3JkKSlcbiAgICAgIHR5cGUgPSBrZXl3b3JkVHlwZXNbd29yZF1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlLCB3b3JkKVxuICB9XG5cbiAgdmFyIHZlcnNpb24gPSBcIjMuMy4wXCJcblxuICAvLyBUaGUgbWFpbiBleHBvcnRlZCBpbnRlcmZhY2UgKHVuZGVyIGBzZWxmLmFjb3JuYCB3aGVuIGluIHRoZVxuICAvLyBicm93c2VyKSBpcyBhIGBwYXJzZWAgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGNvZGUgc3RyaW5nIGFuZFxuICAvLyByZXR1cm5zIGFuIGFic3RyYWN0IHN5bnRheCB0cmVlIGFzIHNwZWNpZmllZCBieSBbTW96aWxsYSBwYXJzZXJcbiAgLy8gQVBJXVthcGldLlxuICAvL1xuICAvLyBbYXBpXTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9TcGlkZXJNb25rZXkvUGFyc2VyX0FQSVxuXG4gIGZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQYXJzZXIob3B0aW9ucywgaW5wdXQpLnBhcnNlKClcbiAgfVxuXG4gIC8vIFRoaXMgZnVuY3Rpb24gdHJpZXMgdG8gcGFyc2UgYSBzaW5nbGUgZXhwcmVzc2lvbiBhdCBhIGdpdmVuXG4gIC8vIG9mZnNldCBpbiBhIHN0cmluZy4gVXNlZnVsIGZvciBwYXJzaW5nIG1peGVkLWxhbmd1YWdlIGZvcm1hdHNcbiAgLy8gdGhhdCBlbWJlZCBKYXZhU2NyaXB0IGV4cHJlc3Npb25zLlxuXG4gIGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbkF0KGlucHV0LCBwb3MsIG9wdGlvbnMpIHtcbiAgICB2YXIgcCA9IG5ldyBQYXJzZXIob3B0aW9ucywgaW5wdXQsIHBvcylcbiAgICBwLm5leHRUb2tlbigpXG4gICAgcmV0dXJuIHAucGFyc2VFeHByZXNzaW9uKClcbiAgfVxuXG4gIC8vIEFjb3JuIGlzIG9yZ2FuaXplZCBhcyBhIHRva2VuaXplciBhbmQgYSByZWN1cnNpdmUtZGVzY2VudCBwYXJzZXIuXG4gIC8vIFRoZSBgdG9rZW5pemVyYCBleHBvcnQgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIHRvIHRoZSB0b2tlbml6ZXIuXG5cbiAgZnVuY3Rpb24gdG9rZW5pemVyKGlucHV0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQYXJzZXIob3B0aW9ucywgaW5wdXQpXG4gIH1cblxuICBleHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICBleHBvcnRzLnBhcnNlID0gcGFyc2U7XG4gIGV4cG9ydHMucGFyc2VFeHByZXNzaW9uQXQgPSBwYXJzZUV4cHJlc3Npb25BdDtcbiAgZXhwb3J0cy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XG4gIGV4cG9ydHMuUGFyc2VyID0gUGFyc2VyO1xuICBleHBvcnRzLnBsdWdpbnMgPSBwbHVnaW5zO1xuICBleHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gIGV4cG9ydHMuUG9zaXRpb24gPSBQb3NpdGlvbjtcbiAgZXhwb3J0cy5Tb3VyY2VMb2NhdGlvbiA9IFNvdXJjZUxvY2F0aW9uO1xuICBleHBvcnRzLmdldExpbmVJbmZvID0gZ2V0TGluZUluZm87XG4gIGV4cG9ydHMuTm9kZSA9IE5vZGU7XG4gIGV4cG9ydHMuVG9rZW5UeXBlID0gVG9rZW5UeXBlO1xuICBleHBvcnRzLnRva1R5cGVzID0gdHQ7XG4gIGV4cG9ydHMuVG9rQ29udGV4dCA9IFRva0NvbnRleHQ7XG4gIGV4cG9ydHMudG9rQ29udGV4dHMgPSB0eXBlcztcbiAgZXhwb3J0cy5pc0lkZW50aWZpZXJDaGFyID0gaXNJZGVudGlmaWVyQ2hhcjtcbiAgZXhwb3J0cy5pc0lkZW50aWZpZXJTdGFydCA9IGlzSWRlbnRpZmllclN0YXJ0O1xuICBleHBvcnRzLlRva2VuID0gVG9rZW47XG4gIGV4cG9ydHMuaXNOZXdMaW5lID0gaXNOZXdMaW5lO1xuICBleHBvcnRzLmxpbmVCcmVhayA9IGxpbmVCcmVhaztcbiAgZXhwb3J0cy5saW5lQnJlYWtHID0gbGluZUJyZWFrRztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Fjb3JuL2Rpc3QvYWNvcm4uanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbmZ1bmN0aW9uIEJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbigpIHtcclxuXHR0aGlzLnJhbmdlID0gbnVsbDtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbjtcclxuXHJcbkJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbi5wcm90b3R5cGUuaXNOdWxsID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuICEhdGhpcy5udWxsO1xyXG59O1xyXG5CYXNpY0V2YWx1YXRlZEV4cHJlc3Npb24ucHJvdG90eXBlLmlzU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBcInN0cmluZ1wiKTtcclxufTtcclxuQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uLnByb3RvdHlwZS5pc051bWJlciA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgXCJudW1iZXJcIik7XHJcbn07XHJcbkJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbi5wcm90b3R5cGUuaXNCb29sZWFuID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBcImJvb2xcIik7XHJcbn07XHJcbkJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbi5wcm90b3R5cGUuaXNSZWdFeHAgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIFwicmVnRXhwXCIpO1xyXG59O1xyXG5CYXNpY0V2YWx1YXRlZEV4cHJlc3Npb24ucHJvdG90eXBlLmlzQ29uZGl0aW9uYWwgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIFwib3B0aW9uc1wiKTtcclxufTtcclxuQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uLnByb3RvdHlwZS5pc0FycmF5ID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBcIml0ZW1zXCIpO1xyXG59O1xyXG5CYXNpY0V2YWx1YXRlZEV4cHJlc3Npb24ucHJvdG90eXBlLmlzQ29uc3RBcnJheSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgXCJhcnJheVwiKTtcclxufTtcclxuQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uLnByb3RvdHlwZS5pc0lkZW50aWZpZXIgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIFwiaWRlbnRpZmllclwiKTtcclxufTtcclxuQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uLnByb3RvdHlwZS5pc1dyYXBwZWQgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIFwicHJlZml4XCIpIHx8IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBcInBvc3RmaXhcIik7XHJcbn07XHJcbkJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbi5wcm90b3R5cGUuYXNCb29sID0gZnVuY3Rpb24oKSB7XHJcblx0aWYodGhpcy5pc0Jvb2xlYW4oKSkgcmV0dXJuIHRoaXMuYm9vbDtcclxuXHRlbHNlIGlmKHRoaXMuaXNOdWxsKCkpIHJldHVybiBmYWxzZTtcclxuXHRlbHNlIGlmKHRoaXMuaXNTdHJpbmcoKSkgcmV0dXJuICEhdGhpcy5zdHJpbmc7XHJcblx0ZWxzZSBpZih0aGlzLmlzTnVtYmVyKCkpIHJldHVybiAhIXRoaXMubnVtYmVyO1xyXG5cdGVsc2UgaWYodGhpcy5pc1JlZ0V4cCgpKSByZXR1cm4gdHJ1ZTtcclxuXHRlbHNlIGlmKHRoaXMuaXNBcnJheSgpKSByZXR1cm4gdHJ1ZTtcclxuXHRlbHNlIGlmKHRoaXMuaXNDb25zdEFycmF5KCkpIHJldHVybiB0cnVlO1xyXG5cdGVsc2UgaWYodGhpcy5pc1dyYXBwZWQoKSkgcmV0dXJuIHRoaXMucHJlZml4ICYmIHRoaXMucHJlZml4LmFzQm9vbCgpIHx8IHRoaXMucG9zdGZpeCAmJiB0aGlzLnBvc3RmaXguYXNCb29sKCkgPyB0cnVlIDogdW5kZWZpbmVkO1xyXG5cdHJldHVybiB1bmRlZmluZWQ7XHJcbn07XHJcbkJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuXHRpZih0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHJldHVybiB0aGlzLnNldFN0cmluZyh2YWx1ZSk7XHJcblx0aWYodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSByZXR1cm4gdGhpcy5zZXROdW1iZXIodmFsdWUpO1xyXG5cdGlmKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHJldHVybiB0aGlzLnNldEJvb2xlYW4odmFsdWUpO1xyXG5cdGlmKHZhbHVlID09PSBudWxsKSByZXR1cm4gdGhpcy5zZXROdWxsKCk7XHJcblx0aWYodmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHJldHVybiB0aGlzLnNldFJlZ0V4cCh2YWx1ZSk7XHJcblx0aWYoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiB0aGlzLnNldEFycmF5KHZhbHVlKTtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uLnByb3RvdHlwZS5zZXRTdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcclxuXHRpZihzdHIgPT09IG51bGwpXHJcblx0XHRkZWxldGUgdGhpcy5zdHJpbmc7XHJcblx0ZWxzZVxyXG5cdFx0dGhpcy5zdHJpbmcgPSBzdHI7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcbkJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbi5wcm90b3R5cGUuc2V0TnVsbCA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMubnVsbCA9IHRydWU7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcbkJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbi5wcm90b3R5cGUuc2V0TnVtYmVyID0gZnVuY3Rpb24obnVtKSB7XHJcblx0aWYobnVtID09PSBudWxsKVxyXG5cdFx0ZGVsZXRlIHRoaXMubnVtYmVyO1xyXG5cdGVsc2VcclxuXHRcdHRoaXMubnVtYmVyID0gbnVtO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5CYXNpY0V2YWx1YXRlZEV4cHJlc3Npb24ucHJvdG90eXBlLnNldEJvb2xlYW4gPSBmdW5jdGlvbihib29sKSB7XHJcblx0aWYoYm9vbCA9PT0gbnVsbClcclxuXHRcdGRlbGV0ZSB0aGlzLmJvb2w7XHJcblx0ZWxzZVxyXG5cdFx0dGhpcy5ib29sID0gYm9vbDtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uLnByb3RvdHlwZS5zZXRSZWdFeHAgPSBmdW5jdGlvbihyZWdFeHApIHtcclxuXHRpZihyZWdFeHAgPT09IG51bGwpXHJcblx0XHRkZWxldGUgdGhpcy5yZWdFeHA7XHJcblx0ZWxzZVxyXG5cdFx0dGhpcy5yZWdFeHAgPSByZWdFeHA7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcbkJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbi5wcm90b3R5cGUuc2V0SWRlbnRpZmllciA9IGZ1bmN0aW9uKGlkZW50aWZpZXIpIHtcclxuXHRpZihpZGVudGlmaWVyID09PSBudWxsKVxyXG5cdFx0ZGVsZXRlIHRoaXMuaWRlbnRpZmllcjtcclxuXHRlbHNlXHJcblx0XHR0aGlzLmlkZW50aWZpZXIgPSBpZGVudGlmaWVyO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5CYXNpY0V2YWx1YXRlZEV4cHJlc3Npb24ucHJvdG90eXBlLnNldFdyYXBwZWQgPSBmdW5jdGlvbihwcmVmaXgsIHBvc3RmaXgpIHtcclxuXHR0aGlzLnByZWZpeCA9IHByZWZpeDtcclxuXHR0aGlzLnBvc3RmaXggPSBwb3N0Zml4O1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5CYXNpY0V2YWx1YXRlZEV4cHJlc3Npb24ucHJvdG90eXBlLnVuc2V0V3JhcHBlZCA9IGZ1bmN0aW9uKCkge1xyXG5cdGRlbGV0ZSB0aGlzLnByZWZpeDtcclxuXHRkZWxldGUgdGhpcy5wb3N0Zml4O1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5CYXNpY0V2YWx1YXRlZEV4cHJlc3Npb24ucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0aWYob3B0aW9ucyA9PT0gbnVsbClcclxuXHRcdGRlbGV0ZSB0aGlzLm9wdGlvbnM7XHJcblx0ZWxzZVxyXG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uLnByb3RvdHlwZS5zZXRJdGVtcyA9IGZ1bmN0aW9uKGl0ZW1zKSB7XHJcblx0aWYoaXRlbXMgPT09IG51bGwpXHJcblx0XHRkZWxldGUgdGhpcy5pdGVtcztcclxuXHRlbHNlXHJcblx0XHR0aGlzLml0ZW1zID0gaXRlbXM7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcbkJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbi5wcm90b3R5cGUuc2V0QXJyYXkgPSBmdW5jdGlvbihhcnJheSkge1xyXG5cdGlmKGFycmF5ID09PSBudWxsKVxyXG5cdFx0ZGVsZXRlIHRoaXMuYXJyYXk7XHJcblx0ZWxzZVxyXG5cdFx0dGhpcy5hcnJheSA9IGFycmF5O1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5CYXNpY0V2YWx1YXRlZEV4cHJlc3Npb24ucHJvdG90eXBlLmFkZE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0aWYoIXRoaXMub3B0aW9ucykgdGhpcy5vcHRpb25zID0gW107XHJcblx0b3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHRcdHRoaXMub3B0aW9ucy5wdXNoKGl0ZW0pO1xyXG5cdH0sIHRoaXMpO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5CYXNpY0V2YWx1YXRlZEV4cHJlc3Npb24ucHJvdG90eXBlLnNldFJhbmdlID0gZnVuY3Rpb24ocmFuZ2UpIHtcclxuXHR0aGlzLnJhbmdlID0gcmFuZ2U7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgVGFwYWJsZSA9IHJlcXVpcmUoXCJ0YXBhYmxlXCIpO1xyXG52YXIgY3JlYXRlSW5uZXJDYWxsYmFjayA9IHJlcXVpcmUoXCIuL2NyZWF0ZUlubmVyQ2FsbGJhY2tcIik7XHJcblxyXG5mdW5jdGlvbiBSZXNvbHZlcihmaWxlU3lzdGVtKSB7XHJcblx0VGFwYWJsZS5jYWxsKHRoaXMpO1xyXG5cdHRoaXMuZmlsZVN5c3RlbSA9IGZpbGVTeXN0ZW07XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBSZXNvbHZlcjtcclxuXHJcblJlc29sdmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVGFwYWJsZS5wcm90b3R5cGUpO1xyXG5cclxuUmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmVTeW5jID0gZnVuY3Rpb24gcmVzb2x2ZVN5bmMoY29udGV4dCwgcmVxdWVzdCkge1xyXG5cdHZhciBlcnIsIHJlc3VsdCwgc3luYyA9IGZhbHNlO1xyXG5cdHRoaXMucmVzb2x2ZShjb250ZXh0LCByZXF1ZXN0LCBmdW5jdGlvbihlLCByKSB7XHJcblx0XHRlcnIgPSBlO1xyXG5cdFx0cmVzdWx0ID0gcjtcclxuXHRcdHN5bmMgPSB0cnVlO1xyXG5cdH0pO1xyXG5cdGlmKCFzeW5jKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgJ3Jlc29sdmVTeW5jJyBiZWNhdXNlIHRoZSBmaWxlU3lzdGVtIGlzIG5vdCBzeW5jLiBVc2UgJ3Jlc29sdmUnIVwiKTtcclxuXHRpZihlcnIpIHRocm93IGVycjtcclxuXHRyZXR1cm4gcmVzdWx0O1xyXG59O1xyXG5cclxuUmVzb2x2ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKGNvbnRleHQsIHJlcXVlc3QsIGNhbGxiYWNrKSB7XHJcblx0aWYodHlwZW9mIHJlcXVlc3QgPT09IFwic3RyaW5nXCIpIHJlcXVlc3QgPSB0aGlzLnBhcnNlKHJlcXVlc3QpO1xyXG5cdHRoaXMuYXBwbHlQbHVnaW5zKFwicmVzb2x2ZVwiLCBjb250ZXh0LCByZXF1ZXN0KTtcclxuXHR2YXIgb2JqID0ge1xyXG5cdFx0cGF0aDogY29udGV4dCxcclxuXHRcdHJlcXVlc3Q6IHJlcXVlc3QucGF0aCxcclxuXHRcdHF1ZXJ5OiByZXF1ZXN0LnF1ZXJ5LFxyXG5cdFx0ZGlyZWN0b3J5OiByZXF1ZXN0LmRpcmVjdG9yeVxyXG5cdH07XHJcblx0ZnVuY3Rpb24gb25SZXNvbHZlZChlcnIsIHJlc3VsdCkge1xyXG5cdFx0aWYoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHRcdHJldHVybiBjYWxsYmFjayhudWxsLCByZXN1bHQucGF0aCA9PT0gZmFsc2UgPyBmYWxzZSA6IHJlc3VsdC5wYXRoICsgKHJlc3VsdC5xdWVyeSB8fCBcIlwiKSk7XHJcblx0fVxyXG5cdG9uUmVzb2x2ZWQubG9nID0gY2FsbGJhY2subG9nO1xyXG5cdG9uUmVzb2x2ZWQubWlzc2luZyA9IGNhbGxiYWNrLm1pc3Npbmc7XHJcblx0aWYocmVxdWVzdC5tb2R1bGUpIHJldHVybiB0aGlzLmRvUmVzb2x2ZShcIm1vZHVsZVwiLCBvYmosIG9uUmVzb2x2ZWQpO1xyXG5cdGlmKHJlcXVlc3QuZGlyZWN0b3J5KSByZXR1cm4gdGhpcy5kb1Jlc29sdmUoXCJkaXJlY3RvcnlcIiwgb2JqLCBvblJlc29sdmVkKTtcclxuXHRyZXR1cm4gdGhpcy5kb1Jlc29sdmUoW1wiZmlsZVwiLCBcImRpcmVjdG9yeVwiXSwgb2JqLCBvblJlc29sdmVkKTtcclxufTtcclxuXHJcblJlc29sdmVyLnByb3RvdHlwZS5kb1Jlc29sdmUgPSBmdW5jdGlvbiBkb1Jlc29sdmUodHlwZXMsIHJlcXVlc3QsIGNhbGxiYWNrLCBub0Vycm9yKSB7XHJcblx0aWYoIUFycmF5LmlzQXJyYXkodHlwZXMpKSB0eXBlcyA9IFt0eXBlc107XHJcblx0dmFyIHN0YWNrTGluZSA9IHR5cGVzLmpvaW4oXCIgb3IgXCIpICsgXCI6IChcIiArIHJlcXVlc3QucGF0aCArIFwiKSBcIiArXHJcblx0XHQocmVxdWVzdC5yZXF1ZXN0IHx8IFwiXCIpICsgKHJlcXVlc3QucXVlcnkgfHwgXCJcIikgK1xyXG5cdFx0KHJlcXVlc3QuZGlyZWN0b3J5ID8gXCIgZGlyZWN0b3J5XCIgOiBcIlwiKSArXHJcblx0XHQocmVxdWVzdC5tb2R1bGUgPyBcIiBtb2R1bGVcIiA6IFwiXCIpO1xyXG5cdHZhciBuZXdTdGFjayA9IFtzdGFja0xpbmVdO1xyXG5cdGlmKGNhbGxiYWNrLnN0YWNrKSB7XHJcblx0XHRuZXdTdGFjayA9IGNhbGxiYWNrLnN0YWNrLmNvbmNhdChuZXdTdGFjayk7XHJcblx0XHRpZihjYWxsYmFjay5zdGFjay5pbmRleE9mKHN0YWNrTGluZSkgPj0gMCkge1xyXG5cdFx0XHQvLyBQcmV2ZW50IHJlY3Vyc2lvblxyXG5cdFx0XHR2YXIgcmVjdXJzaW9uRXJyb3IgPSBuZXcgRXJyb3IoXCJSZWN1cnNpb24gaW4gcmVzb2x2aW5nXFxuU3RhY2s6XFxuICBcIiArIG5ld1N0YWNrLmpvaW4oXCJcXG4gIFwiKSk7XHJcblx0XHRcdHJlY3Vyc2lvbkVycm9yLnJlY3Vyc2lvbiA9IHRydWU7XHJcblx0XHRcdGlmKGNhbGxiYWNrLmxvZykgY2FsbGJhY2subG9nKFwiYWJvcnQgcmVzb2x2aW5nIGJlY2F1c2Ugb2YgcmVjdXJzaW9uXCIpO1xyXG5cdFx0XHRyZXR1cm4gY2FsbGJhY2socmVjdXJzaW9uRXJyb3IpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHR0aGlzLmFwcGx5UGx1Z2lucyhcInJlc29sdmUtc3RlcFwiLCB0eXBlcywgcmVxdWVzdCk7XHJcblx0dmFyIGxvY2FsTWlzc2luZyA9IFtdO1xyXG5cdHZhciBtaXNzaW5nID0gY2FsbGJhY2subWlzc2luZyA/IHtcclxuXHRcdHB1c2g6IGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHRcdFx0Y2FsbGJhY2subWlzc2luZy5wdXNoKGl0ZW0pO1xyXG5cdFx0XHRsb2NhbE1pc3NpbmcucHVzaChpdGVtKTtcclxuXHRcdH1cclxuXHR9IDogbG9jYWxNaXNzaW5nO1xyXG5cdHZhciBsb2cgPSBbXTtcclxuXHRmdW5jdGlvbiB3cml0ZUxvZyhtc2cpIHtcclxuXHRcdGxvZy5wdXNoKG1zZyk7XHJcblx0fVxyXG5cdGZ1bmN0aW9uIGxvZ0FzU3RyaW5nKCkge1xyXG5cdFx0cmV0dXJuIGxvZy5qb2luKFwiXFxuXCIpO1xyXG5cdH1cclxuXHR2YXIgY3VycmVudFJlcXVlc3RTdHJpbmcgPSByZXF1ZXN0LnJlcXVlc3QgPyByZXF1ZXN0LnJlcXVlc3QgKyBcIiBpbiBcIiArIHJlcXVlc3QucGF0aCA6IHJlcXVlc3QucGF0aDtcclxuXHRpZih0eXBlcy5sZW5ndGggPT0gMSAmJiAhbm9FcnJvcikge1xyXG5cdFx0Ly8gSWYgb25seSBvbmUgdHlwZSwgd2UgY2FuIHBhc3MgdGhlIGVycm9yLlxyXG5cdFx0cmV0dXJuIHRoaXMuYXBwbHlQbHVnaW5zUGFyYWxsZWxCYWlsUmVzdWx0KHR5cGVzWzBdLCByZXF1ZXN0LCBjcmVhdGVJbm5lckNhbGxiYWNrKGZ1bmN0aW9uIGlubmVyQ2FsbGJhY2soZXJyLCByZXN1bHQpIHtcclxuXHRcdFx0aWYoY2FsbGJhY2subG9nKSB7XHJcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGxvZy5sZW5ndGg7IGkrKylcclxuXHRcdFx0XHRcdGNhbGxiYWNrLmxvZyhsb2dbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcblx0XHRcdGlmKHJlc3VsdCkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XHJcblx0XHRcdGlmKHR5cGVzWzBdID09PSBcInJlc3VsdFwiKSByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVxdWVzdCk7XHJcblx0XHRcdHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIFwiICsgdHlwZXNbMF0gKyBcIiAnXCIgKyByZXF1ZXN0LnJlcXVlc3QgKyBcIicgaW4gXCIgKyByZXF1ZXN0LnBhdGgpO1xyXG5cdFx0XHRlcnJvci5kZXRhaWxzID0gbG9nQXNTdHJpbmcoKTtcclxuXHRcdFx0ZXJyb3IubWlzc2luZyA9IGxvY2FsTWlzc2luZztcclxuXHRcdFx0cmV0dXJuIGNhbGxiYWNrKGVycm9yKTtcclxuXHRcdH0sIHtcclxuXHRcdFx0bG9nOiB3cml0ZUxvZyxcclxuXHRcdFx0bWlzc2luZzogbWlzc2luZyxcclxuXHRcdFx0c3RhY2s6IG5ld1N0YWNrXHJcblx0XHR9LCBcInJlc29sdmUgXCIgKyB0eXBlc1swXSArIFwiIFwiICsgY3VycmVudFJlcXVlc3RTdHJpbmcpKTtcclxuXHR9XHJcblx0Ly8gRm9yIG11bHRpcGxlIHR5cGUgd2UgbGlzdCB0aGUgZXJyb3JzIGluIHRoZSBkZXRhaWxzIGFsdGhvdWdoIHNvbWUgb2YgdGhlbSBhcmUgbm90IGltcG9ydGFudFxyXG5cdHRoaXMuZm9yRWFjaEJhaWwodHlwZXMsIGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrKSB7XHJcblx0XHR0aGlzLmFwcGx5UGx1Z2luc1BhcmFsbGVsQmFpbFJlc3VsdCh0eXBlLCByZXF1ZXN0LCBjcmVhdGVJbm5lckNhbGxiYWNrKGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XHJcblx0XHRcdGlmKCFlcnIgJiYgcmVzdWx0KSByZXR1cm4gY2FsbGJhY2socmVzdWx0KTtcclxuXHRcdFx0aWYgKGVycikge1xyXG5cdFx0XHRcdChlcnIubWVzc2FnZSB8fCBcIlwiKS5zcGxpdChcIlxcblwiKS5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcclxuXHRcdFx0XHRcdGxvZy5wdXNoKFwiICBcIiArIGxpbmUpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHR9LCB7XHJcblx0XHRcdGxvZzogd3JpdGVMb2csXHJcblx0XHRcdG1pc3Npbmc6IG1pc3NpbmcsXHJcblx0XHRcdHN0YWNrOiBuZXdTdGFja1xyXG5cdFx0fSwgXCJyZXNvbHZlIFwiICsgdHlwZSkpO1xyXG5cdH0uYmluZCh0aGlzKSwgZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRpZihjYWxsYmFjay5sb2cpIHtcclxuXHRcdFx0Y2FsbGJhY2subG9nKFwicmVzb2x2ZSAnXCIgKyB0eXBlcy5qb2luKFwiJyBvciAnXCIpICsgXCInIFwiICsgY3VycmVudFJlcXVlc3RTdHJpbmcpO1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbG9nLmxlbmd0aDsgaSsrKVxyXG5cdFx0XHRcdGNhbGxiYWNrLmxvZyhcIiAgXCIgKyBsb2dbaV0pO1xyXG5cdFx0fVxyXG5cdFx0aWYobm9FcnJvciAmJiAhcmVzdWx0KSByZXR1cm4gY2FsbGJhY2soKTtcclxuXHRcdGlmKHJlc3VsdCkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XHJcblx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSAnXCIgKyB0eXBlcy5qb2luKFwiJyBvciAnXCIpICsgXCInIFwiICsgY3VycmVudFJlcXVlc3RTdHJpbmcpO1xyXG5cdFx0ZXJyb3IuZGV0YWlscyA9IGxvZ0FzU3RyaW5nKCk7XHJcblx0XHRlcnJvci5taXNzaW5nID0gbG9jYWxNaXNzaW5nO1xyXG5cdFx0cmV0dXJuIGNhbGxiYWNrKGVycm9yKTtcclxuXHR9KTtcclxufTtcclxuXHJcblJlc29sdmVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGlkZW50aWZpZXIpIHtcclxuXHRpZihpZGVudGlmaWVyID09PSBcIlwiKSByZXR1cm4gbnVsbDtcclxuXHR2YXIgcGFydCA9IHtcclxuXHRcdHBhdGg6IG51bGwsXHJcblx0XHRxdWVyeTogbnVsbCxcclxuXHRcdG1vZHVsZTogZmFsc2UsXHJcblx0XHRkaXJlY3Rvcnk6IGZhbHNlLFxyXG5cdFx0ZmlsZTogZmFsc2VcclxuXHR9O1xyXG5cdHZhciBpZHhRdWVyeSA9IGlkZW50aWZpZXIuaW5kZXhPZihcIj9cIik7XHJcblx0aWYoaWR4UXVlcnkgPT0gMCkge1xyXG5cdFx0cGFydC5xdWVyeSA9IGlkZW50aWZpZXI7XHJcblx0fSBlbHNlIGlmKGlkeFF1ZXJ5ID4gMCkge1xyXG5cdFx0cGFydC5wYXRoID0gaWRlbnRpZmllci5zbGljZSgwLCBpZHhRdWVyeSk7XHJcblx0XHRwYXJ0LnF1ZXJ5ID0gaWRlbnRpZmllci5zbGljZShpZHhRdWVyeSk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHBhcnQucGF0aCA9IGlkZW50aWZpZXI7XHJcblx0fVxyXG5cdGlmKHBhcnQucGF0aCkge1xyXG5cdFx0cGFydC5tb2R1bGUgPSB0aGlzLmlzTW9kdWxlKHBhcnQucGF0aCk7XHJcblx0XHRpZihwYXJ0LmRpcmVjdG9yeSA9IHRoaXMuaXNEaXJlY3RvcnkocGFydC5wYXRoKSkge1xyXG5cdFx0XHRwYXJ0LnBhdGggPSBwYXJ0LnBhdGguc3Vic3RyKDAsIHBhcnQucGF0aC5sZW5ndGggLSAxKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHBhcnQ7XHJcbn07XHJcblxyXG52YXIgbm90TW9kdWxlUmVnRXhwID0gL15cXC4kfF5cXC5bXFxcXFxcL118XlxcLlxcLiR8XlxcLlxcLltcXC9cXFxcXXxeXFwvfF5bQS1aXTpbXFxcXFxcL10vaTtcclxuUmVzb2x2ZXIucHJvdG90eXBlLmlzTW9kdWxlID0gZnVuY3Rpb24gaXNNb2R1bGUocGF0aCkge1xyXG5cdHJldHVybiAhbm90TW9kdWxlUmVnRXhwLnRlc3QocGF0aCk7XHJcbn07XHJcblxyXG52YXIgZGlyZWN0b3J5UmVnRXhwID0gL1tcXC9cXFxcXSQvaTtcclxuUmVzb2x2ZXIucHJvdG90eXBlLmlzRGlyZWN0b3J5ID0gZnVuY3Rpb24gaXNEaXJlY3RvcnkocGF0aCkge1xyXG5cdHJldHVybiBkaXJlY3RvcnlSZWdFeHAudGVzdChwYXRoKTtcclxufTtcclxuXHJcblJlc29sdmVyLnByb3RvdHlwZS5qb2luID0gcmVxdWlyZShcIm1lbW9yeS1mcy9saWIvam9pblwiKTtcclxuXHJcblJlc29sdmVyLnByb3RvdHlwZS5ub3JtYWxpemUgPSByZXF1aXJlKFwibWVtb3J5LWZzL2xpYi9ub3JtYWxpemVcIik7XHJcblxyXG5SZXNvbHZlci5wcm90b3R5cGUuZm9yRWFjaEJhaWwgPSBmdW5jdGlvbihhcnJheSwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XHJcblx0aWYoYXJyYXkubGVuZ3RoID09IDApIHJldHVybiBjYWxsYmFjaygpO1xyXG5cdHZhciBjdXJyZW50UG9zID0gYXJyYXkubGVuZ3RoO1xyXG5cdHZhciBjdXJyZW50RXJyb3IsIGN1cnJlbnRSZXN1bHQ7XHJcblx0dmFyIGRvbmUgPSBbXTtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdENiID0gKGZ1bmN0aW9uKGkpIHtcclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGlmKGkgPj0gY3VycmVudFBvcykgcmV0dXJuOyAvLyBpZ25vcmVcclxuXHRcdFx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcblx0XHRcdFx0ZG9uZS5wdXNoKGkpO1xyXG5cdFx0XHRcdGlmKGFyZ3MubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdFx0Y3VycmVudFBvcyA9IGkgKyAxO1xyXG5cdFx0XHRcdFx0ZG9uZSA9IGRvbmUuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGl0ZW0gPD0gaTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0Y3VycmVudFJlc3VsdCA9IGFyZ3M7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKGRvbmUubGVuZ3RoID09IGN1cnJlbnRQb3MpIHtcclxuXHRcdFx0XHRcdGNhbGxiYWNrLmFwcGx5KG51bGwsIGN1cnJlbnRSZXN1bHQpO1xyXG5cdFx0XHRcdFx0Y3VycmVudFBvcyA9IDA7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cdFx0fShpKSk7XHJcblx0XHRpdGVyYXRvcihhcnJheVtpXSwgaXRDYik7XHJcblx0XHRpZihjdXJyZW50UG9zID09IDApIGJyZWFrO1xyXG5cdH1cclxufTtcclxuXHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbmhhbmNlZC1yZXNvbHZlL2xpYi9SZXNvbHZlci5qc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVJbm5lckNhbGxiYWNrKGNhbGxiYWNrLCBvcHRpb25zLCBtZXNzYWdlKSB7XHJcblx0dmFyIGxvZyA9IG9wdGlvbnMubG9nO1xyXG5cdGlmKCFsb2cpIHtcclxuXHRcdGlmKG9wdGlvbnMuc3RhY2sgIT09IGNhbGxiYWNrLnN0YWNrKSB7XHJcblx0XHRcdGZ1bmN0aW9uIGNhbGxiYWNrV3JhcHBlcigpIHtcclxuXHRcdFx0XHRyZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjYWxsYmFja1dyYXBwZXIuc3RhY2sgPSBvcHRpb25zLnN0YWNrO1xyXG5cdFx0XHRjYWxsYmFja1dyYXBwZXIubWlzc2luZyA9IG9wdGlvbnMubWlzc2luZztcclxuXHRcdH1cclxuXHRcdHJldHVybiBjYWxsYmFjaztcclxuXHR9XHJcblx0ZnVuY3Rpb24gbG9nZ2luZ0NhbGxiYWNrV3JhcHBlcigpIHtcclxuXHRcdGxvZyhtZXNzYWdlKTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGVMb2cubGVuZ3RoOyBpKyspXHJcblx0XHRcdGxvZyhcIiAgXCIgKyB0aGVMb2dbaV0pO1xyXG5cdFx0cmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0fVxyXG5cdHZhciB0aGVMb2cgPSBbXTtcclxuXHRsb2dnaW5nQ2FsbGJhY2tXcmFwcGVyLmxvZyA9IGZ1bmN0aW9uIHdyaXRlTG9nKG1zZykge1xyXG5cdFx0dGhlTG9nLnB1c2gobXNnKTtcclxuXHR9O1xyXG5cdGxvZ2dpbmdDYWxsYmFja1dyYXBwZXIuc3RhY2sgPSBvcHRpb25zLnN0YWNrO1xyXG5cdGxvZ2dpbmdDYWxsYmFja1dyYXBwZXIubWlzc2luZyA9IG9wdGlvbnMubWlzc2luZztcclxuXHRyZXR1cm4gbG9nZ2luZ0NhbGxiYWNrV3JhcHBlcjtcclxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbmhhbmNlZC1yZXNvbHZlL2xpYi9jcmVhdGVJbm5lckNhbGxiYWNrLmpzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbm9ybWFsaXplID0gcmVxdWlyZShcIi4vbm9ybWFsaXplXCIpO1xyXG5cclxudmFyIGFic29sdXRlV2luUmVnRXhwID0gL15bQS1aXTooW1xcXFxcXC9dfCQpL2k7XHJcbnZhciBhYnNvbHV0ZU5peFJlZ0V4cCA9IC9eXFwvL2k7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGpvaW4ocGF0aCwgcmVxdWVzdCkge1xyXG5cdGlmKHJlcXVlc3QgPT0gXCJcIikgcmV0dXJuIG5vcm1hbGl6ZShwYXRoKTtcclxuXHRpZihhYnNvbHV0ZVdpblJlZ0V4cC50ZXN0KHJlcXVlc3QpKSByZXR1cm4gbm9ybWFsaXplKHJlcXVlc3QucmVwbGFjZSgvXFwvL2csIFwiXFxcXFwiKSk7XHJcblx0aWYoYWJzb2x1dGVOaXhSZWdFeHAudGVzdChyZXF1ZXN0KSkgcmV0dXJuIG5vcm1hbGl6ZShyZXF1ZXN0KTtcclxuXHRpZihwYXRoID09IFwiL1wiKSByZXR1cm4gbm9ybWFsaXplKHBhdGggKyByZXF1ZXN0KTtcclxuXHRpZihhYnNvbHV0ZVdpblJlZ0V4cC50ZXN0KHBhdGgpKSByZXR1cm4gbm9ybWFsaXplKHBhdGggKyBcIlxcXFxcIiArIHJlcXVlc3QucmVwbGFjZSgvXFwvL2csIFwiXFxcXFwiKSk7XHJcblx0aWYoYWJzb2x1dGVOaXhSZWdFeHAudGVzdChwYXRoKSkgcmV0dXJuIG5vcm1hbGl6ZShwYXRoICsgXCIvXCIgKyByZXF1ZXN0KTtcclxuXHRyZXR1cm4gbm9ybWFsaXplKHBhdGggKyBcIi9cIiArIHJlcXVlc3QpO1xyXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbmhhbmNlZC1yZXNvbHZlL34vbWVtb3J5LWZzL2xpYi9qb2luLmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZG91YmxlU2xhc2hXaW5SZWdFeHAgPSAvXFxcXCsvZztcclxudmFyIGRvdWJsZVNsYXNoTml4UmVnRXhwID0gL1xcLysvZztcclxudmFyIGN1cnJlbnREaXJlY3RvcnlXaW5NaWRkbGVSZWdFeHAgPSAvXFxcXChcXC5cXFxcKSsvO1xyXG52YXIgY3VycmVudERpcmVjdG9yeVdpbkVuZFJlZ0V4cCA9IC9cXFxcXFwuJC87XHJcbnZhciBwYXJlbnREaXJlY3RvcnlXaW5NaWRkbGVSZWdFeHAgPSAvXFxcXCtbXlxcXFxdK1xcXFwrXFwuXFwuXFxcXC87XHJcbnZhciBwYXJlbnREaXJlY3RvcnlXaW5FbmRSZWdFeHAxID0gLyhbQS1aXTpcXFxcKVxcXFwqW15cXFxcXStcXFxcK1xcLlxcLiQvaTtcclxudmFyIHBhcmVudERpcmVjdG9yeVdpbkVuZFJlZ0V4cDIgPSAvXFxcXCtbXlxcXFxdK1xcXFwrXFwuXFwuJC87XHJcbnZhciBjdXJyZW50RGlyZWN0b3J5Tml4TWlkZGxlUmVnRXhwID0gL1xcLysoXFwuXFwvKSsvO1xyXG52YXIgY3VycmVudERpcmVjdG9yeU5peEVuZFJlZ0V4cDEgPSAvXlxcLytcXC4kLztcclxudmFyIGN1cnJlbnREaXJlY3RvcnlOaXhFbmRSZWdFeHAyID0gL1xcLytcXC4kLztcclxudmFyIHBhcmVudERpcmVjdG9yeU5peE1pZGRsZVJlZ0V4cCA9IC8oXnxcXC9bXlxcL10rKVxcLytcXC5cXC5cXC8rLztcclxudmFyIHBhcmVudERpcmVjdG9yeU5peEVuZFJlZ0V4cDEgPSAvXlxcL1teXFwvXStcXC8rXFwuXFwuJC87XHJcbnZhciBwYXJlbnREaXJlY3RvcnlOaXhFbmRSZWdFeHAyID0gL1xcLytbXlxcL10rXFwvK1xcLlxcLiQvO1xyXG52YXIgcGFyZW50RGlyZWN0b3J5Tml4RW5kUmVnRXhwMyA9IC9eXFwvK1xcLlxcLiQvO1xyXG5cclxuLy8gUmVnRXhwIG1hZ2ljIDopXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShwYXRoKSB7XHJcblx0d2hpbGUoY3VycmVudERpcmVjdG9yeVdpbk1pZGRsZVJlZ0V4cC50ZXN0KHBhdGgpKVxyXG5cdFx0cGF0aCA9IHBhdGgucmVwbGFjZShjdXJyZW50RGlyZWN0b3J5V2luTWlkZGxlUmVnRXhwLCBcIlxcXFxcIik7XHJcblx0cGF0aCA9IHBhdGgucmVwbGFjZShjdXJyZW50RGlyZWN0b3J5V2luRW5kUmVnRXhwLCBcIlwiKTtcclxuXHR3aGlsZShwYXJlbnREaXJlY3RvcnlXaW5NaWRkbGVSZWdFeHAudGVzdChwYXRoKSlcclxuXHRcdHBhdGggPSBwYXRoLnJlcGxhY2UocGFyZW50RGlyZWN0b3J5V2luTWlkZGxlUmVnRXhwLCBcIlxcXFxcIik7XHJcblx0cGF0aCA9IHBhdGgucmVwbGFjZShwYXJlbnREaXJlY3RvcnlXaW5FbmRSZWdFeHAxLCBcIiQxXCIpO1xyXG5cdHBhdGggPSBwYXRoLnJlcGxhY2UocGFyZW50RGlyZWN0b3J5V2luRW5kUmVnRXhwMiwgXCJcIik7XHJcblxyXG5cdHdoaWxlKGN1cnJlbnREaXJlY3RvcnlOaXhNaWRkbGVSZWdFeHAudGVzdChwYXRoKSlcclxuXHRcdHBhdGggPSBwYXRoLnJlcGxhY2UoY3VycmVudERpcmVjdG9yeU5peE1pZGRsZVJlZ0V4cCwgXCIvXCIpO1xyXG5cdHBhdGggPSBwYXRoLnJlcGxhY2UoY3VycmVudERpcmVjdG9yeU5peEVuZFJlZ0V4cDEsIFwiL1wiKTtcclxuXHRwYXRoID0gcGF0aC5yZXBsYWNlKGN1cnJlbnREaXJlY3RvcnlOaXhFbmRSZWdFeHAyLCBcIlwiKTtcclxuXHR3aGlsZShwYXJlbnREaXJlY3RvcnlOaXhNaWRkbGVSZWdFeHAudGVzdChwYXRoKSlcclxuXHRcdHBhdGggPSBwYXRoLnJlcGxhY2UocGFyZW50RGlyZWN0b3J5Tml4TWlkZGxlUmVnRXhwLCBcIi9cIik7XHJcblx0cGF0aCA9IHBhdGgucmVwbGFjZShwYXJlbnREaXJlY3RvcnlOaXhFbmRSZWdFeHAxLCBcIi9cIik7XHJcblx0cGF0aCA9IHBhdGgucmVwbGFjZShwYXJlbnREaXJlY3RvcnlOaXhFbmRSZWdFeHAyLCBcIlwiKTtcclxuXHRwYXRoID0gcGF0aC5yZXBsYWNlKHBhcmVudERpcmVjdG9yeU5peEVuZFJlZ0V4cDMsIFwiL1wiKTtcclxuXHJcblx0cmV0dXJuIHBhdGgucmVwbGFjZShkb3VibGVTbGFzaFdpblJlZ0V4cCwgXCJcXFxcXCIpLnJlcGxhY2UoZG91YmxlU2xhc2hOaXhSZWdFeHAsIFwiL1wiKTtcclxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZW5oYW5jZWQtcmVzb2x2ZS9+L21lbW9yeS1mcy9saWIvbm9ybWFsaXplLmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgYXN5bmMgPSByZXF1aXJlKFwiYXN5bmNcIik7XHJcblxyXG52YXIgVGFwYWJsZSA9IHJlcXVpcmUoXCJ0YXBhYmxlXCIpO1xyXG52YXIgTm9ybWFsTW9kdWxlID0gcmVxdWlyZShcIi4vTm9ybWFsTW9kdWxlXCIpO1xyXG52YXIgUmF3TW9kdWxlID0gcmVxdWlyZShcIi4vUmF3TW9kdWxlXCIpO1xyXG52YXIgTG9hZGVyc0xpc3QgPSByZXF1aXJlKFwid2VicGFjay1jb3JlL2xpYi9Mb2FkZXJzTGlzdFwiKTtcclxuXHJcbmZ1bmN0aW9uIE5vcm1hbE1vZHVsZUZhY3RvcnkoY29udGV4dCwgcmVzb2x2ZXJzLCBwYXJzZXIsIG9wdGlvbnMpIHtcclxuXHRUYXBhYmxlLmNhbGwodGhpcyk7XHJcblx0dGhpcy5yZXNvbHZlcnMgPSByZXNvbHZlcnM7XHJcblx0dGhpcy5wYXJzZXIgPSBwYXJzZXI7XHJcblx0dGhpcy5sb2FkZXJzID0gbmV3IExvYWRlcnNMaXN0KG9wdGlvbnMubG9hZGVycyk7XHJcblx0dGhpcy5wcmVMb2FkZXJzID0gbmV3IExvYWRlcnNMaXN0KG9wdGlvbnMucHJlTG9hZGVycyk7XHJcblx0dGhpcy5wb3N0TG9hZGVycyA9IG5ldyBMb2FkZXJzTGlzdChvcHRpb25zLnBvc3RMb2FkZXJzKTtcclxuXHR0aGlzLmNvbnRleHQgPSBjb250ZXh0IHx8IFwiXCI7XHJcblx0dGhpcy5wbHVnaW4oXCJmYWN0b3J5XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIF90aGlzID0gdGhpcztcclxuXHRcdHJldHVybiBmdW5jdGlvbihyZXN1bHQsIGNhbGxiYWNrKSB7XHJcblx0XHRcdHZhciByZXNvbHZlciA9IF90aGlzLmFwcGx5UGx1Z2luc1dhdGVyZmFsbChcInJlc29sdmVyXCIsIG51bGwpO1xyXG5cclxuXHRcdFx0Ly8gSWdub3JlZFxyXG5cdFx0XHRpZighcmVzb2x2ZXIpIHJldHVybiBjYWxsYmFjaygpO1xyXG5cclxuXHRcdFx0cmVzb2x2ZXIocmVzdWx0LCBmdW5jdGlvbiBvbkRvbmVSZXNvbHZpbmcoZXJyLCBkYXRhKSB7XHJcblx0XHRcdFx0aWYoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHJcblx0XHRcdFx0Ly8gSWdub3JlZFxyXG5cdFx0XHRcdGlmKCFkYXRhKSByZXR1cm4gY2FsbGJhY2soKTtcclxuXHJcblx0XHRcdFx0Ly8gZGlyZWN0IG1vZHVsZVxyXG5cdFx0XHRcdGlmKHR5cGVvZiBkYXRhLnNvdXJjZSA9PT0gXCJmdW5jdGlvblwiKVxyXG5cdFx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xyXG5cclxuXHRcdFx0XHRfdGhpcy5hcHBseVBsdWdpbnNBc3luY1dhdGVyZmFsbChcImFmdGVyLXJlc29sdmVcIiwgZGF0YSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcclxuXHRcdFx0XHRcdGlmKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcblxyXG5cdFx0XHRcdFx0Ly8gSWdub3JlZFxyXG5cdFx0XHRcdFx0aWYoIXJlc3VsdCkgcmV0dXJuIGNhbGxiYWNrKCk7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGNyZWF0ZWRNb2R1bGUgPSBfdGhpcy5hcHBseVBsdWdpbnNCYWlsUmVzdWx0KFwiY3JlYXRlLW1vZHVsZVwiLCByZXN1bHQpO1xyXG5cdFx0XHRcdFx0aWYoIWNyZWF0ZWRNb2R1bGUpIHtcclxuXHRcdFx0XHRcdFx0Y3JlYXRlZE1vZHVsZSA9IG5ldyBOb3JtYWxNb2R1bGUoXHJcblx0XHRcdFx0XHRcdFx0cmVzdWx0LnJlcXVlc3QsXHJcblx0XHRcdFx0XHRcdFx0cmVzdWx0LnVzZXJSZXF1ZXN0LFxyXG5cdFx0XHRcdFx0XHRcdHJlc3VsdC5yYXdSZXF1ZXN0LFxyXG5cdFx0XHRcdFx0XHRcdHJlc3VsdC5sb2FkZXJzLFxyXG5cdFx0XHRcdFx0XHRcdHJlc3VsdC5yZXNvdXJjZSxcclxuXHRcdFx0XHRcdFx0XHRyZXN1bHQucGFyc2VyXHJcblx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Y3JlYXRlZE1vZHVsZSA9IF90aGlzLmFwcGx5UGx1Z2luc1dhdGVyZmFsbChcIm1vZHVsZVwiLCBjcmVhdGVkTW9kdWxlKTtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gY2FsbGJhY2sobnVsbCwgY3JlYXRlZE1vZHVsZSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fTtcclxuXHR9KTtcclxuXHR0aGlzLnBsdWdpbihcInJlc29sdmVyXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIF90aGlzID0gdGhpcztcclxuXHRcdHJldHVybiBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xyXG5cdFx0XHR2YXIgY29udGV4dCA9IGRhdGEuY29udGV4dDtcclxuXHRcdFx0dmFyIHJlcXVlc3QgPSBkYXRhLnJlcXVlc3Q7XHJcblxyXG5cdFx0XHR2YXIgbm9BdXRvTG9hZGVycyA9IC9eLT8hLy50ZXN0KHJlcXVlc3QpO1xyXG5cdFx0XHR2YXIgbm9QcmVQb3N0QXV0b0xvYWRlcnMgPSAvXiEhLy50ZXN0KHJlcXVlc3QpO1xyXG5cdFx0XHR2YXIgbm9Qb3N0QXV0b0xvYWRlcnMgPSAvXi0hLy50ZXN0KHJlcXVlc3QpO1xyXG5cdFx0XHR2YXIgZWxlbWVudHMgPSByZXF1ZXN0LnJlcGxhY2UoL14tPyErLywgXCJcIikucmVwbGFjZSgvISErL2csIFwiIVwiKS5zcGxpdChcIiFcIik7XHJcblx0XHRcdHZhciByZXNvdXJjZSA9IGVsZW1lbnRzLnBvcCgpO1xyXG5cclxuXHRcdFx0YXN5bmMucGFyYWxsZWwoW1xyXG5cdFx0XHRcdGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcblx0XHRcdFx0XHRfdGhpcy5yZXNvbHZlUmVxdWVzdEFycmF5KGNvbnRleHQsIGVsZW1lbnRzLCBfdGhpcy5yZXNvbHZlcnMubG9hZGVyLCBjYWxsYmFjayk7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRmdW5jdGlvbihjYWxsYmFjaykge1xyXG5cdFx0XHRcdFx0aWYocmVzb3VyY2UgPT09IFwiXCIgfHwgcmVzb3VyY2VbMF0gPT09IFwiP1wiKVxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzb3VyY2UpO1xyXG5cdFx0XHRcdFx0X3RoaXMucmVzb2x2ZXJzLm5vcm1hbC5yZXNvbHZlKGNvbnRleHQsIHJlc291cmNlLCBjYWxsYmFjayk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRdLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcclxuXHRcdFx0XHRpZihlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG5cdFx0XHRcdHZhciBsb2FkZXJzID0gcmVzdWx0c1swXTtcclxuXHRcdFx0XHRyZXNvdXJjZSA9IHJlc3VsdHNbMV07XHJcblxyXG5cdFx0XHRcdGlmKHJlc291cmNlID09PSBmYWxzZSlcclxuXHRcdFx0XHRcdHJldHVybiBjYWxsYmFjayhudWxsLFxyXG5cdFx0XHRcdFx0XHRuZXcgUmF3TW9kdWxlKFwiLyogKGlnbm9yZWQpICovXCIsXHJcblx0XHRcdFx0XHRcdFx0XCJpZ25vcmVkIFwiICsgY29udGV4dCArIFwiIFwiICsgcmVxdWVzdCxcclxuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0ICsgXCIgKGlnbm9yZWQpXCIpKTsgLy8gaWdub3JlZFxyXG5cclxuXHRcdFx0XHR2YXIgdXNlclJlcXVlc3QgPSBsb2FkZXJzLmNvbmNhdChbcmVzb3VyY2VdKS5qb2luKFwiIVwiKTtcclxuXHJcblx0XHRcdFx0aWYobm9QcmVQb3N0QXV0b0xvYWRlcnMpXHJcblx0XHRcdFx0XHRyZXR1cm4gb25Eb25lUmVzb2x2aW5nKCk7XHJcblx0XHRcdFx0aWYobm9BdXRvTG9hZGVycykge1xyXG5cdFx0XHRcdFx0YXN5bmMucGFyYWxsZWwoW1xyXG5cdFx0XHRcdFx0XHRfdGhpcy5yZXNvbHZlUmVxdWVzdEFycmF5LmJpbmQoX3RoaXMsIGNvbnRleHQsIG5vUG9zdEF1dG9Mb2FkZXJzID8gW10gOiBfdGhpcy5wb3N0TG9hZGVycy5tYXRjaChyZXNvdXJjZSksIF90aGlzLnJlc29sdmVycy5sb2FkZXIpLFxyXG5cdFx0XHRcdFx0XHRfdGhpcy5yZXNvbHZlUmVxdWVzdEFycmF5LmJpbmQoX3RoaXMsIGNvbnRleHQsIF90aGlzLnByZUxvYWRlcnMubWF0Y2gocmVzb3VyY2UpLCBfdGhpcy5yZXNvbHZlcnMubG9hZGVyKVxyXG5cdFx0XHRcdFx0XSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XHJcblx0XHRcdFx0XHRcdGlmKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcblx0XHRcdFx0XHRcdGxvYWRlcnMgPSByZXN1bHRzWzBdLmNvbmNhdChsb2FkZXJzKS5jb25jYXQocmVzdWx0c1sxXSk7XHJcblx0XHRcdFx0XHRcdG9uRG9uZVJlc29sdmluZygpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGFzeW5jLnBhcmFsbGVsKFtcclxuXHRcdFx0XHRcdFx0X3RoaXMucmVzb2x2ZVJlcXVlc3RBcnJheS5iaW5kKF90aGlzLCBjb250ZXh0LCBub1Bvc3RBdXRvTG9hZGVycyA/IFtdIDogX3RoaXMucG9zdExvYWRlcnMubWF0Y2gocmVzb3VyY2UpLCBfdGhpcy5yZXNvbHZlcnMubG9hZGVyKSxcclxuXHRcdFx0XHRcdFx0X3RoaXMucmVzb2x2ZVJlcXVlc3RBcnJheS5iaW5kKF90aGlzLCBjb250ZXh0LCBfdGhpcy5sb2FkZXJzLm1hdGNoKHJlc291cmNlKSwgX3RoaXMucmVzb2x2ZXJzLmxvYWRlciksXHJcblx0XHRcdFx0XHRcdF90aGlzLnJlc29sdmVSZXF1ZXN0QXJyYXkuYmluZChfdGhpcywgY29udGV4dCwgX3RoaXMucHJlTG9hZGVycy5tYXRjaChyZXNvdXJjZSksIF90aGlzLnJlc29sdmVycy5sb2FkZXIpXHJcblx0XHRcdFx0XHRdLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcclxuXHRcdFx0XHRcdFx0aWYoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHRcdFx0XHRcdFx0bG9hZGVycyA9IHJlc3VsdHNbMF0uY29uY2F0KGxvYWRlcnMpLmNvbmNhdChyZXN1bHRzWzFdKS5jb25jYXQocmVzdWx0c1syXSk7XHJcblx0XHRcdFx0XHRcdG9uRG9uZVJlc29sdmluZygpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmdW5jdGlvbiBvbkRvbmVSZXNvbHZpbmcoKSB7XHJcblx0XHRcdFx0XHRjYWxsYmFjayhudWxsLCB7XHJcblx0XHRcdFx0XHRcdGNvbnRleHQ6IGNvbnRleHQsXHJcblx0XHRcdFx0XHRcdHJlcXVlc3Q6IGxvYWRlcnMuY29uY2F0KFtyZXNvdXJjZV0pLmpvaW4oXCIhXCIpLFxyXG5cdFx0XHRcdFx0XHR1c2VyUmVxdWVzdDogdXNlclJlcXVlc3QsXHJcblx0XHRcdFx0XHRcdHJhd1JlcXVlc3Q6IHJlcXVlc3QsXHJcblx0XHRcdFx0XHRcdGxvYWRlcnM6IGxvYWRlcnMsXHJcblx0XHRcdFx0XHRcdHJlc291cmNlOiByZXNvdXJjZSxcclxuXHRcdFx0XHRcdFx0cGFyc2VyOiBfdGhpcy5wYXJzZXJcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9O1xyXG5cdH0pO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gTm9ybWFsTW9kdWxlRmFjdG9yeTtcclxuXHJcbk5vcm1hbE1vZHVsZUZhY3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUYXBhYmxlLnByb3RvdHlwZSk7XHJcbk5vcm1hbE1vZHVsZUZhY3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTm9ybWFsTW9kdWxlRmFjdG9yeTtcclxuXHJcbk5vcm1hbE1vZHVsZUZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGNvbnRleHQsIGRlcGVuZGVuY3ksIGNhbGxiYWNrKSB7XHJcblx0dmFyIF90aGlzID0gdGhpcztcclxuXHRjb250ZXh0ID0gY29udGV4dCB8fCB0aGlzLmNvbnRleHQ7XHJcblx0dmFyIHJlcXVlc3QgPSBkZXBlbmRlbmN5LnJlcXVlc3Q7XHJcblx0X3RoaXMuYXBwbHlQbHVnaW5zQXN5bmNXYXRlcmZhbGwoXCJiZWZvcmUtcmVzb2x2ZVwiLCB7XHJcblx0XHRjb250ZXh0OiBjb250ZXh0LFxyXG5cdFx0cmVxdWVzdDogcmVxdWVzdCxcclxuXHRcdGRlcGVuZGVuY3k6IGRlcGVuZGVuY3lcclxuXHR9LCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xyXG5cdFx0aWYoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHJcblx0XHQvLyBJZ25vcmVkXHJcblx0XHRpZighcmVzdWx0KSByZXR1cm4gY2FsbGJhY2soKTtcclxuXHJcblx0XHR2YXIgZmFjdG9yeSA9IF90aGlzLmFwcGx5UGx1Z2luc1dhdGVyZmFsbChcImZhY3RvcnlcIiwgbnVsbCk7XHJcblxyXG5cdFx0Ly8gSWdub3JlZFxyXG5cdFx0aWYoIWZhY3RvcnkpIHJldHVybiBjYWxsYmFjaygpO1xyXG5cclxuXHRcdGZhY3RvcnkocmVzdWx0LCBjYWxsYmFjayk7XHJcblxyXG5cdH0pO1xyXG59O1xyXG5cclxuTm9ybWFsTW9kdWxlRmFjdG9yeS5wcm90b3R5cGUucmVzb2x2ZVJlcXVlc3RBcnJheSA9IGZ1bmN0aW9uIHJlc29sdmVSZXF1ZXN0QXJyYXkoY29udGV4dCwgYXJyYXksIHJlc29sdmVyLCBjYWxsYmFjaykge1xyXG5cdGlmKGFycmF5Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIFtdKTtcclxuXHRhc3luYy5tYXAoYXJyYXksIGZ1bmN0aW9uKGl0ZW0sIGNhbGxiYWNrKSB7XHJcblx0XHRpZihpdGVtID09PSBcIlwiIHx8IGl0ZW1bMF0gPT09IFwiP1wiKVxyXG5cdFx0XHRyZXR1cm4gY2FsbGJhY2sobnVsbCwgaXRlbSk7XHJcblx0XHRyZXNvbHZlci5yZXNvbHZlKGNvbnRleHQsIGl0ZW0sIGNhbGxiYWNrKTtcclxuXHR9LCBjYWxsYmFjayk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvTm9ybWFsTW9kdWxlRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcclxudmFyIE1vZHVsZSA9IHJlcXVpcmUoXCIuL01vZHVsZVwiKTtcclxudmFyIE5vcm1hbE1vZHVsZU1peGluID0gcmVxdWlyZShcIndlYnBhY2stY29yZS9saWIvTm9ybWFsTW9kdWxlTWl4aW5cIik7XHJcbnZhciBTb3VyY2VNYXBTb3VyY2UgPSByZXF1aXJlKFwid2VicGFjay1jb3JlL2xpYi9Tb3VyY2VNYXBTb3VyY2VcIik7XHJcbnZhciBPcmlnaW5hbFNvdXJjZSA9IHJlcXVpcmUoXCJ3ZWJwYWNrLWNvcmUvbGliL09yaWdpbmFsU291cmNlXCIpO1xyXG52YXIgUmF3U291cmNlID0gcmVxdWlyZShcIndlYnBhY2stY29yZS9saWIvUmF3U291cmNlXCIpO1xyXG52YXIgUmVwbGFjZVNvdXJjZSA9IHJlcXVpcmUoXCJ3ZWJwYWNrLWNvcmUvbGliL1JlcGxhY2VTb3VyY2VcIik7XHJcbnZhciBDYWNoZWRTb3VyY2UgPSByZXF1aXJlKFwid2VicGFjay1jb3JlL2xpYi9DYWNoZWRTb3VyY2VcIik7XHJcbnZhciBNb2R1bGVQYXJzZUVycm9yID0gcmVxdWlyZShcIi4vTW9kdWxlUGFyc2VFcnJvclwiKTtcclxudmFyIFRlbXBsYXRlQXJndW1lbnREZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4vZGVwZW5kZW5jaWVzL1RlbXBsYXRlQXJndW1lbnREZXBlbmRlbmN5XCIpO1xyXG52YXIgQXN5bmNEZXBlbmRlbmNpZXNCbG9jayA9IHJlcXVpcmUoXCIuL0FzeW5jRGVwZW5kZW5jaWVzQmxvY2tcIik7XHJcblxyXG5mdW5jdGlvbiBOb3JtYWxNb2R1bGUocmVxdWVzdCwgdXNlclJlcXVlc3QsIHJhd1JlcXVlc3QsIGxvYWRlcnMsIHJlc291cmNlLCBwYXJzZXIpIHtcclxuXHRNb2R1bGUuY2FsbCh0aGlzKTtcclxuXHR0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xyXG5cdHRoaXMudXNlclJlcXVlc3QgPSB1c2VyUmVxdWVzdDtcclxuXHR0aGlzLnJhd1JlcXVlc3QgPSByYXdSZXF1ZXN0O1xyXG5cdHRoaXMucGFyc2VyID0gcGFyc2VyO1xyXG5cdE5vcm1hbE1vZHVsZU1peGluLmNhbGwodGhpcywgbG9hZGVycywgcmVzb3VyY2UpO1xyXG5cdHRoaXMubWV0YSA9IHt9O1xyXG5cdHRoaXMuYXNzZXRzID0ge307XHJcblx0dGhpcy5idWlsdCA9IGZhbHNlO1xyXG5cdHRoaXMuX2NhY2hlZFNvdXJjZSA9IG51bGw7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBOb3JtYWxNb2R1bGU7XHJcblxyXG5Ob3JtYWxNb2R1bGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNb2R1bGUucHJvdG90eXBlKTtcclxuTm9ybWFsTW9kdWxlTWl4aW4ubWl4aW4oTm9ybWFsTW9kdWxlLnByb3RvdHlwZSk7XHJcblxyXG5Ob3JtYWxNb2R1bGUucHJvdG90eXBlLmlkZW50aWZpZXIgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5yZXF1ZXN0O1xyXG59O1xyXG5cclxuTm9ybWFsTW9kdWxlLnByb3RvdHlwZS5yZWFkYWJsZUlkZW50aWZpZXIgPSBmdW5jdGlvbihyZXF1ZXN0U2hvcnRlbmVyKSB7XHJcblx0cmV0dXJuIHJlcXVlc3RTaG9ydGVuZXIuc2hvcnRlbih0aGlzLnVzZXJSZXF1ZXN0KTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGNvbnRleHRpZnkob3B0aW9ucywgcmVxdWVzdCkge1xyXG5cdHJldHVybiByZXF1ZXN0LnNwbGl0KFwiIVwiKS5tYXAoZnVuY3Rpb24ocikge1xyXG5cdFx0dmFyIHJwID0gcGF0aC5yZWxhdGl2ZShvcHRpb25zLmNvbnRleHQsIHIpO1xyXG5cdFx0aWYocGF0aC5zZXAgPT09IFwiXFxcXFwiKVxyXG5cdFx0XHRycCA9IHJwLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpO1xyXG5cdFx0aWYocnAuaW5kZXhPZihcIi4uL1wiKSAhPT0gMClcclxuXHRcdFx0cnAgPSBcIi4vXCIgKyBycDtcclxuXHRcdHJldHVybiBycDtcclxuXHR9KS5qb2luKFwiIVwiKTtcclxufVxyXG5cclxuTm9ybWFsTW9kdWxlLnByb3RvdHlwZS5saWJJZGVudCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gY29udGV4dGlmeShvcHRpb25zLCB0aGlzLnVzZXJSZXF1ZXN0KTtcclxufTtcclxuXHJcbk5vcm1hbE1vZHVsZS5wcm90b3R5cGUuZmlsbExvYWRlckNvbnRleHQgPSBmdW5jdGlvbiBmaWxsTG9hZGVyQ29udGV4dChsb2FkZXJDb250ZXh0LCBvcHRpb25zLCBjb21waWxhdGlvbikge1xyXG5cdGxvYWRlckNvbnRleHQud2VicGFjayA9IHRydWU7XHJcblx0bG9hZGVyQ29udGV4dC5zb3VyY2VNYXAgPSAhIXRoaXMudXNlU291cmNlTWFwO1xyXG5cdGxvYWRlckNvbnRleHQuZW1pdEZpbGUgPSBmdW5jdGlvbihuYW1lLCBjb250ZW50LCBzb3VyY2VNYXApIHtcclxuXHRcdGlmKHR5cGVvZiBzb3VyY2VNYXAgPT09IFwic3RyaW5nXCIpIHtcclxuXHRcdFx0dGhpcy5hc3NldHNbbmFtZV0gPSBuZXcgT3JpZ2luYWxTb3VyY2UoY29udGVudCwgc291cmNlTWFwKTtcclxuXHRcdH0gZWxzZSBpZihzb3VyY2VNYXApIHtcclxuXHRcdFx0dGhpcy5hc3NldHNbbmFtZV0gPSBuZXcgU291cmNlTWFwU291cmNlKGNvbnRlbnQsIG5hbWUsIHNvdXJjZU1hcCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLmFzc2V0c1tuYW1lXSA9IG5ldyBSYXdTb3VyY2UoY29udGVudCk7XHJcblx0XHR9XHJcblx0fS5iaW5kKHRoaXMpO1xyXG5cdGxvYWRlckNvbnRleHQuX21vZHVsZSA9IHRoaXM7XHJcblx0bG9hZGVyQ29udGV4dC5fY29tcGlsYXRpb24gPSBjb21waWxhdGlvbjtcclxuXHRsb2FkZXJDb250ZXh0Ll9jb21waWxlciA9IGNvbXBpbGF0aW9uLmNvbXBpbGVyO1xyXG5cdGxvYWRlckNvbnRleHQuZnMgPSBjb21waWxhdGlvbi5jb21waWxlci5pbnB1dEZpbGVTeXN0ZW07XHJcblx0Y29tcGlsYXRpb24uYXBwbHlQbHVnaW5zKFwibm9ybWFsLW1vZHVsZS1sb2FkZXJcIiwgbG9hZGVyQ29udGV4dCwgdGhpcyk7XHJcbn07XHJcblxyXG5Ob3JtYWxNb2R1bGUucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiBkaXNjb25uZWN0KCkge1xyXG5cdHRoaXMuYnVpbHQgPSBmYWxzZTtcclxuXHRNb2R1bGUucHJvdG90eXBlLmRpc2Nvbm5lY3QuY2FsbCh0aGlzKTtcclxufTtcclxuXHJcbk5vcm1hbE1vZHVsZS5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiBidWlsZChvcHRpb25zLCBjb21waWxhdGlvbiwgcmVzb2x2ZXIsIGZzLCBjYWxsYmFjaykge1xyXG5cdHRoaXMuYnVpbGRUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuXHR0aGlzLmJ1aWx0ID0gdHJ1ZTtcclxuXHRyZXR1cm4gdGhpcy5kb0J1aWxkKG9wdGlvbnMsIGNvbXBpbGF0aW9uLCByZXNvbHZlciwgZnMsIGZ1bmN0aW9uKGVycikge1xyXG5cdFx0aWYoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHRcdHRoaXMuZGVwZW5kZW5jaWVzLmxlbmd0aCA9IDA7XHJcblx0XHR0aGlzLnZhcmlhYmxlcy5sZW5ndGggPSAwO1xyXG5cdFx0dGhpcy5ibG9ja3MubGVuZ3RoID0gMDtcclxuXHRcdHRoaXMuX2NhY2hlZFNvdXJjZSA9IG51bGw7XHJcblx0XHRpZihvcHRpb25zLm1vZHVsZSAmJiBvcHRpb25zLm1vZHVsZS5ub1BhcnNlKSB7XHJcblx0XHRcdGlmKEFycmF5LmlzQXJyYXkob3B0aW9ucy5tb2R1bGUubm9QYXJzZSkpIHtcclxuXHRcdFx0XHRpZihvcHRpb25zLm1vZHVsZS5ub1BhcnNlLnNvbWUoZnVuY3Rpb24ocmVnRXhwKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiB0eXBlb2YgcmVnRXhwID09PSBcInN0cmluZ1wiID9cclxuXHRcdFx0XHRcdFx0XHR0aGlzLnJlcXVlc3QuaW5kZXhPZihyZWdFeHApID09PSAwIDpcclxuXHRcdFx0XHRcdFx0XHRyZWdFeHAudGVzdCh0aGlzLnJlcXVlc3QpO1xyXG5cdFx0XHRcdFx0fSwgdGhpcykpIHJldHVybiBjYWxsYmFjaygpO1xyXG5cdFx0XHR9IGVsc2UgaWYodHlwZW9mIG9wdGlvbnMubW9kdWxlLm5vUGFyc2UgPT09IFwic3RyaW5nXCIgP1xyXG5cdFx0XHRcdHRoaXMucmVxdWVzdC5pbmRleE9mKG9wdGlvbnMubW9kdWxlLm5vUGFyc2UpID09PSAwIDpcclxuXHRcdFx0XHRvcHRpb25zLm1vZHVsZS5ub1BhcnNlLnRlc3QodGhpcy5yZXF1ZXN0KSkge1xyXG5cdFx0XHRcdHJldHVybiBjYWxsYmFjaygpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHR0cnkge1xyXG5cdFx0XHR0aGlzLnBhcnNlci5wYXJzZSh0aGlzLl9zb3VyY2Uuc291cmNlKCksIHtcclxuXHRcdFx0XHRjdXJyZW50OiB0aGlzLFxyXG5cdFx0XHRcdG1vZHVsZTogdGhpcyxcclxuXHRcdFx0XHRjb21waWxhdGlvbjogY29tcGlsYXRpb24sXHJcblx0XHRcdFx0b3B0aW9uczogb3B0aW9uc1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gY2F0Y2goZSkge1xyXG5cdFx0XHR2YXIgc291cmNlID0gdGhpcy5fc291cmNlLnNvdXJjZSgpO1xyXG5cdFx0XHR0aGlzLl9zb3VyY2UgPSBudWxsO1xyXG5cdFx0XHRyZXR1cm4gY2FsbGJhY2sobmV3IE1vZHVsZVBhcnNlRXJyb3IodGhpcywgc291cmNlLCBlKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gY2FsbGJhY2soKTtcclxuXHR9LmJpbmQodGhpcykpO1xyXG59O1xyXG5cclxuTm9ybWFsTW9kdWxlLnByb3RvdHlwZS5zb3VyY2UgPSBmdW5jdGlvbihkZXBlbmRlbmN5VGVtcGxhdGVzLCBvdXRwdXRPcHRpb25zLCByZXF1ZXN0U2hvcnRlbmVyKSB7XHJcblx0dmFyIGhhc2ggPSByZXF1aXJlKFwiY3J5cHRvXCIpLmNyZWF0ZUhhc2goXCJtZDVcIik7XHJcblx0dGhpcy51cGRhdGVIYXNoKGhhc2gpO1xyXG5cdGhhc2ggPSBoYXNoLmRpZ2VzdChcImhleFwiKTtcclxuXHRpZih0aGlzLl9jYWNoZWRTb3VyY2UgJiYgdGhpcy5fY2FjaGVkU291cmNlLmhhc2ggPT09IGhhc2gpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jYWNoZWRTb3VyY2Uuc291cmNlO1xyXG5cdH1cclxuXHR2YXIgX3NvdXJjZSA9IHRoaXMuX3NvdXJjZTtcclxuXHRpZighX3NvdXJjZSkgcmV0dXJuIG5ldyBSYXdTb3VyY2UoXCJ0aHJvdyBuZXcgRXJyb3IoJ05vIHNvdXJjZSBhdmFpbGFibGUnKTtcIik7XHJcblx0dmFyIHNvdXJjZSA9IG5ldyBSZXBsYWNlU291cmNlKF9zb3VyY2UpO1xyXG5cdHRoaXMuX2NhY2hlZFNvdXJjZSA9IHtcclxuXHRcdHNvdXJjZTogc291cmNlLFxyXG5cdFx0aGFzaDogaGFzaFxyXG5cdH07XHJcblx0dmFyIHRvcExldmVsQmxvY2sgPSB0aGlzO1xyXG5cclxuXHRmdW5jdGlvbiBkb0RlcChkZXApIHtcclxuXHRcdHZhciB0ZW1wbGF0ZSA9IGRlcGVuZGVuY3lUZW1wbGF0ZXMuZ2V0KGRlcC5jb25zdHJ1Y3Rvcik7XHJcblx0XHRpZighdGVtcGxhdGUpIHRocm93IG5ldyBFcnJvcihcIk5vIHRlbXBsYXRlIGZvciBkZXBlbmRlbmN5OiBcIiArIGRlcC5jb25zdHJ1Y3Rvci5uYW1lKTtcclxuXHRcdHRlbXBsYXRlLmFwcGx5KGRlcCwgc291cmNlLCBvdXRwdXRPcHRpb25zLCByZXF1ZXN0U2hvcnRlbmVyLCBkZXBlbmRlbmN5VGVtcGxhdGVzKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGRvVmFyaWFibGUodmFycywgdmFyaWFibGUpIHtcclxuXHRcdHZhciBuYW1lID0gdmFyaWFibGUubmFtZTtcclxuXHRcdHZhciBleHByID0gdmFyaWFibGUuZXhwcmVzc2lvblNvdXJjZShkZXBlbmRlbmN5VGVtcGxhdGVzLCBvdXRwdXRPcHRpb25zLCByZXF1ZXN0U2hvcnRlbmVyKTtcclxuXHRcdHZhcnMucHVzaCh7XHJcblx0XHRcdG5hbWU6IG5hbWUsXHJcblx0XHRcdGV4cHJlc3Npb246IGV4cHJcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZG9CbG9jayhibG9jaykge1xyXG5cdFx0YmxvY2suZGVwZW5kZW5jaWVzLmZvckVhY2goZG9EZXApO1xyXG5cdFx0YmxvY2suYmxvY2tzLmZvckVhY2goZG9CbG9jayk7XHJcblx0XHRpZihibG9jay52YXJpYWJsZXMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHR2YXIgdmFycyA9IFtdO1xyXG5cdFx0XHRibG9jay52YXJpYWJsZXMuZm9yRWFjaChkb1ZhcmlhYmxlLmJpbmQobnVsbCwgdmFycykpO1xyXG5cdFx0XHR2YXIgdmFyTmFtZXMgPSBbXTtcclxuXHRcdFx0dmFyIHZhckV4cHJlc3Npb25zID0gW107XHJcblx0XHRcdHZhciB2YXJTdGFydENvZGUgPSBcIlwiO1xyXG5cdFx0XHR2YXIgdmFyRW5kQ29kZSA9IFwiXCI7XHJcblxyXG5cdFx0XHRmdW5jdGlvbiBlbWl0RnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0aWYodmFyTmFtZXMubGVuZ3RoID09PSAwKSByZXR1cm47XHJcblxyXG5cdFx0XHRcdHZhclN0YXJ0Q29kZSArPSBcIi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihcIiArIHZhck5hbWVzLmpvaW4oXCIsIFwiKSArIFwiKSB7XCI7XHJcblx0XHRcdFx0Ly8gZXhwb3J0cyA9PT0gdGhpcyBpbiB0aGUgdG9wTGV2ZWxCbG9jaywgYnV0IGV4cG9ydHMgZG8gY29tcHJlc3MgYmV0dGVyLi4uXHJcblx0XHRcdFx0dmFyRW5kQ29kZSA9ICh0b3BMZXZlbEJsb2NrID09PSBibG9jayA/IFwifS5jYWxsKGV4cG9ydHMsIFwiIDogXCJ9LmNhbGwodGhpcywgXCIpICtcclxuXHRcdFx0XHRcdHZhckV4cHJlc3Npb25zLm1hcChmdW5jdGlvbihlKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBlLnNvdXJjZSgpO1xyXG5cdFx0XHRcdFx0fSkuam9pbihcIiwgXCIpICsgXCIpKVwiICsgdmFyRW5kQ29kZTtcclxuXHJcblx0XHRcdFx0dmFyTmFtZXMubGVuZ3RoID0gMDtcclxuXHRcdFx0XHR2YXJFeHByZXNzaW9ucy5sZW5ndGggPSAwO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhcnMuZm9yRWFjaChmdW5jdGlvbih2KSB7XHJcblx0XHRcdFx0aWYodmFyTmFtZXMuaW5kZXhPZih2Lm5hbWUpID49IDApIGVtaXRGdW5jdGlvbigpO1xyXG5cdFx0XHRcdHZhck5hbWVzLnB1c2godi5uYW1lKTtcclxuXHRcdFx0XHR2YXJFeHByZXNzaW9ucy5wdXNoKHYuZXhwcmVzc2lvbik7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRlbWl0RnVuY3Rpb24oKTtcclxuXHRcdFx0dmFyIHN0YXJ0ID0gYmxvY2sucmFuZ2UgPyBibG9jay5yYW5nZVswXSA6IDA7XHJcblx0XHRcdHZhciBlbmQgPSBibG9jay5yYW5nZSA/IGJsb2NrLnJhbmdlWzFdIDogX3NvdXJjZS5zaXplKCk7XHJcblx0XHRcdGlmKHZhclN0YXJ0Q29kZSkgc291cmNlLmluc2VydChzdGFydCArIDAuNSwgdmFyU3RhcnRDb2RlKTtcclxuXHRcdFx0aWYodmFyRW5kQ29kZSkgc291cmNlLmluc2VydChlbmQgKyAwLjUsIFwiXFxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovXCIgKyB2YXJFbmRDb2RlKTtcclxuXHRcdH1cclxuXHR9XHJcblx0ZG9CbG9jayh0aGlzKTtcclxuXHRyZXR1cm4gbmV3IENhY2hlZFNvdXJjZShzb3VyY2UpO1xyXG59O1xyXG5cclxuTm9ybWFsTW9kdWxlLnByb3RvdHlwZS5uZWVkUmVidWlsZCA9IGZ1bmN0aW9uIG5lZWRSZWJ1aWxkKGZpbGVUaW1lc3RhbXBzLCBjb250ZXh0VGltZXN0YW1wcykge1xyXG5cdHZhciB0aW1lc3RhbXAgPSAwO1xyXG5cdHRoaXMuZmlsZURlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uKGZpbGUpIHtcclxuXHRcdHZhciB0cyA9IGZpbGVUaW1lc3RhbXBzW2ZpbGVdO1xyXG5cdFx0aWYoIXRzKSB0aW1lc3RhbXAgPSBJbmZpbml0eTtcclxuXHRcdGlmKHRzID4gdGltZXN0YW1wKSB0aW1lc3RhbXAgPSB0cztcclxuXHR9KTtcclxuXHR0aGlzLmNvbnRleHREZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbihjb250ZXh0KSB7XHJcblx0XHR2YXIgdHMgPSBjb250ZXh0VGltZXN0YW1wc1tjb250ZXh0XTtcclxuXHRcdGlmKCF0cykgdGltZXN0YW1wID0gSW5maW5pdHk7XHJcblx0XHRpZih0cyA+IHRpbWVzdGFtcCkgdGltZXN0YW1wID0gdHM7XHJcblx0fSk7XHJcblx0cmV0dXJuIHRpbWVzdGFtcCA+PSB0aGlzLmJ1aWxkVGltZXN0YW1wO1xyXG59O1xyXG5cclxuTm9ybWFsTW9kdWxlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuX3NvdXJjZSA/IHRoaXMuX3NvdXJjZS5zaXplKCkgOiAtMTtcclxufTtcclxuXHJcbk5vcm1hbE1vZHVsZS5wcm90b3R5cGUudXBkYXRlSGFzaCA9IGZ1bmN0aW9uKGhhc2gpIHtcclxuXHRpZih0aGlzLl9zb3VyY2UpIHtcclxuXHRcdGhhc2gudXBkYXRlKFwic291cmNlXCIpO1xyXG5cdFx0dGhpcy5fc291cmNlLnVwZGF0ZUhhc2goaGFzaCk7XHJcblx0fSBlbHNlXHJcblx0XHRoYXNoLnVwZGF0ZShcIm51bGxcIik7XHJcblx0aGFzaC51cGRhdGUoXCJtZXRhXCIpO1xyXG5cdGhhc2gudXBkYXRlKEpTT04uc3RyaW5naWZ5KHRoaXMubWV0YSkpO1xyXG5cdE1vZHVsZS5wcm90b3R5cGUudXBkYXRlSGFzaC5jYWxsKHRoaXMsIGhhc2gpO1xyXG59O1xyXG5cclxuTm9ybWFsTW9kdWxlLnByb3RvdHlwZS5nZXRTb3VyY2VIYXNoID0gZnVuY3Rpb24oKSB7XHJcblx0aWYoIXRoaXMuX3NvdXJjZSkgcmV0dXJuIFwiXCI7XHJcblx0dmFyIGhhc2ggPSByZXF1aXJlKFwiY3J5cHRvXCIpLmNyZWF0ZUhhc2goXCJtZDVcIik7XHJcblx0aGFzaC51cGRhdGUodGhpcy5fc291cmNlLnNvdXJjZSgpKTtcclxuXHRyZXR1cm4gaGFzaC5kaWdlc3QoXCJoZXhcIik7XHJcbn07XHJcblxyXG5Ob3JtYWxNb2R1bGUucHJvdG90eXBlLmdldEFsbE1vZHVsZURlcGVuZGVuY2llcyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBsaXN0ID0gW107XHJcblxyXG5cdGZ1bmN0aW9uIGRvRGVwKGRlcCkge1xyXG5cdFx0aWYoZGVwLm1vZHVsZSAmJiBsaXN0LmluZGV4T2YoZGVwLm1vZHVsZSkgPCAwKVxyXG5cdFx0XHRsaXN0LnB1c2goZGVwLm1vZHVsZSk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBkb1ZhcmlhYmxlKHZhcmlhYmxlKSB7XHJcblx0XHR2YXJpYWJsZS5kZXBlbmRlbmNpZXMuZm9yRWFjaChkb0RlcCk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBkb0Jsb2NrKGJsb2NrKSB7XHJcblx0XHRibG9jay52YXJpYWJsZXMuZm9yRWFjaChkb1ZhcmlhYmxlKTtcclxuXHRcdGJsb2NrLmRlcGVuZGVuY2llcy5mb3JFYWNoKGRvRGVwKTtcclxuXHRcdGJsb2NrLmJsb2Nrcy5mb3JFYWNoKGRvQmxvY2spO1xyXG5cdH1cclxuXHRkb0Jsb2NrKHRoaXMpO1xyXG5cdHJldHVybiBsaXN0O1xyXG59O1xyXG5cclxuTm9ybWFsTW9kdWxlLnByb3RvdHlwZS5jcmVhdGVUZW1wbGF0ZSA9IGZ1bmN0aW9uKGtlZXBNb2R1bGVzLCByb290cykge1xyXG5cdHJvb3RzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG5cdFx0dmFyIGlhID0gYS5pZGVudGlmaWVyKCk7XHJcblx0XHR2YXIgaWIgPSBiLmlkZW50aWZpZXIoKTtcclxuXHRcdGlmKGlhIDwgaWIpIHJldHVybiAtMTtcclxuXHRcdGlmKGliIDwgaWEpIHJldHVybiAxO1xyXG5cdFx0cmV0dXJuIDA7XHJcblx0fSk7XHJcblx0dmFyIHRlbXBsYXRlID0gbmV3IE5vcm1hbE1vZHVsZShcIlwiLCBcIlwiLCBcIlwiLCBbXSwgXCJcIiwgbnVsbCk7XHJcblx0dGVtcGxhdGUuX3NvdXJjZSA9IHRoaXMuX3NvdXJjZTtcclxuXHR0ZW1wbGF0ZS5idWlsdCA9IHRoaXMuYnVpbHQ7XHJcblx0dGVtcGxhdGUudGVtcGxhdGVNb2R1bGVzID0ga2VlcE1vZHVsZXM7XHJcblx0dGVtcGxhdGUuX3RlbXBsYXRlT3JpZ2luID0gdGhpcztcclxuXHR0ZW1wbGF0ZS5yZWFkYWJsZUlkZW50aWZpZXIgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBcInRlbXBsYXRlIG9mIFwiICsgdGhpcy5fdGVtcGxhdGVPcmlnaW4uaWQgKyBcIiByZWZlcmVuY2luZyBcIiArIGtlZXBNb2R1bGVzLm1hcChmdW5jdGlvbihtKSB7XHJcblx0XHRcdHJldHVybiBtLmlkO1xyXG5cdFx0fSkuam9pbihcIiwgXCIpO1xyXG5cdH07XHJcblx0dGVtcGxhdGUuaWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGFycmF5ID0gcm9vdHMubWFwKGZ1bmN0aW9uKG0pIHtcclxuXHRcdFx0cmV0dXJuIG0uaWRlbnRpZmllcigpO1xyXG5cdFx0fSk7XHJcblx0XHRhcnJheS5zb3J0KCk7XHJcblx0XHRyZXR1cm4gYXJyYXkuam9pbihcInxcIik7XHJcblx0fTtcclxuXHR2YXIgYXJncyA9IHRlbXBsYXRlLmFyZ3VtZW50cyA9IFtdO1xyXG5cclxuXHRmdW5jdGlvbiBkb0RlcHMoZGVwcykge1xyXG5cdFx0cmV0dXJuIGRlcHMubWFwKGZ1bmN0aW9uKGRlcCkge1xyXG5cdFx0XHRpZihkZXAubW9kdWxlICYmIGtlZXBNb2R1bGVzLmluZGV4T2YoZGVwLm1vZHVsZSkgPCAwKSB7XHJcblx0XHRcdFx0dmFyIGFyZ05hbWUgPSBcIl9fd2VicGFja19tb2R1bGVfdGVtcGxhdGVfYXJndW1lbnRfXCIgKyBhcmdzLmxlbmd0aCArIFwiX19cIjtcclxuXHRcdFx0XHRhcmdzLnB1c2goYXJnTmFtZSk7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBUZW1wbGF0ZUFyZ3VtZW50RGVwZW5kZW5jeShhcmdOYW1lLCBkZXApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldHVybiBkZXA7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZG9CbG9jayhibG9jaywgbmV3QmxvY2spIHtcclxuXHRcdGJsb2NrLnZhcmlhYmxlcy5mb3JFYWNoKGZ1bmN0aW9uKHZhcmlhYmxlKSB7XHJcblx0XHRcdHZhciBuZXdEZXBlbmRlbmNpZXMgPSBkb0RlcHModmFyaWFibGUuZGVwZW5kZW5jaWVzKTtcclxuXHRcdFx0bmV3QmxvY2suYWRkVmFyaWFibGUodmFyaWFibGUubmFtZSwgdmFyaWFibGUuZXhwcmVzc2lvbiwgbmV3RGVwZW5kZW5jaWVzKTtcclxuXHRcdH0pO1xyXG5cdFx0bmV3QmxvY2suZGVwZW5kZW5jaWVzID0gZG9EZXBzKGJsb2NrLmRlcGVuZGVuY2llcyk7XHJcblx0XHRibG9jay5ibG9ja3MuZm9yRWFjaChmdW5jdGlvbihjaGlsZEJsb2NrKSB7XHJcblx0XHRcdHZhciBuZXdDaGlsZEJsb2NrID0gbmV3IEFzeW5jRGVwZW5kZW5jaWVzQmxvY2soY2hpbGRCbG9jay5uYW1lLCBjaGlsZEJsb2NrLm1vZHVsZSwgY2hpbGRCbG9jay5sb2MpO1xyXG5cdFx0XHRuZXdCbG9jay5hZGRCbG9jayhuZXdDaGlsZEJsb2NrKTtcclxuXHRcdFx0ZG9CbG9jayhjaGlsZEJsb2NrLCBuZXdDaGlsZEJsb2NrKTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHRkb0Jsb2NrKHRoaXMsIHRlbXBsYXRlKTtcclxuXHRyZXR1cm4gdGVtcGxhdGU7XHJcbn07XHJcblxyXG5Ob3JtYWxNb2R1bGUucHJvdG90eXBlLmdldFRlbXBsYXRlQXJndW1lbnRzID0gZnVuY3Rpb24oa2VlcE1vZHVsZXMpIHtcclxuXHR2YXIgbGlzdCA9IFtdO1xyXG5cclxuXHRmdW5jdGlvbiBkb0RlcChkZXApIHtcclxuXHRcdGlmKGRlcC5tb2R1bGUgJiYga2VlcE1vZHVsZXMuaW5kZXhPZihkZXAubW9kdWxlKSA8IDApXHJcblx0XHRcdGxpc3QucHVzaChkZXAubW9kdWxlKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGRvVmFyaWFibGUodmFyaWFibGUpIHtcclxuXHRcdHZhcmlhYmxlLmRlcGVuZGVuY2llcy5mb3JFYWNoKGRvRGVwKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGRvQmxvY2soYmxvY2spIHtcclxuXHRcdGJsb2NrLnZhcmlhYmxlcy5mb3JFYWNoKGRvVmFyaWFibGUpO1xyXG5cdFx0YmxvY2suZGVwZW5kZW5jaWVzLmZvckVhY2goZG9EZXApO1xyXG5cdFx0YmxvY2suYmxvY2tzLmZvckVhY2goZG9CbG9jayk7XHJcblx0fVxyXG5cdGRvQmxvY2sodGhpcyk7XHJcblx0cmV0dXJuIGxpc3Q7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvTm9ybWFsTW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgUmF3U291cmNlID0gcmVxdWlyZShcIi4vUmF3U291cmNlXCIpO1xyXG52YXIgT3JpZ2luYWxTb3VyY2UgPSByZXF1aXJlKFwiLi9PcmlnaW5hbFNvdXJjZVwiKTtcclxudmFyIFNvdXJjZU1hcFNvdXJjZSA9IHJlcXVpcmUoXCIuL1NvdXJjZU1hcFNvdXJjZVwiKTtcclxudmFyIExpbmVUb0xpbmVNYXBwZWRTb3VyY2UgPSByZXF1aXJlKFwiLi9MaW5lVG9MaW5lTWFwcGVkU291cmNlXCIpO1xyXG52YXIgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpOyAvLyBUT0RPIHJlZmFjdG9yXHJcblxyXG52YXIgTW9kdWxlQnVpbGRFcnJvciA9IHJlcXVpcmUoXCIuL01vZHVsZUJ1aWxkRXJyb3JcIik7XHJcbnZhciBNb2R1bGVFcnJvciA9IHJlcXVpcmUoXCIuL01vZHVsZUVycm9yXCIpO1xyXG52YXIgTW9kdWxlV2FybmluZyA9IHJlcXVpcmUoXCIuL01vZHVsZVdhcm5pbmdcIik7XHJcblxyXG5mdW5jdGlvbiB1dGY4QnVmZmVyVG9TdHJpbmcoYnVmKSB7XHJcblx0dmFyIHN0ciA9IGJ1Zi50b1N0cmluZyhcInV0Zi04XCIpO1xyXG5cdGlmKHN0ci5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHtcclxuXHRcdHJldHVybiBzdHIuc3Vic3RyKDEpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gc3RyO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gTm9ybWFsTW9kdWxlTWl4aW4obG9hZGVycywgcmVzb3VyY2UpIHtcclxuXHR0aGlzLnJlc291cmNlID0gcmVzb3VyY2U7XHJcblx0dGhpcy5sb2FkZXJzID0gbG9hZGVycztcclxuXHR2YXIgcmVzb3VyY2VQYXRoID0gdGhpcy5zcGxpdFF1ZXJ5KHRoaXMucmVzb3VyY2UpWzBdO1xyXG5cdHRoaXMuY29udGV4dCA9IHJlc291cmNlUGF0aCA/IHBhdGguZGlybmFtZShyZXNvdXJjZVBhdGgpIDogbnVsbDtcclxuXHR0aGlzLmZpbGVEZXBlbmRlbmNpZXMgPSBbXTtcclxuXHR0aGlzLmNvbnRleHREZXBlbmRlbmNpZXMgPSBbXTtcclxuXHR0aGlzLndhcm5pbmdzID0gW107XHJcblx0dGhpcy5lcnJvcnMgPSBbXTtcclxuXHR0aGlzLmVycm9yID0gbnVsbDtcclxuXHR0aGlzLl9zb3VyY2UgPSBudWxsO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gTm9ybWFsTW9kdWxlTWl4aW47XHJcblxyXG5Ob3JtYWxNb2R1bGVNaXhpbi5taXhpbiA9IGZ1bmN0aW9uKHB0KSB7XHJcblx0Zm9yKHZhciBuYW1lIGluIE5vcm1hbE1vZHVsZU1peGluLnByb3RvdHlwZSlcclxuXHRcdHB0W25hbWVdID0gTm9ybWFsTW9kdWxlTWl4aW4ucHJvdG90eXBlW25hbWVdO1xyXG59O1xyXG5cclxuTm9ybWFsTW9kdWxlTWl4aW4ucHJvdG90eXBlLnNwbGl0UXVlcnkgPSBmdW5jdGlvbiBzcGxpdFF1ZXJ5KHJlcSkge1xyXG5cdHZhciBpID0gcmVxLmluZGV4T2YoXCI/XCIpO1xyXG5cdGlmKGkgPCAwKSByZXR1cm4gW3JlcSwgXCJcIl07XHJcblx0cmV0dXJuIFtyZXEuc3Vic3RyKDAsIGkpLCByZXEuc3Vic3RyKGkpXTtcclxufTtcclxuXHJcbk5vcm1hbE1vZHVsZU1peGluLnByb3RvdHlwZS5kb0J1aWxkID0gZnVuY3Rpb24gZG9CdWlsZChvcHRpb25zLCBtb2R1bGVDb250ZXh0LCByZXNvbHZlciwgZnMsIGNhbGxiYWNrKSB7XHJcblx0dmFyIHNwbGl0UXVlcnkgPSB0aGlzLnNwbGl0UXVlcnkuYmluZCh0aGlzKTtcclxuXHR2YXIgbW9kdWxlID0gdGhpcztcclxuXHR0aGlzLmNhY2hlYWJsZSA9IHRydWU7XHJcblxyXG5cdC8vIFByZXBhcmUgY29udGV4dFxyXG5cdHZhciBsb2FkZXJzID0gW107XHJcblx0ZnVuY3Rpb24gYWRkTG9hZGVyVG9MaXN0KGxvYWRlcikge1xyXG5cdFx0dmFyIGwgPSBzcGxpdFF1ZXJ5KGxvYWRlcik7XHJcblx0XHRsb2FkZXJzLnB1c2goe1xyXG5cdFx0XHRyZXF1ZXN0OiBsb2FkZXIsXHJcblx0XHRcdHBhdGg6IGxbMF0sXHJcblx0XHRcdHF1ZXJ5OiBsWzFdLFxyXG5cdFx0XHRtb2R1bGU6IG51bGxcclxuXHRcdH0pO1xyXG5cdH1cclxuXHR0aGlzLmxvYWRlcnMuZm9yRWFjaChhZGRMb2FkZXJUb0xpc3QpO1xyXG5cdHZhciBsb2FkZXJDb250ZXh0Q2FjaGVhYmxlO1xyXG5cdHZhciBsb2FkZXJDb250ZXh0ID0ge1xyXG5cdFx0dmVyc2lvbjogMSxcclxuXHRcdGNvbnRleHQ6IHRoaXMuY29udGV4dCxcclxuXHRcdGxvYWRlcnM6IGxvYWRlcnMsXHJcblx0XHRsb2FkZXJJbmRleDogMCxcclxuXHRcdHJlc291cmNlOiB0aGlzLnJlc291cmNlLFxyXG5cdFx0cmVzb3VyY2VQYXRoOiBzcGxpdFF1ZXJ5KHRoaXMucmVzb3VyY2UpWzBdLFxyXG5cdFx0cmVzb3VyY2VRdWVyeTogdGhpcy5yZXNvdXJjZSA/IHNwbGl0UXVlcnkodGhpcy5yZXNvdXJjZSlbMV0gfHwgbnVsbCA6IHVuZGVmaW5lZCxcclxuXHRcdGVtaXRXYXJuaW5nOiBmdW5jdGlvbih3YXJuaW5nKSB7XHJcblx0XHRcdHRoaXMud2FybmluZ3MucHVzaChuZXcgTW9kdWxlV2FybmluZyh0aGlzLCB3YXJuaW5nKSk7XHJcblx0XHR9LmJpbmQodGhpcyksXHJcblx0XHRlbWl0RXJyb3I6IGZ1bmN0aW9uKGVycm9yKSB7XHJcblx0XHRcdHRoaXMuZXJyb3JzLnB1c2gobmV3IE1vZHVsZUVycm9yKHRoaXMsIGVycm9yKSk7XHJcblx0XHR9LmJpbmQodGhpcyksXHJcblx0XHRleGVjOiBmdW5jdGlvbihjb2RlLCBmaWxlbmFtZSkge1xyXG5cdFx0XHRpZih0eXBlb2YgX193ZWJwYWNrX21vZHVsZXNfXyA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0XHRcdC8vIFRPRE86IGNoZWNrIGlmIGluIGVuaGFuY2VkLXJlcXVpcmVcclxuXHRcdFx0XHR2YXIgTW9kdWxlID0gcmVxdWlyZShcIm1vZHVsZVwiKTtcclxuXHRcdFx0XHR2YXIgbSA9IG5ldyBNb2R1bGUoZmlsZW5hbWUsIG1vZHVsZSk7XHJcblx0XHRcdFx0bS5wYXRocyA9IE1vZHVsZS5fbm9kZU1vZHVsZVBhdGhzKGxvYWRlckNvbnRleHQuY29udGV4dCk7XHJcblx0XHRcdFx0bS5maWxlbmFtZSA9IGZpbGVuYW1lO1xyXG5cdFx0XHRcdG0uX2NvbXBpbGUoY29kZSwgZmlsZW5hbWUpO1xyXG5cdFx0XHRcdHJldHVybiBtLmV4cG9ydHM7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibG9hZGVyQ29udGV4dC5leGVjIGlzIG5vdCBzdXBwb3J0ZWRcIik7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRyZXNvbHZlOiBmdW5jdGlvbihjb250ZXh0LCByZXF1ZXN0LCBjYWxsYmFjaykge1xyXG5cdFx0XHRyZXNvbHZlci5yZXNvbHZlKGNvbnRleHQsIHJlcXVlc3QsIGNhbGxiYWNrKTtcclxuXHRcdH0sXHJcblx0XHRyZXNvbHZlU3luYzogZnVuY3Rpb24oY29udGV4dCwgcmVxdWVzdCkge1xyXG5cdFx0XHRyZXR1cm4gcmVzb2x2ZXIucmVzb2x2ZVN5bmMoY29udGV4dCwgcmVxdWVzdCk7XHJcblx0XHR9LFxyXG5cdFx0Y2FjaGVhYmxlOiBmdW5jdGlvbihmbGFnKSB7XHJcblx0XHRcdGxvYWRlckNvbnRleHRDYWNoZWFibGUgPSBmbGFnICE9PSBmYWxzZTtcclxuXHRcdH0sXHJcblx0XHRkZXBlbmRlbmN5OiBmdW5jdGlvbihmaWxlKSB7XHJcblx0XHRcdHRoaXMuZmlsZURlcGVuZGVuY2llcy5wdXNoKGZpbGUpO1xyXG5cdFx0fS5iaW5kKHRoaXMpLFxyXG5cdFx0YWRkRGVwZW5kZW5jeTogZnVuY3Rpb24oZmlsZSkge1xyXG5cdFx0XHR0aGlzLmZpbGVEZXBlbmRlbmNpZXMucHVzaChmaWxlKTtcclxuXHRcdH0uYmluZCh0aGlzKSxcclxuXHRcdGFkZENvbnRleHREZXBlbmRlbmN5OiBmdW5jdGlvbihjb250ZXh0KSB7XHJcblx0XHRcdHRoaXMuY29udGV4dERlcGVuZGVuY2llcy5wdXNoKGNvbnRleHQpO1xyXG5cdFx0fS5iaW5kKHRoaXMpLFxyXG5cdFx0Y2xlYXJEZXBlbmRlbmNpZXM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR0aGlzLmZpbGVEZXBlbmRlbmNpZXMubGVuZ3RoID0gMDtcclxuXHRcdFx0dGhpcy5jb250ZXh0RGVwZW5kZW5jaWVzLmxlbmd0aCA9IDA7XHJcblx0XHRcdG1vZHVsZS5jYWNoZWFibGUgPSB0cnVlO1xyXG5cdFx0fS5iaW5kKHRoaXMpLFxyXG5cdFx0aW5wdXRWYWx1ZTogdW5kZWZpbmVkLFxyXG5cdFx0dmFsdWU6IG51bGwsXHJcblx0XHRvcHRpb25zOiBvcHRpb25zLFxyXG5cdFx0ZGVidWc6IG9wdGlvbnMuZGVidWdcclxuXHR9O1xyXG5cdHRoaXMuZmlsbExvYWRlckNvbnRleHQobG9hZGVyQ29udGV4dCwgb3B0aW9ucywgbW9kdWxlQ29udGV4dCk7XHJcblx0aWYob3B0aW9ucy5sb2FkZXIpIGZvcih2YXIga2V5IGluIG9wdGlvbnMubG9hZGVyKVxyXG5cdFx0bG9hZGVyQ29udGV4dFtrZXldID0gb3B0aW9ucy5sb2FkZXJba2V5XTtcclxuXHJcblxyXG5cdGZ1bmN0aW9uIHJ1blN5bmNPckFzeW5jKGZuLCBjb250ZXh0LCBhcmdzLCBjYWxsYmFjaykge1xyXG5cdFx0dmFyIGlzU3luYyA9IHRydWU7XHJcblx0XHR2YXIgaXNEb25lID0gZmFsc2U7XHJcblx0XHR2YXIgaXNFcnJvciA9IGZhbHNlOyAvLyBpbnRlcm5hbCBlcnJvclxyXG5cdFx0dmFyIHJlcG9ydGVkRXJyb3IgPSBmYWxzZTtcclxuXHRcdGlmKCFjb250ZXh0LmFzeW5jKSBjb250ZXh0LmFzeW5jID0gZnVuY3Rpb24gYXN5bmMoKSB7XHJcblx0XHRcdGlmKGlzRG9uZSkge1xyXG5cdFx0XHRcdGlmKHJlcG9ydGVkRXJyb3IpIHJldHVybjsgLy8gaWdub3JlXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiYXN5bmMoKTogVGhlIGNhbGxiYWNrIHdhcyBhbHJlYWR5IGNhbGxlZC5cIik7XHJcblx0XHRcdH1cclxuXHRcdFx0aXNTeW5jID0gZmFsc2U7XHJcblx0XHRcdHJldHVybiBjb250ZXh0LmNhbGxiYWNrO1xyXG5cdFx0fTtcclxuXHRcdGNvbnRleHQuY2FsbGJhY2sgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0aWYoaXNEb25lKSB7XHJcblx0XHRcdFx0aWYocmVwb3J0ZWRFcnJvcikgcmV0dXJuOyAvLyBpZ25vcmVcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJjYWxsYmFjaygpOiBUaGUgY2FsbGJhY2sgd2FzIGFscmVhZHkgY2FsbGVkLlwiKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpc0RvbmUgPSB0cnVlO1xyXG5cdFx0XHRpc1N5bmMgPSBmYWxzZTtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG5cdFx0XHR9IGNhdGNoKGUpIHtcclxuXHRcdFx0XHRpc0Vycm9yID0gdHJ1ZTtcclxuXHRcdFx0XHR0aHJvdyBlO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0dmFyIHJlc3VsdCA9IChmdW5jdGlvbiBXRUJQQUNLX0NPUkVfTE9BREVSX0VYRUNVVElPTigpIHsgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpIH0oKSk7XHJcblx0XHRcdGlmKGlzU3luYykge1xyXG5cdFx0XHRcdGlzRG9uZSA9IHRydWU7XHJcblx0XHRcdFx0aWYocmVzdWx0ID09PSB1bmRlZmluZWQpXHJcblx0XHRcdFx0XHRyZXR1cm4gY2FsbGJhY2soKTtcclxuXHRcdFx0XHRyZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcclxuXHRcdFx0fVxyXG5cdFx0fSBjYXRjaChlKSB7XHJcblx0XHRcdGlmKGlzRXJyb3IpIHRocm93IGU7XHJcblx0XHRcdGlmKGlzRG9uZSkge1xyXG5cdFx0XHRcdC8vIGxvYWRlciBpcyBhbHJlYWR5IFwiZG9uZVwiLCBzbyB3ZSBjYW5ub3QgdXNlIHRoZSBjYWxsYmFjayBmdW5jdGlvblxyXG5cdFx0XHRcdC8vIGZvciBiZXR0ZXIgZGVidWdnaW5nIHdlIHByaW50IHRoZSBlcnJvciBvbiB0aGUgY29uc29sZVxyXG5cdFx0XHRcdGlmKHR5cGVvZiBlID09PSBcIm9iamVjdFwiICYmIGUuc3RhY2spIGNvbnNvbGUuZXJyb3IoZS5zdGFjayk7XHJcblx0XHRcdFx0ZWxzZSBjb25zb2xlLmVycm9yKGUpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHRpc0RvbmUgPSB0cnVlO1xyXG5cdFx0XHRyZXBvcnRlZEVycm9yID0gdHJ1ZTtcclxuXHRcdFx0Y2FsbGJhY2soZSk7XHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gTG9hZCBhbmQgcGl0Y2ggbG9hZGVyc1xyXG5cdChmdW5jdGlvbiBsb2FkUGl0Y2goKSB7XHJcblx0XHR2YXIgbCA9IGxvYWRlckNvbnRleHQubG9hZGVyc1tsb2FkZXJDb250ZXh0LmxvYWRlckluZGV4XTtcclxuXHRcdGlmKCFsKSB7XHJcblx0XHRcdHJldHVybiBvbkxvYWRQaXRjaERvbmUuY2FsbCh0aGlzKTtcclxuXHRcdH1cclxuXHRcdGlmKGwubW9kdWxlKSB7XHJcblx0XHRcdGxvYWRlckNvbnRleHQubG9hZGVySW5kZXgrKztcclxuXHRcdFx0cmV0dXJuIGxvYWRQaXRjaC5jYWxsKHRoaXMpO1xyXG5cdFx0fVxyXG5cdFx0aWYodHlwZW9mIF9fd2VicGFja19tb2R1bGVzX18gPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdFx0aWYocmVxdWlyZS5zdXBwb3J0UXVlcnkpIHtcclxuXHRcdFx0XHRsLm1vZHVsZSA9IHJlcXVpcmUobC5yZXF1ZXN0KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0bC5tb2R1bGUgPSByZXF1aXJlKGwucGF0aCk7XHJcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHRcdFx0Ly8gaXQgaXMgcG9zc2libGUgZm9yIG5vZGUgdG8gY2hva2Ugb24gYSByZXF1aXJlIGlmIHRoZSBGRCBkZXNjcmlwdG9yXHJcblx0XHRcdFx0XHQvLyBsaW1pdCBoYXMgYmVlbiByZWFjaGVkLiBnaXZlIGl0IGEgY2hhbmNlIHRvIHJlY292ZXIuXHJcblx0XHRcdFx0XHRpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUuY29kZSA9PT0gJ0VNRklMRScpIHtcclxuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRcdFx0XHQvLyBub2RlID49IDAuOS4wXHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHNldEltbWVkaWF0ZShsb2FkUGl0Y2guYmluZCh0aGlzKSk7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSAge1xyXG5cdFx0XHRcdFx0XHRcdC8vIG5vZGUgPCAwLjkuMFxyXG5cdFx0XHRcdFx0XHRcdHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGxvYWRQaXRjaC5iaW5kKHRoaXMpKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKGUpXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYodHlwZW9mIF9fd2VicGFja19yZXF1aXJlX2xvYWRlcl9fID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdFx0bC5tb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9sb2FkZXJfXyhsLnJlcXVlc3QpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcIkNhbm5vdCBsb2FkIGxvYWRlciwgX193ZWJwYWNrX3JlcXVpcmVfbG9hZGVyX18gbm90IHByb3ZpZGVkLlwiKSk7XHJcblx0XHR9XHJcblx0XHRpZih0eXBlb2YgbC5tb2R1bGUgIT09IFwiZnVuY3Rpb25cIilcclxuXHRcdFx0cmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcIkxvYWRlciBcIiArIGwucmVxdWVzdCArIFwiIGRpZG4ndCByZXR1cm4gYSBmdW5jdGlvblwiKSk7XHJcblx0XHR2YXIgcGl0Y2hlZExvYWRlcnMgPSBbXTtcclxuXHRcdHZhciByZW1haW5pbmcgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBsb2FkZXJDb250ZXh0LmxvYWRlckluZGV4OyBpKyspXHJcblx0XHRcdHBpdGNoZWRMb2FkZXJzLnB1c2gobG9hZGVyQ29udGV4dC5sb2FkZXJzW2ldLnJlcXVlc3QpO1xyXG5cdFx0Zm9yKGkgPSBsb2FkZXJDb250ZXh0LmxvYWRlckluZGV4ICsgMTsgaSA8IGxvYWRlckNvbnRleHQubG9hZGVycy5sZW5ndGg7IGkrKylcclxuXHRcdFx0cmVtYWluaW5nLnB1c2gobG9hZGVyQ29udGV4dC5sb2FkZXJzW2ldLnJlcXVlc3QpO1xyXG5cdFx0cmVtYWluaW5nLnB1c2gobG9hZGVyQ29udGV4dC5yZXNvdXJjZSk7XHJcblx0XHRpZih0eXBlb2YgbC5tb2R1bGUucGl0Y2ggIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGxvYWRQaXRjaC5jYWxsKHRoaXMpO1xyXG5cdFx0bG9hZGVyQ29udGV4dENhY2hlYWJsZSA9IGZhbHNlO1xyXG5cdFx0dmFyIHByaXZhdGVMb2FkZXJDb250ZXh0ID0gT2JqZWN0LmNyZWF0ZShsb2FkZXJDb250ZXh0KTtcclxuXHRcdHByaXZhdGVMb2FkZXJDb250ZXh0LnF1ZXJ5ID0gbC5xdWVyeTtcclxuXHRcdHJ1blN5bmNPckFzeW5jKGwubW9kdWxlLnBpdGNoLCBwcml2YXRlTG9hZGVyQ29udGV4dCwgW3JlbWFpbmluZy5qb2luKFwiIVwiKSwgcGl0Y2hlZExvYWRlcnMuam9pbihcIiFcIiksIGwuZGF0YSA9IHt9XSwgZnVuY3Rpb24oZXJyKSB7XHJcblx0XHRcdGlmKGVycikgcmV0dXJuIG9uTW9kdWxlQnVpbGRGYWlsZWQuY2FsbCh0aGlzLCBlcnIpO1xyXG5cdFx0XHRpZighbG9hZGVyQ29udGV4dENhY2hlYWJsZSkgdGhpcy5jYWNoZWFibGUgPSBmYWxzZTtcclxuXHRcdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG5cdFx0XHRsb2FkZXJDb250ZXh0LnJlc291cmNlUGF0aCA9IHByaXZhdGVMb2FkZXJDb250ZXh0LnJlc291cmNlUGF0aDtcclxuXHRcdFx0bG9hZGVyQ29udGV4dC5yZXNvdXJjZVF1ZXJ5ID0gcHJpdmF0ZUxvYWRlckNvbnRleHQucmVzb3VyY2VRdWVyeTtcclxuXHRcdFx0bG9hZGVyQ29udGV4dC5yZXNvdXJjZSA9IHByaXZhdGVMb2FkZXJDb250ZXh0LnJlc291cmNlO1xyXG5cdFx0XHRsb2FkZXJDb250ZXh0LmxvYWRlckluZGV4ID0gcHJpdmF0ZUxvYWRlckNvbnRleHQubG9hZGVySW5kZXg7XHJcblx0XHRcdGlmKGFyZ3MubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdG5leHRMb2FkZXIuYXBwbHkodGhpcywgW251bGxdLmNvbmNhdChhcmdzKSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bG9hZFBpdGNoLmNhbGwodGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdH0uYmluZCh0aGlzKSk7XHJcblx0fS5jYWxsKHRoaXMpKTtcclxuXHJcblx0dmFyIHJlc291cmNlQnVmZmVyO1xyXG5cdGZ1bmN0aW9uIG9uTG9hZFBpdGNoRG9uZSgpIHtcclxuXHRcdGxvYWRlckNvbnRleHQubG9hZGVySW5kZXggPSBsb2FkZXJDb250ZXh0LmxvYWRlcnMubGVuZ3RoO1xyXG5cdFx0dmFyIHJlcXVlc3QgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBsb2FkZXJDb250ZXh0LmxvYWRlcnMubGVuZ3RoOyBpKyspXHJcblx0XHRcdHJlcXVlc3QucHVzaChsb2FkZXJDb250ZXh0LmxvYWRlcnNbaV0ucmVxdWVzdCk7XHJcblx0XHRyZXF1ZXN0LnB1c2gobG9hZGVyQ29udGV4dC5yZXNvdXJjZSk7XHJcblx0XHRsb2FkZXJDb250ZXh0LnJlcXVlc3QgPSByZXF1ZXN0LmpvaW4oXCIhXCIpO1xyXG5cdFx0dmFyIHJlc291cmNlUGF0aCA9IGxvYWRlckNvbnRleHQucmVzb3VyY2VQYXRoO1xyXG5cdFx0bG9hZGVyQ29udGV4dENhY2hlYWJsZSA9IHRydWU7XHJcblx0XHRpZihyZXNvdXJjZVBhdGgpIHtcclxuXHRcdFx0bG9hZGVyQ29udGV4dC5hZGREZXBlbmRlbmN5KHJlc291cmNlUGF0aCk7XHJcblx0XHRcdGZzLnJlYWRGaWxlKHJlc291cmNlUGF0aCwgZnVuY3Rpb24oZXJyLCBidWZmZXIpIHtcclxuXHRcdFx0XHRpZihlcnIpIHJldHVybiBuZXh0TG9hZGVyKGVycik7XHJcblx0XHRcdFx0aWYobW9kdWxlLmxpbmVUb0xpbmUpXHJcblx0XHRcdFx0XHRyZXNvdXJjZUJ1ZmZlciA9IGJ1ZmZlcjtcclxuXHRcdFx0XHRuZXh0TG9hZGVyKG51bGwsIGJ1ZmZlcik7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlXHJcblx0XHRcdG5leHRMb2FkZXIobnVsbCwgbnVsbCk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBuZXh0TG9hZGVyKGVyci8qLCBwYXJhbUJ1ZmZlcjEsIHBhcmFtMiwgLi4uKi8pIHtcclxuXHRcdGlmKCFsb2FkZXJDb250ZXh0Q2FjaGVhYmxlKSBtb2R1bGUuY2FjaGVhYmxlID0gZmFsc2U7XHJcblx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblx0XHRpZihlcnIpIHtcclxuXHRcdFx0Ly8gYSBsb2FkZXIgZW1pdHRlZCBhbiBlcnJvclxyXG5cdFx0XHRyZXR1cm4gb25Nb2R1bGVCdWlsZEZhaWxlZC5jYWxsKG1vZHVsZSwgZXJyKTtcclxuXHRcdH1cclxuXHRcdGlmKGxvYWRlckNvbnRleHQubG9hZGVySW5kZXggPT09IDApIHtcclxuXHRcdFx0aWYoQnVmZmVyLmlzQnVmZmVyKGFyZ3NbMF0pKVxyXG5cdFx0XHRcdGFyZ3NbMF0gPSB1dGY4QnVmZmVyVG9TdHJpbmcoYXJnc1swXSk7XHJcblx0XHRcdHJldHVybiBvbk1vZHVsZUJ1aWxkLmFwcGx5KG1vZHVsZSwgYXJncyk7XHJcblx0XHR9XHJcblx0XHRsb2FkZXJDb250ZXh0LmxvYWRlckluZGV4LS07XHJcblx0XHR2YXIgbCA9IGxvYWRlckNvbnRleHQubG9hZGVyc1tsb2FkZXJDb250ZXh0LmxvYWRlckluZGV4XTtcclxuXHRcdGlmKCFsLm1vZHVsZSkgcmV0dXJuIG5leHRMb2FkZXIuYXBwbHkobnVsbCwgW251bGxdLmNvbmNhdChhcmdzKSk7XHJcblx0XHR2YXIgcHJpdmF0ZUxvYWRlckNvbnRleHQgPSBPYmplY3QuY3JlYXRlKGxvYWRlckNvbnRleHQpO1xyXG5cdFx0cHJpdmF0ZUxvYWRlckNvbnRleHQuZGF0YSA9IGwuZGF0YTtcclxuXHRcdHByaXZhdGVMb2FkZXJDb250ZXh0LmlucHV0VmFsdWUgPSBsb2FkZXJDb250ZXh0LmlucHV0VmFsdWU7XHJcblx0XHRwcml2YXRlTG9hZGVyQ29udGV4dC5xdWVyeSA9IGwucXVlcnk7XHJcblx0XHRpZighbC5tb2R1bGUucmF3ICYmIEJ1ZmZlci5pc0J1ZmZlcihhcmdzWzBdKSkge1xyXG5cdFx0XHRhcmdzWzBdID0gdXRmOEJ1ZmZlclRvU3RyaW5nKGFyZ3NbMF0pO1xyXG5cdFx0fSBlbHNlIGlmKGwubW9kdWxlLnJhdyAmJiB0eXBlb2YgYXJnc1swXSA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0XHRhcmdzWzBdID0gbmV3IEJ1ZmZlcihhcmdzWzBdLCBcInV0Zi04XCIpO1xyXG5cdFx0fVxyXG5cdFx0bG9hZGVyQ29udGV4dENhY2hlYWJsZSA9IGZhbHNlO1xyXG5cdFx0cnVuU3luY09yQXN5bmMobC5tb2R1bGUsIHByaXZhdGVMb2FkZXJDb250ZXh0LCBhcmdzLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0bG9hZGVyQ29udGV4dC5pbnB1dFZhbHVlID0gcHJpdmF0ZUxvYWRlckNvbnRleHQudmFsdWU7XHJcblx0XHRcdG5leHRMb2FkZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblxyXG5cdGZ1bmN0aW9uIG9uTW9kdWxlQnVpbGQoc291cmNlLCBzb3VyY2VNYXApIHtcclxuXHRcdGlmKCFCdWZmZXIuaXNCdWZmZXIoc291cmNlKSAmJiB0eXBlb2Ygc291cmNlICE9PSBcInN0cmluZ1wiKVxyXG5cdFx0XHRyZXR1cm4gb25Nb2R1bGVCdWlsZEZhaWxlZC5jYWxsKHRoaXMsIG5ldyBFcnJvcihcIkZpbmFsIGxvYWRlciBkaWRuJ3QgcmV0dXJuIGEgQnVmZmVyIG9yIFN0cmluZ1wiKSk7XHJcblx0XHRpZih0aGlzLmlkZW50aWZpZXIgJiYgdGhpcy5saW5lVG9MaW5lICYmIHJlc291cmNlQnVmZmVyKSB7XHJcblx0XHRcdHRoaXMuX3NvdXJjZSA9IG5ldyBMaW5lVG9MaW5lTWFwcGVkU291cmNlKHNvdXJjZSwgdGhpcy5pZGVudGlmaWVyKCksXHJcblx0XHRcdFx0cmVzb3VyY2VCdWZmZXIudG9TdHJpbmcoXCJ1dGYtOFwiKSk7XHJcblx0XHR9IGVsc2UgaWYodGhpcy5pZGVudGlmaWVyICYmIHRoaXMudXNlU291cmNlTWFwICYmIHNvdXJjZU1hcCkge1xyXG5cdFx0XHR0aGlzLl9zb3VyY2UgPSBuZXcgU291cmNlTWFwU291cmNlKHNvdXJjZSwgdGhpcy5pZGVudGlmaWVyKCksIHNvdXJjZU1hcCk7XHJcblx0XHR9IGVsc2UgaWYodGhpcy5pZGVudGlmaWVyKSB7XHJcblx0XHRcdHRoaXMuX3NvdXJjZSA9IG5ldyBPcmlnaW5hbFNvdXJjZShzb3VyY2UsIHRoaXMuaWRlbnRpZmllcigpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuX3NvdXJjZSA9IG5ldyBSYXdTb3VyY2Uoc291cmNlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBjYWxsYmFjaygpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gb25Nb2R1bGVCdWlsZEZhaWxlZChlcnIpIHtcclxuXHRcdHRoaXMuZXJyb3IgPSBlcnI7XHJcblx0XHRyZXR1cm4gY2FsbGJhY2sobmV3IE1vZHVsZUJ1aWxkRXJyb3IodGhpcywgZXJyKSk7XHJcblx0fVxyXG59O1xyXG5cclxuTm9ybWFsTW9kdWxlTWl4aW4ucHJvdG90eXBlLmZpbGxMb2FkZXJDb250ZXh0ID0gZnVuY3Rpb24gZmlsbExvYWRlckNvbnRleHQoKSB7fTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spLWNvcmUvbGliL05vcm1hbE1vZHVsZU1peGluLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgU291cmNlTm9kZSA9IHJlcXVpcmUoXCJzb3VyY2UtbWFwXCIpLlNvdXJjZU5vZGU7XHJcbnZhciBTb3VyY2VNYXBDb25zdW1lciA9IHJlcXVpcmUoXCJzb3VyY2UtbWFwXCIpLlNvdXJjZU1hcENvbnN1bWVyO1xyXG52YXIgU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZShcInNvdXJjZS1tYXBcIikuU291cmNlTWFwR2VuZXJhdG9yO1xyXG52YXIgU291cmNlTGlzdE1hcCA9IHJlcXVpcmUoXCJzb3VyY2UtbGlzdC1tYXBcIikuU291cmNlTGlzdE1hcDtcclxudmFyIGZyb21TdHJpbmdXaXRoU291cmNlTWFwID0gcmVxdWlyZShcInNvdXJjZS1saXN0LW1hcFwiKS5mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcDtcclxudmFyIFNvdXJjZSA9IHJlcXVpcmUoXCIuL1NvdXJjZVwiKTtcclxuXHJcbmZ1bmN0aW9uIFNvdXJjZU1hcFNvdXJjZSh2YWx1ZSwgbmFtZSwgc291cmNlTWFwLCBvcmlnaW5hbFNvdXJjZSwgaW5uZXJTb3VyY2VNYXApIHtcclxuXHRTb3VyY2UuY2FsbCh0aGlzKTtcclxuXHR0aGlzLl92YWx1ZSA9IHZhbHVlO1xyXG5cdHRoaXMuX25hbWUgPSBuYW1lO1xyXG5cdHRoaXMuX3NvdXJjZU1hcCA9IHNvdXJjZU1hcDtcclxuXHR0aGlzLl9vcmlnaW5hbFNvdXJjZSA9IG9yaWdpbmFsU291cmNlO1xyXG5cdHRoaXMuX2lubmVyU291cmNlTWFwID0gaW5uZXJTb3VyY2VNYXA7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBTb3VyY2VNYXBTb3VyY2U7XHJcblxyXG5Tb3VyY2VNYXBTb3VyY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2UucHJvdG90eXBlKTtcclxuU291cmNlTWFwU291cmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvdXJjZU1hcFNvdXJjZTtcclxuXHJcblNvdXJjZU1hcFNvdXJjZS5wcm90b3R5cGUuc291cmNlID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuX3ZhbHVlO1xyXG59O1xyXG5cclxucmVxdWlyZShcIi4vU291cmNlQW5kTWFwTWl4aW5cIikoU291cmNlTWFwU291cmNlLnByb3RvdHlwZSk7XHJcblxyXG5Tb3VyY2VNYXBTb3VyY2UucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0dmFyIGlubmVyU291cmNlTWFwID0gdGhpcy5faW5uZXJTb3VyY2VNYXA7XHJcblx0dmFyIHNvdXJjZU1hcCA9IHRoaXMuX3NvdXJjZU1hcDtcclxuXHRpZihpbm5lclNvdXJjZU1hcCkge1xyXG5cdFx0aW5uZXJTb3VyY2VNYXAgPSBuZXcgU291cmNlTWFwQ29uc3VtZXIoaW5uZXJTb3VyY2VNYXApO1xyXG5cdFx0c291cmNlTWFwID0gU291cmNlTWFwR2VuZXJhdG9yLmZyb21Tb3VyY2VNYXAobmV3IFNvdXJjZU1hcENvbnN1bWVyKHNvdXJjZU1hcCkpO1xyXG5cdFx0c291cmNlTWFwLnNldFNvdXJjZUNvbnRlbnQodGhpcy5fbmFtZSwgdGhpcy5fb3JpZ2luYWxTb3VyY2UpO1xyXG5cdFx0c291cmNlTWFwLmFwcGx5U291cmNlTWFwKGlubmVyU291cmNlTWFwLCB0aGlzLl9uYW1lKTtcclxuXHRcdHNvdXJjZU1hcCA9IHNvdXJjZU1hcC50b0pTT04oKTtcclxuXHR9XHJcblx0cmV0dXJuIFNvdXJjZU5vZGUuZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAodGhpcy5fdmFsdWUsIG5ldyBTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXApKTtcclxufTtcclxuXHJcblNvdXJjZU1hcFNvdXJjZS5wcm90b3R5cGUubGlzdE1hcCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHRpZihvcHRpb25zLm1vZHVsZSA9PT0gZmFsc2UpXHJcblx0XHRyZXR1cm4gbmV3IFNvdXJjZUxpc3RNYXAodGhpcy5fdmFsdWUsIHRoaXMuX25hbWUsIHRoaXMuX3ZhbHVlKTtcclxuXHRyZXR1cm4gZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAodGhpcy5fdmFsdWUsIHR5cGVvZiB0aGlzLl9zb3VyY2VNYXAgPT09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKHRoaXMuX3NvdXJjZU1hcCkgOiB0aGlzLl9zb3VyY2VNYXApO1xyXG59O1xyXG5cclxuU291cmNlTWFwU291cmNlLnByb3RvdHlwZS51cGRhdGVIYXNoID0gZnVuY3Rpb24oaGFzaCkge1xyXG5cdGhhc2gudXBkYXRlKHRoaXMuX3ZhbHVlKTtcclxuXHRpZih0aGlzLl9vcmlnaW5hbFNvdXJjZSlcclxuXHRcdGhhc2gudXBkYXRlKHRoaXMuX29yaWdpbmFsU291cmNlKTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spLWNvcmUvbGliL1NvdXJjZU1hcFNvdXJjZS5qc1xuLy8gbW9kdWxlIGlkID0gNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIFNvdXJjZU5vZGUgPSByZXF1aXJlKFwic291cmNlLW1hcFwiKS5Tb3VyY2VOb2RlO1xyXG52YXIgU291cmNlTGlzdE1hcCA9IHJlcXVpcmUoXCJzb3VyY2UtbGlzdC1tYXBcIikuU291cmNlTGlzdE1hcDtcclxudmFyIFNvdXJjZSA9IHJlcXVpcmUoXCIuL1NvdXJjZVwiKTtcclxuXHJcbmZ1bmN0aW9uIExpbmVUb0xpbmVNYXBwZWRTb3VyY2UodmFsdWUsIG5hbWUsIG9yaWdpbmFsU291cmNlKSB7XHJcblx0U291cmNlLmNhbGwodGhpcyk7XHJcblx0dGhpcy5fdmFsdWUgPSB2YWx1ZTtcclxuXHR0aGlzLl9uYW1lID0gbmFtZTtcclxuXHR0aGlzLl9vcmlnaW5hbFNvdXJjZSA9IG9yaWdpbmFsU291cmNlO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IExpbmVUb0xpbmVNYXBwZWRTb3VyY2U7XHJcblxyXG5MaW5lVG9MaW5lTWFwcGVkU291cmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlLnByb3RvdHlwZSk7XHJcbkxpbmVUb0xpbmVNYXBwZWRTb3VyY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZVRvTGluZU1hcHBlZFNvdXJjZTtcclxuXHJcbkxpbmVUb0xpbmVNYXBwZWRTb3VyY2UucHJvdG90eXBlLnNvdXJjZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLl92YWx1ZTtcclxufTtcclxuXHJcbnJlcXVpcmUoXCIuL1NvdXJjZUFuZE1hcE1peGluXCIpKExpbmVUb0xpbmVNYXBwZWRTb3VyY2UucHJvdG90eXBlKTtcclxuXHJcbkxpbmVUb0xpbmVNYXBwZWRTb3VyY2UucHJvdG90eXBlLm5vZGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0dmFyIHZhbHVlID0gdGhpcy5fdmFsdWU7XHJcblx0dmFyIG5hbWUgPSB0aGlzLl9uYW1lO1xyXG5cdHZhciBsaW5lcyA9IHZhbHVlLnNwbGl0KFwiXFxuXCIpO1xyXG5cdHZhciBub2RlID0gbmV3IFNvdXJjZU5vZGUobnVsbCwgbnVsbCwgbnVsbCxcclxuXHRcdGxpbmVzLm1hcChmdW5jdGlvbihsaW5lLCBpZHgpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBTb3VyY2VOb2RlKGlkeCsxLCAwLCBuYW1lLFxyXG5cdFx0XHRcdChsaW5lICsgKGlkeCAhPSBsaW5lcy5sZW5ndGgtMSA/IFwiXFxuXCIgOiBcIlwiKSlcclxuXHRcdFx0KTtcclxuXHRcdH0pXHJcblx0KTtcclxuXHRub2RlLnNldFNvdXJjZUNvbnRlbnQobmFtZSwgdGhpcy5fb3JpZ2luYWxTb3VyY2UpO1xyXG5cdHJldHVybiBub2RlO1xyXG59O1xyXG5cclxuTGluZVRvTGluZU1hcHBlZFNvdXJjZS5wcm90b3R5cGUubGlzdE1hcCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IFNvdXJjZUxpc3RNYXAodGhpcy5fdmFsdWUsIHRoaXMuX25hbWUsIHRoaXMuX29yaWdpbmFsU291cmNlKVxyXG59O1xyXG5cclxuTGluZVRvTGluZU1hcHBlZFNvdXJjZS5wcm90b3R5cGUudXBkYXRlSGFzaCA9IGZ1bmN0aW9uKGhhc2gpIHtcclxuXHRoYXNoLnVwZGF0ZSh0aGlzLl92YWx1ZSk7XHJcblx0aGFzaC51cGRhdGUodGhpcy5fb3JpZ2luYWxTb3VyY2UpO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjayktY29yZS9saWIvTGluZVRvTGluZU1hcHBlZFNvdXJjZS5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIGxvYWRlckZsYWcgPSBcIldFQlBBQ0tfQ09SRV9MT0FERVJfRVhFQ1VUSU9OXCI7XHJcbmZ1bmN0aW9uIE1vZHVsZUJ1aWxkRXJyb3IobW9kdWxlLCBlcnIpIHtcclxuXHRFcnJvci5jYWxsKHRoaXMpO1xyXG5cdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIE1vZHVsZUJ1aWxkRXJyb3IpO1xyXG5cdHRoaXMubmFtZSA9IFwiTW9kdWxlQnVpbGRFcnJvclwiO1xyXG5cdHRoaXMubWVzc2FnZSA9IFwiTW9kdWxlIGJ1aWxkIGZhaWxlZDogXCI7XHJcblx0aWYoZXJyICE9PSBudWxsICYmIHR5cGVvZiBlcnIgPT09IFwib2JqZWN0XCIpIHtcclxuXHRcdGlmKHR5cGVvZiBlcnIuc3RhY2sgPT09IFwic3RyaW5nXCIgJiYgZXJyLnN0YWNrKSB7XHJcblx0XHRcdHZhciBzdGFjayA9IGVyci5zdGFjay5zcGxpdChcIlxcblwiKTtcclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKVxyXG5cdFx0XHRcdGlmKHN0YWNrW2ldLmluZGV4T2YobG9hZGVyRmxhZykgPj0gMClcclxuXHRcdFx0XHRcdHN0YWNrLmxlbmd0aCA9IGk7XHJcblx0XHRcdHN0YWNrID0gc3RhY2suam9pbihcIlxcblwiKTtcclxuXHRcdFx0aWYoIWVyci5oaWRlU3RhY2spIHtcclxuXHRcdFx0XHR0aGlzLm1lc3NhZ2UgKz0gc3RhY2s7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5kZXRhaWxzID0gc3RhY2s7XHJcblx0XHRcdFx0aWYodHlwZW9mIGVyci5tZXNzYWdlID09PSBcInN0cmluZ1wiICYmIGVyci5tZXNzYWdlKSB7XHJcblx0XHRcdFx0XHR0aGlzLm1lc3NhZ2UgKz0gZXJyLm1lc3NhZ2U7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRoaXMubWVzc2FnZSArPSBlcnI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYodHlwZW9mIGVyci5tZXNzYWdlID09PSBcInN0cmluZ1wiICYmIGVyci5tZXNzYWdlKSB7XHJcblx0XHRcdHRoaXMubWVzc2FnZSArPSBlcnIubWVzc2FnZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMubWVzc2FnZSArPSBlcnI7XHJcblx0XHR9XHJcblx0fVxyXG5cdHRoaXMubW9kdWxlID0gbW9kdWxlO1xyXG5cdHRoaXMuZXJyb3IgPSBlcnI7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBNb2R1bGVCdWlsZEVycm9yO1xyXG5cclxuTW9kdWxlQnVpbGRFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS1jb3JlL2xpYi9Nb2R1bGVCdWlsZEVycm9yLmpzXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5mdW5jdGlvbiBNb2R1bGVFcnJvcihtb2R1bGUsIGVycikge1xyXG5cdEVycm9yLmNhbGwodGhpcyk7XHJcblx0RXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgTW9kdWxlRXJyb3IpO1xyXG5cdHRoaXMubmFtZSA9IFwiTW9kdWxlRXJyb3JcIjtcclxuXHR0aGlzLm1vZHVsZSA9IG1vZHVsZTtcclxuXHR0aGlzLm1lc3NhZ2UgPSBlcnI7XHJcblx0dGhpcy5lcnJvciA9IGVycjtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IE1vZHVsZUVycm9yO1xyXG5cclxuTW9kdWxlRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjayktY29yZS9saWIvTW9kdWxlRXJyb3IuanNcbi8vIG1vZHVsZSBpZCA9IDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbmZ1bmN0aW9uIE1vZHVsZVdhcm5pbmcobW9kdWxlLCB3YXJuaW5nKSB7XHJcblx0RXJyb3IuY2FsbCh0aGlzKTtcclxuXHRFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBNb2R1bGVXYXJuaW5nKTtcclxuXHR0aGlzLm5hbWUgPSBcIk1vZHVsZVdhcm5pbmdcIjtcclxuXHR0aGlzLm1vZHVsZSA9IG1vZHVsZTtcclxuXHR0aGlzLm1lc3NhZ2UgPSB3YXJuaW5nO1xyXG5cdHRoaXMud2FybmluZyA9IHdhcm5pbmc7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBNb2R1bGVXYXJuaW5nO1xyXG5cclxuTW9kdWxlV2FybmluZy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS1jb3JlL2xpYi9Nb2R1bGVXYXJuaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5mdW5jdGlvbiBNb2R1bGVQYXJzZUVycm9yKG1vZHVsZSwgc291cmNlLCBlcnIpIHtcclxuXHRFcnJvci5jYWxsKHRoaXMpO1xyXG5cdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIE1vZHVsZVBhcnNlRXJyb3IpO1xyXG5cdHRoaXMubmFtZSA9IFwiTW9kdWxlUGFyc2VFcnJvclwiO1xyXG5cdHRoaXMubWVzc2FnZSA9IFwiTW9kdWxlIHBhcnNlIGZhaWxlZDogXCIgKyBtb2R1bGUucmVxdWVzdCArIFwiIFwiICsgZXJyLm1lc3NhZ2U7XHJcblx0dGhpcy5tZXNzYWdlICs9IFwiXFxuWW91IG1heSBuZWVkIGFuIGFwcHJvcHJpYXRlIGxvYWRlciB0byBoYW5kbGUgdGhpcyBmaWxlIHR5cGUuXCI7XHJcblx0aWYodHlwZW9mIGVyci5saW5lTnVtYmVyID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRpZigvW1xcMFxcdTAwMDFcXHUwMDAyXFx1MDAwM1xcdTAwMDRcXHUwMDA1XFx1MDAwNlxcdTAwMDddLy50ZXN0KHNvdXJjZSkpIHsgLy8gYmluYXJ5IGZpbGVcclxuXHRcdFx0dGhpcy5tZXNzYWdlICs9IFwiXFxuKFNvdXJjZSBjb2RlIG9taXR0ZWQgZm9yIHRoaXMgYmluYXJ5IGZpbGUpXCI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzb3VyY2UgPSBzb3VyY2Uuc3BsaXQoXCJcXG5cIik7XHJcblx0XHRcdHRoaXMubWVzc2FnZSArPSBcIlxcbnwgXCIgKyBzb3VyY2Uuc2xpY2UoTWF0aC5tYXgoMCwgZXJyLmxpbmVOdW1iZXIgLSAzKSwgZXJyLmxpbmVOdW1iZXIgKyAyKS5qb2luKFwiXFxufCBcIik7XHJcblx0XHR9XHJcblx0fSBlbHNlIHtcclxuXHRcdHRoaXMubWVzc2FnZSArPSBcIlxcblwiICsgZXJyLnN0YWNrO1xyXG5cdH1cclxuXHR0aGlzLm1vZHVsZSA9IG1vZHVsZTtcclxuXHR0aGlzLmVycm9yID0gZXJyO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gTW9kdWxlUGFyc2VFcnJvcjtcclxuXHJcbk1vZHVsZVBhcnNlRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL01vZHVsZVBhcnNlRXJyb3IuanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbmZ1bmN0aW9uIFRlbXBsYXRlQXJndW1lbnREZXBlbmRlbmN5KG5hbWUsIGRlcCkge1xyXG5cdHRoaXMubmFtZSA9IG5hbWU7XHJcblx0dGhpcy5kZXAgPSBkZXA7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBUZW1wbGF0ZUFyZ3VtZW50RGVwZW5kZW5jeTtcclxuXHJcblRlbXBsYXRlQXJndW1lbnREZXBlbmRlbmN5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRlbXBsYXRlQXJndW1lbnREZXBlbmRlbmN5O1xyXG5UZW1wbGF0ZUFyZ3VtZW50RGVwZW5kZW5jeS5wcm90b3R5cGUudHlwZSA9IFwidGVtcGxhdGUgYXJndW1lbnRcIjtcclxuXHJcblRlbXBsYXRlQXJndW1lbnREZXBlbmRlbmN5LnByb3RvdHlwZS51cGRhdGVIYXNoID0gZnVuY3Rpb24oaGFzaCkge1xyXG5cdGhhc2gudXBkYXRlKHRoaXMubmFtZSk7XHJcbn07XHJcblxyXG5UZW1wbGF0ZUFyZ3VtZW50RGVwZW5kZW5jeS5UZW1wbGF0ZSA9IGZ1bmN0aW9uIFRlbXBsYXRlQXJndW1lbnREZXBlbmRlbmN5VGVtcGxhdGUoKSB7fTtcclxuXHJcblRlbXBsYXRlQXJndW1lbnREZXBlbmRlbmN5LlRlbXBsYXRlLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGRlcCwgc291cmNlLCBvdXRwdXRPcHRpb25zLCByZXF1ZXN0U2hvcnRlbmVyLCBkZXBlbmRlbmN5VGVtcGxhdGVzKSB7XHJcblx0dmFyIGQgPSBkZXAuZGVwO1xyXG5cdHZhciB0ZW1wbGF0ZSA9IGRlcGVuZGVuY3lUZW1wbGF0ZXMuZ2V0KGQuY29uc3RydWN0b3IpO1xyXG5cdGlmKCF0ZW1wbGF0ZSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gdGVtcGxhdGUgZm9yIGRlcGVuZGVuY3k6IFwiICsgZC5jb25zdHJ1Y3Rvci5uYW1lKTtcclxuXHRpZighdGVtcGxhdGUuYXBwbHlBc1RlbXBsYXRlQXJndW1lbnQpIHRocm93IG5ldyBFcnJvcihcIlRlbXBsYXRlIGNhbm5vdCBiZSBhcHBsaWVkIGFzIFRlbXBsYXRlQXJndW1lbnQ6IFwiICsgZC5jb25zdHJ1Y3Rvci5uYW1lKTtcclxuXHRyZXR1cm4gdGVtcGxhdGUuYXBwbHlBc1RlbXBsYXRlQXJndW1lbnQoZGVwLm5hbWUsIGQsIHNvdXJjZSwgb3V0cHV0T3B0aW9ucywgcmVxdWVzdFNob3J0ZW5lciwgZGVwZW5kZW5jeVRlbXBsYXRlcyk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL1RlbXBsYXRlQXJndW1lbnREZXBlbmRlbmN5LmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgRGVwZW5kZW5jaWVzQmxvY2sgPSByZXF1aXJlKFwiLi9EZXBlbmRlbmNpZXNCbG9ja1wiKTtcclxuXHJcbmZ1bmN0aW9uIEFzeW5jRGVwZW5kZW5jaWVzQmxvY2sobmFtZSwgbW9kdWxlLCBsb2MpIHtcclxuXHREZXBlbmRlbmNpZXNCbG9jay5jYWxsKHRoaXMpO1xyXG5cdHRoaXMuY2h1bmtOYW1lID0gbmFtZTtcclxuXHR0aGlzLmNodW5rcyA9IG51bGw7XHJcblx0dGhpcy5tb2R1bGUgPSBtb2R1bGU7XHJcblx0dGhpcy5sb2MgPSBsb2M7XHJcblxyXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNodW5rXCIsIHtcclxuXHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcImBjaHVua2Agd2FzIGJlZW4gcmVuYW1lZCB0byBgY2h1bmtzYCBhbmQgaXMgbm93IGFuIGFycmF5XCIpO1xyXG5cdFx0fSxcclxuXHRcdHNldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcImBjaHVua2Agd2FzIGJlZW4gcmVuYW1lZCB0byBgY2h1bmtzYCBhbmQgaXMgbm93IGFuIGFycmF5XCIpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IEFzeW5jRGVwZW5kZW5jaWVzQmxvY2s7XHJcblxyXG5Bc3luY0RlcGVuZGVuY2llc0Jsb2NrLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRGVwZW5kZW5jaWVzQmxvY2sucHJvdG90eXBlKTtcclxuXHJcbkFzeW5jRGVwZW5kZW5jaWVzQmxvY2sucHJvdG90eXBlLnVwZGF0ZUhhc2ggPSBmdW5jdGlvbiB1cGRhdGVIYXNoKGhhc2gpIHtcclxuXHRoYXNoLnVwZGF0ZSh0aGlzLmNodW5rTmFtZSB8fCBcIlwiKTtcclxuXHRoYXNoLnVwZGF0ZSh0aGlzLmNodW5rcyAmJiB0aGlzLmNodW5rcy5tYXAoZnVuY3Rpb24oY2h1bmspIHtcclxuXHRcdHJldHVybiB0eXBlb2YgY2h1bmsuaWQgPT09IFwibnVtYmVyXCIgPyBjaHVuay5pZCA6IFwiXCI7XHJcblx0fSkuam9pbihcIixcIikgfHwgXCJcIik7XHJcblx0RGVwZW5kZW5jaWVzQmxvY2sucHJvdG90eXBlLnVwZGF0ZUhhc2guY2FsbCh0aGlzLCBoYXNoKTtcclxufTtcclxuXHJcbkFzeW5jRGVwZW5kZW5jaWVzQmxvY2sucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLmNodW5rcyA9IG51bGw7XHJcblx0RGVwZW5kZW5jaWVzQmxvY2sucHJvdG90eXBlLmRpc2Nvbm5lY3QuY2FsbCh0aGlzKTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9Bc3luY0RlcGVuZGVuY2llc0Jsb2NrLmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgTW9kdWxlID0gcmVxdWlyZShcIi4vTW9kdWxlXCIpO1xyXG52YXIgT3JpZ2luYWxTb3VyY2UgPSByZXF1aXJlKFwid2VicGFjay1jb3JlL2xpYi9PcmlnaW5hbFNvdXJjZVwiKTtcclxudmFyIFJhd1NvdXJjZSA9IHJlcXVpcmUoXCJ3ZWJwYWNrLWNvcmUvbGliL1Jhd1NvdXJjZVwiKTtcclxuXHJcbmZ1bmN0aW9uIFJhd01vZHVsZShzb3VyY2UsIGlkZW50aWZpZXIsIHJlYWRhYmxlSWRlbnRpZmllcikge1xyXG5cdE1vZHVsZS5jYWxsKHRoaXMpO1xyXG5cdHRoaXMuc291cmNlU3RyID0gc291cmNlO1xyXG5cdHRoaXMuaWRlbnRpZmllclN0ciA9IGlkZW50aWZpZXIgfHwgdGhpcy5zb3VyY2VTdHI7XHJcblx0dGhpcy5yZWFkYWJsZUlkZW50aWZpZXJTdHIgPSByZWFkYWJsZUlkZW50aWZpZXIgfHwgdGhpcy5pZGVudGlmaWVyU3RyO1xyXG5cdHRoaXMuY2FjaGVhYmxlID0gdHJ1ZTtcclxuXHR0aGlzLmJ1aWx0ID0gZmFsc2U7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBSYXdNb2R1bGU7XHJcblxyXG5SYXdNb2R1bGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNb2R1bGUucHJvdG90eXBlKTtcclxuXHJcblJhd01vZHVsZS5wcm90b3R5cGUuaWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLmlkZW50aWZpZXJTdHI7XHJcbn07XHJcblxyXG5SYXdNb2R1bGUucHJvdG90eXBlLnJlYWRhYmxlSWRlbnRpZmllciA9IGZ1bmN0aW9uKHJlcXVlc3RTaG9ydGVuZXIpIHtcclxuXHRyZXR1cm4gcmVxdWVzdFNob3J0ZW5lci5zaG9ydGVuKHRoaXMucmVhZGFibGVJZGVudGlmaWVyU3RyKTtcclxufTtcclxuXHJcblJhd01vZHVsZS5wcm90b3R5cGUubmVlZFJlYnVpbGQgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gZmFsc2U7XHJcbn07XHJcblxyXG5SYXdNb2R1bGUucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24ob3B0aW9ucywgY29tcGlsYXRpb24sIHJlc29sdmVyLCBmcywgY2FsbGJhY2spIHtcclxuXHR0aGlzLmJ1aWx0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG5cdGNhbGxiYWNrKCk7XHJcbn07XHJcblxyXG5SYXdNb2R1bGUucHJvdG90eXBlLnNvdXJjZSA9IGZ1bmN0aW9uKCkge1xyXG5cdGlmKHRoaXMudXNlU291cmNlTWFwKVxyXG5cdFx0cmV0dXJuIG5ldyBPcmlnaW5hbFNvdXJjZSh0aGlzLnNvdXJjZVN0ciwgdGhpcy5pZGVudGlmaWVyKCkpO1xyXG5cdGVsc2VcclxuXHRcdHJldHVybiBuZXcgUmF3U291cmNlKHRoaXMuc291cmNlU3RyKTtcclxufTtcclxuXHJcblJhd01vZHVsZS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLnNvdXJjZVN0ci5sZW5ndGg7XHJcbn07XHJcblxyXG5SYXdNb2R1bGUucHJvdG90eXBlLmdldFNvdXJjZUhhc2ggPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgaGFzaCA9IHJlcXVpcmUoXCJjcnlwdG9cIikuY3JlYXRlSGFzaChcIm1kNVwiKTtcclxuXHRoYXNoLnVwZGF0ZSh0aGlzLnNvdXJjZVN0cik7XHJcblx0cmV0dXJuIGhhc2guZGlnZXN0KFwiaGV4XCIpO1xyXG59O1xyXG5cclxuUmF3TW9kdWxlLnByb3RvdHlwZS5nZXRBbGxNb2R1bGVEZXBlbmRlbmNpZXMgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gW107XHJcbn07XHJcblxyXG5SYXdNb2R1bGUucHJvdG90eXBlLmNyZWF0ZVRlbXBsYXRlID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIG5ldyBSYXdNb2R1bGUodGhpcy5zb3VyY2VTdHIsIFwidGVtcGxhdGUgb2YgXCIgKyB0aGlzLmlkKTtcclxufTtcclxuXHJcblJhd01vZHVsZS5wcm90b3R5cGUuZ2V0VGVtcGxhdGVBcmd1bWVudHMgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gW107XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvUmF3TW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5mdW5jdGlvbiBMb2FkZXJzTGlzdChsaXN0KSB7XHJcblx0dGhpcy5saXN0ID0gbGlzdCB8fCBbXTtcclxuXHR0aGlzLmxpc3QuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XHJcblx0XHRpZihlbGVtZW50ID09PSBudWxsIHx8IHR5cGVvZiBlbGVtZW50ICE9PSBcIm9iamVjdFwiKVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJFYWNoIGVsZW1lbnQgb2YgdGhlIGxvYWRlcnMgbGlzdCBtdXN0IGJlIGFuIG9iamVjdCBvciBhcnJheVwiKTtcclxuXHR9KTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IExvYWRlcnNMaXN0O1xyXG5cclxuZnVuY3Rpb24gcmVnRXhwQXNNYXRjaGVyKHJlZ0V4cCkge1xyXG5cdHJldHVybiBmdW5jdGlvbihzdHIpIHtcclxuXHRcdHJldHVybiByZWdFeHAudGVzdChzdHIpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXNNYXRjaGVyKHRlc3QpIHtcclxuXHRpZih0eXBlb2YgdGVzdCA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0cmV0dXJuIHJlZ0V4cEFzTWF0Y2hlcihuZXcgUmVnRXhwKFwiXlwiK3Rlc3QucmVwbGFjZSgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csIFwiXFxcXCQmXCIpKSk7XHJcblx0fSBlbHNlIGlmKHR5cGVvZiB0ZXN0ID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdHJldHVybiB0ZXN0O1xyXG5cdH0gZWxzZSBpZih0ZXN0IGluc3RhbmNlb2YgUmVnRXhwKSB7XHJcblx0XHRyZXR1cm4gcmVnRXhwQXNNYXRjaGVyKHRlc3QpO1xyXG5cdH0gZWxzZSBpZihBcnJheS5pc0FycmF5KHRlc3QpKSB7XHJcblx0XHR2YXIgbWF0Y2hlcnMgPSB0ZXN0Lm1hcChmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRcdGlmKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcclxuXHRcdFx0XHR2YXIgbWF0Y2hlcnMgPSBpdGVtLm1hcChhc01hdGNoZXIpO1xyXG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbihzdHIpIHtcclxuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVycy5ldmVyeShmdW5jdGlvbihtYXRjaGVyKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKHN0cik7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldHVybiBhc01hdGNoZXIoaXRlbSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHN0cikge1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGVzdC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGlmKG1hdGNoZXJzW2ldKHN0cikpXHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9O1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IodGVzdCArIFwiIGlzIG5vdCBhIHZhbGlkIHRlc3RcIik7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRMb2FkZXJzRnJvbU9iamVjdChlbGVtZW50KSB7XHJcblx0aWYoZWxlbWVudC5xdWVyeSkge1xyXG5cdFx0aWYoIWVsZW1lbnQubG9hZGVyIHx8IGVsZW1lbnQubG9hZGVyLmluZGV4T2YoXCIhXCIpID49IDApIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBkZWZpbmUgJ3F1ZXJ5JyBhbmQgbXVsdGlwbGUgbG9hZGVycyBpbiBsb2FkZXJzIGxpc3RcIik7XHJcblx0XHRpZih0eXBlb2YgZWxlbWVudC5xdWVyeSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIFtlbGVtZW50LmxvYWRlciArIFwiP1wiICsgZWxlbWVudC5xdWVyeV07XHJcblx0XHRyZXR1cm4gW2VsZW1lbnQubG9hZGVyICsgXCI/XCIgKyBKU09OLnN0cmluZ2lmeShlbGVtZW50LnF1ZXJ5KV07XHJcblx0fVxyXG5cdGlmKGVsZW1lbnQubG9hZGVyKSByZXR1cm4gZWxlbWVudC5sb2FkZXIuc3BsaXQoXCIhXCIpO1xyXG5cdGlmKGVsZW1lbnQubG9hZGVycykgcmV0dXJuIGVsZW1lbnQubG9hZGVycztcclxuXHR0aHJvdyBuZXcgRXJyb3IoXCJFbGVtZW50IGZyb20gbG9hZGVycyBsaXN0IHNob3VsZCBoYXZlIG9uZSBvZiB0aGUgZmllbGRzICdsb2FkZXInIG9yICdsb2FkZXJzJ1wiKTtcclxufVxyXG5cclxuTG9hZGVyc0xpc3QucHJvdG90eXBlLm1hdGNoUGFydCA9IGZ1bmN0aW9uIG1hdGNoUGFydChzdHIsIHRlc3QpIHtcclxuXHRpZighdGVzdCkgcmV0dXJuIHRydWU7XHJcblx0dmFyIG1hdGNoZXIgPSBhc01hdGNoZXIodGVzdCk7XHJcblx0cmV0dXJuIG1hdGNoZXIoc3RyKTtcclxufTtcclxuXHJcbkxvYWRlcnNMaXN0LnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKHN0cikge1xyXG5cdHJldHVybiB0aGlzLmxpc3QubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuXHRcdGlmKEFycmF5LmlzQXJyYXkoZWxlbWVudCkpIHtcclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGVsZW1lbnQubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRpZih0aGlzLm1hdGNoT2JqZWN0KHN0ciwgZWxlbWVudFtpXSkpXHJcblx0XHRcdFx0XHRyZXR1cm4gZ2V0TG9hZGVyc0Zyb21PYmplY3QoZWxlbWVudFtpXSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmKHRoaXMubWF0Y2hPYmplY3Qoc3RyLCBlbGVtZW50KSlcclxuXHRcdFx0XHRyZXR1cm4gZ2V0TG9hZGVyc0Zyb21PYmplY3QoZWxlbWVudCk7XHJcblx0XHR9XHJcblx0fSwgdGhpcykuZmlsdGVyKEJvb2xlYW4pLnJlZHVjZShmdW5jdGlvbihhcnJheSwgcikge1xyXG5cdFx0ci5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcclxuXHRcdFx0YXJyYXkucHVzaChyKTtcclxuXHRcdH0pO1xyXG5cdFx0cmV0dXJuIGFycmF5O1xyXG5cdH0sIFtdKSB8fCBbXTtcclxufTtcclxuXHJcbkxvYWRlcnNMaXN0LnByb3RvdHlwZS5tYXRjaE9iamVjdCA9IGZ1bmN0aW9uIG1hdGNoT2JqZWN0KHN0ciwgb2JqKSB7XHJcblx0aWYob2JqLnRlc3QpXHJcblx0XHRpZighdGhpcy5tYXRjaFBhcnQoc3RyLCBvYmoudGVzdCkpIHJldHVybiBmYWxzZTtcclxuXHRpZihvYmouaW5jbHVkZSlcclxuXHRcdGlmKCF0aGlzLm1hdGNoUGFydChzdHIsIG9iai5pbmNsdWRlKSkgcmV0dXJuIGZhbHNlO1xyXG5cdGlmKG9iai5leGNsdWRlKVxyXG5cdFx0aWYodGhpcy5tYXRjaFBhcnQoc3RyLCBvYmouZXhjbHVkZSkpIHJldHVybiBmYWxzZTtcclxuXHRyZXR1cm4gdHJ1ZTtcclxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjayktY29yZS9saWIvTG9hZGVyc0xpc3QuanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBhc3luYyA9IHJlcXVpcmUoXCJhc3luY1wiKTtcclxudmFyIHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcclxuXHJcbnZhciBUYXBhYmxlID0gcmVxdWlyZShcInRhcGFibGVcIik7XHJcbnZhciBDb250ZXh0TW9kdWxlID0gcmVxdWlyZShcIi4vQ29udGV4dE1vZHVsZVwiKTtcclxudmFyIENvbnRleHRFbGVtZW50RGVwZW5kZW5jeSA9IHJlcXVpcmUoXCIuL2RlcGVuZGVuY2llcy9Db250ZXh0RWxlbWVudERlcGVuZGVuY3lcIik7XHJcblxyXG5mdW5jdGlvbiBDb250ZXh0TW9kdWxlRmFjdG9yeShyZXNvbHZlcnMpIHtcclxuXHRUYXBhYmxlLmNhbGwodGhpcyk7XHJcblx0dGhpcy5yZXNvbHZlcnMgPSByZXNvbHZlcnM7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBDb250ZXh0TW9kdWxlRmFjdG9yeTtcclxuXHJcbkNvbnRleHRNb2R1bGVGYWN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVGFwYWJsZS5wcm90b3R5cGUpO1xyXG5Db250ZXh0TW9kdWxlRmFjdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb250ZXh0TW9kdWxlRmFjdG9yeTtcclxuXHJcbkNvbnRleHRNb2R1bGVGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihjb250ZXh0LCBkZXBlbmRlbmN5LCBjYWxsYmFjaykge1xyXG5cdHRoaXMuYXBwbHlQbHVnaW5zQXN5bmNXYXRlcmZhbGwoXCJiZWZvcmUtcmVzb2x2ZVwiLCB7XHJcblx0XHRjb250ZXh0OiBjb250ZXh0LFxyXG5cdFx0cmVxdWVzdDogZGVwZW5kZW5jeS5yZXF1ZXN0LFxyXG5cdFx0cmVjdXJzaXZlOiBkZXBlbmRlbmN5LnJlY3Vyc2l2ZSxcclxuXHRcdHJlZ0V4cDogZGVwZW5kZW5jeS5yZWdFeHBcclxuXHR9LCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xyXG5cdFx0aWYoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHJcblx0XHQvLyBJZ25vcmVkXHJcblx0XHRpZighcmVzdWx0KSByZXR1cm4gY2FsbGJhY2soKTtcclxuXHJcblx0XHR2YXIgY29udGV4dCA9IHJlc3VsdC5jb250ZXh0O1xyXG5cdFx0dmFyIHJlcXVlc3QgPSByZXN1bHQucmVxdWVzdDtcclxuXHRcdHZhciByZWN1cnNpdmUgPSByZXN1bHQucmVjdXJzaXZlO1xyXG5cdFx0dmFyIHJlZ0V4cCA9IHJlc3VsdC5yZWdFeHA7XHJcblxyXG5cdFx0dmFyIGxvYWRlcnMsIHJlc291cmNlLCBsb2FkZXJzUHJlZml4ID0gXCJcIjtcclxuXHRcdHZhciBpZHggPSByZXF1ZXN0Lmxhc3RJbmRleE9mKFwiIVwiKTtcclxuXHRcdGlmKGlkeCA+PSAwKSB7XHJcblx0XHRcdGxvYWRlcnMgPSByZXF1ZXN0LnN1YnN0cigwLCBpZHggKyAxKTtcclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGxvYWRlcnMubGVuZ3RoICYmIGxvYWRlcnNbaV0gPT09IFwiIVwiOyBpKyspIHtcclxuXHRcdFx0XHRsb2FkZXJzUHJlZml4ICs9IFwiIVwiO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxvYWRlcnMgPSBsb2FkZXJzLnN1YnN0cihpKS5yZXBsYWNlKC8hKyQvLCBcIlwiKS5yZXBsYWNlKC8hISsvZywgXCIhXCIpO1xyXG5cdFx0XHRpZihsb2FkZXJzID09PSBcIlwiKSBsb2FkZXJzID0gW107XHJcblx0XHRcdGVsc2UgbG9hZGVycyA9IGxvYWRlcnMuc3BsaXQoXCIhXCIpO1xyXG5cdFx0XHRyZXNvdXJjZSA9IHJlcXVlc3Quc3Vic3RyKGlkeCArIDEpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bG9hZGVycyA9IFtdO1xyXG5cdFx0XHRyZXNvdXJjZSA9IHJlcXVlc3Q7XHJcblx0XHR9XHJcblxyXG5cdFx0YXN5bmMucGFyYWxsZWwoW1xyXG5cdFx0XHR0aGlzLnJlc29sdmVycy5jb250ZXh0LnJlc29sdmUuYmluZCh0aGlzLnJlc29sdmVycy5jb250ZXh0LCBjb250ZXh0LCByZXNvdXJjZSksXHJcblx0XHRcdGFzeW5jLm1hcC5iaW5kKGFzeW5jLCBsb2FkZXJzLCB0aGlzLnJlc29sdmVycy5sb2FkZXIucmVzb2x2ZS5iaW5kKHRoaXMucmVzb2x2ZXJzLmxvYWRlciwgY29udGV4dCkpXHJcblx0XHRdLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xyXG5cdFx0XHRpZihlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG5cclxuXHRcdFx0dGhpcy5hcHBseVBsdWdpbnNBc3luY1dhdGVyZmFsbChcImFmdGVyLXJlc29sdmVcIiwge1xyXG5cdFx0XHRcdGxvYWRlcnM6IGxvYWRlcnNQcmVmaXggKyByZXN1bHRbMV0uam9pbihcIiFcIikgKyAocmVzdWx0WzFdLmxlbmd0aCA+IDAgPyBcIiFcIiA6IFwiXCIpLFxyXG5cdFx0XHRcdHJlc291cmNlOiByZXN1bHRbMF0sXHJcblx0XHRcdFx0cmVjdXJzaXZlOiByZWN1cnNpdmUsXHJcblx0XHRcdFx0cmVnRXhwOiByZWdFeHAsXHJcblx0XHRcdFx0cmVzb2x2ZURlcGVuZGVuY2llczogdGhpcy5yZXNvbHZlRGVwZW5kZW5jaWVzLmJpbmQodGhpcylcclxuXHRcdFx0fSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcclxuXHRcdFx0XHRpZihlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG5cclxuXHRcdFx0XHQvLyBJZ25vcmVkXHJcblx0XHRcdFx0aWYoIXJlc3VsdCkgcmV0dXJuIGNhbGxiYWNrKCk7XHJcblxyXG5cdFx0XHRcdHJldHVybiBjYWxsYmFjayhudWxsLCBuZXcgQ29udGV4dE1vZHVsZShyZXN1bHQucmVzb2x2ZURlcGVuZGVuY2llcywgcmVzdWx0LnJlc291cmNlLCByZXN1bHQucmVjdXJzaXZlLCByZXN1bHQucmVnRXhwLCByZXN1bHQubG9hZGVycykpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0uYmluZCh0aGlzKSk7XHJcblx0fS5iaW5kKHRoaXMpKTtcclxufTtcclxuXHJcbkNvbnRleHRNb2R1bGVGYWN0b3J5LnByb3RvdHlwZS5yZXNvbHZlRGVwZW5kZW5jaWVzID0gZnVuY3Rpb24gcmVzb2x2ZURlcGVuZGVuY2llcyhmcywgcmVzb3VyY2UsIHJlY3Vyc2l2ZSwgcmVnRXhwLCBjYWxsYmFjaykge1xyXG5cdChmdW5jdGlvbiBhZGREaXJlY3RvcnkoZGlyZWN0b3J5LCBjYWxsYmFjaykge1xyXG5cdFx0ZnMucmVhZGRpcihkaXJlY3RvcnksIGZ1bmN0aW9uKGVyciwgZmlsZXMpIHtcclxuXHRcdFx0aWYoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHRcdFx0aWYoIWZpbGVzIHx8IGZpbGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIFtdKTtcclxuXHRcdFx0YXN5bmMubWFwKGZpbGVzLmZpbHRlcihmdW5jdGlvbihwKSB7XHJcblx0XHRcdFx0cmV0dXJuIHAuaW5kZXhPZihcIi5cIikgIT09IDA7XHJcblx0XHRcdH0pLCBmdW5jdGlvbihzZXFtZW50LCBjYWxsYmFjaykge1xyXG5cclxuXHRcdFx0XHR2YXIgc3ViUmVzb3VyY2UgPSBwYXRoLmpvaW4oZGlyZWN0b3J5LCBzZXFtZW50KTtcclxuXHJcblx0XHRcdFx0ZnMuc3RhdChzdWJSZXNvdXJjZSwgZnVuY3Rpb24oZXJyLCBzdGF0KSB7XHJcblx0XHRcdFx0XHRpZihlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG5cclxuXHRcdFx0XHRcdGlmKHN0YXQuaXNEaXJlY3RvcnkoKSkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYoIXJlY3Vyc2l2ZSkgcmV0dXJuIGNhbGxiYWNrKCk7XHJcblx0XHRcdFx0XHRcdGFkZERpcmVjdG9yeS5jYWxsKHRoaXMsIHN1YlJlc291cmNlLCBjYWxsYmFjayk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKHN0YXQuaXNGaWxlKCkpIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBvYmogPSB7XHJcblx0XHRcdFx0XHRcdFx0Y29udGV4dDogcmVzb3VyY2UsXHJcblx0XHRcdFx0XHRcdFx0cmVxdWVzdDogXCIuXCIgKyBzdWJSZXNvdXJjZS5zdWJzdHIocmVzb3VyY2UubGVuZ3RoKS5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKVxyXG5cdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0XHR0aGlzLmFwcGx5UGx1Z2luc0FzeW5jV2F0ZXJmYWxsKFwiYWx0ZXJuYXRpdmVzXCIsIFtvYmpdLCBmdW5jdGlvbihlcnIsIGFsdGVybmF0aXZlcykge1xyXG5cdFx0XHRcdFx0XHRcdGlmKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcblx0XHRcdFx0XHRcdFx0YWx0ZXJuYXRpdmVzID0gYWx0ZXJuYXRpdmVzLmZpbHRlcihmdW5jdGlvbihvYmopIHtcclxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZWdFeHAudGVzdChvYmoucmVxdWVzdCk7XHJcblx0XHRcdFx0XHRcdFx0fSkubWFwKGZ1bmN0aW9uKG9iaikge1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGRlcCA9IG5ldyBDb250ZXh0RWxlbWVudERlcGVuZGVuY3kob2JqLnJlcXVlc3QpO1xyXG5cdFx0XHRcdFx0XHRcdFx0ZGVwLm9wdGlvbmFsID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBkZXA7XHJcblx0XHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgYWx0ZXJuYXRpdmVzKTtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGNhbGxiYWNrKCk7XHJcblxyXG5cdFx0XHRcdH0uYmluZCh0aGlzKSk7XHJcblxyXG5cdFx0XHR9LmJpbmQodGhpcyksIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XHJcblx0XHRcdFx0aWYoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHJcblx0XHRcdFx0aWYoIXJlc3VsdCkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIFtdKTtcclxuXHJcblx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgcmVzdWx0LmZpbHRlcihmdW5jdGlvbihpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gISFpO1xyXG5cdFx0XHRcdH0pLnJlZHVjZShmdW5jdGlvbihhLCBpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gYS5jb25jYXQoaSk7XHJcblx0XHRcdFx0fSwgW10pKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9LmJpbmQodGhpcykpO1xyXG5cdH0uY2FsbCh0aGlzLCByZXNvdXJjZSwgY2FsbGJhY2spKTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9Db250ZXh0TW9kdWxlRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIE1vZHVsZSA9IHJlcXVpcmUoXCIuL01vZHVsZVwiKTtcclxudmFyIE9yaWdpbmFsU291cmNlID0gcmVxdWlyZShcIndlYnBhY2stY29yZS9saWIvT3JpZ2luYWxTb3VyY2VcIik7XHJcbnZhciBSYXdTb3VyY2UgPSByZXF1aXJlKFwid2VicGFjay1jb3JlL2xpYi9SYXdTb3VyY2VcIik7XHJcblxyXG5mdW5jdGlvbiBDb250ZXh0TW9kdWxlKHJlc29sdmVEZXBlbmRlbmNpZXMsIGNvbnRleHQsIHJlY3Vyc2l2ZSwgcmVnRXhwLCBhZGRvbikge1xyXG5cdE1vZHVsZS5jYWxsKHRoaXMpO1xyXG5cdHRoaXMucmVzb2x2ZURlcGVuZGVuY2llcyA9IHJlc29sdmVEZXBlbmRlbmNpZXM7XHJcblx0dGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuXHR0aGlzLnJlY3Vyc2l2ZSA9IHJlY3Vyc2l2ZTtcclxuXHR0aGlzLnJlZ0V4cCA9IHJlZ0V4cDtcclxuXHR0aGlzLmFkZG9uID0gYWRkb247XHJcblx0dGhpcy5jYWNoZWFibGUgPSB0cnVlO1xyXG5cdHRoaXMuY29udGV4dERlcGVuZGVuY2llcyA9IFtjb250ZXh0XTtcclxuXHR0aGlzLmJ1aWx0ID0gZmFsc2U7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBDb250ZXh0TW9kdWxlO1xyXG5cclxuQ29udGV4dE1vZHVsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE1vZHVsZS5wcm90b3R5cGUpO1xyXG5cclxuQ29udGV4dE1vZHVsZS5wcm90b3R5cGUuaWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBpZGVudGlmaWVyID0gXCJcIjtcclxuXHRpZGVudGlmaWVyICs9IHRoaXMuY29udGV4dCArIFwiIFwiO1xyXG5cdGlmKCF0aGlzLnJlY3Vyc2l2ZSlcclxuXHRcdGlkZW50aWZpZXIgKz0gXCJub25yZWN1cnNpdmUgXCI7XHJcblx0aWYodGhpcy5hZGRvbilcclxuXHRcdGlkZW50aWZpZXIgKz0gdGhpcy5hZGRvbjtcclxuXHRpZih0aGlzLnJlZ0V4cClcclxuXHRcdGlkZW50aWZpZXIgKz0gdGhpcy5yZWdFeHA7XHJcblx0cmV0dXJuIGlkZW50aWZpZXIucmVwbGFjZSgvICQvLCBcIlwiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHByZXR0eVJlZ0V4cChzdHIpIHtcclxuXHRyZXR1cm4gc3RyLnN1YnN0cmluZygxLCBzdHIubGVuZ3RoIC0gMSk7XHJcbn1cclxuXHJcbkNvbnRleHRNb2R1bGUucHJvdG90eXBlLnJlYWRhYmxlSWRlbnRpZmllciA9IGZ1bmN0aW9uKHJlcXVlc3RTaG9ydGVuZXIpIHtcclxuXHR2YXIgaWRlbnRpZmllciA9IFwiXCI7XHJcblx0aWRlbnRpZmllciArPSByZXF1ZXN0U2hvcnRlbmVyLnNob3J0ZW4odGhpcy5jb250ZXh0KSArIFwiIFwiO1xyXG5cdGlmKCF0aGlzLnJlY3Vyc2l2ZSlcclxuXHRcdGlkZW50aWZpZXIgKz0gXCJub25yZWN1cnNpdmUgXCI7XHJcblx0aWYodGhpcy5hZGRvbilcclxuXHRcdGlkZW50aWZpZXIgKz0gcmVxdWVzdFNob3J0ZW5lci5zaG9ydGVuKHRoaXMuYWRkb24pO1xyXG5cdGlmKHRoaXMucmVnRXhwKVxyXG5cdFx0aWRlbnRpZmllciArPSBwcmV0dHlSZWdFeHAodGhpcy5yZWdFeHAgKyBcIlwiKTtcclxuXHRyZXR1cm4gaWRlbnRpZmllci5yZXBsYWNlKC8gJC8sIFwiXCIpO1xyXG59O1xyXG5cclxuQ29udGV4dE1vZHVsZS5wcm90b3R5cGUubmVlZFJlYnVpbGQgPSBmdW5jdGlvbihmaWxlVGltZXN0YW1wcywgY29udGV4dFRpbWVzdGFtcHMpIHtcclxuXHR2YXIgdHMgPSBjb250ZXh0VGltZXN0YW1wc1t0aGlzLmNvbnRleHRdO1xyXG5cdGlmKCF0cykgcmV0dXJuIHRydWU7XHJcblx0cmV0dXJuIHRzID49IHRoaXMuYnVpbHRUaW1lO1xyXG59O1xyXG5cclxuQ29udGV4dE1vZHVsZS5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uIGRpc2Nvbm5lY3QoKSB7XHJcblx0dGhpcy5idWlsdCA9IGZhbHNlO1xyXG5cdE1vZHVsZS5wcm90b3R5cGUuZGlzY29ubmVjdC5jYWxsKHRoaXMpO1xyXG59O1xyXG5cclxuQ29udGV4dE1vZHVsZS5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbihvcHRpb25zLCBjb21waWxhdGlvbiwgcmVzb2x2ZXIsIGZzLCBjYWxsYmFjaykge1xyXG5cdHRoaXMuYnVpbHQgPSB0cnVlO1xyXG5cdHRoaXMuYnVpbHRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcblx0dmFyIGFkZG9uID0gdGhpcy5hZGRvbjtcclxuXHR0aGlzLnJlc29sdmVEZXBlbmRlbmNpZXMoZnMsIHRoaXMuY29udGV4dCwgdGhpcy5yZWN1cnNpdmUsIHRoaXMucmVnRXhwLCBmdW5jdGlvbihlcnIsIGRlcGVuZGVuY2llcykge1xyXG5cdFx0aWYoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHRcdGlmKGRlcGVuZGVuY2llcykge1xyXG5cdFx0XHRkZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbihkZXApIHtcclxuXHRcdFx0XHRkZXAubG9jID0gZGVwLnVzZXJSZXF1ZXN0O1xyXG5cdFx0XHRcdGRlcC5yZXF1ZXN0ID0gYWRkb24gKyBkZXAucmVxdWVzdDtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcztcclxuXHRcdGNhbGxiYWNrKCk7XHJcblx0fS5iaW5kKHRoaXMpKTtcclxufTtcclxuXHJcbkNvbnRleHRNb2R1bGUucHJvdG90eXBlLnNvdXJjZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBzdHI7XHJcblx0aWYodGhpcy5kZXBlbmRlbmNpZXMgJiYgdGhpcy5kZXBlbmRlbmNpZXMubGVuZ3RoID4gMCkge1xyXG5cdFx0dmFyIG1hcCA9IHt9O1xyXG5cdFx0dGhpcy5kZXBlbmRlbmNpZXMuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdFx0aWYoYS51c2VyUmVxdWVzdCA9PT0gYi51c2VyUmVxdWVzdCkgcmV0dXJuIDA7XHJcblx0XHRcdHJldHVybiBhLnVzZXJSZXF1ZXN0IDwgYi51c2VyUmVxdWVzdCA/IC0xIDogMTtcclxuXHRcdH0pLmZvckVhY2goZnVuY3Rpb24oZGVwKSB7XHJcblx0XHRcdGlmKGRlcC5tb2R1bGUpXHJcblx0XHRcdFx0bWFwW2RlcC51c2VyUmVxdWVzdF0gPSBkZXAubW9kdWxlLmlkO1xyXG5cdFx0fSk7XHJcblx0XHRzdHIgPSBbXHJcblx0XHRcdFwidmFyIG1hcCA9IFwiLCBKU09OLnN0cmluZ2lmeShtYXAsIG51bGwsIFwiXFx0XCIpLCBcIjtcXG5cIixcclxuXHRcdFx0XCJmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dChyZXEpIHtcXG5cIixcclxuXHRcdFx0XCJcXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyh3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSk7XFxuXCIsXHJcblx0XHRcdFwifTtcXG5cIixcclxuXHRcdFx0XCJmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XFxuXCIsXHJcblx0XHRcdFwiXFx0cmV0dXJuIG1hcFtyZXFdIHx8IChmdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKFxcXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1xcXCIgKyByZXEgKyBcXFwiJy5cXFwiKSB9KCkpO1xcblwiLFxyXG5cdFx0XHRcIn07XFxuXCIsXHJcblx0XHRcdFwid2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcXG5cIixcclxuXHRcdFx0XCJcXHRyZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcXG5cIixcclxuXHRcdFx0XCJ9O1xcblwiLFxyXG5cdFx0XHRcIndlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XFxuXCIsXHJcblx0XHRcdFwibW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQ29udGV4dDtcXG5cIixcclxuXHRcdFx0XCJ3ZWJwYWNrQ29udGV4dC5pZCA9IFwiICsgdGhpcy5pZCArIFwiO1xcblwiXHJcblx0XHRdO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRzdHIgPSBbXHJcblx0XHRcdFwiZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XFxuXCIsXHJcblx0XHRcdFwiXFx0dGhyb3cgbmV3IEVycm9yKFxcXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1xcXCIgKyByZXEgKyBcXFwiJy5cXFwiKTtcXG5cIixcclxuXHRcdFx0XCJ9XFxuXCIsXHJcblx0XHRcdFwid2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH07XFxuXCIsXHJcblx0XHRcdFwid2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0O1xcblwiLFxyXG5cdFx0XHRcIm1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7XFxuXCIsXHJcblx0XHRcdFwid2VicGFja0NvbnRleHQuaWQgPSBcIiArIHRoaXMuaWQgKyBcIjtcXG5cIlxyXG5cdFx0XTtcclxuXHR9XHJcblx0aWYodGhpcy51c2VTb3VyY2VNYXApIHtcclxuXHRcdHJldHVybiBuZXcgT3JpZ2luYWxTb3VyY2Uoc3RyLmpvaW4oXCJcIiksIHRoaXMuaWRlbnRpZmllcigpKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIG5ldyBSYXdTb3VyY2Uoc3RyLmpvaW4oXCJcIikpO1xyXG5cdH1cclxufTtcclxuXHJcbkNvbnRleHRNb2R1bGUucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5kZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uKGRlcCkge1xyXG5cdFx0cmV0dXJuIGRlcC51c2VyUmVxdWVzdC5sZW5ndGggKyA1O1xyXG5cdH0pLnJlZHVjZShmdW5jdGlvbihhLCBiKSB7XHJcblx0XHRyZXR1cm4gYSArIGI7XHJcblx0fSwgMTYwKTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9Db250ZXh0TW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgTW9kdWxlRGVwZW5kZW5jeSA9IHJlcXVpcmUoXCIuL01vZHVsZURlcGVuZGVuY3lcIik7XHJcblxyXG5mdW5jdGlvbiBDb250ZXh0RWxlbWVudERlcGVuZGVuY3kocmVxdWVzdCwgdXNlclJlcXVlc3QpIHtcclxuXHRNb2R1bGVEZXBlbmRlbmN5LmNhbGwodGhpcywgcmVxdWVzdCk7XHJcblx0aWYodXNlclJlcXVlc3QpIHtcclxuXHRcdHRoaXMudXNlclJlcXVlc3QgPSB1c2VyUmVxdWVzdDtcclxuXHR9XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBDb250ZXh0RWxlbWVudERlcGVuZGVuY3k7XHJcblxyXG5Db250ZXh0RWxlbWVudERlcGVuZGVuY3kucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNb2R1bGVEZXBlbmRlbmN5LnByb3RvdHlwZSk7XHJcbkNvbnRleHRFbGVtZW50RGVwZW5kZW5jeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb250ZXh0RWxlbWVudERlcGVuZGVuY3k7XHJcbkNvbnRleHRFbGVtZW50RGVwZW5kZW5jeS5wcm90b3R5cGUudHlwZSA9IFwiY29udGV4dCBlbGVtZW50XCI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL0NvbnRleHRFbGVtZW50RGVwZW5kZW5jeS5qc1xuLy8gbW9kdWxlIGlkID0gODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIERlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi4vRGVwZW5kZW5jeVwiKTtcclxuXHJcbmZ1bmN0aW9uIE1vZHVsZURlcGVuZGVuY3kocmVxdWVzdCkge1xyXG5cdERlcGVuZGVuY3kuY2FsbCh0aGlzKTtcclxuXHR0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xyXG5cdHRoaXMudXNlclJlcXVlc3QgPSByZXF1ZXN0O1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gTW9kdWxlRGVwZW5kZW5jeTtcclxuXHJcbk1vZHVsZURlcGVuZGVuY3kucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShEZXBlbmRlbmN5LnByb3RvdHlwZSk7XHJcbk1vZHVsZURlcGVuZGVuY3kucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTW9kdWxlRGVwZW5kZW5jeTtcclxuTW9kdWxlRGVwZW5kZW5jeS5wcm90b3R5cGUuaXNFcXVhbFJlc291cmNlID0gZnVuY3Rpb24gaXNFcXVhbFJlc291cmNlKG90aGVyKSB7XHJcblx0aWYoIShvdGhlciBpbnN0YW5jZW9mIE1vZHVsZURlcGVuZGVuY3kpKVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdHJldHVybiB0aGlzLnJlcXVlc3QgPT09IG90aGVyLnJlcXVlc3Q7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL01vZHVsZURlcGVuZGVuY3kuanNcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbmZ1bmN0aW9uIFdlYkVudmlyb25tZW50UGx1Z2luKGlucHV0RmlsZVN5c3RlbSwgb3V0cHV0RmlsZVN5c3RlbSkge1xyXG5cdHRoaXMuaW5wdXRGaWxlU3lzdGVtID0gaW5wdXRGaWxlU3lzdGVtO1xyXG5cdHRoaXMub3V0cHV0RmlsZVN5c3RlbSA9IG91dHB1dEZpbGVTeXN0ZW07XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBXZWJFbnZpcm9ubWVudFBsdWdpbjtcclxuV2ViRW52aXJvbm1lbnRQbHVnaW4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oY29tcGlsZXIpIHtcclxuXHR2YXIgaW5wdXRGaWxlU3lzdGVtID0gY29tcGlsZXIuaW5wdXRGaWxlU3lzdGVtID0gdGhpcy5pbnB1dEZpbGVTeXN0ZW07XHJcblx0Y29tcGlsZXIucmVzb2x2ZXJzLm5vcm1hbC5maWxlU3lzdGVtID0gaW5wdXRGaWxlU3lzdGVtO1xyXG5cdGNvbXBpbGVyLnJlc29sdmVycy5jb250ZXh0LmZpbGVTeXN0ZW0gPSBpbnB1dEZpbGVTeXN0ZW07XHJcblx0Y29tcGlsZXIucmVzb2x2ZXJzLmxvYWRlci5maWxlU3lzdGVtID0gaW5wdXRGaWxlU3lzdGVtO1xyXG5cdGNvbXBpbGVyLm91dHB1dEZpbGVTeXN0ZW0gPSB0aGlzLm91dHB1dEZpbGVTeXN0ZW07XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvd2ViL1dlYkVudmlyb25tZW50UGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgT3B0aW9uc0FwcGx5ID0gcmVxdWlyZShcIi4vT3B0aW9uc0FwcGx5XCIpO1xyXG5cclxudmFyIExvYWRlclRhcmdldFBsdWdpbiA9IHJlcXVpcmUoXCIuL0xvYWRlclRhcmdldFBsdWdpblwiKTtcclxudmFyIEZ1bmN0aW9uTW9kdWxlUGx1Z2luID0gcmVxdWlyZShcIi4vRnVuY3Rpb25Nb2R1bGVQbHVnaW5cIik7XHJcbnZhciBFdmFsRGV2VG9vbE1vZHVsZVBsdWdpbiA9IHJlcXVpcmUoXCIuL0V2YWxEZXZUb29sTW9kdWxlUGx1Z2luXCIpO1xyXG52YXIgU291cmNlTWFwRGV2VG9vbFBsdWdpbiA9IHJlcXVpcmUoXCIuL1NvdXJjZU1hcERldlRvb2xQbHVnaW5cIik7XHJcbnZhciBFdmFsU291cmNlTWFwRGV2VG9vbFBsdWdpbiA9IHJlcXVpcmUoXCIuL0V2YWxTb3VyY2VNYXBEZXZUb29sUGx1Z2luXCIpO1xyXG5cclxudmFyIEVudHJ5T3B0aW9uUGx1Z2luID0gcmVxdWlyZShcIi4vRW50cnlPcHRpb25QbHVnaW5cIik7XHJcbnZhciBSZWNvcmRJZHNQbHVnaW4gPSByZXF1aXJlKFwiLi9SZWNvcmRJZHNQbHVnaW5cIik7XHJcblxyXG52YXIgQVBJUGx1Z2luID0gcmVxdWlyZShcIi4vQVBJUGx1Z2luXCIpO1xyXG52YXIgQ29uc3RQbHVnaW4gPSByZXF1aXJlKFwiLi9Db25zdFBsdWdpblwiKTtcclxudmFyIFJlcXVpcmVKc1N0dWZmUGx1Z2luID0gcmVxdWlyZShcIi4vUmVxdWlyZUpzU3R1ZmZQbHVnaW5cIik7XHJcbnZhciBOb2RlU3R1ZmZQbHVnaW4gPSByZXF1aXJlKFwiLi9Ob2RlU3R1ZmZQbHVnaW5cIik7XHJcbnZhciBDb21wYXRpYmlsaXR5UGx1Z2luID0gcmVxdWlyZShcIi4vQ29tcGF0aWJpbGl0eVBsdWdpblwiKTtcclxudmFyIERlZmluZVBsdWdpbiA9IHJlcXVpcmUoXCIuL0RlZmluZVBsdWdpblwiKTtcclxuXHJcbnZhciBNb3ZlZFRvUGx1Z2luV2FybmluZ1BsdWdpbiA9IHJlcXVpcmUoXCIuL01vdmVkVG9QbHVnaW5XYXJuaW5nUGx1Z2luXCIpO1xyXG52YXIgVGVtcGxhdGVkUGF0aFBsdWdpbiA9IHJlcXVpcmUoXCIuL1RlbXBsYXRlZFBhdGhQbHVnaW5cIik7XHJcbnZhciBXYXJuQ2FzZVNlbnNpdGl2ZU1vZHVsZXNQbHVnaW4gPSByZXF1aXJlKFwiLi9XYXJuQ2FzZVNlbnNpdGl2ZU1vZHVsZXNQbHVnaW5cIik7XHJcblxyXG52YXIgTG9hZGVyUGx1Z2luID0gcmVxdWlyZShcIi4vZGVwZW5kZW5jaWVzL0xvYWRlclBsdWdpblwiKTtcclxudmFyIENvbW1vbkpzUGx1Z2luID0gcmVxdWlyZShcIi4vZGVwZW5kZW5jaWVzL0NvbW1vbkpzUGx1Z2luXCIpO1xyXG52YXIgQU1EUGx1Z2luID0gcmVxdWlyZShcIi4vZGVwZW5kZW5jaWVzL0FNRFBsdWdpblwiKTtcclxudmFyIFJlcXVpcmVDb250ZXh0UGx1Z2luID0gcmVxdWlyZShcIi4vZGVwZW5kZW5jaWVzL1JlcXVpcmVDb250ZXh0UGx1Z2luXCIpO1xyXG52YXIgUmVxdWlyZUVuc3VyZVBsdWdpbiA9IHJlcXVpcmUoXCIuL2RlcGVuZGVuY2llcy9SZXF1aXJlRW5zdXJlUGx1Z2luXCIpO1xyXG52YXIgUmVxdWlyZUluY2x1ZGVQbHVnaW4gPSByZXF1aXJlKFwiLi9kZXBlbmRlbmNpZXMvUmVxdWlyZUluY2x1ZGVQbHVnaW5cIik7XHJcblxyXG52YXIgUmVtb3ZlUGFyZW50TW9kdWxlc1BsdWdpbiA9IHJlcXVpcmUoXCIuL29wdGltaXplL1JlbW92ZVBhcmVudE1vZHVsZXNQbHVnaW5cIik7XHJcbnZhciBSZW1vdmVFbXB0eUNodW5rc1BsdWdpbiA9IHJlcXVpcmUoXCIuL29wdGltaXplL1JlbW92ZUVtcHR5Q2h1bmtzUGx1Z2luXCIpO1xyXG52YXIgTWVyZ2VEdXBsaWNhdGVDaHVua3NQbHVnaW4gPSByZXF1aXJlKFwiLi9vcHRpbWl6ZS9NZXJnZUR1cGxpY2F0ZUNodW5rc1BsdWdpblwiKTtcclxudmFyIEZsYWdJbmNsdWRlZENodW5rc1BsdWdpbiA9IHJlcXVpcmUoXCIuL29wdGltaXplL0ZsYWdJbmNsdWRlZENodW5rc1BsdWdpblwiKTtcclxuXHJcbnZhciBVbnNhZmVDYWNoZVBsdWdpbiA9IHJlcXVpcmUoXCJlbmhhbmNlZC1yZXNvbHZlL2xpYi9VbnNhZmVDYWNoZVBsdWdpblwiKTtcclxudmFyIE1vZHVsZXNJbkRpcmVjdG9yaWVzUGx1Z2luID0gcmVxdWlyZShcImVuaGFuY2VkLXJlc29sdmUvbGliL01vZHVsZXNJbkRpcmVjdG9yaWVzUGx1Z2luXCIpO1xyXG52YXIgTW9kdWxlc0luUm9vdFBsdWdpbiA9IHJlcXVpcmUoXCJlbmhhbmNlZC1yZXNvbHZlL2xpYi9Nb2R1bGVzSW5Sb290UGx1Z2luXCIpO1xyXG52YXIgTW9kdWxlVGVtcGxhdGVzUGx1Z2luID0gcmVxdWlyZShcImVuaGFuY2VkLXJlc29sdmUvbGliL01vZHVsZVRlbXBsYXRlc1BsdWdpblwiKTtcclxudmFyIE1vZHVsZUFzRmlsZVBsdWdpbiA9IHJlcXVpcmUoXCJlbmhhbmNlZC1yZXNvbHZlL2xpYi9Nb2R1bGVBc0ZpbGVQbHVnaW5cIik7XHJcbnZhciBNb2R1bGVBc0RpcmVjdG9yeVBsdWdpbiA9IHJlcXVpcmUoXCJlbmhhbmNlZC1yZXNvbHZlL2xpYi9Nb2R1bGVBc0RpcmVjdG9yeVBsdWdpblwiKTtcclxudmFyIE1vZHVsZUFsaWFzUGx1Z2luID0gcmVxdWlyZShcImVuaGFuY2VkLXJlc29sdmUvbGliL01vZHVsZUFsaWFzUGx1Z2luXCIpO1xyXG52YXIgRGlyZWN0b3J5RGVmYXVsdEZpbGVQbHVnaW4gPSByZXF1aXJlKFwiZW5oYW5jZWQtcmVzb2x2ZS9saWIvRGlyZWN0b3J5RGVmYXVsdEZpbGVQbHVnaW5cIik7XHJcbnZhciBEaXJlY3RvcnlEZXNjcmlwdGlvbkZpbGVQbHVnaW4gPSByZXF1aXJlKFwiZW5oYW5jZWQtcmVzb2x2ZS9saWIvRGlyZWN0b3J5RGVzY3JpcHRpb25GaWxlUGx1Z2luXCIpO1xyXG52YXIgRGlyZWN0b3J5RGVzY3JpcHRpb25GaWxlRmllbGRBbGlhc1BsdWdpbiA9IHJlcXVpcmUoXCJlbmhhbmNlZC1yZXNvbHZlL2xpYi9EaXJlY3RvcnlEZXNjcmlwdGlvbkZpbGVGaWVsZEFsaWFzUGx1Z2luXCIpO1xyXG52YXIgRmlsZUFwcGVuZFBsdWdpbiA9IHJlcXVpcmUoXCJlbmhhbmNlZC1yZXNvbHZlL2xpYi9GaWxlQXBwZW5kUGx1Z2luXCIpO1xyXG52YXIgRGlyZWN0b3J5UmVzdWx0UGx1Z2luID0gcmVxdWlyZShcImVuaGFuY2VkLXJlc29sdmUvbGliL0RpcmVjdG9yeVJlc3VsdFBsdWdpblwiKTtcclxudmFyIFJlc3VsdFN5bWxpbmtQbHVnaW4gPSByZXF1aXJlKFwiZW5oYW5jZWQtcmVzb2x2ZS9saWIvUmVzdWx0U3ltbGlua1BsdWdpblwiKTtcclxuXHJcbmZ1bmN0aW9uIFdlYnBhY2tPcHRpb25zQXBwbHkoKSB7XHJcblx0T3B0aW9uc0FwcGx5LmNhbGwodGhpcyk7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBXZWJwYWNrT3B0aW9uc0FwcGx5O1xyXG5cclxuV2VicGFja09wdGlvbnNBcHBseS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9wdGlvbnNBcHBseS5wcm90b3R5cGUpO1xyXG5XZWJwYWNrT3B0aW9uc0FwcGx5LnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24ob3B0aW9ucywgY29tcGlsZXIpIHtcclxuXHRjb21waWxlci5jb250ZXh0ID0gb3B0aW9ucy5jb250ZXh0O1xyXG5cdGlmKG9wdGlvbnMucGx1Z2lucyAmJiBBcnJheS5pc0FycmF5KG9wdGlvbnMucGx1Z2lucykpIHtcclxuXHRcdGNvbXBpbGVyLmFwcGx5LmFwcGx5KGNvbXBpbGVyLCBvcHRpb25zLnBsdWdpbnMpO1xyXG5cdH1cclxuXHRjb21waWxlci5vdXRwdXRQYXRoID0gb3B0aW9ucy5vdXRwdXQucGF0aDtcclxuXHRjb21waWxlci5yZWNvcmRzSW5wdXRQYXRoID0gb3B0aW9ucy5yZWNvcmRzSW5wdXRQYXRoIHx8IG9wdGlvbnMucmVjb3Jkc1BhdGg7XHJcblx0Y29tcGlsZXIucmVjb3Jkc091dHB1dFBhdGggPSBvcHRpb25zLnJlY29yZHNPdXRwdXRQYXRoIHx8IG9wdGlvbnMucmVjb3Jkc1BhdGg7XHJcblx0Y29tcGlsZXIubmFtZSA9IG9wdGlvbnMubmFtZTtcclxuXHRpZih0eXBlb2Ygb3B0aW9ucy50YXJnZXQgPT09IFwic3RyaW5nXCIpIHtcclxuXHRcdHN3aXRjaChvcHRpb25zLnRhcmdldCkge1xyXG5cdFx0XHRjYXNlIFwid2ViXCI6XHJcblx0XHRcdFx0dmFyIEpzb25wVGVtcGxhdGVQbHVnaW4gPSByZXF1aXJlKFwiLi9Kc29ucFRlbXBsYXRlUGx1Z2luXCIpO1xyXG5cdFx0XHRcdHZhciBOb2RlU291cmNlUGx1Z2luID0gcmVxdWlyZShcIi4vbm9kZS9Ob2RlU291cmNlUGx1Z2luXCIpO1xyXG5cdFx0XHRcdGNvbXBpbGVyLmFwcGx5KFxyXG5cdFx0XHRcdFx0bmV3IEpzb25wVGVtcGxhdGVQbHVnaW4ob3B0aW9ucy5vdXRwdXQpLFxyXG5cdFx0XHRcdFx0bmV3IEZ1bmN0aW9uTW9kdWxlUGx1Z2luKG9wdGlvbnMub3V0cHV0KSxcclxuXHRcdFx0XHRcdG5ldyBOb2RlU291cmNlUGx1Z2luKG9wdGlvbnMubm9kZSksXHJcblx0XHRcdFx0XHRuZXcgTG9hZGVyVGFyZ2V0UGx1Z2luKFwid2ViXCIpXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBcIndlYndvcmtlclwiOlxyXG5cdFx0XHRcdHZhciBXZWJXb3JrZXJUZW1wbGF0ZVBsdWdpbiA9IHJlcXVpcmUoXCIuL3dlYndvcmtlci9XZWJXb3JrZXJUZW1wbGF0ZVBsdWdpblwiKTtcclxuXHRcdFx0XHR2YXIgTm9kZVNvdXJjZVBsdWdpbiA9IHJlcXVpcmUoXCIuL25vZGUvTm9kZVNvdXJjZVBsdWdpblwiKTtcclxuXHRcdFx0XHRjb21waWxlci5hcHBseShcclxuXHRcdFx0XHRcdG5ldyBXZWJXb3JrZXJUZW1wbGF0ZVBsdWdpbihvcHRpb25zLm91dHB1dCksXHJcblx0XHRcdFx0XHRuZXcgRnVuY3Rpb25Nb2R1bGVQbHVnaW4ob3B0aW9ucy5vdXRwdXQpLFxyXG5cdFx0XHRcdFx0bmV3IE5vZGVTb3VyY2VQbHVnaW4ob3B0aW9ucy5ub2RlKSxcclxuXHRcdFx0XHRcdG5ldyBMb2FkZXJUYXJnZXRQbHVnaW4oXCJ3ZWJ3b3JrZXJcIilcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwibm9kZVwiOlxyXG5cdFx0XHRjYXNlIFwiYXN5bmMtbm9kZVwiOlxyXG5cdFx0XHRcdHZhciBOb2RlVGVtcGxhdGVQbHVnaW4gPSByZXF1aXJlKFwiLi9ub2RlL05vZGVUZW1wbGF0ZVBsdWdpblwiKTtcclxuXHRcdFx0XHR2YXIgTm9kZVRhcmdldFBsdWdpbiA9IHJlcXVpcmUoXCIuL25vZGUvTm9kZVRhcmdldFBsdWdpblwiKTtcclxuXHRcdFx0XHRjb21waWxlci5hcHBseShcclxuXHRcdFx0XHRcdG5ldyBOb2RlVGVtcGxhdGVQbHVnaW4ob3B0aW9ucy5vdXRwdXQsIG9wdGlvbnMudGFyZ2V0ID09PSBcImFzeW5jLW5vZGVcIiksXHJcblx0XHRcdFx0XHRuZXcgRnVuY3Rpb25Nb2R1bGVQbHVnaW4ob3B0aW9ucy5vdXRwdXQpLFxyXG5cdFx0XHRcdFx0bmV3IE5vZGVUYXJnZXRQbHVnaW4oKSxcclxuXHRcdFx0XHRcdG5ldyBMb2FkZXJUYXJnZXRQbHVnaW4oXCJub2RlXCIpXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBcIm5vZGUtd2Via2l0XCI6XHJcblx0XHRcdFx0dmFyIEpzb25wVGVtcGxhdGVQbHVnaW4gPSByZXF1aXJlKFwiLi9Kc29ucFRlbXBsYXRlUGx1Z2luXCIpO1xyXG5cdFx0XHRcdHZhciBOb2RlVGFyZ2V0UGx1Z2luID0gcmVxdWlyZShcIi4vbm9kZS9Ob2RlVGFyZ2V0UGx1Z2luXCIpO1xyXG5cdFx0XHRcdHZhciBFeHRlcm5hbHNQbHVnaW4gPSByZXF1aXJlKFwiLi9FeHRlcm5hbHNQbHVnaW5cIik7XHJcblx0XHRcdFx0Y29tcGlsZXIuYXBwbHkoXHJcblx0XHRcdFx0XHRuZXcgSnNvbnBUZW1wbGF0ZVBsdWdpbihvcHRpb25zLm91dHB1dCksXHJcblx0XHRcdFx0XHRuZXcgRnVuY3Rpb25Nb2R1bGVQbHVnaW4ob3B0aW9ucy5vdXRwdXQpLFxyXG5cdFx0XHRcdFx0bmV3IE5vZGVUYXJnZXRQbHVnaW4oKSxcclxuXHRcdFx0XHRcdG5ldyBFeHRlcm5hbHNQbHVnaW4oXCJjb21tb25qc1wiLCBcIm53Lmd1aVwiKSxcclxuXHRcdFx0XHRcdG5ldyBMb2FkZXJUYXJnZXRQbHVnaW4oXCJub2RlLXdlYmtpdFwiKVxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgXCJhdG9tXCI6XHJcblx0XHRcdGNhc2UgXCJlbGVjdHJvblwiOlxyXG5cdFx0XHRjYXNlIFwiZWxlY3Ryb24tbWFpblwiOlxyXG5cdFx0XHRcdHZhciBOb2RlVGVtcGxhdGVQbHVnaW4gPSByZXF1aXJlKFwiLi9ub2RlL05vZGVUZW1wbGF0ZVBsdWdpblwiKTtcclxuXHRcdFx0XHR2YXIgTm9kZVRhcmdldFBsdWdpbiA9IHJlcXVpcmUoXCIuL25vZGUvTm9kZVRhcmdldFBsdWdpblwiKTtcclxuXHRcdFx0XHR2YXIgRXh0ZXJuYWxzUGx1Z2luID0gcmVxdWlyZShcIi4vRXh0ZXJuYWxzUGx1Z2luXCIpO1xyXG5cdFx0XHRcdGNvbXBpbGVyLmFwcGx5KFxyXG5cdFx0XHRcdFx0bmV3IE5vZGVUZW1wbGF0ZVBsdWdpbihvcHRpb25zLm91dHB1dCwgdHJ1ZSksXHJcblx0XHRcdFx0XHRuZXcgRnVuY3Rpb25Nb2R1bGVQbHVnaW4ob3B0aW9ucy5vdXRwdXQpLFxyXG5cdFx0XHRcdFx0bmV3IE5vZGVUYXJnZXRQbHVnaW4oKSxcclxuXHRcdFx0XHRcdG5ldyBFeHRlcm5hbHNQbHVnaW4oXCJjb21tb25qc1wiLCBbXHJcblx0XHRcdFx0XHRcdFwiYXBwXCIsXHJcblx0XHRcdFx0XHRcdFwiYXV0by11cGRhdGVyXCIsXHJcblx0XHRcdFx0XHRcdFwiYnJvd3Nlci13aW5kb3dcIixcclxuXHRcdFx0XHRcdFx0XCJjb250ZW50LXRyYWNpbmdcIixcclxuXHRcdFx0XHRcdFx0XCJkaWFsb2dcIixcclxuXHRcdFx0XHRcdFx0XCJlbGVjdHJvblwiLFxyXG5cdFx0XHRcdFx0XHRcImdsb2JhbC1zaG9ydGN1dFwiLFxyXG5cdFx0XHRcdFx0XHRcImlwY1wiLFxyXG5cdFx0XHRcdFx0XHRcImlwYy1tYWluXCIsXHJcblx0XHRcdFx0XHRcdFwibWVudVwiLFxyXG5cdFx0XHRcdFx0XHRcIm1lbnUtaXRlbVwiLFxyXG5cdFx0XHRcdFx0XHRcInBvd2VyLW1vbml0b3JcIixcclxuXHRcdFx0XHRcdFx0XCJwb3dlci1zYXZlLWJsb2NrZXJcIixcclxuXHRcdFx0XHRcdFx0XCJwcm90b2NvbFwiLFxyXG5cdFx0XHRcdFx0XHRcInNlc3Npb25cIixcclxuXHRcdFx0XHRcdFx0XCJ3ZWItY29udGVudHNcIixcclxuXHRcdFx0XHRcdFx0XCJ0cmF5XCIsXHJcblx0XHRcdFx0XHRcdFwiY2xpcGJvYXJkXCIsXHJcblx0XHRcdFx0XHRcdFwiY3Jhc2gtcmVwb3J0ZXJcIixcclxuXHRcdFx0XHRcdFx0XCJuYXRpdmUtaW1hZ2VcIixcclxuXHRcdFx0XHRcdFx0XCJzY3JlZW5cIixcclxuXHRcdFx0XHRcdFx0XCJzaGVsbFwiXHJcblx0XHRcdFx0XHRdKSxcclxuXHRcdFx0XHRcdG5ldyBMb2FkZXJUYXJnZXRQbHVnaW4ob3B0aW9ucy50YXJnZXQpXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBcImVsZWN0cm9uLXJlbmRlcmVyXCI6XHJcblx0XHRcdFx0dmFyIEpzb25wVGVtcGxhdGVQbHVnaW4gPSByZXF1aXJlKFwiLi9Kc29ucFRlbXBsYXRlUGx1Z2luXCIpO1xyXG5cdFx0XHRcdHZhciBOb2RlVGFyZ2V0UGx1Z2luID0gcmVxdWlyZShcIi4vbm9kZS9Ob2RlVGFyZ2V0UGx1Z2luXCIpO1xyXG5cdFx0XHRcdHZhciBFeHRlcm5hbHNQbHVnaW4gPSByZXF1aXJlKFwiLi9FeHRlcm5hbHNQbHVnaW5cIik7XHJcblx0XHRcdFx0Y29tcGlsZXIuYXBwbHkoXHJcblx0XHRcdFx0XHRuZXcgSnNvbnBUZW1wbGF0ZVBsdWdpbihvcHRpb25zLm91dHB1dCksXHJcblx0XHRcdFx0XHRuZXcgRnVuY3Rpb25Nb2R1bGVQbHVnaW4ob3B0aW9ucy5vdXRwdXQpLFxyXG5cdFx0XHRcdFx0bmV3IE5vZGVUYXJnZXRQbHVnaW4oKSxcclxuXHRcdFx0XHRcdG5ldyBFeHRlcm5hbHNQbHVnaW4oXCJjb21tb25qc1wiLCBbXHJcblx0XHRcdFx0XHRcdFwiZGVza3RvcC1jYXB0dXJlclwiLFxyXG5cdFx0XHRcdFx0XHRcImVsZWN0cm9uXCIsXHJcblx0XHRcdFx0XHRcdFwiaXBjXCIsXHJcblx0XHRcdFx0XHRcdFwiaXBjLXJlbmRlcmVyXCIsXHJcblx0XHRcdFx0XHRcdFwicmVtb3RlXCIsXHJcblx0XHRcdFx0XHRcdFwid2ViLWZyYW1lXCIsXHJcblx0XHRcdFx0XHRcdFwiY2xpcGJvYXJkXCIsXHJcblx0XHRcdFx0XHRcdFwiY3Jhc2gtcmVwb3J0ZXJcIixcclxuXHRcdFx0XHRcdFx0XCJuYXRpdmUtaW1hZ2VcIixcclxuXHRcdFx0XHRcdFx0XCJzY3JlZW5cIixcclxuXHRcdFx0XHRcdFx0XCJzaGVsbFwiXHJcblx0XHRcdFx0XHRdKSxcclxuXHRcdFx0XHRcdG5ldyBMb2FkZXJUYXJnZXRQbHVnaW4ob3B0aW9ucy50YXJnZXQpXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCB0YXJnZXQgJ1wiICsgb3B0aW9ucy50YXJnZXQgKyBcIicuXCIpO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZihvcHRpb25zLnRhcmdldCAhPT0gZmFsc2UpIHtcclxuXHRcdG9wdGlvbnMudGFyZ2V0KGNvbXBpbGVyKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgdGFyZ2V0ICdcIiArIG9wdGlvbnMudGFyZ2V0ICsgXCInLlwiKTtcclxuXHR9XHJcblx0aWYob3B0aW9ucy5vdXRwdXQubGlicmFyeSB8fCBvcHRpb25zLm91dHB1dC5saWJyYXJ5VGFyZ2V0ICE9PSBcInZhclwiKSB7XHJcblx0XHR2YXIgTGlicmFyeVRlbXBsYXRlUGx1Z2luID0gcmVxdWlyZShcIi4vTGlicmFyeVRlbXBsYXRlUGx1Z2luXCIpO1xyXG5cdFx0Y29tcGlsZXIuYXBwbHkobmV3IExpYnJhcnlUZW1wbGF0ZVBsdWdpbihvcHRpb25zLm91dHB1dC5saWJyYXJ5LCBvcHRpb25zLm91dHB1dC5saWJyYXJ5VGFyZ2V0LCBvcHRpb25zLm91dHB1dC51bWROYW1lZERlZmluZSkpO1xyXG5cdH1cclxuXHRpZihvcHRpb25zLmV4dGVybmFscykge1xyXG5cdFx0dmFyIEV4dGVybmFsc1BsdWdpbiA9IHJlcXVpcmUoXCIuL0V4dGVybmFsc1BsdWdpblwiKTtcclxuXHRcdGNvbXBpbGVyLmFwcGx5KG5ldyBFeHRlcm5hbHNQbHVnaW4ob3B0aW9ucy5vdXRwdXQubGlicmFyeVRhcmdldCwgb3B0aW9ucy5leHRlcm5hbHMpKTtcclxuXHR9XHJcblxyXG5cdGlmKG9wdGlvbnMuaG90KSB7XHJcblx0XHRjb21waWxlci5hcHBseShuZXcgTW92ZWRUb1BsdWdpbldhcm5pbmdQbHVnaW4oXCJob3RcIiwgXCJIb3RNb2R1bGVSZXBsYWNlbWVudFBsdWdpblwiKSk7XHJcblx0XHR2YXIgSG90TW9kdWxlUmVwbGFjZW1lbnRQbHVnaW4gPSByZXF1aXJlKFwiLi9Ib3RNb2R1bGVSZXBsYWNlbWVudFBsdWdpblwiKTtcclxuXHRcdGNvbXBpbGVyLmFwcGx5KG5ldyBIb3RNb2R1bGVSZXBsYWNlbWVudFBsdWdpbihvcHRpb25zLm91dHB1dCkpO1xyXG5cdH1cclxuXHJcblx0aWYob3B0aW9ucy5kZXZ0b29sICYmIChvcHRpb25zLmRldnRvb2wuaW5kZXhPZihcInNvdXJjZW1hcFwiKSA+PSAwIHx8IG9wdGlvbnMuZGV2dG9vbC5pbmRleE9mKFwic291cmNlLW1hcFwiKSA+PSAwKSkge1xyXG5cdFx0dmFyIGhpZGRlbiA9IG9wdGlvbnMuZGV2dG9vbC5pbmRleE9mKFwiaGlkZGVuXCIpID49IDA7XHJcblx0XHR2YXIgaW5saW5lID0gb3B0aW9ucy5kZXZ0b29sLmluZGV4T2YoXCJpbmxpbmVcIikgPj0gMDtcclxuXHRcdHZhciBldmFsV3JhcHBlZCA9IG9wdGlvbnMuZGV2dG9vbC5pbmRleE9mKFwiZXZhbFwiKSA+PSAwO1xyXG5cdFx0dmFyIGNoZWFwID0gb3B0aW9ucy5kZXZ0b29sLmluZGV4T2YoXCJjaGVhcFwiKSA+PSAwO1xyXG5cdFx0dmFyIG1vZHVsZU1hcHMgPSBvcHRpb25zLmRldnRvb2wuaW5kZXhPZihcIm1vZHVsZVwiKSA+PSAwO1xyXG5cdFx0dmFyIG5vU291cmNlcyA9IG9wdGlvbnMuZGV2dG9vbC5pbmRleE9mKFwibm9zb3VyY2VzXCIpID49IDA7XHJcblx0XHR2YXIgbGVnYWN5ID0gb3B0aW9ucy5kZXZ0b29sLmluZGV4T2YoXCJAXCIpID49IDA7XHJcblx0XHR2YXIgbW9kZXJuID0gb3B0aW9ucy5kZXZ0b29sLmluZGV4T2YoXCIjXCIpID49IDA7XHJcblx0XHR2YXIgY29tbWVudCA9IGxlZ2FjeSAmJiBtb2Rlcm4gPyBcIlxcbi8qXFxuLy9AIHNvdXJjZU1hcHBpbmdVUkw9W3VybF1cXG4vLyMgc291cmNlTWFwcGluZ1VSTD1bdXJsXVxcbiovXCIgOlxyXG5cdFx0XHRsZWdhY3kgPyBcIlxcbi8qXFxuLy9AIHNvdXJjZU1hcHBpbmdVUkw9W3VybF1cXG4qL1wiIDpcclxuXHRcdFx0bW9kZXJuID8gXCJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1bdXJsXVwiIDpcclxuXHRcdFx0bnVsbDtcclxuXHRcdHZhciBQbHVnaW4gPSBldmFsV3JhcHBlZCA/IEV2YWxTb3VyY2VNYXBEZXZUb29sUGx1Z2luIDogU291cmNlTWFwRGV2VG9vbFBsdWdpbjtcclxuXHRcdGNvbXBpbGVyLmFwcGx5KG5ldyBQbHVnaW4oe1xyXG5cdFx0XHRmaWxlbmFtZTogaW5saW5lID8gbnVsbCA6IG9wdGlvbnMub3V0cHV0LnNvdXJjZU1hcEZpbGVuYW1lLFxyXG5cdFx0XHRtb2R1bGVGaWxlbmFtZVRlbXBsYXRlOiBvcHRpb25zLm91dHB1dC5kZXZ0b29sTW9kdWxlRmlsZW5hbWVUZW1wbGF0ZSxcclxuXHRcdFx0ZmFsbGJhY2tNb2R1bGVGaWxlbmFtZVRlbXBsYXRlOiBvcHRpb25zLm91dHB1dC5kZXZ0b29sRmFsbGJhY2tNb2R1bGVGaWxlbmFtZVRlbXBsYXRlLFxyXG5cdFx0XHRhcHBlbmQ6IGhpZGRlbiA/IGZhbHNlIDogY29tbWVudCxcclxuXHRcdFx0bW9kdWxlOiBtb2R1bGVNYXBzID8gdHJ1ZSA6IGNoZWFwID8gZmFsc2UgOiB0cnVlLFxyXG5cdFx0XHRjb2x1bW5zOiBjaGVhcCA/IGZhbHNlIDogdHJ1ZSxcclxuXHRcdFx0bGluZVRvTGluZTogb3B0aW9ucy5vdXRwdXQuZGV2dG9vbExpbmVUb0xpbmUsXHJcblx0XHRcdG5vU291cmNlczogbm9Tb3VyY2VzLFxyXG5cdFx0fSkpO1xyXG5cdH0gZWxzZSBpZihvcHRpb25zLmRldnRvb2wgJiYgb3B0aW9ucy5kZXZ0b29sLmluZGV4T2YoXCJldmFsXCIpID49IDApIHtcclxuXHRcdHZhciBsZWdhY3kgPSBvcHRpb25zLmRldnRvb2wuaW5kZXhPZihcIkBcIikgPj0gMDtcclxuXHRcdHZhciBtb2Rlcm4gPSBvcHRpb25zLmRldnRvb2wuaW5kZXhPZihcIiNcIikgPj0gMDtcclxuXHRcdHZhciBjb21tZW50ID0gbGVnYWN5ICYmIG1vZGVybiA/IFwiLy9AIHNvdXJjZVVSTD1bdXJsXVxcbi8vIyBzb3VyY2VVUkw9W3VybF1cIiA6XHJcblx0XHRcdGxlZ2FjeSA/IFwiLy9AIHNvdXJjZVVSTD1bdXJsXVwiIDpcclxuXHRcdFx0bW9kZXJuID8gXCIvLyMgc291cmNlVVJMPVt1cmxdXCIgOlxyXG5cdFx0XHRudWxsO1xyXG5cdFx0Y29tcGlsZXIuYXBwbHkobmV3IEV2YWxEZXZUb29sTW9kdWxlUGx1Z2luKGNvbW1lbnQsIG9wdGlvbnMub3V0cHV0LmRldnRvb2xNb2R1bGVGaWxlbmFtZVRlbXBsYXRlKSk7XHJcblx0fVxyXG5cclxuXHRjb21waWxlci5hcHBseShuZXcgRW50cnlPcHRpb25QbHVnaW4oKSk7XHJcblx0Y29tcGlsZXIuYXBwbHlQbHVnaW5zQmFpbFJlc3VsdChcImVudHJ5LW9wdGlvblwiLCBvcHRpb25zLmNvbnRleHQsIG9wdGlvbnMuZW50cnkpO1xyXG5cclxuXHRpZihvcHRpb25zLnByZWZldGNoKSB7XHJcblx0XHRjb21waWxlci5hcHBseShuZXcgTW92ZWRUb1BsdWdpbldhcm5pbmdQbHVnaW4oXCJwcmVmZXRjaFwiLCBcIlByZWZldGNoUGx1Z2luXCIpKTtcclxuXHRcdHZhciBQcmVmZXRjaFBsdWdpbiA9IHJlcXVpcmUoXCIuL1ByZWZldGNoUGx1Z2luXCIpO1xyXG5cdFx0b3B0aW9ucy5wcmVmZXRjaC5tYXAoZnVuY3Rpb24ocmVxdWVzdCkge1xyXG5cdFx0XHRjb21waWxlci5hcHBseShuZXcgUHJlZmV0Y2hQbHVnaW4ob3B0aW9ucy5jb250ZXh0LCByZXF1ZXN0KSk7XHJcblx0XHR9KTtcclxuXHR9XHJcblx0Y29tcGlsZXIuYXBwbHkoXHJcblx0XHRuZXcgQ29tcGF0aWJpbGl0eVBsdWdpbigpLFxyXG5cdFx0bmV3IExvYWRlclBsdWdpbigpLFxyXG5cdFx0bmV3IE5vZGVTdHVmZlBsdWdpbihvcHRpb25zLm5vZGUpLFxyXG5cdFx0bmV3IFJlcXVpcmVKc1N0dWZmUGx1Z2luKCksXHJcblx0XHRuZXcgQVBJUGx1Z2luKCksXHJcblx0XHRuZXcgQ29uc3RQbHVnaW4oKSxcclxuXHRcdG5ldyBSZXF1aXJlSW5jbHVkZVBsdWdpbigpLFxyXG5cdFx0bmV3IFJlcXVpcmVFbnN1cmVQbHVnaW4oKSxcclxuXHRcdG5ldyBSZXF1aXJlQ29udGV4dFBsdWdpbihvcHRpb25zLnJlc29sdmUubW9kdWxlc0RpcmVjdG9yaWVzLCBvcHRpb25zLnJlc29sdmUuZXh0ZW5zaW9ucyksXHJcblx0XHRuZXcgQU1EUGx1Z2luKG9wdGlvbnMubW9kdWxlLCBvcHRpb25zLmFtZCB8fCB7fSksXHJcblx0XHRuZXcgQ29tbW9uSnNQbHVnaW4ob3B0aW9ucy5tb2R1bGUpXHJcblx0KTtcclxuXHJcblx0Y29tcGlsZXIuYXBwbHkoXHJcblx0XHRuZXcgUmVtb3ZlUGFyZW50TW9kdWxlc1BsdWdpbigpLFxyXG5cdFx0bmV3IFJlbW92ZUVtcHR5Q2h1bmtzUGx1Z2luKCksXHJcblx0XHRuZXcgTWVyZ2VEdXBsaWNhdGVDaHVua3NQbHVnaW4oKSxcclxuXHRcdG5ldyBGbGFnSW5jbHVkZWRDaHVua3NQbHVnaW4oKVxyXG5cdCk7XHJcblxyXG5cdGNvbXBpbGVyLmFwcGx5KG5ldyBUZW1wbGF0ZWRQYXRoUGx1Z2luKCkpO1xyXG5cclxuXHRjb21waWxlci5hcHBseShuZXcgUmVjb3JkSWRzUGx1Z2luKCkpO1xyXG5cclxuXHRjb21waWxlci5hcHBseShuZXcgV2FybkNhc2VTZW5zaXRpdmVNb2R1bGVzUGx1Z2luKCkpO1xyXG5cclxuXHRpZihvcHRpb25zLm9wdGltaXplICYmIG9wdGlvbnMub3B0aW1pemUub2NjdXJlbmNlT3JkZXIpIHtcclxuXHRcdGNvbXBpbGVyLmFwcGx5KG5ldyBNb3ZlZFRvUGx1Z2luV2FybmluZ1BsdWdpbihcIm9wdGltaXplLm9jY3VyZW5jZU9yZGVyXCIsIFwib3B0aW1pemUuT2NjdXJyZW5jZU9yZGVyUGx1Z2luXCIpKTtcclxuXHRcdHZhciBPY2N1cnJlbmNlT3JkZXJQbHVnaW4gPSByZXF1aXJlKFwiLi9vcHRpbWl6ZS9PY2N1cnJlbmNlT3JkZXJQbHVnaW5cIik7XHJcblx0XHRjb21waWxlci5hcHBseShuZXcgT2NjdXJyZW5jZU9yZGVyUGx1Z2luKG9wdGlvbnMub3B0aW1pemUub2NjdXJlbmNlT3JkZXJQcmVmZXJFbnRyeSkpO1xyXG5cdH1cclxuXHJcblx0aWYob3B0aW9ucy5vcHRpbWl6ZSAmJiBvcHRpb25zLm9wdGltaXplLm1pbkNodW5rU2l6ZSkge1xyXG5cdFx0Y29tcGlsZXIuYXBwbHkobmV3IE1vdmVkVG9QbHVnaW5XYXJuaW5nUGx1Z2luKFwib3B0aW1pemUubWluQ2h1bmtTaXplXCIsIFwib3B0aW1pemUuTWluQ2h1bmtTaXplUGx1Z2luXCIpKTtcclxuXHRcdHZhciBNaW5DaHVua1NpemVQbHVnaW4gPSByZXF1aXJlKFwiLi9vcHRpbWl6ZS9NaW5DaHVua1NpemVQbHVnaW5cIik7XHJcblx0XHRjb21waWxlci5hcHBseShuZXcgTWluQ2h1bmtTaXplUGx1Z2luKG9wdGlvbnMub3B0aW1pemUpKTtcclxuXHR9XHJcblxyXG5cdGlmKG9wdGlvbnMub3B0aW1pemUgJiYgb3B0aW9ucy5vcHRpbWl6ZS5tYXhDaHVua3MpIHtcclxuXHRcdGNvbXBpbGVyLmFwcGx5KG5ldyBNb3ZlZFRvUGx1Z2luV2FybmluZ1BsdWdpbihcIm9wdGltaXplLm1heENodW5rc1wiLCBcIm9wdGltaXplLkxpbWl0Q2h1bmtDb3VudFBsdWdpblwiKSk7XHJcblx0XHR2YXIgTGltaXRDaHVua0NvdW50UGx1Z2luID0gcmVxdWlyZShcIi4vb3B0aW1pemUvTGltaXRDaHVua0NvdW50UGx1Z2luXCIpO1xyXG5cdFx0Y29tcGlsZXIuYXBwbHkobmV3IExpbWl0Q2h1bmtDb3VudFBsdWdpbihvcHRpb25zLm9wdGltaXplKSk7XHJcblx0fVxyXG5cclxuXHRpZihvcHRpb25zLm9wdGltaXplLm1pbmltaXplKSB7XHJcblx0XHRjb21waWxlci5hcHBseShuZXcgTW92ZWRUb1BsdWdpbldhcm5pbmdQbHVnaW4oXCJvcHRpbWl6ZS5taW5pbWl6ZVwiLCBcIm9wdGltaXplLlVnbGlmeUpzUGx1Z2luXCIpKTtcclxuXHRcdHZhciBVZ2xpZnlKc1BsdWdpbiA9IHJlcXVpcmUoXCIuL29wdGltaXplL1VnbGlmeUpzUGx1Z2luXCIpO1xyXG5cdFx0aWYob3B0aW9ucy5vcHRpbWl6ZS5taW5pbWl6ZSA9PT0gdHJ1ZSlcclxuXHRcdFx0Y29tcGlsZXIuYXBwbHkobmV3IFVnbGlmeUpzUGx1Z2luKCkpO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRjb21waWxlci5hcHBseShuZXcgVWdsaWZ5SnNQbHVnaW4ob3B0aW9ucy5vcHRpbWl6ZS5taW5pbWl6ZSkpO1xyXG5cdH1cclxuXHJcblx0aWYob3B0aW9ucy5jYWNoZSA9PT0gdW5kZWZpbmVkID8gb3B0aW9ucy53YXRjaCA6IG9wdGlvbnMuY2FjaGUpIHtcclxuXHRcdHZhciBDYWNoZVBsdWdpbiA9IHJlcXVpcmUoXCIuL0NhY2hlUGx1Z2luXCIpO1xyXG5cdFx0Y29tcGlsZXIuYXBwbHkobmV3IENhY2hlUGx1Z2luKHR5cGVvZiBvcHRpb25zLmNhY2hlID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5jYWNoZSA6IG51bGwpKTtcclxuXHR9XHJcblxyXG5cdGlmKHR5cGVvZiBvcHRpb25zLnByb3ZpZGUgPT09IFwib2JqZWN0XCIpIHtcclxuXHRcdGNvbXBpbGVyLmFwcGx5KG5ldyBNb3ZlZFRvUGx1Z2luV2FybmluZ1BsdWdpbihcInByb3ZpZGVcIiwgXCJQcm92aWRlUGx1Z2luXCIpKTtcclxuXHRcdHZhciBQcm92aWRlUGx1Z2luID0gcmVxdWlyZShcIi4vUHJvdmlkZVBsdWdpblwiKTtcclxuXHRcdGNvbXBpbGVyLmFwcGx5KG5ldyBQcm92aWRlUGx1Z2luKG9wdGlvbnMucHJvdmlkZSkpO1xyXG5cdH1cclxuXHJcblx0aWYob3B0aW9ucy5kZWZpbmUpIHtcclxuXHRcdGNvbXBpbGVyLmFwcGx5KG5ldyBNb3ZlZFRvUGx1Z2luV2FybmluZ1BsdWdpbihcImRlZmluZVwiLCBcIkRlZmluZVBsdWdpblwiKSk7XHJcblx0XHR2YXIgZGVmaW5lT2JqZWN0ID0ge307XHJcblx0XHRpZih0eXBlb2Ygb3B0aW9ucy5kZWZpbmUgPT09IFwib2JqZWN0XCIpIHtcclxuXHRcdFx0T2JqZWN0LmtleXMob3B0aW9ucy5kZWZpbmUpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XHJcblx0XHRcdFx0ZGVmaW5lT2JqZWN0W2tleV0gPSBvcHRpb25zLmRlZmluZVtrZXldO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHRcdGNvbXBpbGVyLmFwcGx5KG5ldyBEZWZpbmVQbHVnaW4oZGVmaW5lT2JqZWN0KSk7XHJcblx0fVxyXG5cdGlmKG9wdGlvbnMuZGVmaW5lRGVidWcgIT09IGZhbHNlKVxyXG5cdFx0Y29tcGlsZXIuYXBwbHkobmV3IERlZmluZVBsdWdpbih7XHJcblx0XHRcdERFQlVHOiAhIW9wdGlvbnMuZGVidWdcclxuXHRcdH0pKTtcclxuXHJcblx0Y29tcGlsZXIuYXBwbHlQbHVnaW5zKFwiYWZ0ZXItcGx1Z2luc1wiLCBjb21waWxlcik7XHJcblx0Y29tcGlsZXIucmVzb2x2ZXJzLm5vcm1hbC5hcHBseShcclxuXHRcdG5ldyBVbnNhZmVDYWNoZVBsdWdpbihvcHRpb25zLnJlc29sdmUudW5zYWZlQ2FjaGUpLFxyXG5cdFx0b3B0aW9ucy5yZXNvbHZlLnBhY2thZ2VBbGlhcyA/IG5ldyBEaXJlY3RvcnlEZXNjcmlwdGlvbkZpbGVGaWVsZEFsaWFzUGx1Z2luKFwicGFja2FnZS5qc29uXCIsIG9wdGlvbnMucmVzb2x2ZS5wYWNrYWdlQWxpYXMpIDogZnVuY3Rpb24oKSB7fSxcclxuXHRcdG5ldyBNb2R1bGVBbGlhc1BsdWdpbihvcHRpb25zLnJlc29sdmUuYWxpYXMpLFxyXG5cdFx0bWFrZVJvb3RQbHVnaW4oXCJtb2R1bGVcIiwgb3B0aW9ucy5yZXNvbHZlLnJvb3QpLFxyXG5cdFx0bmV3IE1vZHVsZXNJbkRpcmVjdG9yaWVzUGx1Z2luKFwibW9kdWxlXCIsIG9wdGlvbnMucmVzb2x2ZS5tb2R1bGVzRGlyZWN0b3JpZXMpLFxyXG5cdFx0bWFrZVJvb3RQbHVnaW4oXCJtb2R1bGVcIiwgb3B0aW9ucy5yZXNvbHZlLmZhbGxiYWNrKSxcclxuXHRcdG5ldyBNb2R1bGVBc0ZpbGVQbHVnaW4oXCJtb2R1bGVcIiksXHJcblx0XHRuZXcgTW9kdWxlQXNEaXJlY3RvcnlQbHVnaW4oXCJtb2R1bGVcIiksXHJcblx0XHRuZXcgRGlyZWN0b3J5RGVzY3JpcHRpb25GaWxlUGx1Z2luKFwicGFja2FnZS5qc29uXCIsIG9wdGlvbnMucmVzb2x2ZS5wYWNrYWdlTWFpbnMpLFxyXG5cdFx0bmV3IERpcmVjdG9yeURlZmF1bHRGaWxlUGx1Z2luKFtcImluZGV4XCJdKSxcclxuXHRcdG5ldyBGaWxlQXBwZW5kUGx1Z2luKG9wdGlvbnMucmVzb2x2ZS5leHRlbnNpb25zKSxcclxuXHRcdG5ldyBSZXN1bHRTeW1saW5rUGx1Z2luKClcclxuXHQpO1xyXG5cdGNvbXBpbGVyLnJlc29sdmVycy5jb250ZXh0LmFwcGx5KFxyXG5cdFx0bmV3IFVuc2FmZUNhY2hlUGx1Z2luKG9wdGlvbnMucmVzb2x2ZS51bnNhZmVDYWNoZSksXHJcblx0XHRuZXcgTW9kdWxlQWxpYXNQbHVnaW4ob3B0aW9ucy5yZXNvbHZlLmFsaWFzKSxcclxuXHRcdG1ha2VSb290UGx1Z2luKFwibW9kdWxlXCIsIG9wdGlvbnMucmVzb2x2ZS5yb290KSxcclxuXHRcdG5ldyBNb2R1bGVzSW5EaXJlY3Rvcmllc1BsdWdpbihcIm1vZHVsZVwiLCBvcHRpb25zLnJlc29sdmUubW9kdWxlc0RpcmVjdG9yaWVzKSxcclxuXHRcdG1ha2VSb290UGx1Z2luKFwibW9kdWxlXCIsIG9wdGlvbnMucmVzb2x2ZS5mYWxsYmFjayksXHJcblx0XHRuZXcgTW9kdWxlQXNGaWxlUGx1Z2luKFwibW9kdWxlXCIpLFxyXG5cdFx0bmV3IE1vZHVsZUFzRGlyZWN0b3J5UGx1Z2luKFwibW9kdWxlXCIpLFxyXG5cdFx0bmV3IERpcmVjdG9yeVJlc3VsdFBsdWdpbigpLFxyXG5cdFx0bmV3IFJlc3VsdFN5bWxpbmtQbHVnaW4oKVxyXG5cdCk7XHJcblx0Y29tcGlsZXIucmVzb2x2ZXJzLmxvYWRlci5hcHBseShcclxuXHRcdG5ldyBVbnNhZmVDYWNoZVBsdWdpbihvcHRpb25zLnJlc29sdmUudW5zYWZlQ2FjaGUpLFxyXG5cdFx0bmV3IE1vZHVsZUFsaWFzUGx1Z2luKG9wdGlvbnMucmVzb2x2ZUxvYWRlci5hbGlhcyksXHJcblx0XHRtYWtlUm9vdFBsdWdpbihcImxvYWRlci1tb2R1bGVcIiwgb3B0aW9ucy5yZXNvbHZlTG9hZGVyLnJvb3QpLFxyXG5cdFx0bmV3IE1vZHVsZXNJbkRpcmVjdG9yaWVzUGx1Z2luKFwibG9hZGVyLW1vZHVsZVwiLCBvcHRpb25zLnJlc29sdmVMb2FkZXIubW9kdWxlc0RpcmVjdG9yaWVzKSxcclxuXHRcdG1ha2VSb290UGx1Z2luKFwibG9hZGVyLW1vZHVsZVwiLCBvcHRpb25zLnJlc29sdmVMb2FkZXIuZmFsbGJhY2spLFxyXG5cdFx0bmV3IE1vZHVsZVRlbXBsYXRlc1BsdWdpbihcImxvYWRlci1tb2R1bGVcIiwgb3B0aW9ucy5yZXNvbHZlTG9hZGVyLm1vZHVsZVRlbXBsYXRlcywgXCJtb2R1bGVcIiksXHJcblx0XHRuZXcgTW9kdWxlQXNGaWxlUGx1Z2luKFwibW9kdWxlXCIpLFxyXG5cdFx0bmV3IE1vZHVsZUFzRGlyZWN0b3J5UGx1Z2luKFwibW9kdWxlXCIpLFxyXG5cdFx0bmV3IERpcmVjdG9yeURlc2NyaXB0aW9uRmlsZVBsdWdpbihcInBhY2thZ2UuanNvblwiLCBvcHRpb25zLnJlc29sdmVMb2FkZXIucGFja2FnZU1haW5zKSxcclxuXHRcdG5ldyBEaXJlY3RvcnlEZWZhdWx0RmlsZVBsdWdpbihbXCJpbmRleFwiXSksXHJcblx0XHRuZXcgRmlsZUFwcGVuZFBsdWdpbihvcHRpb25zLnJlc29sdmVMb2FkZXIuZXh0ZW5zaW9ucyksXHJcblx0XHRuZXcgUmVzdWx0U3ltbGlua1BsdWdpbigpXHJcblx0KTtcclxuXHRjb21waWxlci5hcHBseVBsdWdpbnMoXCJhZnRlci1yZXNvbHZlcnNcIiwgY29tcGlsZXIpO1xyXG5cdHJldHVybiBvcHRpb25zO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gbWFrZVJvb3RQbHVnaW4obmFtZSwgcm9vdCkge1xyXG5cdGlmKHR5cGVvZiByb290ID09PSBcInN0cmluZ1wiKVxyXG5cdFx0cmV0dXJuIG5ldyBNb2R1bGVzSW5Sb290UGx1Z2luKG5hbWUsIHJvb3QpO1xyXG5cdGVsc2UgaWYoQXJyYXkuaXNBcnJheShyb290KSkge1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyb290LmZvckVhY2goZnVuY3Rpb24ocm9vdCkge1xyXG5cdFx0XHRcdHRoaXMuYXBwbHkobmV3IE1vZHVsZXNJblJvb3RQbHVnaW4obmFtZSwgcm9vdCkpO1xyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH07XHJcblx0fVxyXG5cdHJldHVybiBmdW5jdGlvbigpIHt9O1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvV2VicGFja09wdGlvbnNBcHBseS5qc1xuLy8gbW9kdWxlIGlkID0gODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuZnVuY3Rpb24gT3B0aW9uc0FwcGx5KCkge31cclxubW9kdWxlLmV4cG9ydHMgPSBPcHRpb25zQXBwbHk7XHJcblxyXG5PcHRpb25zQXBwbHkucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiggLyogb3B0aW9ucywgY29tcGlsZXIgKi8gKSB7XHJcblxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL09wdGlvbnNBcHBseS5qc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuZnVuY3Rpb24gTG9hZGVyVGFyZ2V0UGx1Z2luKHRhcmdldCkge1xyXG5cdHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gTG9hZGVyVGFyZ2V0UGx1Z2luO1xyXG5Mb2FkZXJUYXJnZXRQbHVnaW4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oY29tcGlsZXIpIHtcclxuXHR2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XHJcblx0Y29tcGlsZXIucGx1Z2luKFwiY29tcGlsYXRpb25cIiwgZnVuY3Rpb24oY29tcGlsYXRpb24pIHtcclxuXHRcdGNvbXBpbGF0aW9uLnBsdWdpbihcIm5vcm1hbC1tb2R1bGUtbG9hZGVyXCIsIGZ1bmN0aW9uKGxvYWRlckNvbnRleHQpIHtcclxuXHRcdFx0bG9hZGVyQ29udGV4dC50YXJnZXQgPSB0YXJnZXQ7XHJcblx0XHR9KTtcclxuXHR9KTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9Mb2FkZXJUYXJnZXRQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBGdW5jdGlvbk1vZHVsZVRlbXBsYXRlUGx1Z2luID0gcmVxdWlyZShcIi4vRnVuY3Rpb25Nb2R1bGVUZW1wbGF0ZVBsdWdpblwiKTtcclxudmFyIFJlcXVlc3RTaG9ydGVuZXIgPSByZXF1aXJlKFwiLi9SZXF1ZXN0U2hvcnRlbmVyXCIpO1xyXG5cclxuZnVuY3Rpb24gRnVuY3Rpb25Nb2R1bGVQbHVnaW4ob3B0aW9ucywgcmVxdWVzdFNob3J0ZW5lcikge1xyXG5cdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcblx0dGhpcy5yZXF1ZXN0U2hvcnRlbmVyID0gcmVxdWVzdFNob3J0ZW5lcjtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uTW9kdWxlUGx1Z2luO1xyXG5GdW5jdGlvbk1vZHVsZVBsdWdpbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbihjb21waWxlcikge1xyXG5cdGNvbXBpbGVyLnBsdWdpbihcImNvbXBpbGF0aW9uXCIsIGZ1bmN0aW9uKGNvbXBpbGF0aW9uKSB7XHJcblx0XHRjb21waWxhdGlvbi5tb2R1bGVUZW1wbGF0ZS5yZXF1ZXN0U2hvcnRlbmVyID0gdGhpcy5yZXF1ZXN0U2hvcnRlbmVyIHx8IG5ldyBSZXF1ZXN0U2hvcnRlbmVyKGNvbXBpbGVyLmNvbnRleHQpO1xyXG5cdFx0Y29tcGlsYXRpb24ubW9kdWxlVGVtcGxhdGUuYXBwbHkobmV3IEZ1bmN0aW9uTW9kdWxlVGVtcGxhdGVQbHVnaW4oKSk7XHJcblx0fS5iaW5kKHRoaXMpKTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9GdW5jdGlvbk1vZHVsZVBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIENvbmNhdFNvdXJjZSA9IHJlcXVpcmUoXCJ3ZWJwYWNrLWNvcmUvbGliL0NvbmNhdFNvdXJjZVwiKTtcclxudmFyIFByZWZpeFNvdXJjZSA9IHJlcXVpcmUoXCJ3ZWJwYWNrLWNvcmUvbGliL1ByZWZpeFNvdXJjZVwiKTtcclxuXHJcbmZ1bmN0aW9uIEZ1bmN0aW9uTW9kdWxlVGVtcGxhdGVQbHVnaW4oKSB7fVxyXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uTW9kdWxlVGVtcGxhdGVQbHVnaW47XHJcblxyXG5GdW5jdGlvbk1vZHVsZVRlbXBsYXRlUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKG1vZHVsZVRlbXBsYXRlKSB7XHJcblx0bW9kdWxlVGVtcGxhdGUucGx1Z2luKFwicmVuZGVyXCIsIGZ1bmN0aW9uKG1vZHVsZVNvdXJjZSwgbW9kdWxlKSB7XHJcblx0XHR2YXIgc291cmNlID0gbmV3IENvbmNhdFNvdXJjZSgpO1xyXG5cdFx0dmFyIGRlZmF1bHRBcmd1bWVudHMgPSBbXCJtb2R1bGVcIiwgXCJleHBvcnRzXCJdO1xyXG5cdFx0aWYoKG1vZHVsZS5hcmd1bWVudHMgJiYgbW9kdWxlLmFyZ3VtZW50cy5sZW5ndGggIT09IDApIHx8IG1vZHVsZS5oYXNEZXBlbmRlbmNpZXMoKSkge1xyXG5cdFx0XHRkZWZhdWx0QXJndW1lbnRzLnB1c2goXCJfX3dlYnBhY2tfcmVxdWlyZV9fXCIpO1xyXG5cdFx0fVxyXG5cdFx0c291cmNlLmFkZChcIi8qKiovIGZ1bmN0aW9uKFwiICsgZGVmYXVsdEFyZ3VtZW50cy5jb25jYXQobW9kdWxlLmFyZ3VtZW50cyB8fCBbXSkuam9pbihcIiwgXCIpICsgXCIpIHtcXG5cXG5cIik7XHJcblx0XHRzb3VyY2UuYWRkKG5ldyBQcmVmaXhTb3VyY2UodGhpcy5vdXRwdXRPcHRpb25zLnNvdXJjZVByZWZpeCwgbW9kdWxlU291cmNlKSk7XHJcblx0XHRzb3VyY2UuYWRkKFwiXFxuXFxuLyoqKi8gfVwiKTtcclxuXHRcdHJldHVybiBzb3VyY2U7XHJcblx0fSk7XHJcblx0bW9kdWxlVGVtcGxhdGUucGx1Z2luKFwicGFja2FnZVwiLCBmdW5jdGlvbihtb2R1bGVTb3VyY2UsIG1vZHVsZSkge1xyXG5cdFx0aWYodGhpcy5vdXRwdXRPcHRpb25zLnBhdGhpbmZvKSB7XHJcblx0XHRcdHZhciBzb3VyY2UgPSBuZXcgQ29uY2F0U291cmNlKCk7XHJcblx0XHRcdHZhciByZXEgPSBtb2R1bGUucmVhZGFibGVJZGVudGlmaWVyKHRoaXMucmVxdWVzdFNob3J0ZW5lcik7XHJcblx0XHRcdHNvdXJjZS5hZGQoXCIvKiEqKioqXCIgKyByZXEucmVwbGFjZSgvLi9nLCBcIipcIikgKyBcIioqKiohKlxcXFxcXG5cIik7XHJcblx0XHRcdHNvdXJjZS5hZGQoXCIgICEqKiogXCIgKyByZXEucmVwbGFjZSgvXFwqXFwvL2csIFwiKl8vXCIpICsgXCIgKioqIVxcblwiKTtcclxuXHRcdFx0c291cmNlLmFkZChcIiAgXFxcXCoqKipcIiArIHJlcS5yZXBsYWNlKC8uL2csIFwiKlwiKSArIFwiKioqKi9cXG5cIik7XHJcblx0XHRcdHNvdXJjZS5hZGQobW9kdWxlU291cmNlKTtcclxuXHRcdFx0cmV0dXJuIHNvdXJjZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBtb2R1bGVTb3VyY2U7XHJcblx0fSk7XHJcblx0bW9kdWxlVGVtcGxhdGUucGx1Z2luKFwiaGFzaFwiLCBmdW5jdGlvbihoYXNoKSB7XHJcblx0XHRoYXNoLnVwZGF0ZShcIkZ1bmN0aW9uTW9kdWxlVGVtcGxhdGVQbHVnaW5cIik7XHJcblx0XHRoYXNoLnVwZGF0ZShcIjJcIik7XHJcblx0fSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvRnVuY3Rpb25Nb2R1bGVUZW1wbGF0ZVBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIEV2YWxEZXZUb29sTW9kdWxlVGVtcGxhdGVQbHVnaW4gPSByZXF1aXJlKFwiLi9FdmFsRGV2VG9vbE1vZHVsZVRlbXBsYXRlUGx1Z2luXCIpO1xyXG5cclxuZnVuY3Rpb24gRXZhbERldlRvb2xNb2R1bGVQbHVnaW4oc291cmNlVXJsQ29tbWVudCwgbW9kdWxlRmlsZW5hbWVUZW1wbGF0ZSkge1xyXG5cdHRoaXMuc291cmNlVXJsQ29tbWVudCA9IHNvdXJjZVVybENvbW1lbnQ7XHJcblx0dGhpcy5tb2R1bGVGaWxlbmFtZVRlbXBsYXRlID0gbW9kdWxlRmlsZW5hbWVUZW1wbGF0ZTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IEV2YWxEZXZUb29sTW9kdWxlUGx1Z2luO1xyXG5FdmFsRGV2VG9vbE1vZHVsZVBsdWdpbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbihjb21waWxlcikge1xyXG5cdHZhciBzZWxmID0gdGhpcztcclxuXHRjb21waWxlci5wbHVnaW4oXCJjb21waWxhdGlvblwiLCBmdW5jdGlvbihjb21waWxhdGlvbikge1xyXG5cdFx0Y29tcGlsYXRpb24ubW9kdWxlVGVtcGxhdGUuYXBwbHkobmV3IEV2YWxEZXZUb29sTW9kdWxlVGVtcGxhdGVQbHVnaW4oc2VsZi5zb3VyY2VVcmxDb21tZW50LCBzZWxmLm1vZHVsZUZpbGVuYW1lVGVtcGxhdGUpKTtcclxuXHR9KTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9FdmFsRGV2VG9vbE1vZHVsZVBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIFJhd1NvdXJjZSA9IHJlcXVpcmUoXCJ3ZWJwYWNrLWNvcmUvbGliL1Jhd1NvdXJjZVwiKTtcclxudmFyIE1vZHVsZUZpbGVuYW1lSGVscGVycyA9IHJlcXVpcmUoXCIuL01vZHVsZUZpbGVuYW1lSGVscGVyc1wiKTtcclxuXHJcbmZ1bmN0aW9uIEV2YWxEZXZUb29sTW9kdWxlVGVtcGxhdGVQbHVnaW4oc291cmNlVXJsQ29tbWVudCwgbW9kdWxlRmlsZW5hbWVUZW1wbGF0ZSkge1xyXG5cdHRoaXMuc291cmNlVXJsQ29tbWVudCA9IHNvdXJjZVVybENvbW1lbnQgfHwgXCIvLyMgc291cmNlVVJMPVt1cmxdXCI7XHJcblx0dGhpcy5tb2R1bGVGaWxlbmFtZVRlbXBsYXRlID0gbW9kdWxlRmlsZW5hbWVUZW1wbGF0ZSB8fCBcIndlYnBhY2s6Ly8vW3Jlc291cmNlUGF0aF0/W2xvYWRlcnNdXCI7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBFdmFsRGV2VG9vbE1vZHVsZVRlbXBsYXRlUGx1Z2luO1xyXG5cclxuRXZhbERldlRvb2xNb2R1bGVUZW1wbGF0ZVBsdWdpbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbihtb2R1bGVUZW1wbGF0ZSkge1xyXG5cdHZhciBzZWxmID0gdGhpcztcclxuXHRtb2R1bGVUZW1wbGF0ZS5wbHVnaW4oXCJtb2R1bGVcIiwgZnVuY3Rpb24oc291cmNlLCBtb2R1bGUpIHtcclxuXHRcdHZhciBjb250ZW50ID0gc291cmNlLnNvdXJjZSgpO1xyXG5cdFx0dmFyIHN0ciA9IE1vZHVsZUZpbGVuYW1lSGVscGVycy5jcmVhdGVGaWxlbmFtZShtb2R1bGUsIHNlbGYubW9kdWxlRmlsZW5hbWVUZW1wbGF0ZSwgdGhpcy5yZXF1ZXN0U2hvcnRlbmVyKTtcclxuXHRcdHZhciBmb290ZXIgPSBbXCJcXG5cIixcclxuXHRcdFx0TW9kdWxlRmlsZW5hbWVIZWxwZXJzLmNyZWF0ZUZvb3Rlcihtb2R1bGUsIHRoaXMucmVxdWVzdFNob3J0ZW5lciksXHJcblx0XHRcdHNlbGYuc291cmNlVXJsQ29tbWVudC5yZXBsYWNlKC9cXFt1cmxcXF0vZywgZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvJTJGL2csIFwiL1wiKS5yZXBsYWNlKC8lMjAvZywgXCJfXCIpLnJlcGxhY2UoLyU1RS9nLCBcIl5cIikucmVwbGFjZSgvJTVDL2csIFwiXFxcXFwiKS5yZXBsYWNlKC9eXFwvLywgXCJcIikpXHJcblx0XHRdLmpvaW4oXCJcXG5cIik7XHJcblx0XHRyZXR1cm4gbmV3IFJhd1NvdXJjZShcImV2YWwoXCIgKyBKU09OLnN0cmluZ2lmeShjb250ZW50ICsgZm9vdGVyKSArIFwiKTtcIik7XHJcblx0fSk7XHJcblx0bW9kdWxlVGVtcGxhdGUucGx1Z2luKFwiaGFzaFwiLCBmdW5jdGlvbihoYXNoKSB7XHJcblx0XHRoYXNoLnVwZGF0ZShcIkV2YWxEZXZUb29sTW9kdWxlVGVtcGxhdGVQbHVnaW5cIik7XHJcblx0XHRoYXNoLnVwZGF0ZShcIjJcIik7XHJcblx0fSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvRXZhbERldlRvb2xNb2R1bGVUZW1wbGF0ZVBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIE1vZHVsZUZpbGVuYW1lSGVscGVycyA9IGV4cG9ydHM7XHJcblxyXG5Nb2R1bGVGaWxlbmFtZUhlbHBlcnMuQUxMX0xPQURFUlNfUkVTT1VSQ0UgPSBcIlthbGwtbG9hZGVyc11bcmVzb3VyY2VdXCI7XHJcbk1vZHVsZUZpbGVuYW1lSGVscGVycy5SRUdFWFBfQUxMX0xPQURFUlNfUkVTT1VSQ0UgPSAvXFxbYWxsLT9sb2FkZXJzXFxdXFxbcmVzb3VyY2VcXF0vZ2k7XHJcbk1vZHVsZUZpbGVuYW1lSGVscGVycy5MT0FERVJTX1JFU09VUkNFID0gXCJbbG9hZGVyc11bcmVzb3VyY2VdXCI7XHJcbk1vZHVsZUZpbGVuYW1lSGVscGVycy5SRUdFWFBfTE9BREVSU19SRVNPVVJDRSA9IC9cXFtsb2FkZXJzXFxdXFxbcmVzb3VyY2VcXF0vZ2k7XHJcbk1vZHVsZUZpbGVuYW1lSGVscGVycy5SRVNPVVJDRSA9IFwiW3Jlc291cmNlXVwiO1xyXG5Nb2R1bGVGaWxlbmFtZUhlbHBlcnMuUkVHRVhQX1JFU09VUkNFID0gL1xcW3Jlc291cmNlXFxdL2dpO1xyXG5Nb2R1bGVGaWxlbmFtZUhlbHBlcnMuQUJTT0xVVEVfUkVTT1VSQ0VfUEFUSCA9IFwiW2Fic29sdXRlLXJlc291cmNlLXBhdGhdXCI7XHJcbk1vZHVsZUZpbGVuYW1lSGVscGVycy5SRUdFWFBfQUJTT0xVVEVfUkVTT1VSQ0VfUEFUSCA9IC9cXFthYnMob2x1dGUpPy0/cmVzb3VyY2UtP3BhdGhcXF0vZ2k7XHJcbk1vZHVsZUZpbGVuYW1lSGVscGVycy5SRVNPVVJDRV9QQVRIID0gXCJbcmVzb3VyY2UtcGF0aF1cIjtcclxuTW9kdWxlRmlsZW5hbWVIZWxwZXJzLlJFR0VYUF9SRVNPVVJDRV9QQVRIID0gL1xcW3Jlc291cmNlLT9wYXRoXFxdL2dpO1xyXG5Nb2R1bGVGaWxlbmFtZUhlbHBlcnMuQUxMX0xPQURFUlMgPSBcIlthbGwtbG9hZGVyc11cIjtcclxuTW9kdWxlRmlsZW5hbWVIZWxwZXJzLlJFR0VYUF9BTExfTE9BREVSUyA9IC9cXFthbGwtP2xvYWRlcnNcXF0vZ2k7XHJcbk1vZHVsZUZpbGVuYW1lSGVscGVycy5MT0FERVJTID0gXCJbbG9hZGVyc11cIjtcclxuTW9kdWxlRmlsZW5hbWVIZWxwZXJzLlJFR0VYUF9MT0FERVJTID0gL1xcW2xvYWRlcnNcXF0vZ2k7XHJcbk1vZHVsZUZpbGVuYW1lSGVscGVycy5RVUVSWSA9IFwiW3F1ZXJ5XVwiO1xyXG5Nb2R1bGVGaWxlbmFtZUhlbHBlcnMuUkVHRVhQX1FVRVJZID0gL1xcW3F1ZXJ5XFxdL2dpO1xyXG5Nb2R1bGVGaWxlbmFtZUhlbHBlcnMuSUQgPSBcIltpZF1cIjtcclxuTW9kdWxlRmlsZW5hbWVIZWxwZXJzLlJFR0VYUF9JRCA9IC9cXFtpZFxcXS9naTtcclxuTW9kdWxlRmlsZW5hbWVIZWxwZXJzLkhBU0ggPSBcIltoYXNoXVwiO1xyXG5Nb2R1bGVGaWxlbmFtZUhlbHBlcnMuUkVHRVhQX0hBU0ggPSAvXFxbaGFzaFxcXS9naTtcclxuXHJcbmZ1bmN0aW9uIGdldEFmdGVyKHN0ciwgdG9rZW4pIHtcclxuXHR2YXIgaWR4ID0gc3RyLmluZGV4T2YodG9rZW4pO1xyXG5cdHJldHVybiBpZHggPCAwID8gXCJcIiA6IHN0ci5zdWJzdHIoaWR4KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0QmVmb3JlKHN0ciwgdG9rZW4pIHtcclxuXHR2YXIgaWR4ID0gc3RyLmxhc3RJbmRleE9mKHRva2VuKTtcclxuXHRyZXR1cm4gaWR4IDwgMCA/IFwiXCIgOiBzdHIuc3Vic3RyKDAsIGlkeCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEhhc2goc3RyKSB7XHJcblx0dmFyIGhhc2ggPSByZXF1aXJlKFwiY3J5cHRvXCIpLmNyZWF0ZUhhc2goXCJtZDVcIik7XHJcblx0aGFzaC51cGRhdGUoc3RyKTtcclxuXHRyZXR1cm4gaGFzaC5kaWdlc3QoXCJoZXhcIikuc3Vic3RyKDAsIDQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhc1JlZ0V4cCh0ZXN0KSB7XHJcblx0aWYodHlwZW9mIHRlc3QgPT09IFwic3RyaW5nXCIpIHRlc3QgPSBuZXcgUmVnRXhwKFwiXlwiICsgdGVzdC5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZywgXCJcXFxcJCZcIikpO1xyXG5cdHJldHVybiB0ZXN0O1xyXG59XHJcblxyXG5Nb2R1bGVGaWxlbmFtZUhlbHBlcnMuY3JlYXRlRmlsZW5hbWUgPSBmdW5jdGlvbiBjcmVhdGVGaWxlbmFtZShtb2R1bGUsIG1vZHVsZUZpbGVuYW1lVGVtcGxhdGUsIHJlcXVlc3RTaG9ydGVuZXIpIHtcclxuXHRpZighbW9kdWxlKSBtb2R1bGUgPSBcIlwiO1xyXG5cdGlmKHR5cGVvZiBtb2R1bGUgPT09IFwic3RyaW5nXCIpIHtcclxuXHRcdHZhciBzaG9ydElkZW50aWZpZXIgPSByZXF1ZXN0U2hvcnRlbmVyLnNob3J0ZW4obW9kdWxlKTtcclxuXHRcdHZhciBpZGVudGlmaWVyID0gc2hvcnRJZGVudGlmaWVyO1xyXG5cdFx0dmFyIG1vZHVsZUlkID0gXCJcIjtcclxuXHRcdHZhciBhYnNvbHV0ZVJlc291cmNlUGF0aCA9IG1vZHVsZS5zcGxpdChcIiFcIikucG9wKCk7XHJcblx0XHR2YXIgaGFzaCA9IGdldEhhc2goaWRlbnRpZmllcik7XHJcblx0fSBlbHNlIHtcclxuXHRcdHZhciBzaG9ydElkZW50aWZpZXIgPSBtb2R1bGUucmVhZGFibGVJZGVudGlmaWVyKHJlcXVlc3RTaG9ydGVuZXIpO1xyXG5cdFx0dmFyIGlkZW50aWZpZXIgPSByZXF1ZXN0U2hvcnRlbmVyLnNob3J0ZW4obW9kdWxlLmlkZW50aWZpZXIoKSk7XHJcblx0XHR2YXIgbW9kdWxlSWQgPSBtb2R1bGUuaWQ7XHJcblx0XHR2YXIgYWJzb2x1dGVSZXNvdXJjZVBhdGggPSBtb2R1bGUucmVzb3VyY2VQYXRoIHx8IG1vZHVsZS5pZGVudGlmaWVyKCkuc3BsaXQoXCIhXCIpLnBvcCgpO1xyXG5cdFx0dmFyIGhhc2ggPSBnZXRIYXNoKGlkZW50aWZpZXIpO1xyXG5cdH1cclxuXHR2YXIgcmVzb3VyY2UgPSBzaG9ydElkZW50aWZpZXIuc3BsaXQoXCIhXCIpLnBvcCgpO1xyXG5cdHZhciBsb2FkZXJzID0gZ2V0QmVmb3JlKHNob3J0SWRlbnRpZmllciwgXCIhXCIpO1xyXG5cdHZhciBhbGxMb2FkZXJzID0gZ2V0QmVmb3JlKGlkZW50aWZpZXIsIFwiIVwiKTtcclxuXHR2YXIgcXVlcnkgPSBnZXRBZnRlcihyZXNvdXJjZSwgXCI/XCIpO1xyXG5cdHZhciByZXNvdXJjZVBhdGggPSByZXNvdXJjZS5zdWJzdHIoMCwgcmVzb3VyY2UubGVuZ3RoIC0gcXVlcnkubGVuZ3RoKTtcclxuXHRpZih0eXBlb2YgbW9kdWxlRmlsZW5hbWVUZW1wbGF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHRyZXR1cm4gbW9kdWxlRmlsZW5hbWVUZW1wbGF0ZSh7XHJcblx0XHRcdGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXHJcblx0XHRcdHNob3J0SWRlbnRpZmllcjogc2hvcnRJZGVudGlmaWVyLFxyXG5cdFx0XHRyZXNvdXJjZTogcmVzb3VyY2UsXHJcblx0XHRcdHJlc291cmNlUGF0aDogcmVzb3VyY2VQYXRoLFxyXG5cdFx0XHRhYnNvbHV0ZVJlc291cmNlUGF0aDogYWJzb2x1dGVSZXNvdXJjZVBhdGgsXHJcblx0XHRcdGFsbExvYWRlcnM6IGFsbExvYWRlcnMsXHJcblx0XHRcdHF1ZXJ5OiBxdWVyeSxcclxuXHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxyXG5cdFx0XHRoYXNoOiBoYXNoXHJcblx0XHR9KTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZUZpbGVuYW1lVGVtcGxhdGVcclxuXHRcdC5yZXBsYWNlKE1vZHVsZUZpbGVuYW1lSGVscGVycy5SRUdFWFBfQUxMX0xPQURFUlNfUkVTT1VSQ0UsIGlkZW50aWZpZXIpXHJcblx0XHQucmVwbGFjZShNb2R1bGVGaWxlbmFtZUhlbHBlcnMuUkVHRVhQX0xPQURFUlNfUkVTT1VSQ0UsIHNob3J0SWRlbnRpZmllcilcclxuXHRcdC5yZXBsYWNlKE1vZHVsZUZpbGVuYW1lSGVscGVycy5SRUdFWFBfUkVTT1VSQ0UsIHJlc291cmNlKVxyXG5cdFx0LnJlcGxhY2UoTW9kdWxlRmlsZW5hbWVIZWxwZXJzLlJFR0VYUF9SRVNPVVJDRV9QQVRILCByZXNvdXJjZVBhdGgpXHJcblx0XHQucmVwbGFjZShNb2R1bGVGaWxlbmFtZUhlbHBlcnMuUkVHRVhQX0FCU09MVVRFX1JFU09VUkNFX1BBVEgsIGFic29sdXRlUmVzb3VyY2VQYXRoKVxyXG5cdFx0LnJlcGxhY2UoTW9kdWxlRmlsZW5hbWVIZWxwZXJzLlJFR0VYUF9BTExfTE9BREVSUywgYWxsTG9hZGVycylcclxuXHRcdC5yZXBsYWNlKE1vZHVsZUZpbGVuYW1lSGVscGVycy5SRUdFWFBfTE9BREVSUywgbG9hZGVycylcclxuXHRcdC5yZXBsYWNlKE1vZHVsZUZpbGVuYW1lSGVscGVycy5SRUdFWFBfUVVFUlksIHF1ZXJ5KVxyXG5cdFx0LnJlcGxhY2UoTW9kdWxlRmlsZW5hbWVIZWxwZXJzLlJFR0VYUF9JRCwgbW9kdWxlSWQpXHJcblx0XHQucmVwbGFjZShNb2R1bGVGaWxlbmFtZUhlbHBlcnMuUkVHRVhQX0hBU0gsIGhhc2gpO1xyXG59O1xyXG5cclxuTW9kdWxlRmlsZW5hbWVIZWxwZXJzLmNyZWF0ZUZvb3RlciA9IGZ1bmN0aW9uIGNyZWF0ZUZvb3Rlcihtb2R1bGUsIHJlcXVlc3RTaG9ydGVuZXIpIHtcclxuXHRpZighbW9kdWxlKSBtb2R1bGUgPSBcIlwiO1xyXG5cdGlmKHR5cGVvZiBtb2R1bGUgPT09IFwic3RyaW5nXCIpIHtcclxuXHRcdHJldHVybiBbXHJcblx0XHRcdFwiLy8gV0VCUEFDSyBGT09URVIgLy9cIixcclxuXHRcdFx0XCIvLyBcIiArIHJlcXVlc3RTaG9ydGVuZXIuc2hvcnRlbihtb2R1bGUpXHJcblx0XHRdLmpvaW4oXCJcXG5cIik7XHJcblx0fSBlbHNlIHtcclxuXHRcdHJldHVybiBbXHJcblx0XHRcdFwiLy8vLy8vLy8vLy8vLy8vLy8vXCIsXHJcblx0XHRcdFwiLy8gV0VCUEFDSyBGT09URVJcIixcclxuXHRcdFx0XCIvLyBcIiArIG1vZHVsZS5yZWFkYWJsZUlkZW50aWZpZXIocmVxdWVzdFNob3J0ZW5lciksXHJcblx0XHRcdFwiLy8gbW9kdWxlIGlkID0gXCIgKyBtb2R1bGUuaWQsXHJcblx0XHRcdFwiLy8gbW9kdWxlIGNodW5rcyA9IFwiICsgbW9kdWxlLmNodW5rcy5tYXAoZnVuY3Rpb24oYykge1xyXG5cdFx0XHRcdHJldHVybiBjLmlkO1xyXG5cdFx0XHR9KS5qb2luKFwiIFwiKVxyXG5cdFx0XS5qb2luKFwiXFxuXCIpO1xyXG5cdH1cclxufTtcclxuXHJcbk1vZHVsZUZpbGVuYW1lSGVscGVycy5yZXBsYWNlRHVwbGljYXRlcyA9IGZ1bmN0aW9uIHJlcGxhY2VEdXBsaWNhdGVzKGFycmF5LCBmbiwgY29tcGFyYXRvcikge1xyXG5cdHZhciBjb3VudE1hcCA9IHt9O1xyXG5cdHZhciBwb3NNYXAgPSB7fTtcclxuXHRhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0sIGlkeCkge1xyXG5cdFx0Y291bnRNYXBbaXRlbV0gPSAoY291bnRNYXBbaXRlbV0gfHwgW10pO1xyXG5cdFx0Y291bnRNYXBbaXRlbV0ucHVzaChpZHgpO1xyXG5cdFx0cG9zTWFwW2l0ZW1dID0gMDtcclxuXHR9KTtcclxuXHRpZihjb21wYXJhdG9yKSB7XHJcblx0XHRPYmplY3Qua2V5cyhjb3VudE1hcCkuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRcdGNvdW50TWFwW2l0ZW1dLnNvcnQoY29tcGFyYXRvcik7XHJcblx0XHR9KTtcclxuXHR9XHJcblx0cmV0dXJuIGFycmF5Lm1hcChmdW5jdGlvbihpdGVtLCBpKSB7XHJcblx0XHRpZihjb3VudE1hcFtpdGVtXS5sZW5ndGggPiAxKSB7XHJcblx0XHRcdGlmKGNvbXBhcmF0b3IgJiYgY291bnRNYXBbaXRlbV1bMF0gPT09IGkpXHJcblx0XHRcdFx0cmV0dXJuIGl0ZW07XHJcblx0XHRcdHJldHVybiBmbihpdGVtLCBpLCBwb3NNYXBbaXRlbV0rKyk7XHJcblx0XHR9IGVsc2UgcmV0dXJuIGl0ZW07XHJcblx0fSk7XHJcbn07XHJcblxyXG5Nb2R1bGVGaWxlbmFtZUhlbHBlcnMubWF0Y2hQYXJ0ID0gZnVuY3Rpb24gbWF0Y2hQYXJ0KHN0ciwgdGVzdCkge1xyXG5cdGlmKCF0ZXN0KSByZXR1cm4gdHJ1ZTtcclxuXHR0ZXN0ID0gYXNSZWdFeHAodGVzdCk7XHJcblx0aWYoQXJyYXkuaXNBcnJheSh0ZXN0KSkge1xyXG5cdFx0cmV0dXJuIHRlc3QubWFwKGFzUmVnRXhwKS5maWx0ZXIoZnVuY3Rpb24ocmVnRXhwKSB7XHJcblx0XHRcdHJldHVybiByZWdFeHAudGVzdChzdHIpO1xyXG5cdFx0fSkubGVuZ3RoID4gMDtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIHRlc3QudGVzdChzdHIpO1xyXG5cdH1cclxufTtcclxuXHJcbk1vZHVsZUZpbGVuYW1lSGVscGVycy5tYXRjaE9iamVjdCA9IGZ1bmN0aW9uIG1hdGNoT2JqZWN0KG9iaiwgc3RyKSB7XHJcblx0aWYob2JqLnRlc3QpXHJcblx0XHRpZighTW9kdWxlRmlsZW5hbWVIZWxwZXJzLm1hdGNoUGFydChzdHIsIG9iai50ZXN0KSkgcmV0dXJuIGZhbHNlO1xyXG5cdGlmKG9iai5pbmNsdWRlKVxyXG5cdFx0aWYoIU1vZHVsZUZpbGVuYW1lSGVscGVycy5tYXRjaFBhcnQoc3RyLCBvYmouaW5jbHVkZSkpIHJldHVybiBmYWxzZTtcclxuXHRpZihvYmouZXhjbHVkZSlcclxuXHRcdGlmKE1vZHVsZUZpbGVuYW1lSGVscGVycy5tYXRjaFBhcnQoc3RyLCBvYmouZXhjbHVkZSkpIHJldHVybiBmYWxzZTtcclxuXHRyZXR1cm4gdHJ1ZTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9Nb2R1bGVGaWxlbmFtZUhlbHBlcnMuanNcbi8vIG1vZHVsZSBpZCA9IDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbnZhciBSZXF1ZXN0U2hvcnRlbmVyID0gcmVxdWlyZShcIi4vUmVxdWVzdFNob3J0ZW5lclwiKTtcclxudmFyIENvbmNhdFNvdXJjZSA9IHJlcXVpcmUoXCJ3ZWJwYWNrLWNvcmUvbGliL0NvbmNhdFNvdXJjZVwiKTtcclxudmFyIFJhd1NvdXJjZSA9IHJlcXVpcmUoXCJ3ZWJwYWNrLWNvcmUvbGliL1Jhd1NvdXJjZVwiKTtcclxudmFyIE1vZHVsZUZpbGVuYW1lSGVscGVycyA9IHJlcXVpcmUoXCIuL01vZHVsZUZpbGVuYW1lSGVscGVyc1wiKTtcclxudmFyIFNvdXJjZU1hcERldlRvb2xNb2R1bGVPcHRpb25zUGx1Z2luID0gcmVxdWlyZShcIi4vU291cmNlTWFwRGV2VG9vbE1vZHVsZU9wdGlvbnNQbHVnaW5cIik7XHJcblxyXG5mdW5jdGlvbiBTb3VyY2VNYXBEZXZUb29sUGx1Z2luKG9wdGlvbnMsIHNvdXJjZU1hcHBpbmdVUkxDb21tZW50LCBtb2R1bGVGaWxlbmFtZVRlbXBsYXRlLCBmYWxsYmFja01vZHVsZUZpbGVuYW1lVGVtcGxhdGUpIHtcclxuXHRpZighb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gXCJvYmplY3RcIikge1xyXG5cdFx0dGhpcy5zb3VyY2VNYXBGaWxlbmFtZSA9IG9wdGlvbnM7XHJcblx0XHR0aGlzLnNvdXJjZU1hcHBpbmdVUkxDb21tZW50ID0gc291cmNlTWFwcGluZ1VSTENvbW1lbnQgPT09IGZhbHNlID8gZmFsc2UgOiBzb3VyY2VNYXBwaW5nVVJMQ29tbWVudCB8fCBcIlxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVt1cmxdXCI7XHJcblx0XHR0aGlzLm1vZHVsZUZpbGVuYW1lVGVtcGxhdGUgPSBtb2R1bGVGaWxlbmFtZVRlbXBsYXRlIHx8IFwid2VicGFjazovLy9bcmVzb3VyY2VQYXRoXVwiO1xyXG5cdFx0dGhpcy5mYWxsYmFja01vZHVsZUZpbGVuYW1lVGVtcGxhdGUgPSBmYWxsYmFja01vZHVsZUZpbGVuYW1lVGVtcGxhdGUgfHwgXCJ3ZWJwYWNrOi8vL1tyZXNvdXJjZVBhdGhdP1toYXNoXVwiO1xyXG5cdFx0dGhpcy5vcHRpb25zID0ge307XHJcblx0fSBlbHNlIHtcclxuXHRcdHRoaXMuc291cmNlTWFwRmlsZW5hbWUgPSBvcHRpb25zLmZpbGVuYW1lO1xyXG5cdFx0dGhpcy5zb3VyY2VNYXBwaW5nVVJMQ29tbWVudCA9IG9wdGlvbnMuYXBwZW5kID09PSBmYWxzZSA/IGZhbHNlIDogb3B0aW9ucy5hcHBlbmQgfHwgXCJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1bdXJsXVwiO1xyXG5cdFx0dGhpcy5tb2R1bGVGaWxlbmFtZVRlbXBsYXRlID0gb3B0aW9ucy5tb2R1bGVGaWxlbmFtZVRlbXBsYXRlIHx8IFwid2VicGFjazovLy9bcmVzb3VyY2VQYXRoXVwiO1xyXG5cdFx0dGhpcy5mYWxsYmFja01vZHVsZUZpbGVuYW1lVGVtcGxhdGUgPSBvcHRpb25zLmZhbGxiYWNrTW9kdWxlRmlsZW5hbWVUZW1wbGF0ZSB8fCBcIndlYnBhY2s6Ly8vW3Jlc291cmNlUGF0aF0/W2hhc2hdXCI7XHJcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG5cdH1cclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IFNvdXJjZU1hcERldlRvb2xQbHVnaW47XHJcblNvdXJjZU1hcERldlRvb2xQbHVnaW4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oY29tcGlsZXIpIHtcclxuXHR2YXIgc291cmNlTWFwRmlsZW5hbWUgPSB0aGlzLnNvdXJjZU1hcEZpbGVuYW1lO1xyXG5cdHZhciBzb3VyY2VNYXBwaW5nVVJMQ29tbWVudCA9IHRoaXMuc291cmNlTWFwcGluZ1VSTENvbW1lbnQ7XHJcblx0dmFyIG1vZHVsZUZpbGVuYW1lVGVtcGxhdGUgPSB0aGlzLm1vZHVsZUZpbGVuYW1lVGVtcGxhdGU7XHJcblx0dmFyIGZhbGxiYWNrTW9kdWxlRmlsZW5hbWVUZW1wbGF0ZSA9IHRoaXMuZmFsbGJhY2tNb2R1bGVGaWxlbmFtZVRlbXBsYXRlO1xyXG5cdHZhciByZXF1ZXN0U2hvcnRlbmVyID0gbmV3IFJlcXVlc3RTaG9ydGVuZXIoY29tcGlsZXIuY29udGV4dCk7XHJcblx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblx0b3B0aW9ucy50ZXN0ID0gb3B0aW9ucy50ZXN0IHx8IC9cXC4oanN8Y3NzKSgkfFxcPykvaTtcclxuXHRjb21waWxlci5wbHVnaW4oXCJjb21waWxhdGlvblwiLCBmdW5jdGlvbihjb21waWxhdGlvbikge1xyXG5cdFx0bmV3IFNvdXJjZU1hcERldlRvb2xNb2R1bGVPcHRpb25zUGx1Z2luKG9wdGlvbnMpLmFwcGx5KGNvbXBpbGF0aW9uKTtcclxuXHRcdGNvbXBpbGF0aW9uLnBsdWdpbihcImFmdGVyLW9wdGltaXplLWNodW5rLWFzc2V0c1wiLCBmdW5jdGlvbihjaHVua3MpIHtcclxuXHRcdFx0dmFyIGFsbE1vZHVsZXMgPSBbXTtcclxuXHRcdFx0dmFyIGFsbE1vZHVsZUZpbGVuYW1lcyA9IFtdO1xyXG5cdFx0XHR2YXIgdGFza3MgPSBbXTtcclxuXHRcdFx0Y2h1bmtzLmZvckVhY2goZnVuY3Rpb24oY2h1bmspIHtcclxuXHRcdFx0XHRjaHVuay5maWxlcy5maWx0ZXIoTW9kdWxlRmlsZW5hbWVIZWxwZXJzLm1hdGNoT2JqZWN0LmJpbmQodW5kZWZpbmVkLCBvcHRpb25zKSkubWFwKGZ1bmN0aW9uKGZpbGUpIHtcclxuXHRcdFx0XHRcdHZhciBhc3NldCA9IHRoaXMuYXNzZXRzW2ZpbGVdO1xyXG5cdFx0XHRcdFx0aWYoYXNzZXQuX19Tb3VyY2VNYXBEZXZUb29sRGF0YSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgZGF0YSA9IGFzc2V0Ll9fU291cmNlTWFwRGV2VG9vbERhdGE7XHJcblx0XHRcdFx0XHRcdGZvcih2YXIgY2FjaGVkRmlsZSBpbiBkYXRhKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5hc3NldHNbY2FjaGVkRmlsZV0gPSBkYXRhW2NhY2hlZEZpbGVdO1xyXG5cdFx0XHRcdFx0XHRcdGlmKGNhY2hlZEZpbGUgIT09IGZpbGUpXHJcblx0XHRcdFx0XHRcdFx0XHRjaHVuay5maWxlcy5wdXNoKGNhY2hlZEZpbGUpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKGFzc2V0LnNvdXJjZUFuZE1hcCkge1xyXG5cdFx0XHRcdFx0XHR2YXIgc291cmNlQW5kTWFwID0gYXNzZXQuc291cmNlQW5kTWFwKG9wdGlvbnMpO1xyXG5cdFx0XHRcdFx0XHR2YXIgc291cmNlTWFwID0gc291cmNlQW5kTWFwLm1hcDtcclxuXHRcdFx0XHRcdFx0dmFyIHNvdXJjZSA9IHNvdXJjZUFuZE1hcC5zb3VyY2U7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR2YXIgc291cmNlTWFwID0gYXNzZXQubWFwKG9wdGlvbnMpO1xyXG5cdFx0XHRcdFx0XHR2YXIgc291cmNlID0gYXNzZXQuc291cmNlKCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZihzb3VyY2VNYXApIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdFx0XHRjaHVuazogY2h1bmssXHJcblx0XHRcdFx0XHRcdFx0ZmlsZTogZmlsZSxcclxuXHRcdFx0XHRcdFx0XHRhc3NldDogYXNzZXQsXHJcblx0XHRcdFx0XHRcdFx0c291cmNlOiBzb3VyY2UsXHJcblx0XHRcdFx0XHRcdFx0c291cmNlTWFwOiBzb3VyY2VNYXBcclxuXHRcdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9LCB0aGlzKS5maWx0ZXIoQm9vbGVhbikubWFwKGZ1bmN0aW9uKHRhc2spIHtcclxuXHRcdFx0XHRcdHZhciBtb2R1bGVzID0gdGFzay5zb3VyY2VNYXAuc291cmNlcy5tYXAoZnVuY3Rpb24oc291cmNlKSB7XHJcblx0XHRcdFx0XHRcdHZhciBtb2R1bGUgPSBjb21waWxhdGlvbi5maW5kTW9kdWxlKHNvdXJjZSk7XHJcblx0XHRcdFx0XHRcdHJldHVybiBtb2R1bGUgfHwgc291cmNlO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR2YXIgbW9kdWxlRmlsZW5hbWVzID0gbW9kdWxlcy5tYXAoZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBNb2R1bGVGaWxlbmFtZUhlbHBlcnMuY3JlYXRlRmlsZW5hbWUobW9kdWxlLCBtb2R1bGVGaWxlbmFtZVRlbXBsYXRlLCByZXF1ZXN0U2hvcnRlbmVyKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0dGFzay5tb2R1bGVzID0gbW9kdWxlcztcclxuXHRcdFx0XHRcdHRhc2subW9kdWxlRmlsZW5hbWVzID0gbW9kdWxlRmlsZW5hbWVzO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRhc2s7XHJcblx0XHRcdFx0fSwgdGhpcykuZm9yRWFjaChmdW5jdGlvbih0YXNrKSB7XHJcblx0XHRcdFx0XHRhbGxNb2R1bGVzID0gYWxsTW9kdWxlcy5jb25jYXQodGFzay5tb2R1bGVzKTtcclxuXHRcdFx0XHRcdGFsbE1vZHVsZUZpbGVuYW1lcyA9IGFsbE1vZHVsZUZpbGVuYW1lcy5jb25jYXQodGFzay5tb2R1bGVGaWxlbmFtZXMpO1xyXG5cdFx0XHRcdFx0dGFza3MucHVzaCh0YXNrKTtcclxuXHRcdFx0XHR9LCB0aGlzKTtcclxuXHRcdFx0fSwgdGhpcyk7XHJcblx0XHRcdGFsbE1vZHVsZUZpbGVuYW1lcyA9IE1vZHVsZUZpbGVuYW1lSGVscGVycy5yZXBsYWNlRHVwbGljYXRlcyhhbGxNb2R1bGVGaWxlbmFtZXMsIGZ1bmN0aW9uKGZpbGVuYW1lLCBpKSB7XHJcblx0XHRcdFx0cmV0dXJuIE1vZHVsZUZpbGVuYW1lSGVscGVycy5jcmVhdGVGaWxlbmFtZShhbGxNb2R1bGVzW2ldLCBmYWxsYmFja01vZHVsZUZpbGVuYW1lVGVtcGxhdGUsIHJlcXVlc3RTaG9ydGVuZXIpO1xyXG5cdFx0XHR9LCBmdW5jdGlvbihhaSwgYmkpIHtcclxuXHRcdFx0XHR2YXIgYSA9IGFsbE1vZHVsZXNbYWldO1xyXG5cdFx0XHRcdHZhciBiID0gYWxsTW9kdWxlc1tiaV07XHJcblx0XHRcdFx0YSA9ICFhID8gXCJcIiA6IHR5cGVvZiBhID09PSBcInN0cmluZ1wiID8gYSA6IGEuaWRlbnRpZmllcigpO1xyXG5cdFx0XHRcdGIgPSAhYiA/IFwiXCIgOiB0eXBlb2YgYiA9PT0gXCJzdHJpbmdcIiA/IGIgOiBiLmlkZW50aWZpZXIoKTtcclxuXHRcdFx0XHRyZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGFsbE1vZHVsZUZpbGVuYW1lcyA9IE1vZHVsZUZpbGVuYW1lSGVscGVycy5yZXBsYWNlRHVwbGljYXRlcyhhbGxNb2R1bGVGaWxlbmFtZXMsIGZ1bmN0aW9uKGZpbGVuYW1lLCBpLCBuKSB7XHJcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IG47IGorKylcclxuXHRcdFx0XHRcdGZpbGVuYW1lICs9IFwiKlwiO1xyXG5cdFx0XHRcdHJldHVybiBmaWxlbmFtZTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdHRhc2tzLmZvckVhY2goZnVuY3Rpb24odGFzaykge1xyXG5cdFx0XHRcdHRhc2subW9kdWxlRmlsZW5hbWVzID0gYWxsTW9kdWxlRmlsZW5hbWVzLnNsaWNlKDAsIHRhc2subW9kdWxlRmlsZW5hbWVzLmxlbmd0aCk7XHJcblx0XHRcdFx0YWxsTW9kdWxlRmlsZW5hbWVzID0gYWxsTW9kdWxlRmlsZW5hbWVzLnNsaWNlKHRhc2subW9kdWxlRmlsZW5hbWVzLmxlbmd0aCk7XHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0XHR0YXNrcy5mb3JFYWNoKGZ1bmN0aW9uKHRhc2spIHtcclxuXHRcdFx0XHR2YXIgY2h1bmsgPSB0YXNrLmNodW5rO1xyXG5cdFx0XHRcdHZhciBmaWxlID0gdGFzay5maWxlO1xyXG5cdFx0XHRcdHZhciBhc3NldCA9IHRhc2suYXNzZXQ7XHJcblx0XHRcdFx0dmFyIHNvdXJjZU1hcCA9IHRhc2suc291cmNlTWFwO1xyXG5cdFx0XHRcdHZhciBzb3VyY2UgPSB0YXNrLnNvdXJjZTtcclxuXHRcdFx0XHR2YXIgbW9kdWxlRmlsZW5hbWVzID0gdGFzay5tb2R1bGVGaWxlbmFtZXM7XHJcblx0XHRcdFx0dmFyIG1vZHVsZXMgPSB0YXNrLm1vZHVsZXM7XHJcblx0XHRcdFx0c291cmNlTWFwLnNvdXJjZXMgPSBtb2R1bGVGaWxlbmFtZXM7XHJcblx0XHRcdFx0aWYoc291cmNlTWFwLnNvdXJjZXNDb250ZW50ICYmICFvcHRpb25zLm5vU291cmNlcykge1xyXG5cdFx0XHRcdFx0c291cmNlTWFwLnNvdXJjZXNDb250ZW50ID0gc291cmNlTWFwLnNvdXJjZXNDb250ZW50Lm1hcChmdW5jdGlvbihjb250ZW50LCBpKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBjb250ZW50ICsgXCJcXG5cXG5cXG5cIiArIE1vZHVsZUZpbGVuYW1lSGVscGVycy5jcmVhdGVGb290ZXIobW9kdWxlc1tpXSwgcmVxdWVzdFNob3J0ZW5lcik7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0c291cmNlTWFwLnNvdXJjZXNDb250ZW50ID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRzb3VyY2VNYXAuc291cmNlUm9vdCA9IFwiXCI7XHJcblx0XHRcdFx0c291cmNlTWFwLmZpbGUgPSBmaWxlO1xyXG5cdFx0XHRcdGFzc2V0Ll9fU291cmNlTWFwRGV2VG9vbERhdGEgPSB7fTtcclxuXHRcdFx0XHR2YXIgY3VycmVudFNvdXJjZU1hcHBpbmdVUkxDb21tZW50ID0gc291cmNlTWFwcGluZ1VSTENvbW1lbnQ7XHJcblx0XHRcdFx0aWYoY3VycmVudFNvdXJjZU1hcHBpbmdVUkxDb21tZW50ICE9PSBmYWxzZSAmJiAvXFwuY3NzKCR8XFw/KS9pLnRlc3QoZmlsZSkpIHtcclxuXHRcdFx0XHRcdGN1cnJlbnRTb3VyY2VNYXBwaW5nVVJMQ29tbWVudCA9IGN1cnJlbnRTb3VyY2VNYXBwaW5nVVJMQ29tbWVudC5yZXBsYWNlKC9eXFxuXFwvXFwvKC4qKSQvLCBcIlxcbi8qJDEqL1wiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoc291cmNlTWFwRmlsZW5hbWUpIHtcclxuXHRcdFx0XHRcdHZhciBmaWxlbmFtZSA9IGZpbGUsXHJcblx0XHRcdFx0XHRcdHF1ZXJ5ID0gXCJcIjtcclxuXHRcdFx0XHRcdHZhciBpZHggPSBmaWxlbmFtZS5pbmRleE9mKFwiP1wiKTtcclxuXHRcdFx0XHRcdGlmKGlkeCA+PSAwKSB7XHJcblx0XHRcdFx0XHRcdHF1ZXJ5ID0gZmlsZW5hbWUuc3Vic3RyKGlkeCk7XHJcblx0XHRcdFx0XHRcdGZpbGVuYW1lID0gZmlsZW5hbWUuc3Vic3RyKDAsIGlkeCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR2YXIgc291cmNlTWFwRmlsZSA9IHRoaXMuZ2V0UGF0aChzb3VyY2VNYXBGaWxlbmFtZSwge1xyXG5cdFx0XHRcdFx0XHRjaHVuazogY2h1bmssXHJcblx0XHRcdFx0XHRcdGZpbGVuYW1lOiBmaWxlbmFtZSxcclxuXHRcdFx0XHRcdFx0cXVlcnk6IHF1ZXJ5LFxyXG5cdFx0XHRcdFx0XHRiYXNlbmFtZTogYmFzZW5hbWUoZmlsZW5hbWUpXHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdHZhciBzb3VyY2VNYXBVcmwgPSBwYXRoLnJlbGF0aXZlKHBhdGguZGlybmFtZShmaWxlKSwgc291cmNlTWFwRmlsZSkucmVwbGFjZSgvXFxcXC9nLCBcIi9cIik7XHJcblx0XHRcdFx0XHRpZihjdXJyZW50U291cmNlTWFwcGluZ1VSTENvbW1lbnQgIT09IGZhbHNlKSB7XHJcblx0XHRcdFx0XHRcdGFzc2V0Ll9fU291cmNlTWFwRGV2VG9vbERhdGFbZmlsZV0gPSB0aGlzLmFzc2V0c1tmaWxlXSA9IG5ldyBDb25jYXRTb3VyY2UobmV3IFJhd1NvdXJjZShzb3VyY2UpLCBjdXJyZW50U291cmNlTWFwcGluZ1VSTENvbW1lbnQucmVwbGFjZSgvXFxbdXJsXFxdL2csIHNvdXJjZU1hcFVybCkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0YXNzZXQuX19Tb3VyY2VNYXBEZXZUb29sRGF0YVtzb3VyY2VNYXBGaWxlXSA9IHRoaXMuYXNzZXRzW3NvdXJjZU1hcEZpbGVdID0gbmV3IFJhd1NvdXJjZShKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKTtcclxuXHRcdFx0XHRcdGNodW5rLmZpbGVzLnB1c2goc291cmNlTWFwRmlsZSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGFzc2V0Ll9fU291cmNlTWFwRGV2VG9vbERhdGFbZmlsZV0gPSB0aGlzLmFzc2V0c1tmaWxlXSA9IG5ldyBDb25jYXRTb3VyY2UobmV3IFJhd1NvdXJjZShzb3VyY2UpLCBjdXJyZW50U291cmNlTWFwcGluZ1VSTENvbW1lbnRcclxuXHRcdFx0XHRcdFx0LnJlcGxhY2UoL1xcW21hcFxcXS9nLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKTtcclxuXHRcdFx0XHRcdFx0fSlcclxuXHRcdFx0XHRcdFx0LnJlcGxhY2UoL1xcW3VybFxcXS9nLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gXCJkYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIgK1xyXG5cdFx0XHRcdFx0XHRcdFx0bmV3IEJ1ZmZlcihKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKS50b1N0cmluZyhcImJhc2U2NFwiKTtcclxuXHRcdFx0XHRcdFx0fSlcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gYmFzZW5hbWUobmFtZSkge1xyXG5cdGlmKG5hbWUuaW5kZXhPZihcIi9cIikgPCAwKSByZXR1cm4gbmFtZTtcclxuXHRyZXR1cm4gbmFtZS5zdWJzdHIobmFtZS5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL1NvdXJjZU1hcERldlRvb2xQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBNb2R1bGVGaWxlbmFtZUhlbHBlcnMgPSByZXF1aXJlKFwiLi9Nb2R1bGVGaWxlbmFtZUhlbHBlcnNcIik7XHJcblxyXG5mdW5jdGlvbiBTb3VyY2VNYXBEZXZUb29sTW9kdWxlT3B0aW9uc1BsdWdpbihvcHRpb25zKSB7XHJcblx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBTb3VyY2VNYXBEZXZUb29sTW9kdWxlT3B0aW9uc1BsdWdpbjtcclxuXHJcblNvdXJjZU1hcERldlRvb2xNb2R1bGVPcHRpb25zUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGNvbXBpbGF0aW9uKSB7XHJcblx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblx0aWYob3B0aW9ucy5tb2R1bGUgIT09IGZhbHNlKSB7XHJcblx0XHRjb21waWxhdGlvbi5wbHVnaW4oXCJidWlsZC1tb2R1bGVcIiwgZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0XHRcdG1vZHVsZS51c2VTb3VyY2VNYXAgPSB0cnVlO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cdGlmKG9wdGlvbnMubGluZVRvTGluZSA9PT0gdHJ1ZSkge1xyXG5cdFx0Y29tcGlsYXRpb24ucGx1Z2luKFwiYnVpbGQtbW9kdWxlXCIsIGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdFx0XHRtb2R1bGUubGluZVRvTGluZSA9IHRydWU7XHJcblx0XHR9KTtcclxuXHR9IGVsc2UgaWYob3B0aW9ucy5saW5lVG9MaW5lKSB7XHJcblx0XHRjb21waWxhdGlvbi5wbHVnaW4oXCJidWlsZC1tb2R1bGVcIiwgZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0XHRcdGlmKCFtb2R1bGUucmVzb3VyY2UpIHJldHVybjtcclxuXHRcdFx0dmFyIHJlc291cmNlUGF0aCA9IG1vZHVsZS5yZXNvdXJjZTtcclxuXHRcdFx0dmFyIGlkeCA9IHJlc291cmNlUGF0aC5pbmRleE9mKFwiP1wiKTtcclxuXHRcdFx0aWYoaWR4ID49IDApIHJlc291cmNlUGF0aCA9IHJlc291cmNlUGF0aC5zdWJzdHIoMCwgaWR4KTtcclxuXHRcdFx0bW9kdWxlLmxpbmVUb0xpbmUgPSBNb2R1bGVGaWxlbmFtZUhlbHBlcnMubWF0Y2hPYmplY3Qob3B0aW9ucy5saW5lVG9MaW5lLCByZXNvdXJjZVBhdGgpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL1NvdXJjZU1hcERldlRvb2xNb2R1bGVPcHRpb25zUGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgRXZhbFNvdXJjZU1hcERldlRvb2xNb2R1bGVUZW1wbGF0ZVBsdWdpbiA9IHJlcXVpcmUoXCIuL0V2YWxTb3VyY2VNYXBEZXZUb29sTW9kdWxlVGVtcGxhdGVQbHVnaW5cIik7XHJcbnZhciBTb3VyY2VNYXBEZXZUb29sTW9kdWxlT3B0aW9uc1BsdWdpbiA9IHJlcXVpcmUoXCIuL1NvdXJjZU1hcERldlRvb2xNb2R1bGVPcHRpb25zUGx1Z2luXCIpO1xyXG5cclxuZnVuY3Rpb24gRXZhbFNvdXJjZU1hcERldlRvb2xQbHVnaW4ob3B0aW9ucywgbW9kdWxlRmlsZW5hbWVUZW1wbGF0ZSkge1xyXG5cdGlmKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSBcIm9iamVjdFwiKSB7XHJcblx0XHR0aGlzLm9wdGlvbnMgPSB7XHJcblx0XHRcdGFwcGVuZDogb3B0aW9ucyxcclxuXHRcdFx0bW9kdWxlRmlsZW5hbWVUZW1wbGF0ZTogbW9kdWxlRmlsZW5hbWVUZW1wbGF0ZVxyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuXHR9XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBFdmFsU291cmNlTWFwRGV2VG9vbFBsdWdpbjtcclxuRXZhbFNvdXJjZU1hcERldlRvb2xQbHVnaW4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oY29tcGlsZXIpIHtcclxuXHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHRjb21waWxlci5wbHVnaW4oXCJjb21waWxhdGlvblwiLCBmdW5jdGlvbihjb21waWxhdGlvbikge1xyXG5cdFx0bmV3IFNvdXJjZU1hcERldlRvb2xNb2R1bGVPcHRpb25zUGx1Z2luKG9wdGlvbnMpLmFwcGx5KGNvbXBpbGF0aW9uKTtcclxuXHRcdGNvbXBpbGF0aW9uLm1vZHVsZVRlbXBsYXRlLmFwcGx5KG5ldyBFdmFsU291cmNlTWFwRGV2VG9vbE1vZHVsZVRlbXBsYXRlUGx1Z2luKGNvbXBpbGF0aW9uLCBvcHRpb25zLCBvcHRpb25zLmFwcGVuZCwgb3B0aW9ucy5tb2R1bGVGaWxlbmFtZVRlbXBsYXRlKSk7XHJcblx0fSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvRXZhbFNvdXJjZU1hcERldlRvb2xQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBSYXdTb3VyY2UgPSByZXF1aXJlKFwid2VicGFjay1jb3JlL2xpYi9SYXdTb3VyY2VcIik7XHJcbnZhciBNb2R1bGVGaWxlbmFtZUhlbHBlcnMgPSByZXF1aXJlKFwiLi9Nb2R1bGVGaWxlbmFtZUhlbHBlcnNcIik7XHJcblxyXG5mdW5jdGlvbiBFdmFsU291cmNlTWFwRGV2VG9vbE1vZHVsZVRlbXBsYXRlUGx1Z2luKGNvbXBpbGF0aW9uLCBvcHRpb25zLCBzb3VyY2VNYXBDb21tZW50LCBtb2R1bGVGaWxlbmFtZVRlbXBsYXRlKSB7XHJcblx0dGhpcy5jb21waWxhdGlvbiA9IGNvbXBpbGF0aW9uO1xyXG5cdHRoaXMuc291cmNlTWFwQ29tbWVudCA9IHNvdXJjZU1hcENvbW1lbnQgfHwgXCIvLyMgc291cmNlTWFwcGluZ1VSTD1bdXJsXVwiO1xyXG5cdHRoaXMubW9kdWxlRmlsZW5hbWVUZW1wbGF0ZSA9IG1vZHVsZUZpbGVuYW1lVGVtcGxhdGUgfHwgXCJ3ZWJwYWNrOi8vL1tyZXNvdXJjZS1wYXRoXT9baGFzaF1cIjtcclxuXHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gRXZhbFNvdXJjZU1hcERldlRvb2xNb2R1bGVUZW1wbGF0ZVBsdWdpbjtcclxuXHJcbkV2YWxTb3VyY2VNYXBEZXZUb29sTW9kdWxlVGVtcGxhdGVQbHVnaW4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24obW9kdWxlVGVtcGxhdGUpIHtcclxuXHR2YXIgc2VsZiA9IHRoaXM7XHJcblx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblx0bW9kdWxlVGVtcGxhdGUucGx1Z2luKFwibW9kdWxlXCIsIGZ1bmN0aW9uKHNvdXJjZSwgbW9kdWxlKSB7XHJcblx0XHRpZihzb3VyY2UuX19FdmFsU291cmNlTWFwRGV2VG9vbERhdGEpXHJcblx0XHRcdHJldHVybiBzb3VyY2UuX19FdmFsU291cmNlTWFwRGV2VG9vbERhdGE7XHJcblxyXG5cdFx0aWYoc291cmNlLnNvdXJjZUFuZE1hcCkge1xyXG5cdFx0XHR2YXIgc291cmNlQW5kTWFwID0gc291cmNlLnNvdXJjZUFuZE1hcChvcHRpb25zKTtcclxuXHRcdFx0dmFyIHNvdXJjZU1hcCA9IHNvdXJjZUFuZE1hcC5tYXA7XHJcblx0XHRcdHZhciBjb250ZW50ID0gc291cmNlQW5kTWFwLnNvdXJjZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciBzb3VyY2VNYXAgPSBzb3VyY2UubWFwKG9wdGlvbnMpO1xyXG5cdFx0XHR2YXIgY29udGVudCA9IHNvdXJjZS5zb3VyY2UoKTtcclxuXHRcdH1cclxuXHRcdGlmKCFzb3VyY2VNYXApIHtcclxuXHRcdFx0cmV0dXJuIHNvdXJjZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBDbG9uZSAoZmxhdCkgdGhlIHNvdXJjZW1hcCB0byBlbnN1cmUgdGhhdCB0aGUgbXV0YXRpb25zIGJlbG93IGRvIG5vdCBwZXJzaXN0LlxyXG5cdFx0c291cmNlTWFwID0gT2JqZWN0LmtleXMoc291cmNlTWFwKS5yZWR1Y2UoZnVuY3Rpb24ob2JqLCBrZXkpIHtcclxuXHRcdFx0b2JqW2tleV0gPSBzb3VyY2VNYXBba2V5XTtcclxuXHRcdFx0cmV0dXJuIG9iajtcclxuXHRcdH0sIHt9KTtcclxuXHRcdHZhciBtb2R1bGVzID0gc291cmNlTWFwLnNvdXJjZXMubWFwKGZ1bmN0aW9uKHNvdXJjZSkge1xyXG5cdFx0XHR2YXIgbW9kdWxlID0gc2VsZi5jb21waWxhdGlvbi5maW5kTW9kdWxlKHNvdXJjZSk7XHJcblx0XHRcdHJldHVybiBtb2R1bGUgfHwgc291cmNlO1xyXG5cdFx0fSk7XHJcblx0XHR2YXIgbW9kdWxlRmlsZW5hbWVzID0gbW9kdWxlcy5tYXAoZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0XHRcdHJldHVybiBNb2R1bGVGaWxlbmFtZUhlbHBlcnMuY3JlYXRlRmlsZW5hbWUobW9kdWxlLCBzZWxmLm1vZHVsZUZpbGVuYW1lVGVtcGxhdGUsIHRoaXMucmVxdWVzdFNob3J0ZW5lcik7XHJcblx0XHR9LCB0aGlzKTtcclxuXHRcdG1vZHVsZUZpbGVuYW1lcyA9IE1vZHVsZUZpbGVuYW1lSGVscGVycy5yZXBsYWNlRHVwbGljYXRlcyhtb2R1bGVGaWxlbmFtZXMsIGZ1bmN0aW9uKGZpbGVuYW1lLCBpLCBuKSB7XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBuOyBqKyspXHJcblx0XHRcdFx0ZmlsZW5hbWUgKz0gXCIqXCI7XHJcblx0XHRcdHJldHVybiBmaWxlbmFtZTtcclxuXHRcdH0pO1xyXG5cdFx0c291cmNlTWFwLnNvdXJjZXMgPSBtb2R1bGVGaWxlbmFtZXM7XHJcblx0XHRpZihzb3VyY2VNYXAuc291cmNlc0NvbnRlbnQpIHtcclxuXHRcdFx0c291cmNlTWFwLnNvdXJjZXNDb250ZW50ID0gc291cmNlTWFwLnNvdXJjZXNDb250ZW50Lm1hcChmdW5jdGlvbihjb250ZW50LCBpKSB7XHJcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQgKyBcIlxcblxcblxcblwiICsgTW9kdWxlRmlsZW5hbWVIZWxwZXJzLmNyZWF0ZUZvb3Rlcihtb2R1bGVzW2ldLCB0aGlzLnJlcXVlc3RTaG9ydGVuZXIpO1xyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH1cclxuXHRcdHNvdXJjZU1hcC5zb3VyY2VSb290ID0gXCJcIjtcclxuXHRcdHNvdXJjZU1hcC5maWxlID0gbW9kdWxlLmlkICsgXCIuanNcIjtcclxuXHRcdHZhciBmb290ZXIgPSBzZWxmLnNvdXJjZU1hcENvbW1lbnQucmVwbGFjZSgvXFxbdXJsXFxdL2csIFwiZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiICsgbmV3IEJ1ZmZlcihKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKS50b1N0cmluZyhcImJhc2U2NFwiKSk7XHJcblx0XHRzb3VyY2UuX19FdmFsU291cmNlTWFwRGV2VG9vbERhdGEgPSBuZXcgUmF3U291cmNlKFwiZXZhbChcIiArIEpTT04uc3RyaW5naWZ5KGNvbnRlbnQgKyBmb290ZXIpICsgXCIpO1wiKTtcclxuXHRcdHJldHVybiBzb3VyY2UuX19FdmFsU291cmNlTWFwRGV2VG9vbERhdGE7XHJcblx0fSk7XHJcblx0bW9kdWxlVGVtcGxhdGUucGx1Z2luKFwiaGFzaFwiLCBmdW5jdGlvbihoYXNoKSB7XHJcblx0XHRoYXNoLnVwZGF0ZShcImV2YWwtc291cmNlLW1hcFwiKTtcclxuXHRcdGhhc2gudXBkYXRlKFwiMVwiKTtcclxuXHR9KTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9FdmFsU291cmNlTWFwRGV2VG9vbE1vZHVsZVRlbXBsYXRlUGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgU2luZ2xlRW50cnlQbHVnaW4gPSByZXF1aXJlKFwiLi9TaW5nbGVFbnRyeVBsdWdpblwiKTtcclxudmFyIE11bHRpRW50cnlQbHVnaW4gPSByZXF1aXJlKFwiLi9NdWx0aUVudHJ5UGx1Z2luXCIpO1xyXG5cclxuZnVuY3Rpb24gRW50cnlPcHRpb25QbHVnaW4oKSB7fVxyXG5tb2R1bGUuZXhwb3J0cyA9IEVudHJ5T3B0aW9uUGx1Z2luO1xyXG5cclxuRW50cnlPcHRpb25QbHVnaW4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oY29tcGlsZXIpIHtcclxuXHRjb21waWxlci5wbHVnaW4oXCJlbnRyeS1vcHRpb25cIiwgZnVuY3Rpb24oY29udGV4dCwgZW50cnkpIHtcclxuXHRcdGZ1bmN0aW9uIGl0ZW1Ub1BsdWdpbihpdGVtLCBuYW1lKSB7XHJcblx0XHRcdGlmKEFycmF5LmlzQXJyYXkoaXRlbSkpXHJcblx0XHRcdFx0cmV0dXJuIG5ldyBNdWx0aUVudHJ5UGx1Z2luKGNvbnRleHQsIGl0ZW0sIG5hbWUpO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0cmV0dXJuIG5ldyBTaW5nbGVFbnRyeVBsdWdpbihjb250ZXh0LCBpdGVtLCBuYW1lKTtcclxuXHRcdH1cclxuXHRcdGlmKHR5cGVvZiBlbnRyeSA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KGVudHJ5KSkge1xyXG5cdFx0XHRjb21waWxlci5hcHBseShpdGVtVG9QbHVnaW4oZW50cnksIFwibWFpblwiKSk7XHJcblx0XHR9IGVsc2UgaWYodHlwZW9mIGVudHJ5ID09PSBcIm9iamVjdFwiKSB7XHJcblx0XHRcdE9iamVjdC5rZXlzKGVudHJ5KS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcclxuXHRcdFx0XHRjb21waWxlci5hcHBseShpdGVtVG9QbHVnaW4oZW50cnlbbmFtZV0sIG5hbWUpKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9KTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9FbnRyeU9wdGlvblBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIFNpbmdsZUVudHJ5RGVwZW5kZW5jeSA9IHJlcXVpcmUoXCIuL2RlcGVuZGVuY2llcy9TaW5nbGVFbnRyeURlcGVuZGVuY3lcIik7XHJcblxyXG5mdW5jdGlvbiBTaW5nbGVFbnRyeVBsdWdpbihjb250ZXh0LCBlbnRyeSwgbmFtZSkge1xyXG5cdHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcblx0dGhpcy5lbnRyeSA9IGVudHJ5O1xyXG5cdHRoaXMubmFtZSA9IG5hbWU7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBTaW5nbGVFbnRyeVBsdWdpbjtcclxuU2luZ2xlRW50cnlQbHVnaW4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oY29tcGlsZXIpIHtcclxuXHRjb21waWxlci5wbHVnaW4oXCJjb21waWxhdGlvblwiLCBmdW5jdGlvbihjb21waWxhdGlvbiwgcGFyYW1zKSB7XHJcblx0XHR2YXIgbm9ybWFsTW9kdWxlRmFjdG9yeSA9IHBhcmFtcy5ub3JtYWxNb2R1bGVGYWN0b3J5O1xyXG5cclxuXHRcdGNvbXBpbGF0aW9uLmRlcGVuZGVuY3lGYWN0b3JpZXMuc2V0KFNpbmdsZUVudHJ5RGVwZW5kZW5jeSwgbm9ybWFsTW9kdWxlRmFjdG9yeSk7XHJcblx0fSk7XHJcblx0Y29tcGlsZXIucGx1Z2luKFwibWFrZVwiLCBmdW5jdGlvbihjb21waWxhdGlvbiwgY2FsbGJhY2spIHtcclxuXHRcdHZhciBkZXAgPSBuZXcgU2luZ2xlRW50cnlEZXBlbmRlbmN5KHRoaXMuZW50cnkpO1xyXG5cdFx0ZGVwLmxvYyA9IHRoaXMubmFtZTtcclxuXHRcdGNvbXBpbGF0aW9uLmFkZEVudHJ5KHRoaXMuY29udGV4dCwgZGVwLCB0aGlzLm5hbWUsIGNhbGxiYWNrKTtcclxuXHR9LmJpbmQodGhpcykpO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL1NpbmdsZUVudHJ5UGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSA5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgTW9kdWxlRGVwZW5kZW5jeSA9IHJlcXVpcmUoXCIuL01vZHVsZURlcGVuZGVuY3lcIik7XHJcblxyXG5mdW5jdGlvbiBTaW5nbGVFbnRyeURlcGVuZGVuY3kocmVxdWVzdCkge1xyXG5cdE1vZHVsZURlcGVuZGVuY3kuY2FsbCh0aGlzLCByZXF1ZXN0KTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IFNpbmdsZUVudHJ5RGVwZW5kZW5jeTtcclxuXHJcblNpbmdsZUVudHJ5RGVwZW5kZW5jeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE1vZHVsZURlcGVuZGVuY3kucHJvdG90eXBlKTtcclxuU2luZ2xlRW50cnlEZXBlbmRlbmN5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNpbmdsZUVudHJ5RGVwZW5kZW5jeTtcclxuU2luZ2xlRW50cnlEZXBlbmRlbmN5LnByb3RvdHlwZS50eXBlID0gXCJzaW5nbGUgZW50cnlcIjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvU2luZ2xlRW50cnlEZXBlbmRlbmN5LmpzXG4vLyBtb2R1bGUgaWQgPSA5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgTXVsdGlFbnRyeURlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9kZXBlbmRlbmNpZXMvTXVsdGlFbnRyeURlcGVuZGVuY3lcIik7XHJcbnZhciBTaW5nbGVFbnRyeURlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9kZXBlbmRlbmNpZXMvU2luZ2xlRW50cnlEZXBlbmRlbmN5XCIpO1xyXG52YXIgTXVsdGlNb2R1bGVGYWN0b3J5ID0gcmVxdWlyZShcIi4vTXVsdGlNb2R1bGVGYWN0b3J5XCIpO1xyXG5cclxuZnVuY3Rpb24gTXVsdGlFbnRyeVBsdWdpbihjb250ZXh0LCBlbnRyaWVzLCBuYW1lKSB7XHJcblx0dGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuXHR0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xyXG5cdHRoaXMubmFtZSA9IG5hbWU7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBNdWx0aUVudHJ5UGx1Z2luO1xyXG5NdWx0aUVudHJ5UGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGNvbXBpbGVyKSB7XHJcblx0Y29tcGlsZXIucGx1Z2luKFwiY29tcGlsYXRpb25cIiwgZnVuY3Rpb24oY29tcGlsYXRpb24sIHBhcmFtcykge1xyXG5cdFx0dmFyIG11bHRpTW9kdWxlRmFjdG9yeSA9IG5ldyBNdWx0aU1vZHVsZUZhY3RvcnkoKTtcclxuXHRcdHZhciBub3JtYWxNb2R1bGVGYWN0b3J5ID0gcGFyYW1zLm5vcm1hbE1vZHVsZUZhY3Rvcnk7XHJcblxyXG5cdFx0Y29tcGlsYXRpb24uZGVwZW5kZW5jeUZhY3Rvcmllcy5zZXQoTXVsdGlFbnRyeURlcGVuZGVuY3ksIG11bHRpTW9kdWxlRmFjdG9yeSk7XHJcblxyXG5cdFx0Y29tcGlsYXRpb24uZGVwZW5kZW5jeUZhY3Rvcmllcy5zZXQoU2luZ2xlRW50cnlEZXBlbmRlbmN5LCBub3JtYWxNb2R1bGVGYWN0b3J5KTtcclxuXHR9KTtcclxuXHRjb21waWxlci5wbHVnaW4oXCJtYWtlXCIsIGZ1bmN0aW9uKGNvbXBpbGF0aW9uLCBjYWxsYmFjaykge1xyXG5cdFx0Y29tcGlsYXRpb24uYWRkRW50cnkodGhpcy5jb250ZXh0LCBuZXcgTXVsdGlFbnRyeURlcGVuZGVuY3kodGhpcy5lbnRyaWVzLm1hcChmdW5jdGlvbihlLCBpZHgpIHtcclxuXHRcdFx0dmFyIGRlcCA9IG5ldyBTaW5nbGVFbnRyeURlcGVuZGVuY3koZSk7XHJcblx0XHRcdGRlcC5sb2MgPSB0aGlzLm5hbWUgKyBcIjpcIiArICgxMDAwMDAgKyBpZHgpO1xyXG5cdFx0XHRyZXR1cm4gZGVwO1xyXG5cdFx0fSwgdGhpcyksIHRoaXMubmFtZSksIHRoaXMubmFtZSwgY2FsbGJhY2spO1xyXG5cdH0uYmluZCh0aGlzKSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvTXVsdGlFbnRyeVBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBEZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4uL0RlcGVuZGVuY3lcIik7XHJcblxyXG5mdW5jdGlvbiBNdWx0aUVudHJ5RGVwZW5kZW5jeShkZXBlbmRlbmNpZXMsIG5hbWUpIHtcclxuXHREZXBlbmRlbmN5LmNhbGwodGhpcyk7XHJcblx0dGhpcy5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XHJcblx0dGhpcy5uYW1lID0gbmFtZTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IE11bHRpRW50cnlEZXBlbmRlbmN5O1xyXG5cclxuTXVsdGlFbnRyeURlcGVuZGVuY3kucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShEZXBlbmRlbmN5LnByb3RvdHlwZSk7XHJcbk11bHRpRW50cnlEZXBlbmRlbmN5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE11bHRpRW50cnlEZXBlbmRlbmN5O1xyXG5NdWx0aUVudHJ5RGVwZW5kZW5jeS5wcm90b3R5cGUudHlwZSA9IFwibXVsdGkgZW50cnlcIjtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvTXVsdGlFbnRyeURlcGVuZGVuY3kuanNcbi8vIG1vZHVsZSBpZCA9IDEwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgVGFwYWJsZSA9IHJlcXVpcmUoXCJ0YXBhYmxlXCIpO1xyXG52YXIgTXVsdGlNb2R1bGUgPSByZXF1aXJlKFwiLi9NdWx0aU1vZHVsZVwiKTtcclxuXHJcbmZ1bmN0aW9uIE11bHRpTW9kdWxlRmFjdG9yeSgpIHtcclxuXHRUYXBhYmxlLmNhbGwodGhpcyk7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBNdWx0aU1vZHVsZUZhY3Rvcnk7XHJcblxyXG5NdWx0aU1vZHVsZUZhY3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUYXBhYmxlLnByb3RvdHlwZSk7XHJcbk11bHRpTW9kdWxlRmFjdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNdWx0aU1vZHVsZUZhY3Rvcnk7XHJcblxyXG5NdWx0aU1vZHVsZUZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKGNvbnRleHQsIGRlcGVuZGVuY3ksIGNhbGxiYWNrKSB7XHJcblx0Y2FsbGJhY2sobnVsbCwgbmV3IE11bHRpTW9kdWxlKGNvbnRleHQsIGRlcGVuZGVuY3kuZGVwZW5kZW5jaWVzLCBkZXBlbmRlbmN5Lm5hbWUpKTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9NdWx0aU1vZHVsZUZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDEwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgTW9kdWxlID0gcmVxdWlyZShcIi4vTW9kdWxlXCIpO1xyXG52YXIgUmF3U291cmNlID0gcmVxdWlyZShcIndlYnBhY2stY29yZS9saWIvUmF3U291cmNlXCIpO1xyXG5cclxuZnVuY3Rpb24gTXVsdGlNb2R1bGUoY29udGV4dCwgZGVwZW5kZW5jaWVzLCBuYW1lKSB7XHJcblx0TW9kdWxlLmNhbGwodGhpcyk7XHJcblx0dGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuXHR0aGlzLmRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcztcclxuXHR0aGlzLm5hbWUgPSBuYW1lO1xyXG5cdHRoaXMuYnVpbHQgPSBmYWxzZTtcclxuXHR0aGlzLmNhY2hlYWJsZSA9IHRydWU7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBNdWx0aU1vZHVsZTtcclxuXHJcbk11bHRpTW9kdWxlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTW9kdWxlLnByb3RvdHlwZSk7XHJcblxyXG5NdWx0aU1vZHVsZS5wcm90b3R5cGUuaWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcIm11bHRpIFwiICsgdGhpcy5uYW1lO1xyXG59O1xyXG5cclxuTXVsdGlNb2R1bGUucHJvdG90eXBlLnJlYWRhYmxlSWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcIm11bHRpIFwiICsgdGhpcy5uYW1lO1xyXG59O1xyXG5cclxuTXVsdGlNb2R1bGUucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiBkaXNjb25uZWN0KCkge1xyXG5cdHRoaXMuYnVpbHQgPSBmYWxzZTtcclxuXHRNb2R1bGUucHJvdG90eXBlLmRpc2Nvbm5lY3QuY2FsbCh0aGlzKTtcclxufTtcclxuXHJcbk11bHRpTW9kdWxlLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIGJ1aWxkKG9wdGlvbnMsIGNvbXBpbGF0aW9uLCByZXNvbHZlciwgZnMsIGNhbGxiYWNrKSB7XHJcblx0dGhpcy5idWlsdCA9IHRydWU7XHJcblx0cmV0dXJuIGNhbGxiYWNrKCk7XHJcbn07XHJcblxyXG5NdWx0aU1vZHVsZS5wcm90b3R5cGUuc291cmNlID0gZnVuY3Rpb24oZGVwZW5kZW5jeVRlbXBsYXRlcywgb3V0cHV0T3B0aW9ucykge1xyXG5cdHZhciBzdHIgPSBbXTtcclxuXHR0aGlzLmRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uKGRlcCwgaWR4KSB7XHJcblx0XHRpZihkZXAubW9kdWxlKSB7XHJcblx0XHRcdGlmKGlkeCA9PT0gdGhpcy5kZXBlbmRlbmNpZXMubGVuZ3RoIC0gMSlcclxuXHRcdFx0XHRzdHIucHVzaChcIm1vZHVsZS5leHBvcnRzID0gXCIpO1xyXG5cdFx0XHRzdHIucHVzaChcIl9fd2VicGFja19yZXF1aXJlX18oXCIpO1xyXG5cdFx0XHRpZihvdXRwdXRPcHRpb25zLnBhdGhpbmZvKVxyXG5cdFx0XHRcdHN0ci5wdXNoKFwiLyohIFwiICsgZGVwLnJlcXVlc3QgKyBcIiAqL1wiKTtcclxuXHRcdFx0c3RyLnB1c2goXCJcIiArIEpTT04uc3RyaW5naWZ5KGRlcC5tb2R1bGUuaWQpKTtcclxuXHRcdFx0c3RyLnB1c2goXCIpXCIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3RyLnB1c2goXCIoZnVuY3Rpb24gd2VicGFja01pc3NpbmdNb2R1bGUoKSB7IHRocm93IG5ldyBFcnJvcihcIik7XHJcblx0XHRcdHN0ci5wdXNoKEpTT04uc3RyaW5naWZ5KFwiQ2Fubm90IGZpbmQgbW9kdWxlIFxcXCJcIiArIGRlcC5yZXF1ZXN0ICsgXCJcXFwiXCIpKTtcclxuXHRcdFx0c3RyLnB1c2goXCIpOyB9KCkpXCIpO1xyXG5cdFx0fVxyXG5cdFx0c3RyLnB1c2goXCI7XFxuXCIpO1xyXG5cdH0sIHRoaXMpO1xyXG5cdHJldHVybiBuZXcgUmF3U291cmNlKHN0ci5qb2luKFwiXCIpKTtcclxufTtcclxuXHJcbk11bHRpTW9kdWxlLnByb3RvdHlwZS5uZWVkUmVidWlsZCA9IGZ1bmN0aW9uIG5lZWRSZWJ1aWxkKCkge1xyXG5cdHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbk11bHRpTW9kdWxlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIDE2ICsgdGhpcy5kZXBlbmRlbmNpZXMubGVuZ3RoICogMTI7XHJcbn07XHJcblxyXG5NdWx0aU1vZHVsZS5wcm90b3R5cGUudXBkYXRlSGFzaCA9IGZ1bmN0aW9uKGhhc2gpIHtcclxuXHRoYXNoLnVwZGF0ZShcIm11bHRpIG1vZHVsZVwiKTtcclxuXHRoYXNoLnVwZGF0ZSh0aGlzLm5hbWUgfHwgXCJcIik7XHJcblx0TW9kdWxlLnByb3RvdHlwZS51cGRhdGVIYXNoLmNhbGwodGhpcywgaGFzaCk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvTXVsdGlNb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xyXG5cclxuZnVuY3Rpb24gUmVjb3JkSWRzUGx1Z2luKCkge31cclxubW9kdWxlLmV4cG9ydHMgPSBSZWNvcmRJZHNQbHVnaW47XHJcblxyXG5mdW5jdGlvbiBtYWtlUmVsYXRpdmUoY29tcGlsZXIsIGlkZW50aWZpZXIpIHtcclxuXHR2YXIgY29udGV4dCA9IGNvbXBpbGVyLmNvbnRleHQ7XHJcblx0cmV0dXJuIGlkZW50aWZpZXIuc3BsaXQoXCJ8XCIpLm1hcChmdW5jdGlvbihzdHIpIHtcclxuXHRcdHJldHVybiBpZGVudGlmaWVyLnNwbGl0KFwiIVwiKS5tYXAoZnVuY3Rpb24oc3RyKSB7XHJcblx0XHRcdHJldHVybiBwYXRoLnJlbGF0aXZlKGNvbnRleHQsIHN0cik7XHJcblx0XHR9KS5qb2luKFwiIVwiKTtcclxuXHR9KS5qb2luKFwifFwiKTtcclxufVxyXG5cclxuUmVjb3JkSWRzUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGNvbXBpbGVyKSB7XHJcblx0Y29tcGlsZXIucGx1Z2luKFwiY29tcGlsYXRpb25cIiwgZnVuY3Rpb24oY29tcGlsYXRpb24pIHtcclxuXHRcdGNvbXBpbGF0aW9uLnBsdWdpbihcInJlY29yZC1tb2R1bGVzXCIsIGZ1bmN0aW9uKG1vZHVsZXMsIHJlY29yZHMpIHtcclxuXHRcdFx0cmVjb3Jkcy5uZXh0RnJlZU1vZHVsZUlkID0gY29tcGlsYXRpb24ubmV4dEZyZWVNb2R1bGVJZDtcclxuXHRcdFx0aWYoIXJlY29yZHMubW9kdWxlcykgcmVjb3Jkcy5tb2R1bGVzID0ge307XHJcblx0XHRcdGlmKCFyZWNvcmRzLm1vZHVsZXMuYnlJZGVudGlmaWVyKSByZWNvcmRzLm1vZHVsZXMuYnlJZGVudGlmaWVyID0ge307XHJcblx0XHRcdG1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRcdFx0XHR2YXIgaWRlbnRpZmllciA9IG1ha2VSZWxhdGl2ZShjb21waWxlciwgbW9kdWxlLmlkZW50aWZpZXIoKSk7XHJcblx0XHRcdFx0cmVjb3Jkcy5tb2R1bGVzLmJ5SWRlbnRpZmllcltpZGVudGlmaWVyXSA9IG1vZHVsZS5pZDtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHRcdGNvbXBpbGF0aW9uLnBsdWdpbihcInJldml2ZS1tb2R1bGVzXCIsIGZ1bmN0aW9uKG1vZHVsZXMsIHJlY29yZHMpIHtcclxuXHRcdFx0aWYocmVjb3Jkcy5uZXh0RnJlZU1vZHVsZUlkKVxyXG5cdFx0XHRcdGNvbXBpbGF0aW9uLm5leHRGcmVlTW9kdWxlSWQgPSByZWNvcmRzLm5leHRGcmVlTW9kdWxlSWQ7XHJcblx0XHRcdGlmKCFyZWNvcmRzLm1vZHVsZXMgfHwgIXJlY29yZHMubW9kdWxlcy5ieUlkZW50aWZpZXIpIHJldHVybjtcclxuXHRcdFx0dmFyIHVzZWRJZHMgPSB7XHJcblx0XHRcdFx0MDogdHJ1ZVxyXG5cdFx0XHR9O1xyXG5cdFx0XHRtb2R1bGVzLmZvckVhY2goZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0XHRcdFx0aWYobW9kdWxlLmlkICE9PSBudWxsKSByZXR1cm47XHJcblx0XHRcdFx0dmFyIGlkZW50aWZpZXIgPSBtYWtlUmVsYXRpdmUoY29tcGlsZXIsIG1vZHVsZS5pZGVudGlmaWVyKCkpO1xyXG5cdFx0XHRcdHZhciBpZCA9IHJlY29yZHMubW9kdWxlcy5ieUlkZW50aWZpZXJbaWRlbnRpZmllcl07XHJcblx0XHRcdFx0aWYoaWQgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xyXG5cdFx0XHRcdGlmKHVzZWRJZHNbaWRdKSByZXR1cm47XHJcblx0XHRcdFx0dXNlZElkc1tpZF0gPSB0cnVlO1xyXG5cdFx0XHRcdG1vZHVsZS5pZCA9IGlkO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGdldERlcEJsb2NrSWRlbnQoY2h1bmssIGJsb2NrKSB7XHJcblx0XHRcdHZhciBpZGVudCA9IFtdO1xyXG5cdFx0XHRpZihibG9jay5jaHVua3MubGVuZ3RoID4gMSlcclxuXHRcdFx0XHRpZGVudC5wdXNoKGJsb2NrLmNodW5rcy5pbmRleE9mKGNodW5rKSk7XHJcblx0XHRcdHdoaWxlKGJsb2NrLnBhcmVudCkge1xyXG5cdFx0XHRcdHZhciBwID0gYmxvY2sucGFyZW50O1xyXG5cdFx0XHRcdHZhciBpZHggPSBwLmJsb2Nrcy5pbmRleE9mKGJsb2NrKTtcclxuXHRcdFx0XHR2YXIgbCA9IHAuYmxvY2tzLmxlbmd0aCAtIDE7XHJcblx0XHRcdFx0aWRlbnQudW5zaGlmdChpZHggKyBcIi9cIiArIGwpO1xyXG5cdFx0XHRcdGJsb2NrID0gYmxvY2sucGFyZW50O1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKCFibG9jay5pZGVudGlmaWVyKSByZXR1cm4gbnVsbDtcclxuXHRcdFx0aWRlbnQudW5zaGlmdChtYWtlUmVsYXRpdmUoY29tcGlsZXIsIGJsb2NrLmlkZW50aWZpZXIoKSkpO1xyXG5cdFx0XHRyZXR1cm4gaWRlbnQuam9pbihcIjpcIik7XHJcblx0XHR9XHJcblx0XHRjb21waWxhdGlvbi5wbHVnaW4oXCJyZWNvcmQtY2h1bmtzXCIsIGZ1bmN0aW9uKGNodW5rcywgcmVjb3Jkcykge1xyXG5cdFx0XHRyZWNvcmRzLm5leHRGcmVlQ2h1bmtJZCA9IGNvbXBpbGF0aW9uLm5leHRGcmVlQ2h1bmtJZDtcclxuXHRcdFx0aWYoIXJlY29yZHMuY2h1bmtzKSByZWNvcmRzLmNodW5rcyA9IHt9O1xyXG5cdFx0XHRpZighcmVjb3Jkcy5jaHVua3MuYnlOYW1lKSByZWNvcmRzLmNodW5rcy5ieU5hbWUgPSB7fTtcclxuXHRcdFx0aWYoIXJlY29yZHMuY2h1bmtzLmJ5QmxvY2tzKSByZWNvcmRzLmNodW5rcy5ieUJsb2NrcyA9IHt9O1xyXG5cdFx0XHRjaHVua3MuZm9yRWFjaChmdW5jdGlvbihjaHVuaykge1xyXG5cdFx0XHRcdHZhciBuYW1lID0gY2h1bmsubmFtZTtcclxuXHRcdFx0XHR2YXIgYmxvY2tJZGVudHMgPSBjaHVuay5ibG9ja3MubWFwKGdldERlcEJsb2NrSWRlbnQuYmluZChudWxsLCBjaHVuaykpLmZpbHRlcihCb29sZWFuKTtcclxuXHRcdFx0XHRpZihuYW1lKSByZWNvcmRzLmNodW5rcy5ieU5hbWVbbmFtZV0gPSBjaHVuay5pZDtcclxuXHRcdFx0XHRibG9ja0lkZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGJsb2NrSWRlbnQpIHtcclxuXHRcdFx0XHRcdHJlY29yZHMuY2h1bmtzLmJ5QmxvY2tzW2Jsb2NrSWRlbnRdID0gY2h1bmsuaWQ7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0XHRjb21waWxhdGlvbi5wbHVnaW4oXCJyZXZpdmUtY2h1bmtzXCIsIGZ1bmN0aW9uKGNodW5rcywgcmVjb3Jkcykge1xyXG5cdFx0XHRpZihyZWNvcmRzLm5leHRGcmVlQ2h1bmtJZClcclxuXHRcdFx0XHRjb21waWxhdGlvbi5uZXh0RnJlZUNodW5rSWQgPSByZWNvcmRzLm5leHRGcmVlQ2h1bmtJZDtcclxuXHRcdFx0aWYoIXJlY29yZHMuY2h1bmtzKSByZXR1cm47XHJcblx0XHRcdHZhciB1c2VkSWRzID0ge307XHJcblx0XHRcdGlmKHJlY29yZHMuY2h1bmtzLmJ5TmFtZSkge1xyXG5cdFx0XHRcdGNodW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGNodW5rKSB7XHJcblx0XHRcdFx0XHRpZihjaHVuay5pZCAhPT0gbnVsbCkgcmV0dXJuO1xyXG5cdFx0XHRcdFx0aWYoIWNodW5rLm5hbWUpIHJldHVybjtcclxuXHRcdFx0XHRcdHZhciBpZCA9IHJlY29yZHMuY2h1bmtzLmJ5TmFtZVtjaHVuay5uYW1lXTtcclxuXHRcdFx0XHRcdGlmKGlkID09PSB1bmRlZmluZWQpIHJldHVybjtcclxuXHRcdFx0XHRcdGlmKHVzZWRJZHNbaWRdKSByZXR1cm47XHJcblx0XHRcdFx0XHR1c2VkSWRzW2lkXSA9IHRydWU7XHJcblx0XHRcdFx0XHRjaHVuay5pZCA9IGlkO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHJlY29yZHMuY2h1bmtzLmJ5QmxvY2tzKSB7XHJcblx0XHRcdFx0dmFyIGFyZ3VtZW50ZWRDaHVua3MgPSBjaHVua3MuZmlsdGVyKGZ1bmN0aW9uKGNodW5rKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gY2h1bmsuaWQgPT09IG51bGw7XHJcblx0XHRcdFx0fSkubWFwKGZ1bmN0aW9uKGNodW5rKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0XHRjaHVuazogY2h1bmssXHJcblx0XHRcdFx0XHRcdGJsb2NrSWRlbnRzOiBjaHVuay5ibG9ja3MubWFwKGdldERlcEJsb2NrSWRlbnQuYmluZChudWxsLCBjaHVuaykpLmZpbHRlcihCb29sZWFuKVxyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHR9KS5maWx0ZXIoZnVuY3Rpb24oYXJnKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gYXJnLmJsb2NrSWRlbnRzLmxlbmd0aCA+IDA7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0dmFyIGJsb2NrSWRlbnRzQ291bnQgPSB7fTtcclxuXHRcdFx0XHRhcmd1bWVudGVkQ2h1bmtzLmZvckVhY2goZnVuY3Rpb24oYXJnLCBpZHgpIHtcclxuXHRcdFx0XHRcdGFyZy5ibG9ja0lkZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGJsb2NrSWRlbnQpIHtcclxuXHRcdFx0XHRcdFx0dmFyIGlkID0gcmVjb3Jkcy5jaHVua3MuYnlCbG9ja3NbYmxvY2tJZGVudF07XHJcblx0XHRcdFx0XHRcdGlmKHR5cGVvZiBpZCAhPT0gXCJudW1iZXJcIikgcmV0dXJuO1xyXG5cdFx0XHRcdFx0XHR2YXIgYWNjZXNzb3IgPSBpZCArIFwiOlwiICsgaWR4O1xyXG5cdFx0XHRcdFx0XHRibG9ja0lkZW50c0NvdW50W2FjY2Vzc29yXSA9IChibG9ja0lkZW50c0NvdW50W2FjY2Vzc29yXSB8fCAwKSArIDE7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRibG9ja0lkZW50c0NvdW50ID0gT2JqZWN0LmtleXMoYmxvY2tJZGVudHNDb3VudCkubWFwKGZ1bmN0aW9uKGFjY2Vzc29yKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gW2Jsb2NrSWRlbnRzQ291bnRbYWNjZXNzb3JdXS5jb25jYXQoYWNjZXNzb3Iuc3BsaXQoXCI6XCIpLm1hcChOdW1iZXIpKTtcclxuXHRcdFx0XHR9KS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdFx0XHRcdHJldHVybiBiWzBdIC0gYVswXTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRibG9ja0lkZW50c0NvdW50LmZvckVhY2goZnVuY3Rpb24oYXJnKSB7XHJcblx0XHRcdFx0XHR2YXIgaWQgPSBhcmdbMV07XHJcblx0XHRcdFx0XHRpZih1c2VkSWRzW2lkXSkgcmV0dXJuO1xyXG5cdFx0XHRcdFx0dmFyIGlkeCA9IGFyZ1syXTtcclxuXHRcdFx0XHRcdHZhciBjaHVuayA9IGFyZ3VtZW50ZWRDaHVua3NbaWR4XS5jaHVuaztcclxuXHRcdFx0XHRcdGlmKGNodW5rLmlkICE9PSBudWxsKSByZXR1cm47XHJcblx0XHRcdFx0XHR1c2VkSWRzW2lkXSA9IHRydWU7XHJcblx0XHRcdFx0XHRjaHVuay5pZCA9IGlkO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9KTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9SZWNvcmRJZHNQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDEwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgQ29uc3REZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4vZGVwZW5kZW5jaWVzL0NvbnN0RGVwZW5kZW5jeVwiKTtcclxudmFyIEJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbiA9IHJlcXVpcmUoXCIuL0Jhc2ljRXZhbHVhdGVkRXhwcmVzc2lvblwiKTtcclxuXHJcbnZhciBOdWxsRmFjdG9yeSA9IHJlcXVpcmUoXCIuL051bGxGYWN0b3J5XCIpO1xyXG5cclxuZnVuY3Rpb24gQVBJUGx1Z2luKCkge31cclxubW9kdWxlLmV4cG9ydHMgPSBBUElQbHVnaW47XHJcblxyXG52YXIgUkVQTEFDRU1FTlRTID0ge1xyXG5cdF9fd2VicGFja19yZXF1aXJlX186IFwiX193ZWJwYWNrX3JlcXVpcmVfX1wiLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxyXG5cdF9fd2VicGFja19wdWJsaWNfcGF0aF9fOiBcIl9fd2VicGFja19yZXF1aXJlX18ucFwiLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxyXG5cdF9fd2VicGFja19tb2R1bGVzX186IFwiX193ZWJwYWNrX3JlcXVpcmVfXy5tXCIsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXHJcblx0X193ZWJwYWNrX2NodW5rX2xvYWRfXzogXCJfX3dlYnBhY2tfcmVxdWlyZV9fLmVcIiwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcclxuXHRfX25vbl93ZWJwYWNrX3JlcXVpcmVfXzogXCJyZXF1aXJlXCIsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXHJcblx0XCJyZXF1aXJlLm9uRXJyb3JcIjogXCJfX3dlYnBhY2tfcmVxdWlyZV9fLm9uRXJyb3JcIiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxyXG59O1xyXG52YXIgUkVQTEFDRU1FTlRfVFlQRVMgPSB7XHJcblx0X193ZWJwYWNrX3B1YmxpY19wYXRoX186IFwic3RyaW5nXCIsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXHJcblx0X193ZWJwYWNrX3JlcXVpcmVfXzogXCJmdW5jdGlvblwiLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxyXG5cdF9fd2VicGFja19tb2R1bGVzX186IFwib2JqZWN0XCIsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXHJcblx0X193ZWJwYWNrX2NodW5rX2xvYWRfXzogXCJmdW5jdGlvblwiIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXHJcbn07XHJcbnZhciBJR05PUkVTID0gW107XHJcbkFQSVBsdWdpbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbihjb21waWxlcikge1xyXG5cdGNvbXBpbGVyLnBsdWdpbihcImNvbXBpbGF0aW9uXCIsIGZ1bmN0aW9uKGNvbXBpbGF0aW9uKSB7XHJcblx0XHRjb21waWxhdGlvbi5kZXBlbmRlbmN5RmFjdG9yaWVzLnNldChDb25zdERlcGVuZGVuY3ksIG5ldyBOdWxsRmFjdG9yeSgpKTtcclxuXHRcdGNvbXBpbGF0aW9uLmRlcGVuZGVuY3lUZW1wbGF0ZXMuc2V0KENvbnN0RGVwZW5kZW5jeSwgbmV3IENvbnN0RGVwZW5kZW5jeS5UZW1wbGF0ZSgpKTtcclxuXHR9KTtcclxuXHRPYmplY3Qua2V5cyhSRVBMQUNFTUVOVFMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XHJcblx0XHRjb21waWxlci5wYXJzZXIucGx1Z2luKFwiZXhwcmVzc2lvbiBcIiArIGtleSwgZnVuY3Rpb24oZXhwcikge1xyXG5cdFx0XHR2YXIgZGVwID0gbmV3IENvbnN0RGVwZW5kZW5jeShSRVBMQUNFTUVOVFNba2V5XSwgZXhwci5yYW5nZSk7XHJcblx0XHRcdGRlcC5sb2MgPSBleHByLmxvYztcclxuXHRcdFx0dGhpcy5zdGF0ZS5jdXJyZW50LmFkZERlcGVuZGVuY3koZGVwKTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9KTtcclxuXHRcdGNvbXBpbGVyLnBhcnNlci5wbHVnaW4oXCJldmFsdWF0ZSB0eXBlb2YgXCIgKyBrZXksIGZ1bmN0aW9uKGV4cHIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBCYXNpY0V2YWx1YXRlZEV4cHJlc3Npb24oKS5zZXRTdHJpbmcoUkVQTEFDRU1FTlRfVFlQRVNba2V5XSkuc2V0UmFuZ2UoZXhwci5yYW5nZSk7XHJcblx0XHR9KTtcclxuXHR9KTtcclxuXHRJR05PUkVTLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XHJcblx0XHRjb21waWxlci5wYXJzZXIucGx1Z2luKGtleSwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvQVBJUGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIE51bGxEZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4vTnVsbERlcGVuZGVuY3lcIik7XHJcblxyXG5mdW5jdGlvbiBDb25zdERlcGVuZGVuY3koZXhwcmVzc2lvbiwgcmFuZ2UpIHtcclxuXHROdWxsRGVwZW5kZW5jeS5jYWxsKHRoaXMpO1xyXG5cdHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XHJcblx0dGhpcy5yYW5nZSA9IHJhbmdlO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gQ29uc3REZXBlbmRlbmN5O1xyXG5cclxuQ29uc3REZXBlbmRlbmN5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTnVsbERlcGVuZGVuY3kucHJvdG90eXBlKTtcclxuQ29uc3REZXBlbmRlbmN5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnN0RGVwZW5kZW5jeTtcclxuXHJcbkNvbnN0RGVwZW5kZW5jeS5UZW1wbGF0ZSA9IGZ1bmN0aW9uIENvbnN0RGVwZW5kZW5jeVRlbXBsYXRlKCkge307XHJcblxyXG5Db25zdERlcGVuZGVuY3kuVGVtcGxhdGUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oZGVwLCBzb3VyY2UpIHtcclxuXHRpZih0eXBlb2YgZGVwLnJhbmdlID09PSBcIm51bWJlclwiKVxyXG5cdFx0c291cmNlLmluc2VydChkZXAucmFuZ2UsIGRlcC5leHByZXNzaW9uKTtcclxuXHRlbHNlXHJcblx0XHRzb3VyY2UucmVwbGFjZShkZXAucmFuZ2VbMF0sIGRlcC5yYW5nZVsxXSAtIDEsIGRlcC5leHByZXNzaW9uKTtcclxufTtcclxuXHJcbkNvbnN0RGVwZW5kZW5jeS5wcm90b3R5cGUudXBkYXRlSGFzaCA9IGZ1bmN0aW9uKGhhc2gpIHtcclxuXHRoYXNoLnVwZGF0ZSh0aGlzLnJhbmdlICsgXCJcIik7XHJcblx0aGFzaC51cGRhdGUodGhpcy5leHByZXNzaW9uICsgXCJcIik7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL0NvbnN0RGVwZW5kZW5jeS5qc1xuLy8gbW9kdWxlIGlkID0gMTA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBEZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4uL0RlcGVuZGVuY3lcIik7XHJcblxyXG5mdW5jdGlvbiBOdWxsRGVwZW5kZW5jeSgpIHtcclxuXHREZXBlbmRlbmN5LmNhbGwodGhpcyk7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBOdWxsRGVwZW5kZW5jeTtcclxuXHJcbk51bGxEZXBlbmRlbmN5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRGVwZW5kZW5jeS5wcm90b3R5cGUpO1xyXG5OdWxsRGVwZW5kZW5jeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOdWxsRGVwZW5kZW5jeTtcclxuTnVsbERlcGVuZGVuY3kucHJvdG90eXBlLnR5cGUgPSBcIm51bGxcIjtcclxuTnVsbERlcGVuZGVuY3kucHJvdG90eXBlLmlzRXF1YWxSZXNvdXJjZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBmYWxzZTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvTnVsbERlcGVuZGVuY3kuanNcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5mdW5jdGlvbiBOdWxsRmFjdG9yeSgpIHt9XHJcbm1vZHVsZS5leHBvcnRzID0gTnVsbEZhY3Rvcnk7XHJcblxyXG5OdWxsRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oY29udGV4dCwgZGVwZW5kZW5jeSwgY2FsbGJhY2spIHtcclxuXHRyZXR1cm4gY2FsbGJhY2soKTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9OdWxsRmFjdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gMTA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBDb25zdERlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9kZXBlbmRlbmNpZXMvQ29uc3REZXBlbmRlbmN5XCIpO1xyXG52YXIgQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uID0gcmVxdWlyZShcIi4vQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uXCIpO1xyXG5cclxudmFyIE51bGxGYWN0b3J5ID0gcmVxdWlyZShcIi4vTnVsbEZhY3RvcnlcIik7XHJcblxyXG5mdW5jdGlvbiBDb25zdFBsdWdpbigpIHt9XHJcbm1vZHVsZS5leHBvcnRzID0gQ29uc3RQbHVnaW47XHJcblxyXG5Db25zdFBsdWdpbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbihjb21waWxlcikge1xyXG5cdGNvbXBpbGVyLnBsdWdpbihcImNvbXBpbGF0aW9uXCIsIGZ1bmN0aW9uKGNvbXBpbGF0aW9uKSB7XHJcblx0XHRjb21waWxhdGlvbi5kZXBlbmRlbmN5RmFjdG9yaWVzLnNldChDb25zdERlcGVuZGVuY3ksIG5ldyBOdWxsRmFjdG9yeSgpKTtcclxuXHRcdGNvbXBpbGF0aW9uLmRlcGVuZGVuY3lUZW1wbGF0ZXMuc2V0KENvbnN0RGVwZW5kZW5jeSwgbmV3IENvbnN0RGVwZW5kZW5jeS5UZW1wbGF0ZSgpKTtcclxuXHR9KTtcclxuXHRjb21waWxlci5wYXJzZXIucGx1Z2luKFwic3RhdGVtZW50IGlmXCIsIGZ1bmN0aW9uKHN0YXRlbWVudCkge1xyXG5cdFx0dmFyIHBhcmFtID0gdGhpcy5ldmFsdWF0ZUV4cHJlc3Npb24oc3RhdGVtZW50LnRlc3QpO1xyXG5cdFx0dmFyIGJvb2wgPSBwYXJhbS5hc0Jvb2woKTtcclxuXHRcdGlmKHR5cGVvZiBib29sID09PSBcImJvb2xlYW5cIikge1xyXG5cdFx0XHRpZihzdGF0ZW1lbnQudGVzdC50eXBlICE9PSBcIkxpdGVyYWxcIikge1xyXG5cdFx0XHRcdHZhciBkZXAgPSBuZXcgQ29uc3REZXBlbmRlbmN5KGJvb2wgKyBcIlwiLCBwYXJhbS5yYW5nZSk7XHJcblx0XHRcdFx0ZGVwLmxvYyA9IHN0YXRlbWVudC5sb2M7XHJcblx0XHRcdFx0dGhpcy5zdGF0ZS5jdXJyZW50LmFkZERlcGVuZGVuY3koZGVwKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gYm9vbDtcclxuXHRcdH1cclxuXHR9KTtcclxuXHRjb21waWxlci5wYXJzZXIucGx1Z2luKFwiZXhwcmVzc2lvbiA/OlwiLCBmdW5jdGlvbihleHByZXNzaW9uKSB7XHJcblx0XHR2YXIgcGFyYW0gPSB0aGlzLmV2YWx1YXRlRXhwcmVzc2lvbihleHByZXNzaW9uLnRlc3QpO1xyXG5cdFx0dmFyIGJvb2wgPSBwYXJhbS5hc0Jvb2woKTtcclxuXHRcdGlmKHR5cGVvZiBib29sID09PSBcImJvb2xlYW5cIikge1xyXG5cdFx0XHRpZihleHByZXNzaW9uLnRlc3QudHlwZSAhPT0gXCJMaXRlcmFsXCIpIHtcclxuXHRcdFx0XHR2YXIgZGVwID0gbmV3IENvbnN0RGVwZW5kZW5jeShcIiBcIiArIGJvb2wgKyBcIlwiLCBwYXJhbS5yYW5nZSk7XHJcblx0XHRcdFx0ZGVwLmxvYyA9IGV4cHJlc3Npb24ubG9jO1xyXG5cdFx0XHRcdHRoaXMuc3RhdGUuY3VycmVudC5hZGREZXBlbmRlbmN5KGRlcCk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGJvb2w7XHJcblx0XHR9XHJcblx0fSk7XHJcblx0Y29tcGlsZXIucGFyc2VyLnBsdWdpbihcImV2YWx1YXRlIElkZW50aWZpZXIgX19yZXNvdXJjZVF1ZXJ5XCIsIGZ1bmN0aW9uKGV4cHIpIHtcclxuXHRcdGlmKCF0aGlzLnN0YXRlLm1vZHVsZSkgcmV0dXJuO1xyXG5cdFx0dmFyIHJlcyA9IG5ldyBCYXNpY0V2YWx1YXRlZEV4cHJlc3Npb24oKTtcclxuXHRcdHJlcy5zZXRTdHJpbmcodGhpcy5zdGF0ZS5tb2R1bGUuc3BsaXRRdWVyeSh0aGlzLnN0YXRlLm1vZHVsZS5yZXNvdXJjZSlbMV0pO1xyXG5cdFx0cmVzLnNldFJhbmdlKGV4cHIucmFuZ2UpO1xyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9KTtcclxuXHRjb21waWxlci5wYXJzZXIucGx1Z2luKFwiZXhwcmVzc2lvbiBfX3Jlc291cmNlUXVlcnlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRpZighdGhpcy5zdGF0ZS5tb2R1bGUpIHJldHVybjtcclxuXHRcdHRoaXMuc3RhdGUuY3VycmVudC5hZGRWYXJpYWJsZShcIl9fcmVzb3VyY2VRdWVyeVwiLCBKU09OLnN0cmluZ2lmeSh0aGlzLnN0YXRlLm1vZHVsZS5zcGxpdFF1ZXJ5KHRoaXMuc3RhdGUubW9kdWxlLnJlc291cmNlKVsxXSkpO1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvQ29uc3RQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDEwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgQ29uc3REZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4vZGVwZW5kZW5jaWVzL0NvbnN0RGVwZW5kZW5jeVwiKTtcclxuXHJcbnZhciBOdWxsRmFjdG9yeSA9IHJlcXVpcmUoXCIuL051bGxGYWN0b3J5XCIpO1xyXG5cclxuZnVuY3Rpb24gUmVxdWlyZUpzU3R1ZmZQbHVnaW4oKSB7fVxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlcXVpcmVKc1N0dWZmUGx1Z2luO1xyXG5SZXF1aXJlSnNTdHVmZlBsdWdpbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbihjb21waWxlcikge1xyXG5cdGNvbXBpbGVyLnBsdWdpbihcImNvbXBpbGF0aW9uXCIsIGZ1bmN0aW9uKGNvbXBpbGF0aW9uKSB7XHJcblx0XHRjb21waWxhdGlvbi5kZXBlbmRlbmN5RmFjdG9yaWVzLnNldChDb25zdERlcGVuZGVuY3ksIG5ldyBOdWxsRmFjdG9yeSgpKTtcclxuXHRcdGNvbXBpbGF0aW9uLmRlcGVuZGVuY3lUZW1wbGF0ZXMuc2V0KENvbnN0RGVwZW5kZW5jeSwgbmV3IENvbnN0RGVwZW5kZW5jeS5UZW1wbGF0ZSgpKTtcclxuXHR9KTtcclxuXHJcblx0ZnVuY3Rpb24gcmVtb3ZlKGV4cHIpIHtcclxuXHRcdHZhciBkZXAgPSBuZXcgQ29uc3REZXBlbmRlbmN5KFwiO1wiLCBleHByLnJhbmdlKTtcclxuXHRcdGRlcC5sb2MgPSBleHByLmxvYztcclxuXHRcdHRoaXMuc3RhdGUuY3VycmVudC5hZGREZXBlbmRlbmN5KGRlcCk7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblx0Y29tcGlsZXIucGFyc2VyLnBsdWdpbihcImNhbGwgcmVxdWlyZS5jb25maWdcIiwgcmVtb3ZlKTtcclxuXHRjb21waWxlci5wYXJzZXIucGx1Z2luKFwiY2FsbCByZXF1aXJlanMuY29uZmlnXCIsIHJlbW92ZSk7XHJcblxyXG5cdGNvbXBpbGVyLnBhcnNlci5wbHVnaW4oXCJleHByZXNzaW9uIHJlcXVpcmUudmVyc2lvblwiLCBmdW5jdGlvbihleHByKSB7XHJcblx0XHR2YXIgZGVwID0gbmV3IENvbnN0RGVwZW5kZW5jeShKU09OLnN0cmluZ2lmeShcIjAuMC4wXCIpLCBleHByLnJhbmdlKTtcclxuXHRcdGRlcC5sb2MgPSBleHByLmxvYztcclxuXHRcdHRoaXMuc3RhdGUuY3VycmVudC5hZGREZXBlbmRlbmN5KGRlcCk7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9KTtcclxuXHRjb21waWxlci5wYXJzZXIucGx1Z2luKFwiZXhwcmVzc2lvbiByZXF1aXJlanMub25FcnJvclwiLCBmdW5jdGlvbihleHByKSB7XHJcblx0XHR2YXIgZGVwID0gbmV3IENvbnN0RGVwZW5kZW5jeShKU09OLnN0cmluZ2lmeShcIl9fd2VicGFja19yZXF1aXJlX18ub25FcnJvclwiKSwgZXhwci5yYW5nZSk7XHJcblx0XHRkZXAubG9jID0gZXhwci5sb2M7XHJcblx0XHR0aGlzLnN0YXRlLmN1cnJlbnQuYWRkRGVwZW5kZW5jeShkZXApO1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvUmVxdWlyZUpzU3R1ZmZQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDExMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xyXG52YXIgTW9kdWxlUGFyc2VySGVscGVycyA9IHJlcXVpcmUoXCIuL01vZHVsZVBhcnNlckhlbHBlcnNcIik7XHJcbnZhciBDb25zdERlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9kZXBlbmRlbmNpZXMvQ29uc3REZXBlbmRlbmN5XCIpO1xyXG52YXIgQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uID0gcmVxdWlyZShcIi4vQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uXCIpO1xyXG52YXIgVW5zdXBwb3J0ZWRGZWF0dXJlV2FybmluZyA9IHJlcXVpcmUoXCIuL1Vuc3VwcG9ydGVkRmVhdHVyZVdhcm5pbmdcIik7XHJcblxyXG52YXIgTnVsbEZhY3RvcnkgPSByZXF1aXJlKFwiLi9OdWxsRmFjdG9yeVwiKTtcclxuXHJcbmZ1bmN0aW9uIE5vZGVTdHVmZlBsdWdpbihvcHRpb25zKSB7XHJcblx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVTdHVmZlBsdWdpbjtcclxuTm9kZVN0dWZmUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGNvbXBpbGVyKSB7XHJcblx0Y29tcGlsZXIucGx1Z2luKFwiY29tcGlsYXRpb25cIiwgZnVuY3Rpb24oY29tcGlsYXRpb24pIHtcclxuXHRcdGNvbXBpbGF0aW9uLmRlcGVuZGVuY3lGYWN0b3JpZXMuc2V0KENvbnN0RGVwZW5kZW5jeSwgbmV3IE51bGxGYWN0b3J5KCkpO1xyXG5cdFx0Y29tcGlsYXRpb24uZGVwZW5kZW5jeVRlbXBsYXRlcy5zZXQoQ29uc3REZXBlbmRlbmN5LCBuZXcgQ29uc3REZXBlbmRlbmN5LlRlbXBsYXRlKCkpO1xyXG5cdH0pO1xyXG5cclxuXHRmdW5jdGlvbiBpZ25vcmUoKSB7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldENvbnN0YW50KGV4cHJlc3Npb25OYW1lLCB2YWx1ZSkge1xyXG5cdFx0Y29tcGlsZXIucGFyc2VyLnBsdWdpbihcImV4cHJlc3Npb24gXCIgKyBleHByZXNzaW9uTmFtZSwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdHRoaXMuc3RhdGUuY3VycmVudC5hZGRWYXJpYWJsZShleHByZXNzaW9uTmFtZSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldE1vZHVsZUNvbnN0YW50KGV4cHJlc3Npb25OYW1lLCBmbikge1xyXG5cdFx0Y29tcGlsZXIucGFyc2VyLnBsdWdpbihcImV4cHJlc3Npb24gXCIgKyBleHByZXNzaW9uTmFtZSwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdHRoaXMuc3RhdGUuY3VycmVudC5hZGRWYXJpYWJsZShleHByZXNzaW9uTmFtZSwgSlNPTi5zdHJpbmdpZnkoZm4odGhpcy5zdGF0ZS5tb2R1bGUpKSk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cdHZhciBjb250ZXh0ID0gY29tcGlsZXIuY29udGV4dDtcclxuXHRpZih0aGlzLm9wdGlvbnMuX19maWxlbmFtZSA9PT0gXCJtb2NrXCIpIHtcclxuXHRcdHNldENvbnN0YW50KFwiX19maWxlbmFtZVwiLCBcIi9pbmRleC5qc1wiKTtcclxuXHR9IGVsc2UgaWYodGhpcy5vcHRpb25zLl9fZmlsZW5hbWUpIHtcclxuXHRcdHNldE1vZHVsZUNvbnN0YW50KFwiX19maWxlbmFtZVwiLCBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRcdFx0cmV0dXJuIHBhdGgucmVsYXRpdmUoY29udGV4dCwgbW9kdWxlLnJlc291cmNlKTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHRjb21waWxlci5wYXJzZXIucGx1Z2luKFwiZXZhbHVhdGUgSWRlbnRpZmllciBfX2ZpbGVuYW1lXCIsIGZ1bmN0aW9uKGV4cHIpIHtcclxuXHRcdGlmKCF0aGlzLnN0YXRlLm1vZHVsZSkgcmV0dXJuO1xyXG5cdFx0dmFyIHJlcyA9IG5ldyBCYXNpY0V2YWx1YXRlZEV4cHJlc3Npb24oKTtcclxuXHRcdHJlcy5zZXRTdHJpbmcodGhpcy5zdGF0ZS5tb2R1bGUuc3BsaXRRdWVyeSh0aGlzLnN0YXRlLm1vZHVsZS5yZXNvdXJjZSlbMF0pO1xyXG5cdFx0cmVzLnNldFJhbmdlKGV4cHIucmFuZ2UpO1xyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9KTtcclxuXHRpZih0aGlzLm9wdGlvbnMuX19kaXJuYW1lID09PSBcIm1vY2tcIikge1xyXG5cdFx0c2V0Q29uc3RhbnQoXCJfX2Rpcm5hbWVcIiwgXCIvXCIpO1xyXG5cdH0gZWxzZSBpZih0aGlzLm9wdGlvbnMuX19kaXJuYW1lKSB7XHJcblx0XHRzZXRNb2R1bGVDb25zdGFudChcIl9fZGlybmFtZVwiLCBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRcdFx0cmV0dXJuIHBhdGgucmVsYXRpdmUoY29udGV4dCwgbW9kdWxlLmNvbnRleHQpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cdGNvbXBpbGVyLnBhcnNlci5wbHVnaW4oXCJldmFsdWF0ZSBJZGVudGlmaWVyIF9fZGlybmFtZVwiLCBmdW5jdGlvbihleHByKSB7XHJcblx0XHRpZighdGhpcy5zdGF0ZS5tb2R1bGUpIHJldHVybjtcclxuXHRcdHZhciByZXMgPSBuZXcgQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uKCk7XHJcblx0XHRyZXMuc2V0U3RyaW5nKHRoaXMuc3RhdGUubW9kdWxlLmNvbnRleHQpO1xyXG5cdFx0cmVzLnNldFJhbmdlKGV4cHIucmFuZ2UpO1xyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9KTtcclxuXHRjb21waWxlci5wYXJzZXIucGx1Z2luKFwiZXhwcmVzc2lvbiByZXF1aXJlLm1haW5cIiwgZnVuY3Rpb24oZXhwcikge1xyXG5cdFx0dmFyIGRlcCA9IG5ldyBDb25zdERlcGVuZGVuY3koXCJfX3dlYnBhY2tfcmVxdWlyZV9fLmNbMF1cIiwgZXhwci5yYW5nZSk7XHJcblx0XHRkZXAubG9jID0gZXhwci5sb2M7XHJcblx0XHR0aGlzLnN0YXRlLmN1cnJlbnQuYWRkRGVwZW5kZW5jeShkZXApO1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSk7XHJcblx0Y29tcGlsZXIucGFyc2VyLnBsdWdpbihcImV4cHJlc3Npb24gcmVxdWlyZS5leHRlbnNpb25zXCIsIGZ1bmN0aW9uKGV4cHIpIHtcclxuXHRcdHZhciBkZXAgPSBuZXcgQ29uc3REZXBlbmRlbmN5KFwiKHZvaWQgMClcIiwgZXhwci5yYW5nZSk7XHJcblx0XHRkZXAubG9jID0gZXhwci5sb2M7XHJcblx0XHR0aGlzLnN0YXRlLmN1cnJlbnQuYWRkRGVwZW5kZW5jeShkZXApO1xyXG5cdFx0aWYoIXRoaXMuc3RhdGUubW9kdWxlKSByZXR1cm47XHJcblx0XHR0aGlzLnN0YXRlLm1vZHVsZS53YXJuaW5ncy5wdXNoKG5ldyBVbnN1cHBvcnRlZEZlYXR1cmVXYXJuaW5nKHRoaXMuc3RhdGUubW9kdWxlLCBcInJlcXVpcmUuZXh0ZW5zaW9ucyBpcyBub3Qgc3VwcG9ydGVkIGJ5IHdlYnBhY2suIFVzZSBhIGxvYWRlciBpbnN0ZWFkLlwiKSk7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9KTtcclxuXHRjb21waWxlci5wYXJzZXIucGx1Z2luKFwiZXhwcmVzc2lvbiBtb2R1bGUuZXhwb3J0c1wiLCBpZ25vcmUpO1xyXG5cdGNvbXBpbGVyLnBhcnNlci5wbHVnaW4oXCJleHByZXNzaW9uIG1vZHVsZS5sb2FkZWRcIiwgaWdub3JlKTtcclxuXHRjb21waWxlci5wYXJzZXIucGx1Z2luKFwiZXhwcmVzc2lvbiBtb2R1bGUuaWRcIiwgaWdub3JlKTtcclxuXHRjb21waWxlci5wYXJzZXIucGx1Z2luKFwiZXZhbHVhdGUgSWRlbnRpZmllciBtb2R1bGUuaG90XCIsIGZ1bmN0aW9uKGV4cHIpIHtcclxuXHRcdHJldHVybiBuZXcgQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uKCkuc2V0Qm9vbGVhbihmYWxzZSkuc2V0UmFuZ2UoZXhwci5yYW5nZSk7XHJcblx0fSk7XHJcblx0Y29tcGlsZXIucGFyc2VyLnBsdWdpbihcImV4cHJlc3Npb24gbW9kdWxlXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIG1vZHVsZUpzUGF0aCA9IHBhdGguam9pbihfX2Rpcm5hbWUsIFwiLi5cIiwgXCJidWlsZGluXCIsIFwibW9kdWxlLmpzXCIpO1xyXG5cdFx0aWYodGhpcy5zdGF0ZS5tb2R1bGUuY29udGV4dCkge1xyXG5cdFx0XHRtb2R1bGVKc1BhdGggPSBwYXRoLnJlbGF0aXZlKHRoaXMuc3RhdGUubW9kdWxlLmNvbnRleHQsIG1vZHVsZUpzUGF0aCk7XHJcblx0XHRcdGlmKCEvXltBLVpdOi9pLnRlc3QobW9kdWxlSnNQYXRoKSkge1xyXG5cdFx0XHRcdG1vZHVsZUpzUGF0aCA9IFwiLi9cIiArIG1vZHVsZUpzUGF0aC5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIE1vZHVsZVBhcnNlckhlbHBlcnMuYWRkUGFyc2VkVmFyaWFibGUodGhpcywgXCJtb2R1bGVcIiwgXCJyZXF1aXJlKFwiICsgSlNPTi5zdHJpbmdpZnkobW9kdWxlSnNQYXRoKSArIFwiKShtb2R1bGUpXCIpO1xyXG5cdH0pO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL05vZGVTdHVmZlBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBNb2R1bGVQYXJzZXJIZWxwZXJzID0gZXhwb3J0cztcclxuXHJcbk1vZHVsZVBhcnNlckhlbHBlcnMuYWRkUGFyc2VkVmFyaWFibGUgPSBmdW5jdGlvbihwYXJzZXIsIG5hbWUsIGV4cHJlc3Npb24pIHtcclxuXHRpZighcGFyc2VyLnN0YXRlLmN1cnJlbnQuYWRkVmFyaWFibGUpIHJldHVybiBmYWxzZTtcclxuXHR2YXIgZGVwcyA9IFtdO1xyXG5cdHBhcnNlci5wYXJzZShleHByZXNzaW9uLCB7XHJcblx0XHRjdXJyZW50OiB7XHJcblx0XHRcdGFkZERlcGVuZGVuY3k6IGZ1bmN0aW9uKGRlcCkge1xyXG5cdFx0XHRcdGRlcC51c2VyUmVxdWVzdCA9IG5hbWU7XHJcblx0XHRcdFx0ZGVwcy5wdXNoKGRlcCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRtb2R1bGU6IHBhcnNlci5zdGF0ZS5tb2R1bGVcclxuXHR9KTtcclxuXHRwYXJzZXIuc3RhdGUuY3VycmVudC5hZGRWYXJpYWJsZShuYW1lLCBleHByZXNzaW9uLCBkZXBzKTtcclxuXHRyZXR1cm4gdHJ1ZTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9Nb2R1bGVQYXJzZXJIZWxwZXJzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuZnVuY3Rpb24gVW5zdXBwb3J0ZWRGZWF0dXJlV2FybmluZyhtb2R1bGUsIG1lc3NhZ2UpIHtcclxuXHRFcnJvci5jYWxsKHRoaXMpO1xyXG5cdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFVuc3VwcG9ydGVkRmVhdHVyZVdhcm5pbmcpO1xyXG5cdHRoaXMubmFtZSA9IFwiVW5zdXBwb3J0ZWRGZWF0dXJlV2FybmluZ1wiO1xyXG5cdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcblx0dGhpcy5vcmlnaW4gPSB0aGlzLm1vZHVsZSA9IG1vZHVsZTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IFVuc3VwcG9ydGVkRmVhdHVyZVdhcm5pbmc7XHJcblxyXG5VbnN1cHBvcnRlZEZlYXR1cmVXYXJuaW5nLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9VbnN1cHBvcnRlZEZlYXR1cmVXYXJuaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcclxudmFyIENvbnN0RGVwZW5kZW5jeSA9IHJlcXVpcmUoXCIuL2RlcGVuZGVuY2llcy9Db25zdERlcGVuZGVuY3lcIik7XHJcblxyXG52YXIgTW9kdWxlQWxpYXNQbHVnaW4gPSByZXF1aXJlKFwiZW5oYW5jZWQtcmVzb2x2ZS9saWIvTW9kdWxlQWxpYXNQbHVnaW5cIik7XHJcblxyXG52YXIgTnVsbEZhY3RvcnkgPSByZXF1aXJlKFwiLi9OdWxsRmFjdG9yeVwiKTtcclxuXHJcbmZ1bmN0aW9uIENvbXBhdGliaWxpdHlQbHVnaW4oKSB7fVxyXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBhdGliaWxpdHlQbHVnaW47XHJcblxyXG5Db21wYXRpYmlsaXR5UGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGNvbXBpbGVyKSB7XHJcblx0Y29tcGlsZXIucGx1Z2luKFwiY29tcGlsYXRpb25cIiwgZnVuY3Rpb24oY29tcGlsYXRpb24pIHtcclxuXHRcdGNvbXBpbGF0aW9uLmRlcGVuZGVuY3lGYWN0b3JpZXMuc2V0KENvbnN0RGVwZW5kZW5jeSwgbmV3IE51bGxGYWN0b3J5KCkpO1xyXG5cdFx0Y29tcGlsYXRpb24uZGVwZW5kZW5jeVRlbXBsYXRlcy5zZXQoQ29uc3REZXBlbmRlbmN5LCBuZXcgQ29uc3REZXBlbmRlbmN5LlRlbXBsYXRlKCkpO1xyXG5cdH0pO1xyXG5cdGNvbXBpbGVyLnJlc29sdmVycy5ub3JtYWwuYXBwbHkoXHJcblx0XHRuZXcgTW9kdWxlQWxpYXNQbHVnaW4oe1xyXG5cdFx0XHRcImVuaGFuY2VkLXJlcXVpcmVcIjogcGF0aC5qb2luKF9fZGlybmFtZSwgXCIuLlwiLCBcImJ1aWxkaW5cIiwgXCJyZXR1cm4tcmVxdWlyZS5qc1wiKVxyXG5cdFx0fSlcclxuXHQpO1xyXG5cdGNvbXBpbGVyLnBhcnNlci5wbHVnaW4oXCJjYWxsIHJlcXVpcmVcIiwgZnVuY3Rpb24oZXhwcikge1xyXG5cdFx0Ly8gc3VwcG9ydCBmb3IgYnJvd3NlcmlmeSBzdHlsZSByZXF1aXJlIGRlbGVnYXRvcjogXCJyZXF1aXJlKG8sICEwKVwiXHJcblx0XHRpZihleHByLmFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHJldHVybjtcclxuXHRcdHZhciBzZWNvbmQgPSB0aGlzLmV2YWx1YXRlRXhwcmVzc2lvbihleHByLmFyZ3VtZW50c1sxXSk7XHJcblx0XHRpZighc2Vjb25kLmlzQm9vbGVhbigpKSByZXR1cm47XHJcblx0XHRpZihzZWNvbmQuYXNCb29sKCkgIT09IHRydWUpIHJldHVybjtcclxuXHRcdHZhciBkZXAgPSBuZXcgQ29uc3REZXBlbmRlbmN5KFwicmVxdWlyZVwiLCBleHByLmNhbGxlZS5yYW5nZSk7XHJcblx0XHRkZXAubG9jID0gZXhwci5sb2M7XHJcblx0XHRpZih0aGlzLnN0YXRlLmN1cnJlbnQuZGVwZW5kZW5jaWVzLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0dmFyIGxhc3QgPSB0aGlzLnN0YXRlLmN1cnJlbnQuZGVwZW5kZW5jaWVzW3RoaXMuc3RhdGUuY3VycmVudC5kZXBlbmRlbmNpZXMubGVuZ3RoIC0gMV07XHJcblx0XHRcdGlmKGxhc3QuY3JpdGljYWwgJiYgbGFzdC5yZXF1ZXN0ID09PSBcIi5cIiAmJiBsYXN0LnVzZXJSZXF1ZXN0ID09PSBcIi5cIiAmJiBsYXN0LnJlY3Vyc2l2ZSlcclxuXHRcdFx0XHR0aGlzLnN0YXRlLmN1cnJlbnQuZGVwZW5kZW5jaWVzLnBvcCgpO1xyXG5cdFx0fVxyXG5cdFx0ZGVwLmNyaXRpY2FsID0gXCJUaGlzIHNlZW1zIHRvIGJlIGEgcHJlLWJ1aWx0IGphdmFzY3JpcHQgZmlsZS4gVGhvdWdoIHRoaXMgaXMgcG9zc2libGUsIGl0J3Mgbm90IHJlY29tbWVuZGVkLiBUcnkgdG8gcmVxdWlyZSB0aGUgb3JpZ2luYWwgc291cmNlIHRvIGdldCBiZXR0ZXIgcmVzdWx0cy5cIjtcclxuXHRcdHRoaXMuc3RhdGUuY3VycmVudC5hZGREZXBlbmRlbmN5KGRlcCk7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9KTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9Db21wYXRpYmlsaXR5UGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIGNyZWF0ZUlubmVyQ2FsbGJhY2sgPSByZXF1aXJlKFwiLi9jcmVhdGVJbm5lckNhbGxiYWNrXCIpO1xyXG5cclxuZnVuY3Rpb24gTW9kdWxlQWxpYXNQbHVnaW4oYWxpYXNNYXApIHtcclxuXHR0aGlzLmFsaWFzTWFwID0gYWxpYXNNYXA7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBNb2R1bGVBbGlhc1BsdWdpbjtcclxuXHJcbk1vZHVsZUFsaWFzUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKHJlc29sdmVyKSB7XHJcblx0dmFyIGFsaWFzTWFwID0gdGhpcy5hbGlhc01hcDtcclxuXHRyZXNvbHZlci5wbHVnaW4oXCJtb2R1bGVcIiwgZnVuY3Rpb24ocmVxdWVzdCwgY2FsbGJhY2spIHtcclxuXHRcdHZhciBmcyA9IHRoaXMuZmlsZVN5c3RlbTtcclxuXHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWxpYXNNYXApO1xyXG5cdFx0dmFyIGkgPSAwO1xyXG5cdFx0KGZ1bmN0aW9uIG5leHQoKSB7XHJcblx0XHRcdGZvcig7aSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHR2YXIgYWxpYXNOYW1lID0ga2V5c1tpXTtcclxuXHRcdFx0XHR2YXIgb25seU1vZHVsZSA9IC9cXCQkLy50ZXN0KGFsaWFzTmFtZSk7XHJcblx0XHRcdFx0aWYob25seU1vZHVsZSkgYWxpYXNOYW1lID0gYWxpYXNOYW1lLnN1YnN0cigwLCBhbGlhc05hbWUubGVuZ3RoLTEpO1xyXG5cdFx0XHRcdGlmKCghb25seU1vZHVsZSAmJiByZXF1ZXN0LnJlcXVlc3QuaW5kZXhPZihhbGlhc05hbWUgKyBcIi9cIikgPT09IDApIHx8IHJlcXVlc3QucmVxdWVzdCA9PT0gYWxpYXNOYW1lKSB7XHJcblx0XHRcdFx0XHR2YXIgYWxpYXNWYWx1ZSA9IGFsaWFzTWFwW2tleXNbaV1dO1xyXG5cdFx0XHRcdFx0aWYocmVxdWVzdC5yZXF1ZXN0LmluZGV4T2YoYWxpYXNWYWx1ZSArIFwiL1wiKSAhPT0gMCAmJiByZXF1ZXN0LnJlcXVlc3QgIT0gYWxpYXNWYWx1ZSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgbmV3UmVxdWVzdFN0ciA9IGFsaWFzVmFsdWUgKyByZXF1ZXN0LnJlcXVlc3Quc3Vic3RyKGFsaWFzTmFtZS5sZW5ndGgpO1xyXG5cdFx0XHRcdFx0XHR2YXIgbmV3UmVxdWVzdCA9IHRoaXMucGFyc2UobmV3UmVxdWVzdFN0cik7XHJcblx0XHRcdFx0XHRcdHZhciBvYmogPSB7XHJcblx0XHRcdFx0XHRcdFx0cGF0aDogcmVxdWVzdC5wYXRoLFxyXG5cdFx0XHRcdFx0XHRcdHJlcXVlc3Q6IG5ld1JlcXVlc3QucGF0aCxcclxuXHRcdFx0XHRcdFx0XHRxdWVyeTogbmV3UmVxdWVzdC5xdWVyeSxcclxuXHRcdFx0XHRcdFx0XHRkaXJlY3Rvcnk6IG5ld1JlcXVlc3QuZGlyZWN0b3J5XHJcblx0XHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHRcdHZhciBuZXdDYWxsYmFjayA9IGNyZWF0ZUlubmVyQ2FsbGJhY2soY2FsbGJhY2ssIGNhbGxiYWNrLCBcImFsaWFzZWQgd2l0aCBtYXBwaW5nIFwiICsgSlNPTi5zdHJpbmdpZnkoYWxpYXNOYW1lKSArIFwiOiBcIiArIEpTT04uc3RyaW5naWZ5KGFsaWFzVmFsdWUpICsgXCIgdG8gXCIgKyBuZXdSZXF1ZXN0U3RyKTtcclxuXHRcdFx0XHRcdFx0aWYobmV3UmVxdWVzdC5tb2R1bGUpIHJldHVybiB0aGlzLmRvUmVzb2x2ZShcIm1vZHVsZVwiLCBvYmosIG5ld0NhbGxiYWNrKTtcclxuXHRcdFx0XHRcdFx0aWYobmV3UmVxdWVzdC5kaXJlY3RvcnkpIHJldHVybiB0aGlzLmRvUmVzb2x2ZShcImRpcmVjdG9yeVwiLCBvYmosIG5ld0NhbGxiYWNrKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuZG9SZXNvbHZlKFtcImZpbGVcIiwgXCJkaXJlY3RvcnlcIl0sIG9iaiwgbmV3Q2FsbGJhY2spO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gY2FsbGJhY2soKTtcclxuXHRcdH0uY2FsbCh0aGlzKSk7XHJcblx0fSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbmhhbmNlZC1yZXNvbHZlL2xpYi9Nb2R1bGVBbGlhc1BsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBDb25zdERlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9kZXBlbmRlbmNpZXMvQ29uc3REZXBlbmRlbmN5XCIpO1xyXG52YXIgQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uID0gcmVxdWlyZShcIi4vQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uXCIpO1xyXG5cclxudmFyIE51bGxGYWN0b3J5ID0gcmVxdWlyZShcIi4vTnVsbEZhY3RvcnlcIik7XHJcblxyXG5mdW5jdGlvbiBEZWZpbmVQbHVnaW4oZGVmaW5pdGlvbnMpIHtcclxuXHR0aGlzLmRlZmluaXRpb25zID0gZGVmaW5pdGlvbnM7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBEZWZpbmVQbHVnaW47XHJcbkRlZmluZVBsdWdpbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbihjb21waWxlcikge1xyXG5cdGNvbXBpbGVyLnBsdWdpbihcImNvbXBpbGF0aW9uXCIsIGZ1bmN0aW9uKGNvbXBpbGF0aW9uKSB7XHJcblx0XHRjb21waWxhdGlvbi5kZXBlbmRlbmN5RmFjdG9yaWVzLnNldChDb25zdERlcGVuZGVuY3ksIG5ldyBOdWxsRmFjdG9yeSgpKTtcclxuXHRcdGNvbXBpbGF0aW9uLmRlcGVuZGVuY3lUZW1wbGF0ZXMuc2V0KENvbnN0RGVwZW5kZW5jeSwgbmV3IENvbnN0RGVwZW5kZW5jeS5UZW1wbGF0ZSgpKTtcclxuXHR9KTtcclxuXHQoZnVuY3Rpb24gd2Fsa0RlZmluaXRpb25zKGRlZmluaXRpb25zLCBwcmVmaXgpIHtcclxuXHRcdE9iamVjdC5rZXlzKGRlZmluaXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG5cdFx0XHR2YXIgY29kZSA9IGRlZmluaXRpb25zW2tleV07XHJcblx0XHRcdGlmKGNvZGUgJiYgdHlwZW9mIGNvZGUgPT09IFwib2JqZWN0XCIgJiYgIShjb2RlIGluc3RhbmNlb2YgUmVnRXhwKSkge1xyXG5cdFx0XHRcdHdhbGtEZWZpbml0aW9ucyhjb2RlLCBwcmVmaXggKyBrZXkgKyBcIi5cIik7XHJcblx0XHRcdFx0YXBwbHlPYmplY3REZWZpbmUocHJlZml4ICsga2V5LCBjb2RlKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0YXBwbHlEZWZpbmVLZXkocHJlZml4LCBrZXkpO1xyXG5cdFx0XHRhcHBseURlZmluZShwcmVmaXggKyBrZXksIGNvZGUpO1xyXG5cdFx0fSk7XHJcblx0fSh0aGlzLmRlZmluaXRpb25zLCBcIlwiKSk7XHJcblxyXG5cdGZ1bmN0aW9uIHN0cmluZ2lmeU9iaihvYmopIHtcclxuXHRcdHJldHVybiBcIntcIiArIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uKGtleSkge1xyXG5cdFx0XHR2YXIgY29kZSA9IG9ialtrZXldO1xyXG5cdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoa2V5KSArIFwiOlwiICsgdG9Db2RlKGNvZGUpO1xyXG5cdFx0fSkuam9pbihcIixcIikgKyBcIn1cIjtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRvQ29kZShjb2RlKSB7XHJcblx0XHRpZihjb2RlID09PSBudWxsKSByZXR1cm4gXCJudWxsXCI7XHJcblx0XHRlbHNlIGlmKGNvZGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFwidW5kZWZpbmVkXCI7XHJcblx0XHRlbHNlIGlmKGNvZGUgaW5zdGFuY2VvZiBSZWdFeHAgJiYgY29kZS50b1N0cmluZykgcmV0dXJuIGNvZGUudG9TdHJpbmcoKTtcclxuXHRcdGVsc2UgaWYodHlwZW9mIGNvZGUgPT09IFwiZnVuY3Rpb25cIiAmJiBjb2RlLnRvU3RyaW5nKSByZXR1cm4gY29kZS50b1N0cmluZygpO1xyXG5cdFx0ZWxzZSBpZih0eXBlb2YgY29kZSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIHN0cmluZ2lmeU9iaihjb2RlKTtcclxuXHRcdGVsc2UgcmV0dXJuIGNvZGUgKyBcIlwiO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gYXBwbHlEZWZpbmVLZXkocHJlZml4LCBrZXkpIHtcclxuXHRcdHZhciBzcGxpdHRlZEtleSA9IGtleS5zcGxpdChcIi5cIik7XHJcblx0XHRzcGxpdHRlZEtleS5zbGljZSgxKS5mb3JFYWNoKGZ1bmN0aW9uKF8sIGkpIHtcclxuXHRcdFx0dmFyIGZ1bGxLZXkgPSBwcmVmaXggKyBzcGxpdHRlZEtleS5zbGljZSgwLCBpICsgMSkuam9pbihcIi5cIik7XHJcblx0XHRcdGNvbXBpbGVyLnBhcnNlci5wbHVnaW4oXCJjYW4tcmVuYW1lIFwiICsgZnVsbEtleSwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBhcHBseURlZmluZShrZXksIGNvZGUpIHtcclxuXHRcdHZhciBpc1R5cGVvZiA9IC9edHlwZW9mXFxzKy8udGVzdChrZXkpO1xyXG5cdFx0aWYoaXNUeXBlb2YpIGtleSA9IGtleS5yZXBsYWNlKC9edHlwZW9mXFxzKy8sIFwiXCIpO1xyXG5cdFx0dmFyIHJlY3Vyc2UgPSBmYWxzZTtcclxuXHRcdHZhciByZWN1cnNlVHlwZW9mID0gZmFsc2U7XHJcblx0XHRjb2RlID0gdG9Db2RlKGNvZGUpO1xyXG5cdFx0aWYoIWlzVHlwZW9mKSB7XHJcblx0XHRcdGNvbXBpbGVyLnBhcnNlci5wbHVnaW4oXCJjYW4tcmVuYW1lIFwiICsga2V5LCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGNvbXBpbGVyLnBhcnNlci5wbHVnaW4oXCJldmFsdWF0ZSBJZGVudGlmaWVyIFwiICsga2V5LCBmdW5jdGlvbihleHByKSB7XHJcblx0XHRcdFx0aWYocmVjdXJzZSkgcmV0dXJuO1xyXG5cdFx0XHRcdHJlY3Vyc2UgPSB0cnVlO1xyXG5cdFx0XHRcdHZhciByZXMgPSBjb21waWxlci5wYXJzZXIuZXZhbHVhdGUoY29kZSk7XHJcblx0XHRcdFx0cmVjdXJzZSA9IGZhbHNlO1xyXG5cdFx0XHRcdHJlcy5zZXRSYW5nZShleHByLnJhbmdlKTtcclxuXHRcdFx0XHRyZXR1cm4gcmVzO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0Y29tcGlsZXIucGFyc2VyLnBsdWdpbihcImV4cHJlc3Npb24gXCIgKyBrZXksIGZ1bmN0aW9uKGV4cHIpIHtcclxuXHRcdFx0XHR2YXIgZGVwID0gbmV3IENvbnN0RGVwZW5kZW5jeShcIihcIiArIGNvZGUgKyBcIilcIiwgZXhwci5yYW5nZSk7XHJcblx0XHRcdFx0ZGVwLmxvYyA9IGV4cHIubG9jO1xyXG5cdFx0XHRcdHRoaXMuc3RhdGUuY3VycmVudC5hZGREZXBlbmRlbmN5KGRlcCk7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdFx0dmFyIHR5cGVvZkNvZGUgPSBpc1R5cGVvZiA/IGNvZGUgOiBcInR5cGVvZiAoXCIgKyBjb2RlICsgXCIpXCI7XHJcblx0XHRjb21waWxlci5wYXJzZXIucGx1Z2luKFwiZXZhbHVhdGUgdHlwZW9mIFwiICsga2V5LCBmdW5jdGlvbihleHByKSB7XHJcblx0XHRcdGlmKHJlY3Vyc2VUeXBlb2YpIHJldHVybjtcclxuXHRcdFx0cmVjdXJzZVR5cGVvZiA9IHRydWU7XHJcblx0XHRcdHZhciByZXMgPSBjb21waWxlci5wYXJzZXIuZXZhbHVhdGUodHlwZW9mQ29kZSk7XHJcblx0XHRcdHJlY3Vyc2VUeXBlb2YgPSBmYWxzZTtcclxuXHRcdFx0cmVzLnNldFJhbmdlKGV4cHIucmFuZ2UpO1xyXG5cdFx0XHRyZXR1cm4gcmVzO1xyXG5cdFx0fSk7XHJcblx0XHRjb21waWxlci5wYXJzZXIucGx1Z2luKFwidHlwZW9mIFwiICsga2V5LCBmdW5jdGlvbihleHByKSB7XHJcblx0XHRcdHZhciByZXMgPSBjb21waWxlci5wYXJzZXIuZXZhbHVhdGUodHlwZW9mQ29kZSk7XHJcblx0XHRcdGlmKCFyZXMuaXNTdHJpbmcoKSkgcmV0dXJuO1xyXG5cdFx0XHR2YXIgZGVwID0gbmV3IENvbnN0RGVwZW5kZW5jeShKU09OLnN0cmluZ2lmeShyZXMuc3RyaW5nKSwgZXhwci5yYW5nZSk7XHJcblx0XHRcdGRlcC5sb2MgPSBleHByLmxvYztcclxuXHRcdFx0dGhpcy5zdGF0ZS5jdXJyZW50LmFkZERlcGVuZGVuY3koZGVwKTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGFwcGx5T2JqZWN0RGVmaW5lKGtleSwgb2JqKSB7XHJcblx0XHR2YXIgY29kZSA9IHN0cmluZ2lmeU9iaihvYmopO1xyXG5cdFx0Y29tcGlsZXIucGFyc2VyLnBsdWdpbihcImNhbi1yZW5hbWUgXCIgKyBrZXksIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0pO1xyXG5cdFx0Y29tcGlsZXIucGFyc2VyLnBsdWdpbihcImV2YWx1YXRlIElkZW50aWZpZXIgXCIgKyBrZXksIGZ1bmN0aW9uKGV4cHIpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBCYXNpY0V2YWx1YXRlZEV4cHJlc3Npb24oKS5zZXRSYW5nZShleHByLnJhbmdlKTtcclxuXHRcdH0pO1xyXG5cdFx0Y29tcGlsZXIucGFyc2VyLnBsdWdpbihcImV2YWx1YXRlIHR5cGVvZiBcIiArIGtleSwgZnVuY3Rpb24oZXhwcikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IEJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbigpLnNldFN0cmluZyhcIm9iamVjdFwiKS5zZXRSYW5nZShleHByLnJhbmdlKTtcclxuXHRcdH0pO1xyXG5cdFx0Y29tcGlsZXIucGFyc2VyLnBsdWdpbihcImV4cHJlc3Npb24gXCIgKyBrZXksIGZ1bmN0aW9uKGV4cHIpIHtcclxuXHRcdFx0dmFyIGRlcCA9IG5ldyBDb25zdERlcGVuZGVuY3koXCIoXCIgKyBjb2RlICsgXCIpXCIsIGV4cHIucmFuZ2UpO1xyXG5cdFx0XHRkZXAubG9jID0gZXhwci5sb2M7XHJcblx0XHRcdHRoaXMuc3RhdGUuY3VycmVudC5hZGREZXBlbmRlbmN5KGRlcCk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSk7XHJcblx0XHRjb21waWxlci5wYXJzZXIucGx1Z2luKFwidHlwZW9mIFwiICsga2V5LCBmdW5jdGlvbihleHByKSB7XHJcblx0XHRcdHZhciBkZXAgPSBuZXcgQ29uc3REZXBlbmRlbmN5KFwiXFxcIm9iamVjdFxcXCJcIiwgZXhwci5yYW5nZSk7XHJcblx0XHRcdGRlcC5sb2MgPSBleHByLmxvYztcclxuXHRcdFx0dGhpcy5zdGF0ZS5jdXJyZW50LmFkZERlcGVuZGVuY3koZGVwKTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9KTtcclxuXHR9XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvRGVmaW5lUGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuZnVuY3Rpb24gTW92ZWRUb1BsdWdpbldhcm5pbmdQbHVnaW4ob3B0aW9uTmFtZSwgcGx1Z2luTmFtZSkge1xyXG5cdHRoaXMub3B0aW9uTmFtZSA9IG9wdGlvbk5hbWU7XHJcblx0dGhpcy5wbHVnaW5OYW1lID0gcGx1Z2luTmFtZTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IE1vdmVkVG9QbHVnaW5XYXJuaW5nUGx1Z2luO1xyXG5cclxuTW92ZWRUb1BsdWdpbldhcm5pbmdQbHVnaW4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oY29tcGlsZXIpIHtcclxuXHR2YXIgb3B0aW9uTmFtZSA9IHRoaXMub3B0aW9uTmFtZTtcclxuXHR2YXIgcGx1Z2luTmFtZSA9IHRoaXMucGx1Z2luTmFtZTtcclxuXHRjb21waWxlci5wbHVnaW4oXCJjb21waWxhdGlvblwiLCBmdW5jdGlvbihjb21waWxhdGlvbikge1xyXG5cdFx0Y29tcGlsYXRpb24ud2FybmluZ3MucHVzaChuZXcgRXJyb3IoXCJ3ZWJwYWNrIG9wdGlvbnM6XFxuREVQUkVDQVRFRCBvcHRpb24gJ1wiICsgb3B0aW9uTmFtZSArIFwiJyB3aWxsIGJlIG1vdmVkIHRvIHRoZSBcIiArIHBsdWdpbk5hbWUgKyBcIi4gVXNlIHRoaXMgaW5zdGVhZC5cXG5Gb3IgbW9yZSBpbmZvIGFib3V0IHRoZSB1c2FnZSBvZiB0aGUgXCIgKyBwbHVnaW5OYW1lICsgXCIgc2VlIGh0dHBzOi8vd2VicGFjay5naXRodWIuaW8vZG9jcy9saXN0LW9mLXBsdWdpbnMuaHRtbFwiKSk7XHJcblx0fSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvTW92ZWRUb1BsdWdpbldhcm5pbmdQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDExN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIEphc29uIEFuZGVyc29uIEBkaXVybmFsaXN0XHJcbiovXHJcblxyXG52YXIgUkVHRVhQX0hBU0ggPSAvXFxbaGFzaCg/OjooXFxkKykpP1xcXS9naSxcclxuXHRSRUdFWFBfQ0hVTktIQVNIID0gL1xcW2NodW5raGFzaCg/OjooXFxkKykpP1xcXS9naSxcclxuXHRSRUdFWFBfTkFNRSA9IC9cXFtuYW1lXFxdL2dpLFxyXG5cdFJFR0VYUF9JRCA9IC9cXFtpZFxcXS9naSxcclxuXHRSRUdFWFBfRklMRSA9IC9cXFtmaWxlXFxdL2dpLFxyXG5cdFJFR0VYUF9RVUVSWSA9IC9cXFtxdWVyeVxcXS9naSxcclxuXHRSRUdFWFBfRklMRUJBU0UgPSAvXFxbZmlsZWJhc2VcXF0vZ2k7XHJcblxyXG4vLyBVc2luZyBnbG9iYWwgUmVnRXhwIGZvciAudGVzdCBpcyBkYW5nZXJvdXNcclxuLy8gV2UgdXNlIGEgbm9ybWFsIFJlZ0V4cCBpbnN0ZWFkIG9mIC50ZXN0XHJcbnZhciBSRUdFWFBfSEFTSF9GT1JfVEVTVCA9IG5ldyBSZWdFeHAoUkVHRVhQX0hBU0guc291cmNlLCBcImlcIiksXHJcblx0UkVHRVhQX0NIVU5LSEFTSF9GT1JfVEVTVCA9IG5ldyBSZWdFeHAoUkVHRVhQX0NIVU5LSEFTSC5zb3VyY2UsIFwiaVwiKSxcclxuXHRSRUdFWFBfTkFNRV9GT1JfVEVTVCA9IG5ldyBSZWdFeHAoUkVHRVhQX05BTUUuc291cmNlLCBcImlcIik7XHJcblxyXG4vLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eTsgZXhwb3NlIHJlZ2V4ZXMgb24gVGVtcGxhdGUgb2JqZWN0XHJcbnZhciBUZW1wbGF0ZSA9IHJlcXVpcmUoXCIuL1RlbXBsYXRlXCIpO1xyXG5UZW1wbGF0ZS5SRUdFWFBfSEFTSCA9IFJFR0VYUF9IQVNIO1xyXG5UZW1wbGF0ZS5SRUdFWFBfQ0hVTktIQVNIID0gUkVHRVhQX0NIVU5LSEFTSDtcclxuVGVtcGxhdGUuUkVHRVhQX05BTUUgPSBSRUdFWFBfTkFNRTtcclxuVGVtcGxhdGUuUkVHRVhQX0lEID0gUkVHRVhQX0lEO1xyXG5UZW1wbGF0ZS5SRUdFWFBfRklMRSA9IFJFR0VYUF9GSUxFO1xyXG5UZW1wbGF0ZS5SRUdFWFBfUVVFUlkgPSBSRUdFWFBfUVVFUlk7XHJcblRlbXBsYXRlLlJFR0VYUF9GSUxFQkFTRSA9IFJFR0VYUF9GSUxFQkFTRTtcclxuXHJcbmZ1bmN0aW9uIFRlbXBsYXRlZFBhdGhQbHVnaW4oKSB7fVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUZW1wbGF0ZWRQYXRoUGx1Z2luO1xyXG5cclxuZnVuY3Rpb24gd2l0aEhhc2hMZW5ndGgocmVwbGFjZXIsIGhhbmRsZXJGbikge1xyXG5cdHJldHVybiBmdW5jdGlvbihfLCBoYXNoTGVuZ3RoKSB7XHJcblx0XHR2YXIgbGVuZ3RoID0gaGFzaExlbmd0aCAmJiBwYXJzZUludChoYXNoTGVuZ3RoLCAxMCk7XHJcblx0XHRpZihsZW5ndGggJiYgaGFuZGxlckZuKSB7XHJcblx0XHRcdHJldHVybiBoYW5kbGVyRm4obGVuZ3RoKTtcclxuXHRcdH1cclxuXHRcdHZhciBoYXNoID0gcmVwbGFjZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdHJldHVybiBsZW5ndGggPyBoYXNoLnNsaWNlKDAsIGxlbmd0aCkgOiBoYXNoO1xyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFJlcGxhY2VyKHZhbHVlLCBhbGxvd0VtcHR5KSB7XHJcblx0cmV0dXJuIGZ1bmN0aW9uKG1hdGNoKSB7XHJcblx0XHQvLyBsYXN0IGFyZ3VtZW50IGluIHJlcGxhY2VyIGlzIHRoZSBlbnRpcmUgaW5wdXQgc3RyaW5nXHJcblx0XHR2YXIgaW5wdXQgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xyXG5cdFx0aWYodmFsdWUgPT0gbnVsbCkge1xyXG5cdFx0XHRpZighYWxsb3dFbXB0eSkgdGhyb3cgbmV3IEVycm9yKFwiUGF0aCB2YXJpYWJsZSBcIiArIG1hdGNoICsgXCIgbm90IGltcGxlbWVudGVkIGluIHRoaXMgY29udGV4dDogXCIgKyBpbnB1dCk7XHJcblx0XHRcdHJldHVybiBcIlwiO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIFwiXCIgKyB2YWx1ZTtcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZXBsYWNlUGF0aFZhcmlhYmxlcyhwYXRoLCBkYXRhKSB7XHJcblx0dmFyIGNodW5rID0gZGF0YS5jaHVuaztcclxuXHR2YXIgY2h1bmtJZCA9IGNodW5rICYmIGNodW5rLmlkO1xyXG5cdHZhciBjaHVua05hbWUgPSBjaHVuayAmJiAoY2h1bmsubmFtZSB8fCBjaHVuay5pZCk7XHJcblx0dmFyIGNodW5rSGFzaCA9IGNodW5rICYmIChjaHVuay5yZW5kZXJlZEhhc2ggfHwgY2h1bmsuaGFzaCk7XHJcblx0dmFyIGNodW5rSGFzaFdpdGhMZW5ndGggPSBjaHVuayAmJiBjaHVuay5oYXNoV2l0aExlbmd0aDtcclxuXHJcblx0aWYoZGF0YS5ub0NodW5rSGFzaCAmJiBSRUdFWFBfQ0hVTktIQVNIX0ZPUl9URVNULnRlc3QocGF0aCkpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgW2NodW5raGFzaF0gZm9yIGNodW5rIGluICdcIiArIHBhdGggKyBcIicgKHVzZSBbaGFzaF0gaW5zdGVhZClcIik7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcGF0aFxyXG5cdFx0LnJlcGxhY2UoUkVHRVhQX0hBU0gsIHdpdGhIYXNoTGVuZ3RoKGdldFJlcGxhY2VyKGRhdGEuaGFzaCksIGRhdGEuaGFzaFdpdGhMZW5ndGgpKVxyXG5cdFx0LnJlcGxhY2UoUkVHRVhQX0NIVU5LSEFTSCwgd2l0aEhhc2hMZW5ndGgoZ2V0UmVwbGFjZXIoY2h1bmtIYXNoKSwgY2h1bmtIYXNoV2l0aExlbmd0aCkpXHJcblx0XHQucmVwbGFjZShSRUdFWFBfSUQsIGdldFJlcGxhY2VyKGNodW5rSWQpKVxyXG5cdFx0LnJlcGxhY2UoUkVHRVhQX05BTUUsIGdldFJlcGxhY2VyKGNodW5rTmFtZSkpXHJcblx0XHQucmVwbGFjZShSRUdFWFBfRklMRSwgZ2V0UmVwbGFjZXIoZGF0YS5maWxlbmFtZSkpXHJcblx0XHQucmVwbGFjZShSRUdFWFBfRklMRUJBU0UsIGdldFJlcGxhY2VyKGRhdGEuYmFzZW5hbWUpKVxyXG5cdFx0Ly8gcXVlcnkgaXMgb3B0aW9uYWwsIGl0J3MgT0sgaWYgaXQncyBpbiBhIHBhdGggYnV0IHRoZXJlJ3Mgbm90aGluZyB0byByZXBsYWNlIGl0IHdpdGhcclxuXHRcdC5yZXBsYWNlKFJFR0VYUF9RVUVSWSwgZ2V0UmVwbGFjZXIoZGF0YS5xdWVyeSwgdHJ1ZSkpO1xyXG59XHJcblxyXG5UZW1wbGF0ZWRQYXRoUGx1Z2luLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRlbXBsYXRlZFBhdGhQbHVnaW47XHJcblRlbXBsYXRlZFBhdGhQbHVnaW4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oY29tcGlsZXIpIHtcclxuXHRjb21waWxlci5wbHVnaW4oXCJjb21waWxhdGlvblwiLCBmdW5jdGlvbihjb21waWxhdGlvbikge1xyXG5cdFx0dmFyIG1haW5UZW1wbGF0ZSA9IGNvbXBpbGF0aW9uLm1haW5UZW1wbGF0ZTtcclxuXHJcblx0XHRtYWluVGVtcGxhdGUucGx1Z2luKFwiYXNzZXQtcGF0aFwiLCByZXBsYWNlUGF0aFZhcmlhYmxlcyk7XHJcblxyXG5cdFx0bWFpblRlbXBsYXRlLnBsdWdpbihcImdsb2JhbC1oYXNoXCIsIGZ1bmN0aW9uKGNodW5rLCBwYXRocykge1xyXG5cdFx0XHR2YXIgb3V0cHV0T3B0aW9ucyA9IHRoaXMub3V0cHV0T3B0aW9ucztcclxuXHRcdFx0dmFyIHB1YmxpY1BhdGggPSBvdXRwdXRPcHRpb25zLnB1YmxpY1BhdGggfHwgXCJcIjtcclxuXHRcdFx0dmFyIGZpbGVuYW1lID0gb3V0cHV0T3B0aW9ucy5maWxlbmFtZSB8fCBcIlwiO1xyXG5cdFx0XHR2YXIgY2h1bmtGaWxlbmFtZSA9IG91dHB1dE9wdGlvbnMuY2h1bmtGaWxlbmFtZSB8fCBvdXRwdXRPcHRpb25zLmZpbGVuYW1lO1xyXG5cdFx0XHRpZihSRUdFWFBfSEFTSF9GT1JfVEVTVC50ZXN0KHB1YmxpY1BhdGgpIHx8IFJFR0VYUF9DSFVOS0hBU0hfRk9SX1RFU1QudGVzdChwdWJsaWNQYXRoKSB8fCBSRUdFWFBfTkFNRV9GT1JfVEVTVC50ZXN0KHB1YmxpY1BhdGgpKVxyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRpZihSRUdFWFBfSEFTSF9GT1JfVEVTVC50ZXN0KGZpbGVuYW1lKSlcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0aWYoUkVHRVhQX0hBU0hfRk9SX1RFU1QudGVzdChjaHVua0ZpbGVuYW1lKSlcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0aWYoUkVHRVhQX0hBU0hfRk9SX1RFU1QudGVzdChwYXRocy5qb2luKFwifFwiKSkpXHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9KTtcclxuXHJcblx0XHRtYWluVGVtcGxhdGUucGx1Z2luKFwiaGFzaC1mb3ItY2h1bmtcIiwgZnVuY3Rpb24oaGFzaCwgY2h1bmspIHtcclxuXHRcdFx0dmFyIG91dHB1dE9wdGlvbnMgPSB0aGlzLm91dHB1dE9wdGlvbnM7XHJcblx0XHRcdHZhciBjaHVua0ZpbGVuYW1lID0gb3V0cHV0T3B0aW9ucy5jaHVua0ZpbGVuYW1lIHx8IG91dHB1dE9wdGlvbnMuZmlsZW5hbWU7XHJcblx0XHRcdGlmKFJFR0VYUF9DSFVOS0hBU0hfRk9SX1RFU1QudGVzdChjaHVua0ZpbGVuYW1lKSlcclxuXHRcdFx0XHRoYXNoLnVwZGF0ZShKU09OLnN0cmluZ2lmeShjaHVuay5nZXRDaHVua01hcHModHJ1ZSwgdHJ1ZSkuaGFzaCkpO1xyXG5cdFx0XHRpZihSRUdFWFBfTkFNRV9GT1JfVEVTVC50ZXN0KGNodW5rRmlsZW5hbWUpKVxyXG5cdFx0XHRcdGhhc2gudXBkYXRlKEpTT04uc3RyaW5naWZ5KGNodW5rLmdldENodW5rTWFwcyh0cnVlLCB0cnVlKS5uYW1lKSk7XHJcblx0XHR9KTtcclxuXHR9KTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9UZW1wbGF0ZWRQYXRoUGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSAxMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIENhc2VTZW5zaXRpdmVNb2R1bGVzV2FybmluZyA9IHJlcXVpcmUoXCIuL0Nhc2VTZW5zaXRpdmVNb2R1bGVzV2FybmluZ1wiKTtcclxuXHJcbmZ1bmN0aW9uIFdhcm5DYXNlU2Vuc2l0aXZlTW9kdWxlc1BsdWdpbigpIHt9XHJcbm1vZHVsZS5leHBvcnRzID0gV2FybkNhc2VTZW5zaXRpdmVNb2R1bGVzUGx1Z2luO1xyXG5cclxuV2FybkNhc2VTZW5zaXRpdmVNb2R1bGVzUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGNvbXBpbGVyKSB7XHJcblx0Y29tcGlsZXIucGx1Z2luKFwiY29tcGlsYXRpb25cIiwgZnVuY3Rpb24oY29tcGlsYXRpb24pIHtcclxuXHRcdGNvbXBpbGF0aW9uLnBsdWdpbihcInNlYWxcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciBtb2R1bGVXaXRob3V0Q2FzZSA9IHt9O1xyXG5cdFx0XHR0aGlzLm1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRcdFx0XHR2YXIgaWRlbnQgPSBtb2R1bGUuaWRlbnRpZmllcigpLnRvTG93ZXJDYXNlKCk7XHJcblx0XHRcdFx0aWYobW9kdWxlV2l0aG91dENhc2VbXCIkXCIgKyBpZGVudF0pIHtcclxuXHRcdFx0XHRcdGlmKG1vZHVsZVdpdGhvdXRDYXNlW1wiJFwiICsgaWRlbnRdICE9PSB0cnVlKVxyXG5cdFx0XHRcdFx0XHR0aGlzLndhcm5pbmdzLnB1c2gobmV3IENhc2VTZW5zaXRpdmVNb2R1bGVzV2FybmluZyhtb2R1bGVXaXRob3V0Q2FzZVtcIiRcIiArIGlkZW50XSkpO1xyXG5cdFx0XHRcdFx0dGhpcy53YXJuaW5ncy5wdXNoKG5ldyBDYXNlU2Vuc2l0aXZlTW9kdWxlc1dhcm5pbmcobW9kdWxlKSk7XHJcblx0XHRcdFx0XHRtb2R1bGVXaXRob3V0Q2FzZVtcIiRcIiArIGlkZW50XSA9IHRydWU7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdG1vZHVsZVdpdGhvdXRDYXNlW1wiJFwiICsgaWRlbnRdID0gbW9kdWxlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSwgdGhpcyk7XHJcblx0XHR9KTtcclxuXHR9KTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9XYXJuQ2FzZVNlbnNpdGl2ZU1vZHVsZXNQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDExOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5mdW5jdGlvbiBDYXNlU2Vuc2l0aXZlTW9kdWxlc1dhcm5pbmcobW9kdWxlKSB7XHJcblx0RXJyb3IuY2FsbCh0aGlzKTtcclxuXHRFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDYXNlU2Vuc2l0aXZlTW9kdWxlc1dhcm5pbmcpO1xyXG5cdHRoaXMubmFtZSA9IFwiQ2FzZVNlbnNpdGl2ZU1vZHVsZXNXYXJuaW5nXCI7XHJcblx0dGhpcy5tZXNzYWdlID0gXCJUaGVyZSBpcyBhbm90aGVyIG1vZHVsZSB3aXRoIGFuIGVxdWFsIG5hbWUgd2hlbiBjYXNlIGlzIGlnbm9yZWQuXFxuXCIgK1xyXG5cdFx0XCJUaGlzIGNhbiBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3Igd2hlbiBjb21waWxpbmcgb24gYSBmaWxlc3lzdGVtIHdpdGggb3RoZXIgY2FzZS1zZW1hbnRpYy5cXG5cIiArXHJcblx0XHRcIlJlbmFtZSBtb2R1bGUgaWYgbXVsdGlwbGUgbW9kdWxlcyBhcmUgZXhwZWN0ZWQgb3IgdXNlIGVxdWFsIGNhc2luZyBpZiBvbmUgbW9kdWxlIGlzIGV4cGVjdGVkLlwiO1xyXG5cdHRoaXMub3JpZ2luID0gdGhpcy5tb2R1bGUgPSBtb2R1bGU7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBDYXNlU2Vuc2l0aXZlTW9kdWxlc1dhcm5pbmc7XHJcblxyXG5DYXNlU2Vuc2l0aXZlTW9kdWxlc1dhcm5pbmcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL0Nhc2VTZW5zaXRpdmVNb2R1bGVzV2FybmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMTIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBMb2FkZXJEZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4vTG9hZGVyRGVwZW5kZW5jeVwiKTtcclxuXHJcbmZ1bmN0aW9uIExvYWRlclBsdWdpbigpIHt9XHJcbm1vZHVsZS5leHBvcnRzID0gTG9hZGVyUGx1Z2luO1xyXG5cclxuTG9hZGVyUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGNvbXBpbGVyKSB7XHJcblx0Y29tcGlsZXIucGx1Z2luKFwiY29tcGlsYXRpb25cIiwgZnVuY3Rpb24oY29tcGlsYXRpb24sIHBhcmFtcykge1xyXG5cdFx0dmFyIG5vcm1hbE1vZHVsZUZhY3RvcnkgPSBwYXJhbXMubm9ybWFsTW9kdWxlRmFjdG9yeTtcclxuXHJcblx0XHRjb21waWxhdGlvbi5kZXBlbmRlbmN5RmFjdG9yaWVzLnNldChMb2FkZXJEZXBlbmRlbmN5LCBub3JtYWxNb2R1bGVGYWN0b3J5KTtcclxuXHR9KTtcclxuXHRjb21waWxlci5wbHVnaW4oXCJjb21waWxhdGlvblwiLCBmdW5jdGlvbihjb21waWxhdGlvbikge1xyXG5cdFx0Y29tcGlsYXRpb24ucGx1Z2luKFwibm9ybWFsLW1vZHVsZS1sb2FkZXJcIiwgZnVuY3Rpb24obG9hZGVyQ29udGV4dCwgbW9kdWxlKSB7XHJcblx0XHRcdGxvYWRlckNvbnRleHQubG9hZE1vZHVsZSA9IGZ1bmN0aW9uIGxvYWRNb2R1bGUocmVxdWVzdCwgY2FsbGJhY2spIHtcclxuXHRcdFx0XHR2YXIgZGVwID0gbmV3IExvYWRlckRlcGVuZGVuY3kocmVxdWVzdCk7XHJcblx0XHRcdFx0ZGVwLmxvYyA9IHJlcXVlc3Q7XHJcblx0XHRcdFx0Y29tcGlsYXRpb24uYWRkTW9kdWxlRGVwZW5kZW5jaWVzKG1vZHVsZSwgW1xyXG5cdFx0XHRcdFx0W2RlcF1cclxuXHRcdFx0XHRdLCB0cnVlLCBcImxtXCIsIGZhbHNlLCBmdW5jdGlvbihlcnIpIHtcclxuXHRcdFx0XHRcdGlmKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcblxyXG5cdFx0XHRcdFx0aWYoIWRlcC5tb2R1bGUpIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoXCJDYW5ub3QgbG9hZCB0aGUgbW9kdWxlXCIpKTtcclxuXHRcdFx0XHRcdGlmKGRlcC5tb2R1bGUuYnVpbGRpbmcpIGRlcC5tb2R1bGUuYnVpbGRpbmcucHVzaChuZXh0KTtcclxuXHRcdFx0XHRcdGVsc2UgbmV4dCgpO1xyXG5cclxuXHRcdFx0XHRcdGZ1bmN0aW9uIG5leHQoZXJyKSB7XHJcblx0XHRcdFx0XHRcdGlmKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcblxyXG5cdFx0XHRcdFx0XHRpZihkZXAubW9kdWxlLmVycm9yKSByZXR1cm4gY2FsbGJhY2soZGVwLm1vZHVsZS5lcnJvcik7XHJcblx0XHRcdFx0XHRcdGlmKCFkZXAubW9kdWxlLl9zb3VyY2UpIHRocm93IG5ldyBFcnJvcihcIlRoZSBtb2R1bGUgY3JlYXRlZCBmb3IgYSBMb2FkZXJEZXBlbmRlbmN5IG11c3QgaGF2ZSBhIHByb3BlcnR5IF9zb3VyY2VcIik7XHJcblx0XHRcdFx0XHRcdHZhciBzb3VyY2UsIG1hcDtcclxuXHRcdFx0XHRcdFx0dmFyIG1vZHVsZVNvdXJjZSA9IGRlcC5tb2R1bGUuX3NvdXJjZTtcclxuXHRcdFx0XHRcdFx0aWYobW9kdWxlU291cmNlLnNvdXJjZUFuZE1hcCkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBzb3VyY2VBbmRNYXAgPSBtb2R1bGVTb3VyY2Uuc291cmNlQW5kTWFwKCk7XHJcblx0XHRcdFx0XHRcdFx0bWFwID0gc291cmNlQW5kTWFwLm1hcDtcclxuXHRcdFx0XHRcdFx0XHRzb3VyY2UgPSBzb3VyY2VBbmRNYXAuc291cmNlO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdG1hcCA9IG1vZHVsZVNvdXJjZS5tYXAoKTtcclxuXHRcdFx0XHRcdFx0XHRzb3VyY2UgPSBtb2R1bGVTb3VyY2Uuc291cmNlKCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0aWYoZGVwLm1vZHVsZS5maWxlRGVwZW5kZW5jaWVzKSB7XHJcblx0XHRcdFx0XHRcdFx0ZGVwLm1vZHVsZS5maWxlRGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24oZGVwKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRsb2FkZXJDb250ZXh0LmFkZERlcGVuZGVuY3koZGVwKTtcclxuXHRcdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRpZihkZXAubW9kdWxlLmNvbnRleHREZXBlbmRlbmNpZXMpIHtcclxuXHRcdFx0XHRcdFx0XHRkZXAubW9kdWxlLmNvbnRleHREZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbihkZXApIHtcclxuXHRcdFx0XHRcdFx0XHRcdGxvYWRlckNvbnRleHQuYWRkQ29udGV4dERlcGVuZGVuY3koZGVwKTtcclxuXHRcdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gY2FsbGJhY2sobnVsbCwgc291cmNlLCBtYXAsIGRlcC5tb2R1bGUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9O1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL0xvYWRlclBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBNb2R1bGVEZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4vTW9kdWxlRGVwZW5kZW5jeVwiKTtcclxuXHJcbmZ1bmN0aW9uIExvYWRlckRlcGVuZGVuY3kocmVxdWVzdCkge1xyXG5cdE1vZHVsZURlcGVuZGVuY3kuY2FsbCh0aGlzLCByZXF1ZXN0KTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IExvYWRlckRlcGVuZGVuY3k7XHJcblxyXG5Mb2FkZXJEZXBlbmRlbmN5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTW9kdWxlRGVwZW5kZW5jeS5wcm90b3R5cGUpO1xyXG5Mb2FkZXJEZXBlbmRlbmN5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExvYWRlckRlcGVuZGVuY3k7XHJcbkxvYWRlckRlcGVuZGVuY3kucHJvdG90eXBlLnR5cGUgPSBcImxvYWRlclwiO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9Mb2FkZXJEZXBlbmRlbmN5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIENvbnN0RGVwZW5kZW5jeSA9IHJlcXVpcmUoXCIuL0NvbnN0RGVwZW5kZW5jeVwiKTtcclxudmFyIENvbW1vbkpzUmVxdWlyZURlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9Db21tb25Kc1JlcXVpcmVEZXBlbmRlbmN5XCIpO1xyXG52YXIgQ29tbW9uSnNSZXF1aXJlQ29udGV4dERlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9Db21tb25Kc1JlcXVpcmVDb250ZXh0RGVwZW5kZW5jeVwiKTtcclxudmFyIFJlcXVpcmVSZXNvbHZlRGVwZW5kZW5jeSA9IHJlcXVpcmUoXCIuL1JlcXVpcmVSZXNvbHZlRGVwZW5kZW5jeVwiKTtcclxudmFyIFJlcXVpcmVSZXNvbHZlQ29udGV4dERlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9SZXF1aXJlUmVzb2x2ZUNvbnRleHREZXBlbmRlbmN5XCIpO1xyXG52YXIgUmVxdWlyZVJlc29sdmVIZWFkZXJEZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4vUmVxdWlyZVJlc29sdmVIZWFkZXJEZXBlbmRlbmN5XCIpO1xyXG52YXIgUmVxdWlyZUhlYWRlckRlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9SZXF1aXJlSGVhZGVyRGVwZW5kZW5jeVwiKTtcclxuXHJcbnZhciBOdWxsRmFjdG9yeSA9IHJlcXVpcmUoXCIuLi9OdWxsRmFjdG9yeVwiKTtcclxuXHJcbnZhciBSZXF1aXJlUmVzb2x2ZURlcGVuZGVuY3lQYXJzZXJQbHVnaW4gPSByZXF1aXJlKFwiLi9SZXF1aXJlUmVzb2x2ZURlcGVuZGVuY3lQYXJzZXJQbHVnaW5cIik7XHJcbnZhciBDb21tb25Kc1JlcXVpcmVEZXBlbmRlbmN5UGFyc2VyUGx1Z2luID0gcmVxdWlyZShcIi4vQ29tbW9uSnNSZXF1aXJlRGVwZW5kZW5jeVBhcnNlclBsdWdpblwiKTtcclxuXHJcbnZhciBCYXNpY0V2YWx1YXRlZEV4cHJlc3Npb24gPSByZXF1aXJlKFwiLi4vQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uXCIpO1xyXG5cclxuZnVuY3Rpb24gQ29tbW9uSnNQbHVnaW4ob3B0aW9ucykge1xyXG5cdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBDb21tb25Kc1BsdWdpbjtcclxuXHJcbkNvbW1vbkpzUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGNvbXBpbGVyKSB7XHJcblx0ZnVuY3Rpb24gc2V0VHlwZW9mKGV4cHIsIHZhbHVlKSB7XHJcblx0XHRjb21waWxlci5wYXJzZXIucGx1Z2luKFwiZXZhbHVhdGUgdHlwZW9mIFwiICsgZXhwciwgZnVuY3Rpb24oZXhwcikge1xyXG5cdFx0XHRyZXR1cm4gbmV3IEJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbigpLnNldFN0cmluZyh2YWx1ZSkuc2V0UmFuZ2UoZXhwci5yYW5nZSk7XHJcblx0XHR9KTtcclxuXHRcdGNvbXBpbGVyLnBhcnNlci5wbHVnaW4oXCJ0eXBlb2YgXCIgKyBleHByLCBmdW5jdGlvbihleHByKSB7XHJcblx0XHRcdHZhciBkZXAgPSBuZXcgQ29uc3REZXBlbmRlbmN5KEpTT04uc3RyaW5naWZ5KHZhbHVlKSwgZXhwci5yYW5nZSk7XHJcblx0XHRcdGRlcC5sb2MgPSBleHByLmxvYztcclxuXHRcdFx0dGhpcy5zdGF0ZS5jdXJyZW50LmFkZERlcGVuZGVuY3koZGVwKTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9KTtcclxuXHR9XHJcblx0Y29tcGlsZXIucGx1Z2luKFwiY29tcGlsYXRpb25cIiwgZnVuY3Rpb24oY29tcGlsYXRpb24sIHBhcmFtcykge1xyXG5cdFx0dmFyIG5vcm1hbE1vZHVsZUZhY3RvcnkgPSBwYXJhbXMubm9ybWFsTW9kdWxlRmFjdG9yeTtcclxuXHRcdHZhciBjb250ZXh0TW9kdWxlRmFjdG9yeSA9IHBhcmFtcy5jb250ZXh0TW9kdWxlRmFjdG9yeTtcclxuXHJcblx0XHRjb21waWxhdGlvbi5kZXBlbmRlbmN5RmFjdG9yaWVzLnNldChDb21tb25Kc1JlcXVpcmVEZXBlbmRlbmN5LCBub3JtYWxNb2R1bGVGYWN0b3J5KTtcclxuXHRcdGNvbXBpbGF0aW9uLmRlcGVuZGVuY3lUZW1wbGF0ZXMuc2V0KENvbW1vbkpzUmVxdWlyZURlcGVuZGVuY3ksIG5ldyBDb21tb25Kc1JlcXVpcmVEZXBlbmRlbmN5LlRlbXBsYXRlKCkpO1xyXG5cclxuXHRcdGNvbXBpbGF0aW9uLmRlcGVuZGVuY3lGYWN0b3JpZXMuc2V0KENvbW1vbkpzUmVxdWlyZUNvbnRleHREZXBlbmRlbmN5LCBjb250ZXh0TW9kdWxlRmFjdG9yeSk7XHJcblx0XHRjb21waWxhdGlvbi5kZXBlbmRlbmN5VGVtcGxhdGVzLnNldChDb21tb25Kc1JlcXVpcmVDb250ZXh0RGVwZW5kZW5jeSwgbmV3IENvbW1vbkpzUmVxdWlyZUNvbnRleHREZXBlbmRlbmN5LlRlbXBsYXRlKCkpO1xyXG5cclxuXHRcdGNvbXBpbGF0aW9uLmRlcGVuZGVuY3lGYWN0b3JpZXMuc2V0KFJlcXVpcmVSZXNvbHZlRGVwZW5kZW5jeSwgbm9ybWFsTW9kdWxlRmFjdG9yeSk7XHJcblx0XHRjb21waWxhdGlvbi5kZXBlbmRlbmN5VGVtcGxhdGVzLnNldChSZXF1aXJlUmVzb2x2ZURlcGVuZGVuY3ksIG5ldyBSZXF1aXJlUmVzb2x2ZURlcGVuZGVuY3kuVGVtcGxhdGUoKSk7XHJcblxyXG5cdFx0Y29tcGlsYXRpb24uZGVwZW5kZW5jeUZhY3Rvcmllcy5zZXQoUmVxdWlyZVJlc29sdmVDb250ZXh0RGVwZW5kZW5jeSwgY29udGV4dE1vZHVsZUZhY3RvcnkpO1xyXG5cdFx0Y29tcGlsYXRpb24uZGVwZW5kZW5jeVRlbXBsYXRlcy5zZXQoUmVxdWlyZVJlc29sdmVDb250ZXh0RGVwZW5kZW5jeSwgbmV3IFJlcXVpcmVSZXNvbHZlQ29udGV4dERlcGVuZGVuY3kuVGVtcGxhdGUoKSk7XHJcblxyXG5cdFx0Y29tcGlsYXRpb24uZGVwZW5kZW5jeUZhY3Rvcmllcy5zZXQoUmVxdWlyZVJlc29sdmVIZWFkZXJEZXBlbmRlbmN5LCBuZXcgTnVsbEZhY3RvcnkoKSk7XHJcblx0XHRjb21waWxhdGlvbi5kZXBlbmRlbmN5VGVtcGxhdGVzLnNldChSZXF1aXJlUmVzb2x2ZUhlYWRlckRlcGVuZGVuY3ksIG5ldyBSZXF1aXJlUmVzb2x2ZUhlYWRlckRlcGVuZGVuY3kuVGVtcGxhdGUoKSk7XHJcblxyXG5cdFx0Y29tcGlsYXRpb24uZGVwZW5kZW5jeUZhY3Rvcmllcy5zZXQoUmVxdWlyZUhlYWRlckRlcGVuZGVuY3ksIG5ldyBOdWxsRmFjdG9yeSgpKTtcclxuXHRcdGNvbXBpbGF0aW9uLmRlcGVuZGVuY3lUZW1wbGF0ZXMuc2V0KFJlcXVpcmVIZWFkZXJEZXBlbmRlbmN5LCBuZXcgUmVxdWlyZUhlYWRlckRlcGVuZGVuY3kuVGVtcGxhdGUoKSk7XHJcblx0fSk7XHJcblx0c2V0VHlwZW9mKFwicmVxdWlyZVwiLCBcImZ1bmN0aW9uXCIpO1xyXG5cdHNldFR5cGVvZihcInJlcXVpcmUucmVzb2x2ZVwiLCBcImZ1bmN0aW9uXCIpO1xyXG5cdHNldFR5cGVvZihcInJlcXVpcmUucmVzb2x2ZVdlYWtcIiwgXCJmdW5jdGlvblwiKTtcclxuXHRjb21waWxlci5wYXJzZXIucGx1Z2luKFwiZXZhbHVhdGUgdHlwZW9mIG1vZHVsZVwiLCBmdW5jdGlvbihleHByKSB7XHJcblx0XHRyZXR1cm4gbmV3IEJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbigpLnNldFN0cmluZyhcIm9iamVjdFwiKS5zZXRSYW5nZShleHByLnJhbmdlKTtcclxuXHR9KTtcclxuXHRjb21waWxlci5wYXJzZXIucGx1Z2luKFwiYXNzaWduIHJlcXVpcmVcIiwgZnVuY3Rpb24oZXhwcikge1xyXG5cdFx0Ly8gdG8gbm90IGxlYWsgdG8gZ2xvYmFsIFwicmVxdWlyZVwiLCB3ZSBuZWVkIHRvIGRlZmluZSBhIGxvY2FsIHJlcXVpcmUgaGVyZS5cclxuXHRcdHZhciBkZXAgPSBuZXcgQ29uc3REZXBlbmRlbmN5KFwidmFyIHJlcXVpcmU7XCIsIDApO1xyXG5cdFx0ZGVwLmxvYyA9IGV4cHIubG9jO1xyXG5cdFx0dGhpcy5zdGF0ZS5jdXJyZW50LmFkZERlcGVuZGVuY3koZGVwKTtcclxuXHRcdHRoaXMuc2NvcGUuZGVmaW5pdGlvbnMucHVzaChcInJlcXVpcmVcIik7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9KTtcclxuXHRjb21waWxlci5wYXJzZXIucGx1Z2luKFwiY2FuLXJlbmFtZSByZXF1aXJlXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSk7XHJcblx0Y29tcGlsZXIucGFyc2VyLnBsdWdpbihcInJlbmFtZSByZXF1aXJlXCIsIGZ1bmN0aW9uKGV4cHIpIHtcclxuXHRcdC8vIGRlZmluZSB0aGUgcmVxdWlyZSB2YXJpYWJsZS4gSXQncyBzdGlsbCB1bmRlZmluZWQsIGJ1dCBub3QgXCJub3QgZGVmaW5lZFwiLlxyXG5cdFx0dmFyIGRlcCA9IG5ldyBDb25zdERlcGVuZGVuY3koXCJ2YXIgcmVxdWlyZTtcIiwgMCk7XHJcblx0XHRkZXAubG9jID0gZXhwci5sb2M7XHJcblx0XHR0aGlzLnN0YXRlLmN1cnJlbnQuYWRkRGVwZW5kZW5jeShkZXApO1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0pO1xyXG5cdGNvbXBpbGVyLnBhcnNlci5wbHVnaW4oXCJ0eXBlb2YgbW9kdWxlXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSk7XHJcblx0Y29tcGlsZXIucGFyc2VyLnBsdWdpbihcImV2YWx1YXRlIHR5cGVvZiBleHBvcnRzXCIsIGZ1bmN0aW9uKGV4cHIpIHtcclxuXHRcdHJldHVybiBuZXcgQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uKCkuc2V0U3RyaW5nKFwib2JqZWN0XCIpLnNldFJhbmdlKGV4cHIucmFuZ2UpO1xyXG5cdH0pO1xyXG5cdGNvbXBpbGVyLnBhcnNlci5hcHBseShcclxuXHRcdG5ldyBDb21tb25Kc1JlcXVpcmVEZXBlbmRlbmN5UGFyc2VyUGx1Z2luKHRoaXMub3B0aW9ucyksXHJcblx0XHRuZXcgUmVxdWlyZVJlc29sdmVEZXBlbmRlbmN5UGFyc2VyUGx1Z2luKHRoaXMub3B0aW9ucylcclxuXHQpO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9Db21tb25Kc1BsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBNb2R1bGVEZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4vTW9kdWxlRGVwZW5kZW5jeVwiKTtcclxuXHJcbmZ1bmN0aW9uIENvbW1vbkpzUmVxdWlyZURlcGVuZGVuY3kocmVxdWVzdCwgcmFuZ2UpIHtcclxuXHRNb2R1bGVEZXBlbmRlbmN5LmNhbGwodGhpcywgcmVxdWVzdCk7XHJcblx0dGhpcy5yYW5nZSA9IHJhbmdlO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gQ29tbW9uSnNSZXF1aXJlRGVwZW5kZW5jeTtcclxuXHJcbkNvbW1vbkpzUmVxdWlyZURlcGVuZGVuY3kucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNb2R1bGVEZXBlbmRlbmN5LnByb3RvdHlwZSk7XHJcbkNvbW1vbkpzUmVxdWlyZURlcGVuZGVuY3kucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29tbW9uSnNSZXF1aXJlRGVwZW5kZW5jeTtcclxuQ29tbW9uSnNSZXF1aXJlRGVwZW5kZW5jeS5wcm90b3R5cGUudHlwZSA9IFwiY2pzIHJlcXVpcmVcIjtcclxuXHJcbkNvbW1vbkpzUmVxdWlyZURlcGVuZGVuY3kuVGVtcGxhdGUgPSByZXF1aXJlKFwiLi9Nb2R1bGVEZXBlbmRlbmN5VGVtcGxhdGVBc0lkXCIpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9Db21tb25Kc1JlcXVpcmVEZXBlbmRlbmN5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuZnVuY3Rpb24gTW9kdWxlRGVwZW5kZW5jeVRlbXBsYXRlQXNJZCgpIHt9XHJcbm1vZHVsZS5leHBvcnRzID0gTW9kdWxlRGVwZW5kZW5jeVRlbXBsYXRlQXNJZDtcclxuXHJcbk1vZHVsZURlcGVuZGVuY3lUZW1wbGF0ZUFzSWQucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oZGVwLCBzb3VyY2UsIG91dHB1dE9wdGlvbnMsIHJlcXVlc3RTaG9ydGVuZXIpIHtcclxuXHRpZighZGVwLnJhbmdlKSByZXR1cm47XHJcblx0dmFyIGNvbW1lbnQgPSBcIlwiO1xyXG5cdGlmKG91dHB1dE9wdGlvbnMucGF0aGluZm8pIGNvbW1lbnQgPSBcIi8qISBcIiArIHJlcXVlc3RTaG9ydGVuZXIuc2hvcnRlbihkZXAucmVxdWVzdCkgKyBcIiAqLyBcIjtcclxuXHRpZihkZXAubW9kdWxlKVxyXG5cdFx0dmFyIGNvbnRlbnQgPSBjb21tZW50ICsgSlNPTi5zdHJpbmdpZnkoZGVwLm1vZHVsZS5pZCk7XHJcblx0ZWxzZVxyXG5cdFx0dmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiLi9XZWJwYWNrTWlzc2luZ01vZHVsZVwiKS5tb2R1bGUoZGVwLnJlcXVlc3QpO1xyXG5cdHNvdXJjZS5yZXBsYWNlKGRlcC5yYW5nZVswXSwgZGVwLnJhbmdlWzFdIC0gMSwgY29udGVudCk7XHJcbn07XHJcblxyXG5Nb2R1bGVEZXBlbmRlbmN5VGVtcGxhdGVBc0lkLnByb3RvdHlwZS5hcHBseUFzVGVtcGxhdGVBcmd1bWVudCA9IGZ1bmN0aW9uKG5hbWUsIGRlcCwgc291cmNlKSB7XHJcblx0aWYoIWRlcC5yYW5nZSkgcmV0dXJuO1xyXG5cdHNvdXJjZS5yZXBsYWNlKGRlcC5yYW5nZVswXSwgZGVwLnJhbmdlWzFdIC0gMSwgbmFtZSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL01vZHVsZURlcGVuZGVuY3lUZW1wbGF0ZUFzSWQuanNcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5leHBvcnRzLm1vZHVsZSA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcclxuXHRyZXR1cm4gXCIhKGZ1bmN0aW9uIHdlYnBhY2tNaXNzaW5nTW9kdWxlKCkgeyBcIiArXHJcblx0XHRleHBvcnRzLm1vZHVsZUNvZGUocmVxdWVzdCkgK1xyXG5cdFx0XCIgfSgpKVwiO1xyXG59O1xyXG5cclxuZXhwb3J0cy5tb2R1bGVDb2RlID0gZnVuY3Rpb24ocmVxdWVzdCkge1xyXG5cdHJldHVybiBcInZhciBlID0gbmV3IEVycm9yKFwiICsgSlNPTi5zdHJpbmdpZnkoXCJDYW5ub3QgZmluZCBtb2R1bGUgXFxcIlwiICsgcmVxdWVzdCArIFwiXFxcIlwiKSArIFwiKTsgXCIgK1xyXG5cdFx0XCJlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7IFwiICtcclxuXHRcdFwidGhyb3cgZTtcIjtcclxufTtcclxuXHJcbmV4cG9ydHMubW9kdWxlTWV0YUluZm8gPSBmdW5jdGlvbihyZXF1ZXN0KSB7XHJcblx0cmV0dXJuIFwiIShmdW5jdGlvbiB3ZWJwYWNrTWlzc2luZ01vZHVsZU1ldGFJbmZvKCkgeyBcIiArXHJcblx0XHRcInZhciBlID0gbmV3IEVycm9yKFwiICsgSlNPTi5zdHJpbmdpZnkoXCJNb2R1bGUgY2Fubm90IGJlIGltcG9ydGVkIGJlY2F1c2Ugbm8gbWV0YSBpbmZvIGFib3V0IGV4cG9ydHMgaXMgYXZhaWxhYmxlIFxcXCJcIiArIHJlcXVlc3QgKyBcIlxcXCJcIikgKyBcIik7IFwiICtcclxuXHRcdFwiZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnOyBcIiArXHJcblx0XHRcInRocm93IGU7IFwiICtcclxuXHRcdFwifSgpKVwiO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9XZWJwYWNrTWlzc2luZ01vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBDb250ZXh0RGVwZW5kZW5jeSA9IHJlcXVpcmUoXCIuL0NvbnRleHREZXBlbmRlbmN5XCIpO1xyXG5cclxuZnVuY3Rpb24gQ29tbW9uSnNSZXF1aXJlQ29udGV4dERlcGVuZGVuY3kocmVxdWVzdCwgcmVjdXJzaXZlLCByZWdFeHAsIHJhbmdlLCB2YWx1ZVJhbmdlKSB7XHJcblx0Q29udGV4dERlcGVuZGVuY3kuY2FsbCh0aGlzLCByZXF1ZXN0LCByZWN1cnNpdmUsIHJlZ0V4cCk7XHJcblx0dGhpcy5yYW5nZSA9IHJhbmdlO1xyXG5cdHRoaXMudmFsdWVSYW5nZSA9IHZhbHVlUmFuZ2U7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBDb21tb25Kc1JlcXVpcmVDb250ZXh0RGVwZW5kZW5jeTtcclxuXHJcbkNvbW1vbkpzUmVxdWlyZUNvbnRleHREZXBlbmRlbmN5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29udGV4dERlcGVuZGVuY3kucHJvdG90eXBlKTtcclxuQ29tbW9uSnNSZXF1aXJlQ29udGV4dERlcGVuZGVuY3kucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29tbW9uSnNSZXF1aXJlQ29udGV4dERlcGVuZGVuY3k7XHJcbkNvbW1vbkpzUmVxdWlyZUNvbnRleHREZXBlbmRlbmN5LnByb3RvdHlwZS50eXBlID0gXCJjanMgcmVxdWlyZSBjb250ZXh0XCI7XHJcblxyXG5Db21tb25Kc1JlcXVpcmVDb250ZXh0RGVwZW5kZW5jeS5UZW1wbGF0ZSA9IHJlcXVpcmUoXCIuL0NvbnRleHREZXBlbmRlbmN5VGVtcGxhdGVBc1JlcXVpcmVDYWxsXCIpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9Db21tb25Kc1JlcXVpcmVDb250ZXh0RGVwZW5kZW5jeS5qc1xuLy8gbW9kdWxlIGlkID0gMTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBEZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4uL0RlcGVuZGVuY3lcIik7XHJcblxyXG5mdW5jdGlvbiBDb250ZXh0RGVwZW5kZW5jeShyZXF1ZXN0LCByZWN1cnNpdmUsIHJlZ0V4cCkge1xyXG5cdERlcGVuZGVuY3kuY2FsbCh0aGlzKTtcclxuXHR0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xyXG5cdHRoaXMudXNlclJlcXVlc3QgPSByZXF1ZXN0O1xyXG5cdHRoaXMucmVjdXJzaXZlID0gcmVjdXJzaXZlO1xyXG5cdHRoaXMucmVnRXhwID0gcmVnRXhwO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGV4dERlcGVuZGVuY3k7XHJcblxyXG5Db250ZXh0RGVwZW5kZW5jeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKERlcGVuZGVuY3kucHJvdG90eXBlKTtcclxuQ29udGV4dERlcGVuZGVuY3kucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29udGV4dERlcGVuZGVuY3k7XHJcbkNvbnRleHREZXBlbmRlbmN5LnByb3RvdHlwZS5pc0VxdWFsUmVzb3VyY2UgPSBmdW5jdGlvbihvdGhlcikge1xyXG5cdGlmKCEob3RoZXIgaW5zdGFuY2VvZiBDb250ZXh0RGVwZW5kZW5jeSkpXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0cmV0dXJuIHRoaXMucmVxdWVzdCA9PT0gb3RoZXIucmVxdWVzdCAmJlxyXG5cdFx0dGhpcy5yZWN1cnNpdmUgPT09IG90aGVyLnJlY3Vyc2l2ZSAmJlxyXG5cdFx0dGhpcy5yZWdFeHAgPT09IG90aGVyLnJlZ0V4cDtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvQ29udGV4dERlcGVuZGVuY3kuanNcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5mdW5jdGlvbiBDb250ZXh0RGVwZW5kZW5jeVRlbXBsYXRlQXNSZXF1aXJlQ2FsbCgpIHt9XHJcbm1vZHVsZS5leHBvcnRzID0gQ29udGV4dERlcGVuZGVuY3lUZW1wbGF0ZUFzUmVxdWlyZUNhbGw7XHJcblxyXG5Db250ZXh0RGVwZW5kZW5jeVRlbXBsYXRlQXNSZXF1aXJlQ2FsbC5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbihkZXAsIHNvdXJjZSwgb3V0cHV0T3B0aW9ucywgcmVxdWVzdFNob3J0ZW5lcikge1xyXG5cdHZhciBjb21tZW50ID0gXCJcIjtcclxuXHRpZihvdXRwdXRPcHRpb25zLnBhdGhpbmZvKSBjb21tZW50ID0gXCIvKiEgXCIgKyByZXF1ZXN0U2hvcnRlbmVyLnNob3J0ZW4oZGVwLnJlcXVlc3QpICsgXCIgKi8gXCI7XHJcblx0aWYoZGVwLm1vZHVsZSAmJiBkZXAubW9kdWxlLmRlcGVuZGVuY2llcyAmJiBkZXAubW9kdWxlLmRlcGVuZGVuY2llcy5sZW5ndGggPiAwKSB7XHJcblx0XHRpZihkZXAudmFsdWVSYW5nZSkge1xyXG5cdFx0XHRzb3VyY2UucmVwbGFjZShkZXAudmFsdWVSYW5nZVsxXSwgZGVwLnJhbmdlWzFdIC0gMSwgXCIpXCIpO1xyXG5cdFx0XHRzb3VyY2UucmVwbGFjZShkZXAucmFuZ2VbMF0sIGRlcC52YWx1ZVJhbmdlWzBdIC0gMSwgXCJfX3dlYnBhY2tfcmVxdWlyZV9fKFwiICsgY29tbWVudCArIEpTT04uc3RyaW5naWZ5KGRlcC5tb2R1bGUuaWQpICsgXCIpKFwiICsgKHR5cGVvZiBkZXAucHJlcGVuZCA9PT0gXCJzdHJpbmdcIiA/IEpTT04uc3RyaW5naWZ5KGRlcC5wcmVwZW5kKSA6IFwiXCIpICsgXCJcIik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzb3VyY2UucmVwbGFjZShkZXAucmFuZ2VbMF0sIGRlcC5yYW5nZVsxXSAtIDEsIFwiX193ZWJwYWNrX3JlcXVpcmVfXyhcIiArIGNvbW1lbnQgKyBKU09OLnN0cmluZ2lmeShkZXAubW9kdWxlLmlkKSArIFwiKVwiKTtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0dmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiLi9XZWJwYWNrTWlzc2luZ01vZHVsZVwiKS5tb2R1bGUoZGVwLnJlcXVlc3QpO1xyXG5cdFx0c291cmNlLnJlcGxhY2UoZGVwLnJhbmdlWzBdLCBkZXAucmFuZ2VbMV0gLSAxLCBjb250ZW50KTtcclxuXHR9XHJcbn07XHJcblxyXG5Db250ZXh0RGVwZW5kZW5jeVRlbXBsYXRlQXNSZXF1aXJlQ2FsbC5wcm90b3R5cGUuYXBwbHlBc1RlbXBsYXRlQXJndW1lbnQgPSBmdW5jdGlvbihuYW1lLCBkZXAsIHNvdXJjZSkge1xyXG5cdGlmKGRlcC52YWx1ZVJhbmdlKSB7XHJcblx0XHRzb3VyY2UucmVwbGFjZShkZXAudmFsdWVSYW5nZVsxXSwgZGVwLnJhbmdlWzFdIC0gMSwgXCIpXCIpO1xyXG5cdFx0c291cmNlLnJlcGxhY2UoZGVwLnJhbmdlWzBdLCBkZXAudmFsdWVSYW5nZVswXSAtIDEsIFwiX193ZWJwYWNrX3JlcXVpcmVfXyhcIiArIG5hbWUgKyBcIikoXCIgKyAodHlwZW9mIGRlcC5wcmVwZW5kID09PSBcInN0cmluZ1wiID8gSlNPTi5zdHJpbmdpZnkoZGVwLnByZXBlbmQpIDogXCJcIikgKyBcIlwiKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0c291cmNlLnJlcGxhY2UoZGVwLnJhbmdlWzBdLCBkZXAucmFuZ2VbMV0gLSAxLCBcIl9fd2VicGFja19yZXF1aXJlX18oXCIgKyBuYW1lICsgXCIpXCIpO1xyXG5cdH1cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvQ29udGV4dERlcGVuZGVuY3lUZW1wbGF0ZUFzUmVxdWlyZUNhbGwuanNcbi8vIG1vZHVsZSBpZCA9IDEyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgTW9kdWxlRGVwZW5kZW5jeSA9IHJlcXVpcmUoXCIuL01vZHVsZURlcGVuZGVuY3lcIik7XHJcblxyXG5mdW5jdGlvbiBSZXF1aXJlUmVzb2x2ZURlcGVuZGVuY3kocmVxdWVzdCwgcmFuZ2UpIHtcclxuXHRNb2R1bGVEZXBlbmRlbmN5LmNhbGwodGhpcywgcmVxdWVzdCk7XHJcblx0dGhpcy5yYW5nZSA9IHJhbmdlO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gUmVxdWlyZVJlc29sdmVEZXBlbmRlbmN5O1xyXG5cclxuUmVxdWlyZVJlc29sdmVEZXBlbmRlbmN5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTW9kdWxlRGVwZW5kZW5jeS5wcm90b3R5cGUpO1xyXG5SZXF1aXJlUmVzb2x2ZURlcGVuZGVuY3kucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVxdWlyZVJlc29sdmVEZXBlbmRlbmN5O1xyXG5SZXF1aXJlUmVzb2x2ZURlcGVuZGVuY3kucHJvdG90eXBlLnR5cGUgPSBcInJlcXVpcmUucmVzb2x2ZVwiO1xyXG5cclxuUmVxdWlyZVJlc29sdmVEZXBlbmRlbmN5LlRlbXBsYXRlID0gcmVxdWlyZShcIi4vTW9kdWxlRGVwZW5kZW5jeVRlbXBsYXRlQXNJZFwiKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvUmVxdWlyZVJlc29sdmVEZXBlbmRlbmN5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIENvbnRleHREZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4vQ29udGV4dERlcGVuZGVuY3lcIik7XHJcblxyXG5mdW5jdGlvbiBSZXF1aXJlUmVzb2x2ZUNvbnRleHREZXBlbmRlbmN5KHJlcXVlc3QsIHJlY3Vyc2l2ZSwgcmVnRXhwLCByYW5nZSwgdmFsdWVSYW5nZSkge1xyXG5cdENvbnRleHREZXBlbmRlbmN5LmNhbGwodGhpcywgcmVxdWVzdCwgcmVjdXJzaXZlLCByZWdFeHApO1xyXG5cdHRoaXMucmFuZ2UgPSByYW5nZTtcclxuXHR0aGlzLnZhbHVlUmFuZ2UgPSB2YWx1ZVJhbmdlO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gUmVxdWlyZVJlc29sdmVDb250ZXh0RGVwZW5kZW5jeTtcclxuXHJcblJlcXVpcmVSZXNvbHZlQ29udGV4dERlcGVuZGVuY3kucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb250ZXh0RGVwZW5kZW5jeS5wcm90b3R5cGUpO1xyXG5SZXF1aXJlUmVzb2x2ZUNvbnRleHREZXBlbmRlbmN5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlcXVpcmVSZXNvbHZlQ29udGV4dERlcGVuZGVuY3k7XHJcblJlcXVpcmVSZXNvbHZlQ29udGV4dERlcGVuZGVuY3kucHJvdG90eXBlLnR5cGUgPSBcImFtZCByZXF1aXJlIGNvbnRleHRcIjtcclxuXHJcblJlcXVpcmVSZXNvbHZlQ29udGV4dERlcGVuZGVuY3kuVGVtcGxhdGUgPSByZXF1aXJlKFwiLi9Db250ZXh0RGVwZW5kZW5jeVRlbXBsYXRlQXNJZFwiKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvUmVxdWlyZVJlc29sdmVDb250ZXh0RGVwZW5kZW5jeS5qc1xuLy8gbW9kdWxlIGlkID0gMTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbmZ1bmN0aW9uIENvbnRleHREZXBlbmRlbmN5VGVtcGxhdGVBc0lkKCkge31cclxubW9kdWxlLmV4cG9ydHMgPSBDb250ZXh0RGVwZW5kZW5jeVRlbXBsYXRlQXNJZDtcclxuXHJcbkNvbnRleHREZXBlbmRlbmN5VGVtcGxhdGVBc0lkLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGRlcCwgc291cmNlLCBvdXRwdXRPcHRpb25zLCByZXF1ZXN0U2hvcnRlbmVyKSB7XHJcblx0dmFyIGNvbW1lbnQgPSBcIlwiO1xyXG5cdGlmKG91dHB1dE9wdGlvbnMucGF0aGluZm8pIGNvbW1lbnQgPSBcIi8qISBcIiArIHJlcXVlc3RTaG9ydGVuZXIuc2hvcnRlbihkZXAucmVxdWVzdCkgKyBcIiAqLyBcIjtcclxuXHRpZihkZXAubW9kdWxlICYmIGRlcC5tb2R1bGUuZGVwZW5kZW5jaWVzICYmIGRlcC5tb2R1bGUuZGVwZW5kZW5jaWVzLmxlbmd0aCA+IDApIHtcclxuXHRcdGlmKGRlcC52YWx1ZVJhbmdlKSB7XHJcblx0XHRcdHNvdXJjZS5yZXBsYWNlKGRlcC52YWx1ZVJhbmdlWzFdLCBkZXAucmFuZ2VbMV0gLSAxLCBcIilcIik7XHJcblx0XHRcdHNvdXJjZS5yZXBsYWNlKGRlcC5yYW5nZVswXSwgZGVwLnZhbHVlUmFuZ2VbMF0gLSAxLCBcIl9fd2VicGFja19yZXF1aXJlX18oXCIgKyBjb21tZW50ICsgSlNPTi5zdHJpbmdpZnkoZGVwLm1vZHVsZS5pZCkgKyBcIikucmVzb2x2ZShcIiArICh0eXBlb2YgZGVwLnByZXBlbmQgPT09IFwic3RyaW5nXCIgPyBKU09OLnN0cmluZ2lmeShkZXAucHJlcGVuZCkgOiBcIlwiKSArIFwiXCIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c291cmNlLnJlcGxhY2UoZGVwLnJhbmdlWzBdLCBkZXAucmFuZ2VbMV0gLSAxLCBcIl9fd2VicGFja19yZXF1aXJlX18oXCIgKyBjb21tZW50ICsgSlNPTi5zdHJpbmdpZnkoZGVwLm1vZHVsZS5pZCkgKyBcIikucmVzb2x2ZVwiKTtcclxuXHRcdH1cclxuXHR9IGVsc2Uge1xyXG5cdFx0dmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiLi9XZWJwYWNrTWlzc2luZ01vZHVsZVwiKS5tb2R1bGUoZGVwLnJlcXVlc3QpO1xyXG5cdFx0c291cmNlLnJlcGxhY2UoZGVwLnJhbmdlWzBdLCBkZXAucmFuZ2VbMV0gLSAxLCBjb250ZW50KTtcclxuXHR9XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL0NvbnRleHREZXBlbmRlbmN5VGVtcGxhdGVBc0lkLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIE51bGxEZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4vTnVsbERlcGVuZGVuY3lcIik7XHJcblxyXG5mdW5jdGlvbiBSZXF1aXJlUmVzb2x2ZUhlYWRlckRlcGVuZGVuY3kocmFuZ2UpIHtcclxuXHRpZighQXJyYXkuaXNBcnJheShyYW5nZSkpIHRocm93IG5ldyBFcnJvcihcInJhbmdlIG11c3QgYmUgdmFsaWRcIik7XHJcblx0TnVsbERlcGVuZGVuY3kuY2FsbCh0aGlzKTtcclxuXHR0aGlzLnJhbmdlID0gcmFuZ2U7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBSZXF1aXJlUmVzb2x2ZUhlYWRlckRlcGVuZGVuY3k7XHJcblxyXG5SZXF1aXJlUmVzb2x2ZUhlYWRlckRlcGVuZGVuY3kucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOdWxsRGVwZW5kZW5jeS5wcm90b3R5cGUpO1xyXG5SZXF1aXJlUmVzb2x2ZUhlYWRlckRlcGVuZGVuY3kucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVxdWlyZVJlc29sdmVIZWFkZXJEZXBlbmRlbmN5O1xyXG5cclxuUmVxdWlyZVJlc29sdmVIZWFkZXJEZXBlbmRlbmN5LlRlbXBsYXRlID0gZnVuY3Rpb24gUmVxdWlyZVJlc29sdmVIZWFkZXJEZXBlbmRlbmN5VGVtcGxhdGUoKSB7fTtcclxuXHJcblJlcXVpcmVSZXNvbHZlSGVhZGVyRGVwZW5kZW5jeS5UZW1wbGF0ZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbihkZXAsIHNvdXJjZSkge1xyXG5cdHNvdXJjZS5yZXBsYWNlKGRlcC5yYW5nZVswXSwgZGVwLnJhbmdlWzFdIC0gMSwgXCIvKnJlcXVpcmUucmVzb2x2ZSovXCIpO1xyXG59O1xyXG5cclxuUmVxdWlyZVJlc29sdmVIZWFkZXJEZXBlbmRlbmN5LlRlbXBsYXRlLnByb3RvdHlwZS5hcHBseUFzVGVtcGxhdGVBcmd1bWVudCA9IGZ1bmN0aW9uKG5hbWUsIGRlcCwgc291cmNlKSB7XHJcblx0c291cmNlLnJlcGxhY2UoZGVwLnJhbmdlWzBdLCBkZXAucmFuZ2VbMV0gLSAxLCBcIi8qcmVxdWlyZS5yZXNvbHZlKi9cIik7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL1JlcXVpcmVSZXNvbHZlSGVhZGVyRGVwZW5kZW5jeS5qc1xuLy8gbW9kdWxlIGlkID0gMTMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBOdWxsRGVwZW5kZW5jeSA9IHJlcXVpcmUoXCIuL051bGxEZXBlbmRlbmN5XCIpO1xyXG5cclxuZnVuY3Rpb24gUmVxdWlyZUhlYWRlckRlcGVuZGVuY3kocmFuZ2UpIHtcclxuXHRpZighQXJyYXkuaXNBcnJheShyYW5nZSkpIHRocm93IG5ldyBFcnJvcihcInJhbmdlIG11c3QgYmUgdmFsaWRcIik7XHJcblx0TnVsbERlcGVuZGVuY3kuY2FsbCh0aGlzKTtcclxuXHR0aGlzLnJhbmdlID0gcmFuZ2U7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBSZXF1aXJlSGVhZGVyRGVwZW5kZW5jeTtcclxuXHJcblJlcXVpcmVIZWFkZXJEZXBlbmRlbmN5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTnVsbERlcGVuZGVuY3kucHJvdG90eXBlKTtcclxuUmVxdWlyZUhlYWRlckRlcGVuZGVuY3kucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVxdWlyZUhlYWRlckRlcGVuZGVuY3k7XHJcblxyXG5SZXF1aXJlSGVhZGVyRGVwZW5kZW5jeS5UZW1wbGF0ZSA9IGZ1bmN0aW9uIFJlcXVpcmVIZWFkZXJEZXBlbmRlbmN5VGVtcGxhdGUoKSB7fTtcclxuXHJcblJlcXVpcmVIZWFkZXJEZXBlbmRlbmN5LlRlbXBsYXRlLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGRlcCwgc291cmNlKSB7XHJcblx0c291cmNlLnJlcGxhY2UoZGVwLnJhbmdlWzBdLCBkZXAucmFuZ2VbMV0gLSAxLCBcIl9fd2VicGFja19yZXF1aXJlX19cIik7XHJcbn07XHJcblxyXG5SZXF1aXJlSGVhZGVyRGVwZW5kZW5jeS5UZW1wbGF0ZS5wcm90b3R5cGUuYXBwbHlBc1RlbXBsYXRlQXJndW1lbnQgPSBmdW5jdGlvbihuYW1lLCBkZXAsIHNvdXJjZSkge1xyXG5cdHNvdXJjZS5yZXBsYWNlKGRlcC5yYW5nZVswXSwgZGVwLnJhbmdlWzFdIC0gMSwgXCJyZXF1aXJlXCIpO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9SZXF1aXJlSGVhZGVyRGVwZW5kZW5jeS5qc1xuLy8gbW9kdWxlIGlkID0gMTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBSZXF1aXJlUmVzb2x2ZURlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9SZXF1aXJlUmVzb2x2ZURlcGVuZGVuY3lcIik7XHJcbnZhciBSZXF1aXJlUmVzb2x2ZUNvbnRleHREZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4vUmVxdWlyZVJlc29sdmVDb250ZXh0RGVwZW5kZW5jeVwiKTtcclxudmFyIFJlcXVpcmVSZXNvbHZlSGVhZGVyRGVwZW5kZW5jeSA9IHJlcXVpcmUoXCIuL1JlcXVpcmVSZXNvbHZlSGVhZGVyRGVwZW5kZW5jeVwiKTtcclxudmFyIENvbnRleHREZXBlbmRlbmN5SGVscGVycyA9IHJlcXVpcmUoXCIuL0NvbnRleHREZXBlbmRlbmN5SGVscGVyc1wiKTtcclxuXHJcbmZ1bmN0aW9uIFJlcXVpcmVSZXNvbHZlRGVwZW5kZW5jeVBhcnNlclBsdWdpbihvcHRpb25zKSB7XHJcblx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBSZXF1aXJlUmVzb2x2ZURlcGVuZGVuY3lQYXJzZXJQbHVnaW47XHJcblxyXG5SZXF1aXJlUmVzb2x2ZURlcGVuZGVuY3lQYXJzZXJQbHVnaW4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24ocGFyc2VyKSB7XHJcblx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblx0cGFyc2VyLnBsdWdpbihcImNhbGwgcmVxdWlyZS5yZXNvbHZlXCIsIGZ1bmN0aW9uKGV4cHIpIHtcclxuXHRcdHJldHVybiB0aGlzLmFwcGx5UGx1Z2luc0JhaWxSZXN1bHQoXCJjYWxsIHJlcXVpcmUucmVzb2x2ZShXZWFrKVwiLCBleHByLCBmYWxzZSk7XHJcblx0fSk7XHJcblx0cGFyc2VyLnBsdWdpbihcImNhbGwgcmVxdWlyZS5yZXNvbHZlV2Vha1wiLCBmdW5jdGlvbihleHByKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5hcHBseVBsdWdpbnNCYWlsUmVzdWx0KFwiY2FsbCByZXF1aXJlLnJlc29sdmUoV2VhaylcIiwgZXhwciwgdHJ1ZSk7XHJcblx0fSk7XHJcblx0cGFyc2VyLnBsdWdpbihcImNhbGwgcmVxdWlyZS5yZXNvbHZlKFdlYWspXCIsIGZ1bmN0aW9uKGV4cHIsIHdlYWspIHtcclxuXHRcdGlmKGV4cHIuYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkgcmV0dXJuO1xyXG5cdFx0dmFyIHBhcmFtID0gdGhpcy5ldmFsdWF0ZUV4cHJlc3Npb24oZXhwci5hcmd1bWVudHNbMF0pO1xyXG5cdFx0dmFyIGRlcDtcclxuXHRcdGlmKHBhcmFtLmlzQ29uZGl0aW9uYWwoKSkge1xyXG5cdFx0XHRwYXJhbS5vcHRpb25zLmZvckVhY2goZnVuY3Rpb24ob3B0aW9uKSB7XHJcblx0XHRcdFx0dmFyIHJlc3VsdCA9IHRoaXMuYXBwbHlQbHVnaW5zQmFpbFJlc3VsdChcImNhbGwgcmVxdWlyZS5yZXNvbHZlKFdlYWspOml0ZW1cIiwgZXhwciwgb3B0aW9uLCB3ZWFrKTtcclxuXHRcdFx0XHRpZihyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0dGhpcy5hcHBseVBsdWdpbnNCYWlsUmVzdWx0KFwiY2FsbCByZXF1aXJlLnJlc29sdmUoV2Vhayk6Y29udGV4dFwiLCBleHByLCBvcHRpb24sIHdlYWspO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSwgdGhpcyk7XHJcblx0XHRcdGRlcCA9IG5ldyBSZXF1aXJlUmVzb2x2ZUhlYWRlckRlcGVuZGVuY3koZXhwci5jYWxsZWUucmFuZ2UpO1xyXG5cdFx0XHRkZXAubG9jID0gZXhwci5sb2M7XHJcblx0XHRcdHRoaXMuc3RhdGUuY3VycmVudC5hZGREZXBlbmRlbmN5KGRlcCk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIHJlc3VsdCA9IHRoaXMuYXBwbHlQbHVnaW5zQmFpbFJlc3VsdChcImNhbGwgcmVxdWlyZS5yZXNvbHZlKFdlYWspOml0ZW1cIiwgZXhwciwgcGFyYW0sIHdlYWspO1xyXG5cdFx0XHRpZihyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdHRoaXMuYXBwbHlQbHVnaW5zQmFpbFJlc3VsdChcImNhbGwgcmVxdWlyZS5yZXNvbHZlKFdlYWspOmNvbnRleHRcIiwgZXhwciwgcGFyYW0sIHdlYWspO1xyXG5cdFx0XHR9XHJcblx0XHRcdGRlcCA9IG5ldyBSZXF1aXJlUmVzb2x2ZUhlYWRlckRlcGVuZGVuY3koZXhwci5jYWxsZWUucmFuZ2UpO1xyXG5cdFx0XHRkZXAubG9jID0gZXhwci5sb2M7XHJcblx0XHRcdHRoaXMuc3RhdGUuY3VycmVudC5hZGREZXBlbmRlbmN5KGRlcCk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cdHBhcnNlci5wbHVnaW4oXCJjYWxsIHJlcXVpcmUucmVzb2x2ZShXZWFrKTppdGVtXCIsIGZ1bmN0aW9uKGV4cHIsIHBhcmFtLCB3ZWFrKSB7XHJcblx0XHRpZihwYXJhbS5pc1N0cmluZygpKSB7XHJcblx0XHRcdHZhciBkZXAgPSBuZXcgUmVxdWlyZVJlc29sdmVEZXBlbmRlbmN5KHBhcmFtLnN0cmluZywgcGFyYW0ucmFuZ2UpO1xyXG5cdFx0XHRkZXAubG9jID0gZXhwci5sb2M7XHJcblx0XHRcdGRlcC5vcHRpb25hbCA9ICEhdGhpcy5zY29wZS5pblRyeTtcclxuXHRcdFx0ZGVwLndlYWsgPSB3ZWFrO1xyXG5cdFx0XHR0aGlzLnN0YXRlLmN1cnJlbnQuYWRkRGVwZW5kZW5jeShkZXApO1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHRwYXJzZXIucGx1Z2luKFwiY2FsbCByZXF1aXJlLnJlc29sdmUoV2Vhayk6Y29udGV4dFwiLCBmdW5jdGlvbihleHByLCBwYXJhbSwgd2Vhaykge1xyXG5cdFx0dmFyIGRlcCA9IENvbnRleHREZXBlbmRlbmN5SGVscGVycy5jcmVhdGUoUmVxdWlyZVJlc29sdmVDb250ZXh0RGVwZW5kZW5jeSwgcGFyYW0ucmFuZ2UsIHBhcmFtLCBleHByLCBvcHRpb25zKTtcclxuXHRcdGlmKCFkZXApIHJldHVybjtcclxuXHRcdGRlcC5sb2MgPSBleHByLmxvYztcclxuXHRcdGRlcC5vcHRpb25hbCA9ICEhdGhpcy5zY29wZS5pblRyeTtcclxuXHRcdGRlcC53ZWFrID0gd2VhaztcclxuXHRcdHRoaXMuc3RhdGUuY3VycmVudC5hZGREZXBlbmRlbmN5KGRlcCk7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9KTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvUmVxdWlyZVJlc29sdmVEZXBlbmRlbmN5UGFyc2VyUGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIENvbnRleHREZXBlbmRlbmN5SGVscGVycyA9IGV4cG9ydHM7XHJcblxyXG5Db250ZXh0RGVwZW5kZW5jeUhlbHBlcnMuY3JlYXRlID0gZnVuY3Rpb24oRGVwLCByYW5nZSwgcGFyYW0sIGV4cHIsIG9wdGlvbnMpIHtcclxuXHRpZihwYXJhbS5pc1dyYXBwZWQoKSAmJiAocGFyYW0ucHJlZml4ICYmIHBhcmFtLnByZWZpeC5pc1N0cmluZygpIHx8IHBhcmFtLnBvc3RmaXggJiYgcGFyYW0ucG9zdGZpeC5pc1N0cmluZygpKSkge1xyXG5cdFx0dmFyIHByZWZpeCA9IHBhcmFtLnByZWZpeCAmJiBwYXJhbS5wcmVmaXguaXNTdHJpbmcoKSA/IHBhcmFtLnByZWZpeC5zdHJpbmcgOiBcIlwiO1xyXG5cdFx0dmFyIHBvc3RmaXggPSBwYXJhbS5wb3N0Zml4ICYmIHBhcmFtLnBvc3RmaXguaXNTdHJpbmcoKSA/IHBhcmFtLnBvc3RmaXguc3RyaW5nIDogXCJcIjtcclxuXHRcdHZhciBwcmVmaXhSYW5nZSA9IHBhcmFtLnByZWZpeCAmJiBwYXJhbS5wcmVmaXguaXNTdHJpbmcoKSA/IHBhcmFtLnByZWZpeC5yYW5nZSA6IG51bGw7XHJcblx0XHR2YXIgdmFsdWVSYW5nZSA9IFtwcmVmaXhSYW5nZSA/IHByZWZpeFJhbmdlWzFdIDogcGFyYW0ucmFuZ2VbMF0sIHBhcmFtLnJhbmdlWzFdXTtcclxuXHRcdHZhciBpZHggPSBwcmVmaXgubGFzdEluZGV4T2YoXCIvXCIpO1xyXG5cdFx0dmFyIGNvbnRleHQgPSBcIi5cIjtcclxuXHRcdGlmKGlkeCA+PSAwKSB7XHJcblx0XHRcdGNvbnRleHQgPSBwcmVmaXguc3Vic3RyKDAsIGlkeCk7XHJcblx0XHRcdHByZWZpeCA9IFwiLlwiICsgcHJlZml4LnN1YnN0cihpZHgpO1xyXG5cdFx0fVxyXG5cdFx0dmFyIHJlZ0V4cCA9IG5ldyBSZWdFeHAoXCJeXCIgK1xyXG5cdFx0XHRwcmVmaXgucmVwbGFjZSgvW1xcLVxcW1xcXVxcL1xce1xcfVxcKFxcKVxcKlxcK1xcP1xcLlxcXFxcXF5cXCRcXHxdL2csIFwiXFxcXCQmXCIpICtcclxuXHRcdFx0b3B0aW9ucy53cmFwcGVkQ29udGV4dFJlZ0V4cC5zb3VyY2UgK1xyXG5cdFx0XHRwb3N0Zml4LnJlcGxhY2UoL1tcXC1cXFtcXF1cXC9cXHtcXH1cXChcXClcXCpcXCtcXD9cXC5cXFxcXFxeXFwkXFx8XS9nLCBcIlxcXFwkJlwiKSArIFwiJFwiKTtcclxuXHRcdHZhciBkZXAgPSBuZXcgRGVwKGNvbnRleHQsIG9wdGlvbnMud3JhcHBlZENvbnRleHRSZWN1cnNpdmUsIHJlZ0V4cCwgcmFuZ2UsIHZhbHVlUmFuZ2UpO1xyXG5cdFx0ZGVwLmxvYyA9IGV4cHIubG9jO1xyXG5cdFx0ZGVwLnByZXBlbmQgPSBwYXJhbS5wcmVmaXggJiYgcGFyYW0ucHJlZml4LmlzU3RyaW5nKCkgPyBwcmVmaXggOiBudWxsO1xyXG5cdFx0ZGVwLmNyaXRpY2FsID0gb3B0aW9ucy53cmFwcGVkQ29udGV4dENyaXRpY2FsICYmIFwiYSBwYXJ0IG9mIHRoZSByZXF1ZXN0IG9mIGEgZGVwZW5kZW5jeSBpcyBhbiBleHByZXNzaW9uXCI7XHJcblx0XHRyZXR1cm4gZGVwO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgZGVwID0gbmV3IERlcChvcHRpb25zLmV4cHJDb250ZXh0UmVxdWVzdCwgb3B0aW9ucy5leHByQ29udGV4dFJlY3Vyc2l2ZSwgb3B0aW9ucy5leHByQ29udGV4dFJlZ0V4cCwgcmFuZ2UsIHBhcmFtLnJhbmdlKTtcclxuXHRcdGRlcC5sb2MgPSBleHByLmxvYztcclxuXHRcdGRlcC5jcml0aWNhbCA9IG9wdGlvbnMuZXhwckNvbnRleHRDcml0aWNhbCAmJiBcInRoZSByZXF1ZXN0IG9mIGEgZGVwZW5kZW5jeSBpcyBhbiBleHByZXNzaW9uXCI7XHJcblx0XHRyZXR1cm4gZGVwO1xyXG5cdH1cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvQ29udGV4dERlcGVuZGVuY3lIZWxwZXJzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIENvbnN0RGVwZW5kZW5jeSA9IHJlcXVpcmUoXCIuL0NvbnN0RGVwZW5kZW5jeVwiKTtcclxudmFyIENvbW1vbkpzUmVxdWlyZURlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9Db21tb25Kc1JlcXVpcmVEZXBlbmRlbmN5XCIpO1xyXG52YXIgQ29tbW9uSnNSZXF1aXJlQ29udGV4dERlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9Db21tb25Kc1JlcXVpcmVDb250ZXh0RGVwZW5kZW5jeVwiKTtcclxudmFyIFJlcXVpcmVIZWFkZXJEZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4vUmVxdWlyZUhlYWRlckRlcGVuZGVuY3lcIik7XHJcbnZhciBMb2NhbE1vZHVsZURlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9Mb2NhbE1vZHVsZURlcGVuZGVuY3lcIik7XHJcbnZhciBDb250ZXh0RGVwZW5kZW5jeUhlbHBlcnMgPSByZXF1aXJlKFwiLi9Db250ZXh0RGVwZW5kZW5jeUhlbHBlcnNcIik7XHJcbnZhciBMb2NhbE1vZHVsZXNIZWxwZXJzID0gcmVxdWlyZShcIi4vTG9jYWxNb2R1bGVzSGVscGVyc1wiKTtcclxuXHJcbmZ1bmN0aW9uIENvbW1vbkpzUmVxdWlyZURlcGVuZGVuY3lQYXJzZXJQbHVnaW4ob3B0aW9ucykge1xyXG5cdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29tbW9uSnNSZXF1aXJlRGVwZW5kZW5jeVBhcnNlclBsdWdpbjtcclxuXHJcbkNvbW1vbkpzUmVxdWlyZURlcGVuZGVuY3lQYXJzZXJQbHVnaW4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24ocGFyc2VyKSB7XHJcblx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblx0cGFyc2VyLnBsdWdpbihcImV4cHJlc3Npb24gcmVxdWlyZS5jYWNoZVwiLCBmdW5jdGlvbihleHByKSB7XHJcblx0XHR2YXIgZGVwID0gbmV3IENvbnN0RGVwZW5kZW5jeShcIl9fd2VicGFja19yZXF1aXJlX18uY1wiLCBleHByLnJhbmdlKTtcclxuXHRcdGRlcC5sb2MgPSBleHByLmxvYztcclxuXHRcdHRoaXMuc3RhdGUuY3VycmVudC5hZGREZXBlbmRlbmN5KGRlcCk7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9KTtcclxuXHRwYXJzZXIucGx1Z2luKFwiZXhwcmVzc2lvbiByZXF1aXJlXCIsIGZ1bmN0aW9uKGV4cHIpIHtcclxuXHRcdHZhciBkZXAgPSBuZXcgQ29tbW9uSnNSZXF1aXJlQ29udGV4dERlcGVuZGVuY3kob3B0aW9ucy51bmtub3duQ29udGV4dFJlcXVlc3QsIG9wdGlvbnMudW5rbm93bkNvbnRleHRSZWN1cnNpdmUsIG9wdGlvbnMudW5rbm93bkNvbnRleHRSZWdFeHAsIGV4cHIucmFuZ2UpO1xyXG5cdFx0ZGVwLmNyaXRpY2FsID0gb3B0aW9ucy51bmtub3duQ29udGV4dENyaXRpY2FsICYmIFwicmVxdWlyZSBmdW5jdGlvbiBpcyB1c2VkIGluIGEgd2F5IGluIHdoaWNoIGRlcGVuZGVuY2llcyBjYW5ub3QgYmUgc3RhdGljYWxseSBleHRyYWN0ZWRcIjtcclxuXHRcdGRlcC5sb2MgPSBleHByLmxvYztcclxuXHRcdGRlcC5vcHRpb25hbCA9ICEhdGhpcy5zY29wZS5pblRyeTtcclxuXHRcdHRoaXMuc3RhdGUuY3VycmVudC5hZGREZXBlbmRlbmN5KGRlcCk7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9KTtcclxuXHRwYXJzZXIucGx1Z2luKFwiY2FsbCByZXF1aXJlXCIsIGZ1bmN0aW9uKGV4cHIpIHtcclxuXHRcdGlmKGV4cHIuYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkgcmV0dXJuO1xyXG5cdFx0dmFyIGxvY2FsTW9kdWxlLCBkZXA7XHJcblx0XHR2YXIgcGFyYW0gPSB0aGlzLmV2YWx1YXRlRXhwcmVzc2lvbihleHByLmFyZ3VtZW50c1swXSk7XHJcblx0XHRpZihwYXJhbS5pc0NvbmRpdGlvbmFsKCkpIHtcclxuXHRcdFx0dmFyIGlzRXhwcmVzc2lvbiA9IGZhbHNlO1xyXG5cdFx0XHR2YXIgcHJldkxlbmd0aCA9IHRoaXMuc3RhdGUuY3VycmVudC5kZXBlbmRlbmNpZXMubGVuZ3RoO1xyXG5cdFx0XHRkZXAgPSBuZXcgUmVxdWlyZUhlYWRlckRlcGVuZGVuY3koZXhwci5jYWxsZWUucmFuZ2UpO1xyXG5cdFx0XHRkZXAubG9jID0gZXhwci5sb2M7XHJcblx0XHRcdHRoaXMuc3RhdGUuY3VycmVudC5hZGREZXBlbmRlbmN5KGRlcCk7XHJcblx0XHRcdHBhcmFtLm9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbihwYXJhbSkge1xyXG5cdFx0XHRcdHZhciByZXN1bHQgPSB0aGlzLmFwcGx5UGx1Z2luc0JhaWxSZXN1bHQoXCJjYWxsIHJlcXVpcmU6Y29tbW9uanM6aXRlbVwiLCBleHByLCBwYXJhbSk7XHJcblx0XHRcdFx0aWYocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdGlzRXhwcmVzc2lvbiA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdFx0aWYoaXNFeHByZXNzaW9uKSB7XHJcblx0XHRcdFx0dGhpcy5zdGF0ZS5jdXJyZW50LmRlcGVuZGVuY2llcy5sZW5ndGggPSBwcmV2TGVuZ3RoO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZihwYXJhbS5pc1N0cmluZygpICYmIChsb2NhbE1vZHVsZSA9IExvY2FsTW9kdWxlc0hlbHBlcnMuZ2V0TG9jYWxNb2R1bGUodGhpcy5zdGF0ZSwgcGFyYW0uc3RyaW5nKSkpIHtcclxuXHRcdFx0ZGVwID0gbmV3IExvY2FsTW9kdWxlRGVwZW5kZW5jeShsb2NhbE1vZHVsZSwgZXhwci5yYW5nZSk7XHJcblx0XHRcdGRlcC5sb2MgPSBleHByLmxvYztcclxuXHRcdFx0dGhpcy5zdGF0ZS5jdXJyZW50LmFkZERlcGVuZGVuY3koZGVwKTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgcmVzdWx0ID0gdGhpcy5hcHBseVBsdWdpbnNCYWlsUmVzdWx0KFwiY2FsbCByZXF1aXJlOmNvbW1vbmpzOml0ZW1cIiwgZXhwciwgcGFyYW0pO1xyXG5cdFx0XHRpZihyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdHRoaXMuYXBwbHlQbHVnaW5zQmFpbFJlc3VsdChcImNhbGwgcmVxdWlyZTpjb21tb25qczpjb250ZXh0XCIsIGV4cHIsIHBhcmFtKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRkZXAgPSBuZXcgUmVxdWlyZUhlYWRlckRlcGVuZGVuY3koZXhwci5jYWxsZWUucmFuZ2UpO1xyXG5cdFx0XHRcdGRlcC5sb2MgPSBleHByLmxvYztcclxuXHRcdFx0XHR0aGlzLnN0YXRlLmN1cnJlbnQuYWRkRGVwZW5kZW5jeShkZXApO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cdHBhcnNlci5wbHVnaW4oXCJjYWxsIHJlcXVpcmU6Y29tbW9uanM6aXRlbVwiLCBmdW5jdGlvbihleHByLCBwYXJhbSkge1xyXG5cdFx0aWYocGFyYW0uaXNTdHJpbmcoKSkge1xyXG5cdFx0XHR2YXIgZGVwID0gbmV3IENvbW1vbkpzUmVxdWlyZURlcGVuZGVuY3kocGFyYW0uc3RyaW5nLCBwYXJhbS5yYW5nZSk7XHJcblx0XHRcdGRlcC5sb2MgPSBleHByLmxvYztcclxuXHRcdFx0ZGVwLm9wdGlvbmFsID0gISF0aGlzLnNjb3BlLmluVHJ5O1xyXG5cdFx0XHR0aGlzLnN0YXRlLmN1cnJlbnQuYWRkRGVwZW5kZW5jeShkZXApO1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHRwYXJzZXIucGx1Z2luKFwiY2FsbCByZXF1aXJlOmNvbW1vbmpzOmNvbnRleHRcIiwgZnVuY3Rpb24oZXhwciwgcGFyYW0pIHtcclxuXHRcdHZhciBkZXAgPSBDb250ZXh0RGVwZW5kZW5jeUhlbHBlcnMuY3JlYXRlKENvbW1vbkpzUmVxdWlyZUNvbnRleHREZXBlbmRlbmN5LCBleHByLnJhbmdlLCBwYXJhbSwgZXhwciwgb3B0aW9ucyk7XHJcblx0XHRpZighZGVwKSByZXR1cm47XHJcblx0XHRkZXAubG9jID0gZXhwci5sb2M7XHJcblx0XHRkZXAub3B0aW9uYWwgPSAhIXRoaXMuc2NvcGUuaW5Ucnk7XHJcblx0XHR0aGlzLnN0YXRlLmN1cnJlbnQuYWRkRGVwZW5kZW5jeShkZXApO1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL0NvbW1vbkpzUmVxdWlyZURlcGVuZGVuY3lQYXJzZXJQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDEzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgTnVsbERlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9OdWxsRGVwZW5kZW5jeVwiKTtcclxuXHJcbmZ1bmN0aW9uIExvY2FsTW9kdWxlRGVwZW5kZW5jeShsb2NhbE1vZHVsZSwgcmFuZ2UpIHtcclxuXHROdWxsRGVwZW5kZW5jeS5jYWxsKHRoaXMpO1xyXG5cdGxvY2FsTW9kdWxlLmZsYWdVc2VkKCk7XHJcblx0dGhpcy5sb2NhbE1vZHVsZSA9IGxvY2FsTW9kdWxlO1xyXG5cdHRoaXMucmFuZ2UgPSByYW5nZTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IExvY2FsTW9kdWxlRGVwZW5kZW5jeTtcclxuXHJcbkxvY2FsTW9kdWxlRGVwZW5kZW5jeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE51bGxEZXBlbmRlbmN5LnByb3RvdHlwZSk7XHJcbkxvY2FsTW9kdWxlRGVwZW5kZW5jeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2NhbE1vZHVsZURlcGVuZGVuY3k7XHJcblxyXG5Mb2NhbE1vZHVsZURlcGVuZGVuY3kuVGVtcGxhdGUgPSBmdW5jdGlvbiBMb2NhbE1vZHVsZURlcGVuZGVuY3lUZW1wbGF0ZSgpIHt9O1xyXG5cclxuTG9jYWxNb2R1bGVEZXBlbmRlbmN5LlRlbXBsYXRlLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGRlcCwgc291cmNlKSB7XHJcblx0aWYoIWRlcC5yYW5nZSkgcmV0dXJuO1xyXG5cdHNvdXJjZS5yZXBsYWNlKGRlcC5yYW5nZVswXSwgZGVwLnJhbmdlWzFdIC0gMSwgZGVwLmxvY2FsTW9kdWxlLnZhcmlhYmxlTmFtZSgpKTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvTG9jYWxNb2R1bGVEZXBlbmRlbmN5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIExvY2FsTW9kdWxlID0gcmVxdWlyZShcIi4vTG9jYWxNb2R1bGVcIik7XHJcblxyXG52YXIgTG9jYWxNb2R1bGVzSGVscGVycyA9IGV4cG9ydHM7XHJcblxyXG5Mb2NhbE1vZHVsZXNIZWxwZXJzLmFkZExvY2FsTW9kdWxlID0gZnVuY3Rpb24oc3RhdGUsIG5hbWUpIHtcclxuXHRpZighc3RhdGUubG9jYWxNb2R1bGVzKSBzdGF0ZS5sb2NhbE1vZHVsZXMgPSBbXTtcclxuXHR2YXIgbSA9IG5ldyBMb2NhbE1vZHVsZShzdGF0ZS5tb2R1bGUsIG5hbWUsIHN0YXRlLmxvY2FsTW9kdWxlcy5sZW5ndGgpO1xyXG5cdHN0YXRlLmxvY2FsTW9kdWxlcy5wdXNoKG0pO1xyXG5cdHJldHVybiBtO1xyXG59O1xyXG5cclxuTG9jYWxNb2R1bGVzSGVscGVycy5nZXRMb2NhbE1vZHVsZSA9IGZ1bmN0aW9uKHN0YXRlLCBuYW1lLCBuYW1lZE1vZHVsZSkge1xyXG5cdGlmKCFzdGF0ZS5sb2NhbE1vZHVsZXMpIHJldHVybiBudWxsO1xyXG5cdGlmKG5hbWVkTW9kdWxlKSB7XHJcblx0XHQvLyByZXNvbHZlIGRlcGVuZGVuY3kgbmFtZSByZWxhdGl2ZSB0byB0aGUgZGVmaW5pbmcgbmFtZWQgbW9kdWxlXHJcblx0XHRuYW1lID0gbG9va3VwKG5hbWVkTW9kdWxlLCBuYW1lKTtcclxuXHR9XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IHN0YXRlLmxvY2FsTW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYoc3RhdGUubG9jYWxNb2R1bGVzW2ldLm5hbWUgPT09IG5hbWUpXHJcblx0XHRcdHJldHVybiBzdGF0ZS5sb2NhbE1vZHVsZXNbaV07XHJcblx0fVxyXG5cdHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gbG9va3VwKHBhcmVudCwgbW9kKSB7XHJcblx0aWYobW9kLmNoYXJBdCgwKSAhPT0gXCIuXCIpIHJldHVybiBtb2Q7XHJcblxyXG5cdHZhciBwYXRoID0gcGFyZW50LnNwbGl0KFwiL1wiKSxcclxuXHRcdHNlZ3MgPSBtb2Quc3BsaXQoXCIvXCIpO1xyXG5cdHBhdGgucG9wKCk7XHJcblxyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgc2VnID0gc2Vnc1tpXTtcclxuXHRcdGlmKHNlZyA9PT0gXCIuLlwiKSBwYXRoLnBvcCgpO1xyXG5cdFx0ZWxzZSBpZihzZWcgIT09IFwiLlwiKSBwYXRoLnB1c2goc2VnKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBwYXRoLmpvaW4oXCIvXCIpO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL0xvY2FsTW9kdWxlc0hlbHBlcnMuanNcbi8vIG1vZHVsZSBpZCA9IDEzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5mdW5jdGlvbiBMb2NhbE1vZHVsZShtb2R1bGUsIG5hbWUsIGlkeCkge1xyXG5cdHRoaXMubW9kdWxlID0gbW9kdWxlO1xyXG5cdHRoaXMubmFtZSA9IG5hbWU7XHJcblx0dGhpcy5pZHggPSBpZHg7XHJcblx0dGhpcy51c2VkID0gZmFsc2U7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBMb2NhbE1vZHVsZTtcclxuXHJcbkxvY2FsTW9kdWxlLnByb3RvdHlwZS5mbGFnVXNlZCA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMudXNlZCA9IHRydWU7XHJcbn07XHJcblxyXG5Mb2NhbE1vZHVsZS5wcm90b3R5cGUudmFyaWFibGVOYW1lID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFwiX19XRUJQQUNLX0xPQ0FMX01PRFVMRV9cIiArIHRoaXMuaWR4ICsgXCJfX1wiO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9Mb2NhbE1vZHVsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbnZhciBBTURSZXF1aXJlRGVwZW5kZW5jeSA9IHJlcXVpcmUoXCIuL0FNRFJlcXVpcmVEZXBlbmRlbmN5XCIpO1xyXG52YXIgQU1EUmVxdWlyZUl0ZW1EZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4vQU1EUmVxdWlyZUl0ZW1EZXBlbmRlbmN5XCIpO1xyXG52YXIgQU1EUmVxdWlyZUFycmF5RGVwZW5kZW5jeSA9IHJlcXVpcmUoXCIuL0FNRFJlcXVpcmVBcnJheURlcGVuZGVuY3lcIik7XHJcbnZhciBBTURSZXF1aXJlQ29udGV4dERlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9BTURSZXF1aXJlQ29udGV4dERlcGVuZGVuY3lcIik7XHJcbnZhciBBTUREZWZpbmVEZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4vQU1ERGVmaW5lRGVwZW5kZW5jeVwiKTtcclxudmFyIExvY2FsTW9kdWxlRGVwZW5kZW5jeSA9IHJlcXVpcmUoXCIuL0xvY2FsTW9kdWxlRGVwZW5kZW5jeVwiKTtcclxudmFyIENvbnN0RGVwZW5kZW5jeSA9IHJlcXVpcmUoXCIuL0NvbnN0RGVwZW5kZW5jeVwiKTtcclxuXHJcbnZhciBOdWxsRmFjdG9yeSA9IHJlcXVpcmUoXCIuLi9OdWxsRmFjdG9yeVwiKTtcclxuXHJcbnZhciBBTURSZXF1aXJlRGVwZW5kZW5jaWVzQmxvY2tQYXJzZXJQbHVnaW4gPSByZXF1aXJlKFwiLi9BTURSZXF1aXJlRGVwZW5kZW5jaWVzQmxvY2tQYXJzZXJQbHVnaW5cIik7XHJcbnZhciBBTUREZWZpbmVEZXBlbmRlbmN5UGFyc2VyUGx1Z2luID0gcmVxdWlyZShcIi4vQU1ERGVmaW5lRGVwZW5kZW5jeVBhcnNlclBsdWdpblwiKTtcclxuXHJcbnZhciBNb2R1bGVBbGlhc1BsdWdpbiA9IHJlcXVpcmUoXCJlbmhhbmNlZC1yZXNvbHZlL2xpYi9Nb2R1bGVBbGlhc1BsdWdpblwiKTtcclxuXHJcbnZhciBCYXNpY0V2YWx1YXRlZEV4cHJlc3Npb24gPSByZXF1aXJlKFwiLi4vQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uXCIpO1xyXG5cclxuZnVuY3Rpb24gQU1EUGx1Z2luKG9wdGlvbnMsIGFtZE9wdGlvbnMpIHtcclxuXHR0aGlzLmFtZE9wdGlvbnMgPSBhbWRPcHRpb25zO1xyXG5cdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBBTURQbHVnaW47XHJcblxyXG5BTURQbHVnaW4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oY29tcGlsZXIpIHtcclxuXHRmdW5jdGlvbiBzZXRUeXBlb2YoZXhwciwgdmFsdWUpIHtcclxuXHRcdGNvbXBpbGVyLnBhcnNlci5wbHVnaW4oXCJldmFsdWF0ZSB0eXBlb2YgXCIgKyBleHByLCBmdW5jdGlvbihleHByKSB7XHJcblx0XHRcdHJldHVybiBuZXcgQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uKCkuc2V0U3RyaW5nKHZhbHVlKS5zZXRSYW5nZShleHByLnJhbmdlKTtcclxuXHRcdH0pO1xyXG5cdFx0Y29tcGlsZXIucGFyc2VyLnBsdWdpbihcInR5cGVvZiBcIiArIGV4cHIsIGZ1bmN0aW9uKGV4cHIpIHtcclxuXHRcdFx0dmFyIGRlcCA9IG5ldyBDb25zdERlcGVuZGVuY3koSlNPTi5zdHJpbmdpZnkodmFsdWUpLCBleHByLnJhbmdlKTtcclxuXHRcdFx0ZGVwLmxvYyA9IGV4cHIubG9jO1xyXG5cdFx0XHR0aGlzLnN0YXRlLmN1cnJlbnQuYWRkRGVwZW5kZW5jeShkZXApO1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2V0RXhwcmVzc2lvblRvTW9kdWxlKGV4cHIsIG1vZHVsZSkge1xyXG5cdFx0Y29tcGlsZXIucGFyc2VyLnBsdWdpbihcImV4cHJlc3Npb24gXCIgKyBleHByLCBmdW5jdGlvbihleHByKSB7XHJcblx0XHRcdHZhciBkZXAgPSBuZXcgQU1EUmVxdWlyZUl0ZW1EZXBlbmRlbmN5KG1vZHVsZSwgZXhwci5yYW5nZSk7XHJcblx0XHRcdGRlcC51c2VyUmVxdWVzdCA9IGV4cHI7XHJcblx0XHRcdGRlcC5sb2MgPSBleHByLmxvYztcclxuXHRcdFx0dGhpcy5zdGF0ZS5jdXJyZW50LmFkZERlcGVuZGVuY3koZGVwKTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9KTtcclxuXHR9XHJcblx0dmFyIGFtZE9wdGlvbnMgPSB0aGlzLmFtZE9wdGlvbnM7XHJcblx0Y29tcGlsZXIucGx1Z2luKFwiY29tcGlsYXRpb25cIiwgZnVuY3Rpb24oY29tcGlsYXRpb24sIHBhcmFtcykge1xyXG5cdFx0dmFyIG5vcm1hbE1vZHVsZUZhY3RvcnkgPSBwYXJhbXMubm9ybWFsTW9kdWxlRmFjdG9yeTtcclxuXHRcdHZhciBjb250ZXh0TW9kdWxlRmFjdG9yeSA9IHBhcmFtcy5jb250ZXh0TW9kdWxlRmFjdG9yeTtcclxuXHJcblx0XHRjb21waWxhdGlvbi5kZXBlbmRlbmN5RmFjdG9yaWVzLnNldChBTURSZXF1aXJlRGVwZW5kZW5jeSwgbmV3IE51bGxGYWN0b3J5KCkpO1xyXG5cdFx0Y29tcGlsYXRpb24uZGVwZW5kZW5jeVRlbXBsYXRlcy5zZXQoQU1EUmVxdWlyZURlcGVuZGVuY3ksIG5ldyBBTURSZXF1aXJlRGVwZW5kZW5jeS5UZW1wbGF0ZSgpKTtcclxuXHJcblx0XHRjb21waWxhdGlvbi5kZXBlbmRlbmN5RmFjdG9yaWVzLnNldChBTURSZXF1aXJlSXRlbURlcGVuZGVuY3ksIG5vcm1hbE1vZHVsZUZhY3RvcnkpO1xyXG5cdFx0Y29tcGlsYXRpb24uZGVwZW5kZW5jeVRlbXBsYXRlcy5zZXQoQU1EUmVxdWlyZUl0ZW1EZXBlbmRlbmN5LCBuZXcgQU1EUmVxdWlyZUl0ZW1EZXBlbmRlbmN5LlRlbXBsYXRlKCkpO1xyXG5cclxuXHRcdGNvbXBpbGF0aW9uLmRlcGVuZGVuY3lGYWN0b3JpZXMuc2V0KEFNRFJlcXVpcmVBcnJheURlcGVuZGVuY3ksIG5ldyBOdWxsRmFjdG9yeSgpKTtcclxuXHRcdGNvbXBpbGF0aW9uLmRlcGVuZGVuY3lUZW1wbGF0ZXMuc2V0KEFNRFJlcXVpcmVBcnJheURlcGVuZGVuY3ksIG5ldyBBTURSZXF1aXJlQXJyYXlEZXBlbmRlbmN5LlRlbXBsYXRlKCkpO1xyXG5cclxuXHRcdGNvbXBpbGF0aW9uLmRlcGVuZGVuY3lGYWN0b3JpZXMuc2V0KEFNRFJlcXVpcmVDb250ZXh0RGVwZW5kZW5jeSwgY29udGV4dE1vZHVsZUZhY3RvcnkpO1xyXG5cdFx0Y29tcGlsYXRpb24uZGVwZW5kZW5jeVRlbXBsYXRlcy5zZXQoQU1EUmVxdWlyZUNvbnRleHREZXBlbmRlbmN5LCBuZXcgQU1EUmVxdWlyZUNvbnRleHREZXBlbmRlbmN5LlRlbXBsYXRlKCkpO1xyXG5cclxuXHRcdGNvbXBpbGF0aW9uLmRlcGVuZGVuY3lGYWN0b3JpZXMuc2V0KEFNRERlZmluZURlcGVuZGVuY3ksIG5ldyBOdWxsRmFjdG9yeSgpKTtcclxuXHRcdGNvbXBpbGF0aW9uLmRlcGVuZGVuY3lUZW1wbGF0ZXMuc2V0KEFNRERlZmluZURlcGVuZGVuY3ksIG5ldyBBTUREZWZpbmVEZXBlbmRlbmN5LlRlbXBsYXRlKCkpO1xyXG5cclxuXHRcdGNvbXBpbGF0aW9uLmRlcGVuZGVuY3lGYWN0b3JpZXMuc2V0KExvY2FsTW9kdWxlRGVwZW5kZW5jeSwgbmV3IE51bGxGYWN0b3J5KCkpO1xyXG5cdFx0Y29tcGlsYXRpb24uZGVwZW5kZW5jeVRlbXBsYXRlcy5zZXQoTG9jYWxNb2R1bGVEZXBlbmRlbmN5LCBuZXcgTG9jYWxNb2R1bGVEZXBlbmRlbmN5LlRlbXBsYXRlKCkpO1xyXG5cdH0pO1xyXG5cdGNvbXBpbGVyLnBhcnNlci5hcHBseShcclxuXHRcdG5ldyBBTURSZXF1aXJlRGVwZW5kZW5jaWVzQmxvY2tQYXJzZXJQbHVnaW4odGhpcy5vcHRpb25zKSxcclxuXHRcdG5ldyBBTUREZWZpbmVEZXBlbmRlbmN5UGFyc2VyUGx1Z2luKHRoaXMub3B0aW9ucylcclxuXHQpO1xyXG5cdHNldEV4cHJlc3Npb25Ub01vZHVsZShcInJlcXVpcmUuYW1kXCIsIFwiISF3ZWJwYWNrIGFtZCBvcHRpb25zXCIpO1xyXG5cdHNldEV4cHJlc3Npb25Ub01vZHVsZShcImRlZmluZS5hbWRcIiwgXCIhIXdlYnBhY2sgYW1kIG9wdGlvbnNcIik7XHJcblx0c2V0RXhwcmVzc2lvblRvTW9kdWxlKFwiZGVmaW5lXCIsIFwiISF3ZWJwYWNrIGFtZCBkZWZpbmVcIik7XHJcblx0Y29tcGlsZXIucGFyc2VyLnBsdWdpbihcImV4cHJlc3Npb24gX193ZWJwYWNrX2FtZF9vcHRpb25zX19cIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZS5jdXJyZW50LmFkZFZhcmlhYmxlKFwiX193ZWJwYWNrX2FtZF9vcHRpb25zX19cIiwgSlNPTi5zdHJpbmdpZnkoYW1kT3B0aW9ucykpO1xyXG5cdH0pO1xyXG5cdGNvbXBpbGVyLnBhcnNlci5wbHVnaW4oXCJldmFsdWF0ZSB0eXBlb2YgZGVmaW5lLmFtZFwiLCBmdW5jdGlvbihleHByKSB7XHJcblx0XHRyZXR1cm4gbmV3IEJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbigpLnNldFN0cmluZyh0eXBlb2YgYW1kT3B0aW9ucykuc2V0UmFuZ2UoZXhwci5yYW5nZSk7XHJcblx0fSk7XHJcblx0Y29tcGlsZXIucGFyc2VyLnBsdWdpbihcImV2YWx1YXRlIHR5cGVvZiByZXF1aXJlLmFtZFwiLCBmdW5jdGlvbihleHByKSB7XHJcblx0XHRyZXR1cm4gbmV3IEJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbigpLnNldFN0cmluZyh0eXBlb2YgYW1kT3B0aW9ucykuc2V0UmFuZ2UoZXhwci5yYW5nZSk7XHJcblx0fSk7XHJcblx0Y29tcGlsZXIucGFyc2VyLnBsdWdpbihcImV2YWx1YXRlIElkZW50aWZpZXIgZGVmaW5lLmFtZFwiLCBmdW5jdGlvbihleHByKSB7XHJcblx0XHRyZXR1cm4gbmV3IEJhc2ljRXZhbHVhdGVkRXhwcmVzc2lvbigpLnNldEJvb2xlYW4odHJ1ZSkuc2V0UmFuZ2UoZXhwci5yYW5nZSk7XHJcblx0fSk7XHJcblx0Y29tcGlsZXIucGFyc2VyLnBsdWdpbihcImV2YWx1YXRlIElkZW50aWZpZXIgcmVxdWlyZS5hbWRcIiwgZnVuY3Rpb24oZXhwcikge1xyXG5cdFx0cmV0dXJuIG5ldyBCYXNpY0V2YWx1YXRlZEV4cHJlc3Npb24oKS5zZXRCb29sZWFuKHRydWUpLnNldFJhbmdlKGV4cHIucmFuZ2UpO1xyXG5cdH0pO1xyXG5cdHNldFR5cGVvZihcImRlZmluZVwiLCBcImZ1bmN0aW9uXCIpO1xyXG5cdGNvbXBpbGVyLnBhcnNlci5wbHVnaW4oXCJjYW4tcmVuYW1lIGRlZmluZVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0pO1xyXG5cdGNvbXBpbGVyLnBhcnNlci5wbHVnaW4oXCJyZW5hbWUgZGVmaW5lXCIsIGZ1bmN0aW9uKGV4cHIpIHtcclxuXHRcdHZhciBkZXAgPSBuZXcgQU1EUmVxdWlyZUl0ZW1EZXBlbmRlbmN5KFwiISF3ZWJwYWNrIGFtZCBkZWZpbmVcIiwgZXhwci5yYW5nZSk7XHJcblx0XHRkZXAudXNlclJlcXVlc3QgPSBcImRlZmluZVwiO1xyXG5cdFx0ZGVwLmxvYyA9IGV4cHIubG9jO1xyXG5cdFx0dGhpcy5zdGF0ZS5jdXJyZW50LmFkZERlcGVuZGVuY3koZGVwKTtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9KTtcclxuXHRzZXRUeXBlb2YoXCJyZXF1aXJlXCIsIFwiZnVuY3Rpb25cIik7XHJcblx0Y29tcGlsZXIucmVzb2x2ZXJzLm5vcm1hbC5hcHBseShcclxuXHRcdG5ldyBNb2R1bGVBbGlhc1BsdWdpbih7XHJcblx0XHRcdFwiYW1kZWZpbmVcIjogcGF0aC5qb2luKF9fZGlybmFtZSwgXCIuLlwiLCBcIi4uXCIsIFwiYnVpbGRpblwiLCBcImFtZC1kZWZpbmUuanNcIiksXHJcblx0XHRcdFwid2VicGFjayBhbWQgb3B0aW9uc1wiOiBwYXRoLmpvaW4oX19kaXJuYW1lLCBcIi4uXCIsIFwiLi5cIiwgXCJidWlsZGluXCIsIFwiYW1kLW9wdGlvbnMuanNcIiksXHJcblx0XHRcdFwid2VicGFjayBhbWQgZGVmaW5lXCI6IHBhdGguam9pbihfX2Rpcm5hbWUsIFwiLi5cIiwgXCIuLlwiLCBcImJ1aWxkaW5cIiwgXCJhbWQtZGVmaW5lLmpzXCIpXHJcblx0XHR9KVxyXG5cdCk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL0FNRFBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBOdWxsRGVwZW5kZW5jeSA9IHJlcXVpcmUoXCIuL051bGxEZXBlbmRlbmN5XCIpO1xyXG52YXIgRGVwQmxvY2tIZWxwZXJzID0gcmVxdWlyZShcIi4vRGVwQmxvY2tIZWxwZXJzXCIpO1xyXG5cclxuZnVuY3Rpb24gQU1EUmVxdWlyZURlcGVuZGVuY3koYmxvY2spIHtcclxuXHROdWxsRGVwZW5kZW5jeS5jYWxsKHRoaXMpO1xyXG5cdHRoaXMuYmxvY2sgPSBibG9jaztcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IEFNRFJlcXVpcmVEZXBlbmRlbmN5O1xyXG5cclxuQU1EUmVxdWlyZURlcGVuZGVuY3kucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOdWxsRGVwZW5kZW5jeS5wcm90b3R5cGUpO1xyXG5BTURSZXF1aXJlRGVwZW5kZW5jeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBTURSZXF1aXJlRGVwZW5kZW5jeTtcclxuXHJcbkFNRFJlcXVpcmVEZXBlbmRlbmN5LlRlbXBsYXRlID0gZnVuY3Rpb24gQU1EUmVxdWlyZURlcGVuZGVuY3lUZW1wbGF0ZSgpIHt9O1xyXG5cclxuQU1EUmVxdWlyZURlcGVuZGVuY3kuVGVtcGxhdGUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oZGVwLCBzb3VyY2UsIG91dHB1dE9wdGlvbnMsIHJlcXVlc3RTaG9ydGVuZXIpIHtcclxuXHR2YXIgZGVwQmxvY2sgPSBkZXAuYmxvY2s7XHJcblx0dmFyIHdyYXBwZXIgPSBEZXBCbG9ja0hlbHBlcnMuZ2V0TG9hZERlcEJsb2NrV3JhcHBlcihkZXBCbG9jaywgb3V0cHV0T3B0aW9ucywgcmVxdWVzdFNob3J0ZW5lciwgXCJyZXF1aXJlXCIpO1xyXG5cdGlmKGRlcEJsb2NrLmFycmF5UmFuZ2UgJiYgIWRlcEJsb2NrLmZ1bmN0aW9uUmFuZ2UpIHtcclxuXHRcdGlmKHdyYXBwZXIpIHtcclxuXHRcdFx0c291cmNlLnJlcGxhY2UoZGVwQmxvY2sub3V0ZXJSYW5nZVswXSwgZGVwQmxvY2suYXJyYXlSYW5nZVswXSAtIDEsXHJcblx0XHRcdFx0d3JhcHBlclswXSArIFwiZnVuY3Rpb24oKSB7XCIpO1xyXG5cdFx0XHRzb3VyY2UucmVwbGFjZShkZXBCbG9jay5hcnJheVJhbmdlWzFdLCBkZXBCbG9jay5vdXRlclJhbmdlWzFdIC0gMSwgXCI7fVwiICsgd3JhcHBlclsxXSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzb3VyY2UucmVwbGFjZShkZXBCbG9jay5vdXRlclJhbmdlWzBdLCBkZXBCbG9jay5hcnJheVJhbmdlWzBdIC0gMSxcclxuXHRcdFx0XHRcIiEvKiByZXF1aXJlICovKFwiICsgYXNDb21tZW50KGRlcEJsb2NrLmNodW5rUmVhc29uKSk7XHJcblx0XHRcdHNvdXJjZS5yZXBsYWNlKGRlcEJsb2NrLmFycmF5UmFuZ2VbMV0sIGRlcEJsb2NrLm91dGVyUmFuZ2VbMV0gLSAxLCBcIilcIik7XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmKCFkZXBCbG9jay5hcnJheVJhbmdlICYmIGRlcEJsb2NrLmZ1bmN0aW9uUmFuZ2UpIHtcclxuXHRcdGlmKHdyYXBwZXIpIHtcclxuXHRcdFx0c291cmNlLnJlcGxhY2UoZGVwQmxvY2sub3V0ZXJSYW5nZVswXSwgZGVwQmxvY2suZnVuY3Rpb25SYW5nZVswXSAtIDEsXHJcblx0XHRcdFx0d3JhcHBlclswXSArIFwiZnVuY3Rpb24oX193ZWJwYWNrX3JlcXVpcmVfXykgeyhcIik7XHJcblx0XHRcdHNvdXJjZS5yZXBsYWNlKGRlcEJsb2NrLmZ1bmN0aW9uUmFuZ2VbMV0sIGRlcEJsb2NrLm91dGVyUmFuZ2VbMV0gLSAxLCBcIi5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSkpO31cIiArIHdyYXBwZXJbMV0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c291cmNlLnJlcGxhY2UoZGVwQmxvY2sub3V0ZXJSYW5nZVswXSwgZGVwQmxvY2suZnVuY3Rpb25SYW5nZVswXSAtIDEsXHJcblx0XHRcdFx0XCIhLyogcmVxdWlyZSAqLyhcIiArIGFzQ29tbWVudChkZXBCbG9jay5jaHVua1JlYXNvbikpO1xyXG5cdFx0XHRzb3VyY2UucmVwbGFjZShkZXBCbG9jay5mdW5jdGlvblJhbmdlWzFdLCBkZXBCbG9jay5vdXRlclJhbmdlWzFdIC0gMSwgXCIuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpKVwiKTtcclxuXHRcdH1cclxuXHR9IGVsc2UgaWYoZGVwQmxvY2suYXJyYXlSYW5nZSAmJiBkZXBCbG9jay5mdW5jdGlvblJhbmdlKSB7XHJcblx0XHRpZih3cmFwcGVyKSB7XHJcblx0XHRcdHNvdXJjZS5yZXBsYWNlKGRlcEJsb2NrLm91dGVyUmFuZ2VbMF0sIGRlcEJsb2NrLmFycmF5UmFuZ2VbMF0gLSAxLFxyXG5cdFx0XHRcdHdyYXBwZXJbMF0gKyBcImZ1bmN0aW9uKF9fd2VicGFja19yZXF1aXJlX18pIHsgXCIpO1xyXG5cdFx0XHRzb3VyY2UuaW5zZXJ0KGRlcEJsb2NrLmFycmF5UmFuZ2VbMF0gKyAwLjksIFwidmFyIF9fV0VCUEFDS19BTURfUkVRVUlSRV9BUlJBWV9fID0gXCIpO1xyXG5cdFx0XHRzb3VyY2UucmVwbGFjZShkZXBCbG9jay5hcnJheVJhbmdlWzFdLCBkZXBCbG9jay5mdW5jdGlvblJhbmdlWzBdIC0gMSwgXCI7IChcIik7XHJcblx0XHRcdHNvdXJjZS5pbnNlcnQoZGVwQmxvY2suZnVuY3Rpb25SYW5nZVsxXSwgXCIuYXBwbHkobnVsbCwgX19XRUJQQUNLX0FNRF9SRVFVSVJFX0FSUkFZX18pKTtcIik7XHJcblx0XHRcdHNvdXJjZS5yZXBsYWNlKGRlcEJsb2NrLmZ1bmN0aW9uUmFuZ2VbMV0sIGRlcEJsb2NrLm91dGVyUmFuZ2VbMV0gLSAxLCBcIn1cIiArIChkZXBCbG9jay5iaW5kVGhpcyA/IFwiLmJpbmQodGhpcylcIiA6IFwiXCIpICsgd3JhcHBlclsxXSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzb3VyY2UucmVwbGFjZShkZXBCbG9jay5vdXRlclJhbmdlWzBdLCBkZXBCbG9jay5hcnJheVJhbmdlWzBdIC0gMSxcclxuXHRcdFx0XHRcIiEvKiByZXF1aXJlICovKFwiICsgYXNDb21tZW50KGRlcEJsb2NrLmNodW5rUmVhc29uKSArIFwiZnVuY3Rpb24oKSB7IFwiKTtcclxuXHRcdFx0c291cmNlLmluc2VydChkZXBCbG9jay5hcnJheVJhbmdlWzBdICsgMC45LCBcInZhciBfX1dFQlBBQ0tfQU1EX1JFUVVJUkVfQVJSQVlfXyA9IFwiKTtcclxuXHRcdFx0c291cmNlLnJlcGxhY2UoZGVwQmxvY2suYXJyYXlSYW5nZVsxXSwgZGVwQmxvY2suZnVuY3Rpb25SYW5nZVswXSAtIDEsIFwiOyAoXCIpO1xyXG5cdFx0XHRzb3VyY2UuaW5zZXJ0KGRlcEJsb2NrLmZ1bmN0aW9uUmFuZ2VbMV0sIFwiLmFwcGx5KG51bGwsIF9fV0VCUEFDS19BTURfUkVRVUlSRV9BUlJBWV9fKSk7XCIpO1xyXG5cdFx0XHRzb3VyY2UucmVwbGFjZShkZXBCbG9jay5mdW5jdGlvblJhbmdlWzFdLCBkZXBCbG9jay5vdXRlclJhbmdlWzFdIC0gMSwgXCJ9XCIgKyAoZGVwQmxvY2suYmluZFRoaXMgPyBcIi5jYWxsKHRoaXMpXCIgOiBcIigpXCIpICsgXCIpXCIpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbmZ1bmN0aW9uIGFzQ29tbWVudChzdHIpIHtcclxuXHRpZighc3RyKSByZXR1cm4gXCJcIjtcclxuXHRyZXR1cm4gXCIvKiBcIiArIHN0ciArIFwiICovXCI7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvQU1EUmVxdWlyZURlcGVuZGVuY3kuanNcbi8vIG1vZHVsZSBpZCA9IDE0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgRGVwQmxvY2tIZWxwZXJzID0gZXhwb3J0cztcclxuXHJcbkRlcEJsb2NrSGVscGVycy5nZXRMb2FkRGVwQmxvY2tXcmFwcGVyID0gZnVuY3Rpb24oZGVwQmxvY2ssIG91dHB1dE9wdGlvbnMsIHJlcXVlc3RTaG9ydGVuZXIsIG5hbWUpIHtcclxuXHRpZihkZXBCbG9jay5jaHVua3MpIHtcclxuXHRcdHZhciBjaHVua3MgPSBkZXBCbG9jay5jaHVua3MuZmlsdGVyKGZ1bmN0aW9uKGNodW5rKSB7XHJcblx0XHRcdHJldHVybiAhY2h1bmsuZW50cnkgJiYgdHlwZW9mIGNodW5rLmlkID09PSBcIm51bWJlclwiO1xyXG5cdFx0fSk7XHJcblx0XHRpZihjaHVua3MubGVuZ3RoID09PSAxKSB7XHJcblx0XHRcdHZhciBjaHVuayA9IGNodW5rc1swXTtcclxuXHRcdFx0cmV0dXJuIFtcclxuXHRcdFx0XHRcIl9fd2VicGFja19yZXF1aXJlX18uZVwiICsgYXNDb21tZW50KG5hbWUpICsgXCIoXCIgKyBjaHVuay5pZCArIFwiXCIgK1xyXG5cdFx0XHRcdChvdXRwdXRPcHRpb25zLnBhdGhpbmZvICYmIGRlcEJsb2NrLmNodW5rTmFtZSA/IFwiLyohIFwiICsgcmVxdWVzdFNob3J0ZW5lci5zaG9ydGVuKGRlcEJsb2NrLmNodW5rTmFtZSkgKyBcIiAqL1wiIDogXCJcIikgK1xyXG5cdFx0XHRcdGFzQ29tbWVudChkZXBCbG9jay5jaHVua1JlYXNvbikgKyBcIiwgXCIsXHJcblx0XHRcdFx0XCIpXCJcclxuXHRcdFx0XTtcclxuXHRcdH0gZWxzZSBpZihjaHVua3MubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRyZXR1cm4gW1xyXG5cdFx0XHRcdFwiKGZ1bmN0aW9uKFwiICsgYXNDb21tZW50KG5hbWUpICsgXCIpIHtcIiArXHJcblx0XHRcdFx0XCJ2YXIgX19XRUJQQUNLX1JFTUFJTklOR19DSFVOS1NfXyA9IFwiICsgY2h1bmtzLmxlbmd0aCArIFwiO1wiICtcclxuXHRcdFx0XHRcInZhciBfX1dFQlBBQ0tfQ0FMTEJBQ0tfXyA9IGZ1bmN0aW9uKCkge1wiICtcclxuXHRcdFx0XHRcImlmKC0tX19XRUJQQUNLX1JFTUFJTklOR19DSFVOS1NfXyA8IDEpIChcIixcclxuXHJcblx0XHRcdFx0XCIoX193ZWJwYWNrX3JlcXVpcmVfXykpO1wiICtcclxuXHRcdFx0XHRcIn0uYmluZCh0aGlzKTtcIiArXHJcblx0XHRcdFx0Y2h1bmtzLm1hcChmdW5jdGlvbihjaHVuaykge1xyXG5cdFx0XHRcdFx0cmV0dXJuIFwiX193ZWJwYWNrX3JlcXVpcmVfXy5lKFwiICsgY2h1bmsuaWQgKyBcIiwgX19XRUJQQUNLX0NBTExCQUNLX18pO1wiO1xyXG5cdFx0XHRcdH0pLmpvaW4oXCJcIikgK1xyXG5cdFx0XHRcdFwifSkuY2FsbCh0aGlzKVwiXHJcblx0XHRcdF07XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuZnVuY3Rpb24gYXNDb21tZW50KHN0cikge1xyXG5cdGlmKCFzdHIpIHJldHVybiBcIlwiO1xyXG5cdHJldHVybiBcIi8qIFwiICsgc3RyICsgXCIgKi9cIjtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9EZXBCbG9ja0hlbHBlcnMuanNcbi8vIG1vZHVsZSBpZCA9IDE0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgTW9kdWxlRGVwZW5kZW5jeSA9IHJlcXVpcmUoXCIuL01vZHVsZURlcGVuZGVuY3lcIik7XHJcblxyXG5mdW5jdGlvbiBBTURSZXF1aXJlSXRlbURlcGVuZGVuY3kocmVxdWVzdCwgcmFuZ2UpIHtcclxuXHRNb2R1bGVEZXBlbmRlbmN5LmNhbGwodGhpcywgcmVxdWVzdCk7XHJcblx0dGhpcy5yYW5nZSA9IHJhbmdlO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gQU1EUmVxdWlyZUl0ZW1EZXBlbmRlbmN5O1xyXG5cclxuQU1EUmVxdWlyZUl0ZW1EZXBlbmRlbmN5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTW9kdWxlRGVwZW5kZW5jeS5wcm90b3R5cGUpO1xyXG5BTURSZXF1aXJlSXRlbURlcGVuZGVuY3kucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQU1EUmVxdWlyZUl0ZW1EZXBlbmRlbmN5O1xyXG5BTURSZXF1aXJlSXRlbURlcGVuZGVuY3kucHJvdG90eXBlLnR5cGUgPSBcImFtZCByZXF1aXJlXCI7XHJcblxyXG5BTURSZXF1aXJlSXRlbURlcGVuZGVuY3kuVGVtcGxhdGUgPSByZXF1aXJlKFwiLi9Nb2R1bGVEZXBlbmRlbmN5VGVtcGxhdGVBc1JlcXVpcmVJZFwiKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvQU1EUmVxdWlyZUl0ZW1EZXBlbmRlbmN5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuZnVuY3Rpb24gTW9kdWxlRGVwZW5kZW5jeVRlbXBsYXRlQXNSZXF1aXJlSWQoKSB7fVxyXG5tb2R1bGUuZXhwb3J0cyA9IE1vZHVsZURlcGVuZGVuY3lUZW1wbGF0ZUFzUmVxdWlyZUlkO1xyXG5cclxuTW9kdWxlRGVwZW5kZW5jeVRlbXBsYXRlQXNSZXF1aXJlSWQucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oZGVwLCBzb3VyY2UsIG91dHB1dE9wdGlvbnMsIHJlcXVlc3RTaG9ydGVuZXIpIHtcclxuXHRpZighZGVwLnJhbmdlKSByZXR1cm47XHJcblx0dmFyIGNvbW1lbnQgPSBcIlwiO1xyXG5cdGlmKG91dHB1dE9wdGlvbnMucGF0aGluZm8pIGNvbW1lbnQgPSBcIi8qISBcIiArIHJlcXVlc3RTaG9ydGVuZXIuc2hvcnRlbihkZXAucmVxdWVzdCkgKyBcIiAqLyBcIjtcclxuXHRpZihkZXAubW9kdWxlKVxyXG5cdFx0dmFyIGNvbnRlbnQgPSBcIl9fd2VicGFja19yZXF1aXJlX18oXCIgKyBjb21tZW50ICsgSlNPTi5zdHJpbmdpZnkoZGVwLm1vZHVsZS5pZCkgKyBcIilcIjtcclxuXHRlbHNlXHJcblx0XHR2YXIgY29udGVudCA9IHJlcXVpcmUoXCIuL1dlYnBhY2tNaXNzaW5nTW9kdWxlXCIpLm1vZHVsZShkZXAucmVxdWVzdCk7XHJcblx0c291cmNlLnJlcGxhY2UoZGVwLnJhbmdlWzBdLCBkZXAucmFuZ2VbMV0gLSAxLCBjb250ZW50KTtcclxufTtcclxuXHJcbk1vZHVsZURlcGVuZGVuY3lUZW1wbGF0ZUFzUmVxdWlyZUlkLnByb3RvdHlwZS5hcHBseUFzVGVtcGxhdGVBcmd1bWVudCA9IGZ1bmN0aW9uKG5hbWUsIGRlcCwgc291cmNlKSB7XHJcblx0aWYoIWRlcC5yYW5nZSkgcmV0dXJuO1xyXG5cdHNvdXJjZS5yZXBsYWNlKGRlcC5yYW5nZVswXSwgZGVwLnJhbmdlWzFdIC0gMSwgXCIoX193ZWJwYWNrX3JlcXVpcmVfXyhcIiArIG5hbWUgKyBcIikpXCIpO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9Nb2R1bGVEZXBlbmRlbmN5VGVtcGxhdGVBc1JlcXVpcmVJZC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBEZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4uL0RlcGVuZGVuY3lcIik7XHJcblxyXG5mdW5jdGlvbiBBTURSZXF1aXJlQXJyYXlEZXBlbmRlbmN5KGRlcHNBcnJheSwgcmFuZ2UpIHtcclxuXHREZXBlbmRlbmN5LmNhbGwodGhpcyk7XHJcblx0dGhpcy5kZXBzQXJyYXkgPSBkZXBzQXJyYXk7XHJcblx0dGhpcy5yYW5nZSA9IHJhbmdlO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gQU1EUmVxdWlyZUFycmF5RGVwZW5kZW5jeTtcclxuXHJcbkFNRFJlcXVpcmVBcnJheURlcGVuZGVuY3kucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShEZXBlbmRlbmN5LnByb3RvdHlwZSk7XHJcbkFNRFJlcXVpcmVBcnJheURlcGVuZGVuY3kucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQU1EUmVxdWlyZUFycmF5RGVwZW5kZW5jeTtcclxuQU1EUmVxdWlyZUFycmF5RGVwZW5kZW5jeS5wcm90b3R5cGUudHlwZSA9IFwiYW1kIHJlcXVpcmUgYXJyYXlcIjtcclxuXHJcbkFNRFJlcXVpcmVBcnJheURlcGVuZGVuY3kuVGVtcGxhdGUgPSBmdW5jdGlvbiBBTURSZXF1aXJlQXJyYXlEZXBlbmRlbmN5VGVtcGxhdGUoKSB7fTtcclxuXHJcbkFNRFJlcXVpcmVBcnJheURlcGVuZGVuY3kuVGVtcGxhdGUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oZGVwLCBzb3VyY2UsIG91dHB1dE9wdGlvbnMsIHJlcXVlc3RTaG9ydGVuZXIpIHtcclxuXHR2YXIgY29udGVudCA9IFwiW1wiICsgZGVwLmRlcHNBcnJheS5tYXAoZnVuY3Rpb24oZGVwKSB7XHJcblx0XHRpZih0eXBlb2YgZGVwID09PSBcInN0cmluZ1wiKSB7XHJcblx0XHRcdHJldHVybiBkZXA7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgY29tbWVudCA9IFwiXCI7XHJcblx0XHRcdGlmKG91dHB1dE9wdGlvbnMucGF0aGluZm8pIGNvbW1lbnQgPSBcIi8qISBcIiArIHJlcXVlc3RTaG9ydGVuZXIuc2hvcnRlbihkZXAucmVxdWVzdCkgKyBcIiAqLyBcIjtcclxuXHRcdFx0aWYoZGVwLm1vZHVsZSlcclxuXHRcdFx0XHRyZXR1cm4gXCJfX3dlYnBhY2tfcmVxdWlyZV9fKFwiICsgY29tbWVudCArIEpTT04uc3RyaW5naWZ5KGRlcC5tb2R1bGUuaWQpICsgXCIpXCI7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHRyZXR1cm4gcmVxdWlyZShcIi4vV2VicGFja01pc3NpbmdNb2R1bGVcIikubW9kdWxlKGRlcC5yZXF1ZXN0KTtcclxuXHRcdH1cclxuXHR9KS5qb2luKFwiLCBcIikgKyBcIl1cIjtcclxuXHRzb3VyY2UucmVwbGFjZShkZXAucmFuZ2VbMF0sIGRlcC5yYW5nZVsxXSAtIDEsIGNvbnRlbnQpO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9BTURSZXF1aXJlQXJyYXlEZXBlbmRlbmN5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIENvbnRleHREZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4vQ29udGV4dERlcGVuZGVuY3lcIik7XHJcblxyXG5mdW5jdGlvbiBBTURSZXF1aXJlQ29udGV4dERlcGVuZGVuY3kocmVxdWVzdCwgcmVjdXJzaXZlLCByZWdFeHAsIHJhbmdlLCB2YWx1ZVJhbmdlKSB7XHJcblx0Q29udGV4dERlcGVuZGVuY3kuY2FsbCh0aGlzLCByZXF1ZXN0LCByZWN1cnNpdmUsIHJlZ0V4cCk7XHJcblx0dGhpcy5yYW5nZSA9IHJhbmdlO1xyXG5cdHRoaXMudmFsdWVSYW5nZSA9IHZhbHVlUmFuZ2U7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBBTURSZXF1aXJlQ29udGV4dERlcGVuZGVuY3k7XHJcblxyXG5BTURSZXF1aXJlQ29udGV4dERlcGVuZGVuY3kucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb250ZXh0RGVwZW5kZW5jeS5wcm90b3R5cGUpO1xyXG5BTURSZXF1aXJlQ29udGV4dERlcGVuZGVuY3kucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQU1EUmVxdWlyZUNvbnRleHREZXBlbmRlbmN5O1xyXG5BTURSZXF1aXJlQ29udGV4dERlcGVuZGVuY3kucHJvdG90eXBlLnR5cGUgPSBcImFtZCByZXF1aXJlIGNvbnRleHRcIjtcclxuXHJcbkFNRFJlcXVpcmVDb250ZXh0RGVwZW5kZW5jeS5UZW1wbGF0ZSA9IHJlcXVpcmUoXCIuL0NvbnRleHREZXBlbmRlbmN5VGVtcGxhdGVBc1JlcXVpcmVDYWxsXCIpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9BTURSZXF1aXJlQ29udGV4dERlcGVuZGVuY3kuanNcbi8vIG1vZHVsZSBpZCA9IDE0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgTnVsbERlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9OdWxsRGVwZW5kZW5jeVwiKTtcclxuXHJcbmZ1bmN0aW9uIEFNRERlZmluZURlcGVuZGVuY3kocmFuZ2UsIGFycmF5UmFuZ2UsIGZ1bmN0aW9uUmFuZ2UsIG9iamVjdFJhbmdlKSB7XHJcblx0TnVsbERlcGVuZGVuY3kuY2FsbCh0aGlzKTtcclxuXHR0aGlzLnJhbmdlID0gcmFuZ2U7XHJcblx0dGhpcy5hcnJheVJhbmdlID0gYXJyYXlSYW5nZTtcclxuXHR0aGlzLmZ1bmN0aW9uUmFuZ2UgPSBmdW5jdGlvblJhbmdlO1xyXG5cdHRoaXMub2JqZWN0UmFuZ2UgPSBvYmplY3RSYW5nZTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IEFNRERlZmluZURlcGVuZGVuY3k7XHJcblxyXG5BTUREZWZpbmVEZXBlbmRlbmN5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTnVsbERlcGVuZGVuY3kucHJvdG90eXBlKTtcclxuQU1ERGVmaW5lRGVwZW5kZW5jeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBTUREZWZpbmVEZXBlbmRlbmN5O1xyXG5BTUREZWZpbmVEZXBlbmRlbmN5LnByb3RvdHlwZS50eXBlID0gXCJhbWQgZGVmaW5lXCI7XHJcblxyXG5BTUREZWZpbmVEZXBlbmRlbmN5LlRlbXBsYXRlID0gZnVuY3Rpb24gQU1ERGVmaW5lRGVwZW5kZW5jeVRlbXBsYXRlKCkge307XHJcblxyXG5BTUREZWZpbmVEZXBlbmRlbmN5LlRlbXBsYXRlLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGRlcCwgc291cmNlKSB7XHJcblx0dmFyIGxvY2FsTW9kdWxlVmFyID0gZGVwLmxvY2FsTW9kdWxlICYmIGRlcC5sb2NhbE1vZHVsZS51c2VkICYmIGRlcC5sb2NhbE1vZHVsZS52YXJpYWJsZU5hbWUoKTtcclxuXHJcblx0ZnVuY3Rpb24gcmVwbGFjZShkZWYsIHRleHQpIHtcclxuXHRcdGlmKGxvY2FsTW9kdWxlVmFyKSB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9YWFgvZywgbG9jYWxNb2R1bGVWYXIucmVwbGFjZSgvXFwkL2csIFwiJCQkJFwiKSk7XHJcblx0XHRpZihsb2NhbE1vZHVsZVZhcikgZGVmID0gZGVmLnJlcGxhY2UoL1hYWC9nLCBsb2NhbE1vZHVsZVZhci5yZXBsYWNlKC9cXCQvZywgXCIkJCQkXCIpKTtcclxuXHRcdHZhciB0ZXh0cyA9IHRleHQuc3BsaXQoXCIjXCIpO1xyXG5cdFx0aWYoZGVmKVxyXG5cdFx0XHRzb3VyY2UuaW5zZXJ0KDAsIGRlZik7XHJcblx0XHR2YXIgY3VycmVudCA9IGRlcC5yYW5nZVswXTtcclxuXHRcdGlmKGRlcC5hcnJheVJhbmdlKSB7XHJcblx0XHRcdHNvdXJjZS5yZXBsYWNlKGN1cnJlbnQsIGRlcC5hcnJheVJhbmdlWzBdIC0gMSwgdGV4dHMuc2hpZnQoKSk7XHJcblx0XHRcdGN1cnJlbnQgPSBkZXAuYXJyYXlSYW5nZVsxXTtcclxuXHRcdH1cclxuXHRcdGlmKGRlcC5vYmplY3RSYW5nZSkge1xyXG5cdFx0XHRzb3VyY2UucmVwbGFjZShjdXJyZW50LCBkZXAub2JqZWN0UmFuZ2VbMF0gLSAxLCB0ZXh0cy5zaGlmdCgpKTtcclxuXHRcdFx0Y3VycmVudCA9IGRlcC5vYmplY3RSYW5nZVsxXTtcclxuXHRcdH0gZWxzZSBpZihkZXAuZnVuY3Rpb25SYW5nZSkge1xyXG5cdFx0XHRzb3VyY2UucmVwbGFjZShjdXJyZW50LCBkZXAuZnVuY3Rpb25SYW5nZVswXSAtIDEsIHRleHRzLnNoaWZ0KCkpO1xyXG5cdFx0XHRjdXJyZW50ID0gZGVwLmZ1bmN0aW9uUmFuZ2VbMV07XHJcblx0XHR9XHJcblx0XHRzb3VyY2UucmVwbGFjZShjdXJyZW50LCBkZXAucmFuZ2VbMV0gLSAxLCB0ZXh0cy5zaGlmdCgpKTtcclxuXHRcdGlmKHRleHRzLmxlbmd0aCA+IDApXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkltcGxlbWVudGF0aW9uIGVycm9yXCIpO1xyXG5cdH1cclxuXHR2YXIgYnJhbmNoID0gKGxvY2FsTW9kdWxlVmFyID8gXCJsXCIgOiBcIlwiKSArIChkZXAuYXJyYXlSYW5nZSA/IFwiYVwiIDogXCJcIikgKyAoZGVwLm9iamVjdFJhbmdlID8gXCJvXCIgOiBcIlwiKSArIChkZXAuZnVuY3Rpb25SYW5nZSA/IFwiZlwiIDogXCJcIik7XHJcblx0dmFyIGRlZnMgPSB7XHJcblx0XHRmOiBbXCJ2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XCIsIFwiIShfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICMuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSlcIl0sXHJcblx0XHRvOiBbXCJcIiwgXCIhKG1vZHVsZS5leHBvcnRzID0gIylcIl0sXHJcblx0XHRvZjogW1widmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XCIsIFwiIShfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoIyksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKHR5cGVvZiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPT09ICdmdW5jdGlvbicgPyAoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSlcIl0sXHJcblx0XHRhZjogW1widmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO1wiLCBcIiEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9ICMsIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gIy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpXCJdLFxyXG5cdFx0YW86IFtcIlwiLCBcIiEoIywgbW9kdWxlLmV4cG9ydHMgPSAjKVwiXSxcclxuXHRcdGFvZjogW1widmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187XCIsIFwiIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gIywgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID0gKCMpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID8gKF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSlcIl0sXHJcblx0XHRsZjogW1widmFyIFhYWDtcIiwgXCIhKFhYWCA9ICMuY2FsbChleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fLCBleHBvcnRzLCBtb2R1bGUpKVwiXSxcclxuXHRcdGxvOiBbXCJ2YXIgWFhYO1wiLCBcIiEoWFhYID0gIylcIl0sXHJcblx0XHRsb2Y6IFtcInZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIFhYWDtcIiwgXCIhKF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9ICgjKSwgWFhYID0gKHR5cGVvZiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPT09ICdmdW5jdGlvbicgPyAoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXywgZXhwb3J0cywgbW9kdWxlKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pKVwiXSxcclxuXHRcdGxhZjogW1widmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIFhYWDtcIiwgXCIhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSAjLCBYWFggPSAoIy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSkpXCJdLFxyXG5cdFx0bGFvOiBbXCJ2YXIgWFhYO1wiLCBcIiEoIywgWFhYID0gIylcIl0sXHJcblx0XHRsYW9mOiBbXCJ2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBYWFg7XCIsIFwiIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gIywgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID0gKCMpLCBYWFggPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/IChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSlcIl1cclxuXHR9O1xyXG5cdHJlcGxhY2UuYXBwbHkobnVsbCwgZGVmc1ticmFuY2hdKTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvQU1ERGVmaW5lRGVwZW5kZW5jeS5qc1xuLy8gbW9kdWxlIGlkID0gMTQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBBTURSZXF1aXJlSXRlbURlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9BTURSZXF1aXJlSXRlbURlcGVuZGVuY3lcIik7XHJcbnZhciBBTURSZXF1aXJlQXJyYXlEZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4vQU1EUmVxdWlyZUFycmF5RGVwZW5kZW5jeVwiKTtcclxudmFyIEFNRFJlcXVpcmVDb250ZXh0RGVwZW5kZW5jeSA9IHJlcXVpcmUoXCIuL0FNRFJlcXVpcmVDb250ZXh0RGVwZW5kZW5jeVwiKTtcclxudmFyIEFNRFJlcXVpcmVEZXBlbmRlbmNpZXNCbG9jayA9IHJlcXVpcmUoXCIuL0FNRFJlcXVpcmVEZXBlbmRlbmNpZXNCbG9ja1wiKTtcclxudmFyIExvY2FsTW9kdWxlRGVwZW5kZW5jeSA9IHJlcXVpcmUoXCIuL0xvY2FsTW9kdWxlRGVwZW5kZW5jeVwiKTtcclxudmFyIENvbnRleHREZXBlbmRlbmN5SGVscGVycyA9IHJlcXVpcmUoXCIuL0NvbnRleHREZXBlbmRlbmN5SGVscGVyc1wiKTtcclxudmFyIExvY2FsTW9kdWxlc0hlbHBlcnMgPSByZXF1aXJlKFwiLi9Mb2NhbE1vZHVsZXNIZWxwZXJzXCIpO1xyXG52YXIgQ29uc3REZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4vQ29uc3REZXBlbmRlbmN5XCIpO1xyXG52YXIgZ2V0RnVuY3Rpb25FeHByZXNzaW9uID0gcmVxdWlyZShcIi4vZ2V0RnVuY3Rpb25FeHByZXNzaW9uXCIpO1xyXG5cclxuZnVuY3Rpb24gQU1EUmVxdWlyZURlcGVuZGVuY2llc0Jsb2NrUGFyc2VyUGx1Z2luKG9wdGlvbnMpIHtcclxuXHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFNRFJlcXVpcmVEZXBlbmRlbmNpZXNCbG9ja1BhcnNlclBsdWdpbjtcclxuXHJcbkFNRFJlcXVpcmVEZXBlbmRlbmNpZXNCbG9ja1BhcnNlclBsdWdpbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbihwYXJzZXIpIHtcclxuXHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHRwYXJzZXIucGx1Z2luKFwiY2FsbCByZXF1aXJlXCIsIGZ1bmN0aW9uKGV4cHIpIHtcclxuXHRcdHN3aXRjaChleHByLmFyZ3VtZW50cy5sZW5ndGgpIHtcclxuXHRcdFx0Y2FzZSAxOlxyXG5cdFx0XHRcdHZhciBwYXJhbSA9IHRoaXMuZXZhbHVhdGVFeHByZXNzaW9uKGV4cHIuYXJndW1lbnRzWzBdKTtcclxuXHRcdFx0XHR2YXIgcmVzdWx0O1xyXG5cdFx0XHRcdHZhciBkZXAgPSBuZXcgQU1EUmVxdWlyZURlcGVuZGVuY2llc0Jsb2NrKGV4cHIsIHBhcmFtLnJhbmdlLCBudWxsLCB0aGlzLnN0YXRlLm1vZHVsZSwgZXhwci5sb2MpO1xyXG5cdFx0XHRcdHZhciBvbGQgPSB0aGlzLnN0YXRlLmN1cnJlbnQ7XHJcblx0XHRcdFx0dGhpcy5zdGF0ZS5jdXJyZW50ID0gZGVwO1xyXG5cdFx0XHRcdHRoaXMuaW5TY29wZShbXSwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRyZXN1bHQgPSB0aGlzLmFwcGx5UGx1Z2luc0JhaWxSZXN1bHQoXCJjYWxsIHJlcXVpcmU6YW1kOmFycmF5XCIsIGV4cHIsIHBhcmFtKTtcclxuXHRcdFx0XHR9LmJpbmQodGhpcykpO1xyXG5cdFx0XHRcdHRoaXMuc3RhdGUuY3VycmVudCA9IG9sZDtcclxuXHRcdFx0XHRpZighcmVzdWx0KSByZXR1cm47XHJcblx0XHRcdFx0dGhpcy5zdGF0ZS5jdXJyZW50LmFkZEJsb2NrKGRlcCk7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdGNhc2UgMjpcclxuXHRcdFx0XHR2YXIgcGFyYW0gPSB0aGlzLmV2YWx1YXRlRXhwcmVzc2lvbihleHByLmFyZ3VtZW50c1swXSk7XHJcblx0XHRcdFx0dmFyIGRlcCA9IG5ldyBBTURSZXF1aXJlRGVwZW5kZW5jaWVzQmxvY2soZXhwciwgcGFyYW0ucmFuZ2UsIGV4cHIuYXJndW1lbnRzWzFdLnJhbmdlLCB0aGlzLnN0YXRlLm1vZHVsZSwgZXhwci5sb2MpO1xyXG5cdFx0XHRcdGRlcC5sb2MgPSBleHByLmxvYztcclxuXHRcdFx0XHR2YXIgb2xkID0gdGhpcy5zdGF0ZS5jdXJyZW50O1xyXG5cdFx0XHRcdHRoaXMuc3RhdGUuY3VycmVudCA9IGRlcDtcclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0dmFyIHJlc3VsdDtcclxuXHRcdFx0XHRcdHRoaXMuaW5TY29wZShbXSwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdHJlc3VsdCA9IHRoaXMuYXBwbHlQbHVnaW5zQmFpbFJlc3VsdChcImNhbGwgcmVxdWlyZTphbWQ6YXJyYXlcIiwgZXhwciwgcGFyYW0pO1xyXG5cdFx0XHRcdFx0fS5iaW5kKHRoaXMpKTtcclxuXHRcdFx0XHRcdGlmKCFyZXN1bHQpIHJldHVybjtcclxuXHRcdFx0XHRcdHZhciBmbkRhdGEgPSBnZXRGdW5jdGlvbkV4cHJlc3Npb24oZXhwci5hcmd1bWVudHNbMV0pO1xyXG5cdFx0XHRcdFx0aWYoZm5EYXRhKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuaW5TY29wZShmbkRhdGEuZm4ucGFyYW1zLmZpbHRlcihmdW5jdGlvbihpKSB7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFtcInJlcXVpcmVcIiwgXCJtb2R1bGVcIiwgXCJleHBvcnRzXCJdLmluZGV4T2YoaS5uYW1lKSA8IDA7XHJcblx0XHRcdFx0XHRcdH0pLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0XHRpZihmbkRhdGEuZm4uYm9keS50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIpXHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLndhbGtTdGF0ZW1lbnQoZm5EYXRhLmZuLmJvZHkpO1xyXG5cdFx0XHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0XHRcdHRoaXMud2Fsa0V4cHJlc3Npb24oZm5EYXRhLmZuLmJvZHkpO1xyXG5cdFx0XHRcdFx0XHR9LmJpbmQodGhpcykpO1xyXG5cdFx0XHRcdFx0XHR0aGlzLndhbGtFeHByZXNzaW9ucyhmbkRhdGEuZXhwcmVzc2lvbnMpO1xyXG5cdFx0XHRcdFx0XHRpZihmbkRhdGEubmVlZFRoaXMgPT09IGZhbHNlKSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gc21hbGxlciBidW5kbGVzIGZvciBzaW1wbGUgZnVuY3Rpb24gZXhwcmVzc2lvblxyXG5cdFx0XHRcdFx0XHRcdGRlcC5iaW5kVGhpcyA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0aGlzLndhbGtFeHByZXNzaW9uKGV4cHIuYXJndW1lbnRzWzFdKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGZpbmFsbHkge1xyXG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5jdXJyZW50ID0gb2xkO1xyXG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5jdXJyZW50LmFkZEJsb2NrKGRlcCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cdHBhcnNlci5wbHVnaW4oXCJjYWxsIHJlcXVpcmU6YW1kOmFycmF5XCIsIGZ1bmN0aW9uKGV4cHIsIHBhcmFtKSB7XHJcblx0XHRpZihwYXJhbS5pc0FycmF5KCkpIHtcclxuXHRcdFx0cGFyYW0uaXRlbXMuZm9yRWFjaChmdW5jdGlvbihwYXJhbSkge1xyXG5cdFx0XHRcdHZhciByZXN1bHQgPSB0aGlzLmFwcGx5UGx1Z2luc0JhaWxSZXN1bHQoXCJjYWxsIHJlcXVpcmU6YW1kOml0ZW1cIiwgZXhwciwgcGFyYW0pO1xyXG5cdFx0XHRcdGlmKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHR0aGlzLmFwcGx5UGx1Z2luc0JhaWxSZXN1bHQoXCJjYWxsIHJlcXVpcmU6YW1kOmNvbnRleHRcIiwgZXhwciwgcGFyYW0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSwgdGhpcyk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSBlbHNlIGlmKHBhcmFtLmlzQ29uc3RBcnJheSgpKSB7XHJcblx0XHRcdHZhciBkZXBzID0gW107XHJcblx0XHRcdHBhcmFtLmFycmF5LmZvckVhY2goZnVuY3Rpb24ocmVxdWVzdCkge1xyXG5cdFx0XHRcdHZhciBkZXAsIGxvY2FsTW9kdWxlO1xyXG5cdFx0XHRcdGlmKHJlcXVlc3QgPT09IFwicmVxdWlyZVwiKSB7XHJcblx0XHRcdFx0XHRkZXAgPSBcIl9fd2VicGFja19yZXF1aXJlX19cIjtcclxuXHRcdFx0XHR9IGVsc2UgaWYoW1wiZXhwb3J0c1wiLCBcIm1vZHVsZVwiXS5pbmRleE9mKHJlcXVlc3QpID49IDApIHtcclxuXHRcdFx0XHRcdGRlcCA9IHJlcXVlc3Q7XHJcblx0XHRcdFx0fSBlbHNlIGlmKGxvY2FsTW9kdWxlID0gTG9jYWxNb2R1bGVzSGVscGVycy5nZXRMb2NhbE1vZHVsZSh0aGlzLnN0YXRlLCByZXF1ZXN0KSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbmQtYXNzaWduXHJcblx0XHRcdFx0XHRkZXAgPSBuZXcgTG9jYWxNb2R1bGVEZXBlbmRlbmN5KGxvY2FsTW9kdWxlKTtcclxuXHRcdFx0XHRcdGRlcC5sb2MgPSBleHByLmxvYztcclxuXHRcdFx0XHRcdHRoaXMuc3RhdGUuY3VycmVudC5hZGREZXBlbmRlbmN5KGRlcCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGRlcCA9IG5ldyBBTURSZXF1aXJlSXRlbURlcGVuZGVuY3kocmVxdWVzdCk7XHJcblx0XHRcdFx0XHRkZXAubG9jID0gZXhwci5sb2M7XHJcblx0XHRcdFx0XHRkZXAub3B0aW9uYWwgPSAhIXRoaXMuc2NvcGUuaW5Ucnk7XHJcblx0XHRcdFx0XHR0aGlzLnN0YXRlLmN1cnJlbnQuYWRkRGVwZW5kZW5jeShkZXApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRkZXBzLnB1c2goZGVwKTtcclxuXHRcdFx0fSwgdGhpcyk7XHJcblx0XHRcdHZhciBkZXAgPSBuZXcgQU1EUmVxdWlyZUFycmF5RGVwZW5kZW5jeShkZXBzLCBwYXJhbS5yYW5nZSk7XHJcblx0XHRcdGRlcC5sb2MgPSBleHByLmxvYztcclxuXHRcdFx0ZGVwLm9wdGlvbmFsID0gISF0aGlzLnNjb3BlLmluVHJ5O1xyXG5cdFx0XHR0aGlzLnN0YXRlLmN1cnJlbnQuYWRkRGVwZW5kZW5jeShkZXApO1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHRwYXJzZXIucGx1Z2luKFwiY2FsbCByZXF1aXJlOmFtZDppdGVtXCIsIGZ1bmN0aW9uKGV4cHIsIHBhcmFtKSB7XHJcblx0XHRpZihwYXJhbS5pc0NvbmRpdGlvbmFsKCkpIHtcclxuXHRcdFx0cGFyYW0ub3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtKSB7XHJcblx0XHRcdFx0dmFyIHJlc3VsdCA9IHRoaXMuYXBwbHlQbHVnaW5zQmFpbFJlc3VsdChcImNhbGwgcmVxdWlyZTphbWQ6aXRlbVwiLCBleHByLCBwYXJhbSk7XHJcblx0XHRcdFx0aWYocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdHRoaXMuYXBwbHlQbHVnaW5zQmFpbFJlc3VsdChcImNhbGwgcmVxdWlyZTphbWQ6Y29udGV4dFwiLCBleHByLCBwYXJhbSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9IGVsc2UgaWYocGFyYW0uaXNTdHJpbmcoKSkge1xyXG5cdFx0XHR2YXIgZGVwLCBsb2NhbE1vZHVsZTtcclxuXHRcdFx0aWYocGFyYW0uc3RyaW5nID09PSBcInJlcXVpcmVcIikge1xyXG5cdFx0XHRcdGRlcCA9IG5ldyBDb25zdERlcGVuZGVuY3koXCJfX3dlYnBhY2tfcmVxdWlyZV9fXCIsIHBhcmFtLnN0cmluZyk7XHJcblx0XHRcdH0gZWxzZSBpZihbXCJleHBvcnRzXCIsIFwibW9kdWxlXCJdLmluZGV4T2YocGFyYW0uc3RyaW5nKSA+PSAwKSB7XHJcblx0XHRcdFx0ZGVwID0gbmV3IENvbnN0RGVwZW5kZW5jeShwYXJhbS5zdHJpbmcsIHBhcmFtLnJhbmdlKTtcclxuXHRcdFx0fSBlbHNlIGlmKGxvY2FsTW9kdWxlID0gTG9jYWxNb2R1bGVzSGVscGVycy5nZXRMb2NhbE1vZHVsZSh0aGlzLnN0YXRlLCBwYXJhbS5zdHJpbmcpKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uZC1hc3NpZ25cclxuXHRcdFx0XHRkZXAgPSBuZXcgTG9jYWxNb2R1bGVEZXBlbmRlbmN5KGxvY2FsTW9kdWxlLCBwYXJhbS5yYW5nZSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ZGVwID0gbmV3IEFNRFJlcXVpcmVJdGVtRGVwZW5kZW5jeShwYXJhbS5zdHJpbmcsIHBhcmFtLnJhbmdlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRkZXAubG9jID0gZXhwci5sb2M7XHJcblx0XHRcdGRlcC5vcHRpb25hbCA9ICEhdGhpcy5zY29wZS5pblRyeTtcclxuXHRcdFx0dGhpcy5zdGF0ZS5jdXJyZW50LmFkZERlcGVuZGVuY3koZGVwKTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblx0fSk7XHJcblx0cGFyc2VyLnBsdWdpbihcImNhbGwgcmVxdWlyZTphbWQ6Y29udGV4dFwiLCBmdW5jdGlvbihleHByLCBwYXJhbSkge1xyXG5cdFx0dmFyIGRlcCA9IENvbnRleHREZXBlbmRlbmN5SGVscGVycy5jcmVhdGUoQU1EUmVxdWlyZUNvbnRleHREZXBlbmRlbmN5LCBwYXJhbS5yYW5nZSwgcGFyYW0sIGV4cHIsIG9wdGlvbnMpO1xyXG5cdFx0aWYoIWRlcCkgcmV0dXJuO1xyXG5cdFx0ZGVwLmxvYyA9IGV4cHIubG9jO1xyXG5cdFx0ZGVwLm9wdGlvbmFsID0gISF0aGlzLnNjb3BlLmluVHJ5O1xyXG5cdFx0dGhpcy5zdGF0ZS5jdXJyZW50LmFkZERlcGVuZGVuY3koZGVwKTtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0pO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9BTURSZXF1aXJlRGVwZW5kZW5jaWVzQmxvY2tQYXJzZXJQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDE0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgQXN5bmNEZXBlbmRlbmNpZXNCbG9jayA9IHJlcXVpcmUoXCIuLi9Bc3luY0RlcGVuZGVuY2llc0Jsb2NrXCIpO1xyXG52YXIgQU1EUmVxdWlyZURlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9BTURSZXF1aXJlRGVwZW5kZW5jeVwiKTtcclxuXHJcbmZ1bmN0aW9uIEFNRFJlcXVpcmVEZXBlbmRlbmNpZXNCbG9jayhleHByLCBhcnJheVJhbmdlLCBmdW5jdGlvblJhbmdlLCBtb2R1bGUsIGxvYykge1xyXG5cdEFzeW5jRGVwZW5kZW5jaWVzQmxvY2suY2FsbCh0aGlzLCBudWxsLCBtb2R1bGUsIGxvYyk7XHJcblx0dGhpcy5leHByID0gZXhwcjtcclxuXHR0aGlzLm91dGVyUmFuZ2UgPSBleHByLnJhbmdlO1xyXG5cdHRoaXMuYXJyYXlSYW5nZSA9IGFycmF5UmFuZ2U7XHJcblx0dGhpcy5mdW5jdGlvblJhbmdlID0gZnVuY3Rpb25SYW5nZTtcclxuXHR0aGlzLmJpbmRUaGlzID0gdHJ1ZTtcclxuXHR0aGlzLnJhbmdlID0gYXJyYXlSYW5nZSAmJiBmdW5jdGlvblJhbmdlID8gW2FycmF5UmFuZ2VbMF0sIGZ1bmN0aW9uUmFuZ2VbMV1dIDpcclxuXHRcdGFycmF5UmFuZ2UgPyBhcnJheVJhbmdlIDpcclxuXHRcdGZ1bmN0aW9uUmFuZ2UgPyBmdW5jdGlvblJhbmdlIDpcclxuXHRcdGV4cHIucmFuZ2U7XHJcblx0dmFyIGRlcCA9IG5ldyBBTURSZXF1aXJlRGVwZW5kZW5jeSh0aGlzKTtcclxuXHRkZXAubG9jID0gbG9jO1xyXG5cdHRoaXMuYWRkRGVwZW5kZW5jeShkZXApO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gQU1EUmVxdWlyZURlcGVuZGVuY2llc0Jsb2NrO1xyXG5cclxuQU1EUmVxdWlyZURlcGVuZGVuY2llc0Jsb2NrLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQXN5bmNEZXBlbmRlbmNpZXNCbG9jay5wcm90b3R5cGUpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9BTURSZXF1aXJlRGVwZW5kZW5jaWVzQmxvY2suanNcbi8vIG1vZHVsZSBpZCA9IDE1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4cHIpIHtcclxuXHQvLyA8RnVuY3Rpb25FeHByZXNzaW9uPlxyXG5cdGlmKGV4cHIudHlwZSA9PT0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIikge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0Zm46IGV4cHIsXHJcblx0XHRcdGV4cHJlc3Npb25zOiBbXSxcclxuXHRcdFx0bmVlZFRoaXM6IGZhbHNlXHJcblx0XHR9O1xyXG5cdH1cclxuXHQvLyA8RnVuY3Rpb25FeHByZXNzaW9uPi5iaW5kKDxFeHByZXNzaW9uPilcclxuXHRpZihleHByLnR5cGUgPT09IFwiQ2FsbEV4cHJlc3Npb25cIiAmJlxyXG5cdFx0ZXhwci5jYWxsZWUudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiZcclxuXHRcdGV4cHIuY2FsbGVlLm9iamVjdC50eXBlID09PSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiICYmXHJcblx0XHRleHByLmNhbGxlZS5wcm9wZXJ0eS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJlxyXG5cdFx0ZXhwci5jYWxsZWUucHJvcGVydHkubmFtZSA9PT0gXCJiaW5kXCIgJiZcclxuXHRcdGV4cHIuYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0Zm46IGV4cHIuY2FsbGVlLm9iamVjdCxcclxuXHRcdFx0ZXhwcmVzc2lvbnM6IFtleHByLmFyZ3VtZW50c1swXV1cclxuXHRcdH07XHJcblx0fVxyXG5cdC8vIChmdW5jdGlvbihfdGhpcykge3JldHVybiA8RnVuY3Rpb25FeHByZXNzaW9uPn0pKHRoaXMpIChDb2ZmZWVzY3JpcHQpXHJcblx0aWYoZXhwci50eXBlID09PSBcIkNhbGxFeHByZXNzaW9uXCIgJiZcclxuXHRcdGV4cHIuY2FsbGVlLnR5cGUgPT09IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIgJiZcclxuXHRcdGV4cHIuY2FsbGVlLmJvZHkudHlwZSA9PT0gXCJCbG9ja1N0YXRlbWVudFwiICYmXHJcblx0XHRleHByLmFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiZcclxuXHRcdGV4cHIuYXJndW1lbnRzWzBdLnR5cGUgPT09IFwiVGhpc0V4cHJlc3Npb25cIiAmJlxyXG5cdFx0ZXhwci5jYWxsZWUuYm9keS5ib2R5ICYmXHJcblx0XHRleHByLmNhbGxlZS5ib2R5LmJvZHkubGVuZ3RoID09PSAxICYmXHJcblx0XHRleHByLmNhbGxlZS5ib2R5LmJvZHlbMF0udHlwZSA9PT0gXCJSZXR1cm5TdGF0ZW1lbnRcIiAmJlxyXG5cdFx0ZXhwci5jYWxsZWUuYm9keS5ib2R5WzBdLmFyZ3VtZW50ICYmXHJcblx0XHRleHByLmNhbGxlZS5ib2R5LmJvZHlbMF0uYXJndW1lbnQudHlwZSA9PT0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIikge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0Zm46IGV4cHIuY2FsbGVlLmJvZHkuYm9keVswXS5hcmd1bWVudCxcclxuXHRcdFx0ZXhwcmVzc2lvbnM6IFtdLFxyXG5cdFx0XHRuZWVkVGhpczogdHJ1ZVxyXG5cdFx0fTtcclxuXHR9XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL2dldEZ1bmN0aW9uRXhwcmVzc2lvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBBTURSZXF1aXJlSXRlbURlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9BTURSZXF1aXJlSXRlbURlcGVuZGVuY3lcIik7XHJcbnZhciBBTURSZXF1aXJlQ29udGV4dERlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9BTURSZXF1aXJlQ29udGV4dERlcGVuZGVuY3lcIik7XHJcbnZhciBDb25zdERlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9Db25zdERlcGVuZGVuY3lcIik7XHJcbnZhciBBTUREZWZpbmVEZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4vQU1ERGVmaW5lRGVwZW5kZW5jeVwiKTtcclxudmFyIEFNRFJlcXVpcmVBcnJheURlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9BTURSZXF1aXJlQXJyYXlEZXBlbmRlbmN5XCIpO1xyXG52YXIgTG9jYWxNb2R1bGVEZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4vTG9jYWxNb2R1bGVEZXBlbmRlbmN5XCIpO1xyXG52YXIgQ29udGV4dERlcGVuZGVuY3lIZWxwZXJzID0gcmVxdWlyZShcIi4vQ29udGV4dERlcGVuZGVuY3lIZWxwZXJzXCIpO1xyXG52YXIgTG9jYWxNb2R1bGVzSGVscGVycyA9IHJlcXVpcmUoXCIuL0xvY2FsTW9kdWxlc0hlbHBlcnNcIik7XHJcblxyXG5mdW5jdGlvbiBpc0JvdW5kRnVuY3Rpb25FeHByZXNzaW9uKGV4cHIpIHtcclxuXHRpZihleHByLnR5cGUgIT09IFwiQ2FsbEV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xyXG5cdGlmKGV4cHIuY2FsbGVlLnR5cGUgIT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSByZXR1cm4gZmFsc2U7XHJcblx0aWYoZXhwci5jYWxsZWUuY29tcHV0ZWQpIHJldHVybiBmYWxzZTtcclxuXHRpZihleHByLmNhbGxlZS5vYmplY3QudHlwZSAhPT0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xyXG5cdGlmKGV4cHIuY2FsbGVlLnByb3BlcnR5LnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSByZXR1cm4gZmFsc2U7XHJcblx0aWYoZXhwci5jYWxsZWUucHJvcGVydHkubmFtZSAhPT0gXCJiaW5kXCIpIHJldHVybiBmYWxzZTtcclxuXHRyZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gQU1ERGVmaW5lRGVwZW5kZW5jeVBhcnNlclBsdWdpbihvcHRpb25zKSB7XHJcblx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBTUREZWZpbmVEZXBlbmRlbmN5UGFyc2VyUGx1Z2luO1xyXG5BTUREZWZpbmVEZXBlbmRlbmN5UGFyc2VyUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKHBhcnNlcikge1xyXG5cdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cdHBhcnNlci5wbHVnaW4oXCJjYWxsIGRlZmluZVwiLCBmdW5jdGlvbihleHByKSB7XHJcblx0XHR2YXIgYXJyYXksIGZuLCBvYmosIG5hbWVkTW9kdWxlO1xyXG5cdFx0c3dpdGNoKGV4cHIuYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRjYXNlIDE6XHJcblx0XHRcdFx0aWYoZXhwci5hcmd1bWVudHNbMF0udHlwZSA9PT0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIiB8fCBpc0JvdW5kRnVuY3Rpb25FeHByZXNzaW9uKGV4cHIuYXJndW1lbnRzWzBdKSkge1xyXG5cdFx0XHRcdFx0Ly8gZGVmaW5lKGYoKSB7Li4ufSlcclxuXHRcdFx0XHRcdGZuID0gZXhwci5hcmd1bWVudHNbMF07XHJcblx0XHRcdFx0fSBlbHNlIGlmKGV4cHIuYXJndW1lbnRzWzBdLnR5cGUgPT09IFwiT2JqZWN0RXhwcmVzc2lvblwiKSB7XHJcblx0XHRcdFx0XHQvLyBkZWZpbmUoey4uLn0pXHJcblx0XHRcdFx0XHRvYmogPSBleHByLmFyZ3VtZW50c1swXTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Ly8gZGVmaW5lKGV4cHIpXHJcblx0XHRcdFx0XHQvLyB1bmNsZWFyIGlmIGZ1bmN0aW9uIG9yIG9iamVjdFxyXG5cdFx0XHRcdFx0b2JqID0gZm4gPSBleHByLmFyZ3VtZW50c1swXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgMjpcclxuXHRcdFx0XHRpZihleHByLmFyZ3VtZW50c1swXS50eXBlID09PSBcIkxpdGVyYWxcIikge1xyXG5cdFx0XHRcdFx0bmFtZWRNb2R1bGUgPSBleHByLmFyZ3VtZW50c1swXS52YWx1ZTtcclxuXHRcdFx0XHRcdC8vIGRlZmluZShcIi4uLlwiLCAuLi4pXHJcblx0XHRcdFx0XHRpZihleHByLmFyZ3VtZW50c1sxXS50eXBlID09PSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiIHx8IGlzQm91bmRGdW5jdGlvbkV4cHJlc3Npb24oZXhwci5hcmd1bWVudHNbMV0pKSB7XHJcblx0XHRcdFx0XHRcdC8vIGRlZmluZShcIi4uLlwiLCBmKCkgey4uLn0pXHJcblx0XHRcdFx0XHRcdGZuID0gZXhwci5hcmd1bWVudHNbMV07XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoZXhwci5hcmd1bWVudHNbMV0udHlwZSA9PT0gXCJPYmplY3RFeHByZXNzaW9uXCIpIHtcclxuXHRcdFx0XHRcdFx0Ly8gZGVmaW5lKFwiLi4uXCIsIHsuLi59KVxyXG5cdFx0XHRcdFx0XHRvYmogPSBleHByLmFyZ3VtZW50c1sxXTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdC8vIGRlZmluZShcIi4uLlwiLCBleHByKVxyXG5cdFx0XHRcdFx0XHQvLyB1bmNsZWFyIGlmIGZ1bmN0aW9uIG9yIG9iamVjdFxyXG5cdFx0XHRcdFx0XHRvYmogPSBmbiA9IGV4cHIuYXJndW1lbnRzWzFdO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRhcnJheSA9IGV4cHIuYXJndW1lbnRzWzBdO1xyXG5cdFx0XHRcdFx0aWYoZXhwci5hcmd1bWVudHNbMV0udHlwZSA9PT0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIiB8fCBpc0JvdW5kRnVuY3Rpb25FeHByZXNzaW9uKGV4cHIuYXJndW1lbnRzWzFdKSkge1xyXG5cdFx0XHRcdFx0XHQvLyBkZWZpbmUoWy4uLl0sIGYoKSB7fSlcclxuXHRcdFx0XHRcdFx0Zm4gPSBleHByLmFyZ3VtZW50c1sxXTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZihleHByLmFyZ3VtZW50c1sxXS50eXBlID09PSBcIk9iamVjdEV4cHJlc3Npb25cIikge1xyXG5cdFx0XHRcdFx0XHQvLyBkZWZpbmUoWy4uLl0sIHsuLi59KVxyXG5cdFx0XHRcdFx0XHRvYmogPSBleHByLmFyZ3VtZW50c1sxXTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdC8vIGRlZmluZShbLi4uXSwgZXhwcilcclxuXHRcdFx0XHRcdFx0Ly8gdW5jbGVhciBpZiBmdW5jdGlvbiBvciBvYmplY3RcclxuXHRcdFx0XHRcdFx0b2JqID0gZm4gPSBleHByLmFyZ3VtZW50c1sxXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgMzpcclxuXHRcdFx0XHQvLyBkZWZpbmUoXCIuLi5cIiwgWy4uLl0sIGYoKSB7Li4ufSlcclxuXHRcdFx0XHRuYW1lZE1vZHVsZSA9IGV4cHIuYXJndW1lbnRzWzBdLnZhbHVlO1xyXG5cdFx0XHRcdGFycmF5ID0gZXhwci5hcmd1bWVudHNbMV07XHJcblx0XHRcdFx0aWYoZXhwci5hcmd1bWVudHNbMl0udHlwZSA9PT0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIiB8fCBpc0JvdW5kRnVuY3Rpb25FeHByZXNzaW9uKGV4cHIuYXJndW1lbnRzWzJdKSkge1xyXG5cdFx0XHRcdFx0Ly8gZGVmaW5lKFwiLi4uXCIsIFsuLi5dLCBmKCkge30pXHJcblx0XHRcdFx0XHRmbiA9IGV4cHIuYXJndW1lbnRzWzJdO1xyXG5cdFx0XHRcdH0gZWxzZSBpZihleHByLmFyZ3VtZW50c1syXS50eXBlID09PSBcIk9iamVjdEV4cHJlc3Npb25cIikge1xyXG5cdFx0XHRcdFx0Ly8gZGVmaW5lKFwiLi4uXCIsIFsuLi5dLCB7Li4ufSlcclxuXHRcdFx0XHRcdG9iaiA9IGV4cHIuYXJndW1lbnRzWzJdO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQvLyBkZWZpbmUoXCIuLi5cIiwgWy4uLl0sIGV4cHIpXHJcblx0XHRcdFx0XHQvLyB1bmNsZWFyIGlmIGZ1bmN0aW9uIG9yIG9iamVjdFxyXG5cdFx0XHRcdFx0b2JqID0gZm4gPSBleHByLmFyZ3VtZW50c1syXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0dmFyIGZuUGFyYW1zID0gbnVsbDtcclxuXHRcdHZhciBmblBhcmFtc09mZnNldCA9IDA7XHJcblx0XHRpZihmbikge1xyXG5cdFx0XHRpZihmbi50eXBlID09PSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKSBmblBhcmFtcyA9IGZuLnBhcmFtcztcclxuXHRcdFx0ZWxzZSBpZihpc0JvdW5kRnVuY3Rpb25FeHByZXNzaW9uKGZuKSkge1xyXG5cdFx0XHRcdGZuUGFyYW1zID0gZm4uY2FsbGVlLm9iamVjdC5wYXJhbXM7XHJcblx0XHRcdFx0Zm5QYXJhbXNPZmZzZXQgPSBmbi5hcmd1bWVudHMubGVuZ3RoIC0gMTtcclxuXHRcdFx0XHRpZihmblBhcmFtc09mZnNldCA8IDApIGZuUGFyYW1zT2Zmc2V0ID0gMDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0dmFyIGZuUmVuYW1lcyA9IE9iamVjdC5jcmVhdGUodGhpcy5zY29wZS5yZW5hbWVzKTtcclxuXHRcdHZhciBpZGVudGlmaWVycztcclxuXHRcdGlmKGFycmF5KSB7XHJcblx0XHRcdGlkZW50aWZpZXJzID0ge307XHJcblx0XHRcdHZhciBwYXJhbSA9IHRoaXMuZXZhbHVhdGVFeHByZXNzaW9uKGFycmF5KTtcclxuXHRcdFx0dmFyIHJlc3VsdCA9IHRoaXMuYXBwbHlQbHVnaW5zQmFpbFJlc3VsdChcImNhbGwgZGVmaW5lOmFtZDphcnJheVwiLCBleHByLCBwYXJhbSwgaWRlbnRpZmllcnMsIG5hbWVkTW9kdWxlKTtcclxuXHRcdFx0aWYoIXJlc3VsdCkgcmV0dXJuO1xyXG5cdFx0XHRpZihmblBhcmFtcykgZm5QYXJhbXMgPSBmblBhcmFtcy5zbGljZShmblBhcmFtc09mZnNldCkuZmlsdGVyKGZ1bmN0aW9uKHBhcmFtLCBpZHgpIHtcclxuXHRcdFx0XHRpZihpZGVudGlmaWVyc1tpZHhdKSB7XHJcblx0XHRcdFx0XHRmblJlbmFtZXNbXCIkXCIgKyBwYXJhbS5uYW1lXSA9IGlkZW50aWZpZXJzW2lkeF07XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlkZW50aWZpZXJzID0gW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIiwgXCJtb2R1bGVcIl07XHJcblx0XHRcdGlmKGZuUGFyYW1zKSBmblBhcmFtcyA9IGZuUGFyYW1zLnNsaWNlKGZuUGFyYW1zT2Zmc2V0KS5maWx0ZXIoZnVuY3Rpb24ocGFyYW0sIGlkeCkge1xyXG5cdFx0XHRcdGlmKGlkZW50aWZpZXJzW2lkeF0pIHtcclxuXHRcdFx0XHRcdGZuUmVuYW1lc1tcIiRcIiArIHBhcmFtLm5hbWVdID0gaWRlbnRpZmllcnNbaWR4XTtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdFx0dmFyIGluVHJ5O1xyXG5cdFx0aWYoZm4gJiYgZm4udHlwZSA9PT0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIikge1xyXG5cdFx0XHRpblRyeSA9IHRoaXMuc2NvcGUuaW5Ucnk7XHJcblx0XHRcdHRoaXMuaW5TY29wZShmblBhcmFtcywgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dGhpcy5zY29wZS5yZW5hbWVzID0gZm5SZW5hbWVzO1xyXG5cdFx0XHRcdHRoaXMuc2NvcGUuaW5UcnkgPSBpblRyeTtcclxuXHRcdFx0XHRpZihmbi5ib2R5LnR5cGUgPT09IFwiQmxvY2tTdGF0ZW1lbnRcIilcclxuXHRcdFx0XHRcdHRoaXMud2Fsa1N0YXRlbWVudChmbi5ib2R5KTtcclxuXHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHR0aGlzLndhbGtFeHByZXNzaW9uKGZuLmJvZHkpO1xyXG5cdFx0XHR9LmJpbmQodGhpcykpO1xyXG5cdFx0fSBlbHNlIGlmKGZuICYmIGlzQm91bmRGdW5jdGlvbkV4cHJlc3Npb24oZm4pKSB7XHJcblx0XHRcdGluVHJ5ID0gdGhpcy5zY29wZS5pblRyeTtcclxuXHRcdFx0dGhpcy5pblNjb3BlKGZuLmNhbGxlZS5vYmplY3QucGFyYW1zLmZpbHRlcihmdW5jdGlvbihpKSB7XHJcblx0XHRcdFx0cmV0dXJuIFtcInJlcXVpcmVcIiwgXCJtb2R1bGVcIiwgXCJleHBvcnRzXCJdLmluZGV4T2YoaS5uYW1lKSA8IDA7XHJcblx0XHRcdH0pLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR0aGlzLnNjb3BlLnJlbmFtZXMgPSBmblJlbmFtZXM7XHJcblx0XHRcdFx0dGhpcy5zY29wZS5pblRyeSA9IGluVHJ5O1xyXG5cdFx0XHRcdGlmKGZuLmNhbGxlZS5vYmplY3QuYm9keS50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIpXHJcblx0XHRcdFx0XHR0aGlzLndhbGtTdGF0ZW1lbnQoZm4uY2FsbGVlLm9iamVjdC5ib2R5KTtcclxuXHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHR0aGlzLndhbGtFeHByZXNzaW9uKGZuLmNhbGxlZS5vYmplY3QuYm9keSk7XHJcblx0XHRcdH0uYmluZCh0aGlzKSk7XHJcblx0XHRcdGlmKGZuLmFyZ3VtZW50cylcclxuXHRcdFx0XHR0aGlzLndhbGtFeHByZXNzaW9ucyhmbi5hcmd1bWVudHMpO1xyXG5cdFx0fSBlbHNlIGlmKGZuIHx8IG9iaikge1xyXG5cdFx0XHR0aGlzLndhbGtFeHByZXNzaW9uKGZuIHx8IG9iaik7XHJcblx0XHR9XHJcblx0XHR2YXIgZGVwID0gbmV3IEFNRERlZmluZURlcGVuZGVuY3koZXhwci5yYW5nZSwgYXJyYXkgPyBhcnJheS5yYW5nZSA6IG51bGwsIGZuID8gZm4ucmFuZ2UgOiBudWxsLCBvYmogPyBvYmoucmFuZ2UgOiBudWxsKTtcclxuXHRcdGRlcC5sb2MgPSBleHByLmxvYztcclxuXHRcdGlmKG5hbWVkTW9kdWxlKSB7XHJcblx0XHRcdGRlcC5sb2NhbE1vZHVsZSA9IExvY2FsTW9kdWxlc0hlbHBlcnMuYWRkTG9jYWxNb2R1bGUodGhpcy5zdGF0ZSwgbmFtZWRNb2R1bGUpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5zdGF0ZS5jdXJyZW50LmFkZERlcGVuZGVuY3koZGVwKTtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0pO1xyXG5cdHBhcnNlci5wbHVnaW4oXCJjYWxsIGRlZmluZTphbWQ6YXJyYXlcIiwgZnVuY3Rpb24oZXhwciwgcGFyYW0sIGlkZW50aWZpZXJzLCBuYW1lZE1vZHVsZSkge1xyXG5cdFx0aWYocGFyYW0uaXNBcnJheSgpKSB7XHJcblx0XHRcdHBhcmFtLml0ZW1zLmZvckVhY2goZnVuY3Rpb24ocGFyYW0sIGlkeCkge1xyXG5cdFx0XHRcdGlmKHBhcmFtLmlzU3RyaW5nKCkgJiYgW1wicmVxdWlyZVwiLCBcIm1vZHVsZVwiLCBcImV4cG9ydHNcIl0uaW5kZXhPZihwYXJhbS5zdHJpbmcpID49IDApXHJcblx0XHRcdFx0XHRpZGVudGlmaWVyc1tpZHhdID0gcGFyYW0uc3RyaW5nO1xyXG5cdFx0XHRcdHZhciByZXN1bHQgPSB0aGlzLmFwcGx5UGx1Z2luc0JhaWxSZXN1bHQoXCJjYWxsIGRlZmluZTphbWQ6aXRlbVwiLCBleHByLCBwYXJhbSwgbmFtZWRNb2R1bGUpO1xyXG5cdFx0XHRcdGlmKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHR0aGlzLmFwcGx5UGx1Z2luc0JhaWxSZXN1bHQoXCJjYWxsIGRlZmluZTphbWQ6Y29udGV4dFwiLCBleHByLCBwYXJhbSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9IGVsc2UgaWYocGFyYW0uaXNDb25zdEFycmF5KCkpIHtcclxuXHRcdFx0dmFyIGRlcHMgPSBbXTtcclxuXHRcdFx0cGFyYW0uYXJyYXkuZm9yRWFjaChmdW5jdGlvbihyZXF1ZXN0LCBpZHgpIHtcclxuXHRcdFx0XHR2YXIgZGVwLCBsb2NhbE1vZHVsZTtcclxuXHRcdFx0XHRpZihyZXF1ZXN0ID09PSBcInJlcXVpcmVcIikge1xyXG5cdFx0XHRcdFx0aWRlbnRpZmllcnNbaWR4XSA9IHJlcXVlc3Q7XHJcblx0XHRcdFx0XHRkZXAgPSBcIl9fd2VicGFja19yZXF1aXJlX19cIjtcclxuXHRcdFx0XHR9IGVsc2UgaWYoW1wiZXhwb3J0c1wiLCBcIm1vZHVsZVwiXS5pbmRleE9mKHJlcXVlc3QpID49IDApIHtcclxuXHRcdFx0XHRcdGlkZW50aWZpZXJzW2lkeF0gPSByZXF1ZXN0O1xyXG5cdFx0XHRcdFx0ZGVwID0gcmVxdWVzdDtcclxuXHRcdFx0XHR9IGVsc2UgaWYobG9jYWxNb2R1bGUgPSBMb2NhbE1vZHVsZXNIZWxwZXJzLmdldExvY2FsTW9kdWxlKHRoaXMuc3RhdGUsIHJlcXVlc3QpKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uZC1hc3NpZ25cclxuXHRcdFx0XHRcdGRlcCA9IG5ldyBMb2NhbE1vZHVsZURlcGVuZGVuY3kobG9jYWxNb2R1bGUpO1xyXG5cdFx0XHRcdFx0ZGVwLmxvYyA9IGV4cHIubG9jO1xyXG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5jdXJyZW50LmFkZERlcGVuZGVuY3koZGVwKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0ZGVwID0gbmV3IEFNRFJlcXVpcmVJdGVtRGVwZW5kZW5jeShyZXF1ZXN0KTtcclxuXHRcdFx0XHRcdGRlcC5sb2MgPSBleHByLmxvYztcclxuXHRcdFx0XHRcdGRlcC5vcHRpb25hbCA9ICEhdGhpcy5zY29wZS5pblRyeTtcclxuXHRcdFx0XHRcdHRoaXMuc3RhdGUuY3VycmVudC5hZGREZXBlbmRlbmN5KGRlcCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGRlcHMucHVzaChkZXApO1xyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdFx0dmFyIGRlcCA9IG5ldyBBTURSZXF1aXJlQXJyYXlEZXBlbmRlbmN5KGRlcHMsIHBhcmFtLnJhbmdlKTtcclxuXHRcdFx0ZGVwLmxvYyA9IGV4cHIubG9jO1xyXG5cdFx0XHRkZXAub3B0aW9uYWwgPSAhIXRoaXMuc2NvcGUuaW5Ucnk7XHJcblx0XHRcdHRoaXMuc3RhdGUuY3VycmVudC5hZGREZXBlbmRlbmN5KGRlcCk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cdHBhcnNlci5wbHVnaW4oXCJjYWxsIGRlZmluZTphbWQ6aXRlbVwiLCBmdW5jdGlvbihleHByLCBwYXJhbSwgbmFtZWRNb2R1bGUpIHtcclxuXHRcdGlmKHBhcmFtLmlzQ29uZGl0aW9uYWwoKSkge1xyXG5cdFx0XHRwYXJhbS5vcHRpb25zLmZvckVhY2goZnVuY3Rpb24ocGFyYW0pIHtcclxuXHRcdFx0XHR2YXIgcmVzdWx0ID0gdGhpcy5hcHBseVBsdWdpbnNCYWlsUmVzdWx0KFwiY2FsbCBkZWZpbmU6YW1kOml0ZW1cIiwgZXhwciwgcGFyYW0pO1xyXG5cdFx0XHRcdGlmKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHR0aGlzLmFwcGx5UGx1Z2luc0JhaWxSZXN1bHQoXCJjYWxsIGRlZmluZTphbWQ6Y29udGV4dFwiLCBleHByLCBwYXJhbSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9IGVsc2UgaWYocGFyYW0uaXNTdHJpbmcoKSkge1xyXG5cdFx0XHR2YXIgZGVwLCBsb2NhbE1vZHVsZTtcclxuXHRcdFx0aWYocGFyYW0uc3RyaW5nID09PSBcInJlcXVpcmVcIikge1xyXG5cdFx0XHRcdGRlcCA9IG5ldyBDb25zdERlcGVuZGVuY3koXCJfX3dlYnBhY2tfcmVxdWlyZV9fXCIsIHBhcmFtLnJhbmdlKTtcclxuXHRcdFx0fSBlbHNlIGlmKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwibW9kdWxlXCJdLmluZGV4T2YocGFyYW0uc3RyaW5nKSA+PSAwKSB7XHJcblx0XHRcdFx0ZGVwID0gbmV3IENvbnN0RGVwZW5kZW5jeShwYXJhbS5zdHJpbmcsIHBhcmFtLnJhbmdlKTtcclxuXHRcdFx0fSBlbHNlIGlmKGxvY2FsTW9kdWxlID0gTG9jYWxNb2R1bGVzSGVscGVycy5nZXRMb2NhbE1vZHVsZSh0aGlzLnN0YXRlLCBwYXJhbS5zdHJpbmcsIG5hbWVkTW9kdWxlKSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbmQtYXNzaWduXHJcblx0XHRcdFx0ZGVwID0gbmV3IExvY2FsTW9kdWxlRGVwZW5kZW5jeShsb2NhbE1vZHVsZSwgcGFyYW0ucmFuZ2UpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGRlcCA9IG5ldyBBTURSZXF1aXJlSXRlbURlcGVuZGVuY3kocGFyYW0uc3RyaW5nLCBwYXJhbS5yYW5nZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZGVwLmxvYyA9IGV4cHIubG9jO1xyXG5cdFx0XHRkZXAub3B0aW9uYWwgPSAhIXRoaXMuc2NvcGUuaW5Ucnk7XHJcblx0XHRcdHRoaXMuc3RhdGUuY3VycmVudC5hZGREZXBlbmRlbmN5KGRlcCk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cdHBhcnNlci5wbHVnaW4oXCJjYWxsIGRlZmluZTphbWQ6Y29udGV4dFwiLCBmdW5jdGlvbihleHByLCBwYXJhbSkge1xyXG5cdFx0dmFyIGRlcCA9IENvbnRleHREZXBlbmRlbmN5SGVscGVycy5jcmVhdGUoQU1EUmVxdWlyZUNvbnRleHREZXBlbmRlbmN5LCBwYXJhbS5yYW5nZSwgcGFyYW0sIGV4cHIsIG9wdGlvbnMpO1xyXG5cdFx0aWYoIWRlcCkgcmV0dXJuO1xyXG5cdFx0ZGVwLmxvYyA9IGV4cHIubG9jO1xyXG5cdFx0ZGVwLm9wdGlvbmFsID0gISF0aGlzLnNjb3BlLmluVHJ5O1xyXG5cdFx0dGhpcy5zdGF0ZS5jdXJyZW50LmFkZERlcGVuZGVuY3koZGVwKTtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0pO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9BTUREZWZpbmVEZXBlbmRlbmN5UGFyc2VyUGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIFJlcXVpcmVDb250ZXh0RGVwZW5kZW5jeSA9IHJlcXVpcmUoXCIuL1JlcXVpcmVDb250ZXh0RGVwZW5kZW5jeVwiKTtcclxudmFyIENvbnRleHRFbGVtZW50RGVwZW5kZW5jeSA9IHJlcXVpcmUoXCIuL0NvbnRleHRFbGVtZW50RGVwZW5kZW5jeVwiKTtcclxuXHJcbnZhciBSZXF1aXJlQ29udGV4dERlcGVuZGVuY3lQYXJzZXJQbHVnaW4gPSByZXF1aXJlKFwiLi9SZXF1aXJlQ29udGV4dERlcGVuZGVuY3lQYXJzZXJQbHVnaW5cIik7XHJcblxyXG5mdW5jdGlvbiBSZXF1aXJlQ29udGV4dFBsdWdpbihtb2R1bGVzRGlyZWN0b3JpZXMsIGV4dGVuc2lvbnMpIHtcclxuXHR0aGlzLm1vZHVsZXNEaXJlY3RvcmllcyA9IG1vZHVsZXNEaXJlY3RvcmllcztcclxuXHR0aGlzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gUmVxdWlyZUNvbnRleHRQbHVnaW47XHJcblxyXG5SZXF1aXJlQ29udGV4dFBsdWdpbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbihjb21waWxlcikge1xyXG5cdHZhciBtb2R1bGVzRGlyZWN0b3JpZXMgPSB0aGlzLm1vZHVsZXNEaXJlY3RvcmllcztcclxuXHR2YXIgZXh0ZW5zaW9ucyA9IHRoaXMuZXh0ZW5zaW9ucztcclxuXHRjb21waWxlci5wbHVnaW4oXCJjb21waWxhdGlvblwiLCBmdW5jdGlvbihjb21waWxhdGlvbiwgcGFyYW1zKSB7XHJcblx0XHR2YXIgY29udGV4dE1vZHVsZUZhY3RvcnkgPSBwYXJhbXMuY29udGV4dE1vZHVsZUZhY3Rvcnk7XHJcblx0XHR2YXIgbm9ybWFsTW9kdWxlRmFjdG9yeSA9IHBhcmFtcy5ub3JtYWxNb2R1bGVGYWN0b3J5O1xyXG5cclxuXHRcdGNvbXBpbGF0aW9uLmRlcGVuZGVuY3lGYWN0b3JpZXMuc2V0KFJlcXVpcmVDb250ZXh0RGVwZW5kZW5jeSwgY29udGV4dE1vZHVsZUZhY3RvcnkpO1xyXG5cdFx0Y29tcGlsYXRpb24uZGVwZW5kZW5jeVRlbXBsYXRlcy5zZXQoUmVxdWlyZUNvbnRleHREZXBlbmRlbmN5LCBuZXcgUmVxdWlyZUNvbnRleHREZXBlbmRlbmN5LlRlbXBsYXRlKCkpO1xyXG5cclxuXHRcdGNvbXBpbGF0aW9uLmRlcGVuZGVuY3lGYWN0b3JpZXMuc2V0KENvbnRleHRFbGVtZW50RGVwZW5kZW5jeSwgbm9ybWFsTW9kdWxlRmFjdG9yeSk7XHJcblx0fSk7XHJcblx0Y29tcGlsZXIucGx1Z2luKFwiY29udGV4dC1tb2R1bGUtZmFjdG9yeVwiLCBmdW5jdGlvbihjbWYpIHtcclxuXHRcdGNtZi5wbHVnaW4oXCJhbHRlcm5hdGl2ZXNcIiwgZnVuY3Rpb24oaXRlbXMsIGNhbGxiYWNrKSB7XHJcblx0XHRcdGlmKGl0ZW1zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGl0ZW1zKTtcclxuXHJcblx0XHRcdGNhbGxiYWNrKG51bGwsIGl0ZW1zLm1hcChmdW5jdGlvbihvYmopIHtcclxuXHRcdFx0XHRyZXR1cm4gZXh0ZW5zaW9ucy5maWx0ZXIoZnVuY3Rpb24oZXh0KSB7XHJcblx0XHRcdFx0XHR2YXIgbCA9IG9iai5yZXF1ZXN0Lmxlbmd0aDtcclxuXHRcdFx0XHRcdHJldHVybiBsID4gZXh0Lmxlbmd0aCAmJiBvYmoucmVxdWVzdC5zdWJzdHIobCAtIGV4dC5sZW5ndGgsIGwpID09PSBleHQ7XHJcblx0XHRcdFx0fSkubWFwKGZ1bmN0aW9uKGV4dCkge1xyXG5cdFx0XHRcdFx0dmFyIGwgPSBvYmoucmVxdWVzdC5sZW5ndGg7XHJcblx0XHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0XHRjb250ZXh0OiBvYmouY29udGV4dCxcclxuXHRcdFx0XHRcdFx0cmVxdWVzdDogb2JqLnJlcXVlc3Quc3Vic3RyKDAsIGwgLSBleHQubGVuZ3RoKVxyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSkucmVkdWNlKGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdFx0XHRyZXR1cm4gYS5jb25jYXQoYik7XHJcblx0XHRcdH0sIFtdKSk7XHJcblx0XHR9KTtcclxuXHRcdGNtZi5wbHVnaW4oXCJhbHRlcm5hdGl2ZXNcIiwgZnVuY3Rpb24oaXRlbXMsIGNhbGxiYWNrKSB7XHJcblx0XHRcdGlmKGl0ZW1zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGl0ZW1zKTtcclxuXHJcblx0XHRcdGNhbGxiYWNrKG51bGwsIGl0ZW1zLm1hcChmdW5jdGlvbihvYmopIHtcclxuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbW9kdWxlc0RpcmVjdG9yaWVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgZGlyID0gbW9kdWxlc0RpcmVjdG9yaWVzW2ldO1xyXG5cdFx0XHRcdFx0dmFyIGlkeCA9IG9iai5yZXF1ZXN0LmluZGV4T2YoXCIuL1wiICsgZGlyICsgXCIvXCIpO1xyXG5cdFx0XHRcdFx0aWYoaWR4ID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdG9iai5yZXF1ZXN0ID0gb2JqLnJlcXVlc3Quc2xpY2UoZGlyLmxlbmd0aCArIDMpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIG9iajtcclxuXHRcdFx0fSkpO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcblx0bmV3IFJlcXVpcmVDb250ZXh0RGVwZW5kZW5jeVBhcnNlclBsdWdpbigpLmFwcGx5KGNvbXBpbGVyLnBhcnNlcik7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL1JlcXVpcmVDb250ZXh0UGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIENvbnRleHREZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4vQ29udGV4dERlcGVuZGVuY3lcIik7XHJcblxyXG5mdW5jdGlvbiBSZXF1aXJlQ29udGV4dERlcGVuZGVuY3kocmVxdWVzdCwgcmVjdXJzaXZlLCByZWdFeHAsIHJhbmdlKSB7XHJcblx0Q29udGV4dERlcGVuZGVuY3kuY2FsbCh0aGlzLCByZXF1ZXN0LCByZWN1cnNpdmUsIHJlZ0V4cCk7XHJcblx0dGhpcy5yYW5nZSA9IHJhbmdlO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gUmVxdWlyZUNvbnRleHREZXBlbmRlbmN5O1xyXG5cclxuUmVxdWlyZUNvbnRleHREZXBlbmRlbmN5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29udGV4dERlcGVuZGVuY3kucHJvdG90eXBlKTtcclxuUmVxdWlyZUNvbnRleHREZXBlbmRlbmN5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlcXVpcmVDb250ZXh0RGVwZW5kZW5jeTtcclxuUmVxdWlyZUNvbnRleHREZXBlbmRlbmN5LnByb3RvdHlwZS50eXBlID0gXCJyZXF1aXJlLmNvbnRleHRcIjtcclxuXHJcblJlcXVpcmVDb250ZXh0RGVwZW5kZW5jeS5UZW1wbGF0ZSA9IHJlcXVpcmUoXCIuL01vZHVsZURlcGVuZGVuY3lUZW1wbGF0ZUFzUmVxdWlyZUlkXCIpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9SZXF1aXJlQ29udGV4dERlcGVuZGVuY3kuanNcbi8vIG1vZHVsZSBpZCA9IDE1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgQWJzdHJhY3RQbHVnaW4gPSByZXF1aXJlKFwiLi4vQWJzdHJhY3RQbHVnaW5cIik7XHJcbnZhciBSZXF1aXJlQ29udGV4dERlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9SZXF1aXJlQ29udGV4dERlcGVuZGVuY3lcIik7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEFic3RyYWN0UGx1Z2luLmNyZWF0ZSh7XHJcblx0XCJjYWxsIHJlcXVpcmUuY29udGV4dFwiOiBmdW5jdGlvbihleHByKSB7XHJcblx0XHR2YXIgcmVnRXhwID0gL15cXC5cXC8uKiQvO1xyXG5cdFx0dmFyIHJlY3Vyc2l2ZSA9IHRydWU7XHJcblx0XHRzd2l0Y2goZXhwci5hcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdGNhc2UgMzpcclxuXHRcdFx0XHR2YXIgcmVnRXhwRXhwciA9IHRoaXMuZXZhbHVhdGVFeHByZXNzaW9uKGV4cHIuYXJndW1lbnRzWzJdKTtcclxuXHRcdFx0XHRpZighcmVnRXhwRXhwci5pc1JlZ0V4cCgpKSByZXR1cm47XHJcblx0XHRcdFx0cmVnRXhwID0gcmVnRXhwRXhwci5yZWdFeHA7XHJcblx0XHRcdFx0Ly8gZmFsbHMgdGhyb3VnaFxyXG5cdFx0XHRjYXNlIDI6XHJcblx0XHRcdFx0dmFyIHJlY3Vyc2l2ZUV4cHIgPSB0aGlzLmV2YWx1YXRlRXhwcmVzc2lvbihleHByLmFyZ3VtZW50c1sxXSk7XHJcblx0XHRcdFx0aWYoIXJlY3Vyc2l2ZUV4cHIuaXNCb29sZWFuKCkpIHJldHVybjtcclxuXHRcdFx0XHRyZWN1cnNpdmUgPSByZWN1cnNpdmVFeHByLmJvb2w7XHJcblx0XHRcdFx0Ly8gZmFsbHMgdGhyb3VnaFxyXG5cdFx0XHRjYXNlIDE6XHJcblx0XHRcdFx0dmFyIHJlcXVlc3RFeHByID0gdGhpcy5ldmFsdWF0ZUV4cHJlc3Npb24oZXhwci5hcmd1bWVudHNbMF0pO1xyXG5cdFx0XHRcdGlmKCFyZXF1ZXN0RXhwci5pc1N0cmluZygpKSByZXR1cm47XHJcblx0XHRcdFx0dmFyIGRlcCA9IG5ldyBSZXF1aXJlQ29udGV4dERlcGVuZGVuY3kocmVxdWVzdEV4cHIuc3RyaW5nLCByZWN1cnNpdmUsIHJlZ0V4cCwgZXhwci5yYW5nZSk7XHJcblx0XHRcdFx0ZGVwLmxvYyA9IGV4cHIubG9jO1xyXG5cdFx0XHRcdGRlcC5vcHRpb25hbCA9IHRoaXMuc2NvcGUuaW5Ucnk7XHJcblx0XHRcdFx0dGhpcy5zdGF0ZS5jdXJyZW50LmFkZERlcGVuZGVuY3koZGVwKTtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9SZXF1aXJlQ29udGV4dERlcGVuZGVuY3lQYXJzZXJQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDE1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5mdW5jdGlvbiBBYnN0cmFjdFBsdWdpbihwbHVnaW5zKSB7XHJcblx0dGhpcy5fcGx1Z2lucyA9IHBsdWdpbnMgfHwge307XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBBYnN0cmFjdFBsdWdpbjtcclxuXHJcbkFic3RyYWN0UGx1Z2luLmNyZWF0ZSA9IGZ1bmN0aW9uKHBsdWdpbnMpIHtcclxuXHRmdW5jdGlvbiBQbHVnaW4oKSB7XHJcblx0XHRBYnN0cmFjdFBsdWdpbi5jYWxsKHRoaXMsIHBsdWdpbnMpO1xyXG5cdH1cclxuXHRQbHVnaW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBYnN0cmFjdFBsdWdpbi5wcm90b3R5cGUpO1xyXG5cdHJldHVybiBQbHVnaW47XHJcbn07XHJcblxyXG5BYnN0cmFjdFBsdWdpbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbihvYmplY3QpIHtcclxuXHRmb3IodmFyIG5hbWUgaW4gdGhpcy5fcGx1Z2lucykge1xyXG5cdFx0b2JqZWN0LnBsdWdpbihuYW1lLCB0aGlzLl9wbHVnaW5zW25hbWVdKTtcclxuXHR9XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvQWJzdHJhY3RQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDE1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgUmVxdWlyZUVuc3VyZUl0ZW1EZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4vUmVxdWlyZUVuc3VyZUl0ZW1EZXBlbmRlbmN5XCIpO1xyXG52YXIgUmVxdWlyZUVuc3VyZURlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9SZXF1aXJlRW5zdXJlRGVwZW5kZW5jeVwiKTtcclxudmFyIENvbnN0RGVwZW5kZW5jeSA9IHJlcXVpcmUoXCIuL0NvbnN0RGVwZW5kZW5jeVwiKTtcclxuXHJcbnZhciBOdWxsRmFjdG9yeSA9IHJlcXVpcmUoXCIuLi9OdWxsRmFjdG9yeVwiKTtcclxuXHJcbnZhciBSZXF1aXJlRW5zdXJlRGVwZW5kZW5jaWVzQmxvY2tQYXJzZXJQbHVnaW4gPSByZXF1aXJlKFwiLi9SZXF1aXJlRW5zdXJlRGVwZW5kZW5jaWVzQmxvY2tQYXJzZXJQbHVnaW5cIik7XHJcblxyXG52YXIgQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uID0gcmVxdWlyZShcIi4uL0Jhc2ljRXZhbHVhdGVkRXhwcmVzc2lvblwiKTtcclxuXHJcbmZ1bmN0aW9uIFJlcXVpcmVFbnN1cmVQbHVnaW4oKSB7fVxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlcXVpcmVFbnN1cmVQbHVnaW47XHJcblxyXG5SZXF1aXJlRW5zdXJlUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGNvbXBpbGVyKSB7XHJcblx0Y29tcGlsZXIucGx1Z2luKFwiY29tcGlsYXRpb25cIiwgZnVuY3Rpb24oY29tcGlsYXRpb24sIHBhcmFtcykge1xyXG5cdFx0dmFyIG5vcm1hbE1vZHVsZUZhY3RvcnkgPSBwYXJhbXMubm9ybWFsTW9kdWxlRmFjdG9yeTtcclxuXHJcblx0XHRjb21waWxhdGlvbi5kZXBlbmRlbmN5RmFjdG9yaWVzLnNldChSZXF1aXJlRW5zdXJlSXRlbURlcGVuZGVuY3ksIG5vcm1hbE1vZHVsZUZhY3RvcnkpO1xyXG5cdFx0Y29tcGlsYXRpb24uZGVwZW5kZW5jeVRlbXBsYXRlcy5zZXQoUmVxdWlyZUVuc3VyZUl0ZW1EZXBlbmRlbmN5LCBuZXcgUmVxdWlyZUVuc3VyZUl0ZW1EZXBlbmRlbmN5LlRlbXBsYXRlKCkpO1xyXG5cclxuXHRcdGNvbXBpbGF0aW9uLmRlcGVuZGVuY3lGYWN0b3JpZXMuc2V0KFJlcXVpcmVFbnN1cmVEZXBlbmRlbmN5LCBuZXcgTnVsbEZhY3RvcnkoKSk7XHJcblx0XHRjb21waWxhdGlvbi5kZXBlbmRlbmN5VGVtcGxhdGVzLnNldChSZXF1aXJlRW5zdXJlRGVwZW5kZW5jeSwgbmV3IFJlcXVpcmVFbnN1cmVEZXBlbmRlbmN5LlRlbXBsYXRlKCkpO1xyXG5cdH0pO1xyXG5cdG5ldyBSZXF1aXJlRW5zdXJlRGVwZW5kZW5jaWVzQmxvY2tQYXJzZXJQbHVnaW4oKS5hcHBseShjb21waWxlci5wYXJzZXIpO1xyXG5cdGNvbXBpbGVyLnBhcnNlci5wbHVnaW4oXCJldmFsdWF0ZSB0eXBlb2YgcmVxdWlyZS5lbnN1cmVcIiwgZnVuY3Rpb24oZXhwcikge1xyXG5cdFx0cmV0dXJuIG5ldyBCYXNpY0V2YWx1YXRlZEV4cHJlc3Npb24oKS5zZXRTdHJpbmcoXCJmdW5jdGlvblwiKS5zZXRSYW5nZShleHByLnJhbmdlKTtcclxuXHR9KTtcclxuXHRjb21waWxlci5wYXJzZXIucGx1Z2luKFwidHlwZW9mIHJlcXVpcmUuZW5zdXJlXCIsIGZ1bmN0aW9uKGV4cHIpIHtcclxuXHRcdHZhciBkZXAgPSBuZXcgQ29uc3REZXBlbmRlbmN5KFwiJ2Z1bmN0aW9uJ1wiLCBleHByLnJhbmdlKTtcclxuXHRcdGRlcC5sb2MgPSBleHByLmxvYztcclxuXHRcdHRoaXMuc3RhdGUuY3VycmVudC5hZGREZXBlbmRlbmN5KGRlcCk7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9KTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvUmVxdWlyZUVuc3VyZVBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBNb2R1bGVEZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4vTW9kdWxlRGVwZW5kZW5jeVwiKTtcclxuXHJcbmZ1bmN0aW9uIFJlcXVpcmVFbnN1cmVJdGVtRGVwZW5kZW5jeShyZXF1ZXN0KSB7XHJcblx0TW9kdWxlRGVwZW5kZW5jeS5jYWxsKHRoaXMsIHJlcXVlc3QpO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gUmVxdWlyZUVuc3VyZUl0ZW1EZXBlbmRlbmN5O1xyXG5cclxuUmVxdWlyZUVuc3VyZUl0ZW1EZXBlbmRlbmN5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTW9kdWxlRGVwZW5kZW5jeS5wcm90b3R5cGUpO1xyXG5SZXF1aXJlRW5zdXJlSXRlbURlcGVuZGVuY3kucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVxdWlyZUVuc3VyZUl0ZW1EZXBlbmRlbmN5O1xyXG5SZXF1aXJlRW5zdXJlSXRlbURlcGVuZGVuY3kucHJvdG90eXBlLnR5cGUgPSBcInJlcXVpcmUuZW5zdXJlIGl0ZW1cIjtcclxuXHJcblJlcXVpcmVFbnN1cmVJdGVtRGVwZW5kZW5jeS5UZW1wbGF0ZSA9IHJlcXVpcmUoXCIuL051bGxEZXBlbmRlbmN5VGVtcGxhdGVcIik7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL1JlcXVpcmVFbnN1cmVJdGVtRGVwZW5kZW5jeS5qc1xuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbmZ1bmN0aW9uIE51bGxEZXBlbmRlbmN5VGVtcGxhdGUoKSB7fVxyXG5tb2R1bGUuZXhwb3J0cyA9IE51bGxEZXBlbmRlbmN5VGVtcGxhdGU7XHJcblxyXG5OdWxsRGVwZW5kZW5jeVRlbXBsYXRlLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKCkge307XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL051bGxEZXBlbmRlbmN5VGVtcGxhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDE1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgTnVsbERlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9OdWxsRGVwZW5kZW5jeVwiKTtcclxudmFyIERlcEJsb2NrSGVscGVycyA9IHJlcXVpcmUoXCIuL0RlcEJsb2NrSGVscGVyc1wiKTtcclxuXHJcbmZ1bmN0aW9uIFJlcXVpcmVFbnN1cmVEZXBlbmRlbmN5KGJsb2NrKSB7XHJcblx0TnVsbERlcGVuZGVuY3kuY2FsbCh0aGlzKTtcclxuXHR0aGlzLmJsb2NrID0gYmxvY2s7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBSZXF1aXJlRW5zdXJlRGVwZW5kZW5jeTtcclxuXHJcblJlcXVpcmVFbnN1cmVEZXBlbmRlbmN5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTnVsbERlcGVuZGVuY3kucHJvdG90eXBlKTtcclxuUmVxdWlyZUVuc3VyZURlcGVuZGVuY3kucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVxdWlyZUVuc3VyZURlcGVuZGVuY3k7XHJcblJlcXVpcmVFbnN1cmVEZXBlbmRlbmN5LnByb3RvdHlwZS50eXBlID0gXCJyZXF1aXJlLmVuc3VyZVwiO1xyXG5cclxuUmVxdWlyZUVuc3VyZURlcGVuZGVuY3kuVGVtcGxhdGUgPSBmdW5jdGlvbiBSZXF1aXJlRW5zdXJlRGVwZW5kZW5jeVRlbXBsYXRlKCkge307XHJcblxyXG5SZXF1aXJlRW5zdXJlRGVwZW5kZW5jeS5UZW1wbGF0ZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbihkZXAsIHNvdXJjZSwgb3V0cHV0T3B0aW9ucywgcmVxdWVzdFNob3J0ZW5lcikge1xyXG5cdHZhciBkZXBCbG9jayA9IGRlcC5ibG9jaztcclxuXHR2YXIgd3JhcHBlciA9IERlcEJsb2NrSGVscGVycy5nZXRMb2FkRGVwQmxvY2tXcmFwcGVyKGRlcEJsb2NrLCBvdXRwdXRPcHRpb25zLCByZXF1ZXN0U2hvcnRlbmVyLCAvKnJlcXVpcmUuZSovIFwibnN1cmVcIik7XHJcblx0aWYoIXdyYXBwZXIpIHdyYXBwZXIgPSBbXHJcblx0XHRcIiEvKiByZXF1aXJlLmVuc3VyZSAqLyhcIixcclxuXHRcdFwiKF9fd2VicGFja19yZXF1aXJlX18pKVwiXHJcblx0XTtcclxuXHRzb3VyY2UucmVwbGFjZShkZXBCbG9jay5leHByLnJhbmdlWzBdLCBkZXBCbG9jay5leHByLmFyZ3VtZW50c1sxXS5yYW5nZVswXSAtIDEsIHdyYXBwZXJbMF0pO1xyXG5cdHNvdXJjZS5yZXBsYWNlKGRlcEJsb2NrLmV4cHIuYXJndW1lbnRzWzFdLnJhbmdlWzFdLCBkZXBCbG9jay5leHByLnJhbmdlWzFdIC0gMSwgd3JhcHBlclsxXSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL1JlcXVpcmVFbnN1cmVEZXBlbmRlbmN5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIEFic3RyYWN0UGx1Z2luID0gcmVxdWlyZShcIi4uL0Fic3RyYWN0UGx1Z2luXCIpO1xyXG52YXIgUmVxdWlyZUVuc3VyZURlcGVuZGVuY2llc0Jsb2NrID0gcmVxdWlyZShcIi4vUmVxdWlyZUVuc3VyZURlcGVuZGVuY2llc0Jsb2NrXCIpO1xyXG52YXIgUmVxdWlyZUVuc3VyZUl0ZW1EZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4vUmVxdWlyZUVuc3VyZUl0ZW1EZXBlbmRlbmN5XCIpO1xyXG52YXIgZ2V0RnVuY3Rpb25FeHByZXNzaW9uID0gcmVxdWlyZShcIi4vZ2V0RnVuY3Rpb25FeHByZXNzaW9uXCIpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBBYnN0cmFjdFBsdWdpbi5jcmVhdGUoe1xyXG5cdFwiY2FsbCByZXF1aXJlLmVuc3VyZVwiOiBmdW5jdGlvbihleHByKSB7XHJcblx0XHR2YXIgY2h1bmtOYW1lID0gbnVsbCxcclxuXHRcdFx0Y2h1bmtOYW1lUmFuZ2UgPSBudWxsO1xyXG5cdFx0c3dpdGNoKGV4cHIuYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRjYXNlIDM6XHJcblx0XHRcdFx0dmFyIGNodW5rTmFtZUV4cHIgPSB0aGlzLmV2YWx1YXRlRXhwcmVzc2lvbihleHByLmFyZ3VtZW50c1syXSk7XHJcblx0XHRcdFx0aWYoIWNodW5rTmFtZUV4cHIuaXNTdHJpbmcoKSkgcmV0dXJuO1xyXG5cdFx0XHRcdGNodW5rTmFtZVJhbmdlID0gY2h1bmtOYW1lRXhwci5yYW5nZTtcclxuXHRcdFx0XHRjaHVua05hbWUgPSBjaHVua05hbWVFeHByLnN0cmluZztcclxuXHRcdFx0XHQvLyBmYWxscyB0aHJvdWdoXHJcblx0XHRcdGNhc2UgMjpcclxuXHRcdFx0XHR2YXIgZGVwZW5kZW5jaWVzRXhwciA9IHRoaXMuZXZhbHVhdGVFeHByZXNzaW9uKGV4cHIuYXJndW1lbnRzWzBdKTtcclxuXHRcdFx0XHR2YXIgZGVwZW5kZW5jaWVzSXRlbXMgPSBkZXBlbmRlbmNpZXNFeHByLmlzQXJyYXkoKSA/IGRlcGVuZGVuY2llc0V4cHIuaXRlbXMgOiBbZGVwZW5kZW5jaWVzRXhwcl07XHJcblx0XHRcdFx0dmFyIGZuRXhwcmVzc2lvbkFyZyA9IGV4cHIuYXJndW1lbnRzWzFdO1xyXG5cdFx0XHRcdHZhciBmbkV4cHJlc3Npb24gPSBnZXRGdW5jdGlvbkV4cHJlc3Npb24oZm5FeHByZXNzaW9uQXJnKTtcclxuXHJcblx0XHRcdFx0aWYoZm5FeHByZXNzaW9uKSB7XHJcblx0XHRcdFx0XHR0aGlzLndhbGtFeHByZXNzaW9ucyhmbkV4cHJlc3Npb24uZXhwcmVzc2lvbnMpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIGRlcCA9IG5ldyBSZXF1aXJlRW5zdXJlRGVwZW5kZW5jaWVzQmxvY2soZXhwciwgZm5FeHByZXNzaW9uID8gZm5FeHByZXNzaW9uLmZuIDogZm5FeHByZXNzaW9uQXJnLCBjaHVua05hbWUsIGNodW5rTmFtZVJhbmdlLCB0aGlzLnN0YXRlLm1vZHVsZSwgZXhwci5sb2MpO1xyXG5cdFx0XHRcdHZhciBvbGQgPSB0aGlzLnN0YXRlLmN1cnJlbnQ7XHJcblx0XHRcdFx0dGhpcy5zdGF0ZS5jdXJyZW50ID0gZGVwO1xyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHR2YXIgZmFpbGVkID0gZmFsc2U7XHJcblx0XHRcdFx0XHR0aGlzLmluU2NvcGUoW10sIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRkZXBlbmRlbmNpZXNJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKGVlKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYoZWUuaXNTdHJpbmcoKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGVkZXAgPSBuZXcgUmVxdWlyZUVuc3VyZUl0ZW1EZXBlbmRlbmN5KGVlLnN0cmluZywgZWUucmFuZ2UpO1xyXG5cdFx0XHRcdFx0XHRcdFx0ZWRlcC5sb2MgPSBkZXAubG9jO1xyXG5cdFx0XHRcdFx0XHRcdFx0ZGVwLmFkZERlcGVuZGVuY3koZWRlcCk7XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdGZhaWxlZCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0aWYoZmFpbGVkKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKGZuRXhwcmVzc2lvbikge1xyXG5cdFx0XHRcdFx0XHRpZihmbkV4cHJlc3Npb24uZm4uYm9keS50eXBlID09PSBcIkJsb2NrU3RhdGVtZW50XCIpXHJcblx0XHRcdFx0XHRcdFx0dGhpcy53YWxrU3RhdGVtZW50KGZuRXhwcmVzc2lvbi5mbi5ib2R5KTtcclxuXHRcdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHRcdHRoaXMud2Fsa0V4cHJlc3Npb24oZm5FeHByZXNzaW9uLmZuLmJvZHkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0b2xkLmFkZEJsb2NrKGRlcCk7XHJcblx0XHRcdFx0fSBmaW5hbGx5IHtcclxuXHRcdFx0XHRcdHRoaXMuc3RhdGUuY3VycmVudCA9IG9sZDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoIWZuRXhwcmVzc2lvbikge1xyXG5cdFx0XHRcdFx0dGhpcy53YWxrRXhwcmVzc2lvbihmbkV4cHJlc3Npb25BcmcpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9SZXF1aXJlRW5zdXJlRGVwZW5kZW5jaWVzQmxvY2tQYXJzZXJQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDE2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgQXN5bmNEZXBlbmRlbmNpZXNCbG9jayA9IHJlcXVpcmUoXCIuLi9Bc3luY0RlcGVuZGVuY2llc0Jsb2NrXCIpO1xyXG52YXIgUmVxdWlyZUVuc3VyZURlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9SZXF1aXJlRW5zdXJlRGVwZW5kZW5jeVwiKTtcclxuXHJcbmZ1bmN0aW9uIFJlcXVpcmVFbnN1cmVEZXBlbmRlbmNpZXNCbG9jayhleHByLCBmbkV4cHJlc3Npb24sIGNodW5rTmFtZSwgY2h1bmtOYW1lUmFuZ2UsIG1vZHVsZSwgbG9jKSB7XHJcblx0QXN5bmNEZXBlbmRlbmNpZXNCbG9jay5jYWxsKHRoaXMsIGNodW5rTmFtZSwgbW9kdWxlLCBsb2MpO1xyXG5cdHRoaXMuZXhwciA9IGV4cHI7XHJcblx0dmFyIGJvZHlSYW5nZSA9IGZuRXhwcmVzc2lvbiAmJiBmbkV4cHJlc3Npb24uYm9keSAmJiBmbkV4cHJlc3Npb24uYm9keS5yYW5nZTtcclxuXHR0aGlzLnJhbmdlID0gYm9keVJhbmdlICYmIFtib2R5UmFuZ2VbMF0gKyAxLCBib2R5UmFuZ2VbMV0gLSAxXSB8fCBudWxsO1xyXG5cdHRoaXMuY2h1bmtOYW1lUmFuZ2UgPSBjaHVua05hbWVSYW5nZTtcclxuXHR2YXIgZGVwID0gbmV3IFJlcXVpcmVFbnN1cmVEZXBlbmRlbmN5KHRoaXMpO1xyXG5cdGRlcC5sb2MgPSBsb2M7XHJcblx0dGhpcy5hZGREZXBlbmRlbmN5KGRlcCk7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBSZXF1aXJlRW5zdXJlRGVwZW5kZW5jaWVzQmxvY2s7XHJcblxyXG5SZXF1aXJlRW5zdXJlRGVwZW5kZW5jaWVzQmxvY2sucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBc3luY0RlcGVuZGVuY2llc0Jsb2NrLnByb3RvdHlwZSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL1JlcXVpcmVFbnN1cmVEZXBlbmRlbmNpZXNCbG9jay5qc1xuLy8gbW9kdWxlIGlkID0gMTYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBSZXF1aXJlSW5jbHVkZURlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9SZXF1aXJlSW5jbHVkZURlcGVuZGVuY3lcIik7XHJcbnZhciBSZXF1aXJlSW5jbHVkZURlcGVuZGVuY3lQYXJzZXJQbHVnaW4gPSByZXF1aXJlKFwiLi9SZXF1aXJlSW5jbHVkZURlcGVuZGVuY3lQYXJzZXJQbHVnaW5cIik7XHJcbnZhciBDb25zdERlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9Db25zdERlcGVuZGVuY3lcIik7XHJcblxyXG52YXIgQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uID0gcmVxdWlyZShcIi4uL0Jhc2ljRXZhbHVhdGVkRXhwcmVzc2lvblwiKTtcclxuXHJcbmZ1bmN0aW9uIFJlcXVpcmVJbmNsdWRlUGx1Z2luKCkge31cclxubW9kdWxlLmV4cG9ydHMgPSBSZXF1aXJlSW5jbHVkZVBsdWdpbjtcclxuXHJcblJlcXVpcmVJbmNsdWRlUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGNvbXBpbGVyKSB7XHJcblx0Y29tcGlsZXIucGx1Z2luKFwiY29tcGlsYXRpb25cIiwgZnVuY3Rpb24oY29tcGlsYXRpb24sIHBhcmFtcykge1xyXG5cdFx0dmFyIG5vcm1hbE1vZHVsZUZhY3RvcnkgPSBwYXJhbXMubm9ybWFsTW9kdWxlRmFjdG9yeTtcclxuXHJcblx0XHRjb21waWxhdGlvbi5kZXBlbmRlbmN5RmFjdG9yaWVzLnNldChSZXF1aXJlSW5jbHVkZURlcGVuZGVuY3ksIG5vcm1hbE1vZHVsZUZhY3RvcnkpO1xyXG5cdFx0Y29tcGlsYXRpb24uZGVwZW5kZW5jeVRlbXBsYXRlcy5zZXQoUmVxdWlyZUluY2x1ZGVEZXBlbmRlbmN5LCBuZXcgUmVxdWlyZUluY2x1ZGVEZXBlbmRlbmN5LlRlbXBsYXRlKCkpO1xyXG5cdH0pO1xyXG5cdG5ldyBSZXF1aXJlSW5jbHVkZURlcGVuZGVuY3lQYXJzZXJQbHVnaW4oKS5hcHBseShjb21waWxlci5wYXJzZXIpO1xyXG5cdGNvbXBpbGVyLnBhcnNlci5wbHVnaW4oXCJldmFsdWF0ZSB0eXBlb2YgcmVxdWlyZS5pbmNsdWRlXCIsIGZ1bmN0aW9uKGV4cHIpIHtcclxuXHRcdHJldHVybiBuZXcgQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uKCkuc2V0U3RyaW5nKFwiZnVuY3Rpb25cIikuc2V0UmFuZ2UoZXhwci5yYW5nZSk7XHJcblx0fSk7XHJcblx0Y29tcGlsZXIucGFyc2VyLnBsdWdpbihcInR5cGVvZiByZXF1aXJlLmluY2x1ZGVcIiwgZnVuY3Rpb24oZXhwcikge1xyXG5cdFx0dmFyIGRlcCA9IG5ldyBDb25zdERlcGVuZGVuY3koXCInZnVuY3Rpb24nXCIsIGV4cHIucmFuZ2UpO1xyXG5cdFx0ZGVwLmxvYyA9IGV4cHIubG9jO1xyXG5cdFx0dGhpcy5zdGF0ZS5jdXJyZW50LmFkZERlcGVuZGVuY3koZGVwKTtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0pO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL2RlcGVuZGVuY2llcy9SZXF1aXJlSW5jbHVkZVBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBNb2R1bGVEZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4vTW9kdWxlRGVwZW5kZW5jeVwiKTtcclxuXHJcbmZ1bmN0aW9uIFJlcXVpcmVJbmNsdWRlRGVwZW5kZW5jeShyZXF1ZXN0LCByYW5nZSkge1xyXG5cdE1vZHVsZURlcGVuZGVuY3kuY2FsbCh0aGlzLCByZXF1ZXN0KTtcclxuXHR0aGlzLnJhbmdlID0gcmFuZ2U7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBSZXF1aXJlSW5jbHVkZURlcGVuZGVuY3k7XHJcblxyXG5SZXF1aXJlSW5jbHVkZURlcGVuZGVuY3kucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNb2R1bGVEZXBlbmRlbmN5LnByb3RvdHlwZSk7XHJcblJlcXVpcmVJbmNsdWRlRGVwZW5kZW5jeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZXF1aXJlSW5jbHVkZURlcGVuZGVuY3k7XHJcblJlcXVpcmVJbmNsdWRlRGVwZW5kZW5jeS5wcm90b3R5cGUudHlwZSA9IFwicmVxdWlyZS5pbmNsdWRlXCI7XHJcblxyXG5SZXF1aXJlSW5jbHVkZURlcGVuZGVuY3kuVGVtcGxhdGUgPSBmdW5jdGlvbiBSZXF1aXJlSW5jbHVkZURlcGVuZGVuY3lUZW1wbGF0ZSgpIHt9O1xyXG5cclxuUmVxdWlyZUluY2x1ZGVEZXBlbmRlbmN5LlRlbXBsYXRlLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGRlcCwgc291cmNlLCBvdXRwdXRPcHRpb25zLCByZXF1ZXN0U2hvcnRlbmVyKSB7XHJcblx0dmFyIGNvbW1lbnQgPSBcIlwiO1xyXG5cdGlmKG91dHB1dE9wdGlvbnMucGF0aGluZm8gJiYgZGVwLm1vZHVsZSlcclxuXHRcdGNvbW1lbnQgPSBcIi8qISByZXF1aXJlLmluY2x1ZGUgXCIgKyByZXF1ZXN0U2hvcnRlbmVyLnNob3J0ZW4oZGVwLnJlcXVlc3QpICsgXCIgKi9cIjtcclxuXHRzb3VyY2UucmVwbGFjZShkZXAucmFuZ2VbMF0sIGRlcC5yYW5nZVsxXSAtIDEsXHJcblx0XHRcInVuZGVmaW5lZFwiICsgY29tbWVudCk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL1JlcXVpcmVJbmNsdWRlRGVwZW5kZW5jeS5qc1xuLy8gbW9kdWxlIGlkID0gMTY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBBYnN0cmFjdFBsdWdpbiA9IHJlcXVpcmUoXCIuLi9BYnN0cmFjdFBsdWdpblwiKTtcclxudmFyIFJlcXVpcmVJbmNsdWRlRGVwZW5kZW5jeSA9IHJlcXVpcmUoXCIuL1JlcXVpcmVJbmNsdWRlRGVwZW5kZW5jeVwiKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQWJzdHJhY3RQbHVnaW4uY3JlYXRlKHtcclxuXHRcImNhbGwgcmVxdWlyZS5pbmNsdWRlXCI6IGZ1bmN0aW9uKGV4cHIpIHtcclxuXHRcdGlmKGV4cHIuYXJndW1lbnRzLmxlbmd0aCAhPT0gMSkgcmV0dXJuO1xyXG5cdFx0dmFyIHBhcmFtID0gdGhpcy5ldmFsdWF0ZUV4cHJlc3Npb24oZXhwci5hcmd1bWVudHNbMF0pO1xyXG5cdFx0aWYoIXBhcmFtLmlzU3RyaW5nKCkpIHJldHVybjtcclxuXHRcdHZhciBkZXAgPSBuZXcgUmVxdWlyZUluY2x1ZGVEZXBlbmRlbmN5KHBhcmFtLnN0cmluZywgZXhwci5yYW5nZSk7XHJcblx0XHRkZXAubG9jID0gZXhwci5sb2M7XHJcblx0XHR0aGlzLnN0YXRlLmN1cnJlbnQuYWRkRGVwZW5kZW5jeShkZXApO1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG59KTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvUmVxdWlyZUluY2x1ZGVEZXBlbmRlbmN5UGFyc2VyUGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuZnVuY3Rpb24gaGFzTW9kdWxlKGNodW5rLCBtb2R1bGUsIGNoZWNrZWRDaHVua3MpIHtcclxuXHRpZihjaHVuay5tb2R1bGVzLmluZGV4T2YobW9kdWxlKSA+PSAwKSByZXR1cm4gW2NodW5rXTtcclxuXHRpZihjaHVuay5lbnRyeSkgcmV0dXJuIGZhbHNlO1xyXG5cdHJldHVybiBhbGxIYXZlTW9kdWxlKGNodW5rLnBhcmVudHMuZmlsdGVyKGZ1bmN0aW9uKGMpIHtcclxuXHRcdHJldHVybiBjaGVja2VkQ2h1bmtzLmluZGV4T2YoYykgPCAwO1xyXG5cdH0pLCBtb2R1bGUsIGNoZWNrZWRDaHVua3MpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbGxIYXZlTW9kdWxlKHNvbWVDaHVua3MsIG1vZHVsZSwgY2hlY2tlZENodW5rcykge1xyXG5cdGlmKCFjaGVja2VkQ2h1bmtzKSBjaGVja2VkQ2h1bmtzID0gW107XHJcblx0dmFyIGNodW5rcyA9IFtdO1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBzb21lQ2h1bmtzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRjaGVja2VkQ2h1bmtzLnB1c2goc29tZUNodW5rc1tpXSk7XHJcblx0XHR2YXIgc3ViQ2h1bmtzID0gaGFzTW9kdWxlKHNvbWVDaHVua3NbaV0sIG1vZHVsZSwgY2hlY2tlZENodW5rcyk7XHJcblx0XHRpZighc3ViQ2h1bmtzKSByZXR1cm4gZmFsc2U7XHJcblx0XHRhZGRUb1NldChjaHVua3MsIHN1YkNodW5rcyk7XHJcblx0fVxyXG5cdHJldHVybiBjaHVua3M7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFRvU2V0KHNldCwgaXRlbXMpIHtcclxuXHRpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHRcdGlmKHNldC5pbmRleE9mKGl0ZW0pIDwgMClcclxuXHRcdFx0c2V0LnB1c2goaXRlbSk7XHJcblx0fSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIFJlbW92ZVBhcmVudE1vZHVsZXNQbHVnaW4oKSB7fVxyXG5tb2R1bGUuZXhwb3J0cyA9IFJlbW92ZVBhcmVudE1vZHVsZXNQbHVnaW47XHJcblxyXG5SZW1vdmVQYXJlbnRNb2R1bGVzUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGNvbXBpbGVyKSB7XHJcblx0Y29tcGlsZXIucGx1Z2luKFwiY29tcGlsYXRpb25cIiwgZnVuY3Rpb24oY29tcGlsYXRpb24pIHtcclxuXHRcdGNvbXBpbGF0aW9uLnBsdWdpbihbXCJvcHRpbWl6ZS1jaHVua3NcIiwgXCJvcHRpbWl6ZS1leHRyYWN0ZWQtY2h1bmtzXCJdLCBmdW5jdGlvbihjaHVua3MpIHtcclxuXHRcdFx0Y2h1bmtzLmZvckVhY2goZnVuY3Rpb24oY2h1bmspIHtcclxuXHRcdFx0XHRjaHVuay5tb2R1bGVzLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRcdFx0XHRcdGlmKGNodW5rLmVudHJ5KSByZXR1cm47XHJcblx0XHRcdFx0XHR2YXIgcGFyZW50Q2h1bmtzV2l0aE1vZHVsZSA9IGFsbEhhdmVNb2R1bGUoY2h1bmsucGFyZW50cywgbW9kdWxlKTtcclxuXHRcdFx0XHRcdGlmKHBhcmVudENodW5rc1dpdGhNb2R1bGUpIHtcclxuXHRcdFx0XHRcdFx0bW9kdWxlLnJld3JpdGVDaHVua0luUmVhc29ucyhjaHVuaywgcGFyZW50Q2h1bmtzV2l0aE1vZHVsZSk7XHJcblx0XHRcdFx0XHRcdGNodW5rLnJlbW92ZU1vZHVsZShtb2R1bGUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL29wdGltaXplL1JlbW92ZVBhcmVudE1vZHVsZXNQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDE2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5mdW5jdGlvbiBSZW1vdmVFbXB0eUNodW5rc1BsdWdpbigpIHt9XHJcbm1vZHVsZS5leHBvcnRzID0gUmVtb3ZlRW1wdHlDaHVua3NQbHVnaW47XHJcblxyXG5SZW1vdmVFbXB0eUNodW5rc1BsdWdpbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbihjb21waWxlcikge1xyXG5cdGNvbXBpbGVyLnBsdWdpbihcImNvbXBpbGF0aW9uXCIsIGZ1bmN0aW9uKGNvbXBpbGF0aW9uKSB7XHJcblx0XHRjb21waWxhdGlvbi5wbHVnaW4oW1wib3B0aW1pemUtY2h1bmtzXCIsIFwib3B0aW1pemUtZXh0cmFjdGVkLWNodW5rc1wiXSwgZnVuY3Rpb24oY2h1bmtzKSB7XHJcblx0XHRcdGNodW5rcy5maWx0ZXIoZnVuY3Rpb24oY2h1bmspIHtcclxuXHRcdFx0XHRyZXR1cm4gY2h1bmsuaXNFbXB0eSgpICYmICFjaHVuay5pbml0aWFsO1xyXG5cdFx0XHR9KS5mb3JFYWNoKGZ1bmN0aW9uKGNodW5rKSB7XHJcblx0XHRcdFx0Y2h1bmsucmVtb3ZlKFwiZW1wdHlcIik7XHJcblx0XHRcdFx0Y2h1bmtzLnNwbGljZShjaHVua3MuaW5kZXhPZihjaHVuayksIDEpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL29wdGltaXplL1JlbW92ZUVtcHR5Q2h1bmtzUGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuZnVuY3Rpb24gTWVyZ2VEdXBsaWNhdGVDaHVua3NQbHVnaW4oKSB7fVxyXG5tb2R1bGUuZXhwb3J0cyA9IE1lcmdlRHVwbGljYXRlQ2h1bmtzUGx1Z2luO1xyXG5cclxuZnVuY3Rpb24gZ2V0Q2h1bmtJZGVudGlmaWVyKGNodW5rKSB7XHJcblx0cmV0dXJuIGNodW5rLm1vZHVsZXMubWFwKGZ1bmN0aW9uKG0pIHtcclxuXHRcdHJldHVybiBtLmlkZW50aWZpZXIoKTtcclxuXHR9KS5zb3J0KCkuam9pbihcIiwgXCIpO1xyXG59XHJcblxyXG5NZXJnZUR1cGxpY2F0ZUNodW5rc1BsdWdpbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbihjb21waWxlcikge1xyXG5cdGNvbXBpbGVyLnBsdWdpbihcImNvbXBpbGF0aW9uXCIsIGZ1bmN0aW9uKGNvbXBpbGF0aW9uKSB7XHJcblx0XHRjb21waWxhdGlvbi5wbHVnaW4oXCJvcHRpbWl6ZS1jaHVua3NcIiwgZnVuY3Rpb24oY2h1bmtzKSB7XHJcblx0XHRcdHZhciBtYXAgPSB7fTtcclxuXHRcdFx0Y2h1bmtzLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbihjaHVuaykge1xyXG5cdFx0XHRcdGlmKGNodW5rLmluaXRpYWwpIHJldHVybjtcclxuXHRcdFx0XHR2YXIgaWRlbnQgPSBnZXRDaHVua0lkZW50aWZpZXIoY2h1bmspO1xyXG5cdFx0XHRcdGlmKG1hcFtpZGVudF0pIHtcclxuXHRcdFx0XHRcdGlmKG1hcFtpZGVudF0uaW50ZWdyYXRlKGNodW5rLCBcImR1cGxpY2F0ZVwiKSlcclxuXHRcdFx0XHRcdFx0Y2h1bmtzLnNwbGljZShjaHVua3MuaW5kZXhPZihjaHVuayksIDEpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRtYXBbaWRlbnRdID0gY2h1bms7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvb3B0aW1pemUvTWVyZ2VEdXBsaWNhdGVDaHVua3NQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDE2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5mdW5jdGlvbiBGbGFnSW5jbHVkZWRDaHVua3NQbHVnaW4oKSB7fVxyXG5tb2R1bGUuZXhwb3J0cyA9IEZsYWdJbmNsdWRlZENodW5rc1BsdWdpbjtcclxuXHJcbkZsYWdJbmNsdWRlZENodW5rc1BsdWdpbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbihjb21waWxlcikge1xyXG5cdGNvbXBpbGVyLnBsdWdpbihcImNvbXBpbGF0aW9uXCIsIGZ1bmN0aW9uKGNvbXBpbGF0aW9uKSB7XHJcblx0XHRjb21waWxhdGlvbi5wbHVnaW4oXCJvcHRpbWl6ZS1jaHVuay1pZHNcIiwgZnVuY3Rpb24oY2h1bmtzKSB7XHJcblx0XHRcdGNodW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGNodW5rQSkge1xyXG5cdFx0XHRcdGNodW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGNodW5rQikge1xyXG5cdFx0XHRcdFx0aWYoY2h1bmtBID09PSBjaHVua0IpIHJldHVybjtcclxuXHRcdFx0XHRcdC8vIGlzIGNodW5rQiBpbiBjaHVua0E/XHJcblx0XHRcdFx0XHRpZihjaHVua0EubW9kdWxlcy5sZW5ndGggPCBjaHVua0IubW9kdWxlcy5sZW5ndGgpIHJldHVybjtcclxuXHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBjaHVua0IubW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRpZihjaHVua0EubW9kdWxlcy5pbmRleE9mKGNodW5rQi5tb2R1bGVzW2ldKSA8IDApIHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGNodW5rQS5pZHMucHVzaChjaHVua0IuaWQpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL29wdGltaXplL0ZsYWdJbmNsdWRlZENodW5rc1BsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbmZ1bmN0aW9uIFVuc2FmZUNhY2hlUGx1Z2luKHJlZ0V4cHMsIGNhY2hlKSB7XHJcblx0dGhpcy5yZWdFeHBzID0gcmVnRXhwcyB8fCBbLy4vXTtcclxuXHRpZih0aGlzLnJlZ0V4cHMgPT09IHRydWUpIHRoaXMucmVnRXhwcyA9IFsvLi9dO1xyXG5cdGVsc2UgaWYoIUFycmF5LmlzQXJyYXkodGhpcy5yZWdFeHBzKSkgdGhpcy5yZWdFeHBzID0gW3RoaXMucmVnRXhwc107XHJcblx0dGhpcy5jYWNoZSA9IGNhY2hlIHx8IHt9O1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gVW5zYWZlQ2FjaGVQbHVnaW47XHJcblxyXG5VbnNhZmVDYWNoZVBsdWdpbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbihyZXNvbHZlcikge1xyXG5cdHZhciBvbGRSZXNvbHZlID0gcmVzb2x2ZXIucmVzb2x2ZTtcclxuXHR2YXIgcmVnRXhwcyA9IHRoaXMucmVnRXhwcztcclxuXHR2YXIgY2FjaGUgPSB0aGlzLmNhY2hlO1xyXG5cdHJlc29sdmVyLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKGNvbnRleHQsIHJlcXVlc3QsIGNhbGxiYWNrKSB7XHJcblx0XHR2YXIgaWQgPSBjb250ZXh0ICsgXCItPlwiICsgcmVxdWVzdDtcclxuXHRcdGlmKGNhY2hlW2lkXSkge1xyXG5cdFx0XHQvLyBGcm9tIGNhY2hlXHJcblx0XHRcdHJldHVybiBjYWxsYmFjayhudWxsLCBjYWNoZVtpZF0pO1xyXG5cdFx0fVxyXG5cdFx0b2xkUmVzb2x2ZS5jYWxsKHJlc29sdmVyLCBjb250ZXh0LCByZXF1ZXN0LCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xyXG5cdFx0XHRpZihlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG5cdFx0XHR2YXIgZG9DYWNoZSA9IHJlZ0V4cHMuc29tZShmdW5jdGlvbihyZWdFeHApIHtcclxuXHRcdFx0XHRyZXR1cm4gcmVnRXhwLnRlc3QocmVzdWx0LnBhdGgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0aWYoIWRvQ2FjaGUpIHJldHVybiBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xyXG5cdFx0XHRjYWxsYmFjayhudWxsLCBjYWNoZVtpZF0gPSByZXN1bHQpO1xyXG5cdFx0fSk7XHJcblx0fTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VuaGFuY2VkLXJlc29sdmUvbGliL1Vuc2FmZUNhY2hlUGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIGNyZWF0ZUlubmVyQ2FsbGJhY2sgPSByZXF1aXJlKFwiLi9jcmVhdGVJbm5lckNhbGxiYWNrXCIpO1xyXG52YXIgcG9wUGF0aFNlcW1lbnQgPSByZXF1aXJlKFwiLi9wb3BQYXRoU2VxbWVudFwiKTtcclxuXHJcbmZ1bmN0aW9uIE1vZHVsZXNJbkRpcmVjdG9yaWVzUGx1Z2luKG1vZHVsZVR5cGUsIGRpcmVjdG9yaWVzKSB7XHJcblx0dGhpcy5tb2R1bGVUeXBlID0gbW9kdWxlVHlwZTtcclxuXHR0aGlzLmRpcmVjdG9yaWVzID0gZGlyZWN0b3JpZXM7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBNb2R1bGVzSW5EaXJlY3Rvcmllc1BsdWdpbjtcclxuXHJcbk1vZHVsZXNJbkRpcmVjdG9yaWVzUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKHJlc29sdmVyKSB7XHJcblx0dmFyIG1vZHVsZVR5cGUgPSB0aGlzLm1vZHVsZVR5cGU7XHJcblx0dmFyIGRpcmVjdG9yaWVzID0gdGhpcy5kaXJlY3RvcmllcztcclxuXHRyZXNvbHZlci5wbHVnaW4oXCJtb2R1bGVcIiwgZnVuY3Rpb24ocmVxdWVzdCwgY2FsbGJhY2spIHtcclxuXHRcdHZhciBmcyA9IHRoaXMuZmlsZVN5c3RlbTtcclxuXHRcdHZhciBwYXRocyA9IFtyZXF1ZXN0LnBhdGhdO1xyXG5cdFx0dmFyIGFkZHIgPSBbcmVxdWVzdC5wYXRoXTtcclxuXHRcdHZhciBwYXRoU2VxbWVudCA9IHBvcFBhdGhTZXFtZW50KGFkZHIpO1xyXG5cdFx0dmFyIHRvcExldmVsQ2FsbGJhY2sgPSBjYWxsYmFjaztcclxuXHRcdHdoaWxlKHBhdGhTZXFtZW50KSB7XHJcblx0XHRcdHBhdGhzLnB1c2goYWRkclswXSk7XHJcblx0XHRcdHBhdGhTZXFtZW50ID0gcG9wUGF0aFNlcW1lbnQoYWRkcik7XHJcblx0XHR9XHJcblx0XHR2YXIgYWRkcnMgPSBwYXRocy5tYXAoZnVuY3Rpb24ocCkge1xyXG5cdFx0XHRyZXR1cm4gZGlyZWN0b3JpZXMubWFwKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5qb2luKHAsIGQpO1xyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH0sIHRoaXMpLnJlZHVjZShmdW5jdGlvbihhcnJheSwgcCkge1xyXG5cdFx0XHRhcnJheS5wdXNoLmFwcGx5KGFycmF5LCBwKTtcclxuXHRcdFx0cmV0dXJuIGFycmF5O1xyXG5cdFx0fSwgW10pO1xyXG5cdFx0dGhpcy5mb3JFYWNoQmFpbChhZGRycywgZnVuY3Rpb24oYWRkciwgY2FsbGJhY2spIHtcclxuXHRcdFx0ZnMuc3RhdChhZGRyLCBmdW5jdGlvbihlcnIsIHN0YXQpIHtcclxuXHRcdFx0XHRpZighZXJyICYmIHN0YXQgJiYgc3RhdC5pc0RpcmVjdG9yeSgpKSB7XHJcblx0XHRcdFx0XHR0aGlzLmFwcGx5UGx1Z2luc1BhcmFsbGVsQmFpbFJlc3VsdChcIm1vZHVsZS1cIiArIG1vZHVsZVR5cGUsIHtcclxuXHRcdFx0XHRcdFx0cGF0aDogYWRkcixcclxuXHRcdFx0XHRcdFx0cmVxdWVzdDogcmVxdWVzdC5yZXF1ZXN0LFxyXG5cdFx0XHRcdFx0XHRxdWVyeTogcmVxdWVzdC5xdWVyeSxcclxuXHRcdFx0XHRcdFx0ZGlyZWN0b3J5OiByZXF1ZXN0LmRpcmVjdG9yeVxyXG5cdFx0XHRcdFx0fSwgY3JlYXRlSW5uZXJDYWxsYmFjayhmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xyXG5cdFx0XHRcdFx0XHRpZihlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG5cdFx0XHRcdFx0XHRpZighcmVzdWx0KSByZXR1cm4gY2FsbGJhY2soKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XHJcblx0XHRcdFx0XHR9LCB0b3BMZXZlbENhbGxiYWNrLCBcImxvb2tpbmcgZm9yIG1vZHVsZXMgaW4gXCIgKyBhZGRyKSk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBjYWxsYmFjaygpO1xyXG5cdFx0XHR9LmJpbmQodGhpcykpO1xyXG5cdFx0fS5iaW5kKHRoaXMpLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xyXG5cdFx0XHRpZihlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG5cdFx0XHRpZighcmVzdWx0KSByZXR1cm4gY2FsbGJhY2soKTtcclxuXHRcdFx0cmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XHJcblx0XHR9KTtcclxuXHR9KTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VuaGFuY2VkLXJlc29sdmUvbGliL01vZHVsZXNJbkRpcmVjdG9yaWVzUGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSAxNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwb3BQYXRoU2VxbWVudChwYXRoSW5BcnJheSkge1xyXG5cdHZhciBpID0gcGF0aEluQXJyYXlbMF0ubGFzdEluZGV4T2YoXCIvXCIpLFxyXG5cdFx0aiA9IHBhdGhJbkFycmF5WzBdLmxhc3RJbmRleE9mKFwiXFxcXFwiKTtcclxuXHR2YXIgcCA9IGkgPCAwID8gaiA6IGogPCAwID8gaSA6IGkgPCBqID8gaiA6IGk7XHJcblx0aWYocCA8IDApIHJldHVybiBudWxsO1xyXG5cdHZhciBzID0gcGF0aEluQXJyYXlbMF0uc3Vic3RyKHArMSk7XHJcblx0cGF0aEluQXJyYXlbMF0gPSBwYXRoSW5BcnJheVswXS5zdWJzdHIoMCwgcCB8fCAxKTtcclxuXHRyZXR1cm4gcztcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VuaGFuY2VkLXJlc29sdmUvbGliL3BvcFBhdGhTZXFtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIGNyZWF0ZUlubmVyQ2FsbGJhY2sgPSByZXF1aXJlKFwiLi9jcmVhdGVJbm5lckNhbGxiYWNrXCIpO1xyXG5cclxuZnVuY3Rpb24gTW9kdWxlc0luUm9vdFBsdWdpbihtb2R1bGVUeXBlLCBwYXRoKSB7XHJcblx0dGhpcy5tb2R1bGVUeXBlID0gbW9kdWxlVHlwZTtcclxuXHR0aGlzLnBhdGggPSBwYXRoO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gTW9kdWxlc0luUm9vdFBsdWdpbjtcclxuXHJcbk1vZHVsZXNJblJvb3RQbHVnaW4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24ocmVzb2x2ZXIpIHtcclxuXHR2YXIgbW9kdWxlVHlwZSA9IHRoaXMubW9kdWxlVHlwZTtcclxuXHR2YXIgcGF0aCA9IHRoaXMucGF0aDtcclxuXHRyZXNvbHZlci5wbHVnaW4oXCJtb2R1bGVcIiwgZnVuY3Rpb24ocmVxdWVzdCwgY2FsbGJhY2spIHtcclxuXHRcdHRoaXMuYXBwbHlQbHVnaW5zUGFyYWxsZWxCYWlsUmVzdWx0KFwibW9kdWxlLVwiICsgbW9kdWxlVHlwZSwge1xyXG5cdFx0XHRwYXRoOiBwYXRoLFxyXG5cdFx0XHRyZXF1ZXN0OiByZXF1ZXN0LnJlcXVlc3QsXHJcblx0XHRcdHF1ZXJ5OiByZXF1ZXN0LnF1ZXJ5LFxyXG5cdFx0XHRkaXJlY3Rvcnk6IHJlcXVlc3QuZGlyZWN0b3J5XHJcblx0XHR9LCBjcmVhdGVJbm5lckNhbGxiYWNrKGZ1bmN0aW9uIGlubmVyQ2FsbGJhY2soZXJyLCByZXN1bHQpIHtcclxuXHRcdFx0aWYoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHRcdFx0aWYoIXJlc3VsdCkgcmV0dXJuIGNhbGxiYWNrKCk7XHJcblx0XHRcdHJldHVybiBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xyXG5cdFx0fSwgY2FsbGJhY2ssIFwibG9va2luZyBmb3IgbW9kdWxlcyBpbiBcIiArIHBhdGgpKTtcclxuXHR9KTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VuaGFuY2VkLXJlc29sdmUvbGliL01vZHVsZXNJblJvb3RQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDE3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgY3JlYXRlSW5uZXJDYWxsYmFjayA9IHJlcXVpcmUoXCIuL2NyZWF0ZUlubmVyQ2FsbGJhY2tcIik7XHJcblxyXG5mdW5jdGlvbiBNb2R1bGVUZW1wbGF0ZXNQbHVnaW4obW9kdWxlVHlwZSwgdGVtcGxhdGVzLCB0YXJnZXRNb2R1bGVUeXBlKSB7XHJcblx0dGhpcy5tb2R1bGVUeXBlID0gbW9kdWxlVHlwZTtcclxuXHR0aGlzLnRhcmdldE1vZHVsZVR5cGUgPSB0YXJnZXRNb2R1bGVUeXBlO1xyXG5cdHRoaXMudGVtcGxhdGVzID0gdGVtcGxhdGVzO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gTW9kdWxlVGVtcGxhdGVzUGx1Z2luO1xyXG5cclxuTW9kdWxlVGVtcGxhdGVzUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKHJlc29sdmVyKSB7XHJcblx0dmFyIHRlbXBsYXRlcyA9IHRoaXMudGVtcGxhdGVzO1xyXG5cdHZhciB0YXJnZXRNb2R1bGVUeXBlID0gdGhpcy50YXJnZXRNb2R1bGVUeXBlO1xyXG5cdHJlc29sdmVyLnBsdWdpbihcIm1vZHVsZS1cIiArIHRoaXMubW9kdWxlVHlwZSwgZnVuY3Rpb24ocmVxdWVzdCwgY2FsbGJhY2spIHtcclxuXHRcdHZhciBmcyA9IHRoaXMuZmlsZVN5c3RlbTtcclxuXHRcdHZhciB0b3BMZXZlbENhbGxiYWNrID0gY2FsbGJhY2s7XHJcblx0XHR2YXIgaSA9IHJlcXVlc3QucmVxdWVzdC5pbmRleE9mKFwiL1wiKSxcclxuXHRcdFx0aiA9IHJlcXVlc3QucmVxdWVzdC5pbmRleE9mKFwiXFxcXFwiKTtcclxuXHRcdHZhciBwID0gaSA8IDAgPyBqIDogaiA8IDAgPyBpIDogaSA8IGogPyBpIDogajtcclxuXHRcdHZhciBtb2R1bGVOYW1lLCByZW1haW5pbmdSZXF1ZXN0O1xyXG5cdFx0aWYocCA8IDApIHtcclxuXHRcdFx0bW9kdWxlTmFtZSA9IHJlcXVlc3QucmVxdWVzdDtcclxuXHRcdFx0cmVtYWluaW5nUmVxdWVzdCA9IFwiXCI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRtb2R1bGVOYW1lID0gcmVxdWVzdC5yZXF1ZXN0LnN1YnN0cigwLCBwKTtcclxuXHRcdFx0cmVtYWluaW5nUmVxdWVzdCA9IHJlcXVlc3QucmVxdWVzdC5zdWJzdHIocCk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmZvckVhY2hCYWlsKHRlbXBsYXRlcywgZnVuY3Rpb24odGVtcGxhdGUsIGNhbGxiYWNrKSB7XHJcblx0XHRcdHZhciBtb2R1bGVGaW5hbE5hbWUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC9cXCovZywgbW9kdWxlTmFtZSk7XHJcblx0XHRcdHRoaXMuYXBwbHlQbHVnaW5zUGFyYWxsZWxCYWlsUmVzdWx0KFwibW9kdWxlLVwiICsgdGFyZ2V0TW9kdWxlVHlwZSwge1xyXG5cdFx0XHRcdHBhdGg6IHJlcXVlc3QucGF0aCxcclxuXHRcdFx0XHRyZXF1ZXN0OiBtb2R1bGVGaW5hbE5hbWUgKyByZW1haW5pbmdSZXF1ZXN0LFxyXG5cdFx0XHRcdHF1ZXJ5OiByZXF1ZXN0LnF1ZXJ5LFxyXG5cdFx0XHRcdGRpcmVjdG9yeTogcmVxdWVzdC5kaXJlY3RvcnlcclxuXHRcdFx0fSwgY3JlYXRlSW5uZXJDYWxsYmFjayhmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xyXG5cdFx0XHRcdGlmKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcblx0XHRcdFx0aWYoIXJlc3VsdCkgcmV0dXJuIGNhbGxiYWNrKCk7XHJcblx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XHJcblx0XHRcdH0sIHRvcExldmVsQ2FsbGJhY2ssIFwibW9kdWxlIHZhcmlhdGlvbiBcIiArIG1vZHVsZUZpbmFsTmFtZSkpO1xyXG5cdFx0fS5iaW5kKHRoaXMpLCBjYWxsYmFjayk7XHJcblx0fSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbmhhbmNlZC1yZXNvbHZlL2xpYi9Nb2R1bGVUZW1wbGF0ZXNQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDE3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5mdW5jdGlvbiBNb2R1bGVBc0ZpbGVQbHVnaW4obW9kdWxlVHlwZSkge1xyXG5cdHRoaXMubW9kdWxlVHlwZSA9IG1vZHVsZVR5cGU7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBNb2R1bGVBc0ZpbGVQbHVnaW47XHJcblxyXG5Nb2R1bGVBc0ZpbGVQbHVnaW4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24ocmVzb2x2ZXIpIHtcclxuXHRyZXNvbHZlci5wbHVnaW4oXCJtb2R1bGUtXCIgKyB0aGlzLm1vZHVsZVR5cGUsIGZ1bmN0aW9uKHJlcXVlc3QsIGNhbGxiYWNrKSB7XHJcblx0XHR2YXIgZnMgPSB0aGlzLmZpbGVTeXN0ZW07XHJcblx0XHR2YXIgaSA9IHJlcXVlc3QucmVxdWVzdC5pbmRleE9mKFwiL1wiKSxcclxuXHRcdFx0aiA9IHJlcXVlc3QucmVxdWVzdC5pbmRleE9mKFwiXFxcXFwiKTtcclxuXHRcdGlmKGkgPj0gMCB8fCBqID49IDAgfHwgcmVxdWVzdC5kaXJlY3RvcnkpIHJldHVybiBjYWxsYmFjaygpO1xyXG5cdFx0cmV0dXJuIHRoaXMuZG9SZXNvbHZlKFwiZmlsZVwiLCByZXF1ZXN0LCBjYWxsYmFjaywgdHJ1ZSk7XHJcblx0fSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbmhhbmNlZC1yZXNvbHZlL2xpYi9Nb2R1bGVBc0ZpbGVQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDE3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5mdW5jdGlvbiBNb2R1bGVBc0RpcmVjdG9yeVBsdWdpbihtb2R1bGVUeXBlKSB7XHJcblx0dGhpcy5tb2R1bGVUeXBlID0gbW9kdWxlVHlwZTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IE1vZHVsZUFzRGlyZWN0b3J5UGx1Z2luO1xyXG5cclxuTW9kdWxlQXNEaXJlY3RvcnlQbHVnaW4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24ocmVzb2x2ZXIpIHtcclxuXHRyZXNvbHZlci5wbHVnaW4oXCJtb2R1bGUtXCIgKyB0aGlzLm1vZHVsZVR5cGUsIGZ1bmN0aW9uKHJlcXVlc3QsIGNhbGxiYWNrKSB7XHJcblx0XHR2YXIgZnMgPSB0aGlzLmZpbGVTeXN0ZW07XHJcblx0XHR2YXIgaSA9IHJlcXVlc3QucmVxdWVzdC5pbmRleE9mKFwiL1wiKSxcclxuXHRcdFx0aiA9IHJlcXVlc3QucmVxdWVzdC5pbmRleE9mKFwiXFxcXFwiKTtcclxuXHRcdHZhciBwID0gaSA8IDAgPyBqIDogaiA8IDAgPyBpIDogaSA8IGogPyBpIDogajtcclxuXHRcdHZhciBtb2R1bGVOYW1lLCByZW1haW5pbmdSZXF1ZXN0O1xyXG5cdFx0aWYocCA8IDApIHtcclxuXHRcdFx0bW9kdWxlTmFtZSA9IHJlcXVlc3QucmVxdWVzdDtcclxuXHRcdFx0cmVtYWluaW5nUmVxdWVzdCA9IFwiXCI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRtb2R1bGVOYW1lID0gcmVxdWVzdC5yZXF1ZXN0LnN1YnN0cigwLCBwKTtcclxuXHRcdFx0cmVtYWluaW5nUmVxdWVzdCA9IHJlcXVlc3QucmVxdWVzdC5zdWJzdHIocCsxKTtcclxuXHRcdH1cclxuXHRcdHZhciBtb2R1bGVQYXRoID0gdGhpcy5qb2luKHJlcXVlc3QucGF0aCwgbW9kdWxlTmFtZSk7XHJcblx0XHRmcy5zdGF0KG1vZHVsZVBhdGgsIGZ1bmN0aW9uKGVyciwgc3RhdCkge1xyXG5cdFx0XHRpZihlcnIgfHwgIXN0YXQpIHtcclxuXHRcdFx0XHRpZihjYWxsYmFjay5taXNzaW5nKVxyXG5cdFx0XHRcdFx0Y2FsbGJhY2subWlzc2luZy5wdXNoKG1vZHVsZVBhdGgpO1xyXG5cdFx0XHRcdGlmKGNhbGxiYWNrLmxvZykgY2FsbGJhY2subG9nKG1vZHVsZVBhdGggKyBcIiBkb2Vzbid0IGV4aXN0IChtb2R1bGUgYXMgZGlyZWN0b3J5KVwiKTtcclxuXHRcdFx0XHRyZXR1cm4gY2FsbGJhY2soKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihzdGF0LmlzRGlyZWN0b3J5KCkpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5kb1Jlc29sdmUocmVxdWVzdC5kaXJlY3RvcnkgPyBcImRpcmVjdG9yeVwiIDogW1wiZmlsZVwiLCBcImRpcmVjdG9yeVwiXSwge1xyXG5cdFx0XHRcdFx0cGF0aDogbW9kdWxlUGF0aCxcclxuXHRcdFx0XHRcdHJlcXVlc3Q6IHJlbWFpbmluZ1JlcXVlc3QsXHJcblx0XHRcdFx0XHRxdWVyeTogcmVxdWVzdC5xdWVyeVxyXG5cdFx0XHRcdH0sIGNhbGxiYWNrLCB0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihjYWxsYmFjay5sb2cpIGNhbGxiYWNrLmxvZyhtb2R1bGVQYXRoICsgXCIgaXMgbm90IGEgZGlyZWN0b3J5IChtb2R1bGUgYXMgZGlyZWN0b3J5KVwiKTtcclxuXHRcdFx0cmV0dXJuIGNhbGxiYWNrKCk7XHJcblx0XHR9LmJpbmQodGhpcykpO1xyXG5cdH0pO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZW5oYW5jZWQtcmVzb2x2ZS9saWIvTW9kdWxlQXNEaXJlY3RvcnlQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDE3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgY3JlYXRlSW5uZXJDYWxsYmFjayA9IHJlcXVpcmUoXCIuL2NyZWF0ZUlubmVyQ2FsbGJhY2tcIik7XHJcblxyXG5mdW5jdGlvbiBEaXJlY3RvcnlEZWZhdWx0RmlsZVBsdWdpbihmaWxlcykge1xyXG5cdHRoaXMuZmlsZXMgPSBmaWxlcztcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IERpcmVjdG9yeURlZmF1bHRGaWxlUGx1Z2luO1xyXG5cclxuRGlyZWN0b3J5RGVmYXVsdEZpbGVQbHVnaW4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24ocmVzb2x2ZXIpIHtcclxuXHR2YXIgZmlsZXMgPSB0aGlzLmZpbGVzO1xyXG5cdHJlc29sdmVyLnBsdWdpbihcImRpcmVjdG9yeVwiLCBmdW5jdGlvbihyZXF1ZXN0LCBjYWxsYmFjaykge1xyXG5cdFx0dmFyIGZzID0gdGhpcy5maWxlU3lzdGVtO1xyXG5cdFx0dmFyIHRvcExldmVsQ2FsbGJhY2sgPSBjYWxsYmFjaztcclxuXHRcdHZhciBkaXJlY3RvcnkgPSB0aGlzLmpvaW4ocmVxdWVzdC5wYXRoLCByZXF1ZXN0LnJlcXVlc3QpO1xyXG5cdFx0ZnMuc3RhdChkaXJlY3RvcnksIGZ1bmN0aW9uKGVyciwgc3RhdCkge1xyXG5cdFx0XHRpZihlcnIgfHwgIXN0YXQpIHtcclxuXHRcdFx0XHRpZihjYWxsYmFjay5sb2cpIGNhbGxiYWNrLmxvZyhkaXJlY3RvcnkgKyBcIiBkb2Vzbid0IGV4aXN0IChkaXJlY3RvcnkgZGVmYXVsdCBmaWxlKVwiKTtcclxuXHRcdFx0XHRyZXR1cm4gY2FsbGJhY2soKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZighc3RhdC5pc0RpcmVjdG9yeSgpKSB7XHJcblx0XHRcdFx0aWYoY2FsbGJhY2subG9nKSBjYWxsYmFjay5sb2coZGlyZWN0b3J5ICsgXCIgaXMgbm90IGEgZGlyZWN0b3J5IChkaXJlY3RvcnkgZGVmYXVsdCBmaWxlKVwiKTtcclxuXHRcdFx0XHRyZXR1cm4gY2FsbGJhY2soKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLmZvckVhY2hCYWlsKGZpbGVzLCBmdW5jdGlvbihmaWxlLCBjYWxsYmFjaykge1xyXG5cdFx0XHRcdHRoaXMuZG9SZXNvbHZlKFwiZmlsZVwiLCB7XHJcblx0XHRcdFx0XHRwYXRoOiBkaXJlY3RvcnksXHJcblx0XHRcdFx0XHRxdWVyeTogcmVxdWVzdC5xdWVyeSxcclxuXHRcdFx0XHRcdHJlcXVlc3Q6IGZpbGVcclxuXHRcdFx0XHR9LCBjcmVhdGVJbm5lckNhbGxiYWNrKGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XHJcblx0XHRcdFx0XHRpZighZXJyICYmIHJlc3VsdCkgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdCk7XHJcblx0XHRcdFx0XHRyZXR1cm4gY2FsbGJhY2soKTtcclxuXHRcdFx0XHR9LCB0b3BMZXZlbENhbGxiYWNrLCBcImRpcmVjdG9yeSBkZWZhdWx0IGZpbGUgXCIgKyBmaWxlKSk7XHJcblx0XHRcdH0uYmluZCh0aGlzKSwgZnVuY3Rpb24ocmVzdWx0KSB7XHJcblx0XHRcdFx0aWYoIXJlc3VsdCkgcmV0dXJuIGNhbGxiYWNrKCk7XHJcblx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fS5iaW5kKHRoaXMpKTtcclxuXHR9KTtcclxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZW5oYW5jZWQtcmVzb2x2ZS9saWIvRGlyZWN0b3J5RGVmYXVsdEZpbGVQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDE3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgY3JlYXRlSW5uZXJDYWxsYmFjayA9IHJlcXVpcmUoXCIuL2NyZWF0ZUlubmVyQ2FsbGJhY2tcIik7XHJcblxyXG5mdW5jdGlvbiBEaXJlY3RvcnlEZXNjcmlwdGlvbkZpbGVQbHVnaW4oZmlsZW5hbWUsIGZpZWxkcykge1xyXG5cdHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcclxuXHR0aGlzLmZpZWxkcyA9IGZpZWxkcztcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IERpcmVjdG9yeURlc2NyaXB0aW9uRmlsZVBsdWdpbjtcclxuXHJcbkRpcmVjdG9yeURlc2NyaXB0aW9uRmlsZVBsdWdpbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbihyZXNvbHZlcikge1xyXG5cdHZhciBmaWxlbmFtZSA9IHRoaXMuZmlsZW5hbWU7XHJcblx0dmFyIGZpZWxkcyA9IHRoaXMuZmllbGRzO1xyXG5cdHJlc29sdmVyLnBsdWdpbihcImRpcmVjdG9yeVwiLCBmdW5jdGlvbihyZXF1ZXN0LCBjYWxsYmFjaykge1xyXG5cdFx0dmFyIGZzID0gdGhpcy5maWxlU3lzdGVtO1xyXG5cdFx0dmFyIGRpcmVjdG9yeSA9IHRoaXMuam9pbihyZXF1ZXN0LnBhdGgsIHJlcXVlc3QucmVxdWVzdCk7XHJcblx0XHR2YXIgZGVzY3JpcHRpb25GaWxlUGF0aCA9IHRoaXMuam9pbihkaXJlY3RvcnksIGZpbGVuYW1lKTtcclxuXHRcdGZzLnJlYWRGaWxlKGRlc2NyaXB0aW9uRmlsZVBhdGgsIGZ1bmN0aW9uKGVyciwgY29udGVudCkge1xyXG5cdFx0XHRpZihlcnIpIHtcclxuXHRcdFx0XHRpZihjYWxsYmFjay5sb2cpXHJcblx0XHRcdFx0XHRjYWxsYmFjay5sb2coZGVzY3JpcHRpb25GaWxlUGF0aCArIFwiIGRvZXNuJ3QgZXhpc3QgKGRpcmVjdG9yeSBkZXNjcmlwdGlvbiBmaWxlKVwiKTtcclxuXHRcdFx0XHRyZXR1cm4gY2FsbGJhY2soKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjb250ZW50ID0gY29udGVudC50b1N0cmluZyhcInV0Zi04XCIpO1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGNvbnRlbnQgPSBKU09OLnBhcnNlKGNvbnRlbnQpO1xyXG5cdFx0XHR9IGNhdGNoKGUpIHtcclxuXHRcdFx0XHRpZihjYWxsYmFjay5sb2cpXHJcblx0XHRcdFx0XHRjYWxsYmFjay5sb2coZGVzY3JpcHRpb25GaWxlUGF0aCArIFwiIChkaXJlY3RvcnkgZGVzY3JpcHRpb24gZmlsZSk6IFwiICsgZSk7XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0ZS5tZXNzYWdlID0gZGVzY3JpcHRpb25GaWxlUGF0aCArIFwiIChkaXJlY3RvcnkgZGVzY3JpcHRpb24gZmlsZSk6IFwiICsgZTtcclxuXHRcdFx0XHRyZXR1cm4gY2FsbGJhY2soZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIG1haW5Nb2R1bGVzID0gW107XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRpZihBcnJheS5pc0FycmF5KGZpZWxkc1tpXSkpIHtcclxuXHRcdFx0XHRcdHZhciBjdXJyZW50ID0gY29udGVudDtcclxuXHRcdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBmaWVsZHNbaV0ubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRcdFx0aWYoY3VycmVudCA9PT0gbnVsbCB8fCB0eXBlb2YgY3VycmVudCAhPT0gXCJvYmplY3RcIikge1xyXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSBudWxsO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHZhciBmaWVsZCA9IGZpZWxkc1tpXVtqXTtcclxuXHRcdFx0XHRcdFx0Y3VycmVudCA9IGN1cnJlbnRbZmllbGRdO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYodHlwZW9mIGN1cnJlbnQgPT09IFwic3RyaW5nXCIpIHtcclxuXHRcdFx0XHRcdFx0bWFpbk1vZHVsZXMucHVzaChjdXJyZW50KTtcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcclxuXHRcdFx0XHRcdGlmKHR5cGVvZiBjb250ZW50W2ZpZWxkXSA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0XHRcdFx0XHRtYWluTW9kdWxlcy5wdXNoKGNvbnRlbnRbZmllbGRdKTtcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdChmdW5jdGlvbiBuZXh0KCkge1xyXG5cdFx0XHRcdGlmKG1haW5Nb2R1bGVzLmxlbmd0aCA9PSAwKSByZXR1cm4gY2FsbGJhY2soKTtcclxuXHRcdFx0XHR2YXIgbWFpbk1vZHVsZSA9IG1haW5Nb2R1bGVzLnNoaWZ0KCk7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuZG9SZXNvbHZlKFtcImZpbGVcIiwgXCJkaXJlY3RvcnlcIl0sIHtcclxuXHRcdFx0XHRcdHBhdGg6IGRpcmVjdG9yeSxcclxuXHRcdFx0XHRcdHF1ZXJ5OiByZXF1ZXN0LnF1ZXJ5LFxyXG5cdFx0XHRcdFx0cmVxdWVzdDogbWFpbk1vZHVsZVxyXG5cdFx0XHRcdH0sIGNyZWF0ZUlubmVyQ2FsbGJhY2soZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcclxuXHRcdFx0XHRcdGlmKCFlcnIgJiYgcmVzdWx0KSByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcclxuXHRcdFx0XHRcdHJldHVybiBuZXh0LmNhbGwodGhpcyk7XHJcblx0XHRcdFx0fS5iaW5kKHRoaXMpLCBjYWxsYmFjaywgXCJ1c2UgXCIgKyBtYWluTW9kdWxlICsgXCIgZnJvbSBcIiArIGZpbGVuYW1lKSk7XHJcblx0XHRcdH0uY2FsbCh0aGlzKSlcclxuXHRcdH0uYmluZCh0aGlzKSk7XHJcblx0fSk7XHJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VuaGFuY2VkLXJlc29sdmUvbGliL0RpcmVjdG9yeURlc2NyaXB0aW9uRmlsZVBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBjcmVhdGVJbm5lckNhbGxiYWNrID0gcmVxdWlyZShcIi4vY3JlYXRlSW5uZXJDYWxsYmFja1wiKTtcclxuXHJcbmZ1bmN0aW9uIERpcmVjdG9yeURlc2NyaXB0aW9uRmlsZUZpZWxkQWxpYXNQbHVnaW4oZmlsZW5hbWUsIGZpZWxkKSB7XHJcblx0dGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xyXG5cdHRoaXMuZmllbGQgPSBmaWVsZDtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IERpcmVjdG9yeURlc2NyaXB0aW9uRmlsZUZpZWxkQWxpYXNQbHVnaW47XHJcblxyXG5mdW5jdGlvbiBmaW5kRGVzY3JpcHRpb25GaWxlRmllbGQocmVzb2x2ZXIsIGRpcmVjdG9yeSwgZmlsZW5hbWUsIGZpZWxkLCBjYWxsYmFjaykge1xyXG5cdChmdW5jdGlvbiBmaW5kRGVzY3JpcHRpb25GaWxlKCkge1xyXG5cdFx0dmFyIGRlc2NyaXB0aW9uRmlsZVBhdGggPSByZXNvbHZlci5qb2luKGRpcmVjdG9yeSwgZmlsZW5hbWUpO1xyXG5cdFx0cmVzb2x2ZXIuZmlsZVN5c3RlbS5yZWFkRmlsZShkZXNjcmlwdGlvbkZpbGVQYXRoLCBmdW5jdGlvbihlcnIsIGNvbnRlbnQpIHtcclxuXHRcdFx0aWYoZXJyKSB7XHJcblx0XHRcdFx0ZGlyZWN0b3J5ID0gY2RVcChkaXJlY3RvcnkpO1xyXG5cdFx0XHRcdGlmKCFkaXJlY3RvcnkpIHtcclxuXHRcdFx0XHRcdHJldHVybiBjYWxsYmFjaygpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZmluZERlc2NyaXB0aW9uRmlsZSgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGNvbnRlbnQgPSBKU09OLnBhcnNlKGNvbnRlbnQpO1xyXG5cdFx0XHR9IGNhdGNoKGUpIHtcclxuXHRcdFx0XHRpZihjYWxsYmFjay5sb2cpXHJcblx0XHRcdFx0XHRjYWxsYmFjay5sb2coZGVzY3JpcHRpb25GaWxlUGF0aCArIFwiIChkaXJlY3RvcnkgZGVzY3JpcHRpb24gZmlsZSk6IFwiICsgZSk7XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0ZS5tZXNzYWdlID0gZGVzY3JpcHRpb25GaWxlUGF0aCArIFwiIChkaXJlY3RvcnkgZGVzY3JpcHRpb24gZmlsZSk6IFwiICsgZTtcclxuXHRcdFx0XHRyZXR1cm4gY2FsbGJhY2soZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGZpZWxkRGF0YTtcclxuXHRcdFx0aWYoQXJyYXkuaXNBcnJheShmaWVsZCkpIHtcclxuXHRcdFx0XHR2YXIgY3VycmVudCA9IGNvbnRlbnQ7XHJcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGZpZWxkLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0XHRpZihjdXJyZW50ID09PSBudWxsIHx8IHR5cGVvZiBjdXJyZW50ICE9PSBcIm9iamVjdFwiKSB7XHJcblx0XHRcdFx0XHRcdGN1cnJlbnQgPSBudWxsO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGN1cnJlbnQgPSBjdXJyZW50W2ZpZWxkW2pdXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYodHlwZW9mIGN1cnJlbnQgPT09IFwib2JqZWN0XCIpIHtcclxuXHRcdFx0XHRcdGZpZWxkRGF0YSA9IGN1cnJlbnQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmKHR5cGVvZiBjb250ZW50W2ZpZWxkXSA9PT0gXCJvYmplY3RcIikge1xyXG5cdFx0XHRcdFx0ZmllbGREYXRhID0gY29udGVudFtmaWVsZF07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmKCFmaWVsZERhdGEpIHJldHVybiBjYWxsYmFjaygpO1xyXG5cdFx0XHRjYWxsYmFjayhudWxsLCBmaWVsZERhdGEsIGRpcmVjdG9yeSk7XHJcblx0XHR9KTtcclxuXHR9KCkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjZFVwKGRpcmVjdG9yeSkge1xyXG5cdGlmKGRpcmVjdG9yeSA9PT0gXCIvXCIpIHJldHVybiBudWxsO1xyXG5cdHZhciBpID0gZGlyZWN0b3J5Lmxhc3RJbmRleE9mKFwiL1wiKSxcclxuXHRcdGogPSBkaXJlY3RvcnkubGFzdEluZGV4T2YoXCJcXFxcXCIpO1xyXG5cdHZhciBwID0gaSA8IDAgPyBqIDogaiA8IDAgPyBpIDogaSA8IGogPyBqIDogaTtcclxuXHRpZihwIDwgMCkgcmV0dXJuIG51bGw7XHJcblx0cmV0dXJuIGRpcmVjdG9yeS5zdWJzdHIoMCwgcCB8fCAxKTtcclxufVxyXG5cclxuRGlyZWN0b3J5RGVzY3JpcHRpb25GaWxlRmllbGRBbGlhc1BsdWdpbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbihyZXNvbHZlcikge1xyXG5cdHZhciBmaWxlbmFtZSA9IHRoaXMuZmlsZW5hbWU7XHJcblx0dmFyIGZpZWxkID0gdGhpcy5maWVsZDtcclxuXHRyZXNvbHZlci5wbHVnaW4oXCJtb2R1bGVcIiwgZnVuY3Rpb24ocmVxdWVzdCwgY2FsbGJhY2spIHtcclxuXHRcdHZhciBkaXJlY3RvcnkgPSByZXF1ZXN0LnBhdGg7XHJcblx0XHR2YXIgbW9kdWxlTmFtZSA9IHJlcXVlc3QucmVxdWVzdDtcclxuXHRcdGZpbmREZXNjcmlwdGlvbkZpbGVGaWVsZCh0aGlzLCBkaXJlY3RvcnksIGZpbGVuYW1lLCBmaWVsZCwgZnVuY3Rpb24oZXJyLCBmaWVsZERhdGEsIGRpcmVjdG9yeSkge1xyXG5cdFx0XHRpZihlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG5cdFx0XHRpZighZmllbGREYXRhKSByZXR1cm4gY2FsbGJhY2soKTtcclxuXHRcdFx0dmFyIGRhdGEgPSBmaWVsZERhdGFbbW9kdWxlTmFtZV07XHJcblx0XHRcdGlmKGRhdGEgPT09IG1vZHVsZU5hbWUpIHJldHVybiBjYWxsYmFjaygpO1xyXG5cdFx0XHRpZihkYXRhID09PSBmYWxzZSkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHtcclxuXHRcdFx0XHRwYXRoOiBmYWxzZSxcclxuXHRcdFx0XHRyZXNvbHZlZDogdHJ1ZVxyXG5cdFx0XHR9KTtcclxuXHRcdFx0aWYoIWRhdGEpIHJldHVybiBjYWxsYmFjaygpO1xyXG5cdFx0XHR2YXIgbmV3UmVxdWVzdCA9IHRoaXMucGFyc2UoZGF0YSk7XHJcblx0XHRcdHZhciBvYmogPSB7XHJcblx0XHRcdFx0cGF0aDogZGlyZWN0b3J5LFxyXG5cdFx0XHRcdHJlcXVlc3Q6IG5ld1JlcXVlc3QucGF0aCxcclxuXHRcdFx0XHRxdWVyeTogbmV3UmVxdWVzdC5xdWVyeSxcclxuXHRcdFx0XHRkaXJlY3Rvcnk6IG5ld1JlcXVlc3QuZGlyZWN0b3J5XHJcblx0XHRcdH07XHJcblx0XHRcdHZhciBuZXdDYWxsYmFjayA9IGNyZWF0ZUlubmVyQ2FsbGJhY2soY2FsbGJhY2ssIGNhbGxiYWNrLCBcImFsaWFzZWQgZnJvbSBkaXJlY3RvcnkgZGVzY3JpcHRpb24gZmlsZSBcIiArIHRoaXMuam9pbihkaXJlY3RvcnksIGZpbGVuYW1lKSArIFwiIHdpdGggbWFwcGluZyBcIiArIEpTT04uc3RyaW5naWZ5KG1vZHVsZU5hbWUpKTtcclxuXHRcdFx0aWYobmV3UmVxdWVzdC5tb2R1bGUpIHJldHVybiB0aGlzLmRvUmVzb2x2ZShcIm1vZHVsZVwiLCBvYmosIG5ld0NhbGxiYWNrKTtcclxuXHRcdFx0aWYobmV3UmVxdWVzdC5kaXJlY3RvcnkpIHJldHVybiB0aGlzLmRvUmVzb2x2ZShcImRpcmVjdG9yeVwiLCBvYmosIG5ld0NhbGxiYWNrKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZG9SZXNvbHZlKFtcImZpbGVcIiwgXCJkaXJlY3RvcnlcIl0sIG9iaiwgbmV3Q2FsbGJhY2spO1xyXG5cdFx0fS5iaW5kKHRoaXMpKTtcclxuXHR9KTtcclxuXHRyZXNvbHZlci5wbHVnaW4oXCJyZXN1bHRcIiwgZnVuY3Rpb24ocmVxdWVzdCwgY2FsbGJhY2spIHtcclxuXHRcdHZhciBkaXJlY3RvcnkgPSBjZFVwKHJlcXVlc3QucGF0aCk7XHJcblx0XHR2YXIgcmVxdWVzdFBhdGggPSByZXF1ZXN0LnBhdGg7XHJcblx0XHRmaW5kRGVzY3JpcHRpb25GaWxlRmllbGQodGhpcywgZGlyZWN0b3J5LCBmaWxlbmFtZSwgZmllbGQsIGZ1bmN0aW9uKGVyciwgZmllbGREYXRhLCBkaXJlY3RvcnkpIHtcclxuXHRcdFx0aWYoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHRcdFx0aWYoIWZpZWxkRGF0YSkgcmV0dXJuIGNhbGxiYWNrKCk7XHJcblx0XHRcdHZhciByZWxhdGl2ZSA9IHJlcXVlc3RQYXRoLnN1YnN0cihkaXJlY3RvcnkubGVuZ3RoKzEpLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpO1xyXG5cdFx0XHRpZih0eXBlb2YgZmllbGREYXRhW3JlbGF0aXZlXSAhPT0gXCJ1bmRlZmluZWRcIilcclxuXHRcdFx0XHR2YXIgZGF0YSA9IGZpZWxkRGF0YVtyZWxhdGl2ZV07XHJcblx0XHRcdGVsc2UgaWYodHlwZW9mIGZpZWxkRGF0YVtcIi4vXCIgKyByZWxhdGl2ZV0gIT09IFwidW5kZWZpbmVkXCIpXHJcblx0XHRcdFx0dmFyIGRhdGEgPSBmaWVsZERhdGFbXCIuL1wiICsgcmVsYXRpdmVdO1xyXG5cdFx0XHRpZihkYXRhID09PSByZWxhdGl2ZSB8fCBkYXRhID09PSBcIi4vXCIgKyByZWxhdGl2ZSkgcmV0dXJuIGNhbGxiYWNrKCk7XHJcblx0XHRcdGlmKGRhdGEgPT09IGZhbHNlKSByZXR1cm4gY2FsbGJhY2sobnVsbCwge1xyXG5cdFx0XHRcdHBhdGg6IGZhbHNlLFxyXG5cdFx0XHRcdHJlc29sdmVkOiB0cnVlXHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpZighZGF0YSkgcmV0dXJuIGNhbGxiYWNrKCk7XHJcblx0XHRcdHZhciBuZXdSZXF1ZXN0ID0gdGhpcy5wYXJzZShkYXRhKTtcclxuXHRcdFx0dmFyIG9iaiA9IHtcclxuXHRcdFx0XHRwYXRoOiBkaXJlY3RvcnksXHJcblx0XHRcdFx0cmVxdWVzdDogbmV3UmVxdWVzdC5wYXRoLFxyXG5cdFx0XHRcdHF1ZXJ5OiBuZXdSZXF1ZXN0LnF1ZXJ5LFxyXG5cdFx0XHRcdGRpcmVjdG9yeTogbmV3UmVxdWVzdC5kaXJlY3RvcnlcclxuXHRcdFx0fTtcclxuXHRcdFx0dmFyIG5ld0NhbGxiYWNrID0gY3JlYXRlSW5uZXJDYWxsYmFjayhjYWxsYmFjaywgY2FsbGJhY2ssIFwiYWxpYXNlZCBmcm9tIGRpcmVjdG9yeSBkZXNjcmlwdGlvbiBmaWxlIFwiICsgdGhpcy5qb2luKGRpcmVjdG9yeSwgZmlsZW5hbWUpICsgXCIgd2l0aCBtYXBwaW5nIFwiICsgSlNPTi5zdHJpbmdpZnkocmVsYXRpdmUpKTtcclxuXHRcdFx0aWYobmV3UmVxdWVzdC5tb2R1bGUpIHJldHVybiB0aGlzLmRvUmVzb2x2ZShcIm1vZHVsZVwiLCBvYmosIG5ld0NhbGxiYWNrKTtcclxuXHRcdFx0aWYobmV3UmVxdWVzdC5kaXJlY3RvcnkpIHJldHVybiB0aGlzLmRvUmVzb2x2ZShcImRpcmVjdG9yeVwiLCBvYmosIG5ld0NhbGxiYWNrKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZG9SZXNvbHZlKFtcImZpbGVcIiwgXCJkaXJlY3RvcnlcIl0sIG9iaiwgbmV3Q2FsbGJhY2spO1xyXG5cdFx0fS5iaW5kKHRoaXMpKTtcclxuXHR9KTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VuaGFuY2VkLXJlc29sdmUvbGliL0RpcmVjdG9yeURlc2NyaXB0aW9uRmlsZUZpZWxkQWxpYXNQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDE3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5mdW5jdGlvbiBGaWxlQXBwZW5kUGx1Z2luKGFwcGVuZGluZ3MpIHtcclxuXHR0aGlzLmFwcGVuZGluZ3MgPSBhcHBlbmRpbmdzO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gRmlsZUFwcGVuZFBsdWdpbjtcclxuXHJcbkZpbGVBcHBlbmRQbHVnaW4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24ocmVzb2x2ZXIpIHtcclxuXHR2YXIgYXBwZW5kaW5ncyA9IHRoaXMuYXBwZW5kaW5ncztcclxuXHRyZXNvbHZlci5wbHVnaW4oXCJmaWxlXCIsIGZ1bmN0aW9uKHJlcXVlc3QsIGNhbGxiYWNrKSB7XHJcblx0XHR2YXIgZnMgPSB0aGlzLmZpbGVTeXN0ZW07XHJcblx0XHR2YXIgYWRkciA9IHRoaXMuam9pbihyZXF1ZXN0LnBhdGgsIHJlcXVlc3QucmVxdWVzdCk7XHJcblx0XHR2YXIgYWRkcnMgPSBhcHBlbmRpbmdzLm1hcChmdW5jdGlvbihhKSB7IHJldHVybiBhZGRyICsgYSB9KTtcclxuXHRcdHZhciBsb2cgPSBjYWxsYmFjay5sb2c7XHJcblx0XHR2YXIgbWlzc2luZyA9IGNhbGxiYWNrLm1pc3Npbmc7XHJcblx0XHR0aGlzLmZvckVhY2hCYWlsKGFkZHJzLCBmdW5jdGlvbihhZGRyLCBjYWxsYmFjaykge1xyXG5cdFx0XHRmcy5zdGF0KGFkZHIsIGZ1bmN0aW9uKGVyciwgc3RhdCkge1xyXG5cdFx0XHRcdGlmKCFlcnIgJiYgc3RhdCAmJiBzdGF0LmlzRmlsZSgpKVxyXG5cdFx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKGFkZHIpO1xyXG5cdFx0XHRcdGlmKG1pc3NpbmcgJiYgZXJyKVxyXG5cdFx0XHRcdFx0bWlzc2luZy5wdXNoKGFkZHIpO1xyXG5cdFx0XHRcdGlmKGxvZykge1xyXG5cdFx0XHRcdFx0aWYoZXJyKSBsb2coYWRkciArIFwiIGRvZXNuJ3QgZXhpc3RcIik7XHJcblx0XHRcdFx0XHRlbHNlIGxvZyhhZGRyICsgXCIgaXMgbm90IGEgZmlsZVwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSwgZnVuY3Rpb24odmFsaWRBZGRyKSB7XHJcblx0XHRcdGlmKCF2YWxpZEFkZHIpIHJldHVybiBjYWxsYmFjaygpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5kb1Jlc29sdmUoXCJyZXN1bHRcIiwge1xyXG5cdFx0XHRcdHBhdGg6IHZhbGlkQWRkcixcclxuXHRcdFx0XHRxdWVyeTogcmVxdWVzdC5xdWVyeSxcclxuXHRcdFx0XHRmaWxlOiB0cnVlLFxyXG5cdFx0XHRcdHJlc29sdmVkOiB0cnVlXHJcblx0XHRcdH0sIGNhbGxiYWNrKTtcclxuXHRcdH0uYmluZCh0aGlzKSk7XHJcblx0fSk7XHJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VuaGFuY2VkLXJlc29sdmUvbGliL0ZpbGVBcHBlbmRQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDE4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5mdW5jdGlvbiBEaXJlY3RvcnlSZXN1bHRQbHVnaW4oZmlsZXMpIHtcclxuXHR0aGlzLmZpbGVzID0gZmlsZXM7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBEaXJlY3RvcnlSZXN1bHRQbHVnaW47XHJcblxyXG5EaXJlY3RvcnlSZXN1bHRQbHVnaW4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24ocmVzb2x2ZXIpIHtcclxuXHR2YXIgZmlsZXMgPSB0aGlzLmZpbGVzO1xyXG5cdHJlc29sdmVyLnBsdWdpbihcImRpcmVjdG9yeVwiLCBmdW5jdGlvbihyZXF1ZXN0LCBjYWxsYmFjaykge1xyXG5cdFx0dmFyIGZzID0gdGhpcy5maWxlU3lzdGVtO1xyXG5cdFx0dmFyIGRpcmVjdG9yeSA9IHRoaXMuam9pbihyZXF1ZXN0LnBhdGgsIHJlcXVlc3QucmVxdWVzdCk7XHJcblx0XHRmcy5zdGF0KGRpcmVjdG9yeSwgZnVuY3Rpb24oZXJyLCBzdGF0KSB7XHJcblx0XHRcdGlmKCFlcnIgJiYgc3RhdCAmJiBzdGF0LmlzRGlyZWN0b3J5KCkpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5kb1Jlc29sdmUoXCJyZXN1bHRcIiwge1xyXG5cdFx0XHRcdFx0cGF0aDogZGlyZWN0b3J5LFxyXG5cdFx0XHRcdFx0cXVlcnk6IHJlcXVlc3QucXVlcnksXHJcblx0XHRcdFx0XHRkaXJlY3Rvcnk6IHRydWUsXHJcblx0XHRcdFx0XHRyZXNvbHZlZDogdHJ1ZVxyXG5cdFx0XHRcdH0sIGNhbGxiYWNrKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihjYWxsYmFjay5sb2cpIHtcclxuXHRcdFx0XHRpZihlcnIpIGNhbGxiYWNrLmxvZyhkaXJlY3RvcnkgKyBcIiBkb2Vzbid0IGV4aXN0XCIpO1xyXG5cdFx0XHRcdGVsc2UgY2FsbGJhY2subG9nKGRpcmVjdG9yeSArIFwiIGlzIG5vdCBhIGRpcmVjdG9yeVwiKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gY2FsbGJhY2soKTtcclxuXHRcdH0uYmluZCh0aGlzKSk7XHJcblx0fSk7XHJcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VuaGFuY2VkLXJlc29sdmUvbGliL0RpcmVjdG9yeVJlc3VsdFBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBwb3BQYXRoU2VxbWVudCA9IHJlcXVpcmUoXCIuL3BvcFBhdGhTZXFtZW50XCIpO1xyXG5cclxuZnVuY3Rpb24gUmVzdWx0U3ltbGlua1BsdWdpbihhcHBlbmRpbmdzKSB7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBSZXN1bHRTeW1saW5rUGx1Z2luO1xyXG5cclxuUmVzdWx0U3ltbGlua1BsdWdpbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbihyZXNvbHZlcikge1xyXG5cdHJlc29sdmVyLnBsdWdpbihcInJlc3VsdFwiLCBmdW5jdGlvbiBwbHVnaW5NZXRob2QocmVxdWVzdCwgY2FsbGJhY2spIHtcclxuXHRcdHZhciBmcyA9IHRoaXMuZmlsZVN5c3RlbTtcclxuXHRcdHZhciBwYXRocyA9IFtyZXF1ZXN0LnBhdGhdO1xyXG5cdFx0dmFyIHBhdGhTZXFtZW50cyA9IFtdO1xyXG5cdFx0dmFyIGFkZHIgPSBbcmVxdWVzdC5wYXRoXTtcclxuXHRcdHZhciBwYXRoU2VxbWVudCA9IHBvcFBhdGhTZXFtZW50KGFkZHIpO1xyXG5cdFx0d2hpbGUocGF0aFNlcW1lbnQpIHtcclxuXHRcdFx0cGF0aFNlcW1lbnRzLnB1c2gocGF0aFNlcW1lbnQpO1xyXG5cdFx0XHRwYXRocy5wdXNoKGFkZHJbMF0pO1xyXG5cdFx0XHRwYXRoU2VxbWVudCA9IHBvcFBhdGhTZXFtZW50KGFkZHIpO1xyXG5cdFx0fVxyXG5cdFx0cGF0aFNlcW1lbnRzLnB1c2gocGF0aHNbcGF0aHMubGVuZ3RoLTFdKTtcclxuXHRcdHZhciBsb2cgPSBjYWxsYmFjay5sb2c7XHJcblx0XHR2YXIgbWlzc2luZyA9IGNhbGxiYWNrLm1pc3Npbmc7XHJcblx0XHR2YXIgY29udGFpbnNTeW1saW5rID0gZmFsc2U7XHJcblx0XHR0aGlzLmZvckVhY2hCYWlsKHBhdGhzLm1hcChmdW5jdGlvbihfLCBpKSB7IHJldHVybiBpOyB9KSwgZnVuY3Rpb24oaWR4LCBjYWxsYmFjaykge1xyXG5cdFx0XHRmcy5yZWFkbGluayhwYXRoc1tpZHhdLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkge1xyXG5cdFx0XHRcdGlmKCFlcnIgJiYgcmVzdWx0KSB7XHJcblx0XHRcdFx0XHRwYXRoU2VxbWVudHNbaWR4XSA9IHJlc3VsdDtcclxuXHRcdFx0XHRcdGNvbnRhaW5zU3ltbGluayA9IHRydWU7XHJcblx0XHRcdFx0XHQvLyBTaG9ydGN1dCB3aGVuIGFic29sdXRlIHN5bWxpbmsgZm91bmRcclxuXHRcdFx0XHRcdGlmKC9eKFxcL3xbYS16QS16XTooJHxcXFxcKSkvLnRlc3QocmVzdWx0KSlcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKG51bGwsIGlkeCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSwgZnVuY3Rpb24oZXJyLCBpZHgpIHtcclxuXHRcdFx0aWYoIWNvbnRhaW5zU3ltbGluaykgcmV0dXJuIGNhbGxiYWNrKCk7XHJcblx0XHRcdHZhciByZXN1bHRTZXFtZW50cyA9IHR5cGVvZiBpZHggPT09IFwibnVtYmVyXCIgPyBwYXRoU2VxbWVudHMuc2xpY2UoMCwgaWR4KzEpIDogcGF0aFNlcW1lbnRzLnNsaWNlKCk7XHJcblx0XHRcdHZhciByZXN1bHQgPSByZXN1bHRTZXFtZW50cy5yZXZlcnNlKCkucmVkdWNlKGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5qb2luKGEsIGIpO1xyXG5cdFx0XHR9LmJpbmQodGhpcykpO1xyXG5cdFx0XHRsb2coXCJyZXNvbHZlZCBzeW1saW5rIHRvIFwiICsgcmVzdWx0KTtcclxuXHRcdFx0cmVxdWVzdC5wYXRoID0gcmVzdWx0O1xyXG5cdFx0XHRwbHVnaW5NZXRob2QuY2FsbCh0aGlzLCByZXF1ZXN0LCBjYWxsYmFjayk7XHJcblx0XHR9LmJpbmQodGhpcykpO1xyXG5cdH0pO1xyXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbmhhbmNlZC1yZXNvbHZlL2xpYi9SZXN1bHRTeW1saW5rUGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSAxODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIEpzb25wTWFpblRlbXBsYXRlUGx1Z2luID0gcmVxdWlyZShcIi4vSnNvbnBNYWluVGVtcGxhdGVQbHVnaW5cIik7XHJcbnZhciBKc29ucENodW5rVGVtcGxhdGVQbHVnaW4gPSByZXF1aXJlKFwiLi9Kc29ucENodW5rVGVtcGxhdGVQbHVnaW5cIik7XHJcbnZhciBKc29ucEhvdFVwZGF0ZUNodW5rVGVtcGxhdGVQbHVnaW4gPSByZXF1aXJlKFwiLi9Kc29ucEhvdFVwZGF0ZUNodW5rVGVtcGxhdGVQbHVnaW5cIik7XHJcblxyXG5mdW5jdGlvbiBKc29ucFRlbXBsYXRlUGx1Z2luKCkge31cclxubW9kdWxlLmV4cG9ydHMgPSBKc29ucFRlbXBsYXRlUGx1Z2luO1xyXG5Kc29ucFRlbXBsYXRlUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGNvbXBpbGVyKSB7XHJcblx0Y29tcGlsZXIucGx1Z2luKFwidGhpcy1jb21waWxhdGlvblwiLCBmdW5jdGlvbihjb21waWxhdGlvbikge1xyXG5cdFx0Y29tcGlsYXRpb24ubWFpblRlbXBsYXRlLmFwcGx5KG5ldyBKc29ucE1haW5UZW1wbGF0ZVBsdWdpbigpKTtcclxuXHRcdGNvbXBpbGF0aW9uLmNodW5rVGVtcGxhdGUuYXBwbHkobmV3IEpzb25wQ2h1bmtUZW1wbGF0ZVBsdWdpbigpKTtcclxuXHRcdGNvbXBpbGF0aW9uLmhvdFVwZGF0ZUNodW5rVGVtcGxhdGUuYXBwbHkobmV3IEpzb25wSG90VXBkYXRlQ2h1bmtUZW1wbGF0ZVBsdWdpbigpKTtcclxuXHR9KTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9Kc29ucFRlbXBsYXRlUGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSAxODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIFRlbXBsYXRlID0gcmVxdWlyZShcIi4vVGVtcGxhdGVcIik7XHJcblxyXG5mdW5jdGlvbiBKc29ucE1haW5UZW1wbGF0ZVBsdWdpbigpIHt9XHJcbm1vZHVsZS5leHBvcnRzID0gSnNvbnBNYWluVGVtcGxhdGVQbHVnaW47XHJcblxyXG5Kc29ucE1haW5UZW1wbGF0ZVBsdWdpbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBKc29ucE1haW5UZW1wbGF0ZVBsdWdpbjtcclxuSnNvbnBNYWluVGVtcGxhdGVQbHVnaW4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24obWFpblRlbXBsYXRlKSB7XHJcblx0bWFpblRlbXBsYXRlLnBsdWdpbihcImxvY2FsLXZhcnNcIiwgZnVuY3Rpb24oc291cmNlLCBjaHVuaykge1xyXG5cdFx0aWYoY2h1bmsuY2h1bmtzLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYXNTdHJpbmcoW1xyXG5cdFx0XHRcdHNvdXJjZSxcclxuXHRcdFx0XHRcIlwiLFxyXG5cdFx0XHRcdFwiLy8gb2JqZWN0IHRvIHN0b3JlIGxvYWRlZCBhbmQgbG9hZGluZyBjaHVua3NcIixcclxuXHRcdFx0XHRcIi8vIFxcXCIwXFxcIiBtZWFucyBcXFwiYWxyZWFkeSBsb2FkZWRcXFwiXCIsXHJcblx0XHRcdFx0XCIvLyBBcnJheSBtZWFucyBcXFwibG9hZGluZ1xcXCIsIGFycmF5IGNvbnRhaW5zIGNhbGxiYWNrc1wiLFxyXG5cdFx0XHRcdFwidmFyIGluc3RhbGxlZENodW5rcyA9IHtcIixcclxuXHRcdFx0XHR0aGlzLmluZGVudChcclxuXHRcdFx0XHRcdGNodW5rLmlkcy5tYXAoZnVuY3Rpb24oaWQpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGlkICsgXCI6MFwiO1xyXG5cdFx0XHRcdFx0fSkuam9pbihcIixcXG5cIilcclxuXHRcdFx0XHQpLFxyXG5cdFx0XHRcdFwifTtcIlxyXG5cdFx0XHRdKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBzb3VyY2U7XHJcblx0fSk7XHJcblx0bWFpblRlbXBsYXRlLnBsdWdpbihcImpzb25wLXNjcmlwdFwiLCBmdW5jdGlvbihfLCBjaHVuaywgaGFzaCkge1xyXG5cdFx0dmFyIGZpbGVuYW1lID0gdGhpcy5vdXRwdXRPcHRpb25zLmZpbGVuYW1lIHx8IFwiYnVuZGxlLmpzXCI7XHJcblx0XHR2YXIgY2h1bmtGaWxlbmFtZSA9IHRoaXMub3V0cHV0T3B0aW9ucy5jaHVua0ZpbGVuYW1lIHx8IFwiW2lkXS5cIiArIGZpbGVuYW1lO1xyXG5cdFx0dmFyIGNodW5rTWFwcyA9IGNodW5rLmdldENodW5rTWFwcygpO1xyXG5cdFx0dmFyIGNyb3NzT3JpZ2luTG9hZGluZyA9IHRoaXMub3V0cHV0T3B0aW9ucy5jcm9zc09yaWdpbkxvYWRpbmc7XHJcblx0XHRyZXR1cm4gdGhpcy5hc1N0cmluZyhbXHJcblx0XHRcdFwidmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1wiLFxyXG5cdFx0XHRcInNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XCIsXHJcblx0XHRcdFwic2NyaXB0LmNoYXJzZXQgPSAndXRmLTgnO1wiLFxyXG5cdFx0XHRcInNjcmlwdC5hc3luYyA9IHRydWU7XCIsXHJcblx0XHRcdGNyb3NzT3JpZ2luTG9hZGluZyA/IFwic2NyaXB0LmNyb3NzT3JpZ2luID0gJ1wiICsgY3Jvc3NPcmlnaW5Mb2FkaW5nICsgXCInO1wiIDogXCJcIixcclxuXHRcdFx0XCJzY3JpcHQuc3JjID0gXCIgKyB0aGlzLnJlcXVpcmVGbiArIFwiLnAgKyBcIiArXHJcblx0XHRcdHRoaXMuYXBwbHlQbHVnaW5zV2F0ZXJmYWxsKFwiYXNzZXQtcGF0aFwiLCBKU09OLnN0cmluZ2lmeShjaHVua0ZpbGVuYW1lKSwge1xyXG5cdFx0XHRcdGhhc2g6IFwiXFxcIiArIFwiICsgdGhpcy5yZW5kZXJDdXJyZW50SGFzaENvZGUoaGFzaCkgKyBcIiArIFxcXCJcIixcclxuXHRcdFx0XHRoYXNoV2l0aExlbmd0aDogZnVuY3Rpb24obGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gXCJcXFwiICsgXCIgKyB0aGlzLnJlbmRlckN1cnJlbnRIYXNoQ29kZShoYXNoLCBsZW5ndGgpICsgXCIgKyBcXFwiXCI7XHJcblx0XHRcdFx0fS5iaW5kKHRoaXMpLFxyXG5cdFx0XHRcdGNodW5rOiB7XHJcblx0XHRcdFx0XHRpZDogXCJcXFwiICsgY2h1bmtJZCArIFxcXCJcIixcclxuXHRcdFx0XHRcdGhhc2g6IFwiXFxcIiArIFwiICsgSlNPTi5zdHJpbmdpZnkoY2h1bmtNYXBzLmhhc2gpICsgXCJbY2h1bmtJZF0gKyBcXFwiXCIsXHJcblx0XHRcdFx0XHRoYXNoV2l0aExlbmd0aDogZnVuY3Rpb24obGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRcdHZhciBzaG9ydENodW5rSGFzaE1hcCA9IHt9O1xyXG5cdFx0XHRcdFx0XHRPYmplY3Qua2V5cyhjaHVua01hcHMuaGFzaCkuZm9yRWFjaChmdW5jdGlvbihjaHVua0lkKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYodHlwZW9mIGNodW5rTWFwcy5oYXNoW2NodW5rSWRdID09PSBcInN0cmluZ1wiKVxyXG5cdFx0XHRcdFx0XHRcdFx0c2hvcnRDaHVua0hhc2hNYXBbY2h1bmtJZF0gPSBjaHVua01hcHMuaGFzaFtjaHVua0lkXS5zdWJzdHIoMCwgbGVuZ3RoKTtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHRcdHJldHVybiBcIlxcXCIgKyBcIiArIEpTT04uc3RyaW5naWZ5KHNob3J0Q2h1bmtIYXNoTWFwKSArIFwiW2NodW5rSWRdICsgXFxcIlwiO1xyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdG5hbWU6IFwiXFxcIiArIChcIiArIEpTT04uc3RyaW5naWZ5KGNodW5rTWFwcy5uYW1lKSArIFwiW2NodW5rSWRdfHxjaHVua0lkKSArIFxcXCJcIlxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSkgKyBcIjtcIlxyXG5cdFx0XSk7XHJcblx0fSk7XHJcblx0bWFpblRlbXBsYXRlLnBsdWdpbihcInJlcXVpcmUtZW5zdXJlXCIsIGZ1bmN0aW9uKF8sIGNodW5rLCBoYXNoKSB7XHJcblx0XHR2YXIgZmlsZW5hbWUgPSB0aGlzLm91dHB1dE9wdGlvbnMuZmlsZW5hbWUgfHwgXCJidW5kbGUuanNcIjtcclxuXHRcdHZhciBjaHVua0ZpbGVuYW1lID0gdGhpcy5vdXRwdXRPcHRpb25zLmNodW5rRmlsZW5hbWUgfHwgXCJbaWRdLlwiICsgZmlsZW5hbWU7XHJcblx0XHRyZXR1cm4gdGhpcy5hc1N0cmluZyhbXHJcblx0XHRcdFwiLy8gXFxcIjBcXFwiIGlzIHRoZSBzaWduYWwgZm9yIFxcXCJhbHJlYWR5IGxvYWRlZFxcXCJcIixcclxuXHRcdFx0XCJpZihpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPT09IDApXCIsXHJcblx0XHRcdHRoaXMuaW5kZW50KFwicmV0dXJuIGNhbGxiYWNrLmNhbGwobnVsbCwgXCIgKyB0aGlzLnJlcXVpcmVGbiArIFwiKTtcIiksXHJcblx0XHRcdFwiXCIsXHJcblx0XHRcdFwiLy8gYW4gYXJyYXkgbWVhbnMgXFxcImN1cnJlbnRseSBsb2FkaW5nXFxcIi5cIixcclxuXHRcdFx0XCJpZihpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gIT09IHVuZGVmaW5lZCkge1wiLFxyXG5cdFx0XHR0aGlzLmluZGVudChcImluc3RhbGxlZENodW5rc1tjaHVua0lkXS5wdXNoKGNhbGxiYWNrKTtcIiksXHJcblx0XHRcdFwifSBlbHNlIHtcIixcclxuXHRcdFx0dGhpcy5pbmRlbnQoW1xyXG5cdFx0XHRcdFwiLy8gc3RhcnQgY2h1bmsgbG9hZGluZ1wiLFxyXG5cdFx0XHRcdFwiaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gW2NhbGxiYWNrXTtcIixcclxuXHRcdFx0XHRcInZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcIixcclxuXHRcdFx0XHR0aGlzLmFwcGx5UGx1Z2luc1dhdGVyZmFsbChcImpzb25wLXNjcmlwdFwiLCBcIlwiLCBjaHVuaywgaGFzaCksXHJcblx0XHRcdFx0XCJoZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XCJcclxuXHRcdFx0XSksXHJcblx0XHRcdFwifVwiXHJcblx0XHRdKTtcclxuXHR9KTtcclxuXHRtYWluVGVtcGxhdGUucGx1Z2luKFwiYm9vdHN0cmFwXCIsIGZ1bmN0aW9uKHNvdXJjZSwgY2h1bmssIGhhc2gpIHtcclxuXHRcdGlmKGNodW5rLmNodW5rcy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdHZhciBqc29ucEZ1bmN0aW9uID0gdGhpcy5vdXRwdXRPcHRpb25zLmpzb25wRnVuY3Rpb24gfHwgVGVtcGxhdGUudG9JZGVudGlmaWVyKFwid2VicGFja0pzb25wXCIgKyAodGhpcy5vdXRwdXRPcHRpb25zLmxpYnJhcnkgfHwgXCJcIikpO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hc1N0cmluZyhbXHJcblx0XHRcdFx0c291cmNlLFxyXG5cdFx0XHRcdFwiXCIsXHJcblx0XHRcdFx0XCIvLyBpbnN0YWxsIGEgSlNPTlAgY2FsbGJhY2sgZm9yIGNodW5rIGxvYWRpbmdcIixcclxuXHRcdFx0XHRcInZhciBwYXJlbnRKc29ucEZ1bmN0aW9uID0gd2luZG93W1wiICsgSlNPTi5zdHJpbmdpZnkoanNvbnBGdW5jdGlvbikgKyBcIl07XCIsXHJcblx0XHRcdFx0XCJ3aW5kb3dbXCIgKyBKU09OLnN0cmluZ2lmeShqc29ucEZ1bmN0aW9uKSArIFwiXSA9IGZ1bmN0aW9uIHdlYnBhY2tKc29ucENhbGxiYWNrKGNodW5rSWRzLCBtb3JlTW9kdWxlcykge1wiLFxyXG5cdFx0XHRcdHRoaXMuaW5kZW50KFtcclxuXHRcdFx0XHRcdFwiLy8gYWRkIFxcXCJtb3JlTW9kdWxlc1xcXCIgdG8gdGhlIG1vZHVsZXMgb2JqZWN0LFwiLFxyXG5cdFx0XHRcdFx0XCIvLyB0aGVuIGZsYWcgYWxsIFxcXCJjaHVua0lkc1xcXCIgYXMgbG9hZGVkIGFuZCBmaXJlIGNhbGxiYWNrXCIsXHJcblx0XHRcdFx0XHRcInZhciBtb2R1bGVJZCwgY2h1bmtJZCwgaSA9IDAsIGNhbGxiYWNrcyA9IFtdO1wiLFxyXG5cdFx0XHRcdFx0XCJmb3IoO2kgPCBjaHVua0lkcy5sZW5ndGg7IGkrKykge1wiLFxyXG5cdFx0XHRcdFx0dGhpcy5pbmRlbnQoW1xyXG5cdFx0XHRcdFx0XHRcImNodW5rSWQgPSBjaHVua0lkc1tpXTtcIixcclxuXHRcdFx0XHRcdFx0XCJpZihpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0pXCIsXHJcblx0XHRcdFx0XHRcdHRoaXMuaW5kZW50KFwiY2FsbGJhY2tzLnB1c2guYXBwbHkoY2FsbGJhY2tzLCBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0pO1wiKSxcclxuXHRcdFx0XHRcdFx0XCJpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSAwO1wiXHJcblx0XHRcdFx0XHRdKSxcclxuXHRcdFx0XHRcdFwifVwiLFxyXG5cdFx0XHRcdFx0XCJmb3IobW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcIixcclxuXHRcdFx0XHRcdHRoaXMuaW5kZW50KHRoaXMucmVuZGVyQWRkTW9kdWxlKGhhc2gsIGNodW5rLCBcIm1vZHVsZUlkXCIsIFwibW9yZU1vZHVsZXNbbW9kdWxlSWRdXCIpKSxcclxuXHRcdFx0XHRcdFwifVwiLFxyXG5cdFx0XHRcdFx0XCJpZihwYXJlbnRKc29ucEZ1bmN0aW9uKSBwYXJlbnRKc29ucEZ1bmN0aW9uKGNodW5rSWRzLCBtb3JlTW9kdWxlcyk7XCIsXHJcblx0XHRcdFx0XHRcIndoaWxlKGNhbGxiYWNrcy5sZW5ndGgpXCIsXHJcblx0XHRcdFx0XHR0aGlzLmluZGVudChcImNhbGxiYWNrcy5zaGlmdCgpLmNhbGwobnVsbCwgXCIgKyB0aGlzLnJlcXVpcmVGbiArIFwiKTtcIiksICh0aGlzLmVudHJ5UG9pbnRJbkNoaWxkcmVuKGNodW5rKSA/IFtcclxuXHRcdFx0XHRcdFx0XCJpZihtb3JlTW9kdWxlc1swXSkge1wiLFxyXG5cdFx0XHRcdFx0XHR0aGlzLmluZGVudChbXHJcblx0XHRcdFx0XHRcdFx0XCJpbnN0YWxsZWRNb2R1bGVzWzBdID0gMDtcIixcclxuXHRcdFx0XHRcdFx0XHRcInJldHVybiBcIiArIHRoaXMucmVxdWlyZUZuICsgXCIoMCk7XCJcclxuXHRcdFx0XHRcdFx0XSksXHJcblx0XHRcdFx0XHRcdFwifVwiXHJcblx0XHRcdFx0XHRdIDogXCJcIilcclxuXHRcdFx0XHRdKSxcclxuXHRcdFx0XHRcIn07XCJcclxuXHRcdFx0XSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gc291cmNlO1xyXG5cdH0pO1xyXG5cdG1haW5UZW1wbGF0ZS5wbHVnaW4oXCJob3QtYm9vdHN0cmFwXCIsIGZ1bmN0aW9uKHNvdXJjZSwgY2h1bmssIGhhc2gpIHtcclxuXHRcdHZhciBob3RVcGRhdGVDaHVua0ZpbGVuYW1lID0gdGhpcy5vdXRwdXRPcHRpb25zLmhvdFVwZGF0ZUNodW5rRmlsZW5hbWU7XHJcblx0XHR2YXIgaG90VXBkYXRlTWFpbkZpbGVuYW1lID0gdGhpcy5vdXRwdXRPcHRpb25zLmhvdFVwZGF0ZU1haW5GaWxlbmFtZTtcclxuXHRcdHZhciBob3RVcGRhdGVGdW5jdGlvbiA9IHRoaXMub3V0cHV0T3B0aW9ucy5ob3RVcGRhdGVGdW5jdGlvbiB8fCBUZW1wbGF0ZS50b0lkZW50aWZpZXIoXCJ3ZWJwYWNrSG90VXBkYXRlXCIgKyAodGhpcy5vdXRwdXRPcHRpb25zLmxpYnJhcnkgfHwgXCJcIikpO1xyXG5cdFx0dmFyIGN1cnJlbnRIb3RVcGRhdGVDaHVua0ZpbGVuYW1lID0gdGhpcy5hcHBseVBsdWdpbnNXYXRlcmZhbGwoXCJhc3NldC1wYXRoXCIsIEpTT04uc3RyaW5naWZ5KGhvdFVwZGF0ZUNodW5rRmlsZW5hbWUpLCB7XHJcblx0XHRcdGhhc2g6IFwiXFxcIiArIFwiICsgdGhpcy5yZW5kZXJDdXJyZW50SGFzaENvZGUoaGFzaCkgKyBcIiArIFxcXCJcIixcclxuXHRcdFx0aGFzaFdpdGhMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCkge1xyXG5cdFx0XHRcdHJldHVybiBcIlxcXCIgKyBcIiArIHRoaXMucmVuZGVyQ3VycmVudEhhc2hDb2RlKGhhc2gsIGxlbmd0aCkgKyBcIiArIFxcXCJcIjtcclxuXHRcdFx0fS5iaW5kKHRoaXMpLFxyXG5cdFx0XHRjaHVuazoge1xyXG5cdFx0XHRcdGlkOiBcIlxcXCIgKyBjaHVua0lkICsgXFxcIlwiXHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0dmFyIGN1cnJlbnRIb3RVcGRhdGVNYWluRmlsZW5hbWUgPSB0aGlzLmFwcGx5UGx1Z2luc1dhdGVyZmFsbChcImFzc2V0LXBhdGhcIiwgSlNPTi5zdHJpbmdpZnkoaG90VXBkYXRlTWFpbkZpbGVuYW1lKSwge1xyXG5cdFx0XHRoYXNoOiBcIlxcXCIgKyBcIiArIHRoaXMucmVuZGVyQ3VycmVudEhhc2hDb2RlKGhhc2gpICsgXCIgKyBcXFwiXCIsXHJcblx0XHRcdGhhc2hXaXRoTGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgpIHtcclxuXHRcdFx0XHRyZXR1cm4gXCJcXFwiICsgXCIgKyB0aGlzLnJlbmRlckN1cnJlbnRIYXNoQ29kZShoYXNoLCBsZW5ndGgpICsgXCIgKyBcXFwiXCI7XHJcblx0XHRcdH0uYmluZCh0aGlzKVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIHNvdXJjZSArIFwiXFxuXCIgK1xyXG5cdFx0XHRcInZhciBwYXJlbnRIb3RVcGRhdGVDYWxsYmFjayA9IHRoaXNbXCIgKyBKU09OLnN0cmluZ2lmeShob3RVcGRhdGVGdW5jdGlvbikgKyBcIl07XFxuXCIgK1xyXG5cdFx0XHRcInRoaXNbXCIgKyBKU09OLnN0cmluZ2lmeShob3RVcGRhdGVGdW5jdGlvbikgKyBcIl0gPSBcIiArIFRlbXBsYXRlLmdldEZ1bmN0aW9uQ29udGVudChyZXF1aXJlKFwiLi9Kc29ucE1haW5UZW1wbGF0ZS5ydW50aW1lLmpzXCIpKVxyXG5cdFx0XHQucmVwbGFjZSgvXFwkcmVxdWlyZVxcJC9nLCB0aGlzLnJlcXVpcmVGbilcclxuXHRcdFx0LnJlcGxhY2UoL1xcJGhvdE1haW5GaWxlbmFtZVxcJC9nLCBjdXJyZW50SG90VXBkYXRlTWFpbkZpbGVuYW1lKVxyXG5cdFx0XHQucmVwbGFjZSgvXFwkaG90Q2h1bmtGaWxlbmFtZVxcJC9nLCBjdXJyZW50SG90VXBkYXRlQ2h1bmtGaWxlbmFtZSlcclxuXHRcdFx0LnJlcGxhY2UoL1xcJGhhc2hcXCQvZywgSlNPTi5zdHJpbmdpZnkoaGFzaCkpO1xyXG5cdH0pO1xyXG5cdG1haW5UZW1wbGF0ZS5wbHVnaW4oXCJoYXNoXCIsIGZ1bmN0aW9uKGhhc2gpIHtcclxuXHRcdGhhc2gudXBkYXRlKFwianNvbnBcIik7XHJcblx0XHRoYXNoLnVwZGF0ZShcIjRcIik7XHJcblx0XHRoYXNoLnVwZGF0ZSh0aGlzLm91dHB1dE9wdGlvbnMuZmlsZW5hbWUgKyBcIlwiKTtcclxuXHRcdGhhc2gudXBkYXRlKHRoaXMub3V0cHV0T3B0aW9ucy5jaHVua0ZpbGVuYW1lICsgXCJcIik7XHJcblx0XHRoYXNoLnVwZGF0ZSh0aGlzLm91dHB1dE9wdGlvbnMuanNvbnBGdW5jdGlvbiArIFwiXCIpO1xyXG5cdFx0aGFzaC51cGRhdGUodGhpcy5vdXRwdXRPcHRpb25zLmxpYnJhcnkgKyBcIlwiKTtcclxuXHR9KTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9Kc29ucE1haW5UZW1wbGF0ZVBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbi8qZ2xvYmFscyBob3RBZGRVcGRhdGVDaHVuayBwYXJlbnRIb3RVcGRhdGVDYWxsYmFjayBkb2N1bWVudCBYTUxIdHRwUmVxdWVzdCAkcmVxdWlyZSQgJGhvdENodW5rRmlsZW5hbWUkICRob3RNYWluRmlsZW5hbWUkICovXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblx0ZnVuY3Rpb24gd2VicGFja0hvdFVwZGF0ZUNhbGxiYWNrKGNodW5rSWQsIG1vcmVNb2R1bGVzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuXHRcdGhvdEFkZFVwZGF0ZUNodW5rKGNodW5rSWQsIG1vcmVNb2R1bGVzKTtcclxuXHRcdGlmKHBhcmVudEhvdFVwZGF0ZUNhbGxiYWNrKSBwYXJlbnRIb3RVcGRhdGVDYWxsYmFjayhjaHVua0lkLCBtb3JlTW9kdWxlcyk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBob3REb3dubG9hZFVwZGF0ZUNodW5rKGNodW5rSWQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG5cdFx0dmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XHJcblx0XHR2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcclxuXHRcdHNjcmlwdC50eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIjtcclxuXHRcdHNjcmlwdC5jaGFyc2V0ID0gXCJ1dGYtOFwiO1xyXG5cdFx0c2NyaXB0LnNyYyA9ICRyZXF1aXJlJC5wICsgJGhvdENodW5rRmlsZW5hbWUkO1xyXG5cdFx0aGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaG90RG93bmxvYWRNYW5pZmVzdChjYWxsYmFjaykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcblx0XHRpZih0eXBlb2YgWE1MSHR0cFJlcXVlc3QgPT09IFwidW5kZWZpbmVkXCIpXHJcblx0XHRcdHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoXCJObyBicm93c2VyIHN1cHBvcnRcIikpO1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0dmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHRcdFx0dmFyIHJlcXVlc3RQYXRoID0gJHJlcXVpcmUkLnAgKyAkaG90TWFpbkZpbGVuYW1lJDtcclxuXHRcdFx0cmVxdWVzdC5vcGVuKFwiR0VUXCIsIHJlcXVlc3RQYXRoLCB0cnVlKTtcclxuXHRcdFx0cmVxdWVzdC50aW1lb3V0ID0gMTAwMDA7XHJcblx0XHRcdHJlcXVlc3Quc2VuZChudWxsKTtcclxuXHRcdH0gY2F0Y2goZXJyKSB7XHJcblx0XHRcdHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG5cdFx0fVxyXG5cdFx0cmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0aWYocmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSByZXR1cm47XHJcblx0XHRcdGlmKHJlcXVlc3Quc3RhdHVzID09PSAwKSB7XHJcblx0XHRcdFx0Ly8gdGltZW91dFxyXG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBFcnJvcihcIk1hbmlmZXN0IHJlcXVlc3QgdG8gXCIgKyByZXF1ZXN0UGF0aCArIFwiIHRpbWVkIG91dC5cIikpO1xyXG5cdFx0XHR9IGVsc2UgaWYocmVxdWVzdC5zdGF0dXMgPT09IDQwNCkge1xyXG5cdFx0XHRcdC8vIG5vIHVwZGF0ZSBhdmFpbGFibGVcclxuXHRcdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0XHR9IGVsc2UgaWYocmVxdWVzdC5zdGF0dXMgIT09IDIwMCAmJiByZXF1ZXN0LnN0YXR1cyAhPT0gMzA0KSB7XHJcblx0XHRcdFx0Ly8gb3RoZXIgZmFpbHVyZVxyXG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBFcnJvcihcIk1hbmlmZXN0IHJlcXVlc3QgdG8gXCIgKyByZXF1ZXN0UGF0aCArIFwiIGZhaWxlZC5cIikpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIHN1Y2Nlc3NcclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0dmFyIHVwZGF0ZSA9IEpTT04ucGFyc2UocmVxdWVzdC5yZXNwb25zZVRleHQpO1xyXG5cdFx0XHRcdH0gY2F0Y2goZSkge1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2soZSk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNhbGxiYWNrKG51bGwsIHVwZGF0ZSk7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0fVxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL0pzb25wTWFpblRlbXBsYXRlLnJ1bnRpbWUuanNcbi8vIG1vZHVsZSBpZCA9IDE4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgQ29uY2F0U291cmNlID0gcmVxdWlyZShcIndlYnBhY2stY29yZS9saWIvQ29uY2F0U291cmNlXCIpO1xyXG52YXIgVGVtcGxhdGUgPSByZXF1aXJlKFwiLi9UZW1wbGF0ZVwiKTtcclxuXHJcbmZ1bmN0aW9uIEpzb25wQ2h1bmtUZW1wbGF0ZVBsdWdpbigpIHt9XHJcbm1vZHVsZS5leHBvcnRzID0gSnNvbnBDaHVua1RlbXBsYXRlUGx1Z2luO1xyXG5cclxuSnNvbnBDaHVua1RlbXBsYXRlUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGNodW5rVGVtcGxhdGUpIHtcclxuXHRjaHVua1RlbXBsYXRlLnBsdWdpbihcInJlbmRlclwiLCBmdW5jdGlvbihtb2R1bGVzLCBjaHVuaykge1xyXG5cdFx0dmFyIGpzb25wRnVuY3Rpb24gPSB0aGlzLm91dHB1dE9wdGlvbnMuanNvbnBGdW5jdGlvbiB8fCBUZW1wbGF0ZS50b0lkZW50aWZpZXIoXCJ3ZWJwYWNrSnNvbnBcIiArICh0aGlzLm91dHB1dE9wdGlvbnMubGlicmFyeSB8fCBcIlwiKSk7XHJcblx0XHR2YXIgc291cmNlID0gbmV3IENvbmNhdFNvdXJjZSgpO1xyXG5cdFx0c291cmNlLmFkZChqc29ucEZ1bmN0aW9uICsgXCIoXCIgKyBKU09OLnN0cmluZ2lmeShjaHVuay5pZHMpICsgXCIsXCIpO1xyXG5cdFx0c291cmNlLmFkZChtb2R1bGVzKTtcclxuXHRcdHNvdXJjZS5hZGQoXCIpXCIpO1xyXG5cdFx0cmV0dXJuIHNvdXJjZTtcclxuXHR9KTtcclxuXHRjaHVua1RlbXBsYXRlLnBsdWdpbihcImhhc2hcIiwgZnVuY3Rpb24oaGFzaCkge1xyXG5cdFx0aGFzaC51cGRhdGUoXCJKc29ucENodW5rVGVtcGxhdGVQbHVnaW5cIik7XHJcblx0XHRoYXNoLnVwZGF0ZShcIjNcIik7XHJcblx0XHRoYXNoLnVwZGF0ZSh0aGlzLm91dHB1dE9wdGlvbnMuanNvbnBGdW5jdGlvbiArIFwiXCIpO1xyXG5cdFx0aGFzaC51cGRhdGUodGhpcy5vdXRwdXRPcHRpb25zLmxpYnJhcnkgKyBcIlwiKTtcclxuXHR9KTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9Kc29ucENodW5rVGVtcGxhdGVQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDE4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgQ29uY2F0U291cmNlID0gcmVxdWlyZShcIndlYnBhY2stY29yZS9saWIvQ29uY2F0U291cmNlXCIpO1xyXG52YXIgVGVtcGxhdGUgPSByZXF1aXJlKFwiLi9UZW1wbGF0ZVwiKTtcclxuXHJcbmZ1bmN0aW9uIEpzb25wSG90VXBkYXRlQ2h1bmtUZW1wbGF0ZVBsdWdpbigpIHt9XHJcbm1vZHVsZS5leHBvcnRzID0gSnNvbnBIb3RVcGRhdGVDaHVua1RlbXBsYXRlUGx1Z2luO1xyXG5cclxuSnNvbnBIb3RVcGRhdGVDaHVua1RlbXBsYXRlUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGhvdFVwZGF0ZUNodW5rVGVtcGxhdGUpIHtcclxuXHRob3RVcGRhdGVDaHVua1RlbXBsYXRlLnBsdWdpbihcInJlbmRlclwiLCBmdW5jdGlvbihtb2R1bGVzU291cmNlLCBtb2R1bGVzLCBoYXNoLCBpZCkge1xyXG5cdFx0dmFyIGpzb25wRnVuY3Rpb24gPSB0aGlzLm91dHB1dE9wdGlvbnMuaG90VXBkYXRlRnVuY3Rpb24gfHwgVGVtcGxhdGUudG9JZGVudGlmaWVyKFwid2VicGFja0hvdFVwZGF0ZVwiICsgKHRoaXMub3V0cHV0T3B0aW9ucy5saWJyYXJ5IHx8IFwiXCIpKTtcclxuXHRcdHZhciBzb3VyY2UgPSBuZXcgQ29uY2F0U291cmNlKCk7XHJcblx0XHRzb3VyY2UuYWRkKGpzb25wRnVuY3Rpb24gKyBcIihcIiArIEpTT04uc3RyaW5naWZ5KGlkKSArIFwiLFwiKTtcclxuXHRcdHNvdXJjZS5hZGQobW9kdWxlc1NvdXJjZSk7XHJcblx0XHRzb3VyY2UuYWRkKFwiKVwiKTtcclxuXHRcdHJldHVybiBzb3VyY2U7XHJcblx0fSk7XHJcblx0aG90VXBkYXRlQ2h1bmtUZW1wbGF0ZS5wbHVnaW4oXCJoYXNoXCIsIGZ1bmN0aW9uKGhhc2gpIHtcclxuXHRcdGhhc2gudXBkYXRlKFwiSnNvbnBIb3RVcGRhdGVDaHVua1RlbXBsYXRlUGx1Z2luXCIpO1xyXG5cdFx0aGFzaC51cGRhdGUoXCIzXCIpO1xyXG5cdFx0aGFzaC51cGRhdGUodGhpcy5vdXRwdXRPcHRpb25zLmhvdFVwZGF0ZUZ1bmN0aW9uICsgXCJcIik7XHJcblx0XHRoYXNoLnVwZGF0ZSh0aGlzLm91dHB1dE9wdGlvbnMubGlicmFyeSArIFwiXCIpO1xyXG5cdH0pO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL0pzb25wSG90VXBkYXRlQ2h1bmtUZW1wbGF0ZVBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBNb2R1bGVBbGlhc1BsdWdpbiA9IHJlcXVpcmUoXCJlbmhhbmNlZC1yZXNvbHZlL2xpYi9Nb2R1bGVBbGlhc1BsdWdpblwiKTtcclxudmFyIE1vZHVsZVBhcnNlckhlbHBlcnMgPSByZXF1aXJlKFwiLi4vTW9kdWxlUGFyc2VySGVscGVyc1wiKTtcclxudmFyIG5vZGVMaWJzQnJvd3NlciA9IHJlcXVpcmUoXCJub2RlLWxpYnMtYnJvd3NlclwiKTtcclxudmFyIHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcclxuXHJcbmZ1bmN0aW9uIE5vZGVTb3VyY2VQbHVnaW4ob3B0aW9ucykge1xyXG5cdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBOb2RlU291cmNlUGx1Z2luO1xyXG5Ob2RlU291cmNlUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGNvbXBpbGVyKSB7XHJcblx0dmFyIHBhcnNlciA9IGNvbXBpbGVyLnBhcnNlcjtcclxuXHJcblx0ZnVuY3Rpb24gYnVpbGRFeHByZXNzaW9uKGNvbnRleHQsIHBhdGhUb01vZHVsZSkge1xyXG5cdFx0dmFyIG1vZHVsZUpzUGF0aCA9IHBhdGgucmVsYXRpdmUoY29udGV4dCwgcGF0aFRvTW9kdWxlKTtcclxuXHRcdGlmKCEvXltBLVpdOi9pLnRlc3QobW9kdWxlSnNQYXRoKSkge1xyXG5cdFx0XHRtb2R1bGVKc1BhdGggPSBcIi4vXCIgKyBtb2R1bGVKc1BhdGgucmVwbGFjZSgvXFxcXC9nLCBcIi9cIik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gXCJyZXF1aXJlKFwiICsgSlNPTi5zdHJpbmdpZnkobW9kdWxlSnNQYXRoKSArIFwiKVwiO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gYWRkRXhwcmVzc2lvbihwYXJzZXIsIG5hbWUsIG1vZHVsZSwgdHlwZSwgc3VmZml4KSB7XHJcblx0XHRzdWZmaXggPSBzdWZmaXggfHwgXCJcIjtcclxuXHRcdHBhcnNlci5wbHVnaW4oXCJleHByZXNzaW9uIFwiICsgbmFtZSwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdGlmKHRoaXMuc3RhdGUubW9kdWxlICYmIHRoaXMuc3RhdGUubW9kdWxlLnJlc291cmNlID09PSBnZXRQYXRoVG9Nb2R1bGUobW9kdWxlLCB0eXBlKSkgcmV0dXJuO1xyXG5cdFx0XHRyZXR1cm4gTW9kdWxlUGFyc2VySGVscGVycy5hZGRQYXJzZWRWYXJpYWJsZSh0aGlzLCBuYW1lLCBidWlsZEV4cHJlc3Npb24odGhpcy5zdGF0ZS5tb2R1bGUuY29udGV4dCwgZ2V0UGF0aFRvTW9kdWxlKG1vZHVsZSwgdHlwZSkpICsgc3VmZml4KTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0UGF0aFRvTW9kdWxlKG1vZHVsZSwgdHlwZSkge1xyXG5cdFx0aWYodHlwZSA9PT0gdHJ1ZSB8fCAodHlwZSA9PT0gdW5kZWZpbmVkICYmIG5vZGVMaWJzQnJvd3Nlclttb2R1bGVdKSkge1xyXG5cdFx0XHRpZighbm9kZUxpYnNCcm93c2VyW21vZHVsZV0pIHRocm93IG5ldyBFcnJvcihcIk5vIGJyb3dzZXIgdmVyc2lvbiBmb3Igbm9kZS5qcyBjb3JlIG1vZHVsZSAnXCIgKyBtb2R1bGUgKyBcIicgYXZhaWxhYmxlXCIpO1xyXG5cdFx0XHRyZXR1cm4gbm9kZUxpYnNCcm93c2VyW21vZHVsZV07XHJcblx0XHR9IGVsc2UgaWYodHlwZSA9PT0gXCJtb2NrXCIpIHtcclxuXHRcdFx0cmV0dXJuIHJlcXVpcmUucmVzb2x2ZShcIm5vZGUtbGlicy1icm93c2VyL21vY2svXCIgKyBtb2R1bGUpO1xyXG5cdFx0fSBlbHNlIGlmKHR5cGUgPT09IFwiZW1wdHlcIikge1xyXG5cdFx0XHRyZXR1cm4gcmVxdWlyZS5yZXNvbHZlKFwibm9kZS1saWJzLWJyb3dzZXIvbW9jay9lbXB0eVwiKTtcclxuXHRcdH0gZWxzZSByZXR1cm4gbW9kdWxlO1xyXG5cdH1cclxuXHJcblx0aWYodGhpcy5vcHRpb25zLmdsb2JhbCkge1xyXG5cdFx0Y29tcGlsZXIucGFyc2VyLnBsdWdpbihcImV4cHJlc3Npb24gZ2xvYmFsXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR0aGlzLnN0YXRlLm1vZHVsZS5hZGRWYXJpYWJsZShcImdsb2JhbFwiLCBcIihmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0oKSlcIik7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cdGlmKHRoaXMub3B0aW9ucy5wcm9jZXNzKSB7XHJcblx0XHR2YXIgcHJvY2Vzc1R5cGUgPSB0aGlzLm9wdGlvbnMucHJvY2VzcztcclxuXHRcdGFkZEV4cHJlc3Npb24ocGFyc2VyLCBcInByb2Nlc3NcIiwgXCJwcm9jZXNzXCIsIHByb2Nlc3NUeXBlKTtcclxuXHR9XHJcblx0aWYodGhpcy5vcHRpb25zLmNvbnNvbGUpIHtcclxuXHRcdHZhciBjb25zb2xlVHlwZSA9IHRoaXMub3B0aW9ucy5jb25zb2xlO1xyXG5cdFx0YWRkRXhwcmVzc2lvbihwYXJzZXIsIFwiY29uc29sZVwiLCBcImNvbnNvbGVcIiwgY29uc29sZVR5cGUpO1xyXG5cdH1cclxuXHR2YXIgYnVmZmVyVHlwZSA9IHRoaXMub3B0aW9ucy5CdWZmZXI7XHJcblx0aWYodHlwZW9mIGJ1ZmZlclR5cGUgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdGJ1ZmZlclR5cGUgPSB0aGlzLm9wdGlvbnMuYnVmZmVyO1xyXG5cdFx0aWYodHlwZW9mIGJ1ZmZlclR5cGUgPT09IFwidW5kZWZpbmVkXCIpXHJcblx0XHRcdGJ1ZmZlclR5cGUgPSB0cnVlO1xyXG5cdH1cclxuXHRpZihidWZmZXJUeXBlKSB7XHJcblx0XHRhZGRFeHByZXNzaW9uKHBhcnNlciwgXCJCdWZmZXJcIiwgXCJidWZmZXJcIiwgYnVmZmVyVHlwZSwgXCIuQnVmZmVyXCIpO1xyXG5cdH1cclxuXHRpZih0aGlzLm9wdGlvbnMuc2V0SW1tZWRpYXRlKSB7XHJcblx0XHR2YXIgc2V0SW1tZWRpYXRlVHlwZSA9IHRoaXMub3B0aW9ucy5zZXRJbW1lZGlhdGU7XHJcblx0XHRhZGRFeHByZXNzaW9uKHBhcnNlciwgXCJzZXRJbW1lZGlhdGVcIiwgXCJ0aW1lcnNcIiwgc2V0SW1tZWRpYXRlVHlwZSwgXCIuc2V0SW1tZWRpYXRlXCIpO1xyXG5cdFx0YWRkRXhwcmVzc2lvbihwYXJzZXIsIFwiY2xlYXJJbW1lZGlhdGVcIiwgXCJ0aW1lcnNcIiwgc2V0SW1tZWRpYXRlVHlwZSwgXCIuY2xlYXJJbW1lZGlhdGVcIik7XHJcblx0fVxyXG5cdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cdGNvbXBpbGVyLnBsdWdpbihcImFmdGVyLXJlc29sdmVyc1wiLCBmdW5jdGlvbihjb21waWxlcikge1xyXG5cdFx0dmFyIGFsaWFzID0ge307XHJcblx0XHRPYmplY3Qua2V5cyhub2RlTGlic0Jyb3dzZXIpLmZvckVhY2goZnVuY3Rpb24obGliKSB7XHJcblx0XHRcdGlmKG9wdGlvbnNbbGliXSAhPT0gZmFsc2UpXHJcblx0XHRcdFx0YWxpYXNbbGliICsgXCIkXCJdID0gZ2V0UGF0aFRvTW9kdWxlKGxpYiwgb3B0aW9uc1tsaWJdKTtcclxuXHRcdH0pO1xyXG5cdFx0aWYoT2JqZWN0LmtleXMoYWxpYXMpLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0Y29tcGlsZXIucmVzb2x2ZXJzLm5vcm1hbC5hcHBseShcclxuXHRcdFx0XHRuZXcgTW9kdWxlQWxpYXNQbHVnaW4oYWxpYXMpXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblx0fSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvbm9kZS9Ob2RlU291cmNlUGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSAxODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG1hcCA9IHtcblx0XCIuL2J1ZmZlclwiOiAxOTEsXG5cdFwiLi9idWZmZXIuanNcIjogMTkxLFxuXHRcIi4vY29uc29sZVwiOiAxOTIsXG5cdFwiLi9jb25zb2xlLmpzXCI6IDE5Mixcblx0XCIuL2Ruc1wiOiAxOTMsXG5cdFwiLi9kbnMuanNcIjogMTkzLFxuXHRcIi4vZW1wdHlcIjogMTk0LFxuXHRcIi4vZW1wdHkuanNcIjogMTk0LFxuXHRcIi4vbmV0XCI6IDE5NSxcblx0XCIuL25ldC5qc1wiOiAxOTUsXG5cdFwiLi9wcm9jZXNzXCI6IDE5Nixcblx0XCIuL3Byb2Nlc3MuanNcIjogMTk2LFxuXHRcIi4vcHVueWNvZGVcIjogMTk3LFxuXHRcIi4vcHVueWNvZGUuanNcIjogMTk3LFxuXHRcIi4vdGxzXCI6IDE5OCxcblx0XCIuL3Rscy5qc1wiOiAxOTgsXG5cdFwiLi90dHlcIjogMTk5LFxuXHRcIi4vdHR5LmpzXCI6IDE5OVxufTtcbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0KHJlcSkge1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyh3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSk7XG59O1xuZnVuY3Rpb24gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkge1xuXHRyZXR1cm4gbWFwW3JlcV0gfHwgKGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInLlwiKSB9KCkpO1xufTtcbndlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dEtleXMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcbndlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xud2VicGFja0NvbnRleHQuaWQgPSAxOTA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbm9kZS1saWJzLWJyb3dzZXIvbW9jayBeXFwuXFwvLiokXG4vLyBtb2R1bGUgaWQgPSAxOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gQnVmZmVyKCkge1xuXHR0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXIgaXMgbm90IGluY2x1ZGVkLlwiKTtcbn1cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTA7XG5leHBvcnRzLlNsb3dCdWZmZXIgPSBCdWZmZXI7XG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ub2RlLWxpYnMtYnJvd3Nlci9tb2NrL2J1ZmZlci5qc1xuLy8gbW9kdWxlIGlkID0gMTkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb25zb2xlO1xuaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNvbnNvbGUpIHtcbiAgICBjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGVcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuY29uc29sZSkge1xuICAgIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZVxufSBlbHNlIHtcbiAgICBjb25zb2xlID0gd2luZG93LmNvbnNvbGUgPSB7fVxufVxubW9kdWxlLmV4cG9ydHMgPSBjb25zb2xlO1xuZm9yKHZhciBuYW1lIGluIHtsb2c6MSwgaW5mbzoxLCBlcnJvcjoxLCB3YXJuOjEsIGRpcjoxLCB0cmFjZToxLCBhc3NlcnQ6MSwgdGltZToxLCB0aW1lRW5kOiAxfSlcblx0aWYoIWNvbnNvbGVbbmFtZV0pXG5cdFx0Y29uc29sZVtuYW1lXSA9IGZ1bmN0aW9uKCkge307XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbm9kZS1saWJzLWJyb3dzZXIvbW9jay9jb25zb2xlLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cy5sb29rdXAgPSBleHBvcnRzLnJlc29sdmU0ID1cbmV4cG9ydHMucmVzb2x2ZTYgPSBleHBvcnRzLnJlc29sdmVDbmFtZSA9XG5leHBvcnRzLnJlc29sdmVNeCA9IGV4cG9ydHMucmVzb2x2ZU5zID1cbmV4cG9ydHMucmVzb2x2ZVR4dCA9IGV4cG9ydHMucmVzb2x2ZVNydiA9XG5leHBvcnRzLnJlc29sdmVOYXB0ciA9IGV4cG9ydHMucmV2ZXJzZSA9XG5leHBvcnRzLnJlc29sdmUgPVxuZnVuY3Rpb24gKCkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybjtcblxuICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sobnVsbCwgJzAuMC4wLjAnKVxuICB9XG59XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ub2RlLWxpYnMtYnJvd3Nlci9tb2NrL2Rucy5qc1xuLy8gbW9kdWxlIGlkID0gMTkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMuY3JlYXRlU2VydmVyID1cbmV4cG9ydHMuY3JlYXRlQ29ubmVjdGlvbiA9XG5leHBvcnRzLmNvbm5lY3QgPVxuZnVuY3Rpb24gKCkge307XG5cbmV4cG9ydHMuaXNJUCA9XG5leHBvcnRzLmlzSVB2NCA9XG5leHBvcnRzLmlzSVB2NiA9XG5mdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlIH07XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ub2RlLWxpYnMtYnJvd3Nlci9tb2NrL25ldC5qc1xuLy8gbW9kdWxlIGlkID0gMTk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMubmV4dFRpY2sgPSBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuXHRzZXRUaW1lb3V0KGZuLCAwKTtcbn07XG5cbmV4cG9ydHMucGxhdGZvcm0gPSBleHBvcnRzLmFyY2ggPSBcbmV4cG9ydHMuZXhlY1BhdGggPSBleHBvcnRzLnRpdGxlID0gJ2Jyb3dzZXInO1xuZXhwb3J0cy5waWQgPSAxO1xuZXhwb3J0cy5icm93c2VyID0gdHJ1ZTtcbmV4cG9ydHMuZW52ID0ge307XG5leHBvcnRzLmFyZ3YgPSBbXTtcblxuZXhwb3J0cy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0dGhyb3cgbmV3IEVycm9yKCdObyBzdWNoIG1vZHVsZS4gKFBvc3NpYmx5IG5vdCB5ZXQgbG9hZGVkKScpXG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICAgIHZhciBjd2QgPSAnLyc7XG4gICAgdmFyIHBhdGg7XG4gICAgZXhwb3J0cy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjd2QgfTtcbiAgICBleHBvcnRzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgICAgICBpZiAoIXBhdGgpIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG4gICAgICAgIGN3ZCA9IHBhdGgucmVzb2x2ZShkaXIsIGN3ZCk7XG4gICAgfTtcbn0pKCk7XG5cbmV4cG9ydHMuZXhpdCA9IGV4cG9ydHMua2lsbCA9IFxuZXhwb3J0cy51bWFzayA9IGV4cG9ydHMuZGxvcGVuID0gXG5leHBvcnRzLnVwdGltZSA9IGV4cG9ydHMubWVtb3J5VXNhZ2UgPSBcbmV4cG9ydHMudXZDb3VudGVycyA9IGZ1bmN0aW9uKCkge307XG5leHBvcnRzLmZlYXR1cmVzID0ge307XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbm9kZS1saWJzLWJyb3dzZXIvbW9jay9wcm9jZXNzLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cy51Y3MyID0ge307XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuZGVjb2RlID1cbmV4cG9ydHMudWNzMi5lbmNvZGUgPSBleHBvcnRzLnVjczIuZGVjb2RlID1cbmV4cG9ydHMudG9Vbmljb2RlID0gZXhwb3J0cy50b0FTQ0lJID1cbmZ1bmN0aW9uIChzKSB7IHJldHVybiBzIH07XG5leHBvcnRzLnZlcnNpb24gPSBcIjAuMC4wXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L25vZGUtbGlicy1icm93c2VyL21vY2svcHVueWNvZGUuanNcbi8vIG1vZHVsZSBpZCA9IDE5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyB0b2RvXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbm9kZS1saWJzLWJyb3dzZXIvbW9jay90bHMuanNcbi8vIG1vZHVsZSBpZCA9IDE5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzLmlzYXR0eSA9IGZ1bmN0aW9uICgpIHt9O1xuZXhwb3J0cy5zZXRSYXdNb2RlID0gZnVuY3Rpb24gKCkge307XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbm9kZS1saWJzLWJyb3dzZXIvbW9jay90dHkuanNcbi8vIG1vZHVsZSBpZCA9IDE5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgV2ViV29ya2VyTWFpblRlbXBsYXRlUGx1Z2luID0gcmVxdWlyZShcIi4vV2ViV29ya2VyTWFpblRlbXBsYXRlUGx1Z2luXCIpO1xyXG52YXIgV2ViV29ya2VyQ2h1bmtUZW1wbGF0ZVBsdWdpbiA9IHJlcXVpcmUoXCIuL1dlYldvcmtlckNodW5rVGVtcGxhdGVQbHVnaW5cIik7XHJcblxyXG5mdW5jdGlvbiBXZWJXb3JrZXJUZW1wbGF0ZVBsdWdpbigpIHt9XHJcbm1vZHVsZS5leHBvcnRzID0gV2ViV29ya2VyVGVtcGxhdGVQbHVnaW47XHJcbldlYldvcmtlclRlbXBsYXRlUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGNvbXBpbGVyKSB7XHJcblx0Y29tcGlsZXIucGx1Z2luKFwidGhpcy1jb21waWxhdGlvblwiLCBmdW5jdGlvbihjb21waWxhdGlvbikge1xyXG5cdFx0Y29tcGlsYXRpb24ubWFpblRlbXBsYXRlLmFwcGx5KG5ldyBXZWJXb3JrZXJNYWluVGVtcGxhdGVQbHVnaW4oKSk7XHJcblx0XHRjb21waWxhdGlvbi5jaHVua1RlbXBsYXRlLmFwcGx5KG5ldyBXZWJXb3JrZXJDaHVua1RlbXBsYXRlUGx1Z2luKCkpO1xyXG5cdH0pO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL3dlYndvcmtlci9XZWJXb3JrZXJUZW1wbGF0ZVBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMjAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBUZW1wbGF0ZSA9IHJlcXVpcmUoXCIuLi9UZW1wbGF0ZVwiKTtcclxuXHJcbmZ1bmN0aW9uIFdlYldvcmtlck1haW5UZW1wbGF0ZVBsdWdpbigpIHt9XHJcbm1vZHVsZS5leHBvcnRzID0gV2ViV29ya2VyTWFpblRlbXBsYXRlUGx1Z2luO1xyXG5cclxuV2ViV29ya2VyTWFpblRlbXBsYXRlUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKG1haW5UZW1wbGF0ZSkge1xyXG5cdG1haW5UZW1wbGF0ZS5wbHVnaW4oXCJsb2NhbC12YXJzXCIsIGZ1bmN0aW9uKHNvdXJjZSwgY2h1bmspIHtcclxuXHRcdGlmKGNodW5rLmNodW5rcy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmFzU3RyaW5nKFtcclxuXHRcdFx0XHRzb3VyY2UsXHJcblx0XHRcdFx0XCJcIixcclxuXHRcdFx0XHRcIi8vIG9iamVjdCB0byBzdG9yZSBsb2FkZWQgY2h1bmtzXCIsXHJcblx0XHRcdFx0XCIvLyBcXFwiMVxcXCIgbWVhbnMgXFxcImFscmVhZHkgbG9hZGVkXFxcIlwiLFxyXG5cdFx0XHRcdFwidmFyIGluc3RhbGxlZENodW5rcyA9IHtcIixcclxuXHRcdFx0XHR0aGlzLmluZGVudChcclxuXHRcdFx0XHRcdGNodW5rLmlkcy5tYXAoZnVuY3Rpb24oaWQpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGlkICsgXCI6MVwiO1xyXG5cdFx0XHRcdFx0fSkuam9pbihcIixcXG5cIilcclxuXHRcdFx0XHQpLFxyXG5cdFx0XHRcdFwifTtcIlxyXG5cdFx0XHRdKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBzb3VyY2U7XHJcblx0fSk7XHJcblx0bWFpblRlbXBsYXRlLnBsdWdpbihcInJlcXVpcmUtZW5zdXJlXCIsIGZ1bmN0aW9uKF8sIGNodW5rLCBoYXNoKSB7XHJcblx0XHR2YXIgZmlsZW5hbWUgPSB0aGlzLm91dHB1dE9wdGlvbnMuZmlsZW5hbWUgfHwgXCJidW5kbGUuanNcIjtcclxuXHRcdHZhciBjaHVua0ZpbGVuYW1lID0gdGhpcy5vdXRwdXRPcHRpb25zLmNodW5rRmlsZW5hbWUgfHwgXCJbaWRdLlwiICsgZmlsZW5hbWU7XHJcblx0XHRyZXR1cm4gdGhpcy5hc1N0cmluZyhbXHJcblx0XHRcdFwiLy8gXFxcIjFcXFwiIGlzIHRoZSBzaWduYWwgZm9yIFxcXCJhbHJlYWR5IGxvYWRlZFxcXCJcIixcclxuXHRcdFx0XCJpZighaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdKSB7XCIsXHJcblx0XHRcdHRoaXMuaW5kZW50KFtcclxuXHRcdFx0XHRcImltcG9ydFNjcmlwdHMoXCIgK1xyXG5cdFx0XHRcdHRoaXMuYXBwbHlQbHVnaW5zV2F0ZXJmYWxsKFwiYXNzZXQtcGF0aFwiLCBKU09OLnN0cmluZ2lmeShjaHVua0ZpbGVuYW1lKSwge1xyXG5cdFx0XHRcdFx0aGFzaDogXCJcXFwiICsgXCIgKyB0aGlzLnJlbmRlckN1cnJlbnRIYXNoQ29kZShoYXNoKSArIFwiICsgXFxcIlwiLFxyXG5cdFx0XHRcdFx0aGFzaFdpdGhMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gXCJcXFwiICsgXCIgKyB0aGlzLnJlbmRlckN1cnJlbnRIYXNoQ29kZShoYXNoLCBsZW5ndGgpICsgXCIgKyBcXFwiXCI7XHJcblx0XHRcdFx0XHR9LmJpbmQodGhpcyksXHJcblx0XHRcdFx0XHRjaHVuazoge1xyXG5cdFx0XHRcdFx0XHRpZDogXCJcXFwiICsgY2h1bmtJZCArIFxcXCJcIlxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pICsgXCIpO1wiXHJcblx0XHRcdF0pLFxyXG5cdFx0XHRcIn1cIixcclxuXHRcdFx0XCJjYWxsYmFjay5jYWxsKG51bGwsIFwiICsgdGhpcy5yZXF1aXJlRm4gKyBcIik7XCJcclxuXHRcdF0pO1xyXG5cdH0pO1xyXG5cdG1haW5UZW1wbGF0ZS5wbHVnaW4oXCJib290c3RyYXBcIiwgZnVuY3Rpb24oc291cmNlLCBjaHVuaywgaGFzaCkge1xyXG5cdFx0aWYoY2h1bmsuY2h1bmtzLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0dmFyIGNodW5rQ2FsbGJhY2tOYW1lID0gdGhpcy5vdXRwdXRPcHRpb25zLmNodW5rQ2FsbGJhY2tOYW1lIHx8IFRlbXBsYXRlLnRvSWRlbnRpZmllcihcIndlYnBhY2tDaHVua1wiICsgKHRoaXMub3V0cHV0T3B0aW9ucy5saWJyYXJ5IHx8IFwiXCIpKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYXNTdHJpbmcoW1xyXG5cdFx0XHRcdHNvdXJjZSxcclxuXHRcdFx0XHRcInRoaXNbXCIgKyBKU09OLnN0cmluZ2lmeShjaHVua0NhbGxiYWNrTmFtZSkgKyBcIl0gPSBmdW5jdGlvbiB3ZWJwYWNrQ2h1bmtDYWxsYmFjayhjaHVua0lkcywgbW9yZU1vZHVsZXMpIHtcIixcclxuXHRcdFx0XHR0aGlzLmluZGVudChbXHJcblx0XHRcdFx0XHRcImZvcih2YXIgbW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcIixcclxuXHRcdFx0XHRcdHRoaXMuaW5kZW50KHRoaXMucmVuZGVyQWRkTW9kdWxlKGhhc2gsIGNodW5rLCBcIm1vZHVsZUlkXCIsIFwibW9yZU1vZHVsZXNbbW9kdWxlSWRdXCIpKSxcclxuXHRcdFx0XHRcdFwifVwiLFxyXG5cdFx0XHRcdFx0XCJ3aGlsZShjaHVua0lkcy5sZW5ndGgpXCIsXHJcblx0XHRcdFx0XHR0aGlzLmluZGVudChcImluc3RhbGxlZENodW5rc1tjaHVua0lkcy5wb3AoKV0gPSAxO1wiKVxyXG5cdFx0XHRcdF0pLFxyXG5cdFx0XHRcdFwifTtcIlxyXG5cdFx0XHRdKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBzb3VyY2U7XHJcblx0fSk7XHJcblx0bWFpblRlbXBsYXRlLnBsdWdpbihcImhhc2hcIiwgZnVuY3Rpb24oaGFzaCkge1xyXG5cdFx0aGFzaC51cGRhdGUoXCJ3ZWJ3b3JrZXJcIik7XHJcblx0XHRoYXNoLnVwZGF0ZShcIjNcIik7XHJcblx0XHRoYXNoLnVwZGF0ZSh0aGlzLm91dHB1dE9wdGlvbnMucHVibGljUGF0aCArIFwiXCIpO1xyXG5cdFx0aGFzaC51cGRhdGUodGhpcy5vdXRwdXRPcHRpb25zLmZpbGVuYW1lICsgXCJcIik7XHJcblx0XHRoYXNoLnVwZGF0ZSh0aGlzLm91dHB1dE9wdGlvbnMuY2h1bmtGaWxlbmFtZSArIFwiXCIpO1xyXG5cdFx0aGFzaC51cGRhdGUodGhpcy5vdXRwdXRPcHRpb25zLmNodW5rQ2FsbGJhY2tOYW1lICsgXCJcIik7XHJcblx0XHRoYXNoLnVwZGF0ZSh0aGlzLm91dHB1dE9wdGlvbnMubGlicmFyeSArIFwiXCIpO1xyXG5cdH0pO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL3dlYndvcmtlci9XZWJXb3JrZXJNYWluVGVtcGxhdGVQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDIwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgQ29uY2F0U291cmNlID0gcmVxdWlyZShcIndlYnBhY2stY29yZS9saWIvQ29uY2F0U291cmNlXCIpO1xyXG52YXIgVGVtcGxhdGUgPSByZXF1aXJlKFwiLi4vVGVtcGxhdGVcIik7XHJcblxyXG5mdW5jdGlvbiBXZWJXb3JrZXJDaHVua1RlbXBsYXRlUGx1Z2luKCkge31cclxubW9kdWxlLmV4cG9ydHMgPSBXZWJXb3JrZXJDaHVua1RlbXBsYXRlUGx1Z2luO1xyXG5cclxuV2ViV29ya2VyQ2h1bmtUZW1wbGF0ZVBsdWdpbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbihjaHVua1RlbXBsYXRlKSB7XHJcblx0Y2h1bmtUZW1wbGF0ZS5wbHVnaW4oXCJyZW5kZXJcIiwgZnVuY3Rpb24obW9kdWxlcywgY2h1bmspIHtcclxuXHRcdHZhciBjaHVua0NhbGxiYWNrTmFtZSA9IHRoaXMub3V0cHV0T3B0aW9ucy5jaHVua0NhbGxiYWNrTmFtZSB8fCBUZW1wbGF0ZS50b0lkZW50aWZpZXIoXCJ3ZWJwYWNrQ2h1bmtcIiArICh0aGlzLm91dHB1dE9wdGlvbnMubGlicmFyeSB8fCBcIlwiKSk7XHJcblx0XHR2YXIgc291cmNlID0gbmV3IENvbmNhdFNvdXJjZSgpO1xyXG5cdFx0c291cmNlLmFkZChjaHVua0NhbGxiYWNrTmFtZSArIFwiKFwiICsgSlNPTi5zdHJpbmdpZnkoY2h1bmsuaWRzKSArIFwiLFwiKTtcclxuXHRcdHNvdXJjZS5hZGQobW9kdWxlcyk7XHJcblx0XHRzb3VyY2UuYWRkKFwiKVwiKTtcclxuXHRcdHJldHVybiBzb3VyY2U7XHJcblx0fSk7XHJcblx0Y2h1bmtUZW1wbGF0ZS5wbHVnaW4oXCJoYXNoXCIsIGZ1bmN0aW9uKGhhc2gpIHtcclxuXHRcdGhhc2gudXBkYXRlKFwid2Vid29ya2VyXCIpO1xyXG5cdFx0aGFzaC51cGRhdGUoXCIzXCIpO1xyXG5cdFx0aGFzaC51cGRhdGUodGhpcy5vdXRwdXRPcHRpb25zLmNodW5rQ2FsbGJhY2tOYW1lICsgXCJcIik7XHJcblx0XHRoYXNoLnVwZGF0ZSh0aGlzLm91dHB1dE9wdGlvbnMubGlicmFyeSArIFwiXCIpO1xyXG5cdH0pO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL3dlYndvcmtlci9XZWJXb3JrZXJDaHVua1RlbXBsYXRlUGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIE5vZGVNYWluVGVtcGxhdGVQbHVnaW4gPSByZXF1aXJlKFwiLi9Ob2RlTWFpblRlbXBsYXRlUGx1Z2luXCIpO1xyXG52YXIgTm9kZUNodW5rVGVtcGxhdGVQbHVnaW4gPSByZXF1aXJlKFwiLi9Ob2RlQ2h1bmtUZW1wbGF0ZVBsdWdpblwiKTtcclxudmFyIE5vZGVIb3RVcGRhdGVDaHVua1RlbXBsYXRlUGx1Z2luID0gcmVxdWlyZShcIi4vTm9kZUhvdFVwZGF0ZUNodW5rVGVtcGxhdGVQbHVnaW5cIik7XHJcblxyXG5mdW5jdGlvbiBOb2RlVGVtcGxhdGVQbHVnaW4ob3B0aW9ucywgYXN5bmNDaHVua0xvYWRpbmcpIHtcclxuXHQvLyBUT0RPIHJlbW92ZSBvcHRpb25zIHBhcmFtZXRlclxyXG5cdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcblx0dGhpcy5hc3luY0NodW5rTG9hZGluZyA9IGFzeW5jQ2h1bmtMb2FkaW5nO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gTm9kZVRlbXBsYXRlUGx1Z2luO1xyXG5Ob2RlVGVtcGxhdGVQbHVnaW4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oY29tcGlsZXIpIHtcclxuXHRjb21waWxlci5wbHVnaW4oXCJ0aGlzLWNvbXBpbGF0aW9uXCIsIGZ1bmN0aW9uKGNvbXBpbGF0aW9uKSB7XHJcblx0XHRjb21waWxhdGlvbi5tYWluVGVtcGxhdGUuYXBwbHkobmV3IE5vZGVNYWluVGVtcGxhdGVQbHVnaW4odGhpcy5hc3luY0NodW5rTG9hZGluZykpO1xyXG5cdFx0Y29tcGlsYXRpb24uY2h1bmtUZW1wbGF0ZS5hcHBseShuZXcgTm9kZUNodW5rVGVtcGxhdGVQbHVnaW4oKSk7XHJcblx0XHRjb21waWxhdGlvbi5ob3RVcGRhdGVDaHVua1RlbXBsYXRlLmFwcGx5KG5ldyBOb2RlSG90VXBkYXRlQ2h1bmtUZW1wbGF0ZVBsdWdpbigpKTtcclxuXHR9LmJpbmQodGhpcykpO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL25vZGUvTm9kZVRlbXBsYXRlUGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIFRlbXBsYXRlID0gcmVxdWlyZShcIi4uL1RlbXBsYXRlXCIpO1xyXG5cclxuZnVuY3Rpb24gTm9kZU1haW5UZW1wbGF0ZVBsdWdpbihhc3luY0NodW5rTG9hZGluZykge1xyXG5cdHRoaXMuYXN5bmNDaHVua0xvYWRpbmcgPSBhc3luY0NodW5rTG9hZGluZztcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVNYWluVGVtcGxhdGVQbHVnaW47XHJcbk5vZGVNYWluVGVtcGxhdGVQbHVnaW4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24obWFpblRlbXBsYXRlKSB7XHJcblx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cdG1haW5UZW1wbGF0ZS5wbHVnaW4oXCJsb2NhbC12YXJzXCIsIGZ1bmN0aW9uKHNvdXJjZSwgY2h1bmspIHtcclxuXHRcdGlmKGNodW5rLmNodW5rcy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmFzU3RyaW5nKFtcclxuXHRcdFx0XHRzb3VyY2UsXHJcblx0XHRcdFx0XCJcIixcclxuXHRcdFx0XHRcIi8vIG9iamVjdCB0byBzdG9yZSBsb2FkZWQgY2h1bmtzXCIsXHJcblx0XHRcdFx0XCIvLyBcXFwiMVxcXCIgbWVhbnMgXFxcImFscmVhZHkgbG9hZGVkXFxcIlwiLFxyXG5cdFx0XHRcdFwidmFyIGluc3RhbGxlZENodW5rcyA9IHtcIixcclxuXHRcdFx0XHR0aGlzLmluZGVudChcclxuXHRcdFx0XHRcdGNodW5rLmlkcy5tYXAoZnVuY3Rpb24oaWQpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGlkICsgXCI6MVwiO1xyXG5cdFx0XHRcdFx0fSkuam9pbihcIixcXG5cIilcclxuXHRcdFx0XHQpLFxyXG5cdFx0XHRcdFwifTtcIlxyXG5cdFx0XHRdKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBzb3VyY2U7XHJcblx0fSk7XHJcblx0bWFpblRlbXBsYXRlLnBsdWdpbihcInJlcXVpcmUtZW5zdXJlXCIsIGZ1bmN0aW9uKF8sIGNodW5rLCBoYXNoKSB7XHJcblx0XHR2YXIgZmlsZW5hbWUgPSB0aGlzLm91dHB1dE9wdGlvbnMuZmlsZW5hbWUgfHwgXCJidW5kbGUuanNcIjtcclxuXHRcdHZhciBjaHVua0ZpbGVuYW1lID0gdGhpcy5vdXRwdXRPcHRpb25zLmNodW5rRmlsZW5hbWUgfHwgXCJbaWRdLlwiICsgZmlsZW5hbWU7XHJcblx0XHR2YXIgY2h1bmtNYXBzID0gY2h1bmsuZ2V0Q2h1bmtNYXBzKCk7XHJcblx0XHR2YXIgaW5zZXJ0TW9yZU1vZHVsZXMgPSBbXHJcblx0XHRcdFwidmFyIG1vcmVNb2R1bGVzID0gY2h1bmsubW9kdWxlcywgY2h1bmtJZHMgPSBjaHVuay5pZHM7XCIsXHJcblx0XHRcdFwiZm9yKHZhciBtb2R1bGVJZCBpbiBtb3JlTW9kdWxlcykge1wiLFxyXG5cdFx0XHR0aGlzLmluZGVudCh0aGlzLnJlbmRlckFkZE1vZHVsZShoYXNoLCBjaHVuaywgXCJtb2R1bGVJZFwiLCBcIm1vcmVNb2R1bGVzW21vZHVsZUlkXVwiKSksXHJcblx0XHRcdFwifVwiXHJcblx0XHRdO1xyXG5cdFx0aWYoc2VsZi5hc3luY0NodW5rTG9hZGluZykge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hc1N0cmluZyhbXHJcblx0XHRcdFx0XCJpZihpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPT09IDEpIGNhbGxiYWNrLmNhbGwobnVsbCwgXCIgKyB0aGlzLnJlcXVpcmVGbiArIFwiKTtcIixcclxuXHRcdFx0XHRcImVsc2UgaWYoIWluc3RhbGxlZENodW5rc1tjaHVua0lkXSkge1wiLFxyXG5cdFx0XHRcdHRoaXMuaW5kZW50KFtcclxuXHRcdFx0XHRcdFwiaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gW2NhbGxiYWNrXTtcIixcclxuXHRcdFx0XHRcdFwidmFyIGZpbGVuYW1lID0gX19kaXJuYW1lICsgXCIgKyB0aGlzLmFwcGx5UGx1Z2luc1dhdGVyZmFsbChcImFzc2V0LXBhdGhcIiwgSlNPTi5zdHJpbmdpZnkoXCIvXCIgKyBjaHVua0ZpbGVuYW1lKSwge1xyXG5cdFx0XHRcdFx0XHRoYXNoOiBcIlxcXCIgKyBcIiArIHRoaXMucmVuZGVyQ3VycmVudEhhc2hDb2RlKGhhc2gpICsgXCIgKyBcXFwiXCIsXHJcblx0XHRcdFx0XHRcdGhhc2hXaXRoTGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgpIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gXCJcXFwiICsgXCIgKyB0aGlzLnJlbmRlckN1cnJlbnRIYXNoQ29kZShoYXNoLCBsZW5ndGgpICsgXCIgKyBcXFwiXCI7XHJcblx0XHRcdFx0XHRcdH0uYmluZCh0aGlzKSxcclxuXHRcdFx0XHRcdFx0Y2h1bms6IHtcclxuXHRcdFx0XHRcdFx0XHRpZDogXCJcXFwiICsgY2h1bmtJZCArIFxcXCJcIixcclxuXHRcdFx0XHRcdFx0XHRoYXNoOiBcIlxcXCIgKyBcIiArIEpTT04uc3RyaW5naWZ5KGNodW5rTWFwcy5oYXNoKSArIFwiW2NodW5rSWRdICsgXFxcIlwiLFxyXG5cdFx0XHRcdFx0XHRcdGhhc2hXaXRoTGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBzaG9ydENodW5rSGFzaE1hcCA9IHt9O1xyXG5cdFx0XHRcdFx0XHRcdFx0T2JqZWN0LmtleXMoY2h1bmtNYXBzLmhhc2gpLmZvckVhY2goZnVuY3Rpb24oY2h1bmtJZCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZih0eXBlb2YgY2h1bmtNYXBzLmhhc2hbY2h1bmtJZF0gPT09IFwic3RyaW5nXCIpXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0c2hvcnRDaHVua0hhc2hNYXBbY2h1bmtJZF0gPSBjaHVua01hcHMuaGFzaFtjaHVua0lkXS5zdWJzdHIoMCwgbGVuZ3RoKTtcclxuXHRcdFx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIFwiXFxcIiArIFwiICsgSlNPTi5zdHJpbmdpZnkoc2hvcnRDaHVua0hhc2hNYXApICsgXCJbY2h1bmtJZF0gKyBcXFwiXCI7XHJcblx0XHRcdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdFx0XHRuYW1lOiBcIlxcXCIgKyAoXCIgKyBKU09OLnN0cmluZ2lmeShjaHVua01hcHMubmFtZSkgKyBcIltjaHVua0lkXXx8Y2h1bmtJZCkgKyBcXFwiXCJcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSkgKyBcIjtcIixcclxuXHRcdFx0XHRcdFwicmVxdWlyZSgnZnMnKS5yZWFkRmlsZShmaWxlbmFtZSwgJ3V0Zi04JywgIGZ1bmN0aW9uKGVyciwgY29udGVudCkge1wiLFxyXG5cdFx0XHRcdFx0dGhpcy5pbmRlbnQoW1xyXG5cdFx0XHRcdFx0XHRcImlmKGVycikgeyBpZihcIiArIHRoaXMucmVxdWlyZUZuICsgXCIub25FcnJvcikgcmV0dXJuIFwiICsgdGhpcy5yZXF1aXJlRm4gKyBcIi5vbkVycm9yKGVycik7IGVsc2UgdGhyb3cgZXJyOyB9XCIsXHJcblx0XHRcdFx0XHRcdFwidmFyIGNodW5rID0ge307XCIsXHJcblx0XHRcdFx0XHRcdFwicmVxdWlyZSgndm0nKS5ydW5JblRoaXNDb250ZXh0KCcoZnVuY3Rpb24oZXhwb3J0cywgcmVxdWlyZSwgX19kaXJuYW1lLCBfX2ZpbGVuYW1lKSB7JyArIGNvbnRlbnQgKyAnXFxcXG59KScsIGZpbGVuYW1lKVwiICtcclxuXHRcdFx0XHRcdFx0XCIoY2h1bmssIHJlcXVpcmUsIHJlcXVpcmUoJ3BhdGgnKS5kaXJuYW1lKGZpbGVuYW1lKSwgZmlsZW5hbWUpO1wiXHJcblx0XHRcdFx0XHRdLmNvbmNhdChpbnNlcnRNb3JlTW9kdWxlcykuY29uY2F0KFtcclxuXHRcdFx0XHRcdFx0XCJ2YXIgY2FsbGJhY2tzID0gW107XCIsXHJcblx0XHRcdFx0XHRcdFwiZm9yKHZhciBpID0gMDsgaSA8IGNodW5rSWRzLmxlbmd0aDsgaSsrKSB7XCIsXHJcblx0XHRcdFx0XHRcdHRoaXMuaW5kZW50KFtcclxuXHRcdFx0XHRcdFx0XHRcImlmKEFycmF5LmlzQXJyYXkoaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRzW2ldXSkpXCIsXHJcblx0XHRcdFx0XHRcdFx0dGhpcy5pbmRlbnQoW1xyXG5cdFx0XHRcdFx0XHRcdFx0XCJjYWxsYmFja3MgPSBjYWxsYmFja3MuY29uY2F0KGluc3RhbGxlZENodW5rc1tjaHVua0lkc1tpXV0pO1wiXHJcblx0XHRcdFx0XHRcdFx0XSksXHJcblx0XHRcdFx0XHRcdFx0XCJpbnN0YWxsZWRDaHVua3NbY2h1bmtJZHNbaV1dID0gMTtcIlxyXG5cdFx0XHRcdFx0XHRdKSxcclxuXHRcdFx0XHRcdFx0XCJ9XCIsXHJcblx0XHRcdFx0XHRcdFwiZm9yKGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKVwiLFxyXG5cdFx0XHRcdFx0XHR0aGlzLmluZGVudChcImNhbGxiYWNrc1tpXS5jYWxsKG51bGwsIFwiICsgdGhpcy5yZXF1aXJlRm4gKyBcIik7XCIpXHJcblx0XHRcdFx0XHRdKSksXHJcblx0XHRcdFx0XHRcIn0pO1wiXHJcblx0XHRcdFx0XSksXHJcblx0XHRcdFx0XCJ9IGVsc2UgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdLnB1c2goY2FsbGJhY2spO1wiXHJcblx0XHRcdF0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIHJlcXVlc3QgPSB0aGlzLmFwcGx5UGx1Z2luc1dhdGVyZmFsbChcImFzc2V0LXBhdGhcIiwgSlNPTi5zdHJpbmdpZnkoXCIuL1wiICsgY2h1bmtGaWxlbmFtZSksIHtcclxuXHRcdFx0XHRoYXNoOiBcIlxcXCIgKyBcIiArIHRoaXMucmVuZGVyQ3VycmVudEhhc2hDb2RlKGhhc2gpICsgXCIgKyBcXFwiXCIsXHJcblx0XHRcdFx0aGFzaFdpdGhMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIFwiXFxcIiArIFwiICsgdGhpcy5yZW5kZXJDdXJyZW50SGFzaENvZGUoaGFzaCwgbGVuZ3RoKSArIFwiICsgXFxcIlwiO1xyXG5cdFx0XHRcdH0uYmluZCh0aGlzKSxcclxuXHRcdFx0XHRjaHVuazoge1xyXG5cdFx0XHRcdFx0aWQ6IFwiXFxcIiArIGNodW5rSWQgKyBcXFwiXCIsXHJcblx0XHRcdFx0XHRoYXNoOiBcIlxcXCIgKyBcIiArIEpTT04uc3RyaW5naWZ5KGNodW5rTWFwcy5oYXNoKSArIFwiW2NodW5rSWRdICsgXFxcIlwiLFxyXG5cdFx0XHRcdFx0aGFzaFdpdGhMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHR2YXIgc2hvcnRDaHVua0hhc2hNYXAgPSB7fTtcclxuXHRcdFx0XHRcdFx0T2JqZWN0LmtleXMoY2h1bmtNYXBzLmhhc2gpLmZvckVhY2goZnVuY3Rpb24oY2h1bmtJZCkge1xyXG5cdFx0XHRcdFx0XHRcdGlmKHR5cGVvZiBjaHVua01hcHMuaGFzaFtjaHVua0lkXSA9PT0gXCJzdHJpbmdcIilcclxuXHRcdFx0XHRcdFx0XHRcdHNob3J0Q2h1bmtIYXNoTWFwW2NodW5rSWRdID0gY2h1bmtNYXBzLmhhc2hbY2h1bmtJZF0uc3Vic3RyKDAsIGxlbmd0aCk7XHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gXCJcXFwiICsgXCIgKyBKU09OLnN0cmluZ2lmeShzaG9ydENodW5rSGFzaE1hcCkgKyBcIltjaHVua0lkXSArIFxcXCJcIjtcclxuXHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRuYW1lOiBcIlxcXCIgKyAoXCIgKyBKU09OLnN0cmluZ2lmeShjaHVua01hcHMubmFtZSkgKyBcIltjaHVua0lkXXx8Y2h1bmtJZCkgKyBcXFwiXCJcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hc1N0cmluZyhbXHJcblx0XHRcdFx0XCIvLyBcXFwiMVxcXCIgaXMgdGhlIHNpZ25hbCBmb3IgXFxcImFscmVhZHkgbG9hZGVkXFxcIlwiLFxyXG5cdFx0XHRcdFwiaWYoIWluc3RhbGxlZENodW5rc1tjaHVua0lkXSkge1wiLFxyXG5cdFx0XHRcdHRoaXMuaW5kZW50KFtcclxuXHRcdFx0XHRcdFwidmFyIGNodW5rID0gcmVxdWlyZShcIiArIHJlcXVlc3QgKyBcIik7XCJcclxuXHRcdFx0XHRdLmNvbmNhdChpbnNlcnRNb3JlTW9kdWxlcykuY29uY2F0KFtcclxuXHRcdFx0XHRcdFwiZm9yKHZhciBpID0gMDsgaSA8IGNodW5rSWRzLmxlbmd0aDsgaSsrKVwiLFxyXG5cdFx0XHRcdFx0dGhpcy5pbmRlbnQoXCJpbnN0YWxsZWRDaHVua3NbY2h1bmtJZHNbaV1dID0gMTtcIilcclxuXHRcdFx0XHRdKSksXHJcblx0XHRcdFx0XCJ9XCIsXHJcblx0XHRcdFx0XCJjYWxsYmFjay5jYWxsKG51bGwsIFwiICsgdGhpcy5yZXF1aXJlRm4gKyBcIik7XCJcclxuXHRcdFx0XSk7XHJcblx0XHR9XHJcblx0fSk7XHJcblx0bWFpblRlbXBsYXRlLnBsdWdpbihcImhvdC1ib290c3RyYXBcIiwgZnVuY3Rpb24oc291cmNlLCBjaHVuaywgaGFzaCkge1xyXG5cdFx0dmFyIGhvdFVwZGF0ZUNodW5rRmlsZW5hbWUgPSB0aGlzLm91dHB1dE9wdGlvbnMuaG90VXBkYXRlQ2h1bmtGaWxlbmFtZTtcclxuXHRcdHZhciBob3RVcGRhdGVNYWluRmlsZW5hbWUgPSB0aGlzLm91dHB1dE9wdGlvbnMuaG90VXBkYXRlTWFpbkZpbGVuYW1lO1xyXG5cdFx0dmFyIGNodW5rTWFwcyA9IGNodW5rLmdldENodW5rTWFwcygpO1xyXG5cdFx0dmFyIGN1cnJlbnRIb3RVcGRhdGVDaHVua0ZpbGVuYW1lID0gdGhpcy5hcHBseVBsdWdpbnNXYXRlcmZhbGwoXCJhc3NldC1wYXRoXCIsIEpTT04uc3RyaW5naWZ5KGhvdFVwZGF0ZUNodW5rRmlsZW5hbWUpLCB7XHJcblx0XHRcdGhhc2g6IFwiXFxcIiArIFwiICsgdGhpcy5yZW5kZXJDdXJyZW50SGFzaENvZGUoaGFzaCkgKyBcIiArIFxcXCJcIixcclxuXHRcdFx0aGFzaFdpdGhMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCkge1xyXG5cdFx0XHRcdHJldHVybiBcIlxcXCIgKyBcIiArIHRoaXMucmVuZGVyQ3VycmVudEhhc2hDb2RlKGhhc2gsIGxlbmd0aCkgKyBcIiArIFxcXCJcIjtcclxuXHRcdFx0fS5iaW5kKHRoaXMpLFxyXG5cdFx0XHRjaHVuazoge1xyXG5cdFx0XHRcdGlkOiBcIlxcXCIgKyBjaHVua0lkICsgXFxcIlwiLFxyXG5cdFx0XHRcdGhhc2g6IFwiXFxcIiArIFwiICsgSlNPTi5zdHJpbmdpZnkoY2h1bmtNYXBzLmhhc2gpICsgXCJbY2h1bmtJZF0gKyBcXFwiXCIsXHJcblx0XHRcdFx0aGFzaFdpdGhMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCkge1xyXG5cdFx0XHRcdFx0dmFyIHNob3J0Q2h1bmtIYXNoTWFwID0ge307XHJcblx0XHRcdFx0XHRPYmplY3Qua2V5cyhjaHVua01hcHMuaGFzaCkuZm9yRWFjaChmdW5jdGlvbihjaHVua0lkKSB7XHJcblx0XHRcdFx0XHRcdGlmKHR5cGVvZiBjaHVua01hcHMuaGFzaFtjaHVua0lkXSA9PT0gXCJzdHJpbmdcIilcclxuXHRcdFx0XHRcdFx0XHRzaG9ydENodW5rSGFzaE1hcFtjaHVua0lkXSA9IGNodW5rTWFwcy5oYXNoW2NodW5rSWRdLnN1YnN0cigwLCBsZW5ndGgpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHRyZXR1cm4gXCJcXFwiICsgXCIgKyBKU09OLnN0cmluZ2lmeShzaG9ydENodW5rSGFzaE1hcCkgKyBcIltjaHVua0lkXSArIFxcXCJcIjtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdG5hbWU6IFwiXFxcIiArIChcIiArIEpTT04uc3RyaW5naWZ5KGNodW5rTWFwcy5uYW1lKSArIFwiW2NodW5rSWRdfHxjaHVua0lkKSArIFxcXCJcIlxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdHZhciBjdXJyZW50SG90VXBkYXRlTWFpbkZpbGVuYW1lID0gdGhpcy5hcHBseVBsdWdpbnNXYXRlcmZhbGwoXCJhc3NldC1wYXRoXCIsIEpTT04uc3RyaW5naWZ5KGhvdFVwZGF0ZU1haW5GaWxlbmFtZSksIHtcclxuXHRcdFx0aGFzaDogXCJcXFwiICsgXCIgKyB0aGlzLnJlbmRlckN1cnJlbnRIYXNoQ29kZShoYXNoKSArIFwiICsgXFxcIlwiLFxyXG5cdFx0XHRoYXNoV2l0aExlbmd0aDogZnVuY3Rpb24obGVuZ3RoKSB7XHJcblx0XHRcdFx0cmV0dXJuIFwiXFxcIiArIFwiICsgdGhpcy5yZW5kZXJDdXJyZW50SGFzaENvZGUoaGFzaCwgbGVuZ3RoKSArIFwiICsgXFxcIlwiO1xyXG5cdFx0XHR9LmJpbmQodGhpcylcclxuXHRcdH0pO1xyXG5cdFx0cmV0dXJuIFRlbXBsYXRlLmdldEZ1bmN0aW9uQ29udGVudChzZWxmLmFzeW5jQ2h1bmtMb2FkaW5nID8gcmVxdWlyZShcIi4vTm9kZU1haW5UZW1wbGF0ZUFzeW5jLnJ1bnRpbWUuanNcIikgOiByZXF1aXJlKFwiLi9Ob2RlTWFpblRlbXBsYXRlLnJ1bnRpbWUuanNcIikpXHJcblx0XHRcdC5yZXBsYWNlKC9cXCRyZXF1aXJlXFwkL2csIHRoaXMucmVxdWlyZUZuKVxyXG5cdFx0XHQucmVwbGFjZSgvXFwkaG90TWFpbkZpbGVuYW1lXFwkL2csIGN1cnJlbnRIb3RVcGRhdGVNYWluRmlsZW5hbWUpXHJcblx0XHRcdC5yZXBsYWNlKC9cXCRob3RDaHVua0ZpbGVuYW1lXFwkL2csIGN1cnJlbnRIb3RVcGRhdGVDaHVua0ZpbGVuYW1lKTtcclxuXHR9KTtcclxuXHRtYWluVGVtcGxhdGUucGx1Z2luKFwiaGFzaFwiLCBmdW5jdGlvbihoYXNoKSB7XHJcblx0XHRoYXNoLnVwZGF0ZShcIm5vZGVcIik7XHJcblx0XHRoYXNoLnVwZGF0ZShcIjNcIik7XHJcblx0XHRoYXNoLnVwZGF0ZSh0aGlzLm91dHB1dE9wdGlvbnMuZmlsZW5hbWUgKyBcIlwiKTtcclxuXHRcdGhhc2gudXBkYXRlKHRoaXMub3V0cHV0T3B0aW9ucy5jaHVua0ZpbGVuYW1lICsgXCJcIik7XHJcblx0fSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvbm9kZS9Ob2RlTWFpblRlbXBsYXRlUGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuLypnbG9iYWwgJGhvdENodW5rRmlsZW5hbWUkICRyZXF1aXJlJCBob3RBZGRVcGRhdGVDaHVuayAkaG90TWFpbkZpbGVuYW1lJCAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG5cdGZ1bmN0aW9uIGhvdERvd25sb2FkVXBkYXRlQ2h1bmsoY2h1bmtJZCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcblx0XHR2YXIgZmlsZW5hbWUgPSByZXF1aXJlKFwicGF0aFwiKS5qb2luKF9fZGlybmFtZSwgJGhvdENodW5rRmlsZW5hbWUkKTtcclxuXHRcdHJlcXVpcmUoXCJmc1wiKS5yZWFkRmlsZShmaWxlbmFtZSwgXCJ1dGYtOFwiLCBmdW5jdGlvbihlcnIsIGNvbnRlbnQpIHtcclxuXHRcdFx0aWYoZXJyKSB7XHJcblx0XHRcdFx0aWYoJHJlcXVpcmUkLm9uRXJyb3IpXHJcblx0XHRcdFx0XHRyZXR1cm4gJHJlcXVpcmUkLm9uRXJyb3IoZXJyKTtcclxuXHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHR0aHJvdyBlcnI7XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGNodW5rID0ge307XHJcblx0XHRcdHJlcXVpcmUoXCJ2bVwiKS5ydW5JblRoaXNDb250ZXh0KFwiKGZ1bmN0aW9uKGV4cG9ydHMpIHtcIiArIGNvbnRlbnQgKyBcIlxcbn0pXCIsIGZpbGVuYW1lKShjaHVuayk7XHJcblx0XHRcdGhvdEFkZFVwZGF0ZUNodW5rKGNodW5rLmlkLCBjaHVuay5tb2R1bGVzKTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaG90RG93bmxvYWRNYW5pZmVzdChjYWxsYmFjaykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcblx0XHR2YXIgZmlsZW5hbWUgPSByZXF1aXJlKFwicGF0aFwiKS5qb2luKF9fZGlybmFtZSwgJGhvdE1haW5GaWxlbmFtZSQpO1xyXG5cdFx0cmVxdWlyZShcImZzXCIpLnJlYWRGaWxlKGZpbGVuYW1lLCBcInV0Zi04XCIsIGZ1bmN0aW9uKGVyciwgY29udGVudCkge1xyXG5cdFx0XHRpZihlcnIpIHJldHVybiBjYWxsYmFjaygpO1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdHZhciB1cGRhdGUgPSBKU09OLnBhcnNlKGNvbnRlbnQpO1xyXG5cdFx0XHR9IGNhdGNoKGUpIHtcclxuXHRcdFx0XHRyZXR1cm4gY2FsbGJhY2soZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Y2FsbGJhY2sobnVsbCwgdXBkYXRlKTtcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9ub2RlL05vZGVNYWluVGVtcGxhdGVBc3luYy5ydW50aW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAyMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGluZGV4T2YgPSByZXF1aXJlKCdpbmRleG9mJyk7XG5cbnZhciBPYmplY3Rfa2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAoT2JqZWN0LmtleXMpIHJldHVybiBPYmplY3Qua2V5cyhvYmopXG4gICAgZWxzZSB7XG4gICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikgcmVzLnB1c2goa2V5KVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn07XG5cbnZhciBmb3JFYWNoID0gZnVuY3Rpb24gKHhzLCBmbikge1xuICAgIGlmICh4cy5mb3JFYWNoKSByZXR1cm4geHMuZm9yRWFjaChmbilcbiAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm4oeHNbaV0sIGksIHhzKTtcbiAgICB9XG59O1xuXG52YXIgZGVmaW5lUHJvcCA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdfJywge30pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbmFtZSwge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihvYmosIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICBvYmpbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG59KCkpO1xuXG52YXIgZ2xvYmFscyA9IFsnQXJyYXknLCAnQm9vbGVhbicsICdEYXRlJywgJ0Vycm9yJywgJ0V2YWxFcnJvcicsICdGdW5jdGlvbicsXG4nSW5maW5pdHknLCAnSlNPTicsICdNYXRoJywgJ05hTicsICdOdW1iZXInLCAnT2JqZWN0JywgJ1JhbmdlRXJyb3InLFxuJ1JlZmVyZW5jZUVycm9yJywgJ1JlZ0V4cCcsICdTdHJpbmcnLCAnU3ludGF4RXJyb3InLCAnVHlwZUVycm9yJywgJ1VSSUVycm9yJyxcbidkZWNvZGVVUkknLCAnZGVjb2RlVVJJQ29tcG9uZW50JywgJ2VuY29kZVVSSScsICdlbmNvZGVVUklDb21wb25lbnQnLCAnZXNjYXBlJyxcbidldmFsJywgJ2lzRmluaXRlJywgJ2lzTmFOJywgJ3BhcnNlRmxvYXQnLCAncGFyc2VJbnQnLCAndW5kZWZpbmVkJywgJ3VuZXNjYXBlJ107XG5cbmZ1bmN0aW9uIENvbnRleHQoKSB7fVxuQ29udGV4dC5wcm90b3R5cGUgPSB7fTtcblxudmFyIFNjcmlwdCA9IGV4cG9ydHMuU2NyaXB0ID0gZnVuY3Rpb24gTm9kZVNjcmlwdCAoY29kZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTY3JpcHQpKSByZXR1cm4gbmV3IFNjcmlwdChjb2RlKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xufTtcblxuU2NyaXB0LnByb3RvdHlwZS5ydW5JbkNvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIGlmICghKGNvbnRleHQgaW5zdGFuY2VvZiBDb250ZXh0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibmVlZHMgYSAnY29udGV4dCcgYXJndW1lbnQuXCIpO1xuICAgIH1cbiAgICBcbiAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgaWYgKCFpZnJhbWUuc3R5bGUpIGlmcmFtZS5zdHlsZSA9IHt9O1xuICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIFxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBcbiAgICB2YXIgd2luID0gaWZyYW1lLmNvbnRlbnRXaW5kb3c7XG4gICAgdmFyIHdFdmFsID0gd2luLmV2YWwsIHdFeGVjU2NyaXB0ID0gd2luLmV4ZWNTY3JpcHQ7XG5cbiAgICBpZiAoIXdFdmFsICYmIHdFeGVjU2NyaXB0KSB7XG4gICAgICAgIC8vIHdpbi5ldmFsKCkgbWFnaWNhbGx5IGFwcGVhcnMgd2hlbiB0aGlzIGlzIGNhbGxlZCBpbiBJRTpcbiAgICAgICAgd0V4ZWNTY3JpcHQuY2FsbCh3aW4sICdudWxsJyk7XG4gICAgICAgIHdFdmFsID0gd2luLmV2YWw7XG4gICAgfVxuICAgIFxuICAgIGZvckVhY2goT2JqZWN0X2tleXMoY29udGV4dCksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgd2luW2tleV0gPSBjb250ZXh0W2tleV07XG4gICAgfSk7XG4gICAgZm9yRWFjaChnbG9iYWxzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChjb250ZXh0W2tleV0pIHtcbiAgICAgICAgICAgIHdpbltrZXldID0gY29udGV4dFtrZXldO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgdmFyIHdpbktleXMgPSBPYmplY3Rfa2V5cyh3aW4pO1xuXG4gICAgdmFyIHJlcyA9IHdFdmFsLmNhbGwod2luLCB0aGlzLmNvZGUpO1xuICAgIFxuICAgIGZvckVhY2goT2JqZWN0X2tleXMod2luKSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAvLyBBdm9pZCBjb3B5aW5nIGNpcmN1bGFyIG9iamVjdHMgbGlrZSBgdG9wYCBhbmQgYHdpbmRvd2AgYnkgb25seVxuICAgICAgICAvLyB1cGRhdGluZyBleGlzdGluZyBjb250ZXh0IHByb3BlcnRpZXMgb3IgbmV3IHByb3BlcnRpZXMgaW4gdGhlIGB3aW5gXG4gICAgICAgIC8vIHRoYXQgd2FzIG9ubHkgaW50cm9kdWNlZCBhZnRlciB0aGUgZXZhbC5cbiAgICAgICAgaWYgKGtleSBpbiBjb250ZXh0IHx8IGluZGV4T2Yod2luS2V5cywga2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnRleHRba2V5XSA9IHdpbltrZXldO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmb3JFYWNoKGdsb2JhbHMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIGNvbnRleHQpKSB7XG4gICAgICAgICAgICBkZWZpbmVQcm9wKGNvbnRleHQsIGtleSwgd2luW2tleV0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgIFxuICAgIHJldHVybiByZXM7XG59O1xuXG5TY3JpcHQucHJvdG90eXBlLnJ1bkluVGhpc0NvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGV2YWwodGhpcy5jb2RlKTsgLy8gbWF5YmUuLi5cbn07XG5cblNjcmlwdC5wcm90b3R5cGUucnVuSW5OZXdDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgY3R4ID0gU2NyaXB0LmNyZWF0ZUNvbnRleHQoY29udGV4dCk7XG4gICAgdmFyIHJlcyA9IHRoaXMucnVuSW5Db250ZXh0KGN0eCk7XG5cbiAgICBmb3JFYWNoKE9iamVjdF9rZXlzKGN0eCksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgY29udGV4dFtrZXldID0gY3R4W2tleV07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzO1xufTtcblxuZm9yRWFjaChPYmplY3Rfa2V5cyhTY3JpcHQucHJvdG90eXBlKSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBleHBvcnRzW25hbWVdID0gU2NyaXB0W25hbWVdID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgdmFyIHMgPSBTY3JpcHQoY29kZSk7XG4gICAgICAgIHJldHVybiBzW25hbWVdLmFwcGx5KHMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgfTtcbn0pO1xuXG5leHBvcnRzLmNyZWF0ZVNjcmlwdCA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuU2NyaXB0KGNvZGUpO1xufTtcblxuZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gU2NyaXB0LmNyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBjb3B5ID0gbmV3IENvbnRleHQoKTtcbiAgICBpZih0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yRWFjaChPYmplY3Rfa2V5cyhjb250ZXh0KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgY29weVtrZXldID0gY29udGV4dFtrZXldO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ZtLWJyb3dzZXJpZnkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbnZhciBpbmRleE9mID0gW10uaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChpbmRleE9mKSByZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2luZGV4b2YvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG4vKmdsb2JhbCAkaG90Q2h1bmtGaWxlbmFtZSQgaG90QWRkVXBkYXRlQ2h1bmsgJGhvdE1haW5GaWxlbmFtZSQgKi9cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuXHRmdW5jdGlvbiBob3REb3dubG9hZFVwZGF0ZUNodW5rKGNodW5rSWQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG5cdFx0dmFyIGNodW5rID0gcmVxdWlyZShcIi4vXCIgKyAkaG90Q2h1bmtGaWxlbmFtZSQpO1xyXG5cdFx0aG90QWRkVXBkYXRlQ2h1bmsoY2h1bmsuaWQsIGNodW5rLm1vZHVsZXMpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaG90RG93bmxvYWRNYW5pZmVzdChjYWxsYmFjaykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcblx0XHR0cnkge1xyXG5cdFx0XHR2YXIgdXBkYXRlID0gcmVxdWlyZShcIi4vXCIgKyAkaG90TWFpbkZpbGVuYW1lJCk7XHJcblx0XHR9IGNhdGNoKGUpIHtcclxuXHRcdFx0cmV0dXJuIGNhbGxiYWNrKCk7XHJcblx0XHR9XHJcblx0XHRjYWxsYmFjayhudWxsLCB1cGRhdGUpO1xyXG5cdH1cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9ub2RlL05vZGVNYWluVGVtcGxhdGUucnVudGltZS5qc1xuLy8gbW9kdWxlIGlkID0gMjA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBtYXAgPSB7XG5cdFwiLi9Ob2RlQ2h1bmtUZW1wbGF0ZVBsdWdpblwiOiAyMTAsXG5cdFwiLi9Ob2RlQ2h1bmtUZW1wbGF0ZVBsdWdpbi5qc1wiOiAyMTAsXG5cdFwiLi9Ob2RlRW52aXJvbm1lbnRQbHVnaW5cIjogMjExLFxuXHRcIi4vTm9kZUVudmlyb25tZW50UGx1Z2luLmpzXCI6IDIxMSxcblx0XCIuL05vZGVIb3RVcGRhdGVDaHVua1RlbXBsYXRlUGx1Z2luXCI6IDMwMixcblx0XCIuL05vZGVIb3RVcGRhdGVDaHVua1RlbXBsYXRlUGx1Z2luLmpzXCI6IDMwMixcblx0XCIuL05vZGVNYWluVGVtcGxhdGUucnVudGltZVwiOiAyMDgsXG5cdFwiLi9Ob2RlTWFpblRlbXBsYXRlLnJ1bnRpbWUuanNcIjogMjA4LFxuXHRcIi4vTm9kZU1haW5UZW1wbGF0ZUFzeW5jLnJ1bnRpbWVcIjogMjA1LFxuXHRcIi4vTm9kZU1haW5UZW1wbGF0ZUFzeW5jLnJ1bnRpbWUuanNcIjogMjA1LFxuXHRcIi4vTm9kZU1haW5UZW1wbGF0ZVBsdWdpblwiOiAyMDQsXG5cdFwiLi9Ob2RlTWFpblRlbXBsYXRlUGx1Z2luLmpzXCI6IDIwNCxcblx0XCIuL05vZGVPdXRwdXRGaWxlU3lzdGVtXCI6IDI5OCxcblx0XCIuL05vZGVPdXRwdXRGaWxlU3lzdGVtLmpzXCI6IDI5OCxcblx0XCIuL05vZGVTb3VyY2VQbHVnaW5cIjogMTg4LFxuXHRcIi4vTm9kZVNvdXJjZVBsdWdpbi5qc1wiOiAxODgsXG5cdFwiLi9Ob2RlVGFyZ2V0UGx1Z2luXCI6IDMwMyxcblx0XCIuL05vZGVUYXJnZXRQbHVnaW4uanNcIjogMzAzLFxuXHRcIi4vTm9kZVRlbXBsYXRlUGx1Z2luXCI6IDIwMyxcblx0XCIuL05vZGVUZW1wbGF0ZVBsdWdpbi5qc1wiOiAyMDMsXG5cdFwiLi9Ob2RlV2F0Y2hGaWxlU3lzdGVtXCI6IDIxMixcblx0XCIuL05vZGVXYXRjaEZpbGVTeXN0ZW0uanNcIjogMjEyLFxuXHRcIi4vT2xkTm9kZVdhdGNoRmlsZVN5c3RlbVwiOiAzMDcsXG5cdFwiLi9PbGROb2RlV2F0Y2hGaWxlU3lzdGVtLmpzXCI6IDMwN1xufTtcbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0KHJlcSkge1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyh3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSk7XG59O1xuZnVuY3Rpb24gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkge1xuXHRyZXR1cm4gbWFwW3JlcV0gfHwgKGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInLlwiKSB9KCkpO1xufTtcbndlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dEtleXMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcbndlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xud2VicGFja0NvbnRleHQuaWQgPSAyMDk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL25vZGUgXlxcLlxcLy4qJFxuLy8gbW9kdWxlIGlkID0gMjA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBDb25jYXRTb3VyY2UgPSByZXF1aXJlKFwid2VicGFjay1jb3JlL2xpYi9Db25jYXRTb3VyY2VcIik7XHJcblxyXG5mdW5jdGlvbiBOb2RlQ2h1bmtUZW1wbGF0ZVBsdWdpbigpIHt9XHJcbm1vZHVsZS5leHBvcnRzID0gTm9kZUNodW5rVGVtcGxhdGVQbHVnaW47XHJcblxyXG5Ob2RlQ2h1bmtUZW1wbGF0ZVBsdWdpbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbihjaHVua1RlbXBsYXRlKSB7XHJcblx0Y2h1bmtUZW1wbGF0ZS5wbHVnaW4oXCJyZW5kZXJcIiwgZnVuY3Rpb24obW9kdWxlcywgY2h1bmspIHtcclxuXHRcdHZhciBzb3VyY2UgPSBuZXcgQ29uY2F0U291cmNlKCk7XHJcblx0XHRzb3VyY2UuYWRkKFwiZXhwb3J0cy5pZHMgPSBcIiArIEpTT04uc3RyaW5naWZ5KGNodW5rLmlkcykgKyBcIjtcXG5leHBvcnRzLm1vZHVsZXMgPSBcIik7XHJcblx0XHRzb3VyY2UuYWRkKG1vZHVsZXMpO1xyXG5cdFx0c291cmNlLmFkZChcIjtcIik7XHJcblx0XHRyZXR1cm4gc291cmNlO1xyXG5cdH0pO1xyXG5cdGNodW5rVGVtcGxhdGUucGx1Z2luKFwiaGFzaFwiLCBmdW5jdGlvbihoYXNoKSB7XHJcblx0XHRoYXNoLnVwZGF0ZShcIm5vZGVcIik7XHJcblx0XHRoYXNoLnVwZGF0ZShcIjNcIik7XHJcblx0fSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvbm9kZS9Ob2RlQ2h1bmtUZW1wbGF0ZVBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMjEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBOb2RlV2F0Y2hGaWxlU3lzdGVtID0gcmVxdWlyZShcIi4vTm9kZVdhdGNoRmlsZVN5c3RlbVwiKTtcclxudmFyIE5vZGVPdXRwdXRGaWxlU3lzdGVtID0gcmVxdWlyZShcIi4vTm9kZU91dHB1dEZpbGVTeXN0ZW1cIik7XHJcbnZhciBOb2RlSnNJbnB1dEZpbGVTeXN0ZW0gPSByZXF1aXJlKFwiZW5oYW5jZWQtcmVzb2x2ZS9saWIvTm9kZUpzSW5wdXRGaWxlU3lzdGVtXCIpO1xyXG52YXIgQ2FjaGVkSW5wdXRGaWxlU3lzdGVtID0gcmVxdWlyZShcImVuaGFuY2VkLXJlc29sdmUvbGliL0NhY2hlZElucHV0RmlsZVN5c3RlbVwiKTtcclxuXHJcbmZ1bmN0aW9uIE5vZGVFbnZpcm9ubWVudFBsdWdpbigpIHt9XHJcbm1vZHVsZS5leHBvcnRzID0gTm9kZUVudmlyb25tZW50UGx1Z2luO1xyXG5Ob2RlRW52aXJvbm1lbnRQbHVnaW4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oY29tcGlsZXIpIHtcclxuXHRjb21waWxlci5pbnB1dEZpbGVTeXN0ZW0gPSBuZXcgTm9kZUpzSW5wdXRGaWxlU3lzdGVtKCk7XHJcblx0dmFyIGlucHV0RmlsZVN5c3RlbSA9IGNvbXBpbGVyLmlucHV0RmlsZVN5c3RlbSA9IG5ldyBDYWNoZWRJbnB1dEZpbGVTeXN0ZW0oY29tcGlsZXIuaW5wdXRGaWxlU3lzdGVtLCA2MDAwMCk7XHJcblx0Y29tcGlsZXIucmVzb2x2ZXJzLm5vcm1hbC5maWxlU3lzdGVtID0gY29tcGlsZXIuaW5wdXRGaWxlU3lzdGVtO1xyXG5cdGNvbXBpbGVyLnJlc29sdmVycy5jb250ZXh0LmZpbGVTeXN0ZW0gPSBjb21waWxlci5pbnB1dEZpbGVTeXN0ZW07XHJcblx0Y29tcGlsZXIucmVzb2x2ZXJzLmxvYWRlci5maWxlU3lzdGVtID0gY29tcGlsZXIuaW5wdXRGaWxlU3lzdGVtO1xyXG5cdGNvbXBpbGVyLm91dHB1dEZpbGVTeXN0ZW0gPSBuZXcgTm9kZU91dHB1dEZpbGVTeXN0ZW0oKTtcclxuXHRjb21waWxlci53YXRjaEZpbGVTeXN0ZW0gPSBuZXcgTm9kZVdhdGNoRmlsZVN5c3RlbShjb21waWxlci5pbnB1dEZpbGVTeXN0ZW0pO1xyXG5cdGNvbXBpbGVyLnBsdWdpbihcInJ1blwiLCBmdW5jdGlvbihjb21waWxlciwgY2FsbGJhY2spIHtcclxuXHRcdGlmKGNvbXBpbGVyLmlucHV0RmlsZVN5c3RlbSA9PT0gaW5wdXRGaWxlU3lzdGVtKVxyXG5cdFx0XHRpbnB1dEZpbGVTeXN0ZW0ucHVyZ2UoKTtcclxuXHRcdGNhbGxiYWNrKCk7XHJcblx0fSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvbm9kZS9Ob2RlRW52aXJvbm1lbnRQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDIxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgV2F0Y2hwYWNrID0gcmVxdWlyZShcIndhdGNocGFja1wiKTtcclxuXHJcbmZ1bmN0aW9uIE5vZGVXYXRjaEZpbGVTeXN0ZW0oaW5wdXRGaWxlU3lzdGVtKSB7XHJcblx0dGhpcy5pbnB1dEZpbGVTeXN0ZW0gPSBpbnB1dEZpbGVTeXN0ZW07XHJcblx0dGhpcy53YXRjaGVyT3B0aW9ucyA9IHtcclxuXHRcdGFnZ3JlZ2F0ZVRpbWVvdXQ6IDBcclxuXHR9O1xyXG5cdHRoaXMud2F0Y2hlciA9IG5ldyBXYXRjaHBhY2sodGhpcy53YXRjaGVyT3B0aW9ucyk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gTm9kZVdhdGNoRmlsZVN5c3RlbTtcclxuXHJcbk5vZGVXYXRjaEZpbGVTeXN0ZW0ucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24gd2F0Y2goZmlsZXMsIGRpcnMsIG1pc3NpbmcsIHN0YXJ0VGltZSwgb3B0aW9ucywgY2FsbGJhY2ssIGNhbGxiYWNrVW5kZWxheWVkKSB7XHJcblx0aWYoIUFycmF5LmlzQXJyYXkoZmlsZXMpKVxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudHM6ICdmaWxlcydcIik7XHJcblx0aWYoIUFycmF5LmlzQXJyYXkoZGlycykpXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50czogJ2RpcnMnXCIpO1xyXG5cdGlmKCFBcnJheS5pc0FycmF5KG1pc3NpbmcpKVxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudHM6ICdtaXNzaW5nJ1wiKTtcclxuXHRpZih0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIilcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnRzOiAnY2FsbGJhY2snXCIpO1xyXG5cdGlmKHR5cGVvZiBzdGFydFRpbWUgIT09IFwibnVtYmVyXCIgJiYgc3RhcnRUaW1lKVxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudHM6ICdzdGFydFRpbWUnXCIpO1xyXG5cdGlmKHR5cGVvZiBvcHRpb25zICE9PSBcIm9iamVjdFwiKVxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudHM6ICdvcHRpb25zJ1wiKTtcclxuXHRpZih0eXBlb2YgY2FsbGJhY2tVbmRlbGF5ZWQgIT09IFwiZnVuY3Rpb25cIiAmJiBjYWxsYmFja1VuZGVsYXllZClcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXJndW1lbnRzOiAnY2FsbGJhY2tVbmRlbGF5ZWQnXCIpO1xyXG5cdHZhciBvbGRXYXRjaGVyID0gdGhpcy53YXRjaGVyO1xyXG5cdHRoaXMud2F0Y2hlciA9IG5ldyBXYXRjaHBhY2sob3B0aW9ucyk7XHJcblxyXG5cdGlmKGNhbGxiYWNrVW5kZWxheWVkKVxyXG5cdFx0dGhpcy53YXRjaGVyLm9uY2UoXCJjaGFuZ2VcIiwgY2FsbGJhY2tVbmRlbGF5ZWQpO1xyXG5cclxuXHR0aGlzLndhdGNoZXIub25jZShcImFnZ3JlZ2F0ZWRcIiwgZnVuY3Rpb24oY2hhbmdlcykge1xyXG5cdFx0aWYodGhpcy5pbnB1dEZpbGVTeXN0ZW0gJiYgdGhpcy5pbnB1dEZpbGVTeXN0ZW0ucHVyZ2UpIHtcclxuXHRcdFx0dGhpcy5pbnB1dEZpbGVTeXN0ZW0ucHVyZ2UoY2hhbmdlcyk7XHJcblx0XHR9XHJcblx0XHR2YXIgdGltZXMgPSB0aGlzLndhdGNoZXIuZ2V0VGltZXMoKTtcclxuXHRcdGNhbGxiYWNrKG51bGwsIGNoYW5nZXMuZmlsdGVyKGZ1bmN0aW9uKGZpbGUpIHtcclxuXHRcdFx0cmV0dXJuIGZpbGVzLmluZGV4T2YoZmlsZSkgPj0gMDtcclxuXHRcdH0pLnNvcnQoKSwgY2hhbmdlcy5maWx0ZXIoZnVuY3Rpb24oZmlsZSkge1xyXG5cdFx0XHRyZXR1cm4gZGlycy5pbmRleE9mKGZpbGUpID49IDA7XHJcblx0XHR9KS5zb3J0KCksIGNoYW5nZXMuZmlsdGVyKGZ1bmN0aW9uKGZpbGUpIHtcclxuXHRcdFx0cmV0dXJuIG1pc3NpbmcuaW5kZXhPZihmaWxlKSA+PSAwO1xyXG5cdFx0fSkuc29ydCgpLCB0aW1lcywgdGltZXMpO1xyXG5cdH0uYmluZCh0aGlzKSk7XHJcblxyXG5cdHRoaXMud2F0Y2hlci53YXRjaChmaWxlcy5jb25jYXQobWlzc2luZyksIGRpcnMsIHN0YXJ0VGltZSk7XHJcblxyXG5cdGlmKG9sZFdhdGNoZXIpIHtcclxuXHRcdG9sZFdhdGNoZXIuY2xvc2UoKTtcclxuXHR9XHJcblx0cmV0dXJuIHtcclxuXHRcdGNsb3NlOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0dGhpcy53YXRjaGVyLmNsb3NlKCk7XHJcblx0XHR9LmJpbmQodGhpcyksXHJcblx0XHRwYXVzZTogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHRoaXMud2F0Y2hlci5wYXVzZSgpO1xyXG5cdFx0fS5iaW5kKHRoaXMpXHJcblx0fTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9ub2RlL05vZGVXYXRjaEZpbGVTeXN0ZW0uanNcbi8vIG1vZHVsZSBpZCA9IDIxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgd2F0Y2hlck1hbmFnZXIgPSByZXF1aXJlKFwiLi93YXRjaGVyTWFuYWdlclwiKTtcclxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJldmVudHNcIikuRXZlbnRFbWl0dGVyO1xyXG5cclxuZnVuY3Rpb24gV2F0Y2hwYWNrKG9wdGlvbnMpIHtcclxuXHRFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcclxuXHRpZighb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xyXG5cdGlmKCFvcHRpb25zLmFnZ3JlZ2F0ZVRpbWVvdXQpIG9wdGlvbnMuYWdncmVnYXRlVGltZW91dCA9IDIwMDtcclxuXHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG5cdHRoaXMud2F0Y2hlck9wdGlvbnMgPSB7XHJcblx0XHRwb2xsOiBvcHRpb25zLnBvbGxcclxuXHR9O1xyXG5cdHRoaXMuZmlsZVdhdGNoZXJzID0gW107XHJcblx0dGhpcy5kaXJXYXRjaGVycyA9IFtdO1xyXG5cdHRoaXMubXRpbWVzID0ge307XHJcblx0dGhpcy5wYXVzZWQgPSBmYWxzZTtcclxuXHR0aGlzLmFnZ3JlZ2F0ZWRDaGFuZ2VzID0gW107XHJcblx0dGhpcy5hZ2dyZWdhdGVUaW1lb3V0ID0gMDtcclxuXHR0aGlzLl9vblRpbWVvdXQgPSB0aGlzLl9vblRpbWVvdXQuYmluZCh0aGlzKTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBXYXRjaHBhY2s7XHJcblxyXG5XYXRjaHBhY2sucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcclxuXHJcbldhdGNocGFjay5wcm90b3R5cGUud2F0Y2ggPSBmdW5jdGlvbiB3YXRjaChmaWxlcywgZGlyZWN0b3JpZXMsIHN0YXJ0VGltZSkge1xyXG5cdHRoaXMucGF1c2VkID0gZmFsc2U7XHJcblx0dmFyIG9sZEZpbGVXYXRjaGVycyA9IHRoaXMuZmlsZVdhdGNoZXJzO1xyXG5cdHZhciBvbGREaXJXYXRjaGVycyA9IHRoaXMuZGlyV2F0Y2hlcnM7XHJcblx0dGhpcy5maWxlV2F0Y2hlcnMgPSBmaWxlcy5tYXAoZnVuY3Rpb24oZmlsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2ZpbGVXYXRjaGVyKGZpbGUsIHdhdGNoZXJNYW5hZ2VyLndhdGNoRmlsZShmaWxlLCB0aGlzLndhdGNoZXJPcHRpb25zLCBzdGFydFRpbWUpKTtcclxuXHR9LCB0aGlzKTtcclxuXHR0aGlzLmRpcldhdGNoZXJzID0gZGlyZWN0b3JpZXMubWFwKGZ1bmN0aW9uKGRpcikge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2RpcldhdGNoZXIoZGlyLCB3YXRjaGVyTWFuYWdlci53YXRjaERpcmVjdG9yeShkaXIsIHRoaXMud2F0Y2hlck9wdGlvbnMsIHN0YXJ0VGltZSkpO1xyXG5cdH0sIHRoaXMpO1xyXG5cdG9sZEZpbGVXYXRjaGVycy5mb3JFYWNoKGZ1bmN0aW9uKHcpIHtcclxuXHRcdHcuY2xvc2UoKTtcclxuXHR9LCB0aGlzKTtcclxuXHRvbGREaXJXYXRjaGVycy5mb3JFYWNoKGZ1bmN0aW9uKHcpIHtcclxuXHRcdHcuY2xvc2UoKTtcclxuXHR9LCB0aGlzKTtcclxufTtcclxuXHJcbldhdGNocGFjay5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiByZXN1bWUoKSB7XHJcblx0dGhpcy5wYXVzZWQgPSB0cnVlO1xyXG5cdGlmKHRoaXMuYWdncmVnYXRlVGltZW91dClcclxuXHRcdGNsZWFyVGltZW91dCh0aGlzLmFnZ3JlZ2F0ZVRpbWVvdXQpO1xyXG5cdHRoaXMuZmlsZVdhdGNoZXJzLmZvckVhY2goZnVuY3Rpb24odykge1xyXG5cdFx0dy5jbG9zZSgpO1xyXG5cdH0sIHRoaXMpO1xyXG5cdHRoaXMuZGlyV2F0Y2hlcnMuZm9yRWFjaChmdW5jdGlvbih3KSB7XHJcblx0XHR3LmNsb3NlKCk7XHJcblx0fSwgdGhpcyk7XHJcblx0dGhpcy5maWxlV2F0Y2hlcnMubGVuZ3RoID0gMDtcclxuXHR0aGlzLmRpcldhdGNoZXJzLmxlbmd0aCA9IDA7XHJcbn07XHJcblxyXG5XYXRjaHBhY2sucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gcGF1c2UoKSB7XHJcblx0dGhpcy5wYXVzZWQgPSB0cnVlO1xyXG5cdGlmKHRoaXMuYWdncmVnYXRlVGltZW91dClcclxuXHRcdGNsZWFyVGltZW91dCh0aGlzLmFnZ3JlZ2F0ZVRpbWVvdXQpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gYWRkV2F0Y2hlcnNUb0FycmF5KHdhdGNoZXJzLCBhcnJheSkge1xyXG5cdHdhdGNoZXJzLmZvckVhY2goZnVuY3Rpb24odykge1xyXG5cdFx0aWYoYXJyYXkuaW5kZXhPZih3LmRpcmVjdG9yeVdhdGNoZXIpIDwgMCkge1xyXG5cdFx0XHRhcnJheS5wdXNoKHcuZGlyZWN0b3J5V2F0Y2hlcik7XHJcblx0XHRcdGFkZFdhdGNoZXJzVG9BcnJheShPYmplY3Qua2V5cyh3LmRpcmVjdG9yeVdhdGNoZXIuZGlyZWN0b3JpZXMpLnJlZHVjZShmdW5jdGlvbihhLCBkaXIpIHtcclxuXHRcdFx0XHRpZih3LmRpcmVjdG9yeVdhdGNoZXIuZGlyZWN0b3JpZXNbZGlyXSAhPT0gdHJ1ZSlcclxuXHRcdFx0XHRcdGEucHVzaCh3LmRpcmVjdG9yeVdhdGNoZXIuZGlyZWN0b3JpZXNbZGlyXSk7XHJcblx0XHRcdFx0cmV0dXJuIGE7XHJcblx0XHRcdH0sIFtdKSwgYXJyYXkpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG59XHJcblxyXG5XYXRjaHBhY2sucHJvdG90eXBlLmdldFRpbWVzID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGRpcmVjdG9yeVdhdGNoZXJzID0gW107XHJcblx0YWRkV2F0Y2hlcnNUb0FycmF5KHRoaXMuZmlsZVdhdGNoZXJzLmNvbmNhdCh0aGlzLmRpcldhdGNoZXJzKSwgZGlyZWN0b3J5V2F0Y2hlcnMpO1xyXG5cdHZhciBvYmogPSB7fTtcclxuXHRkaXJlY3RvcnlXYXRjaGVycy5mb3JFYWNoKGZ1bmN0aW9uKHcpIHtcclxuXHRcdHZhciB0aW1lcyA9IHcuZ2V0VGltZXMoKTtcclxuXHRcdE9iamVjdC5rZXlzKHRpbWVzKS5mb3JFYWNoKGZ1bmN0aW9uKGZpbGUpIHtcclxuXHRcdFx0b2JqW2ZpbGVdID0gdGltZXNbZmlsZV07XHJcblx0XHR9KTtcclxuXHR9KTtcclxuXHRyZXR1cm4gb2JqO1xyXG59O1xyXG5cclxuV2F0Y2hwYWNrLnByb3RvdHlwZS5fZmlsZVdhdGNoZXIgPSBmdW5jdGlvbiBfZmlsZVdhdGNoZXIoZmlsZSwgd2F0Y2hlcikge1xyXG5cdHdhdGNoZXIub24oXCJjaGFuZ2VcIiwgdGhpcy5fb25DaGFuZ2UuYmluZCh0aGlzLCBmaWxlKSk7XHJcblx0cmV0dXJuIHdhdGNoZXI7XHJcbn07XHJcblxyXG5XYXRjaHBhY2sucHJvdG90eXBlLl9kaXJXYXRjaGVyID0gZnVuY3Rpb24gX2RpcldhdGNoZXIoaXRlbSwgd2F0Y2hlcikge1xyXG5cdHdhdGNoZXIub24oXCJjaGFuZ2VcIiwgZnVuY3Rpb24oZmlsZSwgbXRpbWUpIHtcclxuXHRcdHRoaXMuX29uQ2hhbmdlKGl0ZW0sIG10aW1lLCBmaWxlKTtcclxuXHR9LmJpbmQodGhpcykpO1xyXG5cdHJldHVybiB3YXRjaGVyO1xyXG59O1xyXG5cclxuV2F0Y2hwYWNrLnByb3RvdHlwZS5fb25DaGFuZ2UgPSBmdW5jdGlvbiBfb25DaGFuZ2UoaXRlbSwgbXRpbWUsIGZpbGUpIHtcclxuXHRmaWxlID0gZmlsZSB8fCBpdGVtO1xyXG5cdHRoaXMubXRpbWVzW2ZpbGVdID0gbXRpbWU7XHJcblx0aWYodGhpcy5wYXVzZWQpIHJldHVybjtcclxuXHR0aGlzLmVtaXQoXCJjaGFuZ2VcIiwgZmlsZSwgbXRpbWUpO1xyXG5cdGlmKHRoaXMuYWdncmVnYXRlVGltZW91dClcclxuXHRcdGNsZWFyVGltZW91dCh0aGlzLmFnZ3JlZ2F0ZVRpbWVvdXQpO1xyXG5cdGlmKHRoaXMuYWdncmVnYXRlZENoYW5nZXMuaW5kZXhPZihpdGVtKSA8IDApXHJcblx0XHR0aGlzLmFnZ3JlZ2F0ZWRDaGFuZ2VzLnB1c2goaXRlbSk7XHJcblx0dGhpcy5hZ2dyZWdhdGVUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLl9vblRpbWVvdXQsIHRoaXMub3B0aW9ucy5hZ2dyZWdhdGVUaW1lb3V0KTtcclxufTtcclxuXHJcbldhdGNocGFjay5wcm90b3R5cGUuX29uVGltZW91dCA9IGZ1bmN0aW9uIF9vblRpbWVvdXQoKSB7XHJcblx0dGhpcy5hZ2dyZWdhdGVUaW1lb3V0ID0gMDtcclxuXHR2YXIgY2hhbmdlcyA9IHRoaXMuYWdncmVnYXRlZENoYW5nZXM7XHJcblx0dGhpcy5hZ2dyZWdhdGVkQ2hhbmdlcyA9IFtdO1xyXG5cdHRoaXMuZW1pdChcImFnZ3JlZ2F0ZWRcIiwgY2hhbmdlcyk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi93YXRjaHBhY2svbGliL3dhdGNocGFjay5qc1xuLy8gbW9kdWxlIGlkID0gMjEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcblxyXG5mdW5jdGlvbiBXYXRjaGVyTWFuYWdlcigpIHtcclxuXHR0aGlzLmRpcmVjdG9yeVdhdGNoZXJzID0ge307XHJcbn1cclxuXHJcbldhdGNoZXJNYW5hZ2VyLnByb3RvdHlwZS5nZXREaXJlY3RvcnlXYXRjaGVyID0gZnVuY3Rpb24oZGlyZWN0b3J5LCBvcHRpb25zKSB7XHJcblx0dmFyIERpcmVjdG9yeVdhdGNoZXIgPSByZXF1aXJlKFwiLi9EaXJlY3RvcnlXYXRjaGVyXCIpO1xyXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdHZhciBrZXkgPSBkaXJlY3RvcnkgKyBcIiBcIiArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpO1xyXG5cdGlmKCF0aGlzLmRpcmVjdG9yeVdhdGNoZXJzW2tleV0pIHtcclxuXHRcdHRoaXMuZGlyZWN0b3J5V2F0Y2hlcnNba2V5XSA9IG5ldyBEaXJlY3RvcnlXYXRjaGVyKGRpcmVjdG9yeSwgb3B0aW9ucyk7XHJcblx0XHR0aGlzLmRpcmVjdG9yeVdhdGNoZXJzW2tleV0ub24oXCJjbG9zZWRcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLmRpcmVjdG9yeVdhdGNoZXJzW2tleV07XHJcblx0XHR9LmJpbmQodGhpcykpO1xyXG5cdH1cclxuXHRyZXR1cm4gdGhpcy5kaXJlY3RvcnlXYXRjaGVyc1trZXldO1xyXG59O1xyXG5cclxuV2F0Y2hlck1hbmFnZXIucHJvdG90eXBlLndhdGNoRmlsZSA9IGZ1bmN0aW9uIHdhdGNoRmlsZShwLCBvcHRpb25zLCBzdGFydFRpbWUpIHtcclxuXHR2YXIgZGlyZWN0b3J5ID0gcGF0aC5kaXJuYW1lKHApO1xyXG5cdHJldHVybiB0aGlzLmdldERpcmVjdG9yeVdhdGNoZXIoZGlyZWN0b3J5LCBvcHRpb25zKS53YXRjaChwLCBzdGFydFRpbWUpO1xyXG59O1xyXG5cclxuV2F0Y2hlck1hbmFnZXIucHJvdG90eXBlLndhdGNoRGlyZWN0b3J5ID0gZnVuY3Rpb24gd2F0Y2hEaXJlY3RvcnkoZGlyZWN0b3J5LCBvcHRpb25zLCBzdGFydFRpbWUpIHtcclxuXHRyZXR1cm4gdGhpcy5nZXREaXJlY3RvcnlXYXRjaGVyKGRpcmVjdG9yeSwgb3B0aW9ucykud2F0Y2goZGlyZWN0b3J5LCBzdGFydFRpbWUpO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBuZXcgV2F0Y2hlck1hbmFnZXIoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3dhdGNocGFjay9saWIvd2F0Y2hlck1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcImV2ZW50c1wiKS5FdmVudEVtaXR0ZXI7XHJcbnZhciBhc3luYyA9IHJlcXVpcmUoXCJhc3luY1wiKTtcclxudmFyIGNob2tpZGFyID0gcmVxdWlyZShcImNob2tpZGFyXCIpO1xyXG52YXIgZnMgPSByZXF1aXJlKFwiZ3JhY2VmdWwtZnNcIik7XHJcbnZhciBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcblxyXG52YXIgd2F0Y2hlck1hbmFnZXIgPSByZXF1aXJlKFwiLi93YXRjaGVyTWFuYWdlclwiKTtcclxuXHJcbnZhciBGU19BQ0NVUkVOQ1kgPSAxMDAwMDtcclxuXHJcblxyXG5mdW5jdGlvbiB3aXRob3V0Q2FzZShzdHIpIHtcclxuXHRyZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBXYXRjaGVyKGRpcmVjdG9yeVdhdGNoZXIsIGZpbGVQYXRoLCBzdGFydFRpbWUpIHtcclxuXHRFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcclxuXHR0aGlzLmRpcmVjdG9yeVdhdGNoZXIgPSBkaXJlY3RvcnlXYXRjaGVyO1xyXG5cdHRoaXMucGF0aCA9IGZpbGVQYXRoO1xyXG5cdHRoaXMuc3RhcnRUaW1lID0gc3RhcnRUaW1lICYmICtzdGFydFRpbWU7XHJcblx0dGhpcy5kYXRhID0gMDtcclxufVxyXG5cclxuV2F0Y2hlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xyXG5XYXRjaGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFdhdGNoZXI7XHJcblxyXG5XYXRjaGVyLnByb3RvdHlwZS5jaGVja1N0YXJ0VGltZSA9IGZ1bmN0aW9uIGNoZWNrU3RhcnRUaW1lKG10aW1lLCBpbml0aWFsKSB7XHJcblx0aWYodHlwZW9mIHRoaXMuc3RhcnRUaW1lICE9PSBcIm51bWJlclwiKSByZXR1cm4gIWluaXRpYWw7XHJcblx0dmFyIHN0YXJ0VGltZSA9IHRoaXMuc3RhcnRUaW1lICYmIE1hdGguZmxvb3IodGhpcy5zdGFydFRpbWUgLyBGU19BQ0NVUkVOQ1kpICogRlNfQUNDVVJFTkNZO1xyXG5cdHJldHVybiBzdGFydFRpbWUgPD0gbXRpbWU7XHJcbn07XHJcblxyXG5XYXRjaGVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKCkge1xyXG5cdHRoaXMuZW1pdChcImNsb3NlZFwiKTtcclxufTtcclxuXHJcblxyXG5mdW5jdGlvbiBEaXJlY3RvcnlXYXRjaGVyKGRpcmVjdG9yeVBhdGgsIG9wdGlvbnMpIHtcclxuXHRFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcclxuXHR0aGlzLnBhdGggPSBkaXJlY3RvcnlQYXRoO1xyXG5cdHRoaXMuZmlsZXMgPSB7fTtcclxuXHR0aGlzLmRpcmVjdG9yaWVzID0ge307XHJcblx0dGhpcy53YXRjaGVyID0gY2hva2lkYXIud2F0Y2goZGlyZWN0b3J5UGF0aCwge1xyXG5cdFx0aWdub3JlSW5pdGlhbDogdHJ1ZSxcclxuXHRcdHBlcnNpc3RlbnQ6IHRydWUsXHJcblx0XHRmb2xsb3dTeW1saW5rczogZmFsc2UsXHJcblx0XHRkZXB0aDogMCxcclxuXHRcdGF0b21pYzogZmFsc2UsXHJcblx0XHRhbHdheXNTdGF0OiB0cnVlLFxyXG5cdFx0aWdub3JlUGVybWlzc2lvbkVycm9yczogdHJ1ZSxcclxuXHRcdHVzZVBvbGxpbmc6IG9wdGlvbnMucG9sbCA/IHRydWUgOiB1bmRlZmluZWQsXHJcblx0XHRpbnRlcnZhbDogdHlwZW9mIG9wdGlvbnMucG9sbCA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbnMucG9sbCA6IHVuZGVmaW5lZFxyXG5cdH0pO1xyXG5cdHRoaXMud2F0Y2hlci5vbihcImFkZFwiLCB0aGlzLm9uRmlsZUFkZGVkLmJpbmQodGhpcykpO1xyXG5cdHRoaXMud2F0Y2hlci5vbihcImFkZERpclwiLCB0aGlzLm9uRGlyZWN0b3J5QWRkZWQuYmluZCh0aGlzKSk7XHJcblx0dGhpcy53YXRjaGVyLm9uKFwiY2hhbmdlXCIsIHRoaXMub25DaGFuZ2UuYmluZCh0aGlzKSk7XHJcblx0dGhpcy53YXRjaGVyLm9uKFwidW5saW5rXCIsIHRoaXMub25GaWxlVW5saW5rZWQuYmluZCh0aGlzKSk7XHJcblx0dGhpcy53YXRjaGVyLm9uKFwidW5saW5rRGlyXCIsIHRoaXMub25EaXJlY3RvcnlVbmxpbmtlZC5iaW5kKHRoaXMpKTtcclxuXHR0aGlzLndhdGNoZXIub24oXCJlcnJvclwiLCB0aGlzLm9uV2F0Y2hlckVycm9yLmJpbmQodGhpcykpO1xyXG5cdHRoaXMuaW5pdGlhbFNjYW4gPSB0cnVlO1xyXG5cdHRoaXMubmVzdGVkV2F0Y2hpbmcgPSBmYWxzZTtcclxuXHR0aGlzLmluaXRpYWxTY2FuUmVtb3ZlZCA9IFtdO1xyXG5cdHRoaXMuZG9Jbml0aWFsU2NhbigpO1xyXG5cdHRoaXMud2F0Y2hlcnMgPSB7fTtcclxuXHR0aGlzLnJlZnMgPSAwO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gRGlyZWN0b3J5V2F0Y2hlcjtcclxuXHJcbkRpcmVjdG9yeVdhdGNoZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcclxuRGlyZWN0b3J5V2F0Y2hlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEaXJlY3RvcnlXYXRjaGVyO1xyXG5cclxuRGlyZWN0b3J5V2F0Y2hlci5wcm90b3R5cGUuc2V0RmlsZVRpbWUgPSBmdW5jdGlvbiBzZXRGaWxlVGltZShmaWxlUGF0aCwgbXRpbWUsIGluaXRpYWwsIHR5cGUpIHtcclxuXHR2YXIgbm93ID0gRGF0ZS5ub3coKTtcclxuXHR2YXIgb2xkID0gdGhpcy5maWxlc1tmaWxlUGF0aF07XHJcblx0dGhpcy5maWxlc1tmaWxlUGF0aF0gPSBbaW5pdGlhbCA/IE1hdGgubWluKG5vdywgbXRpbWUpIDogbm93LCBtdGltZV07XHJcblx0aWYoIW9sZCkge1xyXG5cdFx0aWYobXRpbWUpIHtcclxuXHRcdFx0aWYodGhpcy53YXRjaGVyc1t3aXRob3V0Q2FzZShmaWxlUGF0aCldKSB7XHJcblx0XHRcdFx0dGhpcy53YXRjaGVyc1t3aXRob3V0Q2FzZShmaWxlUGF0aCldLmZvckVhY2goZnVuY3Rpb24odykge1xyXG5cdFx0XHRcdFx0aWYoIWluaXRpYWwgfHwgdy5jaGVja1N0YXJ0VGltZShtdGltZSwgaW5pdGlhbCkpIHtcclxuXHRcdFx0XHRcdFx0dy5lbWl0KFwiY2hhbmdlXCIsIG10aW1lKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZighaW5pdGlhbCAmJiBtdGltZSAmJiB0eXBlICE9PSBcImFkZFwiKSB7XHJcblx0XHRpZih0aGlzLndhdGNoZXJzW3dpdGhvdXRDYXNlKGZpbGVQYXRoKV0pIHtcclxuXHRcdFx0dGhpcy53YXRjaGVyc1t3aXRob3V0Q2FzZShmaWxlUGF0aCldLmZvckVhY2goZnVuY3Rpb24odykge1xyXG5cdFx0XHRcdHcuZW1pdChcImNoYW5nZVwiLCBtdGltZSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZighaW5pdGlhbCAmJiAhbXRpbWUpIHtcclxuXHRcdGlmKHRoaXMud2F0Y2hlcnNbd2l0aG91dENhc2UoZmlsZVBhdGgpXSkge1xyXG5cdFx0XHR0aGlzLndhdGNoZXJzW3dpdGhvdXRDYXNlKGZpbGVQYXRoKV0uZm9yRWFjaChmdW5jdGlvbih3KSB7XHJcblx0XHRcdFx0dy5lbWl0KFwicmVtb3ZlXCIpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYodGhpcy53YXRjaGVyc1t3aXRob3V0Q2FzZSh0aGlzLnBhdGgpXSkge1xyXG5cdFx0dGhpcy53YXRjaGVyc1t3aXRob3V0Q2FzZSh0aGlzLnBhdGgpXS5mb3JFYWNoKGZ1bmN0aW9uKHcpIHtcclxuXHRcdFx0aWYoIWluaXRpYWwgfHwgdy5jaGVja1N0YXJ0VGltZShtdGltZSwgaW5pdGlhbCkpIHtcclxuXHRcdFx0XHR3LmVtaXQoXCJjaGFuZ2VcIiwgZmlsZVBhdGgsIG10aW1lKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG59O1xyXG5cclxuRGlyZWN0b3J5V2F0Y2hlci5wcm90b3R5cGUuc2V0RGlyZWN0b3J5ID0gZnVuY3Rpb24gc2V0RGlyZWN0b3J5KGRpcmVjdG9yeVBhdGgsIGV4aXN0LCBpbml0aWFsKSB7XHJcblx0dmFyIG9sZCA9IHRoaXMuZGlyZWN0b3JpZXNbZGlyZWN0b3J5UGF0aF07XHJcblx0aWYoIW9sZCkge1xyXG5cdFx0aWYoZXhpc3QpIHtcclxuXHRcdFx0aWYodGhpcy5uZXN0ZWRXYXRjaGluZykge1xyXG5cdFx0XHRcdHRoaXMuY3JlYXRlTmVzdGVkV2F0Y2hlcihkaXJlY3RvcnlQYXRoKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLmRpcmVjdG9yaWVzW2RpcmVjdG9yeVBhdGhdID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0gZWxzZSB7XHJcblx0XHRpZighZXhpc3QpIHtcclxuXHRcdFx0aWYodGhpcy5uZXN0ZWRXYXRjaGluZylcclxuXHRcdFx0XHR0aGlzLmRpcmVjdG9yaWVzW2RpcmVjdG9yeVBhdGhdLmNsb3NlKCk7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLmRpcmVjdG9yaWVzW2RpcmVjdG9yeVBhdGhdO1xyXG5cdFx0XHRpZighaW5pdGlhbCAmJiB0aGlzLndhdGNoZXJzW3dpdGhvdXRDYXNlKHRoaXMucGF0aCldKSB7XHJcblx0XHRcdFx0dGhpcy53YXRjaGVyc1t3aXRob3V0Q2FzZSh0aGlzLnBhdGgpXS5mb3JFYWNoKGZ1bmN0aW9uKHcpIHtcclxuXHRcdFx0XHRcdHcuZW1pdChcImNoYW5nZVwiLCBkaXJlY3RvcnlQYXRoLCB3LmRhdGEpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuRGlyZWN0b3J5V2F0Y2hlci5wcm90b3R5cGUuY3JlYXRlTmVzdGVkV2F0Y2hlciA9IGZ1bmN0aW9uKGRpcmVjdG9yeVBhdGgpIHtcclxuXHR0aGlzLmRpcmVjdG9yaWVzW2RpcmVjdG9yeVBhdGhdID0gd2F0Y2hlck1hbmFnZXIud2F0Y2hEaXJlY3RvcnkoZGlyZWN0b3J5UGF0aCwgdGhpcy5vcHRpb25zLCAxKTtcclxuXHR0aGlzLmRpcmVjdG9yaWVzW2RpcmVjdG9yeVBhdGhdLm9uKFwiY2hhbmdlXCIsIGZ1bmN0aW9uKGZpbGVQYXRoLCBtdGltZSkge1xyXG5cdFx0aWYodGhpcy53YXRjaGVyc1t3aXRob3V0Q2FzZSh0aGlzLnBhdGgpXSkge1xyXG5cdFx0XHR0aGlzLndhdGNoZXJzW3dpdGhvdXRDYXNlKHRoaXMucGF0aCldLmZvckVhY2goZnVuY3Rpb24odykge1xyXG5cdFx0XHRcdGlmKHcuY2hlY2tTdGFydFRpbWUobXRpbWUsIGZhbHNlKSkge1xyXG5cdFx0XHRcdFx0dy5lbWl0KFwiY2hhbmdlXCIsIGZpbGVQYXRoLCBtdGltZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9LmJpbmQodGhpcykpO1xyXG59O1xyXG5cclxuRGlyZWN0b3J5V2F0Y2hlci5wcm90b3R5cGUuc2V0TmVzdGVkV2F0Y2hpbmcgPSBmdW5jdGlvbihmbGFnKSB7XHJcblx0aWYodGhpcy5uZXN0ZWRXYXRjaGluZyAhPT0gISFmbGFnKSB7XHJcblx0XHR0aGlzLm5lc3RlZFdhdGNoaW5nID0gISFmbGFnO1xyXG5cdFx0aWYodGhpcy5uZXN0ZWRXYXRjaGluZykge1xyXG5cdFx0XHRPYmplY3Qua2V5cyh0aGlzLmRpcmVjdG9yaWVzKS5mb3JFYWNoKGZ1bmN0aW9uKGRpcmVjdG9yeSkge1xyXG5cdFx0XHRcdHRoaXMuY3JlYXRlTmVzdGVkV2F0Y2hlcihkaXJlY3RvcnkpO1xyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdE9iamVjdC5rZXlzKHRoaXMuZGlyZWN0b3JpZXMpLmZvckVhY2goZnVuY3Rpb24oZGlyZWN0b3J5KSB7XHJcblx0XHRcdFx0dGhpcy5kaXJlY3Rvcmllc1tkaXJlY3RvcnldLmNsb3NlKCk7XHJcblx0XHRcdFx0dGhpcy5kaXJlY3Rvcmllc1tkaXJlY3RvcnldID0gdHJ1ZTtcclxuXHRcdFx0fSwgdGhpcyk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuRGlyZWN0b3J5V2F0Y2hlci5wcm90b3R5cGUud2F0Y2ggPSBmdW5jdGlvbiB3YXRjaChmaWxlUGF0aCwgc3RhcnRUaW1lKSB7XHJcblx0dGhpcy53YXRjaGVyc1t3aXRob3V0Q2FzZShmaWxlUGF0aCldID0gdGhpcy53YXRjaGVyc1t3aXRob3V0Q2FzZShmaWxlUGF0aCldIHx8IFtdO1xyXG5cdHRoaXMucmVmcysrO1xyXG5cdHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodGhpcywgZmlsZVBhdGgsIHN0YXJ0VGltZSk7XHJcblx0d2F0Y2hlci5vbihcImNsb3NlZFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBpZHggPSB0aGlzLndhdGNoZXJzW3dpdGhvdXRDYXNlKGZpbGVQYXRoKV0uaW5kZXhPZih3YXRjaGVyKTtcclxuXHRcdHRoaXMud2F0Y2hlcnNbd2l0aG91dENhc2UoZmlsZVBhdGgpXS5zcGxpY2UoaWR4LCAxKTtcclxuXHRcdGlmKHRoaXMud2F0Y2hlcnNbd2l0aG91dENhc2UoZmlsZVBhdGgpXS5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0ZGVsZXRlIHRoaXMud2F0Y2hlcnNbd2l0aG91dENhc2UoZmlsZVBhdGgpXTtcclxuXHRcdFx0aWYodGhpcy5wYXRoID09PSBmaWxlUGF0aClcclxuXHRcdFx0XHR0aGlzLnNldE5lc3RlZFdhdGNoaW5nKGZhbHNlKTtcclxuXHRcdH1cclxuXHRcdGlmKC0tdGhpcy5yZWZzIDw9IDApXHJcblx0XHRcdHRoaXMuY2xvc2UoKTtcclxuXHR9LmJpbmQodGhpcykpO1xyXG5cdHRoaXMud2F0Y2hlcnNbd2l0aG91dENhc2UoZmlsZVBhdGgpXS5wdXNoKHdhdGNoZXIpO1xyXG5cdHZhciBkYXRhO1xyXG5cdGlmKGZpbGVQYXRoID09PSB0aGlzLnBhdGgpIHtcclxuXHRcdHRoaXMuc2V0TmVzdGVkV2F0Y2hpbmcodHJ1ZSk7XHJcblx0XHRkYXRhID0gZmFsc2U7XHJcblx0XHRPYmplY3Qua2V5cyh0aGlzLmZpbGVzKS5mb3JFYWNoKGZ1bmN0aW9uKGZpbGUpIHtcclxuXHRcdFx0dmFyIGQgPSB0aGlzLmZpbGVzW2ZpbGVdO1xyXG5cdFx0XHRpZighZGF0YSlcclxuXHRcdFx0XHRkYXRhID0gZDtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdGRhdGEgPSBbTWF0aC5tYXgoZGF0YVswXSwgZFswXSksIE1hdGgubWF4KGRhdGFbMV0sIGRbMV0pXTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRkYXRhID0gdGhpcy5maWxlc1tmaWxlUGF0aF07XHJcblx0fVxyXG5cdHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XHJcblx0XHRpZihkYXRhKSB7XHJcblx0XHRcdGlmKGRhdGFbMF0gPiBzdGFydFRpbWUpXHJcblx0XHRcdFx0d2F0Y2hlci5lbWl0KFwiY2hhbmdlXCIsIGRhdGFbMV0pO1xyXG5cdFx0fSBlbHNlIGlmKHRoaXMuaW5pdGlhbFNjYW4gJiYgdGhpcy5pbml0aWFsU2NhblJlbW92ZWQuaW5kZXhPZihmaWxlUGF0aCkgPj0gMCkge1xyXG5cdFx0XHR3YXRjaGVyLmVtaXQoXCJyZW1vdmVcIik7XHJcblx0XHR9XHJcblx0fS5iaW5kKHRoaXMpKTtcclxuXHRyZXR1cm4gd2F0Y2hlcjtcclxufTtcclxuXHJcbkRpcmVjdG9yeVdhdGNoZXIucHJvdG90eXBlLm9uRmlsZUFkZGVkID0gZnVuY3Rpb24gb25GaWxlQWRkZWQoZmlsZVBhdGgsIHN0YXQpIHtcclxuXHRpZihmaWxlUGF0aC5pbmRleE9mKHRoaXMucGF0aCkgIT09IDApIHJldHVybjtcclxuXHRpZigvW1xcXFxcXC9dLy50ZXN0KGZpbGVQYXRoLnN1YnN0cih0aGlzLnBhdGgubGVuZ3RoICsgMSkpKSByZXR1cm47XHJcblxyXG5cdHRoaXMuc2V0RmlsZVRpbWUoZmlsZVBhdGgsICtzdGF0Lm10aW1lLCBmYWxzZSwgXCJhZGRcIik7XHJcbn07XHJcblxyXG5EaXJlY3RvcnlXYXRjaGVyLnByb3RvdHlwZS5vbkRpcmVjdG9yeUFkZGVkID0gZnVuY3Rpb24gb25EaXJlY3RvcnlBZGRlZChkaXJlY3RvcnlQYXRoIC8qLCBzdGF0ICovKSB7XHJcblx0aWYoZGlyZWN0b3J5UGF0aC5pbmRleE9mKHRoaXMucGF0aCkgIT09IDApIHJldHVybjtcclxuXHRpZigvW1xcXFxcXC9dLy50ZXN0KGRpcmVjdG9yeVBhdGguc3Vic3RyKHRoaXMucGF0aC5sZW5ndGggKyAxKSkpIHJldHVybjtcclxuXHR0aGlzLnNldERpcmVjdG9yeShkaXJlY3RvcnlQYXRoLCB0cnVlLCBmYWxzZSk7XHJcbn07XHJcblxyXG5EaXJlY3RvcnlXYXRjaGVyLnByb3RvdHlwZS5vbkNoYW5nZSA9IGZ1bmN0aW9uIG9uQ2hhbmdlKGZpbGVQYXRoLCBzdGF0KSB7XHJcblx0aWYoZmlsZVBhdGguaW5kZXhPZih0aGlzLnBhdGgpICE9PSAwKSByZXR1cm47XHJcblx0aWYoL1tcXFxcXFwvXS8udGVzdChmaWxlUGF0aC5zdWJzdHIodGhpcy5wYXRoLmxlbmd0aCArIDEpKSkgcmV0dXJuO1xyXG5cdHZhciBtdGltZSA9ICtzdGF0Lm10aW1lO1xyXG5cdGlmKEZTX0FDQ1VSRU5DWSA+IDEgJiYgbXRpbWUgJSAxICE9PSAwKVxyXG5cdFx0RlNfQUNDVVJFTkNZID0gMTtcclxuXHRlbHNlIGlmKEZTX0FDQ1VSRU5DWSA+IDEwICYmIG10aW1lICUgMTAgIT09IDApXHJcblx0XHRGU19BQ0NVUkVOQ1kgPSAxMDtcclxuXHRlbHNlIGlmKEZTX0FDQ1VSRU5DWSA+IDEwMCAmJiBtdGltZSAlIDEwMCAhPT0gMClcclxuXHRcdEZTX0FDQ1VSRU5DWSA9IDEwMDtcclxuXHRlbHNlIGlmKEZTX0FDQ1VSRU5DWSA+IDEwMDAgJiYgbXRpbWUgJSAxMDAwICE9PSAwKVxyXG5cdFx0RlNfQUNDVVJFTkNZID0gMTAwMDtcclxuXHRlbHNlIGlmKEZTX0FDQ1VSRU5DWSA+IDIwMDAgJiYgbXRpbWUgJSAyMDAwICE9PSAwKVxyXG5cdFx0RlNfQUNDVVJFTkNZID0gMjAwMDtcclxuXHR0aGlzLnNldEZpbGVUaW1lKGZpbGVQYXRoLCBtdGltZSwgZmFsc2UsIFwiY2hhbmdlXCIpO1xyXG59O1xyXG5cclxuRGlyZWN0b3J5V2F0Y2hlci5wcm90b3R5cGUub25GaWxlVW5saW5rZWQgPSBmdW5jdGlvbiBvbkZpbGVVbmxpbmtlZChmaWxlUGF0aCkge1xyXG5cdGlmKGZpbGVQYXRoLmluZGV4T2YodGhpcy5wYXRoKSAhPT0gMCkgcmV0dXJuO1xyXG5cdGlmKC9bXFxcXFxcL10vLnRlc3QoZmlsZVBhdGguc3Vic3RyKHRoaXMucGF0aC5sZW5ndGggKyAxKSkpIHJldHVybjtcclxuXHR0aGlzLnNldEZpbGVUaW1lKGZpbGVQYXRoLCBudWxsLCBmYWxzZSwgXCJ1bmxpbmtcIik7XHJcblx0aWYodGhpcy5pbml0aWFsU2Nhbikge1xyXG5cdFx0dGhpcy5pbml0aWFsU2NhblJlbW92ZWQucHVzaChmaWxlUGF0aCk7XHJcblx0fVxyXG59O1xyXG5cclxuRGlyZWN0b3J5V2F0Y2hlci5wcm90b3R5cGUub25EaXJlY3RvcnlVbmxpbmtlZCA9IGZ1bmN0aW9uIG9uRGlyZWN0b3J5VW5saW5rZWQoZGlyZWN0b3J5UGF0aCkge1xyXG5cdGlmKGRpcmVjdG9yeVBhdGguaW5kZXhPZih0aGlzLnBhdGgpICE9PSAwKSByZXR1cm47XHJcblx0aWYoL1tcXFxcXFwvXS8udGVzdChkaXJlY3RvcnlQYXRoLnN1YnN0cih0aGlzLnBhdGgubGVuZ3RoICsgMSkpKSByZXR1cm47XHJcblx0dGhpcy5zZXREaXJlY3RvcnkoZGlyZWN0b3J5UGF0aCwgZmFsc2UsIGZhbHNlKTtcclxuXHRpZih0aGlzLmluaXRpYWxTY2FuKSB7XHJcblx0XHR0aGlzLmluaXRpYWxTY2FuUmVtb3ZlZC5wdXNoKGRpcmVjdG9yeVBhdGgpO1xyXG5cdH1cclxufTtcclxuXHJcbkRpcmVjdG9yeVdhdGNoZXIucHJvdG90eXBlLm9uV2F0Y2hlckVycm9yID0gZnVuY3Rpb24gb25XYXRjaGVyRXJyb3IoLyogZXJyICovKSB7XHJcbn07XHJcblxyXG5EaXJlY3RvcnlXYXRjaGVyLnByb3RvdHlwZS5kb0luaXRpYWxTY2FuID0gZnVuY3Rpb24gZG9Jbml0aWFsU2NhbigpIHtcclxuXHRmcy5yZWFkZGlyKHRoaXMucGF0aCwgZnVuY3Rpb24oZXJyLCBpdGVtcykge1xyXG5cdFx0aWYoZXJyKSB7XHJcblx0XHRcdHRoaXMuaW5pdGlhbFNjYW4gPSBmYWxzZTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0YXN5bmMuZm9yRWFjaChpdGVtcywgZnVuY3Rpb24oaXRlbSwgY2FsbGJhY2spIHtcclxuXHRcdFx0dmFyIGl0ZW1QYXRoID0gcGF0aC5qb2luKHRoaXMucGF0aCwgaXRlbSk7XHJcblx0XHRcdGZzLnN0YXQoaXRlbVBhdGgsIGZ1bmN0aW9uKGVycjIsIHN0YXQpIHtcclxuXHRcdFx0XHRpZighdGhpcy5pbml0aWFsU2NhbikgcmV0dXJuO1xyXG5cdFx0XHRcdGlmKGVycjIpIHtcclxuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHN0YXQuaXNGaWxlKCkpIHtcclxuXHRcdFx0XHRcdGlmKCF0aGlzLmZpbGVzW2l0ZW1QYXRoXSlcclxuXHRcdFx0XHRcdFx0dGhpcy5zZXRGaWxlVGltZShpdGVtUGF0aCwgK3N0YXQubXRpbWUsIHRydWUpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZihzdGF0LmlzRGlyZWN0b3J5KCkpIHtcclxuXHRcdFx0XHRcdGlmKCF0aGlzLmRpcmVjdG9yaWVzW2l0ZW1QYXRoXSlcclxuXHRcdFx0XHRcdFx0dGhpcy5zZXREaXJlY3RvcnkoaXRlbVBhdGgsIHRydWUsIHRydWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0XHR9LmJpbmQodGhpcykpO1xyXG5cdFx0fS5iaW5kKHRoaXMpLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0dGhpcy5pbml0aWFsU2NhbiA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLmluaXRpYWxTY2FuUmVtb3ZlZCA9IG51bGw7XHJcblx0XHR9LmJpbmQodGhpcykpO1xyXG5cdH0uYmluZCh0aGlzKSk7XHJcbn07XHJcblxyXG5EaXJlY3RvcnlXYXRjaGVyLnByb3RvdHlwZS5nZXRUaW1lcyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBvYmogPSB7fTtcclxuXHR2YXIgc2VsZlRpbWUgPSAwO1xyXG5cdE9iamVjdC5rZXlzKHRoaXMuZmlsZXMpLmZvckVhY2goZnVuY3Rpb24oZmlsZSkge1xyXG5cdFx0dmFyIGRhdGEgPSB0aGlzLmZpbGVzW2ZpbGVdO1xyXG5cdFx0aWYoZGF0YVsxXSkge1xyXG5cdFx0XHR2YXIgdGltZSA9IE1hdGgubWF4KGRhdGFbMF0sIGRhdGFbMV0pO1xyXG5cdFx0XHRvYmpbZmlsZV0gPSB0aW1lO1xyXG5cdFx0XHRpZih0aW1lID4gc2VsZlRpbWUpXHJcblx0XHRcdFx0c2VsZlRpbWUgPSB0aW1lO1xyXG5cdFx0fVxyXG5cdH0sIHRoaXMpO1xyXG5cdGlmKHRoaXMubmVzdGVkV2F0Y2hpbmcpIHtcclxuXHRcdE9iamVjdC5rZXlzKHRoaXMuZGlyZWN0b3JpZXMpLmZvckVhY2goZnVuY3Rpb24oZGlyKSB7XHJcblx0XHRcdHZhciB3ID0gdGhpcy5kaXJlY3Rvcmllc1tkaXJdO1xyXG5cdFx0XHR2YXIgdGltZXMgPSB3LmRpcmVjdG9yeVdhdGNoZXIuZ2V0VGltZXMoKTtcclxuXHRcdFx0T2JqZWN0LmtleXModGltZXMpLmZvckVhY2goZnVuY3Rpb24oZmlsZSkge1xyXG5cdFx0XHRcdHZhciB0aW1lID0gdGltZXNbZmlsZV07XHJcblx0XHRcdFx0b2JqW2ZpbGVdID0gdGltZTtcclxuXHRcdFx0XHRpZih0aW1lID4gc2VsZlRpbWUpXHJcblx0XHRcdFx0XHRzZWxmVGltZSA9IHRpbWU7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSwgdGhpcyk7XHJcblx0XHRvYmpbdGhpcy5wYXRoXSA9IHNlbGZUaW1lO1xyXG5cdH1cclxuXHRyZXR1cm4gb2JqO1xyXG59O1xyXG5cclxuRGlyZWN0b3J5V2F0Y2hlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLmluaXRpYWxTY2FuID0gZmFsc2U7XHJcblx0dGhpcy53YXRjaGVyLmNsb3NlKCk7XHJcblx0aWYodGhpcy5uZXN0ZWRXYXRjaGluZykge1xyXG5cdFx0T2JqZWN0LmtleXModGhpcy5kaXJlY3RvcmllcykuZm9yRWFjaChmdW5jdGlvbihkaXIpIHtcclxuXHRcdFx0dGhpcy5kaXJlY3Rvcmllc1tkaXJdLmNsb3NlKCk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9XHJcblx0dGhpcy5lbWl0KFwiY2xvc2VkXCIpO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vd2F0Y2hwYWNrL2xpYi9EaXJlY3RvcnlXYXRjaGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2V2ZW50cy9ldmVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDIxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIGFzeW5jXG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2FvbGFuL2FzeW5jXG4gKlxuICogQ29weXJpZ2h0IDIwMTAtMjAxNCBDYW9sYW4gTWNNYWhvblxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbi8qanNoaW50IG9uZXZhcjogZmFsc2UsIGluZGVudDo0ICovXG4vKmdsb2JhbCBzZXRJbW1lZGlhdGU6IGZhbHNlLCBzZXRUaW1lb3V0OiBmYWxzZSwgY29uc29sZTogZmFsc2UgKi9cbihmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgYXN5bmMgPSB7fTtcblxuICAgIC8vIGdsb2JhbCBvbiB0aGUgc2VydmVyLCB3aW5kb3cgaW4gdGhlIGJyb3dzZXJcbiAgICB2YXIgcm9vdCwgcHJldmlvdXNfYXN5bmM7XG5cbiAgICByb290ID0gdGhpcztcbiAgICBpZiAocm9vdCAhPSBudWxsKSB7XG4gICAgICBwcmV2aW91c19hc3luYyA9IHJvb3QuYXN5bmM7XG4gICAgfVxuXG4gICAgYXN5bmMubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcm9vdC5hc3luYyA9IHByZXZpb3VzX2FzeW5jO1xuICAgICAgICByZXR1cm4gYXN5bmM7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG9ubHlfb25jZShmbikge1xuICAgICAgICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChjYWxsZWQpIHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIHdhcyBhbHJlYWR5IGNhbGxlZC5cIik7XG4gICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm4uYXBwbHkocm9vdCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vLy8gY3Jvc3MtYnJvd3NlciBjb21wYXRpYmxpdHkgZnVuY3Rpb25zIC8vLy9cblxuICAgIHZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gICAgdmFyIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH07XG5cbiAgICB2YXIgX2VhY2ggPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvcikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaXRlcmF0b3IoYXJyW2ldLCBpLCBhcnIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBfbWFwID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IpIHtcbiAgICAgICAgaWYgKGFyci5tYXApIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIubWFwKGl0ZXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBfZWFjaChhcnIsIGZ1bmN0aW9uICh4LCBpLCBhKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goaXRlcmF0b3IoeCwgaSwgYSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcblxuICAgIHZhciBfcmVkdWNlID0gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIG1lbW8pIHtcbiAgICAgICAgaWYgKGFyci5yZWR1Y2UpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnIucmVkdWNlKGl0ZXJhdG9yLCBtZW1vKTtcbiAgICAgICAgfVxuICAgICAgICBfZWFjaChhcnIsIGZ1bmN0aW9uICh4LCBpLCBhKSB7XG4gICAgICAgICAgICBtZW1vID0gaXRlcmF0b3IobWVtbywgeCwgaSwgYSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuXG4gICAgdmFyIF9rZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH07XG5cbiAgICAvLy8vIGV4cG9ydGVkIGFzeW5jIG1vZHVsZSBmdW5jdGlvbnMgLy8vL1xuXG4gICAgLy8vLyBuZXh0VGljayBpbXBsZW1lbnRhdGlvbiB3aXRoIGJyb3dzZXItY29tcGF0aWJsZSBmYWxsYmFjayAvLy8vXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCAhKHByb2Nlc3MubmV4dFRpY2spKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBhc3luYy5uZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIC8vIG5vdCBhIGRpcmVjdCBhbGlhcyBmb3IgSUUxMCBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBhc3luYy5uZXh0VGljaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzeW5jLm5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlID0gYXN5bmMubmV4dFRpY2s7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzeW5jLm5leHRUaWNrID0gcHJvY2Vzcy5uZXh0VGljaztcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgLy8gbm90IGEgZGlyZWN0IGFsaWFzIGZvciBJRTEwIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUgPSBhc3luYy5uZXh0VGljaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jLmVhY2ggPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKCFhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29tcGxldGVkID0gMDtcbiAgICAgICAgX2VhY2goYXJyLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgaXRlcmF0b3IoeCwgb25seV9vbmNlKGRvbmUpICk7XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBkb25lKGVycikge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGNvbXBsZXRlZCArPSAxO1xuICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID49IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGFzeW5jLmZvckVhY2ggPSBhc3luYy5lYWNoO1xuXG4gICAgYXN5bmMuZWFjaFNlcmllcyA9IGZ1bmN0aW9uIChhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBpZiAoIWFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21wbGV0ZWQgPSAwO1xuICAgICAgICB2YXIgaXRlcmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKGFycltjb21wbGV0ZWRdLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQgPj0gYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpdGVyYXRlKCk7XG4gICAgfTtcbiAgICBhc3luYy5mb3JFYWNoU2VyaWVzID0gYXN5bmMuZWFjaFNlcmllcztcblxuICAgIGFzeW5jLmVhY2hMaW1pdCA9IGZ1bmN0aW9uIChhcnIsIGxpbWl0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGZuID0gX2VhY2hMaW1pdChsaW1pdCk7XG4gICAgICAgIGZuLmFwcGx5KG51bGwsIFthcnIsIGl0ZXJhdG9yLCBjYWxsYmFja10pO1xuICAgIH07XG4gICAgYXN5bmMuZm9yRWFjaExpbWl0ID0gYXN5bmMuZWFjaExpbWl0O1xuXG4gICAgdmFyIF9lYWNoTGltaXQgPSBmdW5jdGlvbiAobGltaXQpIHtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgaWYgKCFhcnIubGVuZ3RoIHx8IGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb21wbGV0ZWQgPSAwO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ZWQgPSAwO1xuICAgICAgICAgICAgdmFyIHJ1bm5pbmcgPSAwO1xuXG4gICAgICAgICAgICAoZnVuY3Rpb24gcmVwbGVuaXNoICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID49IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHJ1bm5pbmcgPCBsaW1pdCAmJiBzdGFydGVkIDwgYXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydGVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmcgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IoYXJyW3N0YXJ0ZWQgLSAxXSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmcgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGxldGVkID49IGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxlbmlzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG5cbiAgICB2YXIgZG9QYXJhbGxlbCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFthc3luYy5lYWNoXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgdmFyIGRvUGFyYWxsZWxMaW1pdCA9IGZ1bmN0aW9uKGxpbWl0LCBmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFtfZWFjaExpbWl0KGxpbWl0KV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBkb1NlcmllcyA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIFthc3luYy5lYWNoU2VyaWVzXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9O1xuICAgIH07XG5cblxuICAgIHZhciBfYXN5bmNNYXAgPSBmdW5jdGlvbiAoZWFjaGZuLCBhcnIsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBhcnIgPSBfbWFwKGFyciwgZnVuY3Rpb24gKHgsIGkpIHtcbiAgICAgICAgICAgIHJldHVybiB7aW5kZXg6IGksIHZhbHVlOiB4fTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKHgudmFsdWUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKHgudmFsdWUsIGZ1bmN0aW9uIChlcnIsIHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1t4LmluZGV4XSA9IHY7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBhc3luYy5tYXAgPSBkb1BhcmFsbGVsKF9hc3luY01hcCk7XG4gICAgYXN5bmMubWFwU2VyaWVzID0gZG9TZXJpZXMoX2FzeW5jTWFwKTtcbiAgICBhc3luYy5tYXBMaW1pdCA9IGZ1bmN0aW9uIChhcnIsIGxpbWl0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9tYXBMaW1pdChsaW1pdCkoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICB2YXIgX21hcExpbWl0ID0gZnVuY3Rpb24obGltaXQpIHtcbiAgICAgICAgcmV0dXJuIGRvUGFyYWxsZWxMaW1pdChsaW1pdCwgX2FzeW5jTWFwKTtcbiAgICB9O1xuXG4gICAgLy8gcmVkdWNlIG9ubHkgaGFzIGEgc2VyaWVzIHZlcnNpb24sIGFzIGRvaW5nIHJlZHVjZSBpbiBwYXJhbGxlbCB3b24ndFxuICAgIC8vIHdvcmsgaW4gbWFueSBzaXR1YXRpb25zLlxuICAgIGFzeW5jLnJlZHVjZSA9IGZ1bmN0aW9uIChhcnIsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICBhc3luYy5lYWNoU2VyaWVzKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihtZW1vLCB4LCBmdW5jdGlvbiAoZXJyLCB2KSB7XG4gICAgICAgICAgICAgICAgbWVtbyA9IHY7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIG1lbW8pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGluamVjdCBhbGlhc1xuICAgIGFzeW5jLmluamVjdCA9IGFzeW5jLnJlZHVjZTtcbiAgICAvLyBmb2xkbCBhbGlhc1xuICAgIGFzeW5jLmZvbGRsID0gYXN5bmMucmVkdWNlO1xuXG4gICAgYXN5bmMucmVkdWNlUmlnaHQgPSBmdW5jdGlvbiAoYXJyLCBtZW1vLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJldmVyc2VkID0gX21hcChhcnIsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSkucmV2ZXJzZSgpO1xuICAgICAgICBhc3luYy5yZWR1Y2UocmV2ZXJzZWQsIG1lbW8sIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAvLyBmb2xkciBhbGlhc1xuICAgIGFzeW5jLmZvbGRyID0gYXN5bmMucmVkdWNlUmlnaHQ7XG5cbiAgICB2YXIgX2ZpbHRlciA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIGFyciA9IF9tYXAoYXJyLCBmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHtpbmRleDogaSwgdmFsdWU6IHh9O1xuICAgICAgICB9KTtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LnZhbHVlLCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhfbWFwKHJlc3VsdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICAgICAgICAgIH0pLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFzeW5jLmZpbHRlciA9IGRvUGFyYWxsZWwoX2ZpbHRlcik7XG4gICAgYXN5bmMuZmlsdGVyU2VyaWVzID0gZG9TZXJpZXMoX2ZpbHRlcik7XG4gICAgLy8gc2VsZWN0IGFsaWFzXG4gICAgYXN5bmMuc2VsZWN0ID0gYXN5bmMuZmlsdGVyO1xuICAgIGFzeW5jLnNlbGVjdFNlcmllcyA9IGFzeW5jLmZpbHRlclNlcmllcztcblxuICAgIHZhciBfcmVqZWN0ID0gZnVuY3Rpb24gKGVhY2hmbiwgYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgYXJyID0gX21hcChhcnIsIGZ1bmN0aW9uICh4LCBpKSB7XG4gICAgICAgICAgICByZXR1cm4ge2luZGV4OiBpLCB2YWx1ZTogeH07XG4gICAgICAgIH0pO1xuICAgICAgICBlYWNoZm4oYXJyLCBmdW5jdGlvbiAoeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yKHgudmFsdWUsIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhfbWFwKHJlc3VsdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICAgICAgICAgIH0pLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGFzeW5jLnJlamVjdCA9IGRvUGFyYWxsZWwoX3JlamVjdCk7XG4gICAgYXN5bmMucmVqZWN0U2VyaWVzID0gZG9TZXJpZXMoX3JlamVjdCk7XG5cbiAgICB2YXIgX2RldGVjdCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgaXRlcmF0b3IsIG1haW5fY2FsbGJhY2spIHtcbiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrKHgpO1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBtYWluX2NhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMuZGV0ZWN0ID0gZG9QYXJhbGxlbChfZGV0ZWN0KTtcbiAgICBhc3luYy5kZXRlY3RTZXJpZXMgPSBkb1NlcmllcyhfZGV0ZWN0KTtcblxuICAgIGFzeW5jLnNvbWUgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgbWFpbl9jYWxsYmFjaykge1xuICAgICAgICBhc3luYy5lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIG1haW5fY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBtYWluX2NhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBhbnkgYWxpYXNcbiAgICBhc3luYy5hbnkgPSBhc3luYy5zb21lO1xuXG4gICAgYXN5bmMuZXZlcnkgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgbWFpbl9jYWxsYmFjaykge1xuICAgICAgICBhc3luYy5lYWNoKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIGlmICghdikge1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgbWFpbl9jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIG1haW5fY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gYWxsIGFsaWFzXG4gICAgYXN5bmMuYWxsID0gYXN5bmMuZXZlcnk7XG5cbiAgICBhc3luYy5zb3J0QnkgPSBmdW5jdGlvbiAoYXJyLCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgYXN5bmMubWFwKGFyciwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpdGVyYXRvcih4LCBmdW5jdGlvbiAoZXJyLCBjcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHt2YWx1ZTogeCwgY3JpdGVyaWE6IGNyaXRlcmlhfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWEsIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgX21hcChyZXN1bHRzLnNvcnQoZm4pLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBhc3luYy5hdXRvID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICB2YXIga2V5cyA9IF9rZXlzKHRhc2tzKTtcbiAgICAgICAgdmFyIHJlbWFpbmluZ1Rhc2tzID0ga2V5cy5sZW5ndGhcbiAgICAgICAgaWYgKCFyZW1haW5pbmdUYXNrcykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdmFyIGFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnMudW5zaGlmdChmbik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldID09PSBmbikge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdGFza0NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVtYWluaW5nVGFza3MtLVxuICAgICAgICAgICAgX2VhY2gobGlzdGVuZXJzLnNsaWNlKDApLCBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgYWRkTGlzdGVuZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFyZW1haW5pbmdUYXNrcykge1xuICAgICAgICAgICAgICAgIHZhciB0aGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgZmluYWwgY2FsbGJhY2sgZnJvbSBjYWxsaW5nIGl0c2VsZiBpZiBpdCBlcnJvcnNcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICAgICAgICAgICAgdGhlQ2FsbGJhY2sobnVsbCwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF9lYWNoKGtleXMsIGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IF9pc0FycmF5KHRhc2tzW2tdKSA/IHRhc2tzW2tdOiBbdGFza3Nba11dO1xuICAgICAgICAgICAgdmFyIHRhc2tDYWxsYmFjayA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNhZmVSZXN1bHRzID0ge307XG4gICAgICAgICAgICAgICAgICAgIF9lYWNoKF9rZXlzKHJlc3VsdHMpLCBmdW5jdGlvbihya2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYWZlUmVzdWx0c1tya2V5XSA9IHJlc3VsdHNbcmtleV07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzYWZlUmVzdWx0c1trXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgc2FmZVJlc3VsdHMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzdG9wIHN1YnNlcXVlbnQgZXJyb3JzIGhpdHRpbmcgY2FsbGJhY2sgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUodGFza0NvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHJlcXVpcmVzID0gdGFzay5zbGljZSgwLCBNYXRoLmFicyh0YXNrLmxlbmd0aCAtIDEpKSB8fCBbXTtcbiAgICAgICAgICAgIHZhciByZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlZHVjZShyZXF1aXJlcywgZnVuY3Rpb24gKGEsIHgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChhICYmIHJlc3VsdHMuaGFzT3duUHJvcGVydHkoeCkpO1xuICAgICAgICAgICAgICAgIH0sIHRydWUpICYmICFyZXN1bHRzLmhhc093blByb3BlcnR5KGspO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChyZWFkeSgpKSB7XG4gICAgICAgICAgICAgICAgdGFza1t0YXNrLmxlbmd0aCAtIDFdKHRhc2tDYWxsYmFjaywgcmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWFkeSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrW3Rhc2subGVuZ3RoIC0gMV0odGFza0NhbGxiYWNrLCByZXN1bHRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYWRkTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYXN5bmMucmV0cnkgPSBmdW5jdGlvbih0aW1lcywgdGFzaywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIERFRkFVTFRfVElNRVMgPSA1O1xuICAgICAgICB2YXIgYXR0ZW1wdHMgPSBbXTtcbiAgICAgICAgLy8gVXNlIGRlZmF1bHRzIGlmIHRpbWVzIG5vdCBwYXNzZWRcbiAgICAgICAgaWYgKHR5cGVvZiB0aW1lcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSB0YXNrO1xuICAgICAgICAgICAgdGFzayA9IHRpbWVzO1xuICAgICAgICAgICAgdGltZXMgPSBERUZBVUxUX1RJTUVTO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aW1lcyBpcyBhIG51bWJlclxuICAgICAgICB0aW1lcyA9IHBhcnNlSW50KHRpbWVzLCAxMCkgfHwgREVGQVVMVF9USU1FUztcbiAgICAgICAgdmFyIHdyYXBwZWRUYXNrID0gZnVuY3Rpb24od3JhcHBlZENhbGxiYWNrLCB3cmFwcGVkUmVzdWx0cykge1xuICAgICAgICAgICAgdmFyIHJldHJ5QXR0ZW1wdCA9IGZ1bmN0aW9uKHRhc2ssIGZpbmFsQXR0ZW1wdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzZXJpZXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0YXNrKGZ1bmN0aW9uKGVyciwgcmVzdWx0KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmllc0NhbGxiYWNrKCFlcnIgfHwgZmluYWxBdHRlbXB0LCB7ZXJyOiBlcnIsIHJlc3VsdDogcmVzdWx0fSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHdyYXBwZWRSZXN1bHRzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdoaWxlICh0aW1lcykge1xuICAgICAgICAgICAgICAgIGF0dGVtcHRzLnB1c2gocmV0cnlBdHRlbXB0KHRhc2ssICEodGltZXMtPTEpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3luYy5zZXJpZXMoYXR0ZW1wdHMsIGZ1bmN0aW9uKGRvbmUsIGRhdGEpe1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgKHdyYXBwZWRDYWxsYmFjayB8fCBjYWxsYmFjaykoZGF0YS5lcnIsIGRhdGEucmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGEgY2FsbGJhY2sgaXMgcGFzc2VkLCBydW4gdGhpcyBhcyBhIGNvbnRyb2xsIGZsb3dcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrID8gd3JhcHBlZFRhc2soKSA6IHdyYXBwZWRUYXNrXG4gICAgfTtcblxuICAgIGFzeW5jLndhdGVyZmFsbCA9IGZ1bmN0aW9uICh0YXNrcywgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgaWYgKCFfaXNBcnJheSh0YXNrcykpIHtcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCB0byB3YXRlcmZhbGwgbXVzdCBiZSBhbiBhcnJheSBvZiBmdW5jdGlvbnMnKTtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdyYXBJdGVyYXRvciA9IGZ1bmN0aW9uIChpdGVyYXRvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKHdyYXBJdGVyYXRvcihuZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRvci5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgd3JhcEl0ZXJhdG9yKGFzeW5jLml0ZXJhdG9yKHRhc2tzKSkoKTtcbiAgICB9O1xuXG4gICAgdmFyIF9wYXJhbGxlbCA9IGZ1bmN0aW9uKGVhY2hmbiwgdGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG4gICAgICAgIGlmIChfaXNBcnJheSh0YXNrcykpIHtcbiAgICAgICAgICAgIGVhY2hmbi5tYXAodGFza3MsIGZ1bmN0aW9uIChmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgZm4oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwobnVsbCwgZXJyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgIGVhY2hmbi5lYWNoKF9rZXlzKHRhc2tzKSwgZnVuY3Rpb24gKGssIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGFza3Nba10oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2tdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgYXN5bmMucGFyYWxsZWwgPSBmdW5jdGlvbiAodGFza3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIF9wYXJhbGxlbCh7IG1hcDogYXN5bmMubWFwLCBlYWNoOiBhc3luYy5lYWNoIH0sIHRhc2tzLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLnBhcmFsbGVsTGltaXQgPSBmdW5jdGlvbih0YXNrcywgbGltaXQsIGNhbGxiYWNrKSB7XG4gICAgICAgIF9wYXJhbGxlbCh7IG1hcDogX21hcExpbWl0KGxpbWl0KSwgZWFjaDogX2VhY2hMaW1pdChsaW1pdCkgfSwgdGFza3MsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuc2VyaWVzID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICBpZiAoX2lzQXJyYXkodGFza3MpKSB7XG4gICAgICAgICAgICBhc3luYy5tYXBTZXJpZXModGFza3MsIGZ1bmN0aW9uIChmbiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICAgICAgZm4oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwobnVsbCwgZXJyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgIGFzeW5jLmVhY2hTZXJpZXMoX2tleXModGFza3MpLCBmdW5jdGlvbiAoaywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0YXNrc1trXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba10gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhc3luYy5pdGVyYXRvciA9IGZ1bmN0aW9uICh0YXNrcykge1xuICAgICAgICB2YXIgbWFrZUNhbGxiYWNrID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrc1tpbmRleF0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLm5leHQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmbi5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoaW5kZXggPCB0YXNrcy5sZW5ndGggLSAxKSA/IG1ha2VDYWxsYmFjayhpbmRleCArIDEpOiBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBmbjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1ha2VDYWxsYmFjaygwKTtcbiAgICB9O1xuXG4gICAgYXN5bmMuYXBwbHkgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KFxuICAgICAgICAgICAgICAgIG51bGwsIGFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgX2NvbmNhdCA9IGZ1bmN0aW9uIChlYWNoZm4sIGFyciwgZm4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByID0gW107XG4gICAgICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBjYikge1xuICAgICAgICAgICAgZm4oeCwgZnVuY3Rpb24gKGVyciwgeSkge1xuICAgICAgICAgICAgICAgIHIgPSByLmNvbmNhdCh5IHx8IFtdKTtcbiAgICAgICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgYXN5bmMuY29uY2F0ID0gZG9QYXJhbGxlbChfY29uY2F0KTtcbiAgICBhc3luYy5jb25jYXRTZXJpZXMgPSBkb1NlcmllcyhfY29uY2F0KTtcblxuICAgIGFzeW5jLndoaWxzdCA9IGZ1bmN0aW9uICh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRlc3QoKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzeW5jLndoaWxzdCh0ZXN0LCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGFzeW5jLmRvV2hpbHN0ID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjaykge1xuICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICBpZiAodGVzdC5hcHBseShudWxsLCBhcmdzKSkge1xuICAgICAgICAgICAgICAgIGFzeW5jLmRvV2hpbHN0KGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYXN5bmMudW50aWwgPSBmdW5jdGlvbiAodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghdGVzdCgpKSB7XG4gICAgICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXN5bmMudW50aWwodGVzdCwgaXRlcmF0b3IsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBhc3luYy5kb1VudGlsID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjaykge1xuICAgICAgICBpdGVyYXRvcihmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICBpZiAoIXRlc3QuYXBwbHkobnVsbCwgYXJncykpIHtcbiAgICAgICAgICAgICAgICBhc3luYy5kb1VudGlsKGl0ZXJhdG9yLCB0ZXN0LCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgYXN5bmMucXVldWUgPSBmdW5jdGlvbiAod29ya2VyLCBjb25jdXJyZW5jeSkge1xuICAgICAgICBpZiAoY29uY3VycmVuY3kgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uY3VycmVuY3kgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIF9pbnNlcnQocSwgZGF0YSwgcG9zLCBjYWxsYmFjaykge1xuICAgICAgICAgIGlmICghcS5zdGFydGVkKXtcbiAgICAgICAgICAgIHEuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghX2lzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoZGF0YS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgIC8vIGNhbGwgZHJhaW4gaW1tZWRpYXRlbHkgaWYgdGhlcmUgYXJlIG5vIHRhc2tzXG4gICAgICAgICAgICAgcmV0dXJuIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgaWYgKHEuZHJhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgIHEuZHJhaW4oKTtcbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfZWFjaChkYXRhLCBmdW5jdGlvbih0YXNrKSB7XG4gICAgICAgICAgICAgIHZhciBpdGVtID0ge1xuICAgICAgICAgICAgICAgICAgZGF0YTogdGFzayxcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBjYWxsYmFjayA6IG51bGxcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICAgICAgcS50YXNrcy51bnNoaWZ0KGl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHEudGFza3MucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChxLnNhdHVyYXRlZCAmJiBxLnRhc2tzLmxlbmd0aCA9PT0gcS5jb25jdXJyZW5jeSkge1xuICAgICAgICAgICAgICAgICAgcS5zYXR1cmF0ZWQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUocS5wcm9jZXNzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3b3JrZXJzID0gMDtcbiAgICAgICAgdmFyIHEgPSB7XG4gICAgICAgICAgICB0YXNrczogW10sXG4gICAgICAgICAgICBjb25jdXJyZW5jeTogY29uY3VycmVuY3ksXG4gICAgICAgICAgICBzYXR1cmF0ZWQ6IG51bGwsXG4gICAgICAgICAgICBlbXB0eTogbnVsbCxcbiAgICAgICAgICAgIGRyYWluOiBudWxsLFxuICAgICAgICAgICAgc3RhcnRlZDogZmFsc2UsXG4gICAgICAgICAgICBwYXVzZWQ6IGZhbHNlLFxuICAgICAgICAgICAgcHVzaDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIF9pbnNlcnQocSwgZGF0YSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBraWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHEuZHJhaW4gPSBudWxsO1xuICAgICAgICAgICAgICBxLnRhc2tzID0gW107XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5zaGlmdDogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIF9pbnNlcnQocSwgZGF0YSwgdHJ1ZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXEucGF1c2VkICYmIHdvcmtlcnMgPCBxLmNvbmN1cnJlbmN5ICYmIHEudGFza3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXNrID0gcS50YXNrcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocS5lbXB0eSAmJiBxLnRhc2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcS5lbXB0eSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlcnMgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrZXJzIC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFzay5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2suY2FsbGJhY2suYXBwbHkodGFzaywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxLmRyYWluICYmIHEudGFza3MubGVuZ3RoICsgd29ya2VycyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHEuZHJhaW4oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHEucHJvY2VzcygpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2IgPSBvbmx5X29uY2UobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtlcih0YXNrLmRhdGEsIGNiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHEudGFza3MubGVuZ3RoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJ1bm5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd29ya2VycztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZGxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcS50YXNrcy5sZW5ndGggKyB3b3JrZXJzID09PSAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdXNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHEucGF1c2VkID09PSB0cnVlKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICAgIHEucGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAocS5wYXVzZWQgPT09IGZhbHNlKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICAgIHEucGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gTmVlZCB0byBjYWxsIHEucHJvY2VzcyBvbmNlIHBlciBjb25jdXJyZW50XG4gICAgICAgICAgICAgICAgLy8gd29ya2VyIHRvIHByZXNlcnZlIGZ1bGwgY29uY3VycmVuY3kgYWZ0ZXIgcGF1c2VcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB3ID0gMTsgdyA8PSBxLmNvbmN1cnJlbmN5OyB3KyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXN5bmMuc2V0SW1tZWRpYXRlKHEucHJvY2Vzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcTtcbiAgICB9O1xuXG4gICAgYXN5bmMucHJpb3JpdHlRdWV1ZSA9IGZ1bmN0aW9uICh3b3JrZXIsIGNvbmN1cnJlbmN5KSB7XG5cbiAgICAgICAgZnVuY3Rpb24gX2NvbXBhcmVUYXNrcyhhLCBiKXtcbiAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZnVuY3Rpb24gX2JpbmFyeVNlYXJjaChzZXF1ZW5jZSwgaXRlbSwgY29tcGFyZSkge1xuICAgICAgICAgIHZhciBiZWcgPSAtMSxcbiAgICAgICAgICAgICAgZW5kID0gc2VxdWVuY2UubGVuZ3RoIC0gMTtcbiAgICAgICAgICB3aGlsZSAoYmVnIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgbWlkID0gYmVnICsgKChlbmQgLSBiZWcgKyAxKSA+Pj4gMSk7XG4gICAgICAgICAgICBpZiAoY29tcGFyZShpdGVtLCBzZXF1ZW5jZVttaWRdKSA+PSAwKSB7XG4gICAgICAgICAgICAgIGJlZyA9IG1pZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVuZCA9IG1pZCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiZWc7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBfaW5zZXJ0KHEsIGRhdGEsIHByaW9yaXR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIGlmICghcS5zdGFydGVkKXtcbiAgICAgICAgICAgIHEuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghX2lzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgZGF0YSA9IFtkYXRhXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoZGF0YS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgIC8vIGNhbGwgZHJhaW4gaW1tZWRpYXRlbHkgaWYgdGhlcmUgYXJlIG5vIHRhc2tzXG4gICAgICAgICAgICAgcmV0dXJuIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgaWYgKHEuZHJhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgIHEuZHJhaW4oKTtcbiAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfZWFjaChkYXRhLCBmdW5jdGlvbih0YXNrKSB7XG4gICAgICAgICAgICAgIHZhciBpdGVtID0ge1xuICAgICAgICAgICAgICAgICAgZGF0YTogdGFzayxcbiAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiBwcmlvcml0eSxcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBjYWxsYmFjayA6IG51bGxcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBxLnRhc2tzLnNwbGljZShfYmluYXJ5U2VhcmNoKHEudGFza3MsIGl0ZW0sIF9jb21wYXJlVGFza3MpICsgMSwgMCwgaXRlbSk7XG5cbiAgICAgICAgICAgICAgaWYgKHEuc2F0dXJhdGVkICYmIHEudGFza3MubGVuZ3RoID09PSBxLmNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgICAgICAgICBxLnNhdHVyYXRlZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFzeW5jLnNldEltbWVkaWF0ZShxLnByb2Nlc3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhcnQgd2l0aCBhIG5vcm1hbCBxdWV1ZVxuICAgICAgICB2YXIgcSA9IGFzeW5jLnF1ZXVlKHdvcmtlciwgY29uY3VycmVuY3kpO1xuXG4gICAgICAgIC8vIE92ZXJyaWRlIHB1c2ggdG8gYWNjZXB0IHNlY29uZCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIHByaW9yaXR5XG4gICAgICAgIHEucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBwcmlvcml0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICBfaW5zZXJ0KHEsIGRhdGEsIHByaW9yaXR5LCBjYWxsYmFjayk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmVtb3ZlIHVuc2hpZnQgZnVuY3Rpb25cbiAgICAgICAgZGVsZXRlIHEudW5zaGlmdDtcblxuICAgICAgICByZXR1cm4gcTtcbiAgICB9O1xuXG4gICAgYXN5bmMuY2FyZ28gPSBmdW5jdGlvbiAod29ya2VyLCBwYXlsb2FkKSB7XG4gICAgICAgIHZhciB3b3JraW5nICAgICA9IGZhbHNlLFxuICAgICAgICAgICAgdGFza3MgICAgICAgPSBbXTtcblxuICAgICAgICB2YXIgY2FyZ28gPSB7XG4gICAgICAgICAgICB0YXNrczogdGFza3MsXG4gICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICAgICAgc2F0dXJhdGVkOiBudWxsLFxuICAgICAgICAgICAgZW1wdHk6IG51bGwsXG4gICAgICAgICAgICBkcmFpbjogbnVsbCxcbiAgICAgICAgICAgIGRyYWluZWQ6IHRydWUsXG4gICAgICAgICAgICBwdXNoOiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoIV9pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9lYWNoKGRhdGEsIGZ1bmN0aW9uKHRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGFza3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB0YXNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGNhbGxiYWNrIDogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY2FyZ28uZHJhaW5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FyZ28uc2F0dXJhdGVkICYmIHRhc2tzLmxlbmd0aCA9PT0gcGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZ28uc2F0dXJhdGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhc3luYy5zZXRJbW1lZGlhdGUoY2FyZ28ucHJvY2Vzcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvY2VzczogZnVuY3Rpb24gcHJvY2VzcygpIHtcbiAgICAgICAgICAgICAgICBpZiAod29ya2luZykgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICh0YXNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoY2FyZ28uZHJhaW4gJiYgIWNhcmdvLmRyYWluZWQpIGNhcmdvLmRyYWluKCk7XG4gICAgICAgICAgICAgICAgICAgIGNhcmdvLmRyYWluZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHRzID0gdHlwZW9mIHBheWxvYWQgPT09ICdudW1iZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0YXNrcy5zcGxpY2UoMCwgcGF5bG9hZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRhc2tzLnNwbGljZSgwLCB0YXNrcy5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRzID0gX21hcCh0cywgZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhc2suZGF0YTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmKGNhcmdvLmVtcHR5KSBjYXJnby5lbXB0eSgpO1xuICAgICAgICAgICAgICAgIHdvcmtpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHdvcmtlcihkcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB3b3JraW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgICAgIF9lYWNoKHRzLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhc2tzLmxlbmd0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydW5uaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjYXJnbztcbiAgICB9O1xuXG4gICAgdmFyIF9jb25zb2xlX2ZuID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoW2Z1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uc29sZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb25zb2xlW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZWFjaChhcmdzLCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGVbbmFtZV0oeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dKSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBhc3luYy5sb2cgPSBfY29uc29sZV9mbignbG9nJyk7XG4gICAgYXN5bmMuZGlyID0gX2NvbnNvbGVfZm4oJ2RpcicpO1xuICAgIC8qYXN5bmMuaW5mbyA9IF9jb25zb2xlX2ZuKCdpbmZvJyk7XG4gICAgYXN5bmMud2FybiA9IF9jb25zb2xlX2ZuKCd3YXJuJyk7XG4gICAgYXN5bmMuZXJyb3IgPSBfY29uc29sZV9mbignZXJyb3InKTsqL1xuXG4gICAgYXN5bmMubWVtb2l6ZSA9IGZ1bmN0aW9uIChmbiwgaGFzaGVyKSB7XG4gICAgICAgIHZhciBtZW1vID0ge307XG4gICAgICAgIHZhciBxdWV1ZXMgPSB7fTtcbiAgICAgICAgaGFzaGVyID0gaGFzaGVyIHx8IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgICAgIHZhciBrZXkgPSBoYXNoZXIuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICBpZiAoa2V5IGluIG1lbW8pIHtcbiAgICAgICAgICAgICAgICBhc3luYy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIG1lbW9ba2V5XSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgaW4gcXVldWVzKSB7XG4gICAgICAgICAgICAgICAgcXVldWVzW2tleV0ucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWV1ZXNba2V5XSA9IFtjYWxsYmFja107XG4gICAgICAgICAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoW2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVtb1trZXldID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcSA9IHF1ZXVlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcXVldWVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBxW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBtZW1vaXplZC5tZW1vID0gbWVtbztcbiAgICAgICAgbWVtb2l6ZWQudW5tZW1vaXplZCA9IGZuO1xuICAgICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gICAgfTtcblxuICAgIGFzeW5jLnVubWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChmbi51bm1lbW9pemVkIHx8IGZuKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgYXN5bmMudGltZXMgPSBmdW5jdGlvbiAoY291bnQsIGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgY291bnRlciA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvdW50ZXIucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN5bmMubWFwKGNvdW50ZXIsIGl0ZXJhdG9yLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGFzeW5jLnRpbWVzU2VyaWVzID0gZnVuY3Rpb24gKGNvdW50LCBpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGNvdW50ZXIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb3VudGVyLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzeW5jLm1hcFNlcmllcyhjb3VudGVyLCBpdGVyYXRvciwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBhc3luYy5zZXEgPSBmdW5jdGlvbiAoLyogZnVuY3Rpb25zLi4uICovKSB7XG4gICAgICAgIHZhciBmbnMgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgYXN5bmMucmVkdWNlKGZucywgYXJncywgZnVuY3Rpb24gKG5ld2FyZ3MsIGZuLCBjYikge1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIG5ld2FyZ3MuY29uY2F0KFtmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgICAgICAgICAgICAgIGNiKGVyciwgbmV4dGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1dKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodGhhdCwgW2Vycl0uY29uY2F0KHJlc3VsdHMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBhc3luYy5jb21wb3NlID0gZnVuY3Rpb24gKC8qIGZ1bmN0aW9ucy4uLiAqLykge1xuICAgICAgcmV0dXJuIGFzeW5jLnNlcS5hcHBseShudWxsLCBBcnJheS5wcm90b3R5cGUucmV2ZXJzZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG5cbiAgICB2YXIgX2FwcGx5RWFjaCA9IGZ1bmN0aW9uIChlYWNoZm4sIGZucyAvKmFyZ3MuLi4qLykge1xuICAgICAgICB2YXIgZ28gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIGVhY2hmbihmbnMsIGZ1bmN0aW9uIChmbiwgY2IpIHtcbiAgICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzLmNvbmNhdChbY2JdKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgICAgIHJldHVybiBnby5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnbztcbiAgICAgICAgfVxuICAgIH07XG4gICAgYXN5bmMuYXBwbHlFYWNoID0gZG9QYXJhbGxlbChfYXBwbHlFYWNoKTtcbiAgICBhc3luYy5hcHBseUVhY2hTZXJpZXMgPSBkb1NlcmllcyhfYXBwbHlFYWNoKTtcblxuICAgIGFzeW5jLmZvcmV2ZXIgPSBmdW5jdGlvbiAoZm4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGZ1bmN0aW9uIG5leHQoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbihuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0KCk7XG4gICAgfTtcblxuICAgIC8vIE5vZGUuanNcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBhc3luYztcbiAgICB9XG4gICAgLy8gQU1EIC8gUmVxdWlyZUpTXG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3luYztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGluY2x1ZGVkIGRpcmVjdGx5IHZpYSA8c2NyaXB0PiB0YWdcbiAgICBlbHNlIHtcbiAgICAgICAgcm9vdC5hc3luYyA9IGFzeW5jO1xuICAgIH1cblxufSgpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi93YXRjaHBhY2svfi9hc3luYy9saWIvYXN5bmMuanNcbi8vIG1vZHVsZSBpZCA9IDIxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbnZhciBzeXNQYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIGFzeW5jRWFjaCA9IHJlcXVpcmUoJ2FzeW5jLWVhY2gnKTtcbnZhciBhbnltYXRjaCA9IHJlcXVpcmUoJ2FueW1hdGNoJyk7XG52YXIgZ2xvYlBhcmVudCA9IHJlcXVpcmUoJ2dsb2ItcGFyZW50Jyk7XG52YXIgaXNHbG9iID0gcmVxdWlyZSgnaXMtZ2xvYicpO1xudmFyIGlzQWJzb2x1dGUgPSByZXF1aXJlKCdwYXRoLWlzLWFic29sdXRlJyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG52YXIgTm9kZUZzSGFuZGxlciA9IHJlcXVpcmUoJy4vbGliL25vZGVmcy1oYW5kbGVyJyk7XG52YXIgRnNFdmVudHNIYW5kbGVyID0gcmVxdWlyZSgnLi9saWIvZnNldmVudHMtaGFuZGxlcicpO1xuXG52YXIgYXJyaWZ5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBbXTtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xufTtcblxudmFyIGZsYXR0ZW4gPSBmdW5jdGlvbihsaXN0LCByZXN1bHQpIHtcbiAgaWYgKHJlc3VsdCA9PSBudWxsKSByZXN1bHQgPSBbXTtcbiAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgZmxhdHRlbihpdGVtLCByZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gTGl0dGxlIGlzU3RyaW5nIHV0aWwgZm9yIHVzZSBpbiBBcnJheSNldmVyeS5cbnZhciBpc1N0cmluZyA9IGZ1bmN0aW9uKHRoaW5nKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpbmcgPT09ICdzdHJpbmcnO1xufTtcblxuLy8gUHVibGljOiBNYWluIGNsYXNzLlxuLy8gV2F0Y2hlcyBmaWxlcyAmIGRpcmVjdG9yaWVzIGZvciBjaGFuZ2VzLlxuLy9cbi8vICogX29wdHMgLSBvYmplY3QsIGNob2tpZGFyIG9wdGlvbnMgaGFzaFxuLy9cbi8vIEVtaXR0ZWQgZXZlbnRzOlxuLy8gYGFkZGAsIGBhZGREaXJgLCBgY2hhbmdlYCwgYHVubGlua2AsIGB1bmxpbmtEaXJgLCBgYWxsYCwgYGVycm9yYFxuLy9cbi8vIEV4YW1wbGVzXG4vL1xuLy8gIHZhciB3YXRjaGVyID0gbmV3IEZTV2F0Y2hlcigpXG4vLyAgICAuYWRkKGRpcmVjdG9yaWVzKVxuLy8gICAgLm9uKCdhZGQnLCBwYXRoID0+IGNvbnNvbGUubG9nKCdGaWxlJywgcGF0aCwgJ3dhcyBhZGRlZCcpKVxuLy8gICAgLm9uKCdjaGFuZ2UnLCBwYXRoID0+IGNvbnNvbGUubG9nKCdGaWxlJywgcGF0aCwgJ3dhcyBjaGFuZ2VkJykpXG4vLyAgICAub24oJ3VubGluaycsIHBhdGggPT4gY29uc29sZS5sb2coJ0ZpbGUnLCBwYXRoLCAnd2FzIHJlbW92ZWQnKSlcbi8vICAgIC5vbignYWxsJywgKGV2ZW50LCBwYXRoKSA9PiBjb25zb2xlLmxvZyhwYXRoLCAnIGVtaXR0ZWQgJywgZXZlbnQpKVxuLy9cbmZ1bmN0aW9uIEZTV2F0Y2hlcihfb3B0cykge1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdmFyIG9wdHMgPSB7fTtcbiAgLy8gaW4gY2FzZSBfb3B0cyB0aGF0IGlzIHBhc3NlZCBpbiBpcyBhIGZyb3plbiBvYmplY3RcbiAgaWYgKF9vcHRzKSBmb3IgKHZhciBvcHQgaW4gX29wdHMpIG9wdHNbb3B0XSA9IF9vcHRzW29wdF07XG4gIHRoaXMuX3dhdGNoZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9jbG9zZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5faWdub3JlZFBhdGhzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfZ2xvYklnbm9yZWQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2lnbm9yZWRQYXRocyk7IH1cbiAgfSk7XG4gIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gIHRoaXMuX3Rocm90dGxlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX3N5bWxpbmtQYXRocyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZnVuY3Rpb24gdW5kZWYoa2V5KSB7XG4gICAgcmV0dXJuIG9wdHNba2V5XSA9PT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gU2V0IHVwIGRlZmF1bHQgb3B0aW9ucy5cbiAgaWYgKHVuZGVmKCdwZXJzaXN0ZW50JykpIG9wdHMucGVyc2lzdGVudCA9IHRydWU7XG4gIGlmICh1bmRlZignaWdub3JlSW5pdGlhbCcpKSBvcHRzLmlnbm9yZUluaXRpYWwgPSBmYWxzZTtcbiAgaWYgKHVuZGVmKCdpZ25vcmVQZXJtaXNzaW9uRXJyb3JzJykpIG9wdHMuaWdub3JlUGVybWlzc2lvbkVycm9ycyA9IGZhbHNlO1xuICBpZiAodW5kZWYoJ2ludGVydmFsJykpIG9wdHMuaW50ZXJ2YWwgPSAxMDA7XG4gIGlmICh1bmRlZignYmluYXJ5SW50ZXJ2YWwnKSkgb3B0cy5iaW5hcnlJbnRlcnZhbCA9IDMwMDtcbiAgdGhpcy5lbmFibGVCaW5hcnlJbnRlcnZhbCA9IG9wdHMuYmluYXJ5SW50ZXJ2YWwgIT09IG9wdHMuaW50ZXJ2YWw7XG5cbiAgLy8gRW5hYmxlIGZzZXZlbnRzIG9uIE9TIFggd2hlbiBwb2xsaW5nIGlzbid0IGV4cGxpY2l0bHkgZW5hYmxlZC5cbiAgaWYgKHVuZGVmKCd1c2VGc0V2ZW50cycpKSBvcHRzLnVzZUZzRXZlbnRzID0gIW9wdHMudXNlUG9sbGluZztcblxuICAvLyBJZiB3ZSBjYW4ndCB1c2UgZnNldmVudHMsIGVuc3VyZSB0aGUgb3B0aW9ucyByZWZsZWN0IGl0J3MgZGlzYWJsZWQuXG4gIGlmICghRnNFdmVudHNIYW5kbGVyLmNhblVzZSgpKSBvcHRzLnVzZUZzRXZlbnRzID0gZmFsc2U7XG5cbiAgLy8gVXNlIHBvbGxpbmcgb24gTWFjIGlmIG5vdCB1c2luZyBmc2V2ZW50cy5cbiAgLy8gT3RoZXIgcGxhdGZvcm1zIHVzZSBub24tcG9sbGluZyBmcy53YXRjaC5cbiAgaWYgKHVuZGVmKCd1c2VQb2xsaW5nJykgJiYgIW9wdHMudXNlRnNFdmVudHMpIHtcbiAgICBvcHRzLnVzZVBvbGxpbmcgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJztcbiAgfVxuXG4gIC8vIEdsb2JhbCBvdmVycmlkZSAodXNlZnVsIGZvciBlbmQtZGV2ZWxvcGVycyB0aGF0IG5lZWQgdG8gZm9yY2UgcG9sbGluZyBmb3IgYWxsXG4gIC8vIGluc3RhbmNlcyBvZiBjaG9raWRhciwgcmVnYXJkbGVzcyBvZiB1c2FnZS9kZXBlbmRlbmN5IGRlcHRoKVxuICB2YXIgZW52UG9sbCA9IHByb2Nlc3MuZW52LkNIT0tJREFSX1VTRVBPTExJTkc7XG4gIGlmIChlbnZQb2xsICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZW52TG93ZXIgPSBlbnZQb2xsLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAoZW52TG93ZXIgPT09ICdmYWxzZScgfHwgZW52TG93ZXIgPT09ICcwJykge1xuICAgICAgb3B0cy51c2VQb2xsaW5nID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChlbnZMb3dlciA9PT0gJ3RydWUnIHx8IGVudkxvd2VyID09PSAnMScpIHtcbiAgICAgIG9wdHMudXNlUG9sbGluZyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdHMudXNlUG9sbGluZyA9ICEhZW52TG93ZXJcbiAgICB9XG4gIH1cblxuICAvLyBFZGl0b3IgYXRvbWljIHdyaXRlIG5vcm1hbGl6YXRpb24gZW5hYmxlZCBieSBkZWZhdWx0IHdpdGggZnMud2F0Y2hcbiAgaWYgKHVuZGVmKCdhdG9taWMnKSkgb3B0cy5hdG9taWMgPSAhb3B0cy51c2VQb2xsaW5nICYmICFvcHRzLnVzZUZzRXZlbnRzO1xuICBpZiAob3B0cy5hdG9taWMpIHRoaXMuX3BlbmRpbmdVbmxpbmtzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBpZiAodW5kZWYoJ2ZvbGxvd1N5bWxpbmtzJykpIG9wdHMuZm9sbG93U3ltbGlua3MgPSB0cnVlO1xuXG4gIGlmICh1bmRlZignYXdhaXRXcml0ZUZpbmlzaCcpKSBvcHRzLmF3YWl0V3JpdGVGaW5pc2ggPSBmYWxzZTtcbiAgaWYgKG9wdHMuYXdhaXRXcml0ZUZpbmlzaCA9PT0gdHJ1ZSkgb3B0cy5hd2FpdFdyaXRlRmluaXNoID0ge307XG4gIHZhciBhd2YgPSBvcHRzLmF3YWl0V3JpdGVGaW5pc2g7XG4gIGlmIChhd2YpIHtcbiAgICBpZiAoIWF3Zi5zdGFiaWxpdHlUaHJlc2hvbGQpIGF3Zi5zdGFiaWxpdHlUaHJlc2hvbGQgPSAyMDAwO1xuICAgIGlmICghYXdmLnBvbGxJbnRlcnZhbCkgYXdmLnBvbGxJbnRlcnZhbCA9IDEwMDtcblxuICAgIHRoaXMuX3BlbmRpbmdXcml0ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIGlmIChvcHRzLmlnbm9yZWQpIG9wdHMuaWdub3JlZCA9IGFycmlmeShvcHRzLmlnbm9yZWQpO1xuXG4gIHRoaXMuX2lzbnRJZ25vcmVkID0gZnVuY3Rpb24ocGF0aCwgc3RhdCkge1xuICAgIHJldHVybiAhdGhpcy5faXNJZ25vcmVkKHBhdGgsIHN0YXQpO1xuICB9LmJpbmQodGhpcyk7XG5cbiAgdmFyIHJlYWR5Q2FsbHMgPSAwO1xuICB0aGlzLl9lbWl0UmVhZHkgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoKytyZWFkeUNhbGxzID49IHRoaXMuX3JlYWR5Q291bnQpIHtcbiAgICAgIHRoaXMuX2VtaXRSZWFkeSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbiAgICAgIHRoaXMuX3JlYWR5RW1pdHRlZCA9IHRydWU7XG4gICAgICAvLyB1c2UgcHJvY2Vzcy5uZXh0VGljayB0byBhbGxvdyB0aW1lIGZvciBsaXN0ZW5lciB0byBiZSBib3VuZFxuICAgICAgcHJvY2Vzcy5uZXh0VGljayh0aGlzLmVtaXQuYmluZCh0aGlzLCAncmVhZHknKSk7XG4gICAgfVxuICB9LmJpbmQodGhpcyk7XG5cbiAgdGhpcy5vcHRpb25zID0gb3B0cztcblxuICAvLyBZb3XigJlyZSBmcm96ZW4gd2hlbiB5b3VyIGhlYXJ04oCZcyBub3Qgb3Blbi5cbiAgT2JqZWN0LmZyZWV6ZShvcHRzKTtcbn1cblxuaW5oZXJpdHMoRlNXYXRjaGVyLCBFdmVudEVtaXR0ZXIpO1xuXG4vLyBDb21tb24gaGVscGVyc1xuLy8gLS0tLS0tLS0tLS0tLS1cblxuLy8gUHJpdmF0ZSBtZXRob2Q6IE5vcm1hbGl6ZSBhbmQgZW1pdCBldmVudHNcbi8vXG4vLyAqIGV2ZW50ICAgICAtIHN0cmluZywgdHlwZSBvZiBldmVudFxuLy8gKiBwYXRoICAgICAgLSBzdHJpbmcsIGZpbGUgb3IgZGlyZWN0b3J5IHBhdGhcbi8vICogdmFsWzEuLjNdIC0gYXJndW1lbnRzIHRvIGJlIHBhc3NlZCB3aXRoIGV2ZW50XG4vL1xuLy8gUmV0dXJucyB0aGUgZXJyb3IgaWYgZGVmaW5lZCwgb3RoZXJ3aXNlIHRoZSB2YWx1ZSBvZiB0aGVcbi8vIEZTV2F0Y2hlciBpbnN0YW5jZSdzIGBjbG9zZWRgIGZsYWdcbkZTV2F0Y2hlci5wcm90b3R5cGUuX2VtaXQgPSBmdW5jdGlvbihldmVudCwgcGF0aCwgdmFsMSwgdmFsMiwgdmFsMykge1xuICBpZiAodGhpcy5vcHRpb25zLmN3ZCkgcGF0aCA9IHN5c1BhdGgucmVsYXRpdmUodGhpcy5vcHRpb25zLmN3ZCwgcGF0aCk7XG4gIHZhciBhcmdzID0gW2V2ZW50LCBwYXRoXTtcbiAgaWYgKHZhbDMgIT09IHVuZGVmaW5lZCkgYXJncy5wdXNoKHZhbDEsIHZhbDIsIHZhbDMpO1xuICBlbHNlIGlmICh2YWwyICE9PSB1bmRlZmluZWQpIGFyZ3MucHVzaCh2YWwxLCB2YWwyKTtcbiAgZWxzZSBpZiAodmFsMSAhPT0gdW5kZWZpbmVkKSBhcmdzLnB1c2godmFsMSk7XG5cbiAgdmFyIGF3ZiA9IHRoaXMub3B0aW9ucy5hd2FpdFdyaXRlRmluaXNoO1xuICBpZiAoYXdmICYmIHRoaXMuX3BlbmRpbmdXcml0ZXNbcGF0aF0pIHtcbiAgICB0aGlzLl9wZW5kaW5nV3JpdGVzW3BhdGhdLmxhc3RDaGFuZ2UgPSBuZXcgRGF0ZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5hdG9taWMpIHtcbiAgICBpZiAoZXZlbnQgPT09ICd1bmxpbmsnKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nVW5saW5rc1twYXRoXSA9IGFyZ3M7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9wZW5kaW5nVW5saW5rcykuZm9yRWFjaChmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgICAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIHRoaXMuX3BlbmRpbmdVbmxpbmtzW3BhdGhdKTtcbiAgICAgICAgICB0aGlzLmVtaXQuYXBwbHkodGhpcywgWydhbGwnXS5jb25jYXQodGhpcy5fcGVuZGluZ1VubGlua3NbcGF0aF0pKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fcGVuZGluZ1VubGlua3NbcGF0aF07XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICB9LmJpbmQodGhpcyksIHR5cGVvZiB0aGlzLm9wdGlvbnMuYXRvbWljID09PSBcIm51bWJlclwiXG4gICAgICAgID8gdGhpcy5vcHRpb25zLmF0b21pY1xuICAgICAgICA6IDEwMCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2UgaWYgKGV2ZW50ID09PSAnYWRkJyAmJiB0aGlzLl9wZW5kaW5nVW5saW5rc1twYXRoXSkge1xuICAgICAgZXZlbnQgPSBhcmdzWzBdID0gJ2NoYW5nZSc7XG4gICAgICBkZWxldGUgdGhpcy5fcGVuZGluZ1VubGlua3NbcGF0aF07XG4gICAgfVxuICB9XG5cbiAgdmFyIGVtaXRFdmVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBpZiAoZXZlbnQgIT09ICdlcnJvcicpIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBbJ2FsbCddLmNvbmNhdChhcmdzKSk7XG4gIH0uYmluZCh0aGlzKTtcblxuICBpZiAoYXdmICYmIChldmVudCA9PT0gJ2FkZCcgfHwgZXZlbnQgPT09ICdjaGFuZ2UnKSAmJiB0aGlzLl9yZWFkeUVtaXR0ZWQpIHtcbiAgICB2YXIgYXdmRW1pdCA9IGZ1bmN0aW9uKGVyciwgc3RhdHMpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZXZlbnQgPSBhcmdzWzBdID0gJ2Vycm9yJztcbiAgICAgICAgYXJnc1sxXSA9IGVycjtcbiAgICAgICAgZW1pdEV2ZW50KCk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRzKSB7XG4gICAgICAgIC8vIGlmIHN0YXRzIGRvZXNuJ3QgZXhpc3QgdGhlIGZpbGUgbXVzdCBoYXZlIGJlZW4gZGVsZXRlZFxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgYXJnc1syXSA9IHN0YXRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFyZ3MucHVzaChzdGF0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZW1pdEV2ZW50KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuX2F3YWl0V3JpdGVGaW5pc2gocGF0aCwgYXdmLnN0YWJpbGl0eVRocmVzaG9sZCwgZXZlbnQsIGF3ZkVtaXQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKGV2ZW50ID09PSAnY2hhbmdlJykge1xuICAgIGlmICghdGhpcy5fdGhyb3R0bGUoJ2NoYW5nZScsIHBhdGgsIDUwKSkgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAoXG4gICAgdGhpcy5vcHRpb25zLmFsd2F5c1N0YXQgJiYgdmFsMSA9PT0gdW5kZWZpbmVkICYmXG4gICAgKGV2ZW50ID09PSAnYWRkJyB8fCBldmVudCA9PT0gJ2FkZERpcicgfHwgZXZlbnQgPT09ICdjaGFuZ2UnKVxuICApIHtcbiAgICB2YXIgZnVsbFBhdGggPSB0aGlzLm9wdGlvbnMuY3dkID8gc3lzUGF0aC5qb2luKHRoaXMub3B0aW9ucy5jd2QsIHBhdGgpIDogcGF0aDtcbiAgICBmcy5zdGF0KGZ1bGxQYXRoLCBmdW5jdGlvbihlcnJvciwgc3RhdHMpIHtcbiAgICAgIC8vIFN1cHByZXNzIGV2ZW50IHdoZW4gZnMuc3RhdCBmYWlscywgdG8gYXZvaWQgc2VuZGluZyB1bmRlZmluZWQgJ3N0YXQnXG4gICAgICBpZiAoZXJyb3IgfHwgIXN0YXRzKSByZXR1cm47XG5cbiAgICAgIGFyZ3MucHVzaChzdGF0cyk7XG4gICAgICBlbWl0RXZlbnQoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBlbWl0RXZlbnQoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gUHJpdmF0ZSBtZXRob2Q6IENvbW1vbiBoYW5kbGVyIGZvciBlcnJvcnNcbi8vXG4vLyAqIGVycm9yICAtIG9iamVjdCwgRXJyb3IgaW5zdGFuY2Vcbi8vXG4vLyBSZXR1cm5zIHRoZSBlcnJvciBpZiBkZWZpbmVkLCBvdGhlcndpc2UgdGhlIHZhbHVlIG9mIHRoZVxuLy8gRlNXYXRjaGVyIGluc3RhbmNlJ3MgYGNsb3NlZGAgZmxhZ1xuRlNXYXRjaGVyLnByb3RvdHlwZS5faGFuZGxlRXJyb3IgPSBmdW5jdGlvbihlcnJvcikge1xuICB2YXIgY29kZSA9IGVycm9yICYmIGVycm9yLmNvZGU7XG4gIHZhciBpcGUgPSB0aGlzLm9wdGlvbnMuaWdub3JlUGVybWlzc2lvbkVycm9ycztcbiAgaWYgKGVycm9yICYmXG4gICAgY29kZSAhPT0gJ0VOT0VOVCcgJiZcbiAgICBjb2RlICE9PSAnRU5PVERJUicgJiZcbiAgICAoIWlwZSB8fCAoY29kZSAhPT0gJ0VQRVJNJyAmJiBjb2RlICE9PSAnRUFDQ0VTJykpXG4gICkgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgcmV0dXJuIGVycm9yIHx8IHRoaXMuY2xvc2VkO1xufTtcblxuLy8gUHJpdmF0ZSBtZXRob2Q6IEhlbHBlciB1dGlsaXR5IGZvciB0aHJvdHRsaW5nXG4vL1xuLy8gKiBhY3Rpb24gIC0gc3RyaW5nLCB0eXBlIG9mIGFjdGlvbiBiZWluZyB0aHJvdHRsZWRcbi8vICogcGF0aCAgICAtIHN0cmluZywgcGF0aCBiZWluZyBhY3RlZCB1cG9uXG4vLyAqIHRpbWVvdXQgLSBpbnQsIGR1cmF0aW9uIG9mIHRpbWUgdG8gc3VwcHJlc3MgZHVwbGljYXRlIGFjdGlvbnNcbi8vXG4vLyBSZXR1cm5zIHRocm90dGxlIHRyYWNraW5nIG9iamVjdCBvciBmYWxzZSBpZiBhY3Rpb24gc2hvdWxkIGJlIHN1cHByZXNzZWRcbkZTV2F0Y2hlci5wcm90b3R5cGUuX3Rocm90dGxlID0gZnVuY3Rpb24oYWN0aW9uLCBwYXRoLCB0aW1lb3V0KSB7XG4gIGlmICghKGFjdGlvbiBpbiB0aGlzLl90aHJvdHRsZWQpKSB7XG4gICAgdGhpcy5fdGhyb3R0bGVkW2FjdGlvbl0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIHZhciB0aHJvdHRsZWQgPSB0aGlzLl90aHJvdHRsZWRbYWN0aW9uXTtcbiAgaWYgKHBhdGggaW4gdGhyb3R0bGVkKSByZXR1cm4gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGRlbGV0ZSB0aHJvdHRsZWRbcGF0aF07XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRPYmplY3QpO1xuICB9XG4gIHZhciB0aW1lb3V0T2JqZWN0ID0gc2V0VGltZW91dChjbGVhciwgdGltZW91dCk7XG4gIHRocm90dGxlZFtwYXRoXSA9IHt0aW1lb3V0T2JqZWN0OiB0aW1lb3V0T2JqZWN0LCBjbGVhcjogY2xlYXJ9O1xuICByZXR1cm4gdGhyb3R0bGVkW3BhdGhdO1xufTtcblxuLy8gUHJpdmF0ZSBtZXRob2Q6IEF3YWl0cyB3cml0ZSBvcGVyYXRpb24gdG8gZmluaXNoXG4vL1xuLy8gKiBwYXRoICAgIC0gc3RyaW5nLCBwYXRoIGJlaW5nIGFjdGVkIHVwb25cbi8vICogdGhyZXNob2xkIC0gaW50LCB0aW1lIGluIG1pbGxpc2Vjb25kcyBhIGZpbGUgc2l6ZSBtdXN0IGJlIGZpeGVkIGJlZm9yZVxuLy8gICAgICAgICAgICAgICAgICAgIGFja25vd2xlZGdlaW5nIHdyaXRlIG9wZXJhdGlvbiBpcyBmaW5pc2hlZFxuLy8gKiBhd2ZFbWl0IC0gZnVuY3Rpb24sIHRvIGJlIGNhbGxlZCB3aGVuIHJlYWR5IGZvciBldmVudCB0byBiZSBlbWl0dGVkXG4vLyBQb2xscyBhIG5ld2x5IGNyZWF0ZWQgZmlsZSBmb3Igc2l6ZSB2YXJpYXRpb25zLiBXaGVuIGZpbGVzIHNpemUgZG9lcyBub3Rcbi8vIGNoYW5nZSBmb3IgJ3RocmVzaG9sZCcgbWlsbGlzZWNvbmRzIGNhbGxzIGNhbGxiYWNrLlxuRlNXYXRjaGVyLnByb3RvdHlwZS5fYXdhaXRXcml0ZUZpbmlzaCA9IGZ1bmN0aW9uKHBhdGgsIHRocmVzaG9sZCwgZXZlbnQsIGF3ZkVtaXQpIHtcbiAgdmFyIHRpbWVvdXRIYW5kbGVyO1xuXG4gIHZhciBmdWxsUGF0aCA9IHBhdGg7XG4gIGlmICh0aGlzLm9wdGlvbnMuY3dkICYmICFpc0Fic29sdXRlKHBhdGgpKSB7XG4gICAgZnVsbFBhdGggPSBzeXNQYXRoLmpvaW4odGhpcy5vcHRpb25zLmN3ZCwgcGF0aCk7XG4gIH1cblxuICB2YXIgbm93ID0gbmV3IERhdGUoKTtcblxuICB2YXIgYXdhaXRXcml0ZUZpbmlzaCA9IChmdW5jdGlvbiAocHJldlN0YXQpIHtcbiAgICBmcy5zdGF0KGZ1bGxQYXRoLCBmdW5jdGlvbihlcnIsIGN1clN0YXQpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlICE9PSAnRU5PRU5UJykgYXdmRW1pdChlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICBpZiAocHJldlN0YXQgJiYgY3VyU3RhdC5zaXplICE9IHByZXZTdGF0LnNpemUpIHtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1dyaXRlc1twYXRoXS5sYXN0Q2hhbmdlID0gbm93O1xuICAgICAgfVxuXG4gICAgICBpZiAobm93IC0gdGhpcy5fcGVuZGluZ1dyaXRlc1twYXRoXS5sYXN0Q2hhbmdlID49IHRocmVzaG9sZCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fcGVuZGluZ1dyaXRlc1twYXRoXTtcbiAgICAgICAgYXdmRW1pdChudWxsLCBjdXJTdGF0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXRIYW5kbGVyID0gc2V0VGltZW91dChcbiAgICAgICAgICBhd2FpdFdyaXRlRmluaXNoLmJpbmQodGhpcywgY3VyU3RhdCksXG4gICAgICAgICAgdGhpcy5vcHRpb25zLmF3YWl0V3JpdGVGaW5pc2gucG9sbEludGVydmFsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfS5iaW5kKHRoaXMpKTtcblxuICBpZiAoIShwYXRoIGluIHRoaXMuX3BlbmRpbmdXcml0ZXMpKSB7XG4gICAgdGhpcy5fcGVuZGluZ1dyaXRlc1twYXRoXSA9IHtcbiAgICAgIGxhc3RDaGFuZ2U6IG5vdyxcbiAgICAgIGNhbmNlbFdhaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBkZWxldGUgdGhpcy5fcGVuZGluZ1dyaXRlc1twYXRoXTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRIYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfS5iaW5kKHRoaXMpXG4gICAgfTtcbiAgICB0aW1lb3V0SGFuZGxlciA9IHNldFRpbWVvdXQoXG4gICAgICBhd2FpdFdyaXRlRmluaXNoLmJpbmQodGhpcyksXG4gICAgICB0aGlzLm9wdGlvbnMuYXdhaXRXcml0ZUZpbmlzaC5wb2xsSW50ZXJ2YWxcbiAgICApO1xuICB9XG59O1xuXG4vLyBQcml2YXRlIG1ldGhvZDogRGV0ZXJtaW5lcyB3aGV0aGVyIHVzZXIgaGFzIGFza2VkIHRvIGlnbm9yZSB0aGlzIHBhdGhcbi8vXG4vLyAqIHBhdGggIC0gc3RyaW5nLCBwYXRoIHRvIGZpbGUgb3IgZGlyZWN0b3J5XG4vLyAqIHN0YXRzIC0gb2JqZWN0LCByZXN1bHQgb2YgZnMuc3RhdFxuLy9cbi8vIFJldHVybnMgYm9vbGVhblxudmFyIGRvdFJlID0gL1xcLi4qXFwuKHN3W3B4XSkkfFxcfiR8XFwuc3VibC4qXFwudG1wLztcbkZTV2F0Y2hlci5wcm90b3R5cGUuX2lzSWdub3JlZCA9IGZ1bmN0aW9uKHBhdGgsIHN0YXRzKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuYXRvbWljICYmIGRvdFJlLnRlc3QocGF0aCkpIHJldHVybiB0cnVlO1xuXG4gIGlmICghdGhpcy5fdXNlcklnbm9yZWQpIHtcbiAgICB2YXIgY3dkID0gdGhpcy5vcHRpb25zLmN3ZDtcbiAgICB2YXIgaWdub3JlZCA9IHRoaXMub3B0aW9ucy5pZ25vcmVkO1xuICAgIGlmIChjd2QgJiYgaWdub3JlZCkge1xuICAgICAgaWdub3JlZCA9IGlnbm9yZWQubWFwKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHJldHVybiBwYXRoO1xuICAgICAgICByZXR1cm4gaXNBYnNvbHV0ZShwYXRoKSA/IHBhdGggOiBzeXNQYXRoLmpvaW4oY3dkLCBwYXRoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgcGF0aHMgPSBhcnJpZnkoaWdub3JlZClcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHBhdGggPT09ICdzdHJpbmcnICYmICFpc0dsb2IocGF0aCk7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gcGF0aCArICcvKionO1xuICAgICAgfSk7XG4gICAgdGhpcy5fdXNlcklnbm9yZWQgPSBhbnltYXRjaChcbiAgICAgIHRoaXMuX2dsb2JJZ25vcmVkLmNvbmNhdChpZ25vcmVkKS5jb25jYXQocGF0aHMpXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl91c2VySWdub3JlZChbcGF0aCwgc3RhdHNdKTtcbn07XG5cbi8vIFByaXZhdGUgbWV0aG9kOiBQcm92aWRlcyBhIHNldCBvZiBjb21tb24gaGVscGVycyBhbmQgcHJvcGVydGllcyByZWxhdGluZyB0b1xuLy8gc3ltbGluayBhbmQgZ2xvYiBoYW5kbGluZ1xuLy9cbi8vICogcGF0aCAtIHN0cmluZywgZmlsZSwgZGlyZWN0b3J5LCBvciBnbG9iIHBhdHRlcm4gYmVpbmcgd2F0Y2hlZFxuLy8gKiBkZXB0aCAtIGludCwgYXQgYW55IGRlcHRoID4gMCwgdGhpcyBpc24ndCBhIGdsb2Jcbi8vXG4vLyBSZXR1cm5zIG9iamVjdCBjb250YWluaW5nIGhlbHBlcnMgZm9yIHRoaXMgcGF0aFxudmFyIHJlcGxhY2VyUmUgPSAvXlxcLltcXC9cXFxcXS87XG5GU1dhdGNoZXIucHJvdG90eXBlLl9nZXRXYXRjaEhlbHBlcnMgPSBmdW5jdGlvbihwYXRoLCBkZXB0aCkge1xuICBwYXRoID0gcGF0aC5yZXBsYWNlKHJlcGxhY2VyUmUsICcnKTtcbiAgdmFyIHdhdGNoUGF0aCA9IGRlcHRoIHx8ICFpc0dsb2IocGF0aCkgPyBwYXRoIDogZ2xvYlBhcmVudChwYXRoKTtcbiAgdmFyIGZ1bGxXYXRjaFBhdGggPSBzeXNQYXRoLnJlc29sdmUod2F0Y2hQYXRoKTtcbiAgdmFyIGhhc0dsb2IgPSB3YXRjaFBhdGggIT09IHBhdGg7XG4gIHZhciBnbG9iRmlsdGVyID0gaGFzR2xvYiA/IGFueW1hdGNoKHBhdGgpIDogZmFsc2U7XG4gIHZhciBmb2xsb3cgPSB0aGlzLm9wdGlvbnMuZm9sbG93U3ltbGlua3M7XG4gIHZhciBnbG9iU3ltbGluayA9IGhhc0dsb2IgJiYgZm9sbG93ID8gbnVsbCA6IGZhbHNlO1xuXG4gIHZhciBjaGVja0dsb2JTeW1saW5rID0gZnVuY3Rpb24oZW50cnkpIHtcbiAgICAvLyBvbmx5IG5lZWQgdG8gcmVzb2x2ZSBvbmNlXG4gICAgLy8gZmlyc3QgZW50cnkgc2hvdWxkIGFsd2F5cyBoYXZlIGVudHJ5LnBhcmVudERpciA9PT0gJydcbiAgICBpZiAoZ2xvYlN5bWxpbmsgPT0gbnVsbCkge1xuICAgICAgZ2xvYlN5bWxpbmsgPSBlbnRyeS5mdWxsUGFyZW50RGlyID09PSBmdWxsV2F0Y2hQYXRoID8gZmFsc2UgOiB7XG4gICAgICAgIHJlYWxQYXRoOiBlbnRyeS5mdWxsUGFyZW50RGlyLFxuICAgICAgICBsaW5rUGF0aDogZnVsbFdhdGNoUGF0aFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoZ2xvYlN5bWxpbmspIHtcbiAgICAgIHJldHVybiBlbnRyeS5mdWxsUGF0aC5yZXBsYWNlKGdsb2JTeW1saW5rLnJlYWxQYXRoLCBnbG9iU3ltbGluay5saW5rUGF0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudHJ5LmZ1bGxQYXRoO1xuICB9O1xuXG4gIHZhciBlbnRyeVBhdGggPSBmdW5jdGlvbihlbnRyeSkge1xuICAgIHJldHVybiBzeXNQYXRoLmpvaW4od2F0Y2hQYXRoLFxuICAgICAgc3lzUGF0aC5yZWxhdGl2ZSh3YXRjaFBhdGgsIGNoZWNrR2xvYlN5bWxpbmsoZW50cnkpKVxuICAgICk7XG4gIH07XG5cbiAgdmFyIGZpbHRlclBhdGggPSBmdW5jdGlvbihlbnRyeSkge1xuICAgIGlmIChlbnRyeS5zdGF0ICYmIGVudHJ5LnN0YXQuaXNTeW1ib2xpY0xpbmsoKSkgcmV0dXJuIGZpbHRlckRpcihlbnRyeSk7XG4gICAgdmFyIHJlc29sdmVkUGF0aCA9IGVudHJ5UGF0aChlbnRyeSk7XG4gICAgcmV0dXJuICghaGFzR2xvYiB8fCBnbG9iRmlsdGVyKHJlc29sdmVkUGF0aCkpICYmXG4gICAgICB0aGlzLl9pc250SWdub3JlZChyZXNvbHZlZFBhdGgsIGVudHJ5LnN0YXQpICYmXG4gICAgICAodGhpcy5vcHRpb25zLmlnbm9yZVBlcm1pc3Npb25FcnJvcnMgfHxcbiAgICAgICAgdGhpcy5faGFzUmVhZFBlcm1pc3Npb25zKGVudHJ5LnN0YXQpKTtcbiAgfS5iaW5kKHRoaXMpO1xuXG4gIHZhciBnZXREaXJQYXJ0cyA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBpZiAoIWhhc0dsb2IpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgcGFydHMgPSBzeXNQYXRoLnJlbGF0aXZlKHdhdGNoUGF0aCwgcGF0aCkuc3BsaXQoL1tcXC9cXFxcXS8pO1xuICAgIHJldHVybiBwYXJ0cztcbiAgfTtcblxuICB2YXIgZGlyUGFydHMgPSBnZXREaXJQYXJ0cyhwYXRoKTtcbiAgaWYgKGRpclBhcnRzICYmIGRpclBhcnRzLmxlbmd0aCA+IDEpIGRpclBhcnRzLnBvcCgpO1xuICB2YXIgdW5tYXRjaGVkR2xvYjtcblxuICB2YXIgZmlsdGVyRGlyID0gZnVuY3Rpb24oZW50cnkpIHtcbiAgICBpZiAoaGFzR2xvYikge1xuICAgICAgdmFyIGVudHJ5UGFydHMgPSBnZXREaXJQYXJ0cyhjaGVja0dsb2JTeW1saW5rKGVudHJ5KSk7XG4gICAgICB2YXIgZ2xvYnN0YXIgPSBmYWxzZTtcbiAgICAgIHVubWF0Y2hlZEdsb2IgPSAhZGlyUGFydHMuZXZlcnkoZnVuY3Rpb24ocGFydCwgaSkge1xuICAgICAgICBpZiAocGFydCA9PT0gJyoqJykgZ2xvYnN0YXIgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZ2xvYnN0YXIgfHwgIWVudHJ5UGFydHNbaV0gfHwgYW55bWF0Y2gocGFydCwgZW50cnlQYXJ0c1tpXSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICF1bm1hdGNoZWRHbG9iICYmIHRoaXMuX2lzbnRJZ25vcmVkKGVudHJ5UGF0aChlbnRyeSksIGVudHJ5LnN0YXQpO1xuICB9LmJpbmQodGhpcyk7XG5cbiAgcmV0dXJuIHtcbiAgICBmb2xsb3dTeW1saW5rczogZm9sbG93LFxuICAgIHN0YXRNZXRob2Q6IGZvbGxvdyA/ICdzdGF0JyA6ICdsc3RhdCcsXG4gICAgcGF0aDogcGF0aCxcbiAgICB3YXRjaFBhdGg6IHdhdGNoUGF0aCxcbiAgICBlbnRyeVBhdGg6IGVudHJ5UGF0aCxcbiAgICBoYXNHbG9iOiBoYXNHbG9iLFxuICAgIGdsb2JGaWx0ZXI6IGdsb2JGaWx0ZXIsXG4gICAgZmlsdGVyUGF0aDogZmlsdGVyUGF0aCxcbiAgICBmaWx0ZXJEaXI6IGZpbHRlckRpclxuICB9O1xufTtcblxuLy8gRGlyZWN0b3J5IGhlbHBlcnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIFByaXZhdGUgbWV0aG9kOiBQcm92aWRlcyBkaXJlY3RvcnkgdHJhY2tpbmcgb2JqZWN0c1xuLy9cbi8vICogZGlyZWN0b3J5IC0gc3RyaW5nLCBwYXRoIG9mIHRoZSBkaXJlY3Rvcnlcbi8vXG4vLyBSZXR1cm5zIHRoZSBkaXJlY3RvcnkncyB0cmFja2luZyBvYmplY3RcbkZTV2F0Y2hlci5wcm90b3R5cGUuX2dldFdhdGNoZWREaXIgPSBmdW5jdGlvbihkaXJlY3RvcnkpIHtcbiAgdmFyIGRpciA9IHN5c1BhdGgucmVzb2x2ZShkaXJlY3RvcnkpO1xuICB2YXIgd2F0Y2hlclJlbW92ZSA9IHRoaXMuX3JlbW92ZS5iaW5kKHRoaXMpO1xuICBpZiAoIShkaXIgaW4gdGhpcy5fd2F0Y2hlZCkpIHRoaXMuX3dhdGNoZWRbZGlyXSA9IHtcbiAgICBfaXRlbXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgYWRkOiBmdW5jdGlvbihpdGVtKSB7XG4gICAgICBpZiAoaXRlbSAhPT0gJy4nKSB0aGlzLl9pdGVtc1tpdGVtXSA9IHRydWU7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9pdGVtc1tpdGVtXTtcbiAgICAgIGlmICghdGhpcy5jaGlsZHJlbigpLmxlbmd0aCkge1xuICAgICAgICBmcy5yZWFkZGlyKGRpciwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgaWYgKGVycikgd2F0Y2hlclJlbW92ZShzeXNQYXRoLmRpcm5hbWUoZGlyKSwgc3lzUGF0aC5iYXNlbmFtZShkaXIpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBoYXM6IGZ1bmN0aW9uKGl0ZW0pIHtyZXR1cm4gaXRlbSBpbiB0aGlzLl9pdGVtczt9LFxuICAgIGNoaWxkcmVuOiBmdW5jdGlvbigpIHtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5faXRlbXMpO31cbiAgfTtcbiAgcmV0dXJuIHRoaXMuX3dhdGNoZWRbZGlyXTtcbn07XG5cbi8vIEZpbGUgaGVscGVyc1xuLy8gLS0tLS0tLS0tLS0tXG5cbi8vIFByaXZhdGUgbWV0aG9kOiBDaGVjayBmb3IgcmVhZCBwZXJtaXNzaW9uc1xuLy8gQmFzZWQgb24gdGhpcyBhbnN3ZXIgb24gU086IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzExNzgxNDA0LzEzNTg0MDVcbi8vXG4vLyAqIHN0YXRzIC0gb2JqZWN0LCByZXN1bHQgb2YgZnMuc3RhdFxuLy9cbi8vIFJldHVybnMgYm9vbGVhblxuRlNXYXRjaGVyLnByb3RvdHlwZS5faGFzUmVhZFBlcm1pc3Npb25zID0gZnVuY3Rpb24oc3RhdHMpIHtcbiAgcmV0dXJuIEJvb2xlYW4oNCAmIHBhcnNlSW50KCgoc3RhdHMgJiYgc3RhdHMubW9kZSkgJiAweDFmZikudG9TdHJpbmcoOClbMF0sIDEwKSk7XG59O1xuXG4vLyBQcml2YXRlIG1ldGhvZDogSGFuZGxlcyBlbWl0dGluZyB1bmxpbmsgZXZlbnRzIGZvclxuLy8gZmlsZXMgYW5kIGRpcmVjdG9yaWVzLCBhbmQgdmlhIHJlY3Vyc2lvbiwgZm9yXG4vLyBmaWxlcyBhbmQgZGlyZWN0b3JpZXMgd2l0aGluIGRpcmVjdG9yaWVzIHRoYXQgYXJlIHVubGlua2VkXG4vL1xuLy8gKiBkaXJlY3RvcnkgLSBzdHJpbmcsIGRpcmVjdG9yeSB3aXRoaW4gd2hpY2ggdGhlIGZvbGxvd2luZyBpdGVtIGlzIGxvY2F0ZWRcbi8vICogaXRlbSAgICAgIC0gc3RyaW5nLCBiYXNlIHBhdGggb2YgaXRlbS9kaXJlY3Rvcnlcbi8vXG4vLyBSZXR1cm5zIG5vdGhpbmdcbkZTV2F0Y2hlci5wcm90b3R5cGUuX3JlbW92ZSA9IGZ1bmN0aW9uKGRpcmVjdG9yeSwgaXRlbSkge1xuICAvLyBpZiB3aGF0IGlzIGJlaW5nIGRlbGV0ZWQgaXMgYSBkaXJlY3RvcnksIGdldCB0aGF0IGRpcmVjdG9yeSdzIHBhdGhzXG4gIC8vIGZvciByZWN1cnNpdmUgZGVsZXRpbmcgYW5kIGNsZWFuaW5nIG9mIHdhdGNoZWQgb2JqZWN0XG4gIC8vIGlmIGl0IGlzIG5vdCBhIGRpcmVjdG9yeSwgbmVzdGVkRGlyZWN0b3J5Q2hpbGRyZW4gd2lsbCBiZSBlbXB0eSBhcnJheVxuICB2YXIgcGF0aCA9IHN5c1BhdGguam9pbihkaXJlY3RvcnksIGl0ZW0pO1xuICB2YXIgZnVsbFBhdGggPSBzeXNQYXRoLnJlc29sdmUocGF0aCk7XG4gIHZhciBpc0RpcmVjdG9yeSA9IHRoaXMuX3dhdGNoZWRbcGF0aF0gfHwgdGhpcy5fd2F0Y2hlZFtmdWxsUGF0aF07XG5cbiAgLy8gcHJldmVudCBkdXBsaWNhdGUgaGFuZGxpbmcgaW4gY2FzZSBvZiBhcnJpdmluZyBoZXJlIG5lYXJseSBzaW11bHRhbmVvdXNseVxuICAvLyB2aWEgbXVsdGlwbGUgcGF0aHMgKHN1Y2ggYXMgX2hhbmRsZUZpbGUgYW5kIF9oYW5kbGVEaXIpXG4gIGlmICghdGhpcy5fdGhyb3R0bGUoJ3JlbW92ZScsIHBhdGgsIDEwMCkpIHJldHVybjtcblxuICAvLyBpZiB0aGUgb25seSB3YXRjaGVkIGZpbGUgaXMgcmVtb3ZlZCwgd2F0Y2ggZm9yIGl0cyByZXR1cm5cbiAgdmFyIHdhdGNoZWREaXJzID0gT2JqZWN0LmtleXModGhpcy5fd2F0Y2hlZCk7XG4gIGlmICghaXNEaXJlY3RvcnkgJiYgIXRoaXMub3B0aW9ucy51c2VGc0V2ZW50cyAmJiB3YXRjaGVkRGlycy5sZW5ndGggPT09IDEpIHtcbiAgICB0aGlzLmFkZChkaXJlY3RvcnksIGl0ZW0sIHRydWUpO1xuICB9XG5cbiAgLy8gVGhpcyB3aWxsIGNyZWF0ZSBhIG5ldyBlbnRyeSBpbiB0aGUgd2F0Y2hlZCBvYmplY3QgaW4gZWl0aGVyIGNhc2VcbiAgLy8gc28gd2UgZ290IHRvIGRvIHRoZSBkaXJlY3RvcnkgY2hlY2sgYmVmb3JlaGFuZFxuICB2YXIgbmVzdGVkRGlyZWN0b3J5Q2hpbGRyZW4gPSB0aGlzLl9nZXRXYXRjaGVkRGlyKHBhdGgpLmNoaWxkcmVuKCk7XG5cbiAgLy8gUmVjdXJzaXZlbHkgcmVtb3ZlIGNoaWxkcmVuIGRpcmVjdG9yaWVzIC8gZmlsZXMuXG4gIG5lc3RlZERpcmVjdG9yeUNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24obmVzdGVkSXRlbSkge1xuICAgIHRoaXMuX3JlbW92ZShwYXRoLCBuZXN0ZWRJdGVtKTtcbiAgfSwgdGhpcyk7XG5cbiAgLy8gQ2hlY2sgaWYgaXRlbSB3YXMgb24gdGhlIHdhdGNoZWQgbGlzdCBhbmQgcmVtb3ZlIGl0XG4gIHZhciBwYXJlbnQgPSB0aGlzLl9nZXRXYXRjaGVkRGlyKGRpcmVjdG9yeSk7XG4gIHZhciB3YXNUcmFja2VkID0gcGFyZW50LmhhcyhpdGVtKTtcbiAgcGFyZW50LnJlbW92ZShpdGVtKTtcblxuICAvLyBJZiB3ZSB3YWl0IGZvciB0aGlzIGZpbGUgdG8gYmUgZnVsbHkgd3JpdHRlbiwgY2FuY2VsIHRoZSB3YWl0LlxuICB2YXIgcmVsUGF0aCA9IHBhdGg7XG4gIGlmICh0aGlzLm9wdGlvbnMuY3dkKSByZWxQYXRoID0gc3lzUGF0aC5yZWxhdGl2ZSh0aGlzLm9wdGlvbnMuY3dkLCBwYXRoKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5hd2FpdFdyaXRlRmluaXNoICYmIHRoaXMuX3BlbmRpbmdXcml0ZXNbcmVsUGF0aF0pIHtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLl9wZW5kaW5nV3JpdGVzW3JlbFBhdGhdLmNhbmNlbFdhaXQoKTtcbiAgICBpZiAoZXZlbnQgPT09ICdhZGQnKSByZXR1cm47XG4gIH1cblxuICAvLyBUaGUgRW50cnkgd2lsbCBlaXRoZXIgYmUgYSBkaXJlY3RvcnkgdGhhdCBqdXN0IGdvdCByZW1vdmVkXG4gIC8vIG9yIGEgYm9ndXMgZW50cnkgdG8gYSBmaWxlLCBpbiBlaXRoZXIgY2FzZSB3ZSBoYXZlIHRvIHJlbW92ZSBpdFxuICBkZWxldGUgdGhpcy5fd2F0Y2hlZFtwYXRoXTtcbiAgZGVsZXRlIHRoaXMuX3dhdGNoZWRbZnVsbFBhdGhdO1xuICB2YXIgZXZlbnROYW1lID0gaXNEaXJlY3RvcnkgPyAndW5saW5rRGlyJyA6ICd1bmxpbmsnO1xuICBpZiAod2FzVHJhY2tlZCAmJiAhdGhpcy5faXNJZ25vcmVkKHBhdGgpKSB0aGlzLl9lbWl0KGV2ZW50TmFtZSwgcGF0aCk7XG5cbiAgLy8gQXZvaWQgY29uZmxpY3RzIGlmIHdlIGxhdGVyIGNyZWF0ZSBhbm90aGVyIGZpbGUgd2l0aCB0aGUgc2FtZSBuYW1lXG4gIGlmICghdGhpcy5vcHRpb25zLnVzZUZzRXZlbnRzKSB7XG4gICAgdGhpcy5fY2xvc2VQYXRoKHBhdGgpO1xuICB9XG59O1xuXG5GU1dhdGNoZXIucHJvdG90eXBlLl9jbG9zZVBhdGggPSBmdW5jdGlvbihwYXRoKSB7XG4gIGlmICghdGhpcy5fY2xvc2Vyc1twYXRoXSkgcmV0dXJuO1xuICB0aGlzLl9jbG9zZXJzW3BhdGhdKCk7XG4gIGRlbGV0ZSB0aGlzLl9jbG9zZXJzW3BhdGhdO1xuICB0aGlzLl9nZXRXYXRjaGVkRGlyKHN5c1BhdGguZGlybmFtZShwYXRoKSkucmVtb3ZlKHN5c1BhdGguYmFzZW5hbWUocGF0aCkpO1xufVxuXG4vLyBQdWJsaWMgbWV0aG9kOiBBZGRzIHBhdGhzIHRvIGJlIHdhdGNoZWQgb24gYW4gZXhpc3RpbmcgRlNXYXRjaGVyIGluc3RhbmNlXG5cbi8vICogcGF0aHMgICAgIC0gc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MsIGZpbGUvZGlyZWN0b3J5IHBhdGhzIGFuZC9vciBnbG9ic1xuLy8gKiBfb3JpZ0FkZCAgLSBwcml2YXRlIGJvb2xlYW4sIGZvciBoYW5kbGluZyBub24tZXhpc3RlbnQgcGF0aHMgdG8gYmUgd2F0Y2hlZFxuLy8gKiBfaW50ZXJuYWwgLSBwcml2YXRlIGJvb2xlYW4sIGluZGljYXRlcyBhIG5vbi11c2VyIGFkZFxuXG4vLyBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIEZTV2F0Y2hlciBmb3IgY2hhaW5pbmcuXG5GU1dhdGNoZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHBhdGhzLCBfb3JpZ0FkZCwgX2ludGVybmFsKSB7XG4gIHZhciBjd2QgPSB0aGlzLm9wdGlvbnMuY3dkO1xuICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICBwYXRocyA9IGZsYXR0ZW4oYXJyaWZ5KHBhdGhzKSk7XG5cbiAgaWYgKCFwYXRocy5ldmVyeShpc1N0cmluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb24tc3RyaW5nIHByb3ZpZGVkIGFzIHdhdGNoIHBhdGg6ICcgKyBwYXRocyk7XG4gIH1cblxuICBpZiAoY3dkKSBwYXRocyA9IHBhdGhzLm1hcChmdW5jdGlvbihwYXRoKSB7XG4gICAgaWYgKGlzQWJzb2x1dGUocGF0aCkpIHtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH0gZWxzZSBpZiAocGF0aFswXSA9PT0gJyEnKSB7XG4gICAgICByZXR1cm4gJyEnICsgc3lzUGF0aC5qb2luKGN3ZCwgcGF0aC5zdWJzdHJpbmcoMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3lzUGF0aC5qb2luKGN3ZCwgcGF0aCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBzZXQgYXNpZGUgbmVnYXRlZCBnbG9iIHN0cmluZ3NcbiAgcGF0aHMgPSBwYXRocy5maWx0ZXIoZnVuY3Rpb24ocGF0aCkge1xuICAgIGlmIChwYXRoWzBdID09PSAnIScpIHtcbiAgICAgIHRoaXMuX2lnbm9yZWRQYXRoc1twYXRoLnN1YnN0cmluZygxKV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBhIHBhdGggaXMgYmVpbmcgYWRkZWQgdGhhdCB3YXMgcHJldmlvdXNseSBpZ25vcmVkLCBzdG9wIGlnbm9yaW5nIGl0XG4gICAgICBkZWxldGUgdGhpcy5faWdub3JlZFBhdGhzW3BhdGhdO1xuICAgICAgZGVsZXRlIHRoaXMuX2lnbm9yZWRQYXRoc1twYXRoICsgJy8qKiddO1xuXG4gICAgICAvLyByZXNldCB0aGUgY2FjaGVkIHVzZXJJZ25vcmVkIGFueW1hdGNoIGZuXG4gICAgICAvLyB0byBtYWtlIGlnbm9yZWRQYXRocyBjaGFuZ2VzIGVmZmVjdGl2ZVxuICAgICAgdGhpcy5fdXNlcklnbm9yZWQgPSBudWxsO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHRoaXMpO1xuXG4gIGlmICh0aGlzLm9wdGlvbnMudXNlRnNFdmVudHMgJiYgRnNFdmVudHNIYW5kbGVyLmNhblVzZSgpKSB7XG4gICAgaWYgKCF0aGlzLl9yZWFkeUNvdW50KSB0aGlzLl9yZWFkeUNvdW50ID0gcGF0aHMubGVuZ3RoO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucGVyc2lzdGVudCkgdGhpcy5fcmVhZHlDb3VudCAqPSAyO1xuICAgIHBhdGhzLmZvckVhY2godGhpcy5fYWRkVG9Gc0V2ZW50cywgdGhpcyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCF0aGlzLl9yZWFkeUNvdW50KSB0aGlzLl9yZWFkeUNvdW50ID0gMDtcbiAgICB0aGlzLl9yZWFkeUNvdW50ICs9IHBhdGhzLmxlbmd0aDtcbiAgICBhc3luY0VhY2gocGF0aHMsIGZ1bmN0aW9uKHBhdGgsIG5leHQpIHtcbiAgICAgIHRoaXMuX2FkZFRvTm9kZUZzKHBhdGgsICFfaW50ZXJuYWwsIDAsIDAsIF9vcmlnQWRkLCBmdW5jdGlvbihlcnIsIHJlcykge1xuICAgICAgICBpZiAocmVzKSB0aGlzLl9lbWl0UmVhZHkoKTtcbiAgICAgICAgbmV4dChlcnIsIHJlcyk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0uYmluZCh0aGlzKSwgZnVuY3Rpb24oZXJyb3IsIHJlc3VsdHMpIHtcbiAgICAgIHJlc3VsdHMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIGlmICghaXRlbSkgcmV0dXJuO1xuICAgICAgICB0aGlzLmFkZChzeXNQYXRoLmRpcm5hbWUoaXRlbSksIHN5c1BhdGguYmFzZW5hbWUoX29yaWdBZGQgfHwgaXRlbSkpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gUHVibGljIG1ldGhvZDogQ2xvc2Ugd2F0Y2hlcnMgb3Igc3RhcnQgaWdub3JpbmcgZXZlbnRzIGZyb20gc3BlY2lmaWVkIHBhdGhzLlxuXG4vLyAqIHBhdGhzICAgICAtIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzLCBmaWxlL2RpcmVjdG9yeSBwYXRocyBhbmQvb3IgZ2xvYnNcblxuLy8gUmV0dXJucyBpbnN0YW5jZSBvZiBGU1dhdGNoZXIgZm9yIGNoYWluaW5nLlxuRlNXYXRjaGVyLnByb3RvdHlwZS51bndhdGNoID0gZnVuY3Rpb24ocGF0aHMpIHtcbiAgaWYgKHRoaXMuY2xvc2VkKSByZXR1cm4gdGhpcztcbiAgcGF0aHMgPSBmbGF0dGVuKGFycmlmeShwYXRocykpO1xuXG4gIHBhdGhzLmZvckVhY2goZnVuY3Rpb24ocGF0aCkge1xuICAgIC8vIGNvbnZlcnQgdG8gYWJzb2x1dGUgcGF0aCB1bmxlc3MgcmVsYXRpdmUgcGF0aCBhbHJlYWR5IG1hdGNoZXNcbiAgICBpZiAoIWlzQWJzb2x1dGUocGF0aCkgJiYgIXRoaXMuX2Nsb3NlcnNbcGF0aF0pIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY3dkKSBwYXRoID0gc3lzUGF0aC5qb2luKHRoaXMub3B0aW9ucy5jd2QsIHBhdGgpO1xuICAgICAgcGF0aCA9IHN5c1BhdGgucmVzb2x2ZShwYXRoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jbG9zZVBhdGgocGF0aCk7XG5cbiAgICB0aGlzLl9pZ25vcmVkUGF0aHNbcGF0aF0gPSB0cnVlO1xuICAgIGlmIChwYXRoIGluIHRoaXMuX3dhdGNoZWQpIHtcbiAgICAgIHRoaXMuX2lnbm9yZWRQYXRoc1twYXRoICsgJy8qKiddID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyByZXNldCB0aGUgY2FjaGVkIHVzZXJJZ25vcmVkIGFueW1hdGNoIGZuXG4gICAgLy8gdG8gbWFrZSBpZ25vcmVkUGF0aHMgY2hhbmdlcyBlZmZlY3RpdmVcbiAgICB0aGlzLl91c2VySWdub3JlZCA9IG51bGw7XG4gIH0sIHRoaXMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gUHVibGljIG1ldGhvZDogQ2xvc2Ugd2F0Y2hlcnMgYW5kIHJlbW92ZSBhbGwgbGlzdGVuZXJzIGZyb20gd2F0Y2hlZCBwYXRocy5cblxuLy8gUmV0dXJucyBpbnN0YW5jZSBvZiBGU1dhdGNoZXIgZm9yIGNoYWluaW5nLlxuRlNXYXRjaGVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jbG9zZWQpIHJldHVybiB0aGlzO1xuXG4gIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgT2JqZWN0LmtleXModGhpcy5fY2xvc2VycykuZm9yRWFjaChmdW5jdGlvbih3YXRjaFBhdGgpIHtcbiAgICB0aGlzLl9jbG9zZXJzW3dhdGNoUGF0aF0oKTtcbiAgICBkZWxldGUgdGhpcy5fY2xvc2Vyc1t3YXRjaFBhdGhdO1xuICB9LCB0aGlzKTtcbiAgdGhpcy5fd2F0Y2hlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBQdWJsaWMgbWV0aG9kOiBFeHBvc2UgbGlzdCBvZiB3YXRjaGVkIHBhdGhzXG5cbi8vIFJldHVybnMgb2JqZWN0IHcvIGRpciBwYXRocyBhcyBrZXlzIGFuZCBhcnJheXMgb2YgY29udGFpbmVkIHBhdGhzIGFzIHZhbHVlcy5cbkZTV2F0Y2hlci5wcm90b3R5cGUuZ2V0V2F0Y2hlZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgd2F0Y2hMaXN0ID0ge307XG4gIE9iamVjdC5rZXlzKHRoaXMuX3dhdGNoZWQpLmZvckVhY2goZnVuY3Rpb24oZGlyKSB7XG4gICAgdmFyIGtleSA9IHRoaXMub3B0aW9ucy5jd2QgPyBzeXNQYXRoLnJlbGF0aXZlKHRoaXMub3B0aW9ucy5jd2QsIGRpcikgOiBkaXI7XG4gICAgd2F0Y2hMaXN0W2tleSB8fCAnLiddID0gT2JqZWN0LmtleXModGhpcy5fd2F0Y2hlZFtkaXJdLl9pdGVtcykuc29ydCgpO1xuICB9LmJpbmQodGhpcykpO1xuICByZXR1cm4gd2F0Y2hMaXN0O1xufTtcblxuLy8gQXR0YWNoIHdhdGNoIGhhbmRsZXIgcHJvdG90eXBlIG1ldGhvZHNcbmZ1bmN0aW9uIGltcG9ydEhhbmRsZXIoaGFuZGxlcikge1xuICBPYmplY3Qua2V5cyhoYW5kbGVyLnByb3RvdHlwZSkuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICBGU1dhdGNoZXIucHJvdG90eXBlW21ldGhvZF0gPSBoYW5kbGVyLnByb3RvdHlwZVttZXRob2RdO1xuICB9KTtcbn1cbmltcG9ydEhhbmRsZXIoTm9kZUZzSGFuZGxlcik7XG5pZiAoRnNFdmVudHNIYW5kbGVyLmNhblVzZSgpKSBpbXBvcnRIYW5kbGVyKEZzRXZlbnRzSGFuZGxlcik7XG5cbi8vIEV4cG9ydCBGU1dhdGNoZXIgY2xhc3NcbmV4cG9ydHMuRlNXYXRjaGVyID0gRlNXYXRjaGVyO1xuXG4vLyBQdWJsaWMgZnVuY3Rpb246IEluc3RhbnRpYXRlcyB3YXRjaGVyIHdpdGggcGF0aHMgdG8gYmUgdHJhY2tlZC5cblxuLy8gKiBwYXRocyAgICAgLSBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncywgZmlsZS9kaXJlY3RvcnkgcGF0aHMgYW5kL29yIGdsb2JzXG4vLyAqIG9wdGlvbnMgICAtIG9iamVjdCwgY2hva2lkYXIgb3B0aW9uc1xuXG4vLyBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIEZTV2F0Y2hlciBmb3IgY2hhaW5pbmcuXG5leHBvcnRzLndhdGNoID0gZnVuY3Rpb24ocGF0aHMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBGU1dhdGNoZXIob3B0aW9ucykuYWRkKHBhdGhzKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY2hva2lkYXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBhc3luYy1lYWNoIE1JVCBsaWNlbnNlIChieSBQYXVsIE1pbGxlciBmcm9tIGh0dHA6Ly9wYXVsbWlsbHIuY29tKS5cbihmdW5jdGlvbihnbG9iYWxzKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyIGVhY2ggPSBmdW5jdGlvbihpdGVtcywgbmV4dCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdlYWNoKCkgZXhwZWN0cyBhcnJheSBhcyBmaXJzdCBhcmd1bWVudCcpO1xuICAgIGlmICh0eXBlb2YgbmV4dCAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcignZWFjaCgpIGV4cGVjdHMgZnVuY3Rpb24gYXMgc2Vjb25kIGFyZ3VtZW50Jyk7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2sgPSBGdW5jdGlvbi5wcm90b3R5cGU7IC8vIG5vLW9wXG5cbiAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSByZXR1cm4gY2FsbGJhY2sodW5kZWZpbmVkLCBpdGVtcyk7XG5cbiAgICB2YXIgdHJhbnNmb3JtZWQgPSBuZXcgQXJyYXkoaXRlbXMubGVuZ3RoKTtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciByZXR1cm5lZCA9IGZhbHNlO1xuXG4gICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuICAgICAgbmV4dChpdGVtLCBmdW5jdGlvbihlcnJvciwgdHJhbnNmb3JtZWRJdGVtKSB7XG4gICAgICAgIGlmIChyZXR1cm5lZCkgcmV0dXJuO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm5lZCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2Zvcm1lZFtpbmRleF0gPSB0cmFuc2Zvcm1lZEl0ZW07XG4gICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgIGlmIChjb3VudCA9PT0gaXRlbXMubGVuZ3RoKSByZXR1cm4gY2FsbGJhY2sodW5kZWZpbmVkLCB0cmFuc2Zvcm1lZCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBpZiAodHlwZW9mIGRlZmluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZWFjaDtcbiAgICB9KTsgLy8gUmVxdWlyZUpTXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGVhY2g7IC8vIENvbW1vbkpTXG4gIH0gZWxzZSB7XG4gICAgZ2xvYmFscy5hc3luY0VhY2ggPSBlYWNoOyAvLyA8c2NyaXB0PlxuICB9XG59KSh0aGlzKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hc3luYy1lYWNoL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXJyaWZ5ID0gcmVxdWlyZSgnYXJyaWZ5Jyk7XG52YXIgbWljcm9tYXRjaCA9IHJlcXVpcmUoJ21pY3JvbWF0Y2gnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG52YXIgYW55bWF0Y2ggPSBmdW5jdGlvbihjcml0ZXJpYSwgdmFsdWUsIHJldHVybkluZGV4LCBzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICBjcml0ZXJpYSA9IGFycmlmeShjcml0ZXJpYSk7XG4gIHZhbHVlID0gYXJyaWZ5KHZhbHVlKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gYW55bWF0Y2guYmluZChudWxsLCBjcml0ZXJpYS5tYXAoZnVuY3Rpb24oY3JpdGVyaW9uKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGNyaXRlcmlvbiA9PT0gJ3N0cmluZycgJiYgY3JpdGVyaW9uWzBdICE9PSAnIScgP1xuICAgICAgICBtaWNyb21hdGNoLm1hdGNoZXIoY3JpdGVyaW9uKSA6IGNyaXRlcmlvbjtcbiAgICB9KSk7XG4gIH1cbiAgc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXggfHwgMDtcbiAgdmFyIHN0cmluZyA9IHZhbHVlWzBdO1xuICB2YXIgYWx0U3RyaW5nO1xuICB2YXIgbWF0Y2hlZCA9IGZhbHNlO1xuICB2YXIgbWF0Y2hJbmRleCA9IC0xO1xuICBmdW5jdGlvbiB0ZXN0Q3JpdGVyaWEgKGNyaXRlcmlvbiwgaW5kZXgpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIHN3aXRjaCAodG9TdHJpbmcuY2FsbChjcml0ZXJpb24pKSB7XG4gICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcbiAgICAgIHJlc3VsdCA9IHN0cmluZyA9PT0gY3JpdGVyaW9uIHx8IGFsdFN0cmluZyAmJiBhbHRTdHJpbmcgPT09IGNyaXRlcmlvbjtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCB8fCBtaWNyb21hdGNoLmlzTWF0Y2goc3RyaW5nLCBjcml0ZXJpb24pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgIHJlc3VsdCA9IGNyaXRlcmlvbi50ZXN0KHN0cmluZykgfHwgYWx0U3RyaW5nICYmIGNyaXRlcmlvbi50ZXN0KGFsdFN0cmluZyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdbb2JqZWN0IEZ1bmN0aW9uXSc6XG4gICAgICByZXN1bHQgPSBjcml0ZXJpb24uYXBwbHkobnVsbCwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBtYXRjaEluZGV4ID0gaW5kZXggKyBzdGFydEluZGV4O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHZhciBjcml0ID0gY3JpdGVyaWE7XG4gIHZhciBuZWdHbG9icyA9IGNyaXQucmVkdWNlKGZ1bmN0aW9uKGFyciwgY3JpdGVyaW9uLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgY3JpdGVyaW9uID09PSAnc3RyaW5nJyAmJiBjcml0ZXJpb25bMF0gPT09ICchJykge1xuICAgICAgaWYgKGNyaXQgPT09IGNyaXRlcmlhKSB7XG4gICAgICAgIC8vIG1ha2UgYSBjb3B5IGJlZm9yZSBtb2RpZnlpbmdcbiAgICAgICAgY3JpdCA9IGNyaXQuc2xpY2UoKTtcbiAgICAgIH1cbiAgICAgIGNyaXRbaW5kZXhdID0gbnVsbDtcbiAgICAgIGFyci5wdXNoKGNyaXRlcmlvbi5zdWJzdHIoMSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xuICB9LCBbXSk7XG4gIGlmICghbmVnR2xvYnMubGVuZ3RoIHx8ICFtaWNyb21hdGNoLmFueShzdHJpbmcsIG5lZ0dsb2JzKSkge1xuICAgIGlmIChwYXRoLnNlcCA9PT0gJ1xcXFwnICYmIHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhbHRTdHJpbmcgPSBzdHJpbmcuc3BsaXQoJ1xcXFwnKS5qb2luKCcvJyk7XG4gICAgICBhbHRTdHJpbmcgPSBhbHRTdHJpbmcgPT09IHN0cmluZyA/IG51bGwgOiBhbHRTdHJpbmc7XG4gICAgfVxuICAgIG1hdGNoZWQgPSBjcml0LnNsaWNlKHN0YXJ0SW5kZXgsIGVuZEluZGV4KS5zb21lKHRlc3RDcml0ZXJpYSk7XG4gIH1cbiAgcmV0dXJuIHJldHVybkluZGV4ID09PSB0cnVlID8gbWF0Y2hJbmRleCA6IG1hdGNoZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFueW1hdGNoO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FueW1hdGNoL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblxuXHRyZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsIDogW3ZhbF07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FycmlmeS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogbWljcm9tYXRjaCA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvbWljcm9tYXRjaD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXhwYW5kID0gcmVxdWlyZSgnLi9saWIvZXhwYW5kJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL2xpYi91dGlscycpO1xuXG4vKipcbiAqIFRoZSBtYWluIGZ1bmN0aW9uLiBQYXNzIGFuIGFycmF5IG9mIGZpbGVwYXRocyxcbiAqIGFuZCBhIHN0cmluZyBvciBhcnJheSBvZiBnbG9iIHBhdHRlcm5zXG4gKlxuICogQHBhcmFtICB7QXJyYXl8U3RyaW5nfSBgZmlsZXNgXG4gKiBAcGFyYW0gIHtBcnJheXxTdHJpbmd9IGBwYXR0ZXJuc2BcbiAqIEBwYXJhbSAge09iamVjdH0gYG9wdHNgXG4gKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgbWF0Y2hlc1xuICovXG5cbmZ1bmN0aW9uIG1pY3JvbWF0Y2goZmlsZXMsIHBhdHRlcm5zLCBvcHRzKSB7XG4gIGlmICghZmlsZXMgfHwgIXBhdHRlcm5zKSByZXR1cm4gW107XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIGlmICh0eXBlb2Ygb3B0cy5jYWNoZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRzLmNhY2hlID0gdHJ1ZTtcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShwYXR0ZXJucykpIHtcbiAgICByZXR1cm4gbWF0Y2goZmlsZXMsIHBhdHRlcm5zLCBvcHRzKTtcbiAgfVxuXG4gIHZhciBsZW4gPSBwYXR0ZXJucy5sZW5ndGgsIGkgPSAwO1xuICB2YXIgb21pdCA9IFtdLCBrZWVwID0gW107XG5cbiAgd2hpbGUgKGxlbi0tKSB7XG4gICAgdmFyIGdsb2IgPSBwYXR0ZXJuc1tpKytdO1xuICAgIGlmICh0eXBlb2YgZ2xvYiA9PT0gJ3N0cmluZycgJiYgZ2xvYi5jaGFyQ29kZUF0KDApID09PSAzMyAvKiAhICovKSB7XG4gICAgICBvbWl0LnB1c2guYXBwbHkob21pdCwgbWF0Y2goZmlsZXMsIGdsb2Iuc2xpY2UoMSksIG9wdHMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAga2VlcC5wdXNoLmFwcGx5KGtlZXAsIG1hdGNoKGZpbGVzLCBnbG9iLCBvcHRzKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB1dGlscy5kaWZmKGtlZXAsIG9taXQpO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBvZiBmaWxlcyB0aGF0IG1hdGNoIHRoZSBnaXZlbiBnbG9iIHBhdHRlcm4uXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYnkgdGhlIG1haW4gYG1pY3JvbWF0Y2hgIGZ1bmN0aW9uIElmIHlvdSBvbmx5XG4gKiBuZWVkIHRvIHBhc3MgYSBzaW5nbGUgcGF0dGVybiB5b3UgbWlnaHQgZ2V0IHZlcnkgbWlub3Igc3BlZWQgaW1wcm92ZW1lbnRzXG4gKiB1c2luZyB0aGlzIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSBgZmlsZXNgXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGBwYXR0ZXJuYFxuICogQHBhcmFtICB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIG1hdGNoKGZpbGVzLCBwYXR0ZXJuLCBvcHRzKSB7XG4gIGlmICh1dGlscy50eXBlT2YoZmlsZXMpICE9PSAnc3RyaW5nJyAmJiAhQXJyYXkuaXNBcnJheShmaWxlcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKCdtYXRjaCcsICdmaWxlcycsICdhIHN0cmluZyBvciBhcnJheScpKTtcbiAgfVxuXG4gIGZpbGVzID0gdXRpbHMuYXJyYXlpZnkoZmlsZXMpO1xuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB2YXIgbmVnYXRlID0gb3B0cy5uZWdhdGUgfHwgZmFsc2U7XG4gIHZhciBvcmlnID0gcGF0dGVybjtcblxuICBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgbmVnYXRlID0gcGF0dGVybi5jaGFyQXQoMCkgPT09ICchJztcbiAgICBpZiAobmVnYXRlKSB7XG4gICAgICBwYXR0ZXJuID0gcGF0dGVybi5zbGljZSgxKTtcbiAgICB9XG5cbiAgICAvLyB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgY2hhcmFjdGVyIHJlZ2FyZGxlc3MsXG4gICAgLy8gc28gdGhlIGFib3ZlIGxvZ2ljIGlzIHN0aWxsIG5lZWRlZFxuICAgIGlmIChvcHRzLm5vbmVnYXRlID09PSB0cnVlKSB7XG4gICAgICBuZWdhdGUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB2YXIgX2lzTWF0Y2ggPSBtYXRjaGVyKHBhdHRlcm4sIG9wdHMpO1xuICB2YXIgbGVuID0gZmlsZXMubGVuZ3RoLCBpID0gMDtcbiAgdmFyIHJlcyA9IFtdO1xuXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgdmFyIGZpbGUgPSBmaWxlc1tpKytdO1xuICAgIHZhciBmcCA9IHV0aWxzLnVuaXhpZnkoZmlsZSwgb3B0cyk7XG5cbiAgICBpZiAoIV9pc01hdGNoKGZwKSkgeyBjb250aW51ZTsgfVxuICAgIHJlcy5wdXNoKGZwKTtcbiAgfVxuXG4gIGlmIChyZXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKG9wdHMuZmFpbGdsb2IgPT09IHRydWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWljcm9tYXRjaC5tYXRjaCgpIGZvdW5kIG5vIG1hdGNoZXMgZm9yOiBcIicgKyBvcmlnICsgJ1wiLicpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLm5vbnVsbCB8fCBvcHRzLm51bGxnbG9iKSB7XG4gICAgICByZXMucHVzaCh1dGlscy51bmVzY2FwZUdsb2Iob3JpZykpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIGBuZWdhdGVgIHdhcyBkZWZpbmVkLCBkaWZmIG5lZ2F0ZWQgZmlsZXNcbiAgaWYgKG5lZ2F0ZSkgeyByZXMgPSB1dGlscy5kaWZmKGZpbGVzLCByZXMpOyB9XG5cbiAgLy8gaWYgYGlnbm9yZWAgd2FzIGRlZmluZWQsIGRpZmYgaWdub3JlZCBmaWxlZFxuICBpZiAob3B0cy5pZ25vcmUgJiYgb3B0cy5pZ25vcmUubGVuZ3RoKSB7XG4gICAgcGF0dGVybiA9IG9wdHMuaWdub3JlO1xuICAgIG9wdHMgPSB1dGlscy5vbWl0KG9wdHMsIFsnaWdub3JlJ10pO1xuICAgIHJlcyA9IHV0aWxzLmRpZmYocmVzLCBtaWNyb21hdGNoKHJlcywgcGF0dGVybiwgb3B0cykpO1xuICB9XG5cbiAgaWYgKG9wdHMubm9kdXBlcykge1xuICAgIHJldHVybiB1dGlscy51bmlxdWUocmVzKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgZ2xvYiBwYXR0ZXJuIG9yIGFycmF5IG9mIGdsb2IgcGF0dGVybnNcbiAqIHRvIGJlIHVzZWQgd2l0aCBgQXJyYXkjZmlsdGVyKClgLiAoSW50ZXJuYWxseSB0aGlzIGZ1bmN0aW9uIGdlbmVyYXRlc1xuICogdGhlIG1hdGNoaW5nIGZ1bmN0aW9uIHVzaW5nIHRoZSBbbWF0Y2hlcl0gbWV0aG9kKS5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGZuID0gbW0uZmlsdGVyKCdbYS1jXScpO1xuICogWydhJywgJ2InLCAnYycsICdkJywgJ2UnXS5maWx0ZXIoZm4pO1xuICogLy89PiBbJ2EnLCAnYicsICdjJ11cbiAqIGBgYFxuICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSBgcGF0dGVybnNgIENhbiBiZSBhIGdsb2Igb3IgYXJyYXkgb2YgZ2xvYnMuXG4gKiBAcGFyYW0gIHtPcHRpb25zfSBgb3B0c2AgT3B0aW9ucyB0byBwYXNzIHRvIHRoZSBbbWF0Y2hlcl0gbWV0aG9kLlxuICogQHJldHVybiB7RnVuY3Rpb259IEZpbHRlciBmdW5jdGlvbiB0byBiZSBwYXNzZWQgdG8gYEFycmF5I2ZpbHRlcigpYC5cbiAqL1xuXG5mdW5jdGlvbiBmaWx0ZXIocGF0dGVybnMsIG9wdHMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhdHRlcm5zKSAmJiB0eXBlb2YgcGF0dGVybnMgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtc2coJ2ZpbHRlcicsICdwYXR0ZXJucycsICdhIHN0cmluZyBvciBhcnJheScpKTtcbiAgfVxuXG4gIHBhdHRlcm5zID0gdXRpbHMuYXJyYXlpZnkocGF0dGVybnMpO1xuICB2YXIgbGVuID0gcGF0dGVybnMubGVuZ3RoLCBpID0gMDtcbiAgdmFyIHBhdHRlcm5NYXRjaGVycyA9IEFycmF5KGxlbik7XG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcGF0dGVybk1hdGNoZXJzW2ldID0gbWF0Y2hlcihwYXR0ZXJuc1tpKytdLCBvcHRzKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbihmcCkge1xuICAgIGlmIChmcCA9PSBudWxsKSByZXR1cm4gW107XG4gICAgdmFyIGxlbiA9IHBhdHRlcm5NYXRjaGVycy5sZW5ndGgsIGkgPSAwO1xuICAgIHZhciByZXMgPSB0cnVlO1xuXG4gICAgZnAgPSB1dGlscy51bml4aWZ5KGZwLCBvcHRzKTtcbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgdmFyIGZuID0gcGF0dGVybk1hdGNoZXJzW2krK107XG4gICAgICBpZiAoIWZuKGZwKSkge1xuICAgICAgICByZXMgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBmaWxlcGF0aCBjb250YWlucyB0aGUgZ2l2ZW5cbiAqIHBhdHRlcm4uIENhbiBhbHNvIHJldHVybiBhIGZ1bmN0aW9uIGZvciBtYXRjaGluZy5cbiAqXG4gKiBgYGBqc1xuICogaXNNYXRjaCgnZm9vLm1kJywgJyoubWQnLCB7fSk7XG4gKiAvLz0+IHRydWVcbiAqXG4gKiBpc01hdGNoKCcqLm1kJywge30pKCdmb28ubWQnKVxuICogLy89PiB0cnVlXG4gKiBgYGBcbiAqIEBwYXJhbSAge1N0cmluZ30gYGZwYFxuICogQHBhcmFtICB7U3RyaW5nfSBgcGF0dGVybmBcbiAqIEBwYXJhbSAge09iamVjdH0gYG9wdHNgXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzTWF0Y2goZnAsIHBhdHRlcm4sIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiBmcCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG1zZygnaXNNYXRjaCcsICdmaWxlcGF0aCcsICdhIHN0cmluZycpKTtcbiAgfVxuXG4gIGZwID0gdXRpbHMudW5peGlmeShmcCwgb3B0cyk7XG4gIGlmICh1dGlscy50eXBlT2YocGF0dGVybikgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hdGNoZXIoZnAsIHBhdHRlcm4pO1xuICB9XG4gIHJldHVybiBtYXRjaGVyKHBhdHRlcm4sIG9wdHMpKGZwKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGZpbGVwYXRoIG1hdGNoZXMgdGhlXG4gKiBnaXZlbiBwYXR0ZXJuLlxuICovXG5cbmZ1bmN0aW9uIGNvbnRhaW5zKGZwLCBwYXR0ZXJuLCBvcHRzKSB7XG4gIGlmICh0eXBlb2YgZnAgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtc2coJ2NvbnRhaW5zJywgJ3BhdHRlcm4nLCAnYSBzdHJpbmcnKSk7XG4gIH1cblxuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgb3B0cy5jb250YWlucyA9IChwYXR0ZXJuICE9PSAnJyk7XG4gIGZwID0gdXRpbHMudW5peGlmeShmcCwgb3B0cyk7XG5cbiAgaWYgKG9wdHMuY29udGFpbnMgJiYgIXV0aWxzLmlzR2xvYihwYXR0ZXJuKSkge1xuICAgIHJldHVybiBmcC5pbmRleE9mKHBhdHRlcm4pICE9PSAtMTtcbiAgfVxuICByZXR1cm4gbWF0Y2hlcihwYXR0ZXJuLCBvcHRzKShmcCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgZmlsZSBwYXRoIG1hdGNoZXMgYW55IG9mIHRoZVxuICogZ2l2ZW4gcGF0dGVybnMuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBgZnBgIFRoZSBmaWxlcGF0aCB0byB0ZXN0LlxuICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSBgcGF0dGVybnNgIEdsb2IgcGF0dGVybnMgdG8gdXNlLlxuICogQHBhcmFtICB7T2JqZWN0fSBgb3B0c2AgT3B0aW9ucyB0byBwYXNzIHRvIHRoZSBgbWF0Y2hlcigpYCBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBhbnkoZnAsIHBhdHRlcm5zLCBvcHRzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXR0ZXJucykgJiYgdHlwZW9mIHBhdHRlcm5zICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IobXNnKCdhbnknLCAncGF0dGVybnMnLCAnYSBzdHJpbmcgb3IgYXJyYXknKSk7XG4gIH1cblxuICBwYXR0ZXJucyA9IHV0aWxzLmFycmF5aWZ5KHBhdHRlcm5zKTtcbiAgdmFyIGxlbiA9IHBhdHRlcm5zLmxlbmd0aDtcblxuICBmcCA9IHV0aWxzLnVuaXhpZnkoZnAsIG9wdHMpO1xuICB3aGlsZSAobGVuLS0pIHtcbiAgICB2YXIgaXNNYXRjaCA9IG1hdGNoZXIocGF0dGVybnNbbGVuXSwgb3B0cyk7XG4gICAgaWYgKGlzTWF0Y2goZnApKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEZpbHRlciB0aGUga2V5cyBvZiBhbiBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gYGdsb2JgIHBhdHRlcm5cbiAqIGFuZCBgb3B0aW9uc2BcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGBvYmplY3RgXG4gKiBAcGFyYW0gIHtQYXR0ZXJufSBgb2JqZWN0YFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZnVuY3Rpb24gbWF0Y2hLZXlzKG9iaiwgZ2xvYiwgb3B0aW9ucykge1xuICBpZiAodXRpbHMudHlwZU9mKG9iaikgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtc2coJ21hdGNoS2V5cycsICdmaXJzdCBhcmd1bWVudCcsICdhbiBvYmplY3QnKSk7XG4gIH1cblxuICB2YXIgZm4gPSBtYXRjaGVyKGdsb2IsIG9wdGlvbnMpO1xuICB2YXIgcmVzID0ge307XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSAmJiBmbihrZXkpKSB7XG4gICAgICByZXNba2V5XSA9IG9ialtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGZ1bmN0aW9uIGZvciBtYXRjaGluZyBiYXNlZCBvbiB0aGVcbiAqIGdpdmVuIGBwYXR0ZXJuYCBhbmQgYG9wdGlvbnNgLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gYHBhdHRlcm5gXG4gKiBAcGFyYW0gIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxuZnVuY3Rpb24gbWF0Y2hlcihwYXR0ZXJuLCBvcHRzKSB7XG4gIC8vIHBhdHRlcm4gaXMgYSBmdW5jdGlvblxuICBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuICAvLyBwYXR0ZXJuIGlzIGEgcmVnZXhcbiAgaWYgKHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZnApIHtcbiAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QoZnApO1xuICAgIH07XG4gIH1cblxuICBpZiAodHlwZW9mIHBhdHRlcm4gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtc2coJ21hdGNoZXInLCAncGF0dGVybicsICdhIHN0cmluZywgcmVnZXgsIG9yIGZ1bmN0aW9uJykpO1xuICB9XG5cbiAgLy8gc3RyaW5ncywgYWxsIHRoZSB3YXkgZG93bi4uLlxuICBwYXR0ZXJuID0gdXRpbHMudW5peGlmeShwYXR0ZXJuLCBvcHRzKTtcblxuICAvLyBwYXR0ZXJuIGlzIGEgbm9uLWdsb2Igc3RyaW5nXG4gIGlmICghdXRpbHMuaXNHbG9iKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHV0aWxzLm1hdGNoUGF0aChwYXR0ZXJuLCBvcHRzKTtcbiAgfVxuICAvLyBwYXR0ZXJuIGlzIGEgZ2xvYiBzdHJpbmdcbiAgdmFyIHJlID0gbWFrZVJlKHBhdHRlcm4sIG9wdHMpO1xuXG4gIC8vIGBtYXRjaEJhc2VgIGlzIGRlZmluZWRcbiAgaWYgKG9wdHMgJiYgb3B0cy5tYXRjaEJhc2UpIHtcbiAgICByZXR1cm4gdXRpbHMuaGFzRmlsZW5hbWUocmUsIG9wdHMpO1xuICB9XG4gIC8vIGBtYXRjaEJhc2VgIGlzIG5vdCBkZWZpbmVkXG4gIHJldHVybiBmdW5jdGlvbihmcCkge1xuICAgIGZwID0gdXRpbHMudW5peGlmeShmcCwgb3B0cyk7XG4gICAgcmV0dXJuIHJlLnRlc3QoZnApO1xuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbmQgY2FjaGUgYSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIG1hdGNoaW5nXG4gKiBmaWxlIHBhdGhzLlxuICpcbiAqIElmIHRoZSBsZWFkaW5nIGNoYXJhY3RlciBpbiB0aGUgYGdsb2JgIGlzIGAhYCwgYSBuZWdhdGlvblxuICogcmVnZXggaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBgZ2xvYmBcbiAqIEBwYXJhbSAge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKi9cblxuZnVuY3Rpb24gdG9SZWdleChnbG9iLCBvcHRpb25zKSB7XG4gIC8vIGNsb25lIG9wdGlvbnMgdG8gcHJldmVudCAgbXV0YXRpbmcgdGhlIG9yaWdpbmFsIG9iamVjdFxuICB2YXIgb3B0cyA9IE9iamVjdC5jcmVhdGUob3B0aW9ucyB8fCB7fSk7XG4gIHZhciBmbGFncyA9IG9wdHMuZmxhZ3MgfHwgJyc7XG4gIGlmIChvcHRzLm5vY2FzZSAmJiBmbGFncy5pbmRleE9mKCdpJykgPT09IC0xKSB7XG4gICAgZmxhZ3MgKz0gJ2knO1xuICB9XG5cbiAgdmFyIHBhcnNlZCA9IGV4cGFuZChnbG9iLCBvcHRzKTtcblxuICAvLyBwYXNzIGluIHRva2VucyB0byBhdm9pZCBwYXJzaW5nIG1vcmUgdGhhbiBvbmNlXG4gIG9wdHMubmVnYXRlZCA9IG9wdHMubmVnYXRlZCB8fCBwYXJzZWQubmVnYXRlZDtcbiAgb3B0cy5uZWdhdGUgPSBvcHRzLm5lZ2F0ZWQ7XG4gIGdsb2IgPSB3cmFwR2xvYihwYXJzZWQucGF0dGVybiwgb3B0cyk7XG4gIHZhciByZTtcblxuICB0cnkge1xuICAgIHJlID0gbmV3IFJlZ0V4cChnbG9iLCBmbGFncyk7XG4gICAgcmV0dXJuIHJlO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIucmVhc29uID0gJ21pY3JvbWF0Y2ggaW52YWxpZCByZWdleDogKCcgKyByZSArICcpJztcbiAgICBpZiAob3B0cy5zdHJpY3QpIHRocm93IG5ldyBTeW50YXhFcnJvcihlcnIpO1xuICB9XG5cbiAgLy8gd2UncmUgb25seSBoZXJlIGlmIGEgYmFkIHBhdHRlcm4gd2FzIHVzZWQgYW5kIHRoZSB1c2VyXG4gIC8vIHBhc3NlZCBgb3B0aW9ucy5zaWxlbnRgLCBzbyBtYXRjaCBub3RoaW5nXG4gIHJldHVybiAvJF4vO1xufVxuXG4vKipcbiAqIENyZWF0ZSB0aGUgcmVnZXggdG8gZG8gdGhlIG1hdGNoaW5nLiBJZiB0aGUgbGVhZGluZ1xuICogY2hhcmFjdGVyIGluIHRoZSBgZ2xvYmAgaXMgYCFgIGEgbmVnYXRpb24gcmVnZXggaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGBnbG9iYFxuICogQHBhcmFtIHtCb29sZWFufSBgbmVnYXRlYFxuICovXG5cbmZ1bmN0aW9uIHdyYXBHbG9iKGdsb2IsIG9wdHMpIHtcbiAgdmFyIHByZWZpeCA9IChvcHRzICYmICFvcHRzLmNvbnRhaW5zKSA/ICdeJyA6ICcnO1xuICB2YXIgYWZ0ZXIgPSAob3B0cyAmJiAhb3B0cy5jb250YWlucykgPyAnJCcgOiAnJztcbiAgZ2xvYiA9ICgnKD86JyArIGdsb2IgKyAnKScgKyBhZnRlcik7XG4gIGlmIChvcHRzICYmIG9wdHMubmVnYXRlKSB7XG4gICAgcmV0dXJuIHByZWZpeCArICgnKD8hXicgKyBnbG9iICsgJykuKiQnKTtcbiAgfVxuICByZXR1cm4gcHJlZml4ICsgZ2xvYjtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW5kIGNhY2hlIGEgcmVndWxhciBleHByZXNzaW9uIGZvciBtYXRjaGluZyBmaWxlIHBhdGhzLlxuICogSWYgdGhlIGxlYWRpbmcgY2hhcmFjdGVyIGluIHRoZSBgZ2xvYmAgaXMgYCFgLCBhIG5lZ2F0aW9uXG4gKiByZWdleCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGBnbG9iYFxuICogQHBhcmFtICB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge1JlZ0V4cH1cbiAqL1xuXG5mdW5jdGlvbiBtYWtlUmUoZ2xvYiwgb3B0cykge1xuICBpZiAodXRpbHMudHlwZU9mKGdsb2IpICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcihtc2coJ21ha2VSZScsICdnbG9iJywgJ2Egc3RyaW5nJykpO1xuICB9XG4gIHJldHVybiB1dGlscy5jYWNoZSh0b1JlZ2V4LCBnbG9iLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBNYWtlIGVycm9yIG1lc3NhZ2VzIGNvbnNpc3RlbnQuIEZvbGxvd3MgdGhpcyBmb3JtYXQ6XG4gKlxuICogYGBganNcbiAqIG1zZyhtZXRob2ROYW1lLCBhcmdOdW1iZXIsIG5hdGl2ZVR5cGUpO1xuICogLy8gZXhhbXBsZTpcbiAqIG1zZygnbWF0Y2hLZXlzJywgJ2ZpcnN0JywgJ2FuIG9iamVjdCcpO1xuICogYGBgXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBgbWV0aG9kYFxuICogQHBhcmFtICB7U3RyaW5nfSBgbnVtYFxuICogQHBhcmFtICB7U3RyaW5nfSBgdHlwZWBcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBtc2cobWV0aG9kLCB3aGF0LCB0eXBlKSB7XG4gIHJldHVybiAnbWljcm9tYXRjaC4nICsgbWV0aG9kICsgJygpOiAnICsgd2hhdCArICcgc2hvdWxkIGJlICcgKyB0eXBlICsgJy4nO1xufVxuXG4vKipcbiAqIFB1YmxpYyBtZXRob2RzXG4gKi9cblxuLyogZXNsaW50IG5vLW11bHRpLXNwYWNlczogMCAqL1xubWljcm9tYXRjaC5hbnkgICAgICAgPSBhbnk7XG5taWNyb21hdGNoLmJyYWNlcyAgICA9IG1pY3JvbWF0Y2guYnJhY2VFeHBhbmQgPSB1dGlscy5icmFjZXM7XG5taWNyb21hdGNoLmNvbnRhaW5zICA9IGNvbnRhaW5zO1xubWljcm9tYXRjaC5leHBhbmQgICAgPSBleHBhbmQ7XG5taWNyb21hdGNoLmZpbHRlciAgICA9IGZpbHRlcjtcbm1pY3JvbWF0Y2guaXNNYXRjaCAgID0gaXNNYXRjaDtcbm1pY3JvbWF0Y2gubWFrZVJlICAgID0gbWFrZVJlO1xubWljcm9tYXRjaC5tYXRjaCAgICAgPSBtYXRjaDtcbm1pY3JvbWF0Y2gubWF0Y2hlciAgID0gbWF0Y2hlcjtcbm1pY3JvbWF0Y2gubWF0Y2hLZXlzID0gbWF0Y2hLZXlzO1xuXG4vKipcbiAqIEV4cG9zZSBgbWljcm9tYXRjaGBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1pY3JvbWF0Y2g7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWljcm9tYXRjaC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogbWljcm9tYXRjaCA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvbWljcm9tYXRjaD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgR2xvYiA9IHJlcXVpcmUoJy4vZ2xvYicpO1xuXG4vKipcbiAqIEV4cG9zZSBgZXhwYW5kYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwYW5kO1xuXG4vKipcbiAqIEV4cGFuZCBhIGdsb2IgcGF0dGVybiB0byByZXNvbHZlIGJyYWNlcyBhbmRcbiAqIHNpbWlsYXIgcGF0dGVybnMgYmVmb3JlIGNvbnZlcnRpbmcgdG8gcmVnZXguXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSBgcGF0dGVybmBcbiAqIEBwYXJhbSAge0FycmF5fSBgZmlsZXNgXG4gKiBAcGFyYW0gIHtPcHRpb25zfSBgb3B0c2BcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIGV4cGFuZChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaWNyb21hdGNoLmV4cGFuZCgpOiBhcmd1bWVudCBzaG91bGQgYmUgYSBzdHJpbmcuJyk7XG4gIH1cblxuICB2YXIgZ2xvYiA9IG5ldyBHbG9iKHBhdHRlcm4sIG9wdGlvbnMgfHwge30pO1xuICB2YXIgb3B0cyA9IGdsb2Iub3B0aW9ucztcblxuICBpZiAoIXV0aWxzLmlzR2xvYihwYXR0ZXJuKSkge1xuICAgIGdsb2IucGF0dGVybiA9IGdsb2IucGF0dGVybi5yZXBsYWNlKC8oW1xcLy5dKS9nLCAnXFxcXCQxJyk7XG4gICAgcmV0dXJuIGdsb2I7XG4gIH1cblxuICBnbG9iLnBhdHRlcm4gPSBnbG9iLnBhdHRlcm4ucmVwbGFjZSgvKFxcKykoPyFcXCgpL2csICdcXFxcJDEnKTtcbiAgZ2xvYi5wYXR0ZXJuID0gZ2xvYi5wYXR0ZXJuLnNwbGl0KCckJykuam9pbignXFxcXCQnKTtcblxuICBpZiAodHlwZW9mIG9wdHMuYnJhY2VzICE9PSAnYm9vbGVhbicgJiYgdHlwZW9mIG9wdHMubm9icmFjZXMgIT09ICdib29sZWFuJykge1xuICAgIG9wdHMuYnJhY2VzID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChnbG9iLnBhdHRlcm4gPT09ICcuKicpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0dGVybjogJ1xcXFwuJyArIHN0YXIsXG4gICAgICB0b2tlbnM6IHRvayxcbiAgICAgIG9wdGlvbnM6IG9wdHNcbiAgICB9O1xuICB9XG5cbiAgaWYgKGdsb2IucGF0dGVybiA9PT0gJyonKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdHRlcm46IG9uZVN0YXIob3B0cy5kb3QpLFxuICAgICAgdG9rZW5zOiB0b2ssXG4gICAgICBvcHRpb25zOiBvcHRzXG4gICAgfTtcbiAgfVxuXG4gIC8vIHBhcnNlIHRoZSBnbG9iIHBhdHRlcm4gaW50byB0b2tlbnNcbiAgZ2xvYi5wYXJzZSgpO1xuICB2YXIgdG9rID0gZ2xvYi50b2tlbnM7XG4gIHRvay5pcy5uZWdhdGVkID0gb3B0cy5uZWdhdGVkO1xuXG4gIC8vIGRvdGZpbGUgaGFuZGxpbmdcbiAgaWYgKChvcHRzLmRvdGZpbGVzID09PSB0cnVlIHx8IHRvay5pcy5kb3RmaWxlKSAmJiBvcHRzLmRvdCAhPT0gZmFsc2UpIHtcbiAgICBvcHRzLmRvdGZpbGVzID0gdHJ1ZTtcbiAgICBvcHRzLmRvdCA9IHRydWU7XG4gIH1cblxuICBpZiAoKG9wdHMuZG90ZGlycyA9PT0gdHJ1ZSB8fCB0b2suaXMuZG90ZGlyKSAmJiBvcHRzLmRvdCAhPT0gZmFsc2UpIHtcbiAgICBvcHRzLmRvdGRpcnMgPSB0cnVlO1xuICAgIG9wdHMuZG90ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBicmFjZXMgd2l0aCBhIGRvdGZpbGUgcGF0dGVyblxuICBpZiAoL1t7LF1cXC4vLnRlc3QoZ2xvYi5wYXR0ZXJuKSkge1xuICAgIG9wdHMubWFrZVJlID0gZmFsc2U7XG4gICAgb3B0cy5kb3QgPSB0cnVlO1xuICB9XG5cbiAgaWYgKG9wdHMubm9uZWdhdGUgIT09IHRydWUpIHtcbiAgICBvcHRzLm5lZ2F0ZWQgPSBnbG9iLm5lZ2F0ZWQ7XG4gIH1cblxuICAvLyBpZiB0aGUgbGVhZGluZyBjaGFyYWN0ZXIgaXMgYSBkb3Qgb3IgYSBzbGFzaCwgZXNjYXBlIGl0XG4gIGlmIChnbG9iLnBhdHRlcm4uY2hhckF0KDApID09PSAnLicgJiYgZ2xvYi5wYXR0ZXJuLmNoYXJBdCgxKSAhPT0gJy8nKSB7XG4gICAgZ2xvYi5wYXR0ZXJuID0gJ1xcXFwnICsgZ2xvYi5wYXR0ZXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dGVuZGVkIGdsb2JzXG4gICAqL1xuXG4gIC8vIGV4cGFuZCBicmFjZXMsIGUuZyBgezEuLjV9YFxuICBnbG9iLnRyYWNrKCdiZWZvcmUgYnJhY2VzJyk7XG4gIGlmICh0b2suaXMuYnJhY2VzKSB7XG4gICAgZ2xvYi5icmFjZXMoKTtcbiAgfVxuICBnbG9iLnRyYWNrKCdhZnRlciBicmFjZXMnKTtcblxuICAvLyBleHBhbmQgZXh0Z2xvYnMsIGUuZyBgZm9vLyEoYXxiKWBcbiAgZ2xvYi50cmFjaygnYmVmb3JlIGV4dGdsb2InKTtcbiAgaWYgKHRvay5pcy5leHRnbG9iKSB7XG4gICAgZ2xvYi5leHRnbG9iKCk7XG4gIH1cbiAgZ2xvYi50cmFjaygnYWZ0ZXIgZXh0Z2xvYicpO1xuXG4gIC8vIGV4cGFuZCBicmFja2V0cywgZS5nIGBbWzphbHBoYTpdXWBcbiAgZ2xvYi50cmFjaygnYmVmb3JlIGJyYWNrZXRzJyk7XG4gIGlmICh0b2suaXMuYnJhY2tldHMpIHtcbiAgICBnbG9iLmJyYWNrZXRzKCk7XG4gIH1cbiAgZ2xvYi50cmFjaygnYWZ0ZXIgYnJhY2tldHMnKTtcblxuICAvLyBzcGVjaWFsIHBhdHRlcm5zXG4gIGdsb2IuX3JlcGxhY2UoJ1shJywgJ1teJyk7XG4gIGdsb2IuX3JlcGxhY2UoJyg/JywgJyglficpO1xuICBnbG9iLl9yZXBsYWNlKC9cXFtcXF0vLCAnXFxcXFtcXFxcXScpO1xuICBnbG9iLl9yZXBsYWNlKCcvWycsICcvJyArIChvcHRzLmRvdCA/IGRvdGZpbGVzIDogbm9kb3QpICsgJ1snLCB0cnVlKTtcbiAgZ2xvYi5fcmVwbGFjZSgnLz8nLCAnLycgKyAob3B0cy5kb3QgPyBkb3RmaWxlcyA6IG5vZG90KSArICdbXi9dJywgdHJ1ZSk7XG4gIGdsb2IuX3JlcGxhY2UoJy8uJywgJy8oPz0uKVxcXFwuJywgdHJ1ZSk7XG5cbiAgLy8gd2luZG93cyBkcml2ZXNcbiAgZ2xvYi5fcmVwbGFjZSgvXihcXHcpOihbXFxcXFxcL10rPykvZ2ksICcoPz0uKSQxOiQyJywgdHJ1ZSk7XG5cbiAgLy8gbmVnYXRlIHNsYXNoZXMgaW4gZXhjbHVzaW9uIHJhbmdlc1xuICBpZiAoZ2xvYi5wYXR0ZXJuLmluZGV4T2YoJ1teJykgIT09IC0xKSB7XG4gICAgZ2xvYi5wYXR0ZXJuID0gbmVnYXRlU2xhc2goZ2xvYi5wYXR0ZXJuKTtcbiAgfVxuXG4gIGlmIChvcHRzLmdsb2JzdGFyICE9PSBmYWxzZSAmJiBnbG9iLnBhdHRlcm4gPT09ICcqKicpIHtcbiAgICBnbG9iLnBhdHRlcm4gPSBnbG9ic3RhcihvcHRzLmRvdCk7XG5cbiAgfSBlbHNlIHtcbiAgICBnbG9iLnBhdHRlcm4gPSBiYWxhbmNlKGdsb2IucGF0dGVybiwgJ1snLCAnXScpO1xuICAgIGdsb2IuZXNjYXBlKGdsb2IucGF0dGVybik7XG5cbiAgICAvLyBpZiB0aGUgcGF0dGVybiBoYXMgYCoqYFxuICAgIGlmICh0b2suaXMuZ2xvYnN0YXIpIHtcbiAgICAgIGdsb2IucGF0dGVybiA9IGNvbGxhcHNlKGdsb2IucGF0dGVybiwgJy8qKicpO1xuICAgICAgZ2xvYi5wYXR0ZXJuID0gY29sbGFwc2UoZ2xvYi5wYXR0ZXJuLCAnKiovJyk7XG4gICAgICBnbG9iLl9yZXBsYWNlKCcvKiovJywgJyg/Oi8nICsgZ2xvYnN0YXIob3B0cy5kb3QpICsgJy98LyknLCB0cnVlKTtcbiAgICAgIGdsb2IuX3JlcGxhY2UoL1xcKnsyLH0vZywgJyoqJyk7XG5cbiAgICAgIC8vICdmb28vKidcbiAgICAgIGdsb2IuX3JlcGxhY2UoLyhcXHcrKVxcKig/IVxcLykvZywgJyQxW14vXSo/JywgdHJ1ZSk7XG4gICAgICBnbG9iLl9yZXBsYWNlKC9cXCpcXCpcXC9cXCooXFx3KS9nLCBnbG9ic3RhcihvcHRzLmRvdCkgKyAnXFxcXC8nICsgKG9wdHMuZG90ID8gZG90ZmlsZXMgOiBub2RvdCkgKyAnW14vXSo/JDEnLCB0cnVlKTtcblxuICAgICAgaWYgKG9wdHMuZG90ICE9PSB0cnVlKSB7XG4gICAgICAgIGdsb2IuX3JlcGxhY2UoL1xcKlxcKlxcLyguKS9nLCAnKD86KipcXFxcL3wpJDEnKTtcbiAgICAgIH1cblxuICAgICAgLy8gJ2Zvby8qKicgb3IgJ3sqKiwqfScsIGJ1dCBub3QgJ2ZvbyoqJ1xuICAgICAgaWYgKHRvay5wYXRoLmRpcm5hbWUgIT09ICcnIHx8IC8sXFwqXFwqfFxcKlxcKiwvLnRlc3QoZ2xvYi5vcmlnKSkge1xuICAgICAgICBnbG9iLl9yZXBsYWNlKCcqKicsIGdsb2JzdGFyKG9wdHMuZG90KSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZW5kcyB3aXRoIC8qXG4gICAgZ2xvYi5fcmVwbGFjZSgvXFwvXFwqJC8sICdcXFxcLycgKyBvbmVTdGFyKG9wdHMuZG90KSwgdHJ1ZSk7XG4gICAgLy8gZW5kcyB3aXRoICosIG5vIHNsYXNoZXNcbiAgICBnbG9iLl9yZXBsYWNlKC8oPyFcXC8pXFwqJC8sIHN0YXIsIHRydWUpO1xuICAgIC8vIGhhcyAnbiouJyAocGFydGlhbCB3aWxkY2FyZCB3LyBmaWxlIGV4dGVuc2lvbilcbiAgICBnbG9iLl9yZXBsYWNlKC8oW15cXC9dKylcXCovLCAnJDEnICsgb25lU3Rhcih0cnVlKSwgdHJ1ZSk7XG4gICAgLy8gaGFzICcqJ1xuICAgIGdsb2IuX3JlcGxhY2UoJyonLCBvbmVTdGFyKG9wdHMuZG90KSwgdHJ1ZSk7XG4gICAgZ2xvYi5fcmVwbGFjZSgnPy4nLCAnP1xcXFwuJywgdHJ1ZSk7XG4gICAgZ2xvYi5fcmVwbGFjZSgnPzonLCAnPzonLCB0cnVlKTtcblxuICAgIGdsb2IuX3JlcGxhY2UoL1xcPysvZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHZhciBsZW4gPSBtYXRjaC5sZW5ndGg7XG4gICAgICBpZiAobGVuID09PSAxKSB7XG4gICAgICAgIHJldHVybiBxbWFyaztcbiAgICAgIH1cbiAgICAgIHJldHVybiBxbWFyayArICd7JyArIGxlbiArICd9JztcbiAgICB9KTtcblxuICAgIC8vIGVzY2FwZSAnLmFiYycgPT4gJ1xcXFwuYWJjJ1xuICAgIGdsb2IuX3JlcGxhY2UoL1xcLihbKlxcd10rKS9nLCAnXFxcXC4kMScpO1xuICAgIC8vIGZpeCAnW15cXFxcXFxcXC9dJ1xuICAgIGdsb2IuX3JlcGxhY2UoL1xcW1xcXltcXFxcXFwvXStcXF0vZywgcW1hcmspO1xuICAgIC8vICcvLy8nID0+ICdcXC8nXG4gICAgZ2xvYi5fcmVwbGFjZSgvXFwvKy9nLCAnXFxcXC8nKTtcbiAgICAvLyAnXFxcXFxcXFxcXFxcJyA9PiAnXFxcXCdcbiAgICBnbG9iLl9yZXBsYWNlKC9cXFxcezIsfS9nLCAnXFxcXCcpO1xuICB9XG5cbiAgLy8gdW5lc2NhcGUgcHJldmlvdXNseSBlc2NhcGVkIHBhdHRlcm5zXG4gIGdsb2IudW5lc2NhcGUoZ2xvYi5wYXR0ZXJuKTtcbiAgZ2xvYi5fcmVwbGFjZSgnX19VTkVTQ19TVEFSX18nLCAnKicpO1xuXG4gIC8vIGVzY2FwZSBkb3RzIHRoYXQgZm9sbG93IHFtYXJrc1xuICBnbG9iLl9yZXBsYWNlKCc/LicsICc/XFxcXC4nKTtcblxuICAvLyByZW1vdmUgdW5uZWNlc3Nhcnkgc2xhc2hlcyBpbiBjaGFyYWN0ZXIgY2xhc3Nlc1xuICBnbG9iLl9yZXBsYWNlKCdbXlxcXFwvXScsIHFtYXJrKTtcblxuICBpZiAoZ2xvYi5wYXR0ZXJuLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoL15bXFxbPypdLy50ZXN0KGdsb2IucGF0dGVybikpIHtcbiAgICAgIC8vIG9ubHkgcHJlcGVuZCB0aGUgc3RyaW5nIGlmIHdlIGRvbid0IHdhbnQgdG8gbWF0Y2ggZG90ZmlsZXNcbiAgICAgIGdsb2IucGF0dGVybiA9IChvcHRzLmRvdCA/IGRvdGZpbGVzIDogbm9kb3QpICsgZ2xvYi5wYXR0ZXJuO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBnbG9iO1xufVxuXG4vKipcbiAqIENvbGxhcHNlIHJlcGVhdGVkIGNoYXJhY3RlciBzZXF1ZW5jZXMuXG4gKlxuICogYGBganNcbiAqIGNvbGxhcHNlKCdhLy4uLy4uLy4uL2InLCAnLi4vJyk7XG4gKiAvLz0+ICdhLy4uL2InXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGBzdHJgXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGBjaGAgQ2hhcmFjdGVyIHNlcXVlbmNlIHRvIGNvbGxhcHNlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gY29sbGFwc2Uoc3RyLCBjaCkge1xuICB2YXIgcmVzID0gc3RyLnNwbGl0KGNoKTtcbiAgdmFyIGlzRmlyc3QgPSByZXNbMF0gPT09ICcnO1xuICB2YXIgaXNMYXN0ID0gcmVzW3Jlcy5sZW5ndGggLSAxXSA9PT0gJyc7XG4gIHJlcyA9IHJlcy5maWx0ZXIoQm9vbGVhbik7XG4gIGlmIChpc0ZpcnN0KSByZXMudW5zaGlmdCgnJyk7XG4gIGlmIChpc0xhc3QpIHJlcy5wdXNoKCcnKTtcbiAgcmV0dXJuIHJlcy5qb2luKGNoKTtcbn1cblxuLyoqXG4gKiBOZWdhdGUgc2xhc2hlcyBpbiBleGNsdXNpb24gcmFuZ2VzLCBwZXIgZ2xvYiBzcGVjOlxuICpcbiAqIGBgYGpzXG4gKiBuZWdhdGVTbGFzaCgnW15mb29dJyk7XG4gKiAvLz0+ICdbXlxcXFwvZm9vXSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gYHN0cmAgZ2xvYiBwYXR0ZXJuXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gbmVnYXRlU2xhc2goc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxbXFxeKFteXFxdXSo/KVxcXS9nLCBmdW5jdGlvbihtYXRjaCwgaW5uZXIpIHtcbiAgICBpZiAoaW5uZXIuaW5kZXhPZignLycpID09PSAtMSkge1xuICAgICAgaW5uZXIgPSAnXFxcXC8nICsgaW5uZXI7XG4gICAgfVxuICAgIHJldHVybiAnW14nICsgaW5uZXIgKyAnXSc7XG4gIH0pO1xufVxuXG4vKipcbiAqIEVzY2FwZSBpbWJhbGFuY2VkIGJyYWNlcy9icmFja2V0LiBUaGlzIGlzIGEgdmVyeVxuICogYmFzaWMsIG5haXZlIGltcGxlbWVudGF0aW9uIHRoYXQgb25seSBkb2VzIGVub3VnaFxuICogdG8gc2VydmUgdGhlIHB1cnBvc2UuXG4gKi9cblxuZnVuY3Rpb24gYmFsYW5jZShzdHIsIGEsIGIpIHtcbiAgdmFyIGFhcnIgPSBzdHIuc3BsaXQoYSk7XG4gIHZhciBhbGVuID0gYWFyci5qb2luKCcnKS5sZW5ndGg7XG4gIHZhciBibGVuID0gc3RyLnNwbGl0KGIpLmpvaW4oJycpLmxlbmd0aDtcblxuICBpZiAoYWxlbiAhPT0gYmxlbikge1xuICAgIHN0ciA9IGFhcnIuam9pbignXFxcXCcgKyBhKTtcbiAgICByZXR1cm4gc3RyLnNwbGl0KGIpLmpvaW4oJ1xcXFwnICsgYik7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBTcGVjaWFsIHBhdHRlcm5zIHRvIGJlIGNvbnZlcnRlZCB0byByZWdleC5cbiAqIEhldXJpc3RpY3MgYXJlIHVzZWQgdG8gc2ltcGxpZnkgcGF0dGVybnNcbiAqIGFuZCBzcGVlZCB1cCBwcm9jZXNzaW5nLlxuICovXG5cbi8qIGVzbGludCBuby1tdWx0aS1zcGFjZXM6IDAgKi9cbnZhciBxbWFyayAgICAgICA9ICdbXi9dJztcbnZhciBzdGFyICAgICAgICA9IHFtYXJrICsgJyo/JztcbnZhciBub2RvdCAgICAgICA9ICcoPyFcXFxcLikoPz0uKSc7XG52YXIgZG90ZmlsZUdsb2IgPSAnKD86XFxcXC98XilcXFxcLnsxLDJ9KCR8XFxcXC8pJztcbnZhciBkb3RmaWxlcyAgICA9ICcoPyEnICsgZG90ZmlsZUdsb2IgKyAnKSg/PS4pJztcbnZhciB0d29TdGFyRG90ICA9ICcoPzooPyEnICsgZG90ZmlsZUdsb2IgKyAnKS4pKj8nO1xuXG4vKipcbiAqIENyZWF0ZSBhIHJlZ2V4IGZvciBgKmAuXG4gKlxuICogSWYgYGRvdGAgaXMgdHJ1ZSwgb3IgdGhlIHBhdHRlcm4gZG9lcyBub3QgYmVnaW4gd2l0aFxuICogYSBsZWFkaW5nIHN0YXIsIHRoZW4gcmV0dXJuIHRoZSBzaW1wbGVyIHJlZ2V4LlxuICovXG5cbmZ1bmN0aW9uIG9uZVN0YXIoZG90ZmlsZSkge1xuICByZXR1cm4gZG90ZmlsZSA/ICcoPyEnICsgZG90ZmlsZUdsb2IgKyAnKSg/PS4pJyArIHN0YXIgOiAobm9kb3QgKyBzdGFyKTtcbn1cblxuZnVuY3Rpb24gZ2xvYnN0YXIoZG90ZmlsZSkge1xuICBpZiAoZG90ZmlsZSkgeyByZXR1cm4gdHdvU3RhckRvdDsgfVxuICByZXR1cm4gJyg/Oig/ISg/OlxcXFwvfF4pXFxcXC4pLikqPyc7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWljcm9tYXRjaC9saWIvZXhwYW5kLmpzXG4vLyBtb2R1bGUgaWQgPSAyMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgd2luMzIgPSBwcm9jZXNzICYmIHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMic7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBmaWxlUmUgPSByZXF1aXJlKCdmaWxlbmFtZS1yZWdleCcpO1xudmFyIHV0aWxzID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnV0aWxzLmRpZmYgPSByZXF1aXJlKCdhcnItZGlmZicpO1xudXRpbHMudW5pcXVlID0gcmVxdWlyZSgnYXJyYXktdW5pcXVlJyk7XG51dGlscy5icmFjZXMgPSByZXF1aXJlKCdicmFjZXMnKTtcbnV0aWxzLmJyYWNrZXRzID0gcmVxdWlyZSgnZXhwYW5kLWJyYWNrZXRzJyk7XG51dGlscy5leHRnbG9iID0gcmVxdWlyZSgnZXh0Z2xvYicpO1xudXRpbHMuaXNFeHRnbG9iID0gcmVxdWlyZSgnaXMtZXh0Z2xvYicpO1xudXRpbHMuaXNHbG9iID0gcmVxdWlyZSgnaXMtZ2xvYicpO1xudXRpbHMudHlwZU9mID0gcmVxdWlyZSgna2luZC1vZicpO1xudXRpbHMubm9ybWFsaXplID0gcmVxdWlyZSgnbm9ybWFsaXplLXBhdGgnKTtcbnV0aWxzLm9taXQgPSByZXF1aXJlKCdvYmplY3Qub21pdCcpO1xudXRpbHMucGFyc2VHbG9iID0gcmVxdWlyZSgncGFyc2UtZ2xvYicpO1xudXRpbHMuY2FjaGUgPSByZXF1aXJlKCdyZWdleC1jYWNoZScpO1xuXG4vKipcbiAqIEdldCB0aGUgZmlsZW5hbWUgb2YgYSBmaWxlcGF0aFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyaW5nYFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbnV0aWxzLmZpbGVuYW1lID0gZnVuY3Rpb24gZmlsZW5hbWUoZnApIHtcbiAgdmFyIHNlZyA9IGZwLm1hdGNoKGZpbGVSZSgpKTtcbiAgcmV0dXJuIHNlZyAmJiBzZWdbMF07XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW5cbiAqIHBhdHRlcm4gaXMgdGhlIHNhbWUgYXMgYSBnaXZlbiBgZmlsZXBhdGhgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYFxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cblxudXRpbHMuaXNQYXRoID0gZnVuY3Rpb24gaXNQYXRoKHBhdHRlcm4sIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHJldHVybiBmdW5jdGlvbihmcCkge1xuICAgIHZhciB1bml4aWZpZWQgPSB1dGlscy51bml4aWZ5KGZwLCBvcHRzKTtcbiAgICBpZihvcHRzLm5vY2FzZSl7XG4gICAgICByZXR1cm4gcGF0dGVybi50b0xvd2VyQ2FzZSgpID09PSB1bml4aWZpZWQudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdHRlcm4gPT09IHVuaXhpZmllZDtcbiAgfTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlblxuICogcGF0dGVybiBjb250YWlucyBhIGBmaWxlcGF0aGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG51dGlscy5oYXNQYXRoID0gZnVuY3Rpb24gaGFzUGF0aChwYXR0ZXJuLCBvcHRzKSB7XG4gIHJldHVybiBmdW5jdGlvbihmcCkge1xuICAgIHJldHVybiB1dGlscy51bml4aWZ5KHBhdHRlcm4sIG9wdHMpLmluZGV4T2YoZnApICE9PSAtMTtcbiAgfTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlblxuICogcGF0dGVybiBtYXRjaGVzIG9yIGNvbnRhaW5zIGEgYGZpbGVwYXRoYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmBcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cbnV0aWxzLm1hdGNoUGF0aCA9IGZ1bmN0aW9uIG1hdGNoUGF0aChwYXR0ZXJuLCBvcHRzKSB7XG4gIHZhciBmbiA9IChvcHRzICYmIG9wdHMuY29udGFpbnMpXG4gICAgPyB1dGlscy5oYXNQYXRoKHBhdHRlcm4sIG9wdHMpXG4gICAgOiB1dGlscy5pc1BhdGgocGF0dGVybiwgb3B0cyk7XG4gIHJldHVybiBmbjtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlblxuICogcmVnZXggbWF0Y2hlcyB0aGUgYGZpbGVuYW1lYCBvZiBhIGZpbGUgcGF0aC5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cH0gYHJlYFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG51dGlscy5oYXNGaWxlbmFtZSA9IGZ1bmN0aW9uIGhhc0ZpbGVuYW1lKHJlKSB7XG4gIHJldHVybiBmdW5jdGlvbihmcCkge1xuICAgIHZhciBuYW1lID0gdXRpbHMuZmlsZW5hbWUoZnApO1xuICAgIHJldHVybiBuYW1lICYmIHJlLnRlc3QobmFtZSk7XG4gIH07XG59O1xuXG4vKipcbiAqIENvZXJjZSBgdmFsYCB0byBhbiBhcnJheVxuICpcbiAqIEBwYXJhbSAgeyp9IHZhbFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxudXRpbHMuYXJyYXlpZnkgPSBmdW5jdGlvbiBhcnJheWlmeSh2YWwpIHtcbiAgcmV0dXJuICFBcnJheS5pc0FycmF5KHZhbClcbiAgICA/IFt2YWxdXG4gICAgOiB2YWw7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhbGwgc2xhc2hlcyBpbiBhIGZpbGUgcGF0aCBvciBnbG9iIHBhdHRlcm4gdG9cbiAqIGZvcndhcmQgc2xhc2hlcy5cbiAqL1xuXG51dGlscy51bml4aWZ5ID0gZnVuY3Rpb24gdW5peGlmeShmcCwgb3B0cykge1xuICBpZiAob3B0cyAmJiBvcHRzLnVuaXhpZnkgPT09IGZhbHNlKSByZXR1cm4gZnA7XG4gIGlmIChvcHRzICYmIG9wdHMudW5peGlmeSA9PT0gdHJ1ZSB8fCB3aW4zMiB8fCBwYXRoLnNlcCA9PT0gJ1xcXFwnKSB7XG4gICAgcmV0dXJuIHV0aWxzLm5vcm1hbGl6ZShmcCwgZmFsc2UpO1xuICB9XG4gIGlmIChvcHRzICYmIG9wdHMudW5lc2NhcGUgPT09IHRydWUpIHtcbiAgICByZXR1cm4gZnAgPyBmcC50b1N0cmluZygpLnJlcGxhY2UoL1xcXFwoXFx3KS9nLCAnJDEnKSA6ICcnO1xuICB9XG4gIHJldHVybiBmcDtcbn07XG5cbi8qKlxuICogRXNjYXBlL3VuZXNjYXBlIHV0aWxzXG4gKi9cblxudXRpbHMuZXNjYXBlUGF0aCA9IGZ1bmN0aW9uIGVzY2FwZVBhdGgoZnApIHtcbiAgcmV0dXJuIGZwLnJlcGxhY2UoL1tcXFxcLl0vZywgJ1xcXFwkJicpO1xufTtcblxudXRpbHMudW5lc2NhcGVHbG9iID0gZnVuY3Rpb24gdW5lc2NhcGVHbG9iKGZwKSB7XG4gIHJldHVybiBmcC5yZXBsYWNlKC9bXFxcXFwiJ10vZywgJycpO1xufTtcblxudXRpbHMuZXNjYXBlUmUgPSBmdW5jdGlvbiBlc2NhcGVSZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLVtcXFxcJCorPy4jXlxcc3t9KHwpXFxdXS9nLCAnXFxcXCQmJyk7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgdXRpbHNgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB1dGlscztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9taWNyb21hdGNoL2xpYi91dGlscy5qc1xuLy8gbW9kdWxlIGlkID0gMjI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogZmlsZW5hbWUtcmVnZXggPGh0dHBzOi8vZ2l0aHViLmNvbS9yZWdleHBzL2ZpbGVuYW1lLXJlZ2V4PlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE1LCBKb24gU2NobGlua2VydFxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmlsZW5hbWVSZWdleCgpIHtcbiAgcmV0dXJuIC8oW15cXFxcXFwvXSspJC87XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2ZpbGVuYW1lLXJlZ2V4L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBhcnItZGlmZiA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvYXJyLWRpZmY+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IEpvbiBTY2hsaW5rZXJ0LCBjb250cmlidXRvcnMuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBmbGF0dGVuID0gcmVxdWlyZSgnYXJyLWZsYXR0ZW4nKTtcbnZhciBzbGljZSA9IFtdLnNsaWNlO1xuXG4vKipcbiAqIFJldHVybiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBmaXJzdCBhcnJheSBhbmRcbiAqIGFkZGl0aW9uYWwgYXJyYXlzLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgZGlmZiA9IHJlcXVpcmUoJ3slPSBuYW1lICV9Jyk7XG4gKlxuICogdmFyIGEgPSBbJ2EnLCAnYicsICdjJywgJ2QnXTtcbiAqIHZhciBiID0gWydiJywgJ2MnXTtcbiAqXG4gKiBjb25zb2xlLmxvZyhkaWZmKGEsIGIpKVxuICogLy89PiBbJ2EnLCAnZCddXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gIHtBcnJheX0gYGFgXG4gKiBAcGFyYW0gIHtBcnJheX0gYGJgXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlmZihhcnIsIGFycmF5cykge1xuICB2YXIgYXJnc0xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoLCBpID0gLTE7XG4gIHZhciByZXMgPSBbXSwgYXJyYXlzO1xuXG4gIGlmIChhcmdzTGVuID09PSAxKSB7XG4gICAgcmV0dXJuIGFycjtcbiAgfVxuXG4gIGlmIChhcmdzTGVuID4gMikge1xuICAgIGFycmF5cyA9IGZsYXR0ZW4oc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgfVxuXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBpZiAoIX5hcnJheXMuaW5kZXhPZihhcnJbaV0pKSB7XG4gICAgICByZXMucHVzaChhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEV4cG9zZSBgZGlmZmBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRpZmY7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYXJyLWRpZmYvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIGFyci1mbGF0dGVuIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9hcnItZmxhdHRlbj5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZsYXR0ZW4oYXJyKSB7XG4gIHJldHVybiBmbGF0KGFyciwgW10pO1xufTtcblxuZnVuY3Rpb24gZmxhdChhcnIsIHJlcykge1xuICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIGkgPSAtMTtcblxuICB3aGlsZSAobGVuLS0pIHtcbiAgICB2YXIgY3VyID0gYXJyWysraV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY3VyKSkge1xuICAgICAgZmxhdChjdXIsIHJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcy5wdXNoKGN1cik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Fyci1mbGF0dGVuL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBhcnJheS11bmlxdWUgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2FycmF5LXVuaXF1ZT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHVuaXF1ZShhcnIpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcnJheS11bmlxdWUgZXhwZWN0cyBhbiBhcnJheS4nKTtcbiAgfVxuXG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgaSA9IC0xO1xuXG4gIHdoaWxlIChpKysgPCBsZW4pIHtcbiAgICB2YXIgaiA9IGkgKyAxO1xuXG4gICAgZm9yICg7IGogPCBhcnIubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChhcnJbaV0gPT09IGFycltqXSkge1xuICAgICAgICBhcnIuc3BsaWNlKGotLSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnI7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FycmF5LXVuaXF1ZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogYnJhY2VzIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9icmFjZXM+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTUsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIGV4cGFuZCA9IHJlcXVpcmUoJ2V4cGFuZC1yYW5nZScpO1xudmFyIHJlcGVhdCA9IHJlcXVpcmUoJ3JlcGVhdC1lbGVtZW50Jyk7XG52YXIgdG9rZW5zID0gcmVxdWlyZSgncHJlc2VydmUnKTtcblxuLyoqXG4gKiBFeHBvc2UgYGJyYWNlc2BcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHN0ciwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JyYWNlcyBleHBlY3RzIGEgc3RyaW5nJyk7XG4gIH1cbiAgcmV0dXJuIGJyYWNlcyhzdHIsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBFeHBhbmQgYHtmb28sYmFyfWAgb3IgYHsxLi41fWAgYnJhY2VzIGluIHRoZVxuICogZ2l2ZW4gYHN0cmluZ2AuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBgc3RyYFxuICogQHBhcmFtICB7QXJyYXl9IGBhcnJgXG4gKiBAcGFyYW0gIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuZnVuY3Rpb24gYnJhY2VzKHN0ciwgYXJyLCBvcHRpb25zKSB7XG4gIGlmIChzdHIgPT09ICcnKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBvcHRpb25zID0gYXJyO1xuICAgIGFyciA9IFtdO1xuICB9XG5cbiAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuICBhcnIgPSBhcnIgfHwgW107XG5cbiAgaWYgKHR5cGVvZiBvcHRzLm5vZHVwZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3B0cy5ub2R1cGVzID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBmbiA9IG9wdHMuZm47XG4gIHZhciBlczY7XG5cbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm4gPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIGlmICghKHBhdHRlcm5SZSBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcbiAgICBwYXR0ZXJuUmUgPSBwYXR0ZXJuUmVnZXgoKTtcbiAgfVxuXG4gIHZhciBtYXRjaGVzID0gc3RyLm1hdGNoKHBhdHRlcm5SZSkgfHwgW107XG4gIHZhciBtID0gbWF0Y2hlc1swXTtcblxuICBzd2l0Y2gobSkge1xuICAgIGNhc2UgJ1xcXFwsJzpcbiAgICAgIHJldHVybiBlc2NhcGVDb21tYXMoc3RyLCBhcnIsIG9wdHMpO1xuICAgIGNhc2UgJ1xcXFwuJzpcbiAgICAgIHJldHVybiBlc2NhcGVEb3RzKHN0ciwgYXJyLCBvcHRzKTtcbiAgICBjYXNlICdcXC8uJzpcbiAgICAgIHJldHVybiBlc2NhcGVQYXRocyhzdHIsIGFyciwgb3B0cyk7XG4gICAgY2FzZSAnICc6XG4gICAgICByZXR1cm4gc3BsaXRXaGl0ZXNwYWNlKHN0cik7XG4gICAgY2FzZSAneyx9JzpcbiAgICAgIHJldHVybiBleHBvbmVudGlhbChzdHIsIG9wdHMsIGJyYWNlcyk7XG4gICAgY2FzZSAne30nOlxuICAgICAgcmV0dXJuIGVtcHR5QnJhY2VzKHN0ciwgYXJyLCBvcHRzKTtcbiAgICBjYXNlICdcXFxceyc6XG4gICAgY2FzZSAnXFxcXH0nOlxuICAgICAgcmV0dXJuIGVzY2FwZUJyYWNlcyhzdHIsIGFyciwgb3B0cyk7XG4gICAgY2FzZSAnJHsnOlxuICAgICAgaWYgKCEvXFx7W157XStcXHsvLnRlc3Qoc3RyKSkge1xuICAgICAgICByZXR1cm4gYXJyLmNvbmNhdChzdHIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXM2ID0gdHJ1ZTtcbiAgICAgICAgc3RyID0gdG9rZW5zLmJlZm9yZShzdHIsIGVzNlJlZ2V4KCkpO1xuICAgICAgfVxuICB9XG5cbiAgaWYgKCEoYnJhY2VSZSBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcbiAgICBicmFjZVJlID0gYnJhY2VSZWdleCgpO1xuICB9XG5cbiAgdmFyIG1hdGNoID0gYnJhY2VSZS5leGVjKHN0cik7XG4gIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtzdHJdO1xuICB9XG5cbiAgdmFyIG91dHRlciA9IG1hdGNoWzFdO1xuICB2YXIgaW5uZXIgPSBtYXRjaFsyXTtcbiAgaWYgKGlubmVyID09PSAnJykgeyByZXR1cm4gW3N0cl07IH1cblxuICB2YXIgc2Vncywgc2Vnc0xlbmd0aDtcblxuICBpZiAoaW5uZXIuaW5kZXhPZignLi4nKSAhPT0gLTEpIHtcbiAgICBzZWdzID0gZXhwYW5kKGlubmVyLCBvcHRzLCBmbikgfHwgaW5uZXIuc3BsaXQoJywnKTtcbiAgICBzZWdzTGVuZ3RoID0gc2Vncy5sZW5ndGg7XG5cbiAgfSBlbHNlIGlmIChpbm5lclswXSA9PT0gJ1wiJyB8fCBpbm5lclswXSA9PT0gJ1xcJycpIHtcbiAgICByZXR1cm4gYXJyLmNvbmNhdChzdHIuc3BsaXQoL1snXCJdLykuam9pbignJykpO1xuXG4gIH0gZWxzZSB7XG4gICAgc2VncyA9IGlubmVyLnNwbGl0KCcsJyk7XG4gICAgaWYgKG9wdHMubWFrZVJlKSB7XG4gICAgICByZXR1cm4gYnJhY2VzKHN0ci5yZXBsYWNlKG91dHRlciwgd3JhcChzZWdzLCAnfCcpKSwgb3B0cyk7XG4gICAgfVxuXG4gICAgc2Vnc0xlbmd0aCA9IHNlZ3MubGVuZ3RoO1xuICAgIGlmIChzZWdzTGVuZ3RoID09PSAxICYmIG9wdHMuYmFzaCkge1xuICAgICAgc2Vnc1swXSA9IHdyYXAoc2Vnc1swXSwgJ1xcXFwnKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbGVuID0gc2Vncy5sZW5ndGg7XG4gIHZhciBpID0gMCwgdmFsO1xuXG4gIHdoaWxlIChsZW4tLSkge1xuICAgIHZhciBwYXRoID0gc2Vnc1tpKytdO1xuXG4gICAgaWYgKC8oXFwuW14uXFwvXSkvLnRlc3QocGF0aCkpIHtcbiAgICAgIGlmIChzZWdzTGVuZ3RoID4gMSkge1xuICAgICAgICByZXR1cm4gc2VncztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbc3RyXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWwgPSBzcGxpY2Uoc3RyLCBvdXR0ZXIsIHBhdGgpO1xuXG4gICAgaWYgKC9cXHtbXnt9XSs/XFx9Ly50ZXN0KHZhbCkpIHtcbiAgICAgIGFyciA9IGJyYWNlcyh2YWwsIGFyciwgb3B0cyk7XG4gICAgfSBlbHNlIGlmICh2YWwgIT09ICcnKSB7XG4gICAgICBpZiAob3B0cy5ub2R1cGVzICYmIGFyci5pbmRleE9mKHZhbCkgIT09IC0xKSB7IGNvbnRpbnVlOyB9XG4gICAgICBhcnIucHVzaChlczYgPyB0b2tlbnMuYWZ0ZXIodmFsKSA6IHZhbCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMuc3RyaWN0KSB7IHJldHVybiBmaWx0ZXIoYXJyLCBmaWx0ZXJFbXB0eSk7IH1cbiAgcmV0dXJuIGFycjtcbn1cblxuLyoqXG4gKiBFeHBhbmQgZXhwb25lbnRpYWwgcmFuZ2VzXG4gKlxuICogICBgYXssfXssfWAgPT4gWydhJywgJ2EnLCAnYScsICdhJ11cbiAqL1xuXG5mdW5jdGlvbiBleHBvbmVudGlhbChzdHIsIG9wdGlvbnMsIGZuKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuXG4gIHZhciBvcHRzID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGVzYyA9ICdfX0VTQ19FWFBfXyc7XG4gIHZhciBleHAgPSAwO1xuICB2YXIgcmVzO1xuXG4gIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgneyx9Jyk7XG4gIGlmIChvcHRzLm5vZHVwZXMpIHtcbiAgICByZXR1cm4gZm4ocGFydHMuam9pbignJyksIG9wdHMpO1xuICB9XG5cbiAgZXhwID0gcGFydHMubGVuZ3RoIC0gMTtcbiAgcmVzID0gZm4ocGFydHMuam9pbihlc2MpLCBvcHRzKTtcbiAgdmFyIGxlbiA9IHJlcy5sZW5ndGg7XG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlIChsZW4tLSkge1xuICAgIHZhciBlbGUgPSByZXNbaSsrXTtcbiAgICB2YXIgaWR4ID0gZWxlLmluZGV4T2YoZXNjKTtcblxuICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICBhcnIucHVzaChlbGUpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZSA9IGVsZS5zcGxpdCgnX19FU0NfRVhQX18nKS5qb2luKCcnKTtcbiAgICAgIGlmICghIWVsZSAmJiBvcHRzLm5vZHVwZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIGFyci5wdXNoKGVsZSk7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBudW0gPSBNYXRoLnBvdygyLCBleHApO1xuICAgICAgICBhcnIucHVzaC5hcHBseShhcnIsIHJlcGVhdChlbGUsIG51bSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG4vKipcbiAqIFdyYXAgYSB2YWx1ZSB3aXRoIHBhcmVucywgYnJhY2tldHMgb3IgYnJhY2VzLFxuICogYmFzZWQgb24gdGhlIGdpdmVuIGNoYXJhY3Rlci9zZXBhcmF0b3IuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSBgdmFsYFxuICogQHBhcmFtICB7U3RyaW5nfSBgY2hgXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gd3JhcCh2YWwsIGNoKSB7XG4gIGlmIChjaCA9PT0gJ3wnKSB7XG4gICAgcmV0dXJuICcoJyArIHZhbC5qb2luKGNoKSArICcpJztcbiAgfVxuICBpZiAoY2ggPT09ICcsJykge1xuICAgIHJldHVybiAneycgKyB2YWwuam9pbihjaCkgKyAnfSc7XG4gIH1cbiAgaWYgKGNoID09PSAnLScpIHtcbiAgICByZXR1cm4gJ1snICsgdmFsLmpvaW4oY2gpICsgJ10nO1xuICB9XG4gIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgcmV0dXJuICdcXFxceycgKyB2YWwgKyAnXFxcXH0nO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlIGVtcHR5IGJyYWNlczogYHt9YFxuICovXG5cbmZ1bmN0aW9uIGVtcHR5QnJhY2VzKHN0ciwgYXJyLCBvcHRzKSB7XG4gIHJldHVybiBicmFjZXMoc3RyLnNwbGl0KCd7fScpLmpvaW4oJ1xcXFx7XFxcXH0nKSwgYXJyLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBGaWx0ZXIgb3V0IGVtcHR5LWlzaCB2YWx1ZXNcbiAqL1xuXG5mdW5jdGlvbiBmaWx0ZXJFbXB0eShlbGUpIHtcbiAgcmV0dXJuICEhZWxlICYmIGVsZSAhPT0gJ1xcXFwnO1xufVxuXG4vKipcbiAqIEhhbmRsZSBwYXR0ZXJucyB3aXRoIHdoaXRlc3BhY2VcbiAqL1xuXG5mdW5jdGlvbiBzcGxpdFdoaXRlc3BhY2Uoc3RyKSB7XG4gIHZhciBzZWdzID0gc3RyLnNwbGl0KCcgJyk7XG4gIHZhciBsZW4gPSBzZWdzLmxlbmd0aDtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaSA9IDA7XG5cbiAgd2hpbGUgKGxlbi0tKSB7XG4gICAgcmVzLnB1c2guYXBwbHkocmVzLCBicmFjZXMoc2Vnc1tpKytdKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBIYW5kbGUgZXNjYXBlZCBicmFjZXM6IGBcXFxce2ZvbyxiYXJ9YFxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZUJyYWNlcyhzdHIsIGFyciwgb3B0cykge1xuICBpZiAoIS9cXHtbXntdK1xcey8udGVzdChzdHIpKSB7XG4gICAgcmV0dXJuIGFyci5jb25jYXQoc3RyLnNwbGl0KCdcXFxcJykuam9pbignJykpO1xuICB9IGVsc2Uge1xuICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxcXHsnKS5qb2luKCdfX0xUX0JSQUNFX18nKTtcbiAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcXFx9Jykuam9pbignX19SVF9CUkFDRV9fJyk7XG4gICAgcmV0dXJuIG1hcChicmFjZXMoc3RyLCBhcnIsIG9wdHMpLCBmdW5jdGlvbihlbGUpIHtcbiAgICAgIGVsZSA9IGVsZS5zcGxpdCgnX19MVF9CUkFDRV9fJykuam9pbigneycpO1xuICAgICAgcmV0dXJuIGVsZS5zcGxpdCgnX19SVF9CUkFDRV9fJykuam9pbignfScpO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlIGVzY2FwZWQgZG90czogYHsxXFxcXC4yfWBcbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGVEb3RzKHN0ciwgYXJyLCBvcHRzKSB7XG4gIGlmICghL1teXFxcXF1cXC4uK1xcXFxcXC4vLnRlc3Qoc3RyKSkge1xuICAgIHJldHVybiBhcnIuY29uY2F0KHN0ci5zcGxpdCgnXFxcXCcpLmpvaW4oJycpKTtcbiAgfSBlbHNlIHtcbiAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcXFwuJykuam9pbignX19FU0NfRE9UX18nKTtcbiAgICByZXR1cm4gbWFwKGJyYWNlcyhzdHIsIGFyciwgb3B0cyksIGZ1bmN0aW9uKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5zcGxpdCgnX19FU0NfRE9UX18nKS5qb2luKCcuJyk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgZXNjYXBlZCBkb3RzOiBgezFcXFxcLjJ9YFxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZVBhdGhzKHN0ciwgYXJyLCBvcHRzKSB7XG4gIHN0ciA9IHN0ci5zcGxpdCgnXFwvLicpLmpvaW4oJ19fRVNDX1BBVEhfXycpO1xuICByZXR1cm4gbWFwKGJyYWNlcyhzdHIsIGFyciwgb3B0cyksIGZ1bmN0aW9uKGVsZSkge1xuICAgIHJldHVybiBlbGUuc3BsaXQoJ19fRVNDX1BBVEhfXycpLmpvaW4oJ1xcLy4nKTtcbiAgfSk7XG59XG5cbi8qKlxuICogSGFuZGxlIGVzY2FwZWQgY29tbWFzOiBge2FcXFxcLGJ9YFxuICovXG5cbmZ1bmN0aW9uIGVzY2FwZUNvbW1hcyhzdHIsIGFyciwgb3B0cykge1xuICBpZiAoIS9cXHcsLy50ZXN0KHN0cikpIHtcbiAgICByZXR1cm4gYXJyLmNvbmNhdChzdHIuc3BsaXQoJ1xcXFwnKS5qb2luKCcnKSk7XG4gIH0gZWxzZSB7XG4gICAgc3RyID0gc3RyLnNwbGl0KCdcXFxcLCcpLmpvaW4oJ19fRVNDX0NPTU1BX18nKTtcbiAgICByZXR1cm4gbWFwKGJyYWNlcyhzdHIsIGFyciwgb3B0cyksIGZ1bmN0aW9uKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5zcGxpdCgnX19FU0NfQ09NTUFfXycpLmpvaW4oJywnKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFJlZ2V4IGZvciBjb21tb24gcGF0dGVybnNcbiAqL1xuXG5mdW5jdGlvbiBwYXR0ZXJuUmVnZXgoKSB7XG4gIHJldHVybiAvXFwke3woICg/PVt7LH1dKXwoPz1beyx9XSkgKXx7fXx7LH18XFxcXCwoPz0uKlt7fV0pfFxcL1xcLig/PS4qW3t9XSl8XFxcXFxcLig/PXspfFxcXFx7fFxcXFx9Lztcbn1cblxuLyoqXG4gKiBCcmFjZXMgcmVnZXguXG4gKi9cblxuZnVuY3Rpb24gYnJhY2VSZWdleCgpIHtcbiAgcmV0dXJuIC8uKihcXFxcP1xceyhbXn1dKylcXH0pLztcbn1cblxuLyoqXG4gKiBlczYgZGVsaW1pdGVyIHJlZ2V4LlxuICovXG5cbmZ1bmN0aW9uIGVzNlJlZ2V4KCkge1xuICByZXR1cm4gL1xcJFxceyhbXn1dKylcXH0vO1xufVxuXG52YXIgYnJhY2VSZTtcbnZhciBwYXR0ZXJuUmU7XG5cbi8qKlxuICogRmFzdGVyIGFsdGVybmF0aXZlIHRvIGBTdHJpbmcucmVwbGFjZSgpYCB3aGVuIHRoZVxuICogaW5kZXggb2YgdGhlIHRva2VuIHRvIGJlIHJlcGxhY2VzIGNhbid0IGJlIHN1cHBsaWVkXG4gKi9cblxuZnVuY3Rpb24gc3BsaWNlKHN0ciwgdG9rZW4sIHJlcGxhY2VtZW50KSB7XG4gIHZhciBpID0gc3RyLmluZGV4T2YodG9rZW4pO1xuICByZXR1cm4gc3RyLnN1YnN0cigwLCBpKSArIHJlcGxhY2VtZW50XG4gICAgKyBzdHIuc3Vic3RyKGkgKyB0b2tlbi5sZW5ndGgpO1xufVxuXG4vKipcbiAqIEZhc3QgYXJyYXkgbWFwXG4gKi9cblxuZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcbiAgaWYgKGFyciA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgdmFyIGkgPSAtMTtcblxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgcmVzW2ldID0gZm4oYXJyW2ldLCBpLCBhcnIpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBGYXN0IGFycmF5IGZpbHRlclxuICovXG5cbmZ1bmN0aW9uIGZpbHRlcihhcnIsIGNiKSB7XG4gIGlmIChhcnIgPT0gbnVsbCkgcmV0dXJuIFtdO1xuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYnJhY2VzOiBmaWx0ZXIgZXhwZWN0cyBhIGNhbGxiYWNrIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciByZXMgPSBhcnIuc2xpY2UoKTtcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlIChsZW4tLSkge1xuICAgIGlmICghY2IoYXJyW2xlbl0sIGkrKykpIHtcbiAgICAgIHJlcy5zcGxpY2UobGVuLCAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9icmFjZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIGV4cGFuZC1yYW5nZSA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvZXhwYW5kLXJhbmdlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE1LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBmaWxsID0gcmVxdWlyZSgnZmlsbC1yYW5nZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4cGFuZFJhbmdlKHN0ciwgb3B0aW9ucywgZm4pIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwYW5kLXJhbmdlIGV4cGVjdHMgYSBzdHJpbmcuJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmbiA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnYm9vbGVhbicpIHtcbiAgICBvcHRpb25zID0ge307XG4gICAgb3B0aW9ucy5tYWtlUmUgPSB0cnVlO1xuICB9XG5cbiAgLy8gY3JlYXRlIGFyZ3VtZW50cyB0byBwYXNzIHRvIGZpbGwtcmFuZ2VcbiAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgYXJncyA9IHN0ci5zcGxpdCgnLi4nKTtcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICBpZiAobGVuID4gMykgeyByZXR1cm4gc3RyOyB9XG5cbiAgLy8gaWYgb25seSBvbmUgYXJndW1lbnQsIGl0IGNhbid0IGV4cGFuZCBzbyByZXR1cm4gaXRcbiAgaWYgKGxlbiA9PT0gMSkgeyByZXR1cm4gYXJnczsgfVxuXG4gIC8vIGlmIGB0cnVlYCwgdGVsbCBmaWxsLXJhbmdlIHRvIHJlZ2V4aWZ5IHRoZSBzdHJpbmdcbiAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Jvb2xlYW4nICYmIGZuID09PSB0cnVlKSB7XG4gICAgb3B0cy5tYWtlUmUgPSB0cnVlO1xuICB9XG5cbiAgYXJncy5wdXNoKG9wdHMpO1xuICByZXR1cm4gZmlsbC5hcHBseShudWxsLCBhcmdzLmNvbmNhdChmbikpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9leHBhbmQtcmFuZ2UvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIGZpbGwtcmFuZ2UgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2ZpbGwtcmFuZ2U+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTUsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnaXNvYmplY3QnKTtcbnZhciBpc051bWJlciA9IHJlcXVpcmUoJ2lzLW51bWJlcicpO1xudmFyIHJhbmRvbWl6ZSA9IHJlcXVpcmUoJ3JhbmRvbWF0aWMnKTtcbnZhciByZXBlYXRTdHIgPSByZXF1aXJlKCdyZXBlYXQtc3RyaW5nJyk7XG52YXIgcmVwZWF0ID0gcmVxdWlyZSgncmVwZWF0LWVsZW1lbnQnKTtcblxuLyoqXG4gKiBFeHBvc2UgYGZpbGxSYW5nZWBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbGxSYW5nZTtcblxuLyoqXG4gKiBSZXR1cm4gYSByYW5nZSBvZiBudW1iZXJzIG9yIGxldHRlcnMuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBgYWAgU3RhcnQgb2YgdGhlIHJhbmdlXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGBiYCBFbmQgb2YgdGhlIHJhbmdlXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGBzdGVwYCBJbmNyZW1lbnQgb3IgZGVjcmVtZW50IHRvIHVzZS5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBgZm5gIEN1c3RvbSBmdW5jdGlvbiB0byBtb2RpZnkgZWFjaCBlbGVtZW50IGluIHRoZSByYW5nZS5cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIGZpbGxSYW5nZShhLCBiLCBzdGVwLCBvcHRpb25zLCBmbikge1xuICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZmlsbC1yYW5nZSBleHBlY3RzIHRoZSBmaXJzdCBhbmQgc2Vjb25kIGFyZ3MgdG8gYmUgc3RyaW5ncy4nKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc3RlcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuID0gc3RlcDsgb3B0aW9ucyA9IHt9OyBzdGVwID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuID0gb3B0aW9uczsgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgaWYgKGlzT2JqZWN0KHN0ZXApKSB7XG4gICAgb3B0aW9ucyA9IHN0ZXA7IHN0ZXAgPSAnJztcbiAgfVxuXG4gIHZhciBleHBhbmQsIHJlZ2V4ID0gZmFsc2UsIHNlcCA9ICcnO1xuICB2YXIgb3B0cyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKHR5cGVvZiBvcHRzLnNpbGVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvcHRzLnNpbGVudCA9IHRydWU7XG4gIH1cblxuICBzdGVwID0gc3RlcCB8fCBvcHRzLnN0ZXA7XG5cbiAgLy8gc3RvcmUgYSByZWYgdG8gdW5tb2RpZmllZCBhcmdcbiAgdmFyIG9yaWdBID0gYSwgb3JpZ0IgPSBiO1xuXG4gIGIgPSAoYi50b1N0cmluZygpID09PSAnLTAnKSA/IDAgOiBiO1xuXG4gIGlmIChvcHRzLm9wdGltaXplIHx8IG9wdHMubWFrZVJlKSB7XG4gICAgc3RlcCA9IHN0ZXAgPyAoc3RlcCArPSAnficpIDogc3RlcDtcbiAgICBleHBhbmQgPSB0cnVlO1xuICAgIHJlZ2V4ID0gdHJ1ZTtcbiAgICBzZXAgPSAnfic7XG4gIH1cblxuICAvLyBoYW5kbGUgc3BlY2lhbCBzdGVwIGNoYXJhY3RlcnNcbiAgaWYgKHR5cGVvZiBzdGVwID09PSAnc3RyaW5nJykge1xuICAgIHZhciBtYXRjaCA9IHN0ZXBSZSgpLmV4ZWMoc3RlcCk7XG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciBpID0gbWF0Y2guaW5kZXg7XG4gICAgICB2YXIgbSA9IG1hdGNoWzBdO1xuXG4gICAgICAvLyByZXBlYXQgc3RyaW5nXG4gICAgICBpZiAobSA9PT0gJysnKSB7XG4gICAgICAgIHJldHVybiByZXBlYXQoYSwgYik7XG5cbiAgICAgIC8vIHJhbmRvbWl6ZSBhLCBgYmAgdGltZXNcbiAgICAgIH0gZWxzZSBpZiAobSA9PT0gJz8nKSB7XG4gICAgICAgIHJldHVybiBbcmFuZG9taXplKGEsIGIpXTtcblxuICAgICAgLy8gZXhwYW5kIHJpZ2h0LCBubyByZWdleCByZWR1Y3Rpb25cbiAgICAgIH0gZWxzZSBpZiAobSA9PT0gJz4nKSB7XG4gICAgICAgIHN0ZXAgPSBzdGVwLnN1YnN0cigwLCBpKSArIHN0ZXAuc3Vic3RyKGkgKyAxKTtcbiAgICAgICAgZXhwYW5kID0gdHJ1ZTtcblxuICAgICAgLy8gZXhwYW5kIHRvIGFuIGFycmF5LCBvciBpZiB2YWxpZCBjcmVhdGUgYSByZWR1Y2VkXG4gICAgICAvLyBzdHJpbmcgZm9yIGEgcmVnZXggbG9naWMgYG9yYFxuICAgICAgfSBlbHNlIGlmIChtID09PSAnfCcpIHtcbiAgICAgICAgc3RlcCA9IHN0ZXAuc3Vic3RyKDAsIGkpICsgc3RlcC5zdWJzdHIoaSArIDEpO1xuICAgICAgICBleHBhbmQgPSB0cnVlO1xuICAgICAgICByZWdleCA9IHRydWU7XG4gICAgICAgIHNlcCA9IG07XG5cbiAgICAgIC8vIGV4cGFuZCB0byBhbiBhcnJheSwgb3IgaWYgdmFsaWQgY3JlYXRlIGEgcmVkdWNlZFxuICAgICAgLy8gc3RyaW5nIGZvciBhIHJlZ2V4IHJhbmdlXG4gICAgICB9IGVsc2UgaWYgKG0gPT09ICd+Jykge1xuICAgICAgICBzdGVwID0gc3RlcC5zdWJzdHIoMCwgaSkgKyBzdGVwLnN1YnN0cihpICsgMSk7XG4gICAgICAgIGV4cGFuZCA9IHRydWU7XG4gICAgICAgIHJlZ2V4ID0gdHJ1ZTtcbiAgICAgICAgc2VwID0gbTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc051bWJlcihzdGVwKSkge1xuICAgICAgaWYgKCFvcHRzLnNpbGVudCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmaWxsLXJhbmdlOiBpbnZhbGlkIHN0ZXAuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBpZiAoL1suJiooKVtcXF1eJSQjQCFdLy50ZXN0KGEpIHx8IC9bLiYqKClbXFxdXiUkI0AhXS8udGVzdChiKSkge1xuICAgIGlmICghb3B0cy5zaWxlbnQpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdmaWxsLXJhbmdlOiBpbnZhbGlkIHJhbmdlIGFyZ3VtZW50cy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBoYXMgbmVpdGhlciBhIGxldHRlciBub3IgbnVtYmVyLCBvciBoYXMgYm90aCBsZXR0ZXJzIGFuZCBudW1iZXJzXG4gIC8vIHRoaXMgbmVlZHMgdG8gYmUgYWZ0ZXIgdGhlIHN0ZXAgbG9naWNcbiAgaWYgKCFub0FscGhhTnVtKGEpIHx8ICFub0FscGhhTnVtKGIpIHx8IGhhc0JvdGgoYSkgfHwgaGFzQm90aChiKSkge1xuICAgIGlmICghb3B0cy5zaWxlbnQpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdmaWxsLXJhbmdlOiBpbnZhbGlkIHJhbmdlIGFyZ3VtZW50cy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyB2YWxpZGF0ZSBhcmd1bWVudHNcbiAgdmFyIGlzTnVtQSA9IGlzTnVtYmVyKHplcm9zKGEpKTtcbiAgdmFyIGlzTnVtQiA9IGlzTnVtYmVyKHplcm9zKGIpKTtcblxuICBpZiAoKCFpc051bUEgJiYgaXNOdW1CKSB8fCAoaXNOdW1BICYmICFpc051bUIpKSB7XG4gICAgaWYgKCFvcHRzLnNpbGVudCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZmlsbC1yYW5nZTogZmlyc3QgcmFuZ2UgYXJndW1lbnQgaXMgaW5jb21wYXRpYmxlIHdpdGggc2Vjb25kLicpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIGJ5IHRoaXMgcG9pbnQgYm90aCBhcmUgdGhlIHNhbWUsIHNvIHdlXG4gIC8vIGNhbiB1c2UgQSB0byBjaGVjayBnb2luZyBmb3J3YXJkLlxuICB2YXIgaXNOdW0gPSBpc051bUE7XG4gIHZhciBudW0gPSBmb3JtYXRTdGVwKHN0ZXApO1xuXG4gIC8vIGlzIHRoZSByYW5nZSBhbHBoYWJldGljYWw/IG9yIG51bWVyaWM/XG4gIGlmIChpc051bSkge1xuICAgIC8vIGlmIG51bWVyaWMsIGNvZXJjZSB0byBhbiBpbnRlZ2VyXG4gICAgYSA9ICthOyBiID0gK2I7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3RoZXJ3aXNlLCBnZXQgdGhlIGNoYXJDb2RlIHRvIGV4cGFuZCBhbHBoYSByYW5nZXNcbiAgICBhID0gYS5jaGFyQ29kZUF0KDApO1xuICAgIGIgPSBiLmNoYXJDb2RlQXQoMCk7XG4gIH1cblxuICAvLyBpcyB0aGUgcGF0dGVybiBkZXNjZW5kaW5nP1xuICB2YXIgaXNEZXNjZW5kaW5nID0gYSA+IGI7XG5cbiAgLy8gZG9uJ3QgY3JlYXRlIGEgY2hhcmFjdGVyIGNsYXNzIGlmIHRoZSBhcmdzIGFyZSA8IDBcbiAgaWYgKGEgPCAwIHx8IGIgPCAwKSB7XG4gICAgZXhwYW5kID0gZmFsc2U7XG4gICAgcmVnZXggPSBmYWxzZTtcbiAgfVxuXG4gIC8vIGRldGVjdCBwYWRkaW5nXG4gIHZhciBwYWRkaW5nID0gaXNQYWRkZWQob3JpZ0EsIG9yaWdCKTtcbiAgdmFyIHJlcywgcGFkLCBhcnIgPSBbXTtcbiAgdmFyIGlpID0gMDtcblxuICAvLyBjaGFyYWN0ZXIgY2xhc3NlcywgcmFuZ2VzIGFuZCBsb2dpY2FsIGBvcmBcbiAgaWYgKHJlZ2V4KSB7XG4gICAgaWYgKHNob3VsZEV4cGFuZChhLCBiLCBudW0sIGlzTnVtLCBwYWRkaW5nLCBvcHRzKSkge1xuICAgICAgLy8gbWFrZSBzdXJlIHRoZSBjb3JyZWN0IHNlcGFyYXRvciBpcyB1c2VkXG4gICAgICBpZiAoc2VwID09PSAnfCcgfHwgc2VwID09PSAnficpIHtcbiAgICAgICAgc2VwID0gZGV0ZWN0U2VwYXJhdG9yKGEsIGIsIG51bSwgaXNOdW0sIGlzRGVzY2VuZGluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcChbb3JpZ0EsIG9yaWdCXSwgc2VwLCBvcHRzKTtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoaXNEZXNjZW5kaW5nID8gKGEgPj0gYikgOiAoYSA8PSBiKSkge1xuICAgIGlmIChwYWRkaW5nICYmIGlzTnVtKSB7XG4gICAgICBwYWQgPSBwYWRkaW5nKGEpO1xuICAgIH1cblxuICAgIC8vIGN1c3RvbSBmdW5jdGlvblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcyA9IGZuKGEsIGlzTnVtLCBwYWQsIGlpKyspO1xuXG4gICAgLy8gbGV0dGVyc1xuICAgIH0gZWxzZSBpZiAoIWlzTnVtKSB7XG4gICAgICBpZiAocmVnZXggJiYgaXNJbnZhbGlkQ2hhcihhKSkge1xuICAgICAgICByZXMgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzID0gU3RyaW5nLmZyb21DaGFyQ29kZShhKTtcbiAgICAgIH1cblxuICAgIC8vIG51bWJlcnNcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0gZm9ybWF0UGFkZGluZyhhLCBwYWQpO1xuICAgIH1cblxuICAgIC8vIGFkZCByZXN1bHQgdG8gdGhlIGFycmF5LCBmaWx0ZXJpbmcgYW55IG51bGxlZCB2YWx1ZXNcbiAgICBpZiAocmVzICE9PSBudWxsKSBhcnIucHVzaChyZXMpO1xuXG4gICAgLy8gaW5jcmVtZW50IG9yIGRlY3JlbWVudFxuICAgIGlmIChpc0Rlc2NlbmRpbmcpIHtcbiAgICAgIGEgLT0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhICs9IG51bTtcbiAgICB9XG4gIH1cblxuICAvLyBub3cgdGhhdCB0aGUgYXJyYXkgaXMgZXhwYW5kZWQsIHdlIG5lZWQgdG8gaGFuZGxlIHJlZ2V4XG4gIC8vIGNoYXJhY3RlciBjbGFzc2VzLCByYW5nZXMgb3IgbG9naWNhbCBgb3JgIHRoYXQgd2Fzbid0XG4gIC8vIGFscmVhZHkgaGFuZGxlZCBiZWZvcmUgdGhlIGxvb3BcbiAgaWYgKChyZWdleCB8fCBleHBhbmQpICYmICFvcHRzLm5vZXhwYW5kKSB7XG4gICAgLy8gbWFrZSBzdXJlIHRoZSBjb3JyZWN0IHNlcGFyYXRvciBpcyB1c2VkXG4gICAgaWYgKHNlcCA9PT0gJ3wnIHx8IHNlcCA9PT0gJ34nKSB7XG4gICAgICBzZXAgPSBkZXRlY3RTZXBhcmF0b3IoYSwgYiwgbnVtLCBpc051bSwgaXNEZXNjZW5kaW5nKTtcbiAgICB9XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDEgfHwgYSA8IDAgfHwgYiA8IDApIHsgcmV0dXJuIGFycjsgfVxuICAgIHJldHVybiB3cmFwKGFyciwgc2VwLCBvcHRzKTtcbiAgfVxuXG4gIHJldHVybiBhcnI7XG59XG5cbi8qKlxuICogV3JhcCB0aGUgc3RyaW5nIHdpdGggdGhlIGNvcnJlY3QgcmVnZXhcbiAqIHN5bnRheC5cbiAqL1xuXG5mdW5jdGlvbiB3cmFwKGFyciwgc2VwLCBvcHRzKSB7XG4gIGlmIChzZXAgPT09ICd+JykgeyBzZXAgPSAnLSc7IH1cbiAgdmFyIHN0ciA9IGFyci5qb2luKHNlcCk7XG4gIHZhciBwcmUgPSBvcHRzICYmIG9wdHMucmVnZXhQcmVmaXg7XG5cbiAgLy8gcmVnZXggbG9naWNhbCBgb3JgXG4gIGlmIChzZXAgPT09ICd8Jykge1xuICAgIHN0ciA9IHByZSA/IHByZSArIHN0ciA6IHN0cjtcbiAgICBzdHIgPSAnKCcgKyBzdHIgKyAnKSc7XG4gIH1cblxuICAvLyByZWdleCBjaGFyYWN0ZXIgY2xhc3NcbiAgaWYgKHNlcCA9PT0gJy0nKSB7XG4gICAgc3RyID0gKHByZSAmJiBwcmUgPT09ICdeJylcbiAgICAgID8gcHJlICsgc3RyXG4gICAgICA6IHN0cjtcbiAgICBzdHIgPSAnWycgKyBzdHIgKyAnXSc7XG4gIH1cbiAgcmV0dXJuIFtzdHJdO1xufVxuXG4vKipcbiAqIENoZWNrIGZvciBpbnZhbGlkIGNoYXJhY3RlcnNcbiAqL1xuXG5mdW5jdGlvbiBpc0NoYXJDbGFzcyhhLCBiLCBzdGVwLCBpc051bSwgaXNEZXNjZW5kaW5nKSB7XG4gIGlmIChpc0Rlc2NlbmRpbmcpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChpc051bSkgeyByZXR1cm4gYSA8PSA5ICYmIGIgPD0gOTsgfVxuICBpZiAoYSA8IGIpIHsgcmV0dXJuIHN0ZXAgPT09IDE7IH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIERldGVjdCB0aGUgY29ycmVjdCBzZXBhcmF0b3IgdG8gdXNlXG4gKi9cblxuZnVuY3Rpb24gc2hvdWxkRXhwYW5kKGEsIGIsIG51bSwgaXNOdW0sIHBhZGRpbmcsIG9wdHMpIHtcbiAgaWYgKGlzTnVtICYmIChhID4gOSB8fCBiID4gOSkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIHJldHVybiAhcGFkZGluZyAmJiBudW0gPT09IDEgJiYgYSA8IGI7XG59XG5cbi8qKlxuICogRGV0ZWN0IHRoZSBjb3JyZWN0IHNlcGFyYXRvciB0byB1c2VcbiAqL1xuXG5mdW5jdGlvbiBkZXRlY3RTZXBhcmF0b3IoYSwgYiwgc3RlcCwgaXNOdW0sIGlzRGVzY2VuZGluZykge1xuICB2YXIgaXNDaGFyID0gaXNDaGFyQ2xhc3MoYSwgYiwgc3RlcCwgaXNOdW0sIGlzRGVzY2VuZGluZyk7XG4gIGlmICghaXNDaGFyKSB7XG4gICAgcmV0dXJuICd8JztcbiAgfVxuICByZXR1cm4gJ34nO1xufVxuXG4vKipcbiAqIENvcnJlY3RseSBmb3JtYXQgdGhlIHN0ZXAgYmFzZWQgb24gdHlwZVxuICovXG5cbmZ1bmN0aW9uIGZvcm1hdFN0ZXAoc3RlcCkge1xuICByZXR1cm4gTWF0aC5hYnMoc3RlcCA+PiAwKSB8fCAxO1xufVxuXG4vKipcbiAqIEZvcm1hdCBwYWRkaW5nLCB0YWtpbmcgbGVhZGluZyBgLWAgaW50byBhY2NvdW50XG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0UGFkZGluZyhjaCwgcGFkKSB7XG4gIHZhciByZXMgPSBwYWQgPyBwYWQgKyBjaCA6IGNoO1xuICBpZiAocGFkICYmIGNoLnRvU3RyaW5nKCkuY2hhckF0KDApID09PSAnLScpIHtcbiAgICByZXMgPSAnLScgKyBwYWQgKyBjaC50b1N0cmluZygpLnN1YnN0cigxKTtcbiAgfVxuICByZXR1cm4gcmVzLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogQ2hlY2sgZm9yIGludmFsaWQgY2hhcmFjdGVyc1xuICovXG5cbmZ1bmN0aW9uIGlzSW52YWxpZENoYXIoc3RyKSB7XG4gIHZhciBjaCA9IHRvU3RyKHN0cik7XG4gIHJldHVybiBjaCA9PT0gJ1xcXFwnXG4gICAgfHwgY2ggPT09ICdbJ1xuICAgIHx8IGNoID09PSAnXSdcbiAgICB8fCBjaCA9PT0gJ14nXG4gICAgfHwgY2ggPT09ICcoJ1xuICAgIHx8IGNoID09PSAnKSdcbiAgICB8fCBjaCA9PT0gJ2AnO1xufVxuXG4vKipcbiAqIENvbnZlcnQgdG8gYSBzdHJpbmcgZnJvbSBhIGNoYXJDb2RlXG4gKi9cblxuZnVuY3Rpb24gdG9TdHIoY2gpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xufVxuXG5cbi8qKlxuICogU3RlcCByZWdleFxuICovXG5cbmZ1bmN0aW9uIHN0ZXBSZSgpIHtcbiAgcmV0dXJuIC9cXD98PnxcXHx8XFwrfFxcfi9nO1xufVxuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIGB2YWxgIGhhcyBlaXRoZXIgYSBsZXR0ZXJcbiAqIG9yIGEgbnVtYmVyXG4gKi9cblxuZnVuY3Rpb24gbm9BbHBoYU51bSh2YWwpIHtcbiAgcmV0dXJuIC9bYS16MC05XS9pLnRlc3QodmFsKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiBgdmFsYCBoYXMgYm90aCBhIGxldHRlciBhbmRcbiAqIGEgbnVtYmVyIChpbnZhbGlkKVxuICovXG5cbmZ1bmN0aW9uIGhhc0JvdGgodmFsKSB7XG4gIHJldHVybiAvW2Etel1bMC05XXxbMC05XVthLXpdL2kudGVzdCh2YWwpO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSB6ZXJvcyBmb3IgY2hlY2tzXG4gKi9cblxuZnVuY3Rpb24gemVyb3ModmFsKSB7XG4gIGlmICgvXi0qMCskLy50ZXN0KHZhbC50b1N0cmluZygpKSkge1xuICAgIHJldHVybiAnMCc7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiBgdmFsYCBoYXMgbGVhZGluZyB6ZXJvcyxcbiAqIG9yIGEgc2ltaWxhciB2YWxpZCBwYXR0ZXJuLlxuICovXG5cbmZ1bmN0aW9uIGhhc1plcm9zKHZhbCkge1xuICByZXR1cm4gL1teLl1cXC58Xi0qMCtbMC05XS8udGVzdCh2YWwpO1xufVxuXG4vKipcbiAqIElmIHRoZSBzdHJpbmcgaXMgcGFkZGVkLCByZXR1cm5zIGEgY3VycmllZCBmdW5jdGlvbiB3aXRoXG4gKiB0aGUgYSBjYWNoZWQgcGFkZGluZyBzdHJpbmcsIG9yIGBmYWxzZWAgaWYgbm8gcGFkZGluZy5cbiAqXG4gKiBAcGFyYW0gIHsqfSBgb3JpZ0FgIFN0cmluZyBvciBudW1iZXIuXG4gKiBAcmV0dXJuIHtTdHJpbmd8Qm9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc1BhZGRlZChvcmlnQSwgb3JpZ0IpIHtcbiAgaWYgKGhhc1plcm9zKG9yaWdBKSB8fCBoYXNaZXJvcyhvcmlnQikpIHtcbiAgICB2YXIgYWxlbiA9IGxlbmd0aChvcmlnQSk7XG4gICAgdmFyIGJsZW4gPSBsZW5ndGgob3JpZ0IpO1xuXG4gICAgdmFyIGxlbiA9IGFsZW4gPj0gYmxlblxuICAgICAgPyBhbGVuXG4gICAgICA6IGJsZW47XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiByZXBlYXRTdHIoJzAnLCBsZW4gLSBsZW5ndGgoYSkpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgc3RyaW5nIGxlbmd0aCBvZiBgdmFsYFxuICovXG5cbmZ1bmN0aW9uIGxlbmd0aCh2YWwpIHtcbiAgcmV0dXJuIHZhbC50b1N0cmluZygpLmxlbmd0aDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9maWxsLXJhbmdlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBpc29iamVjdCA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXNvYmplY3Q+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTUsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB2YWwgIT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiBpc0FycmF5KHZhbCkgPT09IGZhbHNlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9pc29iamVjdC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oMykpKDE0Nik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMgZnJvbSBkbGwtcmVmZXJlbmNlIHZlbmRvcl9hZTk3YmExY2IyNDEyYzFhODY0NFxuLy8gbW9kdWxlIGlkID0gMjMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogaXMtbnVtYmVyIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1udW1iZXI+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTUsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHR5cGVPZiA9IHJlcXVpcmUoJ2tpbmQtb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc051bWJlcihudW0pIHtcbiAgdmFyIHR5cGUgPSB0eXBlT2YobnVtKTtcbiAgaWYgKHR5cGUgIT09ICdudW1iZXInICYmIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBuID0gK251bTtcbiAgcmV0dXJuIChuIC0gbiArIDEpID49IDAgJiYgbnVtICE9PSAnJztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaXMtbnVtYmVyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzQnVmZmVyID0gcmVxdWlyZSgnaXMtYnVmZmVyJyk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIEdldCB0aGUgbmF0aXZlIGB0eXBlb2ZgIGEgdmFsdWUuXG4gKlxuICogQHBhcmFtICB7Kn0gYHZhbGBcbiAqIEByZXR1cm4geyp9IE5hdGl2ZSBqYXZhc2NyaXB0IHR5cGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGtpbmRPZih2YWwpIHtcbiAgLy8gcHJpbWl0aXZpZXNcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICB9XG4gIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9XG4gIGlmICh2YWwgPT09IHRydWUgfHwgdmFsID09PSBmYWxzZSB8fCB2YWwgaW5zdGFuY2VvZiBCb29sZWFuKSB7XG4gICAgcmV0dXJuICdib29sZWFuJztcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgdmFsIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgcmV0dXJuICdzdHJpbmcnO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJyB8fCB2YWwgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICByZXR1cm4gJ251bWJlcic7XG4gIH1cblxuICAvLyBmdW5jdGlvbnNcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgfHwgdmFsIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIC8vIGFycmF5XG4gIGlmICh0eXBlb2YgQXJyYXkuaXNBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuICdhcnJheSc7XG4gIH1cblxuICAvLyBjaGVjayBmb3IgaW5zdGFuY2VzIG9mIFJlZ0V4cCBhbmQgRGF0ZSBiZWZvcmUgY2FsbGluZyBgdG9TdHJpbmdgXG4gIGlmICh2YWwgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gIH1cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gJ2RhdGUnO1xuICB9XG5cbiAgLy8gb3RoZXIgb2JqZWN0c1xuICB2YXIgdHlwZSA9IHRvU3RyaW5nLmNhbGwodmFsKTtcblxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IERhdGVdJykge1xuICAgIHJldHVybiAnZGF0ZSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nKSB7XG4gICAgcmV0dXJuICdhcmd1bWVudHMnO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBFcnJvcl0nKSB7XG4gICAgcmV0dXJuICdlcnJvcic7XG4gIH1cblxuICAvLyBidWZmZXJcbiAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGlzQnVmZmVyKHZhbCkpIHtcbiAgICByZXR1cm4gJ2J1ZmZlcic7XG4gIH1cblxuICAvLyBlczY6IE1hcCwgV2Vha01hcCwgU2V0LCBXZWFrU2V0XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBTZXRdJykge1xuICAgIHJldHVybiAnc2V0JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgV2Vha1NldF0nKSB7XG4gICAgcmV0dXJuICd3ZWFrc2V0JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgTWFwXScpIHtcbiAgICByZXR1cm4gJ21hcCc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFdlYWtNYXBdJykge1xuICAgIHJldHVybiAnd2Vha21hcCc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7XG4gICAgcmV0dXJuICdzeW1ib2wnO1xuICB9XG5cbiAgLy8gdHlwZWQgYXJyYXlzXG4gIGlmICh0eXBlID09PSAnW29iamVjdCBJbnQ4QXJyYXldJykge1xuICAgIHJldHVybiAnaW50OGFycmF5JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgVWludDhBcnJheV0nKSB7XG4gICAgcmV0dXJuICd1aW50OGFycmF5JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJykge1xuICAgIHJldHVybiAndWludDhjbGFtcGVkYXJyYXknO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBJbnQxNkFycmF5XScpIHtcbiAgICByZXR1cm4gJ2ludDE2YXJyYXknO1xuICB9XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBVaW50MTZBcnJheV0nKSB7XG4gICAgcmV0dXJuICd1aW50MTZhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEludDMyQXJyYXldJykge1xuICAgIHJldHVybiAnaW50MzJhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFVpbnQzMkFycmF5XScpIHtcbiAgICByZXR1cm4gJ3VpbnQzMmFycmF5JztcbiAgfVxuICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScpIHtcbiAgICByZXR1cm4gJ2Zsb2F0MzJhcnJheSc7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nKSB7XG4gICAgcmV0dXJuICdmbG9hdDY0YXJyYXknO1xuICB9XG5cbiAgLy8gbXVzdCBiZSBhIHBsYWluIG9iamVjdFxuICByZXR1cm4gJ29iamVjdCc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2tpbmQtb2YvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaXMtYnVmZmVyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiByYW5kb21hdGljIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9yYW5kb21hdGljPlxuICpcbiAqIFRoaXMgd2FzIG9yaWdpbmFsbHkgaW5zcGlyZWQgYnkgPGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzEwNzI3MTU1LzEyNjc2Mzk+XG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc051bWJlciA9IHJlcXVpcmUoJ2lzLW51bWJlcicpO1xudmFyIHR5cGVPZiA9IHJlcXVpcmUoJ2tpbmQtb2YnKTtcblxuLyoqXG4gKiBFeHBvc2UgYHJhbmRvbWF0aWNgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByYW5kb21hdGljO1xuXG4vKipcbiAqIEF2YWlsYWJsZSBtYXNrIGNoYXJhY3RlcnNcbiAqL1xuXG52YXIgdHlwZSA9IHtcbiAgbG93ZXI6ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicsXG4gIHVwcGVyOiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonLFxuICBudW1iZXI6ICcwMTIzNDU2Nzg5JyxcbiAgc3BlY2lhbDogJ34hQCMkJV4mKClfKy09e31bXTtcXCcsLidcbn07XG5cbnR5cGUuYWxsID0gdHlwZS5sb3dlciArIHR5cGUudXBwZXIgKyB0eXBlLm51bWJlcjtcblxuLyoqXG4gKiBHZW5lcmF0ZSByYW5kb20gY2hhcmFjdGVyIHNlcXVlbmNlcyBvZiBhIHNwZWNpZmllZCBgbGVuZ3RoYCxcbiAqIGJhc2VkIG9uIHRoZSBnaXZlbiBgcGF0dGVybmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGBwYXR0ZXJuYCBUaGUgcGF0dGVybiB0byB1c2UgZm9yIGdlbmVyYXRpbmcgdGhlIHJhbmRvbSBzdHJpbmcuXG4gKiBAcGFyYW0ge1N0cmluZ30gYGxlbmd0aGAgVGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nIHRvIGdlbmVyYXRlLlxuICogQHBhcmFtIHtTdHJpbmd9IGBvcHRpb25zYFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiByYW5kb21hdGljKHBhdHRlcm4sIGxlbmd0aCwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyYW5kb21hdGljIGV4cGVjdHMgYSBzdHJpbmcgb3IgbnVtYmVyLicpO1xuICB9XG5cbiAgdmFyIGN1c3RvbSA9IGZhbHNlO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGxlbmd0aCA9IHBhdHRlcm4ubGVuZ3RoO1xuXG4gICAgfSBlbHNlIGlmIChpc051bWJlcihwYXR0ZXJuKSkge1xuICAgICAgb3B0aW9ucyA9IHt9OyBsZW5ndGggPSBwYXR0ZXJuOyBwYXR0ZXJuID0gJyonO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlT2YobGVuZ3RoKSA9PT0gJ29iamVjdCcgJiYgbGVuZ3RoLmhhc093blByb3BlcnR5KCdjaGFycycpKSB7XG4gICAgb3B0aW9ucyA9IGxlbmd0aDtcbiAgICBwYXR0ZXJuID0gb3B0aW9ucy5jaGFycztcbiAgICBsZW5ndGggPSBwYXR0ZXJuLmxlbmd0aDtcbiAgICBjdXN0b20gPSB0cnVlO1xuICB9XG5cbiAgdmFyIG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbWFzayA9ICcnO1xuICB2YXIgcmVzID0gJyc7XG5cbiAgLy8gQ2hhcmFjdGVycyB0byBiZSB1c2VkXG4gIGlmIChwYXR0ZXJuLmluZGV4T2YoJz8nKSAhPT0gLTEpIG1hc2sgKz0gb3B0cy5jaGFycztcbiAgaWYgKHBhdHRlcm4uaW5kZXhPZignYScpICE9PSAtMSkgbWFzayArPSB0eXBlLmxvd2VyO1xuICBpZiAocGF0dGVybi5pbmRleE9mKCdBJykgIT09IC0xKSBtYXNrICs9IHR5cGUudXBwZXI7XG4gIGlmIChwYXR0ZXJuLmluZGV4T2YoJzAnKSAhPT0gLTEpIG1hc2sgKz0gdHlwZS5udW1iZXI7XG4gIGlmIChwYXR0ZXJuLmluZGV4T2YoJyEnKSAhPT0gLTEpIG1hc2sgKz0gdHlwZS5zcGVjaWFsO1xuICBpZiAocGF0dGVybi5pbmRleE9mKCcqJykgIT09IC0xKSBtYXNrICs9IHR5cGUuYWxsO1xuICBpZiAoY3VzdG9tKSBtYXNrICs9IHBhdHRlcm47XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgcmVzICs9IG1hc2suY2hhckF0KHBhcnNlSW50KE1hdGgucmFuZG9tKCkgKiBtYXNrLmxlbmd0aCwgMTApKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yYW5kb21hdGljL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiByZXBlYXQtc3RyaW5nIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9yZXBlYXQtc3RyaW5nPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE1LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmVzdWx0cyBjYWNoZVxuICovXG5cbnZhciByZXMgPSAnJztcbnZhciBjYWNoZTtcblxuLyoqXG4gKiBFeHBvc2UgYHJlcGVhdGBcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcGVhdDtcblxuLyoqXG4gKiBSZXBlYXQgdGhlIGdpdmVuIGBzdHJpbmdgIHRoZSBzcGVjaWZpZWQgYG51bWJlcmBcbiAqIG9mIHRpbWVzLlxuICpcbiAqICoqRXhhbXBsZToqKlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVwZWF0ID0gcmVxdWlyZSgncmVwZWF0LXN0cmluZycpO1xuICogcmVwZWF0KCdBJywgNSk7XG4gKiAvLz0+IEFBQUFBXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYHN0cmluZ2AgVGhlIHN0cmluZyB0byByZXBlYXRcbiAqIEBwYXJhbSB7TnVtYmVyfSBgbnVtYmVyYCBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFJlcGVhdGVkIHN0cmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiByZXBlYXQoc3RyLCBudW0pIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIC8vIGNvdmVyIGNvbW1vbiwgcXVpY2sgdXNlIGNhc2VzXG4gIGlmIChudW0gPT09IDEpIHJldHVybiBzdHI7XG4gIGlmIChudW0gPT09IDIpIHJldHVybiBzdHIgKyBzdHI7XG5cbiAgdmFyIG1heCA9IHN0ci5sZW5ndGggKiBudW07XG4gIGlmIChjYWNoZSAhPT0gc3RyIHx8IHR5cGVvZiBjYWNoZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjYWNoZSA9IHN0cjtcbiAgICByZXMgPSAnJztcbiAgfSBlbHNlIGlmIChyZXMubGVuZ3RoID49IG1heCkge1xuICAgIHJldHVybiByZXMuc3Vic3RyKDAsIG1heCk7XG4gIH1cblxuICB3aGlsZSAobWF4ID4gcmVzLmxlbmd0aCAmJiBudW0gPiAxKSB7XG4gICAgaWYgKG51bSAmIDEpIHtcbiAgICAgIHJlcyArPSBzdHI7XG4gICAgfVxuXG4gICAgbnVtID4+PSAxO1xuICAgIHN0ciArPSBzdHI7XG4gIH1cblxuICByZXMgKz0gc3RyO1xuICByZXMgPSByZXMuc3Vic3RyKDAsIG1heCk7XG4gIHJldHVybiByZXM7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVwZWF0LXN0cmluZy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogcmVwZWF0LWVsZW1lbnQgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L3JlcGVhdC1lbGVtZW50PlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVwZWF0KGVsZSwgbnVtKSB7XG4gIHZhciBhcnIgPSBuZXcgQXJyYXkobnVtKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgYXJyW2ldID0gZWxlO1xuICB9XG5cbiAgcmV0dXJuIGFycjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVwZWF0LWVsZW1lbnQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIHByZXNlcnZlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9wcmVzZXJ2ZT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFJlcGxhY2UgdG9rZW5zIGluIGBzdHJgIHdpdGggYSB0ZW1wb3JhcnksIGhldXJpc3RpYyBwbGFjZWhvbGRlci5cbiAqXG4gKiBgYGBqc1xuICogdG9rZW5zLmJlZm9yZSgne2FcXFxcLGJ9Jyk7XG4gKiAvLz0+ICd7X19JRDFfX30nXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGBzdHJgXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFN0cmluZyB3aXRoIHBsYWNlaG9sZGVycy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5iZWZvcmUgPSBmdW5jdGlvbiBiZWZvcmUoc3RyLCByZSkge1xuICByZXR1cm4gc3RyLnJlcGxhY2UocmUsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHZhciBpZCA9IHJhbmRvbWl6ZSgpO1xuICAgIGNhY2hlW2lkXSA9IG1hdGNoO1xuICAgIHJldHVybiAnX19JRCcgKyBpZCArICdfXyc7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBSZXBsYWNlIHBsYWNlaG9sZGVycyBpbiBgc3RyYCB3aXRoIG9yaWdpbmFsIHRva2Vucy5cbiAqXG4gKiBgYGBqc1xuICogdG9rZW5zLmFmdGVyKCd7X19JRDFfX30nKTtcbiAqIC8vPT4gJ3thXFxcXCxifSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gYHN0cmAgU3RyaW5nIHdpdGggcGxhY2Vob2xkZXJzXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGBzdHJgIFN0cmluZyB3aXRoIG9yaWdpbmFsIHRva2Vucy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5hZnRlciA9IGZ1bmN0aW9uIGFmdGVyKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL19fSUQoLns1fSlfXy9nLCBmdW5jdGlvbiAoXywgaWQpIHtcbiAgICByZXR1cm4gY2FjaGVbaWRdO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIHJhbmRvbWl6ZSgpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKS5zbGljZSgyLCA3KTtcbn1cblxudmFyIGNhY2hlID0ge307XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3ByZXNlcnZlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBleHBhbmQtYnJhY2tldHMgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2V4cGFuZC1icmFja2V0cz5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNQb3NpeEJyYWNrZXQgPSByZXF1aXJlKCdpcy1wb3NpeC1icmFja2V0Jyk7XG5cbi8qKlxuICogUE9TSVggY2hhcmFjdGVyIGNsYXNzZXNcbiAqL1xuXG52YXIgUE9TSVggPSB7XG4gIGFsbnVtOiAnYS16QS1aMC05JyxcbiAgYWxwaGE6ICdhLXpBLVonLFxuICBibGFuazogJyBcXFxcdCcsXG4gIGNudHJsOiAnXFxcXHgwMC1cXFxceDFGXFxcXHg3RicsXG4gIGRpZ2l0OiAnMC05JyxcbiAgZ3JhcGg6ICdcXFxceDIxLVxcXFx4N0UnLFxuICBsb3dlcjogJ2EteicsXG4gIHByaW50OiAnXFxcXHgyMC1cXFxceDdFJyxcbiAgcHVuY3Q6ICctIVwiIyQlJlxcJygpXFxcXCorLC4vOjs8PT4/QFtcXFxcXV5fYHt8fX4nLFxuICBzcGFjZTogJyBcXFxcdFxcXFxyXFxcXG5cXFxcdlxcXFxmJyxcbiAgdXBwZXI6ICdBLVonLFxuICB3b3JkOiAgJ0EtWmEtejAtOV8nLFxuICB4ZGlnaXQ6ICdBLUZhLWYwLTknLFxufTtcblxuLyoqXG4gKiBFeHBvc2UgYGJyYWNrZXRzYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gYnJhY2tldHM7XG5cbmZ1bmN0aW9uIGJyYWNrZXRzKHN0cikge1xuICBpZiAoIWlzUG9zaXhCcmFja2V0KHN0cikpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIG5lZ2F0ZWQgPSBmYWxzZTtcbiAgaWYgKHN0ci5pbmRleE9mKCdbXicpICE9PSAtMSkge1xuICAgIG5lZ2F0ZWQgPSB0cnVlO1xuICAgIHN0ciA9IHN0ci5zcGxpdCgnW14nKS5qb2luKCdbJyk7XG4gIH1cbiAgaWYgKHN0ci5pbmRleE9mKCdbIScpICE9PSAtMSkge1xuICAgIG5lZ2F0ZWQgPSB0cnVlO1xuICAgIHN0ciA9IHN0ci5zcGxpdCgnWyEnKS5qb2luKCdbJyk7XG4gIH1cblxuICB2YXIgYSA9IHN0ci5zcGxpdCgnWycpO1xuICB2YXIgYiA9IHN0ci5zcGxpdCgnXScpO1xuICB2YXIgaW1iYWxhbmNlZCA9IGEubGVuZ3RoICE9PSBiLmxlbmd0aDtcblxuICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoLyg/OjpcXF1cXFs6fFxcWz9cXFs6fDpcXF1cXF0/KS8pO1xuICB2YXIgbGVuID0gcGFydHMubGVuZ3RoLCBpID0gMDtcbiAgdmFyIGVuZCA9ICcnLCBiZWcgPSAnJztcbiAgdmFyIHJlcyA9IFtdO1xuXG4gIC8vIHN0YXJ0IGF0IHRoZSBlbmQgKGlubmVybW9zdCkgZmlyc3RcbiAgd2hpbGUgKGxlbi0tKSB7XG4gICAgdmFyIGlubmVyID0gcGFydHNbaSsrXTtcbiAgICBpZiAoaW5uZXIgPT09ICdeWyEnIHx8IGlubmVyID09PSAnWyEnKSB7XG4gICAgICBpbm5lciA9ICcnO1xuICAgICAgbmVnYXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHByZWZpeCA9IG5lZ2F0ZWQgPyAnXicgOiAnJztcbiAgICB2YXIgY2ggPSBQT1NJWFtpbm5lcl07XG5cbiAgICBpZiAoY2gpIHtcbiAgICAgIHJlcy5wdXNoKCdbJyArIHByZWZpeCArIGNoICsgJ10nKTtcbiAgICB9IGVsc2UgaWYgKGlubmVyKSB7XG4gICAgICBpZiAoL15cXFs/XFx3LVxcd1xcXT8kLy50ZXN0KGlubmVyKSkge1xuICAgICAgICBpZiAoaSA9PT0gcGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgcmVzLnB1c2goJ1snICsgcHJlZml4ICsgaW5uZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDEpIHtcbiAgICAgICAgICByZXMucHVzaChwcmVmaXggKyBpbm5lciArICddJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzLnB1c2gocHJlZml4ICsgaW5uZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaSA9PT0gMSkge1xuICAgICAgICAgIGJlZyArPSBpbm5lcjtcbiAgICAgICAgfSBlbHNlIGlmIChpID09PSBwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICBlbmQgKz0gaW5uZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzLnB1c2goJ1snICsgcHJlZml4ICsgaW5uZXIgKyAnXScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHJlcy5qb2luKCd8Jyk7XG4gIHZhciBybGVuID0gcmVzLmxlbmd0aCB8fCAxO1xuICBpZiAocmxlbiA+IDEpIHtcbiAgICByZXN1bHQgPSAnKD86JyArIHJlc3VsdCArICcpJztcbiAgICBybGVuID0gMTtcbiAgfVxuICBpZiAoYmVnKSB7XG4gICAgcmxlbisrO1xuICAgIGlmIChiZWcuY2hhckF0KDApID09PSAnWycpIHtcbiAgICAgIGlmIChpbWJhbGFuY2VkKSB7XG4gICAgICAgIGJlZyA9ICdcXFxcWycgKyBiZWcuc2xpY2UoMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiZWcgKz0gJ10nO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQgPSBiZWcgKyByZXN1bHQ7XG4gIH1cbiAgaWYgKGVuZCkge1xuICAgIHJsZW4rKztcbiAgICBpZiAoZW5kLnNsaWNlKC0xKSA9PT0gJ10nKSB7XG4gICAgICBpZiAoaW1iYWxhbmNlZCkge1xuICAgICAgICBlbmQgPSBlbmQuc2xpY2UoMCwgZW5kLmxlbmd0aCAtIDEpICsgJ1xcXFxdJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9ICdbJyArIGVuZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0ICs9IGVuZDtcbiAgfVxuXG4gIGlmIChybGVuID4gMSkge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5zcGxpdCgnXVsnKS5qb2luKCddfFsnKTtcbiAgICBpZiAocmVzdWx0LmluZGV4T2YoJ3wnKSAhPT0gLTEgJiYgIS9cXChcXD8vLnRlc3QocmVzdWx0KSkge1xuICAgICAgcmVzdWx0ID0gJyg/OicgKyByZXN1bHQgKyAnKSc7XG4gICAgfVxuICB9XG5cbiAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL1xcWys9fD1cXF0rL2csICdcXFxcYicpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5icmFja2V0cy5tYWtlUmUgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYnJhY2tldHMocGF0dGVybikpO1xuICB9IGNhdGNoIChlcnIpIHt9XG59O1xuXG5icmFja2V0cy5pc01hdGNoID0gZnVuY3Rpb24oc3RyLCBwYXR0ZXJuKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGJyYWNrZXRzLm1ha2VSZShwYXR0ZXJuKS50ZXN0KHN0cik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuYnJhY2tldHMubWF0Y2ggPSBmdW5jdGlvbihhcnIsIHBhdHRlcm4pIHtcbiAgdmFyIGxlbiA9IGFyci5sZW5ndGgsIGkgPSAwO1xuICB2YXIgcmVzID0gYXJyLnNsaWNlKCk7XG5cbiAgdmFyIHJlID0gYnJhY2tldHMubWFrZVJlKHBhdHRlcm4pO1xuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHZhciBlbGUgPSBhcnJbaSsrXTtcbiAgICBpZiAoIXJlLnRlc3QoZWxlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJlcy5zcGxpY2UoaSwgMSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXhwYW5kLWJyYWNrZXRzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBpcy1wb3NpeC1icmFja2V0IDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1wb3NpeC1icmFja2V0PlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNS0yMDE2LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzUG9zaXhCcmFja2V0KHN0cikge1xuICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgJiYgL1xcWyhbOi49K10pKD86W15cXFtcXF1dfCkrXFwxXFxdLy50ZXN0KHN0cik7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2lzLXBvc2l4LWJyYWNrZXQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIGV4dGdsb2IgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2V4dGdsb2I+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBpc0V4dGdsb2IgPSByZXF1aXJlKCdpcy1leHRnbG9iJyk7XG52YXIgcmUsIGNhY2hlID0ge307XG5cbi8qKlxuICogRXhwb3NlIGBleHRnbG9iYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXh0Z2xvYjtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBleHRnbG9iIGBzdHJpbmdgIHRvIGEgcmVnZXgtY29tcGF0aWJsZVxuICogc3RyaW5nLlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgZXh0Z2xvYiA9IHJlcXVpcmUoJ2V4dGdsb2InKTtcbiAqIGV4dGdsb2IoJyEoYT8oYikpJyk7XG4gKiAvLz0+ICcoPyFhKD86Yik/KVteL10qPydcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyYCBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiAgIEBvcHRpb24ge0Jvb2xlYW59IFtvcHRpb25zXSBgZXNjYCBJZiBgZmFsc2VgIHNwZWNpYWwgY2hhcmFjdGVycyB3aWxsIG5vdCBiZSBlc2NhcGVkLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gKiAgIEBvcHRpb24ge0Jvb2xlYW59IFtvcHRpb25zXSBgcmVnZXhgIElmIGB0cnVlYCBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyByZXR1cm5lZCBpbnN0ZWFkIG9mIGEgc3RyaW5nLlxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGV4dGdsb2Ioc3RyLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB2YXIgbyA9IHt9LCBpID0gMDtcblxuICAvLyBmaXggY29tbW9uIGNoYXJhY3RlciByZXZlcnNhbHNcbiAgLy8gJyohKC5qcyknID0+ICcqLiEoanMpJ1xuICBzdHIgPSBzdHIucmVwbGFjZSgvIVxcKChbXlxcdyooKV0pL2csICckMSEoJyk7XG5cbiAgLy8gc3VwcG9ydCBmaWxlIGV4dGVuc2lvbiBuZWdhdGlvblxuICBzdHIgPSBzdHIucmVwbGFjZSgvKFsqXFwvXSlcXC4hXFwoWypdXFwpL2csIGZ1bmN0aW9uIChtLCBjaCkge1xuICAgIGlmIChjaCA9PT0gJy8nKSB7XG4gICAgICByZXR1cm4gZXNjYXBlKCdcXFxcL1teLl0rJyk7XG4gICAgfVxuICAgIHJldHVybiBlc2NhcGUoJ1teLl0rJyk7XG4gIH0pO1xuXG4gIC8vIGNyZWF0ZSBhIHVuaXF1ZSBrZXkgZm9yIGNhY2hpbmcgYnlcbiAgLy8gY29tYmluaW5nIHRoZSBzdHJpbmcgYW5kIG9wdGlvbnNcbiAgdmFyIGtleSA9IHN0clxuICAgICsgU3RyaW5nKCEhb3B0cy5yZWdleClcbiAgICArIFN0cmluZyghIW9wdHMuY29udGFpbnMpXG4gICAgKyBTdHJpbmcoISFvcHRzLmVzY2FwZSk7XG5cbiAgaWYgKGNhY2hlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICByZXR1cm4gY2FjaGVba2V5XTtcbiAgfVxuXG4gIGlmICghKHJlIGluc3RhbmNlb2YgUmVnRXhwKSkge1xuICAgIHJlID0gcmVnZXgoKTtcbiAgfVxuXG4gIG9wdHMubmVnYXRlID0gZmFsc2U7XG4gIHZhciBtO1xuXG4gIHdoaWxlIChtID0gcmUuZXhlYyhzdHIpKSB7XG4gICAgdmFyIHByZWZpeCA9IG1bMV07XG4gICAgdmFyIGlubmVyID0gbVszXTtcbiAgICBpZiAocHJlZml4ID09PSAnIScpIHtcbiAgICAgIG9wdHMubmVnYXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaWQgPSAnX19FWFRHTE9CXycgKyAoaSsrKSArICdfXyc7XG4gICAgLy8gdXNlIHRoZSBwcmVmaXggb2YgdGhlIF9sYXN0XyAob3V0dGVybW9zdCkgcGF0dGVyblxuICAgIG9baWRdID0gd3JhcChpbm5lciwgcHJlZml4LCBvcHRzLmVzY2FwZSk7XG4gICAgc3RyID0gc3RyLnNwbGl0KG1bMF0pLmpvaW4oaWQpO1xuICB9XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvKTtcbiAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuXG4gIC8vIHdlIGhhdmUgdG8gbG9vcCBhZ2FpbiB0byBhbGxvdyB1cyB0byBjb252ZXJ0XG4gIC8vIHBhdHRlcm5zIGluIHJldmVyc2Ugb3JkZXIgKHN0YXJ0aW5nIHdpdGggdGhlXG4gIC8vIGlubmVybW9zdC9sYXN0IHBhdHRlcm4gZmlyc3QpXG4gIHdoaWxlIChsZW4tLSkge1xuICAgIHZhciBwcm9wID0ga2V5c1tsZW5dO1xuICAgIHN0ciA9IHN0ci5zcGxpdChwcm9wKS5qb2luKG9bcHJvcF0pO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG9wdHMucmVnZXhcbiAgICA/IHRvUmVnZXgoc3RyLCBvcHRzLmNvbnRhaW5zLCBvcHRzLm5lZ2F0ZSlcbiAgICA6IHN0cjtcblxuICByZXN1bHQgPSByZXN1bHQuc3BsaXQoJy4nKS5qb2luKCdcXFxcLicpO1xuXG4gIC8vIGNhY2hlIHRoZSByZXN1bHQgYW5kIHJldHVybiBpdFxuICByZXR1cm4gKGNhY2hlW2tleV0gPSByZXN1bHQpO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYHN0cmluZ2AgdG8gYSByZWdleCBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBgc3RyYFxuICogQHBhcmFtICB7U3RyaW5nfSBgcHJlZml4YCBDaGFyYWN0ZXIgdGhhdCBkZXRlcm1pbmVzIGhvdyB0byB3cmFwIHRoZSBzdHJpbmcuXG4gKiBAcGFyYW0gIHtCb29sZWFufSBgZXNjYCBJZiBgZmFsc2VgIHNwZWNpYWwgY2hhcmFjdGVycyB3aWxsIG5vdCBiZSBlc2NhcGVkLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gd3JhcChpbm5lciwgcHJlZml4LCBlc2MpIHtcbiAgaWYgKGVzYykgaW5uZXIgPSBlc2NhcGUoaW5uZXIpO1xuXG4gIHN3aXRjaCAocHJlZml4KSB7XG4gICAgY2FzZSAnISc6XG4gICAgICByZXR1cm4gJyg/IScgKyBpbm5lciArICcpW14vXScgKyAoZXNjID8gJyUlJX4nIDogJyo/Jyk7XG4gICAgY2FzZSAnQCc6XG4gICAgICByZXR1cm4gJyg/OicgKyBpbm5lciArICcpJztcbiAgICBjYXNlICcrJzpcbiAgICAgIHJldHVybiAnKD86JyArIGlubmVyICsgJykrJztcbiAgICBjYXNlICcqJzpcbiAgICAgIHJldHVybiAnKD86JyArIGlubmVyICsgJyknICsgKGVzYyA/ICclJScgOiAnKicpXG4gICAgY2FzZSAnPyc6XG4gICAgICByZXR1cm4gJyg/OicgKyBpbm5lciArICd8KSc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBpbm5lcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBlc2NhcGUoc3RyKSB7XG4gIHN0ciA9IHN0ci5zcGxpdCgnKicpLmpvaW4oJ1teL10lJSV+Jyk7XG4gIHN0ciA9IHN0ci5zcGxpdCgnLicpLmpvaW4oJ1xcXFwuJyk7XG4gIHJldHVybiBzdHI7XG59XG5cbi8qKlxuICogZXh0Z2xvYiByZWdleC5cbiAqL1xuXG5mdW5jdGlvbiByZWdleCgpIHtcbiAgcmV0dXJuIC8oXFxcXD9bQD8hKyokXVxcXFw/KShcXCgoW14oKV0qPylcXCkpLztcbn1cblxuLyoqXG4gKiBOZWdhdGlvbiByZWdleFxuICovXG5cbmZ1bmN0aW9uIG5lZ2F0ZShzdHIpIHtcbiAgcmV0dXJuICcoPyFeJyArIHN0ciArICcpLiokJztcbn1cblxuLyoqXG4gKiBDcmVhdGUgdGhlIHJlZ2V4IHRvIGRvIHRoZSBtYXRjaGluZy4gSWZcbiAqIHRoZSBsZWFkaW5nIGNoYXJhY3RlciBpbiB0aGUgYHBhdHRlcm5gIGlzIGAhYFxuICogYSBuZWdhdGlvbiByZWdleCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYHBhdHRlcm5gXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGBjb250YWluc2AgQWxsb3cgbG9vc2UgbWF0Y2hpbmcuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGBpc05lZ2F0ZWRgIFRydWUgaWYgdGhlIHBhdHRlcm4gaXMgYSBuZWdhdGlvbiBwYXR0ZXJuLlxuICovXG5cbmZ1bmN0aW9uIHRvUmVnZXgocGF0dGVybiwgY29udGFpbnMsIGlzTmVnYXRlZCkge1xuICB2YXIgcHJlZml4ID0gY29udGFpbnMgPyAnXicgOiAnJztcbiAgdmFyIGFmdGVyID0gY29udGFpbnMgPyAnJCcgOiAnJztcbiAgcGF0dGVybiA9ICgnKD86JyArIHBhdHRlcm4gKyAnKScgKyBhZnRlcik7XG4gIGlmIChpc05lZ2F0ZWQpIHtcbiAgICBwYXR0ZXJuID0gcHJlZml4ICsgbmVnYXRlKHBhdHRlcm4pO1xuICB9XG4gIHJldHVybiBuZXcgUmVnRXhwKHByZWZpeCArIHBhdHRlcm4pO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2V4dGdsb2IvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIGlzLWV4dGdsb2IgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLWV4dGdsb2I+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTUsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNFeHRnbG9iKHN0cikge1xuICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZydcbiAgICAmJiAvW0A/ISsqXVxcKC8udGVzdChzdHIpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9pcy1leHRnbG9iL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBpcy1nbG9iIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1nbG9iPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE1LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG52YXIgaXNFeHRnbG9iID0gcmVxdWlyZSgnaXMtZXh0Z2xvYicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzR2xvYihzdHIpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnXG4gICAgJiYgKC9bKiE/e30ofClbXFxdXS8udGVzdChzdHIpXG4gICAgIHx8IGlzRXh0Z2xvYihzdHIpKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2lzLWdsb2IvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIG5vcm1hbGl6ZS1wYXRoIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9ub3JtYWxpemUtcGF0aD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGgoc3RyLCBzdHJpcFRyYWlsaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gIH1cbiAgc3RyID0gc3RyLnJlcGxhY2UoL1tcXFxcXFwvXSsvZywgJy8nKTtcbiAgaWYgKHN0cmlwVHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgc3RyID0gc3RyLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbm9ybWFsaXplLXBhdGgvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIG9iamVjdC5vbWl0IDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9vYmplY3Qub21pdD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCdpcy1leHRlbmRhYmxlJyk7XG52YXIgZm9yT3duID0gcmVxdWlyZSgnZm9yLW93bicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG9taXQob2JqLCBrZXlzKSB7XG4gIGlmICghaXNPYmplY3Qob2JqKSkgcmV0dXJuIHt9O1xuXG4gIGtleXMgPSBbXS5jb25jYXQuYXBwbHkoW10sIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gIHZhciBsYXN0ID0ga2V5c1trZXlzLmxlbmd0aCAtIDFdO1xuICB2YXIgcmVzID0ge30sIGZuO1xuXG4gIGlmICh0eXBlb2YgbGFzdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuID0ga2V5cy5wb3AoKTtcbiAgfVxuXG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nO1xuICBpZiAoIWtleXMubGVuZ3RoICYmICFpc0Z1bmN0aW9uKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZvck93bihvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoa2V5cy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG5cbiAgICAgIGlmICghaXNGdW5jdGlvbikge1xuICAgICAgICByZXNba2V5XSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChmbih2YWx1ZSwga2V5LCBvYmopKSB7XG4gICAgICAgIHJlc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vb2JqZWN0Lm9taXQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIGlzLWV4dGVuZGFibGUgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLWV4dGVuZGFibGU+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNFeHRlbmRhYmxlKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsICE9PSBudWxsXG4gICAgJiYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9pcy1leHRlbmRhYmxlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBmb3Itb3duIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9mb3Itb3duPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE2LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBmb3JJbiA9IHJlcXVpcmUoJ2Zvci1pbicpO1xudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZm9yT3duKG8sIGZuLCB0aGlzQXJnKSB7XG4gIGZvckluKG8sIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgaWYgKGhhc093bi5jYWxsKG8sIGtleSkpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoaXNBcmcsIG9ba2V5XSwga2V5LCBvKTtcbiAgICB9XG4gIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9mb3Itb3duL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBmb3ItaW4gPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2Zvci1pbj5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNiwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvckluKG8sIGZuLCB0aGlzQXJnKSB7XG4gIGZvciAodmFyIGtleSBpbiBvKSB7XG4gICAgaWYgKGZuLmNhbGwodGhpc0FyZywgb1trZXldLCBrZXksIG8pID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Zvci1pbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogcGFyc2UtZ2xvYiA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvcGFyc2UtZ2xvYj5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzR2xvYiA9IHJlcXVpcmUoJ2lzLWdsb2InKTtcbnZhciBmaW5kQmFzZSA9IHJlcXVpcmUoJ2dsb2ItYmFzZScpO1xudmFyIGV4dGdsb2IgPSByZXF1aXJlKCdpcy1leHRnbG9iJyk7XG52YXIgZG90ZmlsZSA9IHJlcXVpcmUoJ2lzLWRvdGZpbGUnKTtcblxuLyoqXG4gKiBFeHBvc2UgYGNhY2hlYFxuICovXG5cbnZhciBjYWNoZSA9IG1vZHVsZS5leHBvcnRzLmNhY2hlID0ge307XG5cbi8qKlxuICogUGFyc2UgYSBnbG9iIHBhdHRlcm4gaW50byB0b2tlbnMuXG4gKlxuICogV2hlbiBubyBwYXRocyBvciAnKionIGFyZSBpbiB0aGUgZ2xvYiwgd2UgdXNlIGFcbiAqIGRpZmZlcmVudCBzdHJhdGVneSBmb3IgcGFyc2luZyB0aGUgZmlsZW5hbWUsIHNpbmNlXG4gKiBmaWxlIG5hbWVzIGNhbiBjb250YWluIGJyYWNlcyBhbmQgb3RoZXIgZGlmZmljdWx0XG4gKiBwYXR0ZXJucy4gc3VjaCBhczpcbiAqXG4gKiAgLSBgKi57YSxifWBcbiAqICAtIGAoKip8Ki5qcylgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUdsb2IoZ2xvYikge1xuICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkoZ2xvYikpIHtcbiAgICByZXR1cm4gY2FjaGVbZ2xvYl07XG4gIH1cblxuICB2YXIgdG9rID0ge307XG4gIHRvay5vcmlnID0gZ2xvYjtcbiAgdG9rLmlzID0ge307XG5cbiAgLy8gdW5lc2NhcGUgZG90cyBhbmQgc2xhc2hlcyBpbiBicmFjZXMvYnJhY2tldHNcbiAgZ2xvYiA9IGVzY2FwZShnbG9iKTtcblxuICB2YXIgcGFyc2VkID0gZmluZEJhc2UoZ2xvYik7XG4gIHRvay5pcy5nbG9iID0gcGFyc2VkLmlzR2xvYjtcblxuICB0b2suZ2xvYiA9IHBhcnNlZC5nbG9iO1xuICB0b2suYmFzZSA9IHBhcnNlZC5iYXNlO1xuICB2YXIgc2VncyA9IC8oW15cXC9dKikkLy5leGVjKGdsb2IpO1xuXG4gIHRvay5wYXRoID0ge307XG4gIHRvay5wYXRoLmRpcm5hbWUgPSAnJztcbiAgdG9rLnBhdGguYmFzZW5hbWUgPSBzZWdzWzFdIHx8ICcnO1xuICB0b2sucGF0aC5kaXJuYW1lID0gZ2xvYi5zcGxpdCh0b2sucGF0aC5iYXNlbmFtZSkuam9pbignJykgfHwgJyc7XG4gIHZhciBiYXNlbmFtZSA9ICh0b2sucGF0aC5iYXNlbmFtZSB8fCAnJykuc3BsaXQoJy4nKSB8fCAnJztcbiAgdG9rLnBhdGguZmlsZW5hbWUgPSBiYXNlbmFtZVswXSB8fCAnJztcbiAgdG9rLnBhdGguZXh0bmFtZSA9IGJhc2VuYW1lLnNsaWNlKDEpLmpvaW4oJy4nKSB8fCAnJztcbiAgdG9rLnBhdGguZXh0ID0gJyc7XG5cbiAgaWYgKGlzR2xvYih0b2sucGF0aC5kaXJuYW1lKSAmJiAhdG9rLnBhdGguYmFzZW5hbWUpIHtcbiAgICBpZiAoIS9cXC8kLy50ZXN0KHRvay5nbG9iKSkge1xuICAgICAgdG9rLnBhdGguYmFzZW5hbWUgPSB0b2suZ2xvYjtcbiAgICB9XG4gICAgdG9rLnBhdGguZGlybmFtZSA9IHRvay5iYXNlO1xuICB9XG5cbiAgaWYgKGdsb2IuaW5kZXhPZignLycpID09PSAtMSAmJiAhdG9rLmlzLmdsb2JzdGFyKSB7XG4gICAgdG9rLnBhdGguZGlybmFtZSA9ICcnO1xuICAgIHRvay5wYXRoLmJhc2VuYW1lID0gdG9rLm9yaWc7XG4gIH1cblxuICB2YXIgZG90ID0gdG9rLnBhdGguYmFzZW5hbWUuaW5kZXhPZignLicpO1xuICBpZiAoZG90ICE9PSAtMSkge1xuICAgIHRvay5wYXRoLmZpbGVuYW1lID0gdG9rLnBhdGguYmFzZW5hbWUuc2xpY2UoMCwgZG90KTtcbiAgICB0b2sucGF0aC5leHRuYW1lID0gdG9rLnBhdGguYmFzZW5hbWUuc2xpY2UoZG90KTtcbiAgfVxuXG4gIGlmICh0b2sucGF0aC5leHRuYW1lLmNoYXJBdCgwKSA9PT0gJy4nKSB7XG4gICAgdmFyIGV4dHMgPSB0b2sucGF0aC5leHRuYW1lLnNwbGl0KCcuJyk7XG4gICAgdG9rLnBhdGguZXh0ID0gZXh0c1tleHRzLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgLy8gdW5lc2NhcGUgZG90cyBhbmQgc2xhc2hlcyBpbiBicmFjZXMvYnJhY2tldHNcbiAgdG9rLmdsb2IgPSB1bmVzY2FwZSh0b2suZ2xvYik7XG4gIHRvay5wYXRoLmRpcm5hbWUgPSB1bmVzY2FwZSh0b2sucGF0aC5kaXJuYW1lKTtcbiAgdG9rLnBhdGguYmFzZW5hbWUgPSB1bmVzY2FwZSh0b2sucGF0aC5iYXNlbmFtZSk7XG4gIHRvay5wYXRoLmZpbGVuYW1lID0gdW5lc2NhcGUodG9rLnBhdGguZmlsZW5hbWUpO1xuICB0b2sucGF0aC5leHRuYW1lID0gdW5lc2NhcGUodG9rLnBhdGguZXh0bmFtZSk7XG5cbiAgLy8gQm9vbGVhbnNcbiAgdmFyIGlzID0gKGdsb2IgJiYgdG9rLmlzLmdsb2IpO1xuICB0b2suaXMubmVnYXRlZCAgPSBnbG9iICYmIGdsb2IuY2hhckF0KDApID09PSAnISc7XG4gIHRvay5pcy5leHRnbG9iICA9IGdsb2IgJiYgZXh0Z2xvYihnbG9iKTtcbiAgdG9rLmlzLmJyYWNlcyAgID0gaGFzKGlzLCBnbG9iLCAneycpO1xuICB0b2suaXMuYnJhY2tldHMgPSBoYXMoaXMsIGdsb2IsICdbOicpO1xuICB0b2suaXMuZ2xvYnN0YXIgPSBoYXMoaXMsIGdsb2IsICcqKicpO1xuICB0b2suaXMuZG90ZmlsZSAgPSBkb3RmaWxlKHRvay5wYXRoLmJhc2VuYW1lKSB8fCBkb3RmaWxlKHRvay5wYXRoLmZpbGVuYW1lKTtcbiAgdG9rLmlzLmRvdGRpciAgID0gZG90ZGlyKHRvay5wYXRoLmRpcm5hbWUpO1xuICByZXR1cm4gKGNhY2hlW2dsb2JdID0gdG9rKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdsb2IgbWF0Y2hlcyBkb3QtZGlyZWN0b3JpZXMuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBgdG9rYCBUaGUgdG9rZW5zIG9iamVjdFxuICogQHBhcmFtICB7T2JqZWN0fSBgcGF0aGAgVGhlIHBhdGggb2JqZWN0XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gZG90ZGlyKGJhc2UpIHtcbiAgaWYgKGJhc2UuaW5kZXhPZignLy4nKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoYmFzZS5jaGFyQXQoMCkgPT09ICcuJyAmJiBiYXNlLmNoYXJBdCgxKSAhPT0gJy8nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGF0dGVybiBoYXMgdGhlIGdpdmVuIGBjaGBhcmFjdGVyKHMpXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBgZ2xvYmAgVGhlIGdsb2IgcGF0dGVybi5cbiAqIEBwYXJhbSAge09iamVjdH0gYGNoYCBUaGUgY2hhcmFjdGVyIHRvIHRlc3QgZm9yXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gaGFzKGlzLCBnbG9iLCBjaCkge1xuICByZXR1cm4gaXMgJiYgZ2xvYi5pbmRleE9mKGNoKSAhPT0gLTE7XG59XG5cbi8qKlxuICogRXNjYXBlL3VuZXNjYXBlIHV0aWxzXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKHN0cikge1xuICB2YXIgcmUgPSAvXFx7KFtee31dKj8pfXxcXCgoW14oKV0qPylcXCl8XFxbKFteXFxbXFxdXSo/KVxcXS9nO1xuICByZXR1cm4gc3RyLnJlcGxhY2UocmUsIGZ1bmN0aW9uIChvdXR0ZXIsIGJyYWNlcywgcGFyZW5zLCBicmFja2V0cykge1xuICAgIHZhciBpbm5lciA9IGJyYWNlcyB8fCBwYXJlbnMgfHwgYnJhY2tldHM7XG4gICAgaWYgKCFpbm5lcikgeyByZXR1cm4gb3V0dGVyOyB9XG4gICAgcmV0dXJuIG91dHRlci5zcGxpdChpbm5lcikuam9pbihlc2MoaW5uZXIpKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVzYyhzdHIpIHtcbiAgc3RyID0gc3RyLnNwbGl0KCcvJykuam9pbignX19TTEFTSF9fJyk7XG4gIHN0ciA9IHN0ci5zcGxpdCgnLicpLmpvaW4oJ19fRE9UX18nKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gdW5lc2NhcGUoc3RyKSB7XG4gIHN0ciA9IHN0ci5zcGxpdCgnX19TTEFTSF9fJykuam9pbignLycpO1xuICBzdHIgPSBzdHIuc3BsaXQoJ19fRE9UX18nKS5qb2luKCcuJyk7XG4gIHJldHVybiBzdHI7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcGFyc2UtZ2xvYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogZ2xvYi1iYXNlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9nbG9iLWJhc2U+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIHBhcmVudCA9IHJlcXVpcmUoJ2dsb2ItcGFyZW50Jyk7XG52YXIgaXNHbG9iID0gcmVxdWlyZSgnaXMtZ2xvYicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdsb2JCYXNlKHBhdHRlcm4pIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2dsb2ItYmFzZSBleHBlY3RzIGEgc3RyaW5nLicpO1xuICB9XG5cbiAgdmFyIHJlcyA9IHt9O1xuICByZXMuYmFzZSA9IHBhcmVudChwYXR0ZXJuKTtcbiAgcmVzLmlzR2xvYiA9IGlzR2xvYihwYXR0ZXJuKTtcblxuICBpZiAocmVzLmJhc2UgIT09ICcuJykge1xuICAgIHJlcy5nbG9iID0gcGF0dGVybi5zdWJzdHIocmVzLmJhc2UubGVuZ3RoKTtcbiAgICBpZiAocmVzLmdsb2IuY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgIHJlcy5nbG9iID0gcmVzLmdsb2Iuc3Vic3RyKDEpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXMuZ2xvYiA9IHBhdHRlcm47XG4gIH1cblxuICBpZiAoIXJlcy5pc0dsb2IpIHtcbiAgICByZXMuYmFzZSA9IGRpcm5hbWUocGF0dGVybik7XG4gICAgcmVzLmdsb2IgPSByZXMuYmFzZSAhPT0gJy4nXG4gICAgICA/IHBhdHRlcm4uc3Vic3RyKHJlcy5iYXNlLmxlbmd0aClcbiAgICAgIDogcGF0dGVybjtcbiAgfVxuXG4gIGlmIChyZXMuZ2xvYi5zdWJzdHIoMCwgMikgPT09ICcuLycpIHtcbiAgICByZXMuZ2xvYiA9IHJlcy5nbG9iLnN1YnN0cigyKTtcbiAgfVxuICBpZiAocmVzLmdsb2IuY2hhckF0KDApID09PSAnLycpIHtcbiAgICByZXMuZ2xvYiA9IHJlcy5nbG9iLnN1YnN0cigxKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gZGlybmFtZShnbG9iKSB7XG4gIGlmIChnbG9iLnNsaWNlKC0xKSA9PT0gJy8nKSByZXR1cm4gZ2xvYjtcbiAgcmV0dXJuIHBhdGguZGlybmFtZShnbG9iKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9nbG9iLWJhc2UvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIGlzZ2xvYiA9IHJlcXVpcmUoJ2lzLWdsb2InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnbG9iUGFyZW50KHN0cikge1xuXHRzdHIgKz0gJ2EnOyAvLyBwcmVzZXJ2ZXMgZnVsbCBwYXRoIGluIGNhc2Ugb2YgdHJhaWxpbmcgcGF0aCBzZXBhcmF0b3Jcblx0ZG8ge3N0ciA9IHBhdGguZGlybmFtZShzdHIpfSB3aGlsZSAoaXNnbG9iKHN0cikpO1xuXHRyZXR1cm4gc3RyO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9nbG9iLXBhcmVudC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogaXMtZG90ZmlsZSA8aHR0cHM6Ly9naXRodWIuY29tL3JlZ2V4cHMvaXMtZG90ZmlsZT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgSm9uIFNjaGxpbmtlcnQsIGNvbnRyaWJ1dG9ycy5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHN0cikge1xuICBpZiAoc3RyLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8gJiYgc3RyLmluZGV4T2YoJy8nLCAxKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBsYXN0ID0gc3RyLmxhc3RJbmRleE9mKCcvJyk7XG4gIHJldHVybiBsYXN0ICE9PSAtMSA/IHN0ci5jaGFyQ29kZUF0KGxhc3QgKyAxKSA9PT0gNDYgIC8qIC4gKi8gOiBmYWxzZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vaXMtZG90ZmlsZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogcmVnZXgtY2FjaGUgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L3JlZ2V4LWNhY2hlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoJ2lzLXByaW1pdGl2ZScpO1xudmFyIGVxdWFsID0gcmVxdWlyZSgnaXMtZXF1YWwtc2hhbGxvdycpO1xudmFyIGJhc2ljID0ge307XG52YXIgY2FjaGUgPSB7fTtcblxuLyoqXG4gKiBFeHBvc2UgYHJlZ2V4Q2FjaGVgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZWdleENhY2hlO1xuXG4vKipcbiAqIE1lbW9pemUgdGhlIHJlc3VsdHMgb2YgYSBjYWxsIHRvIHRoZSBuZXcgUmVnRXhwIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN0ciBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtPcHRpb25zfSBvcHRpb25zIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge0Jvb2xlYW59IG5vY29tcGFyZSBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKi9cblxuZnVuY3Rpb24gcmVnZXhDYWNoZShmbiwgc3RyLCBvcHRzKSB7XG4gIHZhciBrZXkgPSAnX2RlZmF1bHRfJywgcmVnZXgsIGNhY2hlZDtcblxuICBpZiAoIXN0ciAmJiAhb3B0cykge1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBmbjtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2ljW2tleV0gfHwgKGJhc2ljW2tleV0gPSBmbihzdHIpKTtcbiAgfVxuXG4gIHZhciBpc1N0cmluZyA9IHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnO1xuICBpZiAoaXNTdHJpbmcpIHtcbiAgICBpZiAoIW9wdHMpIHtcbiAgICAgIHJldHVybiBiYXNpY1tzdHJdIHx8IChiYXNpY1tzdHJdID0gZm4oc3RyKSk7XG4gICAgfVxuICAgIGtleSA9IHN0cjtcbiAgfSBlbHNlIHtcbiAgICBvcHRzID0gc3RyO1xuICB9XG5cbiAgY2FjaGVkID0gY2FjaGVba2V5XTtcbiAgaWYgKGNhY2hlZCAmJiBlcXVhbChjYWNoZWQub3B0cywgb3B0cykpIHtcbiAgICByZXR1cm4gY2FjaGVkLnJlZ2V4O1xuICB9XG5cbiAgbWVtbyhrZXksIG9wdHMsIChyZWdleCA9IGZuKHN0ciwgb3B0cykpKTtcbiAgcmV0dXJuIHJlZ2V4O1xufVxuXG5mdW5jdGlvbiBtZW1vKGtleSwgb3B0cywgcmVnZXgpIHtcbiAgY2FjaGVba2V5XSA9IHtyZWdleDogcmVnZXgsIG9wdHM6IG9wdHN9O1xufVxuXG4vKipcbiAqIEV4cG9zZSBgY2FjaGVgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMuY2FjaGUgPSBjYWNoZTtcbm1vZHVsZS5leHBvcnRzLmJhc2ljID0gYmFzaWM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVnZXgtY2FjaGUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIGlzLXByaW1pdGl2ZSA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXMtcHJpbWl0aXZlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE1LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIHNlZSBodHRwOi8vanNwZXJmLmNvbS90ZXN0aW5nLXZhbHVlLWlzLXByaW1pdGl2ZS83XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzUHJpbWl0aXZlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8ICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2lzLXByaW1pdGl2ZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogaXMtZXF1YWwtc2hhbGxvdyA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvaXMtZXF1YWwtc2hhbGxvdz5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzUHJpbWl0aXZlID0gcmVxdWlyZSgnaXMtcHJpbWl0aXZlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gIGlmICghYSAmJiAhYikgeyByZXR1cm4gdHJ1ZTsgfVxuICBpZiAoIWEgJiYgYiB8fCBhICYmICFiKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHZhciBudW1LZXlzQSA9IDAsIG51bUtleXNCID0gMCwga2V5O1xuICBmb3IgKGtleSBpbiBiKSB7XG4gICAgbnVtS2V5c0IrKztcbiAgICBpZiAoIWlzUHJpbWl0aXZlKGJba2V5XSkgfHwgIWEuaGFzT3duUHJvcGVydHkoa2V5KSB8fCAoYVtrZXldICE9PSBiW2tleV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoa2V5IGluIGEpIHtcbiAgICBudW1LZXlzQSsrO1xuICB9XG4gIHJldHVybiBudW1LZXlzQSA9PT0gbnVtS2V5c0I7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2lzLWVxdWFsLXNoYWxsb3cvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjaGFycyA9IHJlcXVpcmUoJy4vY2hhcnMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKiBFeHBvc2UgYEdsb2JgXG4gKi9cblxudmFyIEdsb2IgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIEdsb2IocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgR2xvYikpIHtcbiAgICByZXR1cm4gbmV3IEdsb2IocGF0dGVybiwgb3B0aW9ucyk7XG4gIH1cbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgdGhpcy5oaXN0b3J5ID0gW107XG4gIHRoaXMudG9rZW5zID0ge307XG4gIHRoaXMuaW5pdChwYXR0ZXJuKTtcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBkZWZhdWx0c1xuICovXG5cbkdsb2IucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gIHRoaXMub3JpZyA9IHBhdHRlcm47XG4gIHRoaXMubmVnYXRlZCA9IHRoaXMuaXNOZWdhdGVkKCk7XG4gIHRoaXMub3B0aW9ucy50cmFjayA9IHRoaXMub3B0aW9ucy50cmFjayB8fCBmYWxzZTtcbiAgdGhpcy5vcHRpb25zLm1ha2VSZSA9IHRydWU7XG59O1xuXG4vKipcbiAqIFB1c2ggYSBjaGFuZ2UgaW50byBgZ2xvYi5oaXN0b3J5YC4gVXNlZnVsXG4gKiBmb3IgZGVidWdnaW5nLlxuICovXG5cbkdsb2IucHJvdG90eXBlLnRyYWNrID0gZnVuY3Rpb24obXNnKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMudHJhY2spIHtcbiAgICB0aGlzLmhpc3RvcnkucHVzaCh7bXNnOiBtc2csIHBhdHRlcm46IHRoaXMucGF0dGVybn0pO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIGBnbG9iLnBhdHRlcm5gIHdhcyBuZWdhdGVkXG4gKiB3aXRoIGAhYCwgYWxzbyByZW1vdmUgdGhlIGAhYCBmcm9tIHRoZSBwYXR0ZXJuLlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuR2xvYi5wcm90b3R5cGUuaXNOZWdhdGVkID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnBhdHRlcm4uY2hhckNvZGVBdCgwKSA9PT0gMzMgLyogJyEnICovKSB7XG4gICAgdGhpcy5wYXR0ZXJuID0gdGhpcy5wYXR0ZXJuLnNsaWNlKDEpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogRXhwYW5kIGJyYWNlcyBpbiB0aGUgZ2l2ZW4gZ2xvYiBwYXR0ZXJuLlxuICpcbiAqIFdlIG9ubHkgbmVlZCB0byB1c2UgdGhlIFticmFjZXNdIGxpYiB3aGVuXG4gKiBwYXR0ZXJucyBhcmUgbmVzdGVkLlxuICovXG5cbkdsb2IucHJvdG90eXBlLmJyYWNlcyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLm5vYnJhY2VzICE9PSB0cnVlICYmIHRoaXMub3B0aW9ucy5ub2JyYWNlICE9PSB0cnVlKSB7XG4gICAgLy8gbmFpdmUvZmFzdCBjaGVjayBmb3IgaW1iYWxhbmNlZCBjaGFyYWN0ZXJzXG4gICAgdmFyIGEgPSB0aGlzLnBhdHRlcm4ubWF0Y2goL1tcXHtcXChcXFtdL2cpO1xuICAgIHZhciBiID0gdGhpcy5wYXR0ZXJuLm1hdGNoKC9bXFx9XFwpXFxdXS9nKTtcblxuICAgIC8vIGlmIGltYmFsYW5jZWQsIGRvbid0IG9wdGltaXplIHRoZSBwYXR0ZXJuXG4gICAgaWYgKGEgJiYgYiAmJiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSkge1xuICAgICAgdGhpcy5vcHRpb25zLm1ha2VSZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGV4cGFuZCBicmFjZSBwYXR0ZXJucyBhbmQgam9pbiB0aGUgcmVzdWx0aW5nIGFycmF5XG4gICAgdmFyIGV4cGFuZGVkID0gdXRpbHMuYnJhY2VzKHRoaXMucGF0dGVybiwgdGhpcy5vcHRpb25zKTtcbiAgICB0aGlzLnBhdHRlcm4gPSBleHBhbmRlZC5qb2luKCd8Jyk7XG4gIH1cbn07XG5cbi8qKlxuICogRXhwYW5kIGJyYWNrZXQgZXhwcmVzc2lvbnMgaW4gYGdsb2IucGF0dGVybmBcbiAqL1xuXG5HbG9iLnByb3RvdHlwZS5icmFja2V0cyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLm5vYnJhY2tldHMgIT09IHRydWUpIHtcbiAgICB0aGlzLnBhdHRlcm4gPSB1dGlscy5icmFja2V0cyh0aGlzLnBhdHRlcm4pO1xuICB9XG59O1xuXG4vKipcbiAqIEV4cGFuZCBicmFja2V0IGV4cHJlc3Npb25zIGluIGBnbG9iLnBhdHRlcm5gXG4gKi9cblxuR2xvYi5wcm90b3R5cGUuZXh0Z2xvYiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLm5vZXh0Z2xvYiA9PT0gdHJ1ZSkgcmV0dXJuO1xuXG4gIGlmICh1dGlscy5pc0V4dGdsb2IodGhpcy5wYXR0ZXJuKSkge1xuICAgIHRoaXMucGF0dGVybiA9IHV0aWxzLmV4dGdsb2IodGhpcy5wYXR0ZXJuLCB7ZXNjYXBlOiB0cnVlfSk7XG4gIH1cbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIHBhdHRlcm5cbiAqL1xuXG5HbG9iLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHBhdHRlcm4pIHtcbiAgdGhpcy50b2tlbnMgPSB1dGlscy5wYXJzZUdsb2IocGF0dGVybiB8fCB0aGlzLnBhdHRlcm4sIHRydWUpO1xuICByZXR1cm4gdGhpcy50b2tlbnM7XG59O1xuXG4vKipcbiAqIFJlcGxhY2UgYGFgIHdpdGggYGJgLiBBbHNvIHRyYWNrcyB0aGUgY2hhbmdlIGJlZm9yZSBhbmRcbiAqIGFmdGVyIGVhY2ggcmVwbGFjZW1lbnQuIFRoaXMgaXMgZGlzYWJsZWQgYnkgZGVmYXVsdCwgYnV0XG4gKiBjYW4gYmUgZW5hYmxlZCBieSBzZXR0aW5nIGBvcHRpb25zLnRyYWNrYCB0byB0cnVlLlxuICpcbiAqIEFsc28sIHdoZW4gdGhlIHBhdHRlcm4gaXMgYSBzdHJpbmcsIGAuc3BsaXQoKWAgaXMgdXNlZCxcbiAqIGJlY2F1c2UgaXQncyBtdWNoIGZhc3RlciB0aGFuIHJlcGxhY2UuXG4gKlxuICogQHBhcmFtICB7UmVnRXhwfFN0cmluZ30gYGFgXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGBiYFxuICogQHBhcmFtICB7Qm9vbGVhbn0gYGVzY2FwZWAgV2hlbiBgdHJ1ZWAsIGVzY2FwZXMgYCpgIGFuZCBgP2AgaW4gdGhlIHJlcGxhY2VtZW50LlxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5cbkdsb2IucHJvdG90eXBlLl9yZXBsYWNlID0gZnVuY3Rpb24oYSwgYiwgZXNjYXBlKSB7XG4gIHRoaXMudHJhY2soJ2JlZm9yZSAoZmluZCk6IFwiJyArIGEgKyAnXCIgKHJlcGxhY2Ugd2l0aCk6IFwiJyArIGIgKyAnXCInKTtcbiAgaWYgKGVzY2FwZSkgYiA9IGVzYyhiKTtcbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLnBhdHRlcm4gPSB0aGlzLnBhdHRlcm4uc3BsaXQoYSkuam9pbihiKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnBhdHRlcm4gPSB0aGlzLnBhdHRlcm4ucmVwbGFjZShhLCBiKTtcbiAgfVxuICB0aGlzLnRyYWNrKCdhZnRlcicpO1xufTtcblxuLyoqXG4gKiBFc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIHRoZSBnaXZlbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBgc3RyYCBHbG9iIHBhdHRlcm5cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5HbG9iLnByb3RvdHlwZS5lc2NhcGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgdGhpcy50cmFjaygnYmVmb3JlIGVzY2FwZTogJyk7XG4gIHZhciByZSA9IC9bXCJcXFxcXShbJ1wiXT9bXlwiJ1xcXFxdWydcIl0/KS9nO1xuXG4gIHRoaXMucGF0dGVybiA9IHN0ci5yZXBsYWNlKHJlLCBmdW5jdGlvbigkMCwgJDEpIHtcbiAgICB2YXIgbyA9IGNoYXJzLkVTQztcbiAgICB2YXIgY2ggPSBvICYmIG9bJDFdO1xuICAgIGlmIChjaCkge1xuICAgICAgcmV0dXJuIGNoO1xuICAgIH1cbiAgICBpZiAoL1thLXpdL2kudGVzdCgkMCkpIHtcbiAgICAgIHJldHVybiAkMC5zcGxpdCgnXFxcXCcpLmpvaW4oJycpO1xuICAgIH1cbiAgICByZXR1cm4gJDA7XG4gIH0pO1xuXG4gIHRoaXMudHJhY2soJ2FmdGVyIGVzY2FwZTogJyk7XG59O1xuXG4vKipcbiAqIFVuZXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyBpbiB0aGUgZ2l2ZW4gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gYHN0cmBcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5HbG9iLnByb3RvdHlwZS51bmVzY2FwZSA9IGZ1bmN0aW9uKHN0cikge1xuICB2YXIgcmUgPSAvX18oW0EtWl0rKV8oW0EtWl0rKV9fL2c7XG4gIHRoaXMucGF0dGVybiA9IHN0ci5yZXBsYWNlKHJlLCBmdW5jdGlvbigkMCwgJDEpIHtcbiAgICByZXR1cm4gY2hhcnNbJDFdWyQwXTtcbiAgfSk7XG4gIHRoaXMucGF0dGVybiA9IHVuZXNjKHRoaXMucGF0dGVybik7XG59O1xuXG4vKipcbiAqIEVzY2FwZS91bmVzY2FwZSB1dGlsc1xuICovXG5cbmZ1bmN0aW9uIGVzYyhzdHIpIHtcbiAgc3RyID0gc3RyLnNwbGl0KCc/Jykuam9pbignJX4nKTtcbiAgc3RyID0gc3RyLnNwbGl0KCcqJykuam9pbignJSUnKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gdW5lc2Moc3RyKSB7XG4gIHN0ciA9IHN0ci5zcGxpdCgnJX4nKS5qb2luKCc/Jyk7XG4gIHN0ciA9IHN0ci5zcGxpdCgnJSUnKS5qb2luKCcqJyk7XG4gIHJldHVybiBzdHI7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWljcm9tYXRjaC9saWIvZ2xvYi5qc1xuLy8gbW9kdWxlIGlkID0gMjU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNoYXJzID0ge30sIHVuZXNjLCB0ZW1wO1xuXG5mdW5jdGlvbiByZXZlcnNlKG9iamVjdCwgcHJlcGVuZGVyKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpLnJlZHVjZShmdW5jdGlvbihyZXZlcnNlZCwga2V5KSB7XG4gICAgdmFyIG5ld0tleSA9IHByZXBlbmRlciA/IHByZXBlbmRlciArIGtleSA6IGtleTsgLy8gT3B0aW9uYWxseSBwcmVwZW5kIGEgc3RyaW5nIHRvIGtleS5cbiAgICByZXZlcnNlZFtvYmplY3Rba2V5XV0gPSBuZXdLZXk7IC8vIFN3YXAga2V5IGFuZCB2YWx1ZS5cbiAgICByZXR1cm4gcmV2ZXJzZWQ7IC8vIFJldHVybiB0aGUgcmVzdWx0LlxuICB9LCB7fSk7XG59XG5cbi8qKlxuICogUmVnZXggZm9yIGNvbW1vbiBjaGFyYWN0ZXJzXG4gKi9cblxuY2hhcnMuZXNjYXBlUmVnZXggPSB7XG4gICc/JzogL1xcPy9nLFxuICAnQCc6IC9cXEAvZyxcbiAgJyEnOiAvXFwhL2csXG4gICcrJzogL1xcKy9nLFxuICAnKic6IC9cXCovZyxcbiAgJygnOiAvXFwoL2csXG4gICcpJzogL1xcKS9nLFxuICAnWyc6IC9cXFsvZyxcbiAgJ10nOiAvXFxdL2dcbn07XG5cbi8qKlxuICogRXNjYXBlIGNoYXJhY3RlcnNcbiAqL1xuXG5jaGFycy5FU0MgPSB7XG4gICc/JzogJ19fVU5FU0NfUU1SS19fJyxcbiAgJ0AnOiAnX19VTkVTQ19BTVBFX18nLFxuICAnISc6ICdfX1VORVNDX0VYQ0xfXycsXG4gICcrJzogJ19fVU5FU0NfUExVU19fJyxcbiAgJyonOiAnX19VTkVTQ19TVEFSX18nLFxuICAnLCc6ICdfX1VORVNDX0NPTU1BX18nLFxuICAnKCc6ICdfX1VORVNDX0xUUEFSRU5fXycsXG4gICcpJzogJ19fVU5FU0NfUlRQQVJFTl9fJyxcbiAgJ1snOiAnX19VTkVTQ19MVEJSQUNLX18nLFxuICAnXSc6ICdfX1VORVNDX1JUQlJBQ0tfXydcbn07XG5cbi8qKlxuICogVW5lc2NhcGUgY2hhcmFjdGVyc1xuICovXG5cbmNoYXJzLlVORVNDID0gdW5lc2MgfHwgKHVuZXNjID0gcmV2ZXJzZShjaGFycy5FU0MsICdcXFxcJykpO1xuXG5jaGFycy5FU0NfVEVNUCA9IHtcbiAgJz8nOiAnX19URU1QX1FNUktfXycsXG4gICdAJzogJ19fVEVNUF9BTVBFX18nLFxuICAnISc6ICdfX1RFTVBfRVhDTF9fJyxcbiAgJyonOiAnX19URU1QX1NUQVJfXycsXG4gICcrJzogJ19fVEVNUF9QTFVTX18nLFxuICAnLCc6ICdfX1RFTVBfQ09NTUFfXycsXG4gICcoJzogJ19fVEVNUF9MVFBBUkVOX18nLFxuICAnKSc6ICdfX1RFTVBfUlRQQVJFTl9fJyxcbiAgJ1snOiAnX19URU1QX0xUQlJBQ0tfXycsXG4gICddJzogJ19fVEVNUF9SVEJSQUNLX18nXG59O1xuXG5jaGFycy5URU1QID0gdGVtcCB8fCAodGVtcCA9IHJldmVyc2UoY2hhcnMuRVNDX1RFTVApKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjaGFycztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9taWNyb21hdGNoL2xpYi9jaGFycy5qc1xuLy8gbW9kdWxlIGlkID0gMjU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gcG9zaXgocGF0aCkge1xuXHRyZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn1cblxuZnVuY3Rpb24gd2luMzIocGF0aCkge1xuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9iM2ZjYzI0NWZiMjU1Mzk5MDllZjFkNWVhYTAxZGJmOTJlMTY4NjMzL2xpYi9wYXRoLmpzI0w1NlxuXHR2YXIgc3BsaXREZXZpY2VSZSA9IC9eKFthLXpBLVpdOnxbXFxcXFxcL117Mn1bXlxcXFxcXC9dK1tcXFxcXFwvXStbXlxcXFxcXC9dKyk/KFtcXFxcXFwvXSk/KFtcXHNcXFNdKj8pJC87XG5cdHZhciByZXN1bHQgPSBzcGxpdERldmljZVJlLmV4ZWMocGF0aCk7XG5cdHZhciBkZXZpY2UgPSByZXN1bHRbMV0gfHwgJyc7XG5cdHZhciBpc1VuYyA9IEJvb2xlYW4oZGV2aWNlICYmIGRldmljZS5jaGFyQXQoMSkgIT09ICc6Jyk7XG5cblx0Ly8gVU5DIHBhdGhzIGFyZSBhbHdheXMgYWJzb2x1dGVcblx0cmV0dXJuIEJvb2xlYW4ocmVzdWx0WzJdIHx8IGlzVW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInID8gd2luMzIgOiBwb3NpeDtcbm1vZHVsZS5leHBvcnRzLnBvc2l4ID0gcG9zaXg7XG5tb2R1bGUuZXhwb3J0cy53aW4zMiA9IHdpbjMyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3BhdGgtaXMtYWJzb2x1dGUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIHN5c1BhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgcmVhZGRpcnAgPSByZXF1aXJlKCdyZWFkZGlycCcpO1xudmFyIGlzQmluYXJ5UGF0aCA9IHJlcXVpcmUoJ2lzLWJpbmFyeS1wYXRoJyk7XG5cbi8vIGZzLndhdGNoIGhlbHBlcnNcblxuLy8gb2JqZWN0IHRvIGhvbGQgcGVyLXByb2Nlc3MgZnMud2F0Y2ggaW5zdGFuY2VzXG4vLyAobWF5IGJlIHNoYXJlZCBhY3Jvc3MgY2hva2lkYXIgRlNXYXRjaGVyIGluc3RhbmNlcylcbnZhciBGc1dhdGNoSW5zdGFuY2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuLy8gUHJpdmF0ZSBmdW5jdGlvbjogSW5zdGFudGlhdGVzIHRoZSBmcy53YXRjaCBpbnRlcmZhY2VcblxuLy8gKiBwYXRoICAgICAgIC0gc3RyaW5nLCBwYXRoIHRvIGJlIHdhdGNoZWRcbi8vICogb3B0aW9ucyAgICAtIG9iamVjdCwgb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gZnMud2F0Y2hcbi8vICogbGlzdGVuZXIgICAtIGZ1bmN0aW9uLCBtYWluIGV2ZW50IGhhbmRsZXJcbi8vICogZXJySGFuZGxlciAtIGZ1bmN0aW9uLCBoYW5kbGVyIHdoaWNoIGVtaXRzIGluZm8gYWJvdXQgZXJyb3JzXG4vLyAqIGVtaXRSYXcgICAgLSBmdW5jdGlvbiwgaGFuZGxlciB3aGljaCBlbWl0cyByYXcgZXZlbnQgZGF0YVxuXG4vLyBSZXR1cm5zIG5ldyBmc2V2ZW50cyBpbnN0YW5jZVxuZnVuY3Rpb24gY3JlYXRlRnNXYXRjaEluc3RhbmNlKHBhdGgsIG9wdGlvbnMsIGxpc3RlbmVyLCBlcnJIYW5kbGVyLCBlbWl0UmF3KSB7XG4gIHZhciBoYW5kbGVFdmVudCA9IGZ1bmN0aW9uKHJhd0V2ZW50LCBldlBhdGgpIHtcbiAgICBsaXN0ZW5lcihwYXRoKTtcbiAgICBlbWl0UmF3KHJhd0V2ZW50LCBldlBhdGgsIHt3YXRjaGVkUGF0aDogcGF0aH0pO1xuXG4gICAgLy8gZW1pdCBiYXNlZCBvbiBldmVudHMgb2NjdXJpbmcgZm9yIGZpbGVzIGZyb20gYSBkaXJlY3RvcnkncyB3YXRjaGVyIGluXG4gICAgLy8gY2FzZSB0aGUgZmlsZSdzIHdhdGNoZXIgbWlzc2VzIGl0IChhbmQgcmVseSBvbiB0aHJvdHRsaW5nIHRvIGRlLWR1cGUpXG4gICAgaWYgKGV2UGF0aCAmJiBwYXRoICE9PSBldlBhdGgpIHtcbiAgICAgIGZzV2F0Y2hCcm9hZGNhc3QoXG4gICAgICAgIHN5c1BhdGgucmVzb2x2ZShwYXRoLCBldlBhdGgpLCAnbGlzdGVuZXJzJywgc3lzUGF0aC5qb2luKHBhdGgsIGV2UGF0aClcbiAgICAgICk7XG4gICAgfVxuICB9O1xuICB0cnkge1xuICAgIHJldHVybiBmcy53YXRjaChwYXRoLCBvcHRpb25zLCBoYW5kbGVFdmVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZXJySGFuZGxlcihlcnJvcik7XG4gIH1cbn1cblxuLy8gUHJpdmF0ZSBmdW5jdGlvbjogSGVscGVyIGZvciBwYXNzaW5nIGZzLndhdGNoIGV2ZW50IGRhdGEgdG8gYVxuLy8gY29sbGVjdGlvbiBvZiBsaXN0ZW5lcnNcblxuLy8gKiBmdWxsUGF0aCAgIC0gc3RyaW5nLCBhYnNvbHV0ZSBwYXRoIGJvdW5kIHRvIHRoZSBmcy53YXRjaCBpbnN0YW5jZVxuLy8gKiB0eXBlICAgICAgIC0gc3RyaW5nLCBsaXN0ZW5lciB0eXBlXG4vLyAqIHZhbFsxLi4zXSAgLSBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIGxpc3RlbmVyc1xuXG4vLyBSZXR1cm5zIG5vdGhpbmdcbmZ1bmN0aW9uIGZzV2F0Y2hCcm9hZGNhc3QoZnVsbFBhdGgsIHR5cGUsIHZhbDEsIHZhbDIsIHZhbDMpIHtcbiAgaWYgKCFGc1dhdGNoSW5zdGFuY2VzW2Z1bGxQYXRoXSkgcmV0dXJuO1xuICBGc1dhdGNoSW5zdGFuY2VzW2Z1bGxQYXRoXVt0eXBlXS5mb3JFYWNoKGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgbGlzdGVuZXIodmFsMSwgdmFsMiwgdmFsMyk7XG4gIH0pO1xufVxuXG4vLyBQcml2YXRlIGZ1bmN0aW9uOiBJbnN0YW50aWF0ZXMgdGhlIGZzLndhdGNoIGludGVyZmFjZSBvciBiaW5kcyBsaXN0ZW5lcnNcbi8vIHRvIGFuIGV4aXN0aW5nIG9uZSBjb3ZlcmluZyB0aGUgc2FtZSBmaWxlIHN5c3RlbSBlbnRyeVxuXG4vLyAqIHBhdGggICAgICAgLSBzdHJpbmcsIHBhdGggdG8gYmUgd2F0Y2hlZFxuLy8gKiBmdWxsUGF0aCAgIC0gc3RyaW5nLCBhYnNvbHV0ZSBwYXRoXG4vLyAqIG9wdGlvbnMgICAgLSBvYmplY3QsIG9wdGlvbnMgdG8gYmUgcGFzc2VkIHRvIGZzLndhdGNoXG4vLyAqIGhhbmRsZXJzICAgLSBvYmplY3QsIGNvbnRhaW5lciBmb3IgZXZlbnQgbGlzdGVuZXIgZnVuY3Rpb25zXG5cbi8vIFJldHVybnMgY2xvc2UgZnVuY3Rpb25cbmZ1bmN0aW9uIHNldEZzV2F0Y2hMaXN0ZW5lcihwYXRoLCBmdWxsUGF0aCwgb3B0aW9ucywgaGFuZGxlcnMpIHtcbiAgdmFyIGxpc3RlbmVyID0gaGFuZGxlcnMubGlzdGVuZXI7XG4gIHZhciBlcnJIYW5kbGVyID0gaGFuZGxlcnMuZXJySGFuZGxlcjtcbiAgdmFyIHJhd0VtaXR0ZXIgPSBoYW5kbGVycy5yYXdFbWl0dGVyO1xuICB2YXIgY29udGFpbmVyID0gRnNXYXRjaEluc3RhbmNlc1tmdWxsUGF0aF07XG4gIHZhciB3YXRjaGVyO1xuICBpZiAoIW9wdGlvbnMucGVyc2lzdGVudCkge1xuICAgIHdhdGNoZXIgPSBjcmVhdGVGc1dhdGNoSW5zdGFuY2UoXG4gICAgICBwYXRoLCBvcHRpb25zLCBsaXN0ZW5lciwgZXJySGFuZGxlciwgcmF3RW1pdHRlclxuICAgICk7XG4gICAgcmV0dXJuIHdhdGNoZXIuY2xvc2UuYmluZCh3YXRjaGVyKTtcbiAgfVxuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHdhdGNoZXIgPSBjcmVhdGVGc1dhdGNoSW5zdGFuY2UoXG4gICAgICBwYXRoLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGZzV2F0Y2hCcm9hZGNhc3QuYmluZChudWxsLCBmdWxsUGF0aCwgJ2xpc3RlbmVycycpLFxuICAgICAgZXJySGFuZGxlciwgLy8gbm8gbmVlZCB0byB1c2UgYnJvYWRjYXN0IGhlcmVcbiAgICAgIGZzV2F0Y2hCcm9hZGNhc3QuYmluZChudWxsLCBmdWxsUGF0aCwgJ3Jhd0VtaXR0ZXJzJylcbiAgICApO1xuICAgIGlmICghd2F0Y2hlcikgcmV0dXJuO1xuICAgIHZhciBicm9hZGNhc3RFcnIgPSBmc1dhdGNoQnJvYWRjYXN0LmJpbmQobnVsbCwgZnVsbFBhdGgsICdlcnJIYW5kbGVycycpO1xuICAgIHdhdGNoZXIub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvNDMzN1xuICAgICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgJiYgZXJyb3IuY29kZSA9PT0gJ0VQRVJNJykge1xuICAgICAgICBmcy5vcGVuKHBhdGgsICdyJywgZnVuY3Rpb24oZXJyLCBmZCkge1xuICAgICAgICAgIGlmIChmZCkgZnMuY2xvc2UoZmQpO1xuICAgICAgICAgIGlmICghZXJyKSBicm9hZGNhc3RFcnIoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyb2FkY2FzdEVycihlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29udGFpbmVyID0gRnNXYXRjaEluc3RhbmNlc1tmdWxsUGF0aF0gPSB7XG4gICAgICBsaXN0ZW5lcnM6IFtsaXN0ZW5lcl0sXG4gICAgICBlcnJIYW5kbGVyczogW2VyckhhbmRsZXJdLFxuICAgICAgcmF3RW1pdHRlcnM6IFtyYXdFbWl0dGVyXSxcbiAgICAgIHdhdGNoZXI6IHdhdGNoZXJcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnRhaW5lci5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgY29udGFpbmVyLmVyckhhbmRsZXJzLnB1c2goZXJySGFuZGxlcik7XG4gICAgY29udGFpbmVyLnJhd0VtaXR0ZXJzLnB1c2gocmF3RW1pdHRlcik7XG4gIH1cbiAgdmFyIGxpc3RlbmVySW5kZXggPSBjb250YWluZXIubGlzdGVuZXJzLmxlbmd0aCAtIDE7XG5cbiAgLy8gcmVtb3ZlcyB0aGlzIGluc3RhbmNlJ3MgbGlzdGVuZXJzIGFuZCBjbG9zZXMgdGhlIHVuZGVybHlpbmcgZnMud2F0Y2hcbiAgLy8gaW5zdGFuY2UgaWYgdGhlcmUgYXJlIG5vIG1vcmUgbGlzdGVuZXJzIGxlZnRcbiAgcmV0dXJuIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGRlbGV0ZSBjb250YWluZXIubGlzdGVuZXJzW2xpc3RlbmVySW5kZXhdO1xuICAgIGRlbGV0ZSBjb250YWluZXIuZXJySGFuZGxlcnNbbGlzdGVuZXJJbmRleF07XG4gICAgZGVsZXRlIGNvbnRhaW5lci5yYXdFbWl0dGVyc1tsaXN0ZW5lckluZGV4XTtcbiAgICBpZiAoIU9iamVjdC5rZXlzKGNvbnRhaW5lci5saXN0ZW5lcnMpLmxlbmd0aCkge1xuICAgICAgY29udGFpbmVyLndhdGNoZXIuY2xvc2UoKTtcbiAgICAgIGRlbGV0ZSBGc1dhdGNoSW5zdGFuY2VzW2Z1bGxQYXRoXTtcbiAgICB9XG4gIH07XG59XG5cbi8vIGZzLndhdGNoRmlsZSBoZWxwZXJzXG5cbi8vIG9iamVjdCB0byBob2xkIHBlci1wcm9jZXNzIGZzLndhdGNoRmlsZSBpbnN0YW5jZXNcbi8vIChtYXkgYmUgc2hhcmVkIGFjcm9zcyBjaG9raWRhciBGU1dhdGNoZXIgaW5zdGFuY2VzKVxudmFyIEZzV2F0Y2hGaWxlSW5zdGFuY2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuLy8gUHJpdmF0ZSBmdW5jdGlvbjogSW5zdGFudGlhdGVzIHRoZSBmcy53YXRjaEZpbGUgaW50ZXJmYWNlIG9yIGJpbmRzIGxpc3RlbmVyc1xuLy8gdG8gYW4gZXhpc3Rpbmcgb25lIGNvdmVyaW5nIHRoZSBzYW1lIGZpbGUgc3lzdGVtIGVudHJ5XG5cbi8vICogcGF0aCAgICAgICAtIHN0cmluZywgcGF0aCB0byBiZSB3YXRjaGVkXG4vLyAqIGZ1bGxQYXRoICAgLSBzdHJpbmcsIGFic29sdXRlIHBhdGhcbi8vICogb3B0aW9ucyAgICAtIG9iamVjdCwgb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gZnMud2F0Y2hGaWxlXG4vLyAqIGhhbmRsZXJzICAgLSBvYmplY3QsIGNvbnRhaW5lciBmb3IgZXZlbnQgbGlzdGVuZXIgZnVuY3Rpb25zXG5cbi8vIFJldHVybnMgY2xvc2UgZnVuY3Rpb25cbmZ1bmN0aW9uIHNldEZzV2F0Y2hGaWxlTGlzdGVuZXIocGF0aCwgZnVsbFBhdGgsIG9wdGlvbnMsIGhhbmRsZXJzKSB7XG4gIHZhciBsaXN0ZW5lciA9IGhhbmRsZXJzLmxpc3RlbmVyO1xuICB2YXIgcmF3RW1pdHRlciA9IGhhbmRsZXJzLnJhd0VtaXR0ZXI7XG4gIHZhciBjb250YWluZXIgPSBGc1dhdGNoRmlsZUluc3RhbmNlc1tmdWxsUGF0aF07XG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIHJhd0VtaXR0ZXJzID0gW107XG4gIGlmIChcbiAgICBjb250YWluZXIgJiYgKFxuICAgICAgY29udGFpbmVyLm9wdGlvbnMucGVyc2lzdGVudCA8IG9wdGlvbnMucGVyc2lzdGVudCB8fFxuICAgICAgY29udGFpbmVyLm9wdGlvbnMuaW50ZXJ2YWwgPiBvcHRpb25zLmludGVydmFsXG4gICAgKVxuICApIHtcbiAgICAvLyBcIlVwZ3JhZGVcIiB0aGUgd2F0Y2hlciB0byBwZXJzaXN0ZW5jZSBvciBhIHF1aWNrZXIgaW50ZXJ2YWwuXG4gICAgLy8gVGhpcyBjcmVhdGVzIHNvbWUgdW5saWtlbHkgZWRnZSBjYXNlIGlzc3VlcyBpZiB0aGUgdXNlciBtaXhlc1xuICAgIC8vIHNldHRpbmdzIGluIGEgdmVyeSB3ZWlyZCB3YXksIGJ1dCBzb2x2aW5nIGZvciB0aG9zZSBjYXNlc1xuICAgIC8vIGRvZXNuJ3Qgc2VlbSB3b3J0aHdoaWxlIGZvciB0aGUgYWRkZWQgY29tcGxleGl0eS5cbiAgICBsaXN0ZW5lcnMgPSBjb250YWluZXIubGlzdGVuZXJzO1xuICAgIHJhd0VtaXR0ZXJzID0gY29udGFpbmVyLnJhd0VtaXR0ZXJzO1xuICAgIGZzLnVud2F0Y2hGaWxlKGZ1bGxQYXRoKTtcbiAgICBjb250YWluZXIgPSBmYWxzZTtcbiAgfVxuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICByYXdFbWl0dGVycy5wdXNoKHJhd0VtaXR0ZXIpO1xuICAgIGNvbnRhaW5lciA9IEZzV2F0Y2hGaWxlSW5zdGFuY2VzW2Z1bGxQYXRoXSA9IHtcbiAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzLFxuICAgICAgcmF3RW1pdHRlcnM6IHJhd0VtaXR0ZXJzLFxuICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgIHdhdGNoZXI6IGZzLndhdGNoRmlsZShmdWxsUGF0aCwgb3B0aW9ucywgZnVuY3Rpb24oY3VyciwgcHJldikge1xuICAgICAgICBjb250YWluZXIucmF3RW1pdHRlcnMuZm9yRWFjaChmdW5jdGlvbihyYXdFbWl0dGVyKSB7XG4gICAgICAgICAgcmF3RW1pdHRlcignY2hhbmdlJywgZnVsbFBhdGgsIHtjdXJyOiBjdXJyLCBwcmV2OiBwcmV2fSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY3Vycm10aW1lID0gY3Vyci5tdGltZS5nZXRUaW1lKCk7XG4gICAgICAgIGlmIChjdXJyLnNpemUgIT09IHByZXYuc2l6ZSB8fCBjdXJybXRpbWUgPiBwcmV2Lm10aW1lLmdldFRpbWUoKSB8fCBjdXJybXRpbWUgPT09IDApIHtcbiAgICAgICAgICBjb250YWluZXIubGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKHBhdGgsIGN1cnIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY29udGFpbmVyLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICBjb250YWluZXIucmF3RW1pdHRlcnMucHVzaChyYXdFbWl0dGVyKTtcbiAgfVxuICB2YXIgbGlzdGVuZXJJbmRleCA9IGNvbnRhaW5lci5saXN0ZW5lcnMubGVuZ3RoIC0gMTtcblxuICAvLyByZW1vdmVzIHRoaXMgaW5zdGFuY2UncyBsaXN0ZW5lcnMgYW5kIGNsb3NlcyB0aGUgdW5kZXJseWluZyBmcy53YXRjaEZpbGVcbiAgLy8gaW5zdGFuY2UgaWYgdGhlcmUgYXJlIG5vIG1vcmUgbGlzdGVuZXJzIGxlZnRcbiAgcmV0dXJuIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGRlbGV0ZSBjb250YWluZXIubGlzdGVuZXJzW2xpc3RlbmVySW5kZXhdO1xuICAgIGRlbGV0ZSBjb250YWluZXIucmF3RW1pdHRlcnNbbGlzdGVuZXJJbmRleF07XG4gICAgaWYgKCFPYmplY3Qua2V5cyhjb250YWluZXIubGlzdGVuZXJzKS5sZW5ndGgpIHtcbiAgICAgIGZzLnVud2F0Y2hGaWxlKGZ1bGxQYXRoKTtcbiAgICAgIGRlbGV0ZSBGc1dhdGNoRmlsZUluc3RhbmNlc1tmdWxsUGF0aF07XG4gICAgfVxuICB9O1xufVxuXG4vLyBmYWtlIGNvbnN0cnVjdG9yIGZvciBhdHRhY2hpbmcgbm9kZWZzLXNwZWNpZmljIHByb3RvdHlwZSBtZXRob2RzIHRoYXRcbi8vIHdpbGwgYmUgY29waWVkIHRvIEZTV2F0Y2hlcidzIHByb3RvdHlwZVxuZnVuY3Rpb24gTm9kZUZzSGFuZGxlcigpIHt9XG5cbi8vIFByaXZhdGUgbWV0aG9kOiBXYXRjaCBmaWxlIGZvciBjaGFuZ2VzIHdpdGggZnMud2F0Y2hGaWxlIG9yIGZzLndhdGNoLlxuXG4vLyAqIHBhdGggICAgIC0gc3RyaW5nLCBwYXRoIHRvIGZpbGUgb3IgZGlyZWN0b3J5LlxuLy8gKiBsaXN0ZW5lciAtIGZ1bmN0aW9uLCB0byBiZSBleGVjdXRlZCBvbiBmcyBjaGFuZ2UuXG5cbi8vIFJldHVybnMgY2xvc2UgZnVuY3Rpb24gZm9yIHRoZSB3YXRjaGVyIGluc3RhbmNlXG5Ob2RlRnNIYW5kbGVyLnByb3RvdHlwZS5fd2F0Y2hXaXRoTm9kZUZzID1cbmZ1bmN0aW9uKHBhdGgsIGxpc3RlbmVyKSB7XG4gIHZhciBkaXJlY3RvcnkgPSBzeXNQYXRoLmRpcm5hbWUocGF0aCk7XG4gIHZhciBiYXNlbmFtZSA9IHN5c1BhdGguYmFzZW5hbWUocGF0aCk7XG4gIHZhciBwYXJlbnQgPSB0aGlzLl9nZXRXYXRjaGVkRGlyKGRpcmVjdG9yeSk7XG4gIHBhcmVudC5hZGQoYmFzZW5hbWUpO1xuICB2YXIgYWJzb2x1dGVQYXRoID0gc3lzUGF0aC5yZXNvbHZlKHBhdGgpO1xuICB2YXIgb3B0aW9ucyA9IHtwZXJzaXN0ZW50OiB0aGlzLm9wdGlvbnMucGVyc2lzdGVudH07XG4gIGlmICghbGlzdGVuZXIpIGxpc3RlbmVyID0gRnVuY3Rpb24ucHJvdG90eXBlOyAvLyBlbXB0eSBmdW5jdGlvblxuXG4gIHZhciBjbG9zZXI7XG4gIGlmICh0aGlzLm9wdGlvbnMudXNlUG9sbGluZykge1xuICAgIG9wdGlvbnMuaW50ZXJ2YWwgPSB0aGlzLmVuYWJsZUJpbmFyeUludGVydmFsICYmIGlzQmluYXJ5UGF0aChiYXNlbmFtZSkgP1xuICAgICAgdGhpcy5vcHRpb25zLmJpbmFyeUludGVydmFsIDogdGhpcy5vcHRpb25zLmludGVydmFsO1xuICAgIGNsb3NlciA9IHNldEZzV2F0Y2hGaWxlTGlzdGVuZXIocGF0aCwgYWJzb2x1dGVQYXRoLCBvcHRpb25zLCB7XG4gICAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXG4gICAgICByYXdFbWl0dGVyOiB0aGlzLmVtaXQuYmluZCh0aGlzLCAncmF3JylcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjbG9zZXIgPSBzZXRGc1dhdGNoTGlzdGVuZXIocGF0aCwgYWJzb2x1dGVQYXRoLCBvcHRpb25zLCB7XG4gICAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXG4gICAgICBlcnJIYW5kbGVyOiB0aGlzLl9oYW5kbGVFcnJvci5iaW5kKHRoaXMpLFxuICAgICAgcmF3RW1pdHRlcjogdGhpcy5lbWl0LmJpbmQodGhpcywgJ3JhdycpXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGNsb3Nlcjtcbn07XG5cbi8vIFByaXZhdGUgbWV0aG9kOiBXYXRjaCBhIGZpbGUgYW5kIGVtaXQgYWRkIGV2ZW50IGlmIHdhcnJhbnRlZFxuXG4vLyAqIGZpbGUgICAgICAgLSBzdHJpbmcsIHRoZSBmaWxlJ3MgcGF0aFxuLy8gKiBzdGF0cyAgICAgIC0gb2JqZWN0LCByZXN1bHQgb2YgZnMuc3RhdFxuLy8gKiBpbml0aWFsQWRkIC0gYm9vbGVhbiwgd2FzIHRoZSBmaWxlIGFkZGVkIGF0IHdhdGNoIGluc3RhbnRpYXRpb24/XG4vLyAqIGNhbGxiYWNrICAgLSBmdW5jdGlvbiwgY2FsbGVkIHdoZW4gZG9uZSBwcm9jZXNzaW5nIGFzIGEgbmV3bHkgc2VlbiBmaWxlXG5cbi8vIFJldHVybnMgY2xvc2UgZnVuY3Rpb24gZm9yIHRoZSB3YXRjaGVyIGluc3RhbmNlXG5Ob2RlRnNIYW5kbGVyLnByb3RvdHlwZS5faGFuZGxlRmlsZSA9XG5mdW5jdGlvbihmaWxlLCBzdGF0cywgaW5pdGlhbEFkZCwgY2FsbGJhY2spIHtcbiAgdmFyIGRpcm5hbWUgPSBzeXNQYXRoLmRpcm5hbWUoZmlsZSk7XG4gIHZhciBiYXNlbmFtZSA9IHN5c1BhdGguYmFzZW5hbWUoZmlsZSk7XG4gIHZhciBwYXJlbnQgPSB0aGlzLl9nZXRXYXRjaGVkRGlyKGRpcm5hbWUpO1xuXG4gIC8vIGlmIHRoZSBmaWxlIGlzIGFscmVhZHkgYmVpbmcgd2F0Y2hlZCwgZG8gbm90aGluZ1xuICBpZiAocGFyZW50LmhhcyhiYXNlbmFtZSkpIHJldHVybiBjYWxsYmFjaygpO1xuXG4gIC8vIGtpY2sgb2ZmIHRoZSB3YXRjaGVyXG4gIHZhciBjbG9zZXIgPSB0aGlzLl93YXRjaFdpdGhOb2RlRnMoZmlsZSwgZnVuY3Rpb24ocGF0aCwgbmV3U3RhdHMpIHtcbiAgICBpZiAoIXRoaXMuX3Rocm90dGxlKCd3YXRjaCcsIGZpbGUsIDUpKSByZXR1cm47XG4gICAgaWYgKCFuZXdTdGF0cyB8fCBuZXdTdGF0cyAmJiBuZXdTdGF0cy5tdGltZS5nZXRUaW1lKCkgPT09IDApIHtcbiAgICAgIGZzLnN0YXQoZmlsZSwgZnVuY3Rpb24oZXJyb3IsIG5ld1N0YXRzKSB7XG4gICAgICAgIC8vIEZpeCBpc3N1ZXMgd2hlcmUgbXRpbWUgaXMgbnVsbCBidXQgZmlsZSBpcyBzdGlsbCBwcmVzZW50XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHRoaXMuX3JlbW92ZShkaXJuYW1lLCBiYXNlbmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZW1pdCgnY2hhbmdlJywgZmlsZSwgbmV3U3RhdHMpO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgIC8vIGFkZCBpcyBhYm91dCB0byBiZSBlbWl0dGVkIGlmIGZpbGUgbm90IGFscmVhZHkgdHJhY2tlZCBpbiBwYXJlbnRcbiAgICB9IGVsc2UgaWYgKHBhcmVudC5oYXMoYmFzZW5hbWUpKSB7XG4gICAgICB0aGlzLl9lbWl0KCdjaGFuZ2UnLCBmaWxlLCBuZXdTdGF0cyk7XG4gICAgfVxuICB9LmJpbmQodGhpcykpO1xuXG4gIC8vIGVtaXQgYW4gYWRkIGV2ZW50IGlmIHdlJ3JlIHN1cHBvc2VkIHRvXG4gIGlmICghKGluaXRpYWxBZGQgJiYgdGhpcy5vcHRpb25zLmlnbm9yZUluaXRpYWwpKSB7XG4gICAgaWYgKCF0aGlzLl90aHJvdHRsZSgnYWRkJywgZmlsZSwgMCkpIHJldHVybjtcbiAgICB0aGlzLl9lbWl0KCdhZGQnLCBmaWxlLCBzdGF0cyk7XG4gIH1cblxuICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gIHJldHVybiBjbG9zZXI7XG59O1xuXG4vLyBQcml2YXRlIG1ldGhvZDogSGFuZGxlIHN5bWxpbmtzIGVuY291bnRlcmVkIHdoaWxlIHJlYWRpbmcgYSBkaXJcblxuLy8gKiBlbnRyeSAgICAgIC0gb2JqZWN0LCBlbnRyeSBvYmplY3QgcmV0dXJuZWQgYnkgcmVhZGRpcnBcbi8vICogZGlyZWN0b3J5ICAtIHN0cmluZywgcGF0aCBvZiB0aGUgZGlyZWN0b3J5IGJlaW5nIHJlYWRcbi8vICogcGF0aCAgICAgICAtIHN0cmluZywgcGF0aCBvZiB0aGlzIGl0ZW1cbi8vICogaXRlbSAgICAgICAtIHN0cmluZywgYmFzZW5hbWUgb2YgdGhpcyBpdGVtXG5cbi8vIFJldHVybnMgdHJ1ZSBpZiBubyBtb3JlIHByb2Nlc3NpbmcgaXMgbmVlZGVkIGZvciB0aGlzIGVudHJ5LlxuTm9kZUZzSGFuZGxlci5wcm90b3R5cGUuX2hhbmRsZVN5bWxpbmsgPVxuZnVuY3Rpb24oZW50cnksIGRpcmVjdG9yeSwgcGF0aCwgaXRlbSkge1xuICB2YXIgZnVsbCA9IGVudHJ5LmZ1bGxQYXRoO1xuICB2YXIgZGlyID0gdGhpcy5fZ2V0V2F0Y2hlZERpcihkaXJlY3RvcnkpO1xuXG4gIGlmICghdGhpcy5vcHRpb25zLmZvbGxvd1N5bWxpbmtzKSB7XG4gICAgLy8gd2F0Y2ggc3ltbGluayBkaXJlY3RseSAoZG9uJ3QgZm9sbG93KSBhbmQgZGV0ZWN0IGNoYW5nZXNcbiAgICB0aGlzLl9yZWFkeUNvdW50Kys7XG4gICAgZnMucmVhbHBhdGgocGF0aCwgZnVuY3Rpb24oZXJyb3IsIGxpbmtQYXRoKSB7XG4gICAgICBpZiAoZGlyLmhhcyhpdGVtKSkge1xuICAgICAgICBpZiAodGhpcy5fc3ltbGlua1BhdGhzW2Z1bGxdICE9PSBsaW5rUGF0aCkge1xuICAgICAgICAgIHRoaXMuX3N5bWxpbmtQYXRoc1tmdWxsXSA9IGxpbmtQYXRoO1xuICAgICAgICAgIHRoaXMuX2VtaXQoJ2NoYW5nZScsIHBhdGgsIGVudHJ5LnN0YXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXIuYWRkKGl0ZW0pO1xuICAgICAgICB0aGlzLl9zeW1saW5rUGF0aHNbZnVsbF0gPSBsaW5rUGF0aDtcbiAgICAgICAgdGhpcy5fZW1pdCgnYWRkJywgcGF0aCwgZW50cnkuc3RhdCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9lbWl0UmVhZHkoKTtcbiAgICB9LmJpbmQodGhpcykpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gZG9uJ3QgZm9sbG93IHRoZSBzYW1lIHN5bWxpbmsgbW9yZSB0aGFuIG9uY2VcbiAgaWYgKHRoaXMuX3N5bWxpbmtQYXRoc1tmdWxsXSkgcmV0dXJuIHRydWU7XG4gIGVsc2UgdGhpcy5fc3ltbGlua1BhdGhzW2Z1bGxdID0gdHJ1ZTtcbn07XG5cbi8vIFByaXZhdGUgbWV0aG9kOiBSZWFkIGRpcmVjdG9yeSB0byBhZGQgLyByZW1vdmUgZmlsZXMgZnJvbSBgQHdhdGNoZWRgIGxpc3Rcbi8vIGFuZCByZS1yZWFkIGl0IG9uIGNoYW5nZS5cblxuLy8gKiBkaXIgICAgICAgIC0gc3RyaW5nLCBmcyBwYXRoLlxuLy8gKiBzdGF0cyAgICAgIC0gb2JqZWN0LCByZXN1bHQgb2YgZnMuc3RhdFxuLy8gKiBpbml0aWFsQWRkIC0gYm9vbGVhbiwgd2FzIHRoZSBmaWxlIGFkZGVkIGF0IHdhdGNoIGluc3RhbnRpYXRpb24/XG4vLyAqIGRlcHRoICAgICAgLSBpbnQsIGRlcHRoIHJlbGF0aXZlIHRvIHVzZXItc3VwcGxpZWQgcGF0aFxuLy8gKiB0YXJnZXQgICAgIC0gc3RyaW5nLCBjaGlsZCBwYXRoIGFjdHVhbGx5IHRhcmdldGVkIGZvciB3YXRjaFxuLy8gKiB3aCAgICAgICAgIC0gb2JqZWN0LCBjb21tb24gd2F0Y2ggaGVscGVycyBmb3IgdGhpcyBwYXRoXG4vLyAqIGNhbGxiYWNrICAgLSBmdW5jdGlvbiwgY2FsbGVkIHdoZW4gZGlyIHNjYW4gaXMgY29tcGxldGVcblxuLy8gUmV0dXJucyBjbG9zZSBmdW5jdGlvbiBmb3IgdGhlIHdhdGNoZXIgaW5zdGFuY2Vcbk5vZGVGc0hhbmRsZXIucHJvdG90eXBlLl9oYW5kbGVEaXIgPVxuZnVuY3Rpb24oZGlyLCBzdGF0cywgaW5pdGlhbEFkZCwgZGVwdGgsIHRhcmdldCwgd2gsIGNhbGxiYWNrKSB7XG4gIHZhciBwYXJlbnREaXIgPSB0aGlzLl9nZXRXYXRjaGVkRGlyKHN5c1BhdGguZGlybmFtZShkaXIpKTtcbiAgdmFyIHRyYWNrZWQgPSBwYXJlbnREaXIuaGFzKHN5c1BhdGguYmFzZW5hbWUoZGlyKSk7XG4gIGlmICghKGluaXRpYWxBZGQgJiYgdGhpcy5vcHRpb25zLmlnbm9yZUluaXRpYWwpICYmICF0YXJnZXQgJiYgIXRyYWNrZWQpIHtcbiAgICBpZiAoIXdoLmhhc0dsb2IgfHwgd2guZ2xvYkZpbHRlcihkaXIpKSB0aGlzLl9lbWl0KCdhZGREaXInLCBkaXIsIHN0YXRzKTtcbiAgfVxuXG4gIC8vIGVuc3VyZSBkaXIgaXMgdHJhY2tlZCAoaGFybWxlc3MgaWYgcmVkdW5kYW50KVxuICBwYXJlbnREaXIuYWRkKHN5c1BhdGguYmFzZW5hbWUoZGlyKSk7XG4gIHRoaXMuX2dldFdhdGNoZWREaXIoZGlyKTtcblxuICB2YXIgcmVhZCA9IGZ1bmN0aW9uKGRpcmVjdG9yeSwgaW5pdGlhbEFkZCwgZG9uZSkge1xuICAgIC8vIE5vcm1hbGl6ZSB0aGUgZGlyZWN0b3J5IG5hbWUgb24gV2luZG93c1xuICAgIGRpcmVjdG9yeSA9IHN5c1BhdGguam9pbihkaXJlY3RvcnksICcnKTtcblxuICAgIGlmICghd2guaGFzR2xvYikge1xuICAgICAgdmFyIHRocm90dGxlciA9IHRoaXMuX3Rocm90dGxlKCdyZWFkZGlyJywgZGlyZWN0b3J5LCAxMDAwKTtcbiAgICAgIGlmICghdGhyb3R0bGVyKSByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzID0gdGhpcy5fZ2V0V2F0Y2hlZERpcih3aC5wYXRoKTtcbiAgICB2YXIgY3VycmVudCA9IFtdO1xuXG4gICAgcmVhZGRpcnAoe1xuICAgICAgcm9vdDogZGlyZWN0b3J5LFxuICAgICAgZW50cnlUeXBlOiAnYWxsJyxcbiAgICAgIGZpbGVGaWx0ZXI6IHdoLmZpbHRlclBhdGgsXG4gICAgICBkaXJlY3RvcnlGaWx0ZXI6IHdoLmZpbHRlckRpcixcbiAgICAgIGRlcHRoOiAwLFxuICAgICAgbHN0YXQ6IHRydWVcbiAgICB9KS5vbignZGF0YScsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICB2YXIgaXRlbSA9IGVudHJ5LnBhdGg7XG4gICAgICB2YXIgcGF0aCA9IHN5c1BhdGguam9pbihkaXJlY3RvcnksIGl0ZW0pO1xuICAgICAgY3VycmVudC5wdXNoKGl0ZW0pO1xuXG4gICAgICBpZiAoZW50cnkuc3RhdC5pc1N5bWJvbGljTGluaygpICYmXG4gICAgICAgIHRoaXMuX2hhbmRsZVN5bWxpbmsoZW50cnksIGRpcmVjdG9yeSwgcGF0aCwgaXRlbSkpIHJldHVybjtcblxuICAgICAgLy8gRmlsZXMgdGhhdCBwcmVzZW50IGluIGN1cnJlbnQgZGlyZWN0b3J5IHNuYXBzaG90XG4gICAgICAvLyBidXQgYWJzZW50IGluIHByZXZpb3VzIGFyZSBhZGRlZCB0byB3YXRjaCBsaXN0IGFuZFxuICAgICAgLy8gZW1pdCBgYWRkYCBldmVudC5cbiAgICAgIGlmIChpdGVtID09PSB0YXJnZXQgfHwgIXRhcmdldCAmJiAhcHJldmlvdXMuaGFzKGl0ZW0pKSB7XG4gICAgICAgIHRoaXMuX3JlYWR5Q291bnQrKztcblxuICAgICAgICAvLyBlbnN1cmUgcmVsYXRpdmVuZXNzIG9mIHBhdGggaXMgcHJlc2VydmVkIGluIGNhc2Ugb2Ygd2F0Y2hlciByZXVzZVxuICAgICAgICBwYXRoID0gc3lzUGF0aC5qb2luKGRpciwgc3lzUGF0aC5yZWxhdGl2ZShkaXIsIHBhdGgpKTtcblxuICAgICAgICB0aGlzLl9hZGRUb05vZGVGcyhwYXRoLCBpbml0aWFsQWRkLCB3aCwgZGVwdGggKyAxKTtcbiAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aHJvdHRsZXIpIHRocm90dGxlci5jbGVhcigpO1xuICAgICAgaWYgKGRvbmUpIGRvbmUoKTtcblxuICAgICAgLy8gRmlsZXMgdGhhdCBhYnNlbnQgaW4gY3VycmVudCBkaXJlY3Rvcnkgc25hcHNob3RcbiAgICAgIC8vIGJ1dCBwcmVzZW50IGluIHByZXZpb3VzIGVtaXQgYHJlbW92ZWAgZXZlbnRcbiAgICAgIC8vIGFuZCBhcmUgcmVtb3ZlZCBmcm9tIEB3YXRjaGVkW2RpcmVjdG9yeV0uXG4gICAgICBwcmV2aW91cy5jaGlsZHJlbigpLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSBkaXJlY3RvcnkgJiZcbiAgICAgICAgICBjdXJyZW50LmluZGV4T2YoaXRlbSkgPT09IC0xICYmXG4gICAgICAgICAgLy8gaW4gY2FzZSBvZiBpbnRlcnNlY3RpbmcgZ2xvYnM7XG4gICAgICAgICAgLy8gYSBwYXRoIG1heSBoYXZlIGJlZW4gZmlsdGVyZWQgb3V0IG9mIHRoaXMgcmVhZGRpciwgYnV0XG4gICAgICAgICAgLy8gc2hvdWxkbid0IGJlIHJlbW92ZWQgYmVjYXVzZSBpdCBtYXRjaGVzIGEgZGlmZmVyZW50IGdsb2JcbiAgICAgICAgICAoIXdoLmhhc0dsb2IgfHwgd2guZmlsdGVyUGF0aCh7XG4gICAgICAgICAgICBmdWxsUGF0aDogc3lzUGF0aC5yZXNvbHZlKGRpcmVjdG9yeSwgaXRlbSlcbiAgICAgICAgICB9KSk7XG4gICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlKGRpcmVjdG9yeSwgaXRlbSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LmJpbmQodGhpcykpLm9uKCdlcnJvcicsIHRoaXMuX2hhbmRsZUVycm9yLmJpbmQodGhpcykpO1xuICB9LmJpbmQodGhpcyk7XG5cbiAgdmFyIGNsb3NlcjtcblxuICBpZiAodGhpcy5vcHRpb25zLmRlcHRoID09IG51bGwgfHwgZGVwdGggPD0gdGhpcy5vcHRpb25zLmRlcHRoKSB7XG4gICAgaWYgKCF0YXJnZXQpIHJlYWQoZGlyLCBpbml0aWFsQWRkLCBjYWxsYmFjayk7XG4gICAgY2xvc2VyID0gdGhpcy5fd2F0Y2hXaXRoTm9kZUZzKGRpciwgZnVuY3Rpb24oZGlyUGF0aCwgc3RhdHMpIHtcbiAgICAgIC8vIGlmIGN1cnJlbnQgZGlyZWN0b3J5IGlzIHJlbW92ZWQsIGRvIG5vdGhpbmdcbiAgICAgIGlmIChzdGF0cyAmJiBzdGF0cy5tdGltZS5nZXRUaW1lKCkgPT09IDApIHJldHVybjtcblxuICAgICAgcmVhZChkaXJQYXRoLCBmYWxzZSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuICByZXR1cm4gY2xvc2VyO1xufTtcblxuLy8gUHJpdmF0ZSBtZXRob2Q6IEhhbmRsZSBhZGRlZCBmaWxlLCBkaXJlY3RvcnksIG9yIGdsb2IgcGF0dGVybi5cbi8vIERlbGVnYXRlcyBjYWxsIHRvIF9oYW5kbGVGaWxlIC8gX2hhbmRsZURpciBhZnRlciBjaGVja3MuXG5cbi8vICogcGF0aCAgICAgICAtIHN0cmluZywgcGF0aCB0byBmaWxlIG9yIGRpcmVjdG9yeS5cbi8vICogaW5pdGlhbEFkZCAtIGJvb2xlYW4sIHdhcyB0aGUgZmlsZSBhZGRlZCBhdCB3YXRjaCBpbnN0YW50aWF0aW9uP1xuLy8gKiBkZXB0aCAgICAgIC0gaW50LCBkZXB0aCByZWxhdGl2ZSB0byB1c2VyLXN1cHBsaWVkIHBhdGhcbi8vICogdGFyZ2V0ICAgICAtIHN0cmluZywgY2hpbGQgcGF0aCBhY3R1YWxseSB0YXJnZXRlZCBmb3Igd2F0Y2hcbi8vICogY2FsbGJhY2sgICAtIGZ1bmN0aW9uLCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgcGF0aCB3YXMgZm91bmQgb3Igbm90XG5cbi8vIFJldHVybnMgbm90aGluZ1xuTm9kZUZzSGFuZGxlci5wcm90b3R5cGUuX2FkZFRvTm9kZUZzID1cbmZ1bmN0aW9uKHBhdGgsIGluaXRpYWxBZGQsIHByaW9yV2gsIGRlcHRoLCB0YXJnZXQsIGNhbGxiYWNrKSB7XG4gIGlmICghY2FsbGJhY2spIGNhbGxiYWNrID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuICB2YXIgcmVhZHkgPSB0aGlzLl9lbWl0UmVhZHk7XG4gIGlmICh0aGlzLl9pc0lnbm9yZWQocGF0aCkgfHwgdGhpcy5jbG9zZWQpIHtcbiAgICByZWFkeSgpO1xuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBmYWxzZSk7XG4gIH1cblxuICB2YXIgd2ggPSB0aGlzLl9nZXRXYXRjaEhlbHBlcnMocGF0aCwgZGVwdGgpO1xuICBpZiAoIXdoLmhhc0dsb2IgJiYgcHJpb3JXaCkge1xuICAgIHdoLmhhc0dsb2IgPSBwcmlvcldoLmhhc0dsb2I7XG4gICAgd2guZ2xvYkZpbHRlciA9IHByaW9yV2guZ2xvYkZpbHRlcjtcbiAgICB3aC5maWx0ZXJQYXRoID0gcHJpb3JXaC5maWx0ZXJQYXRoO1xuICAgIHdoLmZpbHRlckRpciA9IHByaW9yV2guZmlsdGVyRGlyO1xuICB9XG5cbiAgLy8gZXZhbHVhdGUgd2hhdCBpcyBhdCB0aGUgcGF0aCB3ZSdyZSBiZWluZyBhc2tlZCB0byB3YXRjaFxuICBmc1t3aC5zdGF0TWV0aG9kXSh3aC53YXRjaFBhdGgsIGZ1bmN0aW9uKGVycm9yLCBzdGF0cykge1xuICAgIGlmICh0aGlzLl9oYW5kbGVFcnJvcihlcnJvcikpIHJldHVybiBjYWxsYmFjayhudWxsLCBwYXRoKTtcbiAgICBpZiAodGhpcy5faXNJZ25vcmVkKHdoLndhdGNoUGF0aCwgc3RhdHMpKSB7XG4gICAgICByZWFkeSgpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgaW5pdERpciA9IGZ1bmN0aW9uKGRpciwgdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5faGFuZGxlRGlyKGRpciwgc3RhdHMsIGluaXRpYWxBZGQsIGRlcHRoLCB0YXJnZXQsIHdoLCByZWFkeSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgdmFyIGNsb3NlcjtcbiAgICBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgY2xvc2VyID0gaW5pdERpcih3aC53YXRjaFBhdGgsIHRhcmdldCk7XG4gICAgfSBlbHNlIGlmIChzdGF0cy5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICB2YXIgcGFyZW50ID0gc3lzUGF0aC5kaXJuYW1lKHdoLndhdGNoUGF0aCk7XG4gICAgICB0aGlzLl9nZXRXYXRjaGVkRGlyKHBhcmVudCkuYWRkKHdoLndhdGNoUGF0aCk7XG4gICAgICB0aGlzLl9lbWl0KCdhZGQnLCB3aC53YXRjaFBhdGgsIHN0YXRzKTtcbiAgICAgIGNsb3NlciA9IGluaXREaXIocGFyZW50LCBwYXRoKTtcblxuICAgICAgLy8gcHJlc2VydmUgdGhpcyBzeW1saW5rJ3MgdGFyZ2V0IHBhdGhcbiAgICAgIGZzLnJlYWxwYXRoKHBhdGgsIGZ1bmN0aW9uKGVycm9yLCB0YXJnZXRQYXRoKSB7XG4gICAgICAgIHRoaXMuX3N5bWxpbmtQYXRoc1tzeXNQYXRoLnJlc29sdmUocGF0aCldID0gdGFyZ2V0UGF0aDtcbiAgICAgICAgcmVhZHkoKTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsb3NlciA9IHRoaXMuX2hhbmRsZUZpbGUod2gud2F0Y2hQYXRoLCBzdGF0cywgaW5pdGlhbEFkZCwgcmVhZHkpO1xuICAgIH1cblxuICAgIGlmIChjbG9zZXIpIHRoaXMuX2Nsb3NlcnNbcGF0aF0gPSBjbG9zZXI7XG4gICAgY2FsbGJhY2sobnVsbCwgZmFsc2UpO1xuICB9LmJpbmQodGhpcykpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlRnNIYW5kbGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nob2tpZGFyL2xpYi9ub2RlZnMtaGFuZGxlci5qc1xuLy8gbW9kdWxlIGlkID0gMjYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGZzICAgICAgICA9ICByZXF1aXJlKCdncmFjZWZ1bC1mcycpXG4gICwgcGF0aCAgICAgID0gIHJlcXVpcmUoJ3BhdGgnKVxuICAsIG1pbmltYXRjaCA9ICByZXF1aXJlKCdtaW5pbWF0Y2gnKVxuICAsIHRvU3RyaW5nICA9ICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG4gICwgc2kgICAgICAgID0gIHJlcXVpcmUoJ3NldC1pbW1lZGlhdGUtc2hpbScpXG4gIDtcblxuXG4vLyBTdGFuZGFyZCBoZWxwZXJzXG5mdW5jdGlvbiBpc0Z1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmcgKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBTdHJpbmddJztcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAgKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQgKG9iaikge1xuICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG59XG5cbi8qKiBcbiAqIE1haW4gZnVuY3Rpb24gd2hpY2ggZW5kcyB1cCBjYWxsaW5nIHJlYWRkaXJSZWMgYW5kIHJlYWRzIGFsbCBmaWxlcyBhbmQgZGlyZWN0b3JpZXMgaW4gZ2l2ZW4gcm9vdCByZWN1cnNpdmVseS5cbiAqIEBwYXJhbSB7IE9iamVjdCB9ICAgb3B0cyAgICAgT3B0aW9ucyB0byBzcGVjaWZ5IHJvb3QgKHN0YXJ0IGRpcmVjdG9yeSksIGZpbHRlcnMgYW5kIHJlY3Vyc2lvbiBkZXB0aFxuICogQHBhcmFtIHsgZnVuY3Rpb24gfSBjYWxsYmFjazEgIFdoZW4gY2FsbGJhY2syIGlzIGdpdmVuIGNhbGxzIGJhY2sgZm9yIGVhY2ggcHJvY2Vzc2VkIGZpbGUgLSBmdW5jdGlvbiAoZmlsZUluZm8pIHsgLi4uIH0sXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbiBjYWxsYmFjazIgaXMgbm90IGdpdmVuLCBpdCBiZWhhdmVzIGxpa2UgZXhwbGFpbmVkIGluIGNhbGxiYWNrMlxuICogQHBhcmFtIHsgZnVuY3Rpb24gfSBjYWxsYmFjazIgIENhbGxzIGJhY2sgb25jZSBhbGwgZmlsZXMgaGF2ZSBiZWVuIHByb2Nlc3NlZCB3aXRoIGFuIGFycmF5IG9mIGVycm9ycyBhbmQgZmlsZSBpbmZvc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIsIGZpbGVJbmZvcykgeyAuLi4gfVxuICovXG5mdW5jdGlvbiByZWFkZGlyKG9wdHMsIGNhbGxiYWNrMSwgY2FsbGJhY2syKSB7XG4gIHZhciBzdHJlYW1cbiAgICAsIGhhbmRsZUVycm9yXG4gICAgLCBoYW5kbGVGYXRhbEVycm9yXG4gICAgLCBwZW5kaW5nID0gMFxuICAgICwgZXJyb3JzID0gW11cbiAgICAsIHJlYWRkaXJSZXN1bHQgPSB7XG4gICAgICAgIGRpcmVjdG9yaWVzOiBbXVxuICAgICAgLCBmaWxlczogW11cbiAgICB9XG4gICAgLCBmaWxlUHJvY2Vzc2VkXG4gICAgLCBhbGxQcm9jZXNzZWRcbiAgICAsIHJlYWxSb290XG4gICAgLCBhYm9ydGVkID0gZmFsc2VcbiAgICAsIHBhdXNlZCA9IGZhbHNlXG4gICAgO1xuXG4gIC8vIElmIG5vIGNhbGxiYWNrcyB3ZXJlIGdpdmVuIHdlIHdpbGwgdXNlIGEgc3RyZWFtaW5nIGludGVyZmFjZVxuICBpZiAoaXNVbmRlZmluZWQoY2FsbGJhY2sxKSkge1xuICAgIHZhciBhcGkgICAgICAgICAgPSAgcmVxdWlyZSgnLi9zdHJlYW0tYXBpJykoKTtcbiAgICBzdHJlYW0gICAgICAgICAgID0gIGFwaS5zdHJlYW07XG4gICAgY2FsbGJhY2sxICAgICAgICA9ICBhcGkucHJvY2Vzc0VudHJ5O1xuICAgIGNhbGxiYWNrMiAgICAgICAgPSAgYXBpLmRvbmU7XG4gICAgaGFuZGxlRXJyb3IgICAgICA9ICBhcGkuaGFuZGxlRXJyb3I7XG4gICAgaGFuZGxlRmF0YWxFcnJvciA9ICBhcGkuaGFuZGxlRmF0YWxFcnJvcjtcblxuICAgIHN0cmVhbS5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7IGFib3J0ZWQgPSB0cnVlOyB9KTtcbiAgICBzdHJlYW0ub24oJ3BhdXNlJywgZnVuY3Rpb24gKCkgeyBwYXVzZWQgPSB0cnVlOyB9KTtcbiAgICBzdHJlYW0ub24oJ3Jlc3VtZScsIGZ1bmN0aW9uICgpIHsgcGF1c2VkID0gZmFsc2U7IH0pO1xuICB9IGVsc2Uge1xuICAgIGhhbmRsZUVycm9yICAgICAgPSAgZnVuY3Rpb24gKGVycikgeyBlcnJvcnMucHVzaChlcnIpOyB9O1xuICAgIGhhbmRsZUZhdGFsRXJyb3IgPSAgZnVuY3Rpb24gKGVycikge1xuICAgICAgaGFuZGxlRXJyb3IoZXJyKTtcbiAgICAgIGFsbFByb2Nlc3NlZChlcnJvcnMsIG51bGwpO1xuICAgIH07XG4gIH1cblxuICBpZiAoaXNVbmRlZmluZWQob3B0cykpe1xuICAgIGhhbmRsZUZhdGFsRXJyb3IobmV3IEVycm9yIChcbiAgICAgICdOZWVkIHRvIHBhc3MgYXQgbGVhc3Qgb25lIGFyZ3VtZW50OiBvcHRzISBcXG4nICtcbiAgICAgICdodHRwczovL2dpdGh1Yi5jb20vdGhsb3JlbnovcmVhZGRpcnAjb3B0aW9ucydcbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybiBzdHJlYW07XG4gIH1cblxuICBvcHRzLnJvb3QgICAgICAgICAgICA9ICBvcHRzLnJvb3QgICAgICAgICAgICB8fCAnLic7XG4gIG9wdHMuZmlsZUZpbHRlciAgICAgID0gIG9wdHMuZmlsZUZpbHRlciAgICAgIHx8IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfTtcbiAgb3B0cy5kaXJlY3RvcnlGaWx0ZXIgPSAgb3B0cy5kaXJlY3RvcnlGaWx0ZXIgfHwgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9O1xuICBvcHRzLmRlcHRoICAgICAgICAgICA9ICB0eXBlb2Ygb3B0cy5kZXB0aCA9PT0gJ3VuZGVmaW5lZCcgPyA5OTk5OTk5OTkgOiBvcHRzLmRlcHRoO1xuICBvcHRzLmVudHJ5VHlwZSAgICAgICA9ICBvcHRzLmVudHJ5VHlwZSAgICAgICB8fCAnZmlsZXMnO1xuXG4gIHZhciBzdGF0Zm4gPSBvcHRzLmxzdGF0ID09PSB0cnVlID8gZnMubHN0YXQuYmluZChmcykgOiBmcy5zdGF0LmJpbmQoZnMpO1xuXG4gIGlmIChpc1VuZGVmaW5lZChjYWxsYmFjazIpKSB7XG4gICAgZmlsZVByb2Nlc3NlZCA9IGZ1bmN0aW9uKCkgeyB9O1xuICAgIGFsbFByb2Nlc3NlZCA9IGNhbGxiYWNrMTtcbiAgfSBlbHNlIHtcbiAgICBmaWxlUHJvY2Vzc2VkID0gY2FsbGJhY2sxO1xuICAgIGFsbFByb2Nlc3NlZCA9IGNhbGxiYWNrMjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUZpbHRlciAoZmlsdGVyKSB7XG5cbiAgICBpZiAoaXNVbmRlZmluZWQoZmlsdGVyKSkgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgIGZ1bmN0aW9uIGlzTmVnYXRlZCAoZmlsdGVycykge1xuXG4gICAgICBmdW5jdGlvbiBuZWdhdGVkKGYpIHsgXG4gICAgICAgIHJldHVybiBmLmluZGV4T2YoJyEnKSA9PT0gMDsgXG4gICAgICB9XG5cbiAgICAgIHZhciBzb21lID0gZmlsdGVycy5zb21lKG5lZ2F0ZWQpO1xuICAgICAgaWYgKCFzb21lKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmaWx0ZXJzLmV2ZXJ5KG5lZ2F0ZWQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgd2UgZGV0ZWN0IGlsbGVnYWwgZmlsdGVycywgYmFpbCBvdXQgaW1tZWRpYXRlbHlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2Fubm90IG1peCBuZWdhdGVkIHdpdGggbm9uIG5lZ2F0ZWQgZ2xvYiBmaWx0ZXJzOiAnICsgZmlsdGVycyArICdcXG4nICtcbiAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vdGhsb3JlbnovcmVhZGRpcnAjZmlsdGVycydcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHVybiBhbGwgZmlsdGVycyBpbnRvIGEgZnVuY3Rpb25cbiAgICBpZiAoaXNGdW5jdGlvbihmaWx0ZXIpKSB7XG5cbiAgICAgIHJldHVybiBmaWx0ZXI7XG5cbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKGZpbHRlcikpIHtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlbnRyeUluZm8pIHtcbiAgICAgICAgcmV0dXJuIG1pbmltYXRjaChlbnRyeUluZm8ubmFtZSwgZmlsdGVyLnRyaW0oKSk7XG4gICAgICB9O1xuXG4gICAgfSBlbHNlIGlmIChmaWx0ZXIgJiYgQXJyYXkuaXNBcnJheShmaWx0ZXIpKSB7XG5cbiAgICAgIGlmIChmaWx0ZXIpIGZpbHRlciA9IGZpbHRlci5tYXAoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGYudHJpbSgpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBpc05lZ2F0ZWQoZmlsdGVyKSA/XG4gICAgICAgIC8vIHVzZSBBTkQgdG8gY29uY2F0IG11bHRpcGxlIG5lZ2F0ZWQgZmlsdGVyc1xuICAgICAgICBmdW5jdGlvbiAoZW50cnlJbmZvKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbHRlci5ldmVyeShmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgcmV0dXJuIG1pbmltYXRjaChlbnRyeUluZm8ubmFtZSwgZik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOlxuICAgICAgICAvLyB1c2UgT1IgdG8gY29uY2F0IG11bHRpcGxlIGluY2x1c2l2ZSBmaWx0ZXJzXG4gICAgICAgIGZ1bmN0aW9uIChlbnRyeUluZm8pIHtcbiAgICAgICAgICByZXR1cm4gZmlsdGVyLnNvbWUoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIHJldHVybiBtaW5pbWF0Y2goZW50cnlJbmZvLm5hbWUsIGYpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NEaXIoY3VycmVudERpciwgZW50cmllcywgY2FsbFByb2Nlc3NlZCkge1xuICAgIGlmIChhYm9ydGVkKSByZXR1cm47XG4gICAgdmFyIHRvdGFsID0gZW50cmllcy5sZW5ndGhcbiAgICAgICwgcHJvY2Vzc2VkID0gMFxuICAgICAgLCBlbnRyeUluZm9zID0gW11cbiAgICAgIDtcblxuICAgIGZzLnJlYWxwYXRoKGN1cnJlbnREaXIsIGZ1bmN0aW9uKGVyciwgcmVhbEN1cnJlbnREaXIpIHtcbiAgICAgIGlmIChhYm9ydGVkKSByZXR1cm47XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGVycik7XG4gICAgICAgIGNhbGxQcm9jZXNzZWQoZW50cnlJbmZvcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlbERpciA9IHBhdGgucmVsYXRpdmUocmVhbFJvb3QsIHJlYWxDdXJyZW50RGlyKTtcblxuICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNhbGxQcm9jZXNzZWQoW10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkgeyBcblxuICAgICAgICAgIHZhciBmdWxsUGF0aCA9IHBhdGguam9pbihyZWFsQ3VycmVudERpciwgZW50cnkpXG4gICAgICAgICAgICAsIHJlbFBhdGggID0gcGF0aC5qb2luKHJlbERpciwgZW50cnkpO1xuXG4gICAgICAgICAgc3RhdGZuKGZ1bGxQYXRoLCBmdW5jdGlvbiAoZXJyLCBzdGF0KSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIGhhbmRsZUVycm9yKGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbnRyeUluZm9zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgbmFtZSAgICAgICAgICA6ICBlbnRyeVxuICAgICAgICAgICAgICAgICwgcGF0aCAgICAgICAgICA6ICByZWxQYXRoICAgLy8gcmVsYXRpdmUgdG8gcm9vdFxuICAgICAgICAgICAgICAgICwgZnVsbFBhdGggICAgICA6ICBmdWxsUGF0aFxuXG4gICAgICAgICAgICAgICAgLCBwYXJlbnREaXIgICAgIDogIHJlbERpciAgICAvLyByZWxhdGl2ZSB0byByb290XG4gICAgICAgICAgICAgICAgLCBmdWxsUGFyZW50RGlyIDogIHJlYWxDdXJyZW50RGlyXG5cbiAgICAgICAgICAgICAgICAsIHN0YXQgICAgICAgICAgOiAgc3RhdFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2Nlc3NlZCsrO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3NlZCA9PT0gdG90YWwpIGNhbGxQcm9jZXNzZWQoZW50cnlJbmZvcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVhZGRpclJlYyhjdXJyZW50RGlyLCBkZXB0aCwgY2FsbEN1cnJlbnREaXJQcm9jZXNzZWQpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICBpZiAoYWJvcnRlZCkgcmV0dXJuO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHNpKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVhZGRpclJlYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0pXG4gICAgICByZXR1cm47XG4gICAgfSBcblxuICAgIGZzLnJlYWRkaXIoY3VycmVudERpciwgZnVuY3Rpb24gKGVyciwgZW50cmllcykge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBoYW5kbGVFcnJvcihlcnIpO1xuICAgICAgICBjYWxsQ3VycmVudERpclByb2Nlc3NlZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3NEaXIoY3VycmVudERpciwgZW50cmllcywgZnVuY3Rpb24oZW50cnlJbmZvcykge1xuXG4gICAgICAgIHZhciBzdWJkaXJzID0gZW50cnlJbmZvc1xuICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGVpKSB7IHJldHVybiBlaS5zdGF0LmlzRGlyZWN0b3J5KCkgJiYgb3B0cy5kaXJlY3RvcnlGaWx0ZXIoZWkpOyB9KTtcblxuICAgICAgICBzdWJkaXJzLmZvckVhY2goZnVuY3Rpb24gKGRpKSB7XG4gICAgICAgICAgaWYob3B0cy5lbnRyeVR5cGUgPT09ICdkaXJlY3RvcmllcycgfHwgb3B0cy5lbnRyeVR5cGUgPT09ICdib3RoJyB8fCBvcHRzLmVudHJ5VHlwZSA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICAgIGZpbGVQcm9jZXNzZWQoZGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZWFkZGlyUmVzdWx0LmRpcmVjdG9yaWVzLnB1c2goZGkpOyBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZW50cnlJbmZvc1xuICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oZWkpIHtcbiAgICAgICAgICAgIHZhciBpc0NvcnJlY3RUeXBlID0gb3B0cy5lbnRyeVR5cGUgPT09ICdhbGwnID9cbiAgICAgICAgICAgICAgIWVpLnN0YXQuaXNEaXJlY3RvcnkoKSA6IGVpLnN0YXQuaXNGaWxlKCkgfHwgZWkuc3RhdC5pc1N5bWJvbGljTGluaygpO1xuICAgICAgICAgICAgcmV0dXJuIGlzQ29ycmVjdFR5cGUgJiYgb3B0cy5maWxlRmlsdGVyKGVpKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChmaSkge1xuICAgICAgICAgICAgaWYob3B0cy5lbnRyeVR5cGUgPT09ICdmaWxlcycgfHwgb3B0cy5lbnRyeVR5cGUgPT09ICdib3RoJyB8fCBvcHRzLmVudHJ5VHlwZSA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICAgICAgZmlsZVByb2Nlc3NlZChmaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkZGlyUmVzdWx0LmZpbGVzLnB1c2goZmkpOyBcbiAgICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcGVuZGluZ1N1YmRpcnMgPSBzdWJkaXJzLmxlbmd0aDtcblxuICAgICAgICAvLyBCZSBkb25lIGlmIG5vIG1vcmUgc3ViZm9sZGVycyBleGlzdCBvciB3ZSByZWFjaGVkIHRoZSBtYXhpbXVtIGRlc2lyZWQgZGVwdGhcbiAgICAgICAgaWYocGVuZGluZ1N1YmRpcnMgPT09IDAgfHwgZGVwdGggPT09IG9wdHMuZGVwdGgpIHtcbiAgICAgICAgICBjYWxsQ3VycmVudERpclByb2Nlc3NlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHJlY3Vyc2UgaW50byBzdWJkaXJzLCBrZWVwaW5nIHRyYWNrIG9mIHdoaWNoIG9uZXMgYXJlIGRvbmUgXG4gICAgICAgICAgLy8gYW5kIGNhbGwgYmFjayBvbmNlIGFsbCBhcmUgcHJvY2Vzc2VkXG4gICAgICAgICAgc3ViZGlycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJkaXIpIHtcbiAgICAgICAgICAgIHJlYWRkaXJSZWMoc3ViZGlyLmZ1bGxQYXRoLCBkZXB0aCArIDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcGVuZGluZ1N1YmRpcnMgPSBwZW5kaW5nU3ViZGlycyAtIDE7XG4gICAgICAgICAgICAgIGlmKHBlbmRpbmdTdWJkaXJzID09PSAwKSB7IFxuICAgICAgICAgICAgICAgIGNhbGxDdXJyZW50RGlyUHJvY2Vzc2VkKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFZhbGlkYXRlIGFuZCBub3JtYWxpemUgZmlsdGVyc1xuICB0cnkge1xuICAgIG9wdHMuZmlsZUZpbHRlciA9IG5vcm1hbGl6ZUZpbHRlcihvcHRzLmZpbGVGaWx0ZXIpO1xuICAgIG9wdHMuZGlyZWN0b3J5RmlsdGVyID0gbm9ybWFsaXplRmlsdGVyKG9wdHMuZGlyZWN0b3J5RmlsdGVyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gaWYgd2UgZGV0ZWN0IGlsbGVnYWwgZmlsdGVycywgYmFpbCBvdXQgaW1tZWRpYXRlbHlcbiAgICBoYW5kbGVGYXRhbEVycm9yKGVycik7XG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfVxuXG4gIC8vIElmIGZpbHRlcnMgd2VyZSB2YWxpZCBnZXQgb24gd2l0aCB0aGUgc2hvd1xuICBmcy5yZWFscGF0aChvcHRzLnJvb3QsIGZ1bmN0aW9uKGVyciwgcmVzKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgaGFuZGxlRmF0YWxFcnJvcihlcnIpO1xuICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9XG5cbiAgICByZWFsUm9vdCA9IHJlcztcbiAgICByZWFkZGlyUmVjKG9wdHMucm9vdCwgMCwgZnVuY3Rpb24gKCkgeyBcbiAgICAgIC8vIEFsbCBlcnJvcnMgYXJlIGNvbGxlY3RlZCBpbnRvIHRoZSBlcnJvcnMgYXJyYXlcbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBhbGxQcm9jZXNzZWQoZXJyb3JzLCByZWFkZGlyUmVzdWx0KTsgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxQcm9jZXNzZWQobnVsbCwgcmVhZGRpclJlc3VsdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBzdHJlYW07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVhZGRpcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFkZGlycC9yZWFkZGlycC5qc1xuLy8gbW9kdWxlIGlkID0gMjYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBmcyA9IHJlcXVpcmUoJ2ZzJylcbnZhciBwb2x5ZmlsbHMgPSByZXF1aXJlKCcuL3BvbHlmaWxscy5qcycpXG52YXIgbGVnYWN5ID0gcmVxdWlyZSgnLi9sZWdhY3ktc3RyZWFtcy5qcycpXG52YXIgcXVldWUgPSBbXVxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbnZhciBkZWJ1ZyA9IG5vb3BcbmlmICh1dGlsLmRlYnVnbG9nKVxuICBkZWJ1ZyA9IHV0aWwuZGVidWdsb2coJ2dmczQnKVxuZWxzZSBpZiAoL1xcYmdmczRcXGIvaS50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJycpKVxuICBkZWJ1ZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtID0gdXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgYXJndW1lbnRzKVxuICAgIG0gPSAnR0ZTNDogJyArIG0uc3BsaXQoL1xcbi8pLmpvaW4oJ1xcbkdGUzQ6ICcpXG4gICAgY29uc29sZS5lcnJvcihtKVxuICB9XG5cbmlmICgvXFxiZ2ZzNFxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJykpIHtcbiAgcHJvY2Vzcy5vbignZXhpdCcsIGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKHF1ZXVlKVxuICAgIHJlcXVpcmUoJ2Fzc2VydCcpLmVxdWFsKHF1ZXVlLmxlbmd0aCwgMClcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaChyZXF1aXJlKCcuL2ZzLmpzJykpXG5pZiAocHJvY2Vzcy5lbnYuVEVTVF9HUkFDRUZVTF9GU19HTE9CQUxfUEFUQ0gpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwYXRjaChmcylcbn1cblxuLy8gQWx3YXlzIHBhdGNoIGZzLmNsb3NlL2Nsb3NlU3luYywgYmVjYXVzZSB3ZSB3YW50IHRvXG4vLyByZXRyeSgpIHdoZW5ldmVyIGEgY2xvc2UgaGFwcGVucyAqYW55d2hlcmUqIGluIHRoZSBwcm9ncmFtLlxuLy8gVGhpcyBpcyBlc3NlbnRpYWwgd2hlbiBtdWx0aXBsZSBncmFjZWZ1bC1mcyBpbnN0YW5jZXMgYXJlXG4vLyBpbiBwbGF5IGF0IHRoZSBzYW1lIHRpbWUuXG5tb2R1bGUuZXhwb3J0cy5jbG9zZSA9XG5mcy5jbG9zZSA9IChmdW5jdGlvbiAoZnMkY2xvc2UpIHsgcmV0dXJuIGZ1bmN0aW9uIChmZCwgY2IpIHtcbiAgcmV0dXJuIGZzJGNsb3NlLmNhbGwoZnMsIGZkLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFlcnIpXG4gICAgICByZXRyeSgpXG5cbiAgICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9KVxufX0pKGZzLmNsb3NlKVxuXG5tb2R1bGUuZXhwb3J0cy5jbG9zZVN5bmMgPVxuZnMuY2xvc2VTeW5jID0gKGZ1bmN0aW9uIChmcyRjbG9zZVN5bmMpIHsgcmV0dXJuIGZ1bmN0aW9uIChmZCkge1xuICAvLyBOb3RlIHRoYXQgZ3JhY2VmdWwtZnMgYWxzbyByZXRyaWVzIHdoZW4gZnMuY2xvc2VTeW5jKCkgZmFpbHMuXG4gIC8vIExvb2tzIGxpa2UgYSBidWcgdG8gbWUsIGFsdGhvdWdoIGl0J3MgcHJvYmFibHkgYSBoYXJtbGVzcyBvbmUuXG4gIHZhciBydmFsID0gZnMkY2xvc2VTeW5jLmFwcGx5KGZzLCBhcmd1bWVudHMpXG4gIHJldHJ5KClcbiAgcmV0dXJuIHJ2YWxcbn19KShmcy5jbG9zZVN5bmMpXG5cbmZ1bmN0aW9uIHBhdGNoIChmcykge1xuICAvLyBFdmVyeXRoaW5nIHRoYXQgcmVmZXJlbmNlcyB0aGUgb3BlbigpIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIGluIGhlcmVcbiAgcG9seWZpbGxzKGZzKVxuICBmcy5ncmFjZWZ1bGlmeSA9IHBhdGNoXG4gIGZzLkZpbGVSZWFkU3RyZWFtID0gUmVhZFN0cmVhbTsgIC8vIExlZ2FjeSBuYW1lLlxuICBmcy5GaWxlV3JpdGVTdHJlYW0gPSBXcml0ZVN0cmVhbTsgIC8vIExlZ2FjeSBuYW1lLlxuICBmcy5jcmVhdGVSZWFkU3RyZWFtID0gY3JlYXRlUmVhZFN0cmVhbVxuICBmcy5jcmVhdGVXcml0ZVN0cmVhbSA9IGNyZWF0ZVdyaXRlU3RyZWFtXG4gIHZhciBmcyRyZWFkRmlsZSA9IGZzLnJlYWRGaWxlXG4gIGZzLnJlYWRGaWxlID0gcmVhZEZpbGVcbiAgZnVuY3Rpb24gcmVhZEZpbGUgKHBhdGgsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBvcHRpb25zLCBvcHRpb25zID0gbnVsbFxuXG4gICAgcmV0dXJuIGdvJHJlYWRGaWxlKHBhdGgsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kcmVhZEZpbGUgKHBhdGgsIG9wdGlvbnMsIGNiKSB7XG4gICAgICByZXR1cm4gZnMkcmVhZEZpbGUocGF0aCwgb3B0aW9ucywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyICYmIChlcnIuY29kZSA9PT0gJ0VNRklMRScgfHwgZXJyLmNvZGUgPT09ICdFTkZJTEUnKSlcbiAgICAgICAgICBlbnF1ZXVlKFtnbyRyZWFkRmlsZSwgW3BhdGgsIG9wdGlvbnMsIGNiXV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgcmV0cnkoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyR3cml0ZUZpbGUgPSBmcy53cml0ZUZpbGVcbiAgZnMud3JpdGVGaWxlID0gd3JpdGVGaWxlXG4gIGZ1bmN0aW9uIHdyaXRlRmlsZSAocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpXG4gICAgICBjYiA9IG9wdGlvbnMsIG9wdGlvbnMgPSBudWxsXG5cbiAgICByZXR1cm4gZ28kd3JpdGVGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kd3JpdGVGaWxlIChwYXRoLCBkYXRhLCBvcHRpb25zLCBjYikge1xuICAgICAgcmV0dXJuIGZzJHdyaXRlRmlsZShwYXRoLCBkYXRhLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJHdyaXRlRmlsZSwgW3BhdGgsIGRhdGEsIG9wdGlvbnMsIGNiXV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgcmV0cnkoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyRhcHBlbmRGaWxlID0gZnMuYXBwZW5kRmlsZVxuICBpZiAoZnMkYXBwZW5kRmlsZSlcbiAgICBmcy5hcHBlbmRGaWxlID0gYXBwZW5kRmlsZVxuICBmdW5jdGlvbiBhcHBlbmRGaWxlIChwYXRoLCBkYXRhLCBvcHRpb25zLCBjYikge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gb3B0aW9ucywgb3B0aW9ucyA9IG51bGxcblxuICAgIHJldHVybiBnbyRhcHBlbmRGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGNiKVxuXG4gICAgZnVuY3Rpb24gZ28kYXBwZW5kRmlsZSAocGF0aCwgZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICAgIHJldHVybiBmcyRhcHBlbmRGaWxlKHBhdGgsIGRhdGEsIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgICAgZW5xdWV1ZShbZ28kYXBwZW5kRmlsZSwgW3BhdGgsIGRhdGEsIG9wdGlvbnMsIGNiXV0pXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgcmV0cnkoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHZhciBmcyRyZWFkZGlyID0gZnMucmVhZGRpclxuICBmcy5yZWFkZGlyID0gcmVhZGRpclxuICBmdW5jdGlvbiByZWFkZGlyIChwYXRoLCBvcHRpb25zLCBjYikge1xuICAgIHZhciBhcmdzID0gW3BhdGhdXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhcmdzLnB1c2gob3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgY2IgPSBvcHRpb25zXG4gICAgfVxuICAgIGFyZ3MucHVzaChnbyRyZWFkZGlyJGNiKVxuXG4gICAgcmV0dXJuIGdvJHJlYWRkaXIoYXJncylcblxuICAgIGZ1bmN0aW9uIGdvJHJlYWRkaXIkY2IgKGVyciwgZmlsZXMpIHtcbiAgICAgIGlmIChmaWxlcyAmJiBmaWxlcy5zb3J0KVxuICAgICAgICBmaWxlcy5zb3J0KClcblxuICAgICAgaWYgKGVyciAmJiAoZXJyLmNvZGUgPT09ICdFTUZJTEUnIHx8IGVyci5jb2RlID09PSAnRU5GSUxFJykpXG4gICAgICAgIGVucXVldWUoW2dvJHJlYWRkaXIsIFthcmdzXV0pXG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICBjYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIHJldHJ5KClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnbyRyZWFkZGlyIChhcmdzKSB7XG4gICAgcmV0dXJuIGZzJHJlYWRkaXIuYXBwbHkoZnMsIGFyZ3MpXG4gIH1cblxuICBpZiAocHJvY2Vzcy52ZXJzaW9uLnN1YnN0cigwLCA0KSA9PT0gJ3YwLjgnKSB7XG4gICAgdmFyIGxlZ1N0cmVhbXMgPSBsZWdhY3koZnMpXG4gICAgUmVhZFN0cmVhbSA9IGxlZ1N0cmVhbXMuUmVhZFN0cmVhbVxuICAgIFdyaXRlU3RyZWFtID0gbGVnU3RyZWFtcy5Xcml0ZVN0cmVhbVxuICB9XG5cbiAgdmFyIGZzJFJlYWRTdHJlYW0gPSBmcy5SZWFkU3RyZWFtXG4gIFJlYWRTdHJlYW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShmcyRSZWFkU3RyZWFtLnByb3RvdHlwZSlcbiAgUmVhZFN0cmVhbS5wcm90b3R5cGUub3BlbiA9IFJlYWRTdHJlYW0kb3BlblxuXG4gIHZhciBmcyRXcml0ZVN0cmVhbSA9IGZzLldyaXRlU3RyZWFtXG4gIFdyaXRlU3RyZWFtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZnMkV3JpdGVTdHJlYW0ucHJvdG90eXBlKVxuICBXcml0ZVN0cmVhbS5wcm90b3R5cGUub3BlbiA9IFdyaXRlU3RyZWFtJG9wZW5cblxuICBmcy5SZWFkU3RyZWFtID0gUmVhZFN0cmVhbVxuICBmcy5Xcml0ZVN0cmVhbSA9IFdyaXRlU3RyZWFtXG5cbiAgZnVuY3Rpb24gUmVhZFN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgUmVhZFN0cmVhbSlcbiAgICAgIHJldHVybiBmcyRSZWFkU3RyZWFtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRoaXNcbiAgICBlbHNlXG4gICAgICByZXR1cm4gUmVhZFN0cmVhbS5hcHBseShPYmplY3QuY3JlYXRlKFJlYWRTdHJlYW0ucHJvdG90eXBlKSwgYXJndW1lbnRzKVxuICB9XG5cbiAgZnVuY3Rpb24gUmVhZFN0cmVhbSRvcGVuICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICBvcGVuKHRoYXQucGF0aCwgdGhhdC5mbGFncywgdGhhdC5tb2RlLCBmdW5jdGlvbiAoZXJyLCBmZCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAodGhhdC5hdXRvQ2xvc2UpXG4gICAgICAgICAgdGhhdC5kZXN0cm95KClcblxuICAgICAgICB0aGF0LmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhhdC5mZCA9IGZkXG4gICAgICAgIHRoYXQuZW1pdCgnb3BlbicsIGZkKVxuICAgICAgICB0aGF0LnJlYWQoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBXcml0ZVN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgV3JpdGVTdHJlYW0pXG4gICAgICByZXR1cm4gZnMkV3JpdGVTdHJlYW0uYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdGhpc1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBXcml0ZVN0cmVhbS5hcHBseShPYmplY3QuY3JlYXRlKFdyaXRlU3RyZWFtLnByb3RvdHlwZSksIGFyZ3VtZW50cylcbiAgfVxuXG4gIGZ1bmN0aW9uIFdyaXRlU3RyZWFtJG9wZW4gKCkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuICAgIG9wZW4odGhhdC5wYXRoLCB0aGF0LmZsYWdzLCB0aGF0Lm1vZGUsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRoYXQuZGVzdHJveSgpXG4gICAgICAgIHRoYXQuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGF0LmZkID0gZmRcbiAgICAgICAgdGhhdC5lbWl0KCdvcGVuJywgZmQpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlYWRTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFJlYWRTdHJlYW0ocGF0aCwgb3B0aW9ucylcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVdyaXRlU3RyZWFtIChwYXRoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0ZVN0cmVhbShwYXRoLCBvcHRpb25zKVxuICB9XG5cbiAgdmFyIGZzJG9wZW4gPSBmcy5vcGVuXG4gIGZzLm9wZW4gPSBvcGVuXG4gIGZ1bmN0aW9uIG9wZW4gKHBhdGgsIGZsYWdzLCBtb2RlLCBjYikge1xuICAgIGlmICh0eXBlb2YgbW9kZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gbW9kZSwgbW9kZSA9IG51bGxcblxuICAgIHJldHVybiBnbyRvcGVuKHBhdGgsIGZsYWdzLCBtb2RlLCBjYilcblxuICAgIGZ1bmN0aW9uIGdvJG9wZW4gKHBhdGgsIGZsYWdzLCBtb2RlLCBjYikge1xuICAgICAgcmV0dXJuIGZzJG9wZW4ocGF0aCwgZmxhZ3MsIG1vZGUsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICAgIGlmIChlcnIgJiYgKGVyci5jb2RlID09PSAnRU1GSUxFJyB8fCBlcnIuY29kZSA9PT0gJ0VORklMRScpKVxuICAgICAgICAgIGVucXVldWUoW2dvJG9wZW4sIFtwYXRoLCBmbGFncywgbW9kZSwgY2JdXSlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgICByZXRyeSgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZzXG59XG5cbmZ1bmN0aW9uIGVucXVldWUgKGVsZW0pIHtcbiAgZGVidWcoJ0VOUVVFVUUnLCBlbGVtWzBdLm5hbWUsIGVsZW1bMV0pXG4gIHF1ZXVlLnB1c2goZWxlbSlcbn1cblxuZnVuY3Rpb24gcmV0cnkgKCkge1xuICB2YXIgZWxlbSA9IHF1ZXVlLnNoaWZ0KClcbiAgaWYgKGVsZW0pIHtcbiAgICBkZWJ1ZygnUkVUUlknLCBlbGVtWzBdLm5hbWUsIGVsZW1bMV0pXG4gICAgZWxlbVswXS5hcHBseShudWxsLCBlbGVtWzFdKVxuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZ3JhY2VmdWwtZnMvZ3JhY2VmdWwtZnMuanNcbi8vIG1vZHVsZSBpZCA9IDI2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZnMgPSByZXF1aXJlKCcuL2ZzLmpzJylcbnZhciBjb25zdGFudHMgPSByZXF1aXJlKCdjb25zdGFudHMnKVxuXG52YXIgb3JpZ0N3ZCA9IHByb2Nlc3MuY3dkXG52YXIgY3dkID0gbnVsbFxuXG52YXIgcGxhdGZvcm0gPSBwcm9jZXNzLmVudi5HUkFDRUZVTF9GU19QTEFURk9STSB8fCBwcm9jZXNzLnBsYXRmb3JtXG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24oKSB7XG4gIGlmICghY3dkKVxuICAgIGN3ZCA9IG9yaWdDd2QuY2FsbChwcm9jZXNzKVxuICByZXR1cm4gY3dkXG59XG50cnkge1xuICBwcm9jZXNzLmN3ZCgpXG59IGNhdGNoIChlcikge31cblxudmFyIGNoZGlyID0gcHJvY2Vzcy5jaGRpclxucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uKGQpIHtcbiAgY3dkID0gbnVsbFxuICBjaGRpci5jYWxsKHByb2Nlc3MsIGQpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGF0Y2hcblxuZnVuY3Rpb24gcGF0Y2ggKGZzKSB7XG4gIC8vIChyZS0paW1wbGVtZW50IHNvbWUgdGhpbmdzIHRoYXQgYXJlIGtub3duIGJ1c3RlZCBvciBtaXNzaW5nLlxuXG4gIC8vIGxjaG1vZCwgYnJva2VuIHByaW9yIHRvIDAuNi4yXG4gIC8vIGJhY2stcG9ydCB0aGUgZml4IGhlcmUuXG4gIGlmIChjb25zdGFudHMuaGFzT3duUHJvcGVydHkoJ09fU1lNTElOSycpICYmXG4gICAgICBwcm9jZXNzLnZlcnNpb24ubWF0Y2goL152MFxcLjZcXC5bMC0yXXxedjBcXC41XFwuLykpIHtcbiAgICBwYXRjaExjaG1vZChmcylcbiAgfVxuXG4gIC8vIGx1dGltZXMgaW1wbGVtZW50YXRpb24sIG9yIG5vLW9wXG4gIGlmICghZnMubHV0aW1lcykge1xuICAgIHBhdGNoTHV0aW1lcyhmcylcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3Mvbm9kZS1ncmFjZWZ1bC1mcy9pc3N1ZXMvNFxuICAvLyBDaG93biBzaG91bGQgbm90IGZhaWwgb24gZWludmFsIG9yIGVwZXJtIGlmIG5vbi1yb290LlxuICAvLyBJdCBzaG91bGQgbm90IGZhaWwgb24gZW5vc3lzIGV2ZXIsIGFzIHRoaXMganVzdCBpbmRpY2F0ZXNcbiAgLy8gdGhhdCBhIGZzIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgaW50ZW5kZWQgb3BlcmF0aW9uLlxuXG4gIGZzLmNob3duID0gY2hvd25GaXgoZnMuY2hvd24pXG4gIGZzLmZjaG93biA9IGNob3duRml4KGZzLmZjaG93bilcbiAgZnMubGNob3duID0gY2hvd25GaXgoZnMubGNob3duKVxuXG4gIGZzLmNobW9kID0gY2htb2RGaXgoZnMuY2htb2QpXG4gIGZzLmZjaG1vZCA9IGNobW9kRml4KGZzLmZjaG1vZClcbiAgZnMubGNobW9kID0gY2htb2RGaXgoZnMubGNobW9kKVxuXG4gIGZzLmNob3duU3luYyA9IGNob3duRml4U3luYyhmcy5jaG93blN5bmMpXG4gIGZzLmZjaG93blN5bmMgPSBjaG93bkZpeFN5bmMoZnMuZmNob3duU3luYylcbiAgZnMubGNob3duU3luYyA9IGNob3duRml4U3luYyhmcy5sY2hvd25TeW5jKVxuXG4gIGZzLmNobW9kU3luYyA9IGNobW9kRml4U3luYyhmcy5jaG1vZFN5bmMpXG4gIGZzLmZjaG1vZFN5bmMgPSBjaG1vZEZpeFN5bmMoZnMuZmNobW9kU3luYylcbiAgZnMubGNobW9kU3luYyA9IGNobW9kRml4U3luYyhmcy5sY2htb2RTeW5jKVxuXG4gIGZzLnN0YXQgPSBzdGF0Rml4KGZzLnN0YXQpXG4gIGZzLmZzdGF0ID0gc3RhdEZpeChmcy5mc3RhdClcbiAgZnMubHN0YXQgPSBzdGF0Rml4KGZzLmxzdGF0KVxuXG4gIGZzLnN0YXRTeW5jID0gc3RhdEZpeFN5bmMoZnMuc3RhdFN5bmMpXG4gIGZzLmZzdGF0U3luYyA9IHN0YXRGaXhTeW5jKGZzLmZzdGF0U3luYylcbiAgZnMubHN0YXRTeW5jID0gc3RhdEZpeFN5bmMoZnMubHN0YXRTeW5jKVxuXG4gIC8vIGlmIGxjaG1vZC9sY2hvd24gZG8gbm90IGV4aXN0LCB0aGVuIG1ha2UgdGhlbSBuby1vcHNcbiAgaWYgKCFmcy5sY2htb2QpIHtcbiAgICBmcy5sY2htb2QgPSBmdW5jdGlvbiAocGF0aCwgbW9kZSwgY2IpIHtcbiAgICAgIGlmIChjYikgcHJvY2Vzcy5uZXh0VGljayhjYilcbiAgICB9XG4gICAgZnMubGNobW9kU3luYyA9IGZ1bmN0aW9uICgpIHt9XG4gIH1cbiAgaWYgKCFmcy5sY2hvd24pIHtcbiAgICBmcy5sY2hvd24gPSBmdW5jdGlvbiAocGF0aCwgdWlkLCBnaWQsIGNiKSB7XG4gICAgICBpZiAoY2IpIHByb2Nlc3MubmV4dFRpY2soY2IpXG4gICAgfVxuICAgIGZzLmxjaG93blN5bmMgPSBmdW5jdGlvbiAoKSB7fVxuICB9XG5cbiAgLy8gb24gV2luZG93cywgQS9WIHNvZnR3YXJlIGNhbiBsb2NrIHRoZSBkaXJlY3RvcnksIGNhdXNpbmcgdGhpc1xuICAvLyB0byBmYWlsIHdpdGggYW4gRUFDQ0VTIG9yIEVQRVJNIGlmIHRoZSBkaXJlY3RvcnkgY29udGFpbnMgbmV3bHlcbiAgLy8gY3JlYXRlZCBmaWxlcy4gIFRyeSBhZ2FpbiBvbiBmYWlsdXJlLCBmb3IgdXAgdG8gNjAgc2Vjb25kcy5cblxuICAvLyBTZXQgdGhlIHRpbWVvdXQgdGhpcyBsb25nIGJlY2F1c2Ugc29tZSBXaW5kb3dzIEFudGktVmlydXMsIHN1Y2ggYXMgUGFyaXR5XG4gIC8vIGJpdDksIG1heSBsb2NrIGZpbGVzIGZvciB1cCB0byBhIG1pbnV0ZSwgY2F1c2luZyBucG0gcGFja2FnZSBpbnN0YWxsXG4gIC8vIGZhaWx1cmVzLiBBbHNvLCB0YWtlIGNhcmUgdG8geWllbGQgdGhlIHNjaGVkdWxlci4gV2luZG93cyBzY2hlZHVsaW5nIGdpdmVzXG4gIC8vIENQVSB0byBhIGJ1c3kgbG9vcGluZyBwcm9jZXNzLCB3aGljaCBjYW4gY2F1c2UgdGhlIHByb2dyYW0gY2F1c2luZyB0aGUgbG9ja1xuICAvLyBjb250ZW50aW9uIHRvIGJlIHN0YXJ2ZWQgb2YgQ1BVIGJ5IG5vZGUsIHNvIHRoZSBjb250ZW50aW9uIGRvZXNuJ3QgcmVzb2x2ZS5cbiAgaWYgKHBsYXRmb3JtID09PSBcIndpbjMyXCIpIHtcbiAgICBmcy5yZW5hbWUgPSAoZnVuY3Rpb24gKGZzJHJlbmFtZSkgeyByZXR1cm4gZnVuY3Rpb24gKGZyb20sIHRvLCBjYikge1xuICAgICAgdmFyIHN0YXJ0ID0gRGF0ZS5ub3coKVxuICAgICAgdmFyIGJhY2tvZmYgPSAwO1xuICAgICAgZnMkcmVuYW1lKGZyb20sIHRvLCBmdW5jdGlvbiBDQiAoZXIpIHtcbiAgICAgICAgaWYgKGVyXG4gICAgICAgICAgICAmJiAoZXIuY29kZSA9PT0gXCJFQUNDRVNcIiB8fCBlci5jb2RlID09PSBcIkVQRVJNXCIpXG4gICAgICAgICAgICAmJiBEYXRlLm5vdygpIC0gc3RhcnQgPCA2MDAwMCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmcy5zdGF0KHRvLCBmdW5jdGlvbiAoc3RhdGVyLCBzdCkge1xuICAgICAgICAgICAgICBpZiAoc3RhdGVyICYmIHN0YXRlci5jb2RlID09PSBcIkVOT0VOVFwiKVxuICAgICAgICAgICAgICAgIGZzJHJlbmFtZShmcm9tLCB0bywgQ0IpO1xuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY2IoZXIpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0sIGJhY2tvZmYpXG4gICAgICAgICAgaWYgKGJhY2tvZmYgPCAxMDApXG4gICAgICAgICAgICBiYWNrb2ZmICs9IDEwO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2IpIGNiKGVyKVxuICAgICAgfSlcbiAgICB9fSkoZnMucmVuYW1lKVxuICB9XG5cbiAgLy8gaWYgcmVhZCgpIHJldHVybnMgRUFHQUlOLCB0aGVuIGp1c3QgdHJ5IGl0IGFnYWluLlxuICBmcy5yZWFkID0gKGZ1bmN0aW9uIChmcyRyZWFkKSB7IHJldHVybiBmdW5jdGlvbiAoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFja18pIHtcbiAgICB2YXIgY2FsbGJhY2tcbiAgICBpZiAoY2FsbGJhY2tfICYmIHR5cGVvZiBjYWxsYmFja18gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBlYWdDb3VudGVyID0gMFxuICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoZXIsIF8sIF9fKSB7XG4gICAgICAgIGlmIChlciAmJiBlci5jb2RlID09PSAnRUFHQUlOJyAmJiBlYWdDb3VudGVyIDwgMTApIHtcbiAgICAgICAgICBlYWdDb3VudGVyICsrXG4gICAgICAgICAgcmV0dXJuIGZzJHJlYWQuY2FsbChmcywgZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaylcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFja18uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnMkcmVhZC5jYWxsKGZzLCBmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbGxiYWNrKVxuICB9fSkoZnMucmVhZClcblxuICBmcy5yZWFkU3luYyA9IChmdW5jdGlvbiAoZnMkcmVhZFN5bmMpIHsgcmV0dXJuIGZ1bmN0aW9uIChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHtcbiAgICB2YXIgZWFnQ291bnRlciA9IDBcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZzJHJlYWRTeW5jLmNhbGwoZnMsIGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbilcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGlmIChlci5jb2RlID09PSAnRUFHQUlOJyAmJiBlYWdDb3VudGVyIDwgMTApIHtcbiAgICAgICAgICBlYWdDb3VudGVyICsrXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlclxuICAgICAgfVxuICAgIH1cbiAgfX0pKGZzLnJlYWRTeW5jKVxufVxuXG5mdW5jdGlvbiBwYXRjaExjaG1vZCAoZnMpIHtcbiAgZnMubGNobW9kID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUsIGNhbGxiYWNrKSB7XG4gICAgZnMub3BlbiggcGF0aFxuICAgICAgICAgICAsIGNvbnN0YW50cy5PX1dST05MWSB8IGNvbnN0YW50cy5PX1NZTUxJTktcbiAgICAgICAgICAgLCBtb2RlXG4gICAgICAgICAgICwgZnVuY3Rpb24gKGVyciwgZmQpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLy8gcHJlZmVyIHRvIHJldHVybiB0aGUgY2htb2QgZXJyb3IsIGlmIG9uZSBvY2N1cnMsXG4gICAgICAvLyBidXQgc3RpbGwgdHJ5IHRvIGNsb3NlLCBhbmQgcmVwb3J0IGNsb3NpbmcgZXJyb3JzIGlmIHRoZXkgb2NjdXIuXG4gICAgICBmcy5mY2htb2QoZmQsIG1vZGUsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgZnMuY2xvc2UoZmQsIGZ1bmN0aW9uKGVycjIpIHtcbiAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVyciB8fCBlcnIyKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgZnMubGNobW9kU3luYyA9IGZ1bmN0aW9uIChwYXRoLCBtb2RlKSB7XG4gICAgdmFyIGZkID0gZnMub3BlblN5bmMocGF0aCwgY29uc3RhbnRzLk9fV1JPTkxZIHwgY29uc3RhbnRzLk9fU1lNTElOSywgbW9kZSlcblxuICAgIC8vIHByZWZlciB0byByZXR1cm4gdGhlIGNobW9kIGVycm9yLCBpZiBvbmUgb2NjdXJzLFxuICAgIC8vIGJ1dCBzdGlsbCB0cnkgdG8gY2xvc2UsIGFuZCByZXBvcnQgY2xvc2luZyBlcnJvcnMgaWYgdGhleSBvY2N1ci5cbiAgICB2YXIgdGhyZXcgPSB0cnVlXG4gICAgdmFyIHJldFxuICAgIHRyeSB7XG4gICAgICByZXQgPSBmcy5mY2htb2RTeW5jKGZkLCBtb2RlKVxuICAgICAgdGhyZXcgPSBmYWxzZVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhyZXcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICAgIH0gY2F0Y2ggKGVyKSB7fVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnMuY2xvc2VTeW5jKGZkKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cblxuZnVuY3Rpb24gcGF0Y2hMdXRpbWVzIChmcykge1xuICBpZiAoY29uc3RhbnRzLmhhc093blByb3BlcnR5KFwiT19TWU1MSU5LXCIpKSB7XG4gICAgZnMubHV0aW1lcyA9IGZ1bmN0aW9uIChwYXRoLCBhdCwgbXQsIGNiKSB7XG4gICAgICBmcy5vcGVuKHBhdGgsIGNvbnN0YW50cy5PX1NZTUxJTkssIGZ1bmN0aW9uIChlciwgZmQpIHtcbiAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgaWYgKGNiKSBjYihlcilcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBmcy5mdXRpbWVzKGZkLCBhdCwgbXQsIGZ1bmN0aW9uIChlcikge1xuICAgICAgICAgIGZzLmNsb3NlKGZkLCBmdW5jdGlvbiAoZXIyKSB7XG4gICAgICAgICAgICBpZiAoY2IpIGNiKGVyIHx8IGVyMilcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmcy5sdXRpbWVzU3luYyA9IGZ1bmN0aW9uIChwYXRoLCBhdCwgbXQpIHtcbiAgICAgIHZhciBmZCA9IGZzLm9wZW5TeW5jKHBhdGgsIGNvbnN0YW50cy5PX1NZTUxJTkspXG4gICAgICB2YXIgcmV0XG4gICAgICB2YXIgdGhyZXcgPSB0cnVlXG4gICAgICB0cnkge1xuICAgICAgICByZXQgPSBmcy5mdXRpbWVzU3luYyhmZCwgYXQsIG10KVxuICAgICAgICB0aHJldyA9IGZhbHNlXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodGhyZXcpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZnMuY2xvc2VTeW5jKGZkKVxuICAgICAgICAgIH0gY2F0Y2ggKGVyKSB7fVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZzLmNsb3NlU3luYyhmZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldFxuICAgIH1cblxuICB9IGVsc2Uge1xuICAgIGZzLmx1dGltZXMgPSBmdW5jdGlvbiAoX2EsIF9iLCBfYywgY2IpIHsgaWYgKGNiKSBwcm9jZXNzLm5leHRUaWNrKGNiKSB9XG4gICAgZnMubHV0aW1lc1N5bmMgPSBmdW5jdGlvbiAoKSB7fVxuICB9XG59XG5cbmZ1bmN0aW9uIGNobW9kRml4IChvcmlnKSB7XG4gIGlmICghb3JpZykgcmV0dXJuIG9yaWdcbiAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIG1vZGUsIGNiKSB7XG4gICAgcmV0dXJuIG9yaWcuY2FsbChmcywgdGFyZ2V0LCBtb2RlLCBmdW5jdGlvbiAoZXIpIHtcbiAgICAgIGlmIChjaG93bkVyT2soZXIpKSBlciA9IG51bGxcbiAgICAgIGlmIChjYikgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gY2htb2RGaXhTeW5jIChvcmlnKSB7XG4gIGlmICghb3JpZykgcmV0dXJuIG9yaWdcbiAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIG1vZGUpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG9yaWcuY2FsbChmcywgdGFyZ2V0LCBtb2RlKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICBpZiAoIWNob3duRXJPayhlcikpIHRocm93IGVyXG4gICAgfVxuICB9XG59XG5cblxuZnVuY3Rpb24gY2hvd25GaXggKG9yaWcpIHtcbiAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgdWlkLCBnaWQsIGNiKSB7XG4gICAgcmV0dXJuIG9yaWcuY2FsbChmcywgdGFyZ2V0LCB1aWQsIGdpZCwgZnVuY3Rpb24gKGVyKSB7XG4gICAgICBpZiAoY2hvd25Fck9rKGVyKSkgZXIgPSBudWxsXG4gICAgICBpZiAoY2IpIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGNob3duRml4U3luYyAob3JpZykge1xuICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCB1aWQsIGdpZCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gb3JpZy5jYWxsKGZzLCB0YXJnZXQsIHVpZCwgZ2lkKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICBpZiAoIWNob3duRXJPayhlcikpIHRocm93IGVyXG4gICAgfVxuICB9XG59XG5cblxuZnVuY3Rpb24gc3RhdEZpeCAob3JpZykge1xuICBpZiAoIW9yaWcpIHJldHVybiBvcmlnXG4gIC8vIE9sZGVyIHZlcnNpb25zIG9mIE5vZGUgZXJyb25lb3VzbHkgcmV0dXJuZWQgc2lnbmVkIGludGVnZXJzIGZvclxuICAvLyB1aWQgKyBnaWQuXG4gIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBjYikge1xuICAgIHJldHVybiBvcmlnLmNhbGwoZnMsIHRhcmdldCwgZnVuY3Rpb24gKGVyLCBzdGF0cykge1xuICAgICAgaWYgKCFzdGF0cykgcmV0dXJuIGNiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIGlmIChzdGF0cy51aWQgPCAwKSBzdGF0cy51aWQgKz0gMHgxMDAwMDAwMDBcbiAgICAgIGlmIChzdGF0cy5naWQgPCAwKSBzdGF0cy5naWQgKz0gMHgxMDAwMDAwMDBcbiAgICAgIGlmIChjYikgY2IuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhdEZpeFN5bmMgKG9yaWcpIHtcbiAgaWYgKCFvcmlnKSByZXR1cm4gb3JpZ1xuICAvLyBPbGRlciB2ZXJzaW9ucyBvZiBOb2RlIGVycm9uZW91c2x5IHJldHVybmVkIHNpZ25lZCBpbnRlZ2VycyBmb3JcbiAgLy8gdWlkICsgZ2lkLlxuICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHZhciBzdGF0cyA9IG9yaWcuY2FsbChmcywgdGFyZ2V0KVxuICAgIGlmIChzdGF0cy51aWQgPCAwKSBzdGF0cy51aWQgKz0gMHgxMDAwMDAwMDBcbiAgICBpZiAoc3RhdHMuZ2lkIDwgMCkgc3RhdHMuZ2lkICs9IDB4MTAwMDAwMDAwXG4gICAgcmV0dXJuIHN0YXRzO1xuICB9XG59XG5cbi8vIEVOT1NZUyBtZWFucyB0aGF0IHRoZSBmcyBkb2Vzbid0IHN1cHBvcnQgdGhlIG9wLiBKdXN0IGlnbm9yZVxuLy8gdGhhdCwgYmVjYXVzZSBpdCBkb2Vzbid0IG1hdHRlci5cbi8vXG4vLyBpZiB0aGVyZSdzIG5vIGdldHVpZCwgb3IgaWYgZ2V0dWlkKCkgaXMgc29tZXRoaW5nIG90aGVyXG4vLyB0aGFuIDAsIGFuZCB0aGUgZXJyb3IgaXMgRUlOVkFMIG9yIEVQRVJNLCB0aGVuIGp1c3QgaWdub3JlXG4vLyBpdC5cbi8vXG4vLyBUaGlzIHNwZWNpZmljIGNhc2UgaXMgYSBzaWxlbnQgZmFpbHVyZSBpbiBjcCwgaW5zdGFsbCwgdGFyLFxuLy8gYW5kIG1vc3Qgb3RoZXIgdW5peCB0b29scyB0aGF0IG1hbmFnZSBwZXJtaXNzaW9ucy5cbi8vXG4vLyBXaGVuIHJ1bm5pbmcgYXMgcm9vdCwgb3IgaWYgb3RoZXIgdHlwZXMgb2YgZXJyb3JzIGFyZVxuLy8gZW5jb3VudGVyZWQsIHRoZW4gaXQncyBzdHJpY3QuXG5mdW5jdGlvbiBjaG93bkVyT2sgKGVyKSB7XG4gIGlmICghZXIpXG4gICAgcmV0dXJuIHRydWVcblxuICBpZiAoZXIuY29kZSA9PT0gXCJFTk9TWVNcIilcbiAgICByZXR1cm4gdHJ1ZVxuXG4gIHZhciBub25yb290ID0gIXByb2Nlc3MuZ2V0dWlkIHx8IHByb2Nlc3MuZ2V0dWlkKCkgIT09IDBcbiAgaWYgKG5vbnJvb3QpIHtcbiAgICBpZiAoZXIuY29kZSA9PT0gXCJFSU5WQUxcIiB8fCBlci5jb2RlID09PSBcIkVQRVJNXCIpXG4gICAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZ3JhY2VmdWwtZnMvcG9seWZpbGxzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJylcblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZShmcylcblxuZnVuY3Rpb24gY2xvbmUgKG9iaikge1xuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKVxuICAgIHJldHVybiBvYmpcblxuICBpZiAob2JqIGluc3RhbmNlb2YgT2JqZWN0KVxuICAgIHZhciBjb3B5ID0geyBfX3Byb3RvX186IG9iai5fX3Byb3RvX18gfVxuICBlbHNlXG4gICAgdmFyIGNvcHkgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29weSwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSlcbiAgfSlcblxuICByZXR1cm4gY29weVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2dyYWNlZnVsLWZzL2ZzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpLlN0cmVhbVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxlZ2FjeVxuXG5mdW5jdGlvbiBsZWdhY3kgKGZzKSB7XG4gIHJldHVybiB7XG4gICAgUmVhZFN0cmVhbTogUmVhZFN0cmVhbSxcbiAgICBXcml0ZVN0cmVhbTogV3JpdGVTdHJlYW1cbiAgfVxuXG4gIGZ1bmN0aW9uIFJlYWRTdHJlYW0gKHBhdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZFN0cmVhbSkpIHJldHVybiBuZXcgUmVhZFN0cmVhbShwYXRoLCBvcHRpb25zKTtcblxuICAgIFN0cmVhbS5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLmZkID0gbnVsbDtcbiAgICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLnBhdXNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5mbGFncyA9ICdyJztcbiAgICB0aGlzLm1vZGUgPSA0Mzg7IC8qPTA2NjYqL1xuICAgIHRoaXMuYnVmZmVyU2l6ZSA9IDY0ICogMTAyNDtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gTWl4aW4gb3B0aW9ucyBpbnRvIHRoaXNcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpbmRleF07XG4gICAgICB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZW5jb2RpbmcpIHRoaXMuc2V0RW5jb2RpbmcodGhpcy5lbmNvZGluZyk7XG5cbiAgICBpZiAodGhpcy5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoJ251bWJlcicgIT09IHR5cGVvZiB0aGlzLnN0YXJ0KSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignc3RhcnQgbXVzdCBiZSBhIE51bWJlcicpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5lbmQgPSBJbmZpbml0eTtcbiAgICAgIH0gZWxzZSBpZiAoJ251bWJlcicgIT09IHR5cGVvZiB0aGlzLmVuZCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ2VuZCBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnN0YXJ0ID4gdGhpcy5lbmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdGFydCBtdXN0IGJlIDw9IGVuZCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmQgIT09IG51bGwpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuX3JlYWQoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZzLm9wZW4odGhpcy5wYXRoLCB0aGlzLmZsYWdzLCB0aGlzLm1vZGUsIGZ1bmN0aW9uIChlcnIsIGZkKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICBzZWxmLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi5mZCA9IGZkO1xuICAgICAgc2VsZi5lbWl0KCdvcGVuJywgZmQpO1xuICAgICAgc2VsZi5fcmVhZCgpO1xuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBXcml0ZVN0cmVhbSAocGF0aCwgb3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcml0ZVN0cmVhbSkpIHJldHVybiBuZXcgV3JpdGVTdHJlYW0ocGF0aCwgb3B0aW9ucyk7XG5cbiAgICBTdHJlYW0uY2FsbCh0aGlzKTtcblxuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5mZCA9IG51bGw7XG4gICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgICB0aGlzLmZsYWdzID0gJ3cnO1xuICAgIHRoaXMuZW5jb2RpbmcgPSAnYmluYXJ5JztcbiAgICB0aGlzLm1vZGUgPSA0Mzg7IC8qPTA2NjYqL1xuICAgIHRoaXMuYnl0ZXNXcml0dGVuID0gMDtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gTWl4aW4gb3B0aW9ucyBpbnRvIHRoaXNcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpbmRleF07XG4gICAgICB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdGhpcy5zdGFydCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ3N0YXJ0IG11c3QgYmUgYSBOdW1iZXInKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YXJ0IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0IG11c3QgYmUgPj0gemVybycpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgfVxuXG4gICAgdGhpcy5idXN5ID0gZmFsc2U7XG4gICAgdGhpcy5fcXVldWUgPSBbXTtcblxuICAgIGlmICh0aGlzLmZkID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9vcGVuID0gZnMub3BlbjtcbiAgICAgIHRoaXMuX3F1ZXVlLnB1c2goW3RoaXMuX29wZW4sIHRoaXMucGF0aCwgdGhpcy5mbGFncywgdGhpcy5tb2RlLCB1bmRlZmluZWRdKTtcbiAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ncmFjZWZ1bC1mcy9sZWdhY3ktc3RyZWFtcy5qc1xuLy8gbW9kdWxlIGlkID0gMjY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnKTtcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJyk7XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnKTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIFN0cmVhbSA9IChmdW5jdGlvbiAoKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTsgLy8gaGFjayB0byBmaXggYSBjaXJjdWxhciBkZXBlbmRlbmN5IGlzc3VlIHdoZW4gdXNlZCB3aXRoIGJyb3dzZXJpZnlcbiAgfSBjYXRjaChfKXt9XG59KCkpO1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBTdHJlYW0gfHwgZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG5cbmlmICghcHJvY2Vzcy5icm93c2VyICYmIHByb2Nlc3MuZW52LlJFQURBQkxFX1NUUkVBTSA9PT0gJ2Rpc2FibGUnICYmIFN0cmVhbSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDI3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbTtcbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgU3RyZWFtID0gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTtcbiAgfSBjYXRjaCAoXykge30gZmluYWxseSB7XG4gICAgaWYgKCFTdHJlYW0pIFN0cmVhbSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiAgfVxufSkoKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBidWZmZXJTaGltID0gcmVxdWlyZSgnYnVmZmVyLXNoaW1zJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCcpO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gICAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gICAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAgIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtIHx8IGh3bSA9PT0gMCA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+IH50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gd2hlbiBwaXBpbmcsIHdlIG9ubHkgY2FyZSBhYm91dCAncmVhZGFibGUnIGV2ZW50cyB0aGF0IGhhcHBlblxuICAvLyBhZnRlciByZWFkKClpbmcgYWxsIHRoZSBieXRlcyBhbmQgbm90IGdldHRpbmcgYW55IHB1c2hiYWNrLlxuICB0aGlzLnJhbk91dCA9IGZhbHNlO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgY2h1bmsgPSBidWZmZXJTaGltLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgZmFsc2UpO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgJycsIHRydWUpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250KSB7XG4gIHZhciBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoc3RhdGUuZW5kZWQgJiYgIWFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRFbWl0dGVkICYmIGFkZFRvRnJvbnQpIHtcbiAgICAgIHZhciBfZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIF9lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNraXBBZGQ7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgc2tpcEFkZCA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIGNodW5rLmxlbmd0aCA9PT0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhZGRUb0Zyb250KSBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgIC8vIERvbid0IGFkZCB0byB0aGUgYnVmZmVyIGlmIHdlJ3ZlIGRlY29kZWQgdG8gYW4gZW1wdHkgc3RyaW5nIGNodW5rIGFuZFxuICAgICAgLy8gd2UncmUgbm90IGluIG9iamVjdCBtb2RlXG4gICAgICBpZiAoIXNraXBBZGQpIHtcbiAgICAgICAgLy8gaWYgd2Ugd2FudCB0aGUgZGF0YSBub3csIGp1c3QgZW1pdCBpdC5cbiAgICAgICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgICAgICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXIgPSBudWxsO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIHByb2Nlc3NOZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzc05leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3NOZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwcm9jZXNzTmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uIChldikge1xuICAgIHN0cmVhbS5vbihldiwgc2VsZi5lbWl0LmJpbmQoc2VsZiwgZXYpKTtcbiAgfSk7XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHtcbiAgdmFyIHJldDtcbiAgaWYgKG4gPCBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5nc1xuICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgIGxpc3QuaGVhZC5kYXRhID0gbGlzdC5oZWFkLmRhdGEuc2xpY2Uobik7XG4gIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlclxuICAgIHJldCA9IGhhc1N0cmluZ3MgPyBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSA6IGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGFcbi8vIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkge1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICB2YXIgcmV0ID0gcC5kYXRhO1xuICBuIC09IHJldC5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkge1xuICB2YXIgcmV0ID0gYnVmZmVyU2hpbS5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaCh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAoIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IG5leHRUaWNrO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzLm5leHRUaWNrO1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvY2Vzcy1uZXh0aWNrLWFyZ3MvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKTtcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyO1xudmFyIFNsb3dCdWZmZXIgPSBidWZmZXIuU2xvd0J1ZmZlcjtcbnZhciBNQVhfTEVOID0gYnVmZmVyLmtNYXhMZW5ndGggfHwgMjE0NzQ4MzY0NztcbmV4cG9ydHMuYWxsb2MgPSBmdW5jdGlvbiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIEJ1ZmZlci5hbGxvYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpO1xuICB9XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBub3QgYmUgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemUgbXVzdCBiZSBhIG51bWJlcicpO1xuICB9XG4gIGlmIChzaXplID4gTUFYX0xFTikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaXplIGlzIHRvbyBsYXJnZScpO1xuICB9XG4gIHZhciBlbmMgPSBlbmNvZGluZztcbiAgdmFyIF9maWxsID0gZmlsbDtcbiAgaWYgKF9maWxsID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmMgPSB1bmRlZmluZWQ7XG4gICAgX2ZpbGwgPSAwO1xuICB9XG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHNpemUpO1xuICBpZiAodHlwZW9mIF9maWxsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBmaWxsQnVmID0gbmV3IEJ1ZmZlcihfZmlsbCwgZW5jKTtcbiAgICB2YXIgZmxlbiA9IGZpbGxCdWYubGVuZ3RoO1xuICAgIHZhciBpID0gLTE7XG4gICAgd2hpbGUgKCsraSA8IHNpemUpIHtcbiAgICAgIGJ1ZltpXSA9IGZpbGxCdWZbaSAlIGZsZW5dO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbChfZmlsbCk7XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn1cbmV4cG9ydHMuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiBhbGxvY1Vuc2FmZShzaXplKSB7XG4gIGlmICh0eXBlb2YgQnVmZmVyLmFsbG9jVW5zYWZlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKTtcbiAgfVxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHNpemUgPiBNQVhfTEVOKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NpemUgaXMgdG9vIGxhcmdlJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBCdWZmZXIoc2l6ZSk7XG59XG5leHBvcnRzLmZyb20gPSBmdW5jdGlvbiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuZnJvbSA9PT0gJ2Z1bmN0aW9uJyAmJiAoIWdsb2JhbC5VaW50OEFycmF5IHx8IFVpbnQ4QXJyYXkuZnJvbSAhPT0gQnVmZmVyLmZyb20pKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHZhciBvZmZzZXQgPSBlbmNvZGluZ09yT2Zmc2V0O1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgdmFyIGxlbiA9IGxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGxlbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxlbiA9IHZhbHVlLmJ5dGVMZW5ndGggLSBvZmZzZXQ7XG4gICAgfVxuICAgIGlmIChvZmZzZXQgPj0gdmFsdWUuYnl0ZUxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJyk7XG4gICAgfVxuICAgIGlmIChsZW4gPiB2YWx1ZS5ieXRlTGVuZ3RoIC0gb2Zmc2V0KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW4pKTtcbiAgfVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgIHZhciBvdXQgPSBuZXcgQnVmZmVyKHZhbHVlLmxlbmd0aCk7XG4gICAgdmFsdWUuY29weShvdXQsIDAsIDAsIHZhbHVlLmxlbmd0aCk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIHZhbHVlKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZS50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlLmRhdGEpKSB7XG4gICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZS5kYXRhKTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsICcgKyAnQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKTtcbn1cbmV4cG9ydHMuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gYWxsb2NVbnNhZmVTbG93KHNpemUpIHtcbiAgaWYgKHR5cGVvZiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3coc2l6ZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemUgbXVzdCBiZSBhIG51bWJlcicpO1xuICB9XG4gIGlmIChzaXplID49IE1BWF9MRU4pIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2l6ZSBpcyB0b28gbGFyZ2UnKTtcbiAgfVxuICByZXR1cm4gbmV3IFNsb3dCdWZmZXIoc2l6ZSk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYnVmZmVyLXNoaW1zL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMjc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIChpZ25vcmVkKSAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIHV0aWwgKGlnbm9yZWQpXG4vLyBtb2R1bGUgaWQgPSAyNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBidWZmZXJTaGltID0gcmVxdWlyZSgnYnVmZmVyLXNoaW1zJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJMaXN0O1xuXG5mdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICB0aGlzLmhlYWQgPSBudWxsO1xuICB0aGlzLnRhaWwgPSBudWxsO1xuICB0aGlzLmxlbmd0aCA9IDA7XG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodikge1xuICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgKyt0aGlzLmxlbmd0aDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAodikge1xuICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgKyt0aGlzLmxlbmd0aDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgLS10aGlzLmxlbmd0aDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICB0aGlzLmxlbmd0aCA9IDA7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gKHMpIHtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciBwID0gdGhpcy5oZWFkO1xuICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gIH1yZXR1cm4gcmV0O1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKG4pIHtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gYnVmZmVyU2hpbS5hbGxvYygwKTtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gIHZhciByZXQgPSBidWZmZXJTaGltLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAocCkge1xuICAgIHAuZGF0YS5jb3B5KHJldCwgaSk7XG4gICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgIHAgPSBwLm5leHQ7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0LmpzXG4vLyBtb2R1bGUgaWQgPSAyNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9cmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG52YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbmZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwcm9jZXNzTmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qc1xuLy8gbW9kdWxlIGlkID0gMjc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwcm9jZXNzTmV4dFRpY2s7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbTtcbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgU3RyZWFtID0gcmVxdWlyZSgnc3QnICsgJ3JlYW0nKTtcbiAgfSBjYXRjaCAoXykge30gZmluYWxseSB7XG4gICAgaWYgKCFTdHJlYW0pIFN0cmVhbSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiAgfVxufSkoKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBidWZmZXJTaGltID0gcmVxdWlyZSgnYnVmZmVyLXNoaW1zJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH4gfnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gSWYgd2UgZ2V0IHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBudWxsLCBvciB1bmRlZmluZWQsXG4vLyBhbmQgd2UncmUgbm90IGluIG9iamVjdE1vZGUsIHRoZW4gdGhhdCdzIGFuIGVycm9yLlxuLy8gT3RoZXJ3aXNlIHN0cmVhbSBjaHVua3MgYXJlIGFsbCBjb25zaWRlcmVkIHRvIGJlIG9mIGxlbmd0aD0xLCBhbmQgdGhlXG4vLyB3YXRlcm1hcmtzIGRldGVybWluZSBob3cgbWFueSBvYmplY3RzIHRvIGtlZXAgaW4gdGhlIGJ1ZmZlciwgcmF0aGVyIHRoYW5cbi8vIGhvdyBtYW55IGJ5dGVzIG9yIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcbiAgLy8gQWx3YXlzIHRocm93IGVycm9yIGlmIGEgbnVsbCBpcyB3cml0dGVuXG4gIC8vIGlmIHdlIGFyZSBub3QgaW4gb2JqZWN0IG1vZGUgdGhlbiB0aHJvd1xuICAvLyBpZiBpdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgb3IgdW5kZWZpbmVkLlxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IGJ1ZmZlclNoaW0uZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSBlbmNvZGluZyA9ICdidWZmZXInO1xuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbmV3IFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG4gIGlmIChzeW5jKSBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtlbHNlIGNiKGVyKTtcblxuICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQpIHtcbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHByb2Nlc3NOZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG5cbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgdmFyIGVudHJ5ID0gX3RoaXMuZW50cnk7XG4gICAgX3RoaXMuZW50cnkgPSBudWxsO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICAgIGNiKGVycik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gX3RoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IF90aGlzO1xuICAgIH1cbiAgfTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIGlzQnVmZmVyRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZ1xuICB8fCBmdW5jdGlvbihlbmNvZGluZykge1xuICAgICAgIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgY2FzZSAnaGV4JzogY2FzZSAndXRmOCc6IGNhc2UgJ3V0Zi04JzogY2FzZSAnYXNjaWknOiBjYXNlICdiaW5hcnknOiBjYXNlICdiYXNlNjQnOiBjYXNlICd1Y3MyJzogY2FzZSAndWNzLTInOiBjYXNlICd1dGYxNmxlJzogY2FzZSAndXRmLTE2bGUnOiBjYXNlICdyYXcnOiByZXR1cm4gdHJ1ZTtcbiAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICAgICB9XG4gICAgIH1cblxuXG5mdW5jdGlvbiBhc3NlcnRFbmNvZGluZyhlbmNvZGluZykge1xuICBpZiAoZW5jb2RpbmcgJiYgIWlzQnVmZmVyRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB9XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy4gQ0VTVS04IGlzIGhhbmRsZWQgYXMgcGFydCBvZiB0aGUgVVRGLTggZW5jb2RpbmcuXG4vL1xuLy8gQFRPRE8gSGFuZGxpbmcgYWxsIGVuY29kaW5ncyBpbnNpZGUgYSBzaW5nbGUgb2JqZWN0IG1ha2VzIGl0IHZlcnkgZGlmZmljdWx0XG4vLyB0byByZWFzb24gYWJvdXQgdGhpcyBjb2RlLCBzbyBpdCBzaG91bGQgYmUgc3BsaXQgdXAgaW4gdGhlIGZ1dHVyZS5cbi8vIEBUT0RPIFRoZXJlIHNob3VsZCBiZSBhIHV0Zjgtc3RyaWN0IGVuY29kaW5nIHRoYXQgcmVqZWN0cyBpbnZhbGlkIFVURi04IGNvZGVcbi8vIHBvaW50cyBhcyB1c2VkIGJ5IENFU1UtOC5cbnZhciBTdHJpbmdEZWNvZGVyID0gZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IChlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWy1fXS8sICcnKTtcbiAgYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIC8vIENFU1UtOCByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMy1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgLy8gVVRGLTE2IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAyLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAyO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgLy8gQmFzZS02NCBzdG9yZXMgMyBieXRlcyBpbiA0IGNoYXJzLCBhbmQgcGFkcyB0aGUgcmVtYWluZGVyLlxuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gcGFzc1Rocm91Z2hXcml0ZTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEVub3VnaCBzcGFjZSB0byBzdG9yZSBhbGwgYnl0ZXMgb2YgYSBzaW5nbGUgY2hhcmFjdGVyLiBVVEYtOCBuZWVkcyA0XG4gIC8vIGJ5dGVzLCBidXQgQ0VTVS04IG1heSByZXF1aXJlIHVwIHRvIDYgKDMgYnl0ZXMgcGVyIHN1cnJvZ2F0ZSkuXG4gIHRoaXMuY2hhckJ1ZmZlciA9IG5ldyBCdWZmZXIoNik7XG4gIC8vIE51bWJlciBvZiBieXRlcyByZWNlaXZlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSAwO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhckxlbmd0aCA9IDA7XG59O1xuXG5cbi8vIHdyaXRlIGRlY29kZXMgdGhlIGdpdmVuIGJ1ZmZlciBhbmQgcmV0dXJucyBpdCBhcyBKUyBzdHJpbmcgdGhhdCBpc1xuLy8gZ3VhcmFudGVlZCB0byBub3QgY29udGFpbiBhbnkgcGFydGlhbCBtdWx0aS1ieXRlIGNoYXJhY3RlcnMuIEFueSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIgZm91bmQgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGlzIGJ1ZmZlcmVkIHVwLCBhbmQgd2lsbCBiZVxuLy8gcmV0dXJuZWQgd2hlbiBjYWxsaW5nIHdyaXRlIGFnYWluIHdpdGggdGhlIHJlbWFpbmluZyBieXRlcy5cbi8vXG4vLyBOb3RlOiBDb252ZXJ0aW5nIGEgQnVmZmVyIGNvbnRhaW5pbmcgYW4gb3JwaGFuIHN1cnJvZ2F0ZSB0byBhIFN0cmluZ1xuLy8gY3VycmVudGx5IHdvcmtzLCBidXQgY29udmVydGluZyBhIFN0cmluZyB0byBhIEJ1ZmZlciAodmlhIGBuZXcgQnVmZmVyYCwgb3Jcbi8vIEJ1ZmZlciN3cml0ZSkgd2lsbCByZXBsYWNlIGluY29tcGxldGUgc3Vycm9nYXRlcyB3aXRoIHRoZSB1bmljb2RlXG4vLyByZXBsYWNlbWVudCBjaGFyYWN0ZXIuIFNlZSBodHRwczovL2NvZGVyZXZpZXcuY2hyb21pdW0ub3JnLzEyMTE3MzAwOS8gLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIGNoYXJTdHIgPSAnJztcbiAgLy8gaWYgb3VyIGxhc3Qgd3JpdGUgZW5kZWQgd2l0aCBhbiBpbmNvbXBsZXRlIG11bHRpYnl0ZSBjaGFyYWN0ZXJcbiAgd2hpbGUgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGRldGVybWluZSBob3cgbWFueSByZW1haW5pbmcgYnl0ZXMgdGhpcyBidWZmZXIgaGFzIHRvIG9mZmVyIGZvciB0aGlzIGNoYXJcbiAgICB2YXIgYXZhaWxhYmxlID0gKGJ1ZmZlci5sZW5ndGggPj0gdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQpID9cbiAgICAgICAgdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQgOlxuICAgICAgICBidWZmZXIubGVuZ3RoO1xuXG4gICAgLy8gYWRkIHRoZSBuZXcgYnl0ZXMgdG8gdGhlIGNoYXIgYnVmZmVyXG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCB0aGlzLmNoYXJSZWNlaXZlZCwgMCwgYXZhaWxhYmxlKTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBhdmFpbGFibGU7XG5cbiAgICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQgPCB0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAgIC8vIHN0aWxsIG5vdCBlbm91Z2ggY2hhcnMgaW4gdGhpcyBidWZmZXI/IHdhaXQgZm9yIG1vcmUgLi4uXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGJ5dGVzIGJlbG9uZ2luZyB0byB0aGUgY3VycmVudCBjaGFyYWN0ZXIgZnJvbSB0aGUgYnVmZmVyXG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGF2YWlsYWJsZSwgYnVmZmVyLmxlbmd0aCk7XG5cbiAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciB0aGF0IHdhcyBzcGxpdFxuICAgIGNoYXJTdHIgPSB0aGlzLmNoYXJCdWZmZXIuc2xpY2UoMCwgdGhpcy5jaGFyTGVuZ3RoKS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcblxuICAgIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoY2hhclN0ci5sZW5ndGggLSAxKTtcbiAgICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoICs9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICAgIGNoYXJTdHIgPSAnJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IHRoaXMuY2hhckxlbmd0aCA9IDA7XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBieXRlcyBpbiB0aGlzIGJ1ZmZlciwganVzdCBlbWl0IG91ciBjaGFyXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjaGFyU3RyO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIGRldGVybWluZSBhbmQgc2V0IGNoYXJMZW5ndGggLyBjaGFyUmVjZWl2ZWRcbiAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpO1xuXG4gIHZhciBlbmQgPSBidWZmZXIubGVuZ3RoO1xuICBpZiAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gYnVmZmVyIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlciBieXRlcyB3ZSBnb3RcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCwgZW5kKTtcbiAgICBlbmQgLT0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gIH1cblxuICBjaGFyU3RyICs9IGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCBlbmQpO1xuXG4gIHZhciBlbmQgPSBjaGFyU3RyLmxlbmd0aCAtIDE7XG4gIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChlbmQpO1xuICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgdGhpcy5jaGFyTGVuZ3RoICs9IHNpemU7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJCdWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHNpemUsIDAsIHNpemUpO1xuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgMCwgc2l6ZSk7XG4gICAgcmV0dXJuIGNoYXJTdHIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gIH1cblxuICAvLyBvciBqdXN0IGVtaXQgdGhlIGNoYXJTdHJcbiAgcmV0dXJuIGNoYXJTdHI7XG59O1xuXG4vLyBkZXRlY3RJbmNvbXBsZXRlQ2hhciBkZXRlcm1pbmVzIGlmIHRoZXJlIGlzIGFuIGluY29tcGxldGUgVVRGLTggY2hhcmFjdGVyIGF0XG4vLyB0aGUgZW5kIG9mIHRoZSBnaXZlbiBidWZmZXIuIElmIHNvLCBpdCBzZXRzIHRoaXMuY2hhckxlbmd0aCB0byB0aGUgYnl0ZVxuLy8gbGVuZ3RoIHRoYXQgY2hhcmFjdGVyLCBhbmQgc2V0cyB0aGlzLmNoYXJSZWNlaXZlZCB0byB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4vLyB0aGF0IGFyZSBhdmFpbGFibGUgZm9yIHRoaXMgY2hhcmFjdGVyLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IGJ5dGVzIHdlIGhhdmUgdG8gY2hlY2sgYXQgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlclxuICB2YXIgaSA9IChidWZmZXIubGVuZ3RoID49IDMpID8gMyA6IGJ1ZmZlci5sZW5ndGg7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBvbmUgb2YgdGhlIGxhc3QgaSBieXRlcyBvZiBvdXIgYnVmZmVyIGFubm91bmNlcyBhblxuICAvLyBpbmNvbXBsZXRlIGNoYXIuXG4gIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgdmFyIGMgPSBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIGldO1xuXG4gICAgLy8gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cblxuICAgIC8vIDExMFhYWFhYXG4gICAgaWYgKGkgPT0gMSAmJiBjID4+IDUgPT0gMHgwNikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTBYWFhYXG4gICAgaWYgKGkgPD0gMiAmJiBjID4+IDQgPT0gMHgwRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTEwWFhYXG4gICAgaWYgKGkgPD0gMyAmJiBjID4+IDMgPT0gMHgxRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGk7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpXG4gICAgcmVzID0gdGhpcy53cml0ZShidWZmZXIpO1xuXG4gIGlmICh0aGlzLmNoYXJSZWNlaXZlZCkge1xuICAgIHZhciBjciA9IHRoaXMuY2hhclJlY2VpdmVkO1xuICAgIHZhciBidWYgPSB0aGlzLmNoYXJCdWZmZXI7XG4gICAgdmFyIGVuYyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgcmVzICs9IGJ1Zi5zbGljZSgwLCBjcikudG9TdHJpbmcoZW5jKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBwYXNzVGhyb3VnaFdyaXRlKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAyO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDIgOiAwO1xufVxuXG5mdW5jdGlvbiBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMztcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAzIDogMDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHJpbmdfZGVjb2Rlci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RhdGUoc3RyZWFtKSB7XG4gIHRoaXMuYWZ0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRoaXMud3JpdGVlbmNvZGluZyA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyB3cml0ZWNiIGluIFRyYW5zZm9ybSBjbGFzcycpKTtcblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSBzdHJlYW0ucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUodGhpcyk7XG5cbiAgdmFyIHN0cmVhbSA9IHRoaXM7XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbmNlKCdwcmVmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKHN0cmVhbSwgZXIsIGRhdGEpO1xuICAgIH0pO2Vsc2UgZG9uZShzdHJlYW0pO1xuICB9KTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAod3MubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmICh0cy50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1xuLy8gbW9kdWxlIGlkID0gMjgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qc1xuLy8gbW9kdWxlIGlkID0gMjgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanNcIilcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanNcbi8vIG1vZHVsZSBpZCA9IDI4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX2R1cGxleC5qc1wiKVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanNcbi8vIG1vZHVsZSBpZCA9IDI4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1wiKVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanNcbi8vIG1vZHVsZSBpZCA9IDI4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXCIpXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzXG4vLyBtb2R1bGUgaWQgPSAyODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygzKSkoNTQpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGRlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMgZnJvbSBkbGwtcmVmZXJlbmNlIHZlbmRvcl9hZTk3YmExY2IyNDEyYzFhODY0NFxuLy8gbW9kdWxlIGlkID0gMjg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLy8gY29tcGFyZSBhbmQgaXNCdWZmZXIgdGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iLzY4MGU5ZTVlNDg4ZjIyYWFjMjc1OTlhNTdkYzg0NGE2MzE1OTI4ZGQvaW5kZXguanNcbi8vIG9yaWdpbmFsIG5vdGljZTpcblxuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICB2YXIgeCA9IGEubGVuZ3RoO1xuICB2YXIgeSA9IGIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldO1xuICAgICAgeSA9IGJbaV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKHkgPCB4KSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBpc0J1ZmZlcihiKSB7XG4gIGlmIChnbG9iYWwuQnVmZmVyICYmIHR5cGVvZiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIoYik7XG4gIH1cbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcik7XG59XG5cbi8vIGJhc2VkIG9uIG5vZGUgYXNzZXJ0LCBvcmlnaW5hbCBub3RpY2U6XG5cbi8vIGh0dHA6Ly93aWtpLmNvbW1vbmpzLm9yZy93aWtpL1VuaXRfVGVzdGluZy8xLjBcbi8vXG4vLyBUSElTIElTIE5PVCBURVNURUQgTk9SIExJS0VMWSBUTyBXT1JLIE9VVFNJREUgVjghXG4vL1xuLy8gT3JpZ2luYWxseSBmcm9tIG5hcndoYWwuanMgKGh0dHA6Ly9uYXJ3aGFsanMub3JnKVxuLy8gQ29weXJpZ2h0IChjKSAyMDA5IFRob21hcyBSb2JpbnNvbiA8Mjgwbm9ydGguY29tPlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlICdTb2Z0d2FyZScpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAnQVMgSVMnLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbi8vIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbi8vIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwvJyk7XG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgZnVuY3Rpb25zSGF2ZU5hbWVzID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvbygpIHt9Lm5hbWUgPT09ICdmb28nO1xufSgpKTtcbmZ1bmN0aW9uIHBUb1N0cmluZyAob2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTtcbn1cbmZ1bmN0aW9uIGlzVmlldyhhcnJidWYpIHtcbiAgaWYgKGlzQnVmZmVyKGFycmJ1ZikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBnbG9iYWwuQXJyYXlCdWZmZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KGFycmJ1Zik7XG4gIH1cbiAgaWYgKCFhcnJidWYpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGFycmJ1ZiBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGFycmJ1Zi5idWZmZXIgJiYgYXJyYnVmLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxudmFyIHJlZ2V4ID0gL1xccypmdW5jdGlvblxccysoW15cXChcXHNdKilcXHMqLztcbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9samhhcmIvZnVuY3Rpb24ucHJvdG90eXBlLm5hbWUvYmxvYi9hZGVlZWVjOGJmY2M2MDY4YjE4N2Q3ZDlmYjNkNWJiMWQzYTMwODk5L2ltcGxlbWVudGF0aW9uLmpzXG5mdW5jdGlvbiBnZXROYW1lKGZ1bmMpIHtcbiAgaWYgKCF1dGlsLmlzRnVuY3Rpb24oZnVuYykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcykge1xuICAgIHJldHVybiBmdW5jLm5hbWU7XG4gIH1cbiAgdmFyIHN0ciA9IGZ1bmMudG9TdHJpbmcoKTtcbiAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKHJlZ2V4KTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoWzFdO1xufVxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLmFjdHVhbCA9IG9wdGlvbnMuYWN0dWFsO1xuICB0aGlzLmV4cGVjdGVkID0gb3B0aW9ucy5leHBlY3RlZDtcbiAgdGhpcy5vcGVyYXRvciA9IG9wdGlvbnMub3BlcmF0b3I7XG4gIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gZ2V0TWVzc2FnZSh0aGlzKTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSB0cnVlO1xuICB9XG4gIHZhciBzdGFja1N0YXJ0RnVuY3Rpb24gPSBvcHRpb25zLnN0YWNrU3RhcnRGdW5jdGlvbiB8fCBmYWlsO1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIG5vbiB2OCBicm93c2VycyBzbyB3ZSBjYW4gaGF2ZSBhIHN0YWNrdHJhY2VcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgdmFyIG91dCA9IGVyci5zdGFjaztcblxuICAgICAgLy8gdHJ5IHRvIHN0cmlwIHVzZWxlc3MgZnJhbWVzXG4gICAgICB2YXIgZm5fbmFtZSA9IGdldE5hbWUoc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgICAgIHZhciBpZHggPSBvdXQuaW5kZXhPZignXFxuJyArIGZuX25hbWUpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIC8vIG9uY2Ugd2UgaGF2ZSBsb2NhdGVkIHRoZSBmdW5jdGlvbiBmcmFtZVxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHN0cmlwIG91dCBldmVyeXRoaW5nIGJlZm9yZSBpdCAoYW5kIGl0cyBsaW5lKVxuICAgICAgICB2YXIgbmV4dF9saW5lID0gb3V0LmluZGV4T2YoJ1xcbicsIGlkeCArIDEpO1xuICAgICAgICBvdXQgPSBvdXQuc3Vic3RyaW5nKG5leHRfbGluZSArIDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YWNrID0gb3V0O1xuICAgIH1cbiAgfVxufTtcblxuLy8gYXNzZXJ0LkFzc2VydGlvbkVycm9yIGluc3RhbmNlb2YgRXJyb3JcbnV0aWwuaW5oZXJpdHMoYXNzZXJ0LkFzc2VydGlvbkVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHMsIG4pIHtcbiAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzLmxlbmd0aCA8IG4gPyBzIDogcy5zbGljZSgwLCBuKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuZnVuY3Rpb24gaW5zcGVjdChzb21ldGhpbmcpIHtcbiAgaWYgKGZ1bmN0aW9uc0hhdmVOYW1lcyB8fCAhdXRpbC5pc0Z1bmN0aW9uKHNvbWV0aGluZykpIHtcbiAgICByZXR1cm4gdXRpbC5pbnNwZWN0KHNvbWV0aGluZyk7XG4gIH1cbiAgdmFyIHJhd25hbWUgPSBnZXROYW1lKHNvbWV0aGluZyk7XG4gIHZhciBuYW1lID0gcmF3bmFtZSA/ICc6ICcgKyByYXduYW1lIDogJyc7XG4gIHJldHVybiAnW0Z1bmN0aW9uJyArICBuYW1lICsgJ10nO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZShzZWxmKSB7XG4gIHJldHVybiB0cnVuY2F0ZShpbnNwZWN0KHNlbGYuYWN0dWFsKSwgMTI4KSArICcgJyArXG4gICAgICAgICBzZWxmLm9wZXJhdG9yICsgJyAnICtcbiAgICAgICAgIHRydW5jYXRlKGluc3BlY3Qoc2VsZi5leHBlY3RlZCksIDEyOCk7XG59XG5cbi8vIEF0IHByZXNlbnQgb25seSB0aGUgdGhyZWUga2V5cyBtZW50aW9uZWQgYWJvdmUgYXJlIHVzZWQgYW5kXG4vLyB1bmRlcnN0b29kIGJ5IHRoZSBzcGVjLiBJbXBsZW1lbnRhdGlvbnMgb3Igc3ViIG1vZHVsZXMgY2FuIHBhc3Ncbi8vIG90aGVyIGtleXMgdG8gdGhlIEFzc2VydGlvbkVycm9yJ3MgY29uc3RydWN0b3IgLSB0aGV5IHdpbGwgYmVcbi8vIGlnbm9yZWQuXG5cbi8vIDMuIEFsbCBvZiB0aGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBtdXN0IHRocm93IGFuIEFzc2VydGlvbkVycm9yXG4vLyB3aGVuIGEgY29ycmVzcG9uZGluZyBjb25kaXRpb24gaXMgbm90IG1ldCwgd2l0aCBhIG1lc3NhZ2UgdGhhdFxuLy8gbWF5IGJlIHVuZGVmaW5lZCBpZiBub3QgcHJvdmlkZWQuICBBbGwgYXNzZXJ0aW9uIG1ldGhvZHMgcHJvdmlkZVxuLy8gYm90aCB0aGUgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgdG8gdGhlIGFzc2VydGlvbiBlcnJvciBmb3Jcbi8vIGRpc3BsYXkgcHVycG9zZXMuXG5cbmZ1bmN0aW9uIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgb3BlcmF0b3IsIHN0YWNrU3RhcnRGdW5jdGlvbikge1xuICB0aHJvdyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHtcbiAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgIGFjdHVhbDogYWN0dWFsLFxuICAgIGV4cGVjdGVkOiBleHBlY3RlZCxcbiAgICBvcGVyYXRvcjogb3BlcmF0b3IsXG4gICAgc3RhY2tTdGFydEZ1bmN0aW9uOiBzdGFja1N0YXJ0RnVuY3Rpb25cbiAgfSk7XG59XG5cbi8vIEVYVEVOU0lPTiEgYWxsb3dzIGZvciB3ZWxsIGJlaGF2ZWQgZXJyb3JzIGRlZmluZWQgZWxzZXdoZXJlLlxuYXNzZXJ0LmZhaWwgPSBmYWlsO1xuXG4vLyA0LiBQdXJlIGFzc2VydGlvbiB0ZXN0cyB3aGV0aGVyIGEgdmFsdWUgaXMgdHJ1dGh5LCBhcyBkZXRlcm1pbmVkXG4vLyBieSAhIWd1YXJkLlxuLy8gYXNzZXJ0Lm9rKGd1YXJkLCBtZXNzYWdlX29wdCk7XG4vLyBUaGlzIHN0YXRlbWVudCBpcyBlcXVpdmFsZW50IHRvIGFzc2VydC5lcXVhbCh0cnVlLCAhIWd1YXJkLFxuLy8gbWVzc2FnZV9vcHQpOy4gVG8gdGVzdCBzdHJpY3RseSBmb3IgdGhlIHZhbHVlIHRydWUsIHVzZVxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKHRydWUsIGd1YXJkLCBtZXNzYWdlX29wdCk7LlxuXG5mdW5jdGlvbiBvayh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIXZhbHVlKSBmYWlsKHZhbHVlLCB0cnVlLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQub2spO1xufVxuYXNzZXJ0Lm9rID0gb2s7XG5cbi8vIDUuIFRoZSBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc2hhbGxvdywgY29lcmNpdmUgZXF1YWxpdHkgd2l0aFxuLy8gPT0uXG4vLyBhc3NlcnQuZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT0gZXhwZWN0ZWQpIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09JywgYXNzZXJ0LmVxdWFsKTtcbn07XG5cbi8vIDYuIFRoZSBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciB3aGV0aGVyIHR3byBvYmplY3RzIGFyZSBub3QgZXF1YWxcbi8vIHdpdGggIT0gYXNzZXJ0Lm5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdEVxdWFsID0gZnVuY3Rpb24gbm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT0nLCBhc3NlcnQubm90RXF1YWwpO1xuICB9XG59O1xuXG4vLyA3LiBUaGUgZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGEgZGVlcCBlcXVhbGl0eSByZWxhdGlvbi5cbi8vIGFzc2VydC5kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuZGVlcEVxdWFsID0gZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZhbHNlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5hc3NlcnQuZGVlcFN0cmljdEVxdWFsID0gZnVuY3Rpb24gZGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRydWUpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcFN0cmljdEVxdWFsJywgYXNzZXJ0LmRlZXBTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0LCBtZW1vcykge1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihhY3R1YWwpICYmIGlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBjb21wYXJlKGFjdHVhbCwgZXhwZWN0ZWQpID09PSAwO1xuXG4gIC8vIDcuMi4gSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgRGF0ZSBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgRGF0ZSBvYmplY3QgdGhhdCByZWZlcnMgdG8gdGhlIHNhbWUgdGltZS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzRGF0ZShhY3R1YWwpICYmIHV0aWwuaXNEYXRlKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIHRoZSBhY3R1YWwgdmFsdWUgaXNcbiAgLy8gZXF1aXZhbGVudCBpZiBpdCBpcyBhbHNvIGEgUmVnRXhwIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmRcbiAgLy8gcHJvcGVydGllcyAoYGdsb2JhbGAsIGBtdWx0aWxpbmVgLCBgbGFzdEluZGV4YCwgYGlnbm9yZUNhc2VgKS5cbiAgfSBlbHNlIGlmICh1dGlsLmlzUmVnRXhwKGFjdHVhbCkgJiYgdXRpbC5pc1JlZ0V4cChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLnNvdXJjZSA9PT0gZXhwZWN0ZWQuc291cmNlICYmXG4gICAgICAgICAgIGFjdHVhbC5nbG9iYWwgPT09IGV4cGVjdGVkLmdsb2JhbCAmJlxuICAgICAgICAgICBhY3R1YWwubXVsdGlsaW5lID09PSBleHBlY3RlZC5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgYWN0dWFsLmxhc3RJbmRleCA9PT0gZXhwZWN0ZWQubGFzdEluZGV4ICYmXG4gICAgICAgICAgIGFjdHVhbC5pZ25vcmVDYXNlID09PSBleHBlY3RlZC5pZ25vcmVDYXNlO1xuXG4gIC8vIDcuNC4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICgoYWN0dWFsID09PSBudWxsIHx8IHR5cGVvZiBhY3R1YWwgIT09ICdvYmplY3QnKSAmJlxuICAgICAgICAgICAgIChleHBlY3RlZCA9PT0gbnVsbCB8fCB0eXBlb2YgZXhwZWN0ZWQgIT09ICdvYmplY3QnKSkge1xuICAgIHJldHVybiBzdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIElmIGJvdGggdmFsdWVzIGFyZSBpbnN0YW5jZXMgb2YgdHlwZWQgYXJyYXlzLCB3cmFwIHRoZWlyIHVuZGVybHlpbmdcbiAgLy8gQXJyYXlCdWZmZXJzIGluIGEgQnVmZmVyIGVhY2ggdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2VcbiAgLy8gVGhpcyBvcHRpbWl6YXRpb24gcmVxdWlyZXMgdGhlIGFycmF5cyB0byBoYXZlIHRoZSBzYW1lIHR5cGUgYXMgY2hlY2tlZCBieVxuICAvLyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nIChha2EgcFRvU3RyaW5nKS4gTmV2ZXIgcGVyZm9ybSBiaW5hcnlcbiAgLy8gY29tcGFyaXNvbnMgZm9yIEZsb2F0KkFycmF5cywgdGhvdWdoLCBzaW5jZSBlLmcuICswID09PSAtMCBidXQgdGhlaXJcbiAgLy8gYml0IHBhdHRlcm5zIGFyZSBub3QgaWRlbnRpY2FsLlxuICB9IGVsc2UgaWYgKGlzVmlldyhhY3R1YWwpICYmIGlzVmlldyhleHBlY3RlZCkgJiZcbiAgICAgICAgICAgICBwVG9TdHJpbmcoYWN0dWFsKSA9PT0gcFRvU3RyaW5nKGV4cGVjdGVkKSAmJlxuICAgICAgICAgICAgICEoYWN0dWFsIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8XG4gICAgICAgICAgICAgICBhY3R1YWwgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUobmV3IFVpbnQ4QXJyYXkoYWN0dWFsLmJ1ZmZlciksXG4gICAgICAgICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZXhwZWN0ZWQuYnVmZmVyKSkgPT09IDA7XG5cbiAgLy8gNy41IEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihhY3R1YWwpICE9PSBpc0J1ZmZlcihleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgbWVtb3MgPSBtZW1vcyB8fCB7YWN0dWFsOiBbXSwgZXhwZWN0ZWQ6IFtdfTtcblxuICAgIHZhciBhY3R1YWxJbmRleCA9IG1lbW9zLmFjdHVhbC5pbmRleE9mKGFjdHVhbCk7XG4gICAgaWYgKGFjdHVhbEluZGV4ICE9PSAtMSkge1xuICAgICAgaWYgKGFjdHVhbEluZGV4ID09PSBtZW1vcy5leHBlY3RlZC5pbmRleE9mKGV4cGVjdGVkKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZW1vcy5hY3R1YWwucHVzaChhY3R1YWwpO1xuICAgIG1lbW9zLmV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpO1xuXG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdCwgbWVtb3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIsIHN0cmljdCwgYWN0dWFsVmlzaXRlZE9iamVjdHMpIHtcbiAgaWYgKGEgPT09IG51bGwgfHwgYSA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IG51bGwgfHwgYiA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy8gaWYgb25lIGlzIGEgcHJpbWl0aXZlLCB0aGUgb3RoZXIgbXVzdCBiZSBzYW1lXG4gIGlmICh1dGlsLmlzUHJpbWl0aXZlKGEpIHx8IHV0aWwuaXNQcmltaXRpdmUoYikpXG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIGlmIChzdHJpY3QgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGEpICE9PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICB2YXIgYUlzQXJncyA9IGlzQXJndW1lbnRzKGEpO1xuICB2YXIgYklzQXJncyA9IGlzQXJndW1lbnRzKGIpO1xuICBpZiAoKGFJc0FyZ3MgJiYgIWJJc0FyZ3MpIHx8ICghYUlzQXJncyAmJiBiSXNBcmdzKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChhSXNBcmdzKSB7XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gX2RlZXBFcXVhbChhLCBiLCBzdHJpY3QpO1xuICB9XG4gIHZhciBrYSA9IG9iamVjdEtleXMoYSk7XG4gIHZhciBrYiA9IG9iamVjdEtleXMoYik7XG4gIHZhciBrZXksIGk7XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT09IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9PSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghX2RlZXBFcXVhbChhW2tleV0sIGJba2V5XSwgc3RyaWN0LCBhY3R1YWxWaXNpdGVkT2JqZWN0cykpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmYWxzZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwRXF1YWwnLCBhc3NlcnQubm90RGVlcEVxdWFsKTtcbiAgfVxufTtcblxuYXNzZXJ0Lm5vdERlZXBTdHJpY3RFcXVhbCA9IG5vdERlZXBTdHJpY3RFcXVhbDtcbmZ1bmN0aW9uIG5vdERlZXBTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHRydWUpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnbm90RGVlcFN0cmljdEVxdWFsJywgbm90RGVlcFN0cmljdEVxdWFsKTtcbiAgfVxufVxuXG5cbi8vIDkuIFRoZSBzdHJpY3QgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHN0cmljdCBlcXVhbGl0eSwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQuc3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBzdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgIT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT09JywgYXNzZXJ0LnN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gMTAuIFRoZSBzdHJpY3Qgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igc3RyaWN0IGluZXF1YWxpdHksIGFzXG4vLyBkZXRlcm1pbmVkIGJ5ICE9PS4gIGFzc2VydC5ub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RTdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIG5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPT0nLCBhc3NlcnQubm90U3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIGlmICghYWN0dWFsIHx8ICFleHBlY3RlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXhwZWN0ZWQpID09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgcmV0dXJuIGV4cGVjdGVkLnRlc3QoYWN0dWFsKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJZ25vcmUuICBUaGUgaW5zdGFuY2VvZiBjaGVjayBkb2Vzbid0IHdvcmsgZm9yIGFycm93IGZ1bmN0aW9ucy5cbiAgfVxuXG4gIGlmIChFcnJvci5pc1Byb3RvdHlwZU9mKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlO1xufVxuXG5mdW5jdGlvbiBfdHJ5QmxvY2soYmxvY2spIHtcbiAgdmFyIGVycm9yO1xuICB0cnkge1xuICAgIGJsb2NrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvciA9IGU7XG4gIH1cbiAgcmV0dXJuIGVycm9yO1xufVxuXG5mdW5jdGlvbiBfdGhyb3dzKHNob3VsZFRocm93LCBibG9jaywgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGFjdHVhbDtcblxuICBpZiAodHlwZW9mIGJsb2NrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJibG9ja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICBtZXNzYWdlID0gZXhwZWN0ZWQ7XG4gICAgZXhwZWN0ZWQgPSBudWxsO1xuICB9XG5cbiAgYWN0dWFsID0gX3RyeUJsb2NrKGJsb2NrKTtcblxuICBtZXNzYWdlID0gKGV4cGVjdGVkICYmIGV4cGVjdGVkLm5hbWUgPyAnICgnICsgZXhwZWN0ZWQubmFtZSArICcpLicgOiAnLicpICtcbiAgICAgICAgICAgIChtZXNzYWdlID8gJyAnICsgbWVzc2FnZSA6ICcuJyk7XG5cbiAgaWYgKHNob3VsZFRocm93ICYmICFhY3R1YWwpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdNaXNzaW5nIGV4cGVjdGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIHZhciB1c2VyUHJvdmlkZWRNZXNzYWdlID0gdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnO1xuICB2YXIgaXNVbndhbnRlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiB1dGlsLmlzRXJyb3IoYWN0dWFsKTtcbiAgdmFyIGlzVW5leHBlY3RlZEV4Y2VwdGlvbiA9ICFzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgIWV4cGVjdGVkO1xuXG4gIGlmICgoaXNVbndhbnRlZEV4Y2VwdGlvbiAmJlxuICAgICAgdXNlclByb3ZpZGVkTWVzc2FnZSAmJlxuICAgICAgZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8XG4gICAgICBpc1VuZXhwZWN0ZWRFeGNlcHRpb24pIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsICdHb3QgdW53YW50ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgaWYgKChzaG91bGRUaHJvdyAmJiBhY3R1YWwgJiYgZXhwZWN0ZWQgJiZcbiAgICAgICFleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHwgKCFzaG91bGRUaHJvdyAmJiBhY3R1YWwpKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9XG59XG5cbi8vIDExLiBFeHBlY3RlZCB0byB0aHJvdyBhbiBlcnJvcjpcbi8vIGFzc2VydC50aHJvd3MoYmxvY2ssIEVycm9yX29wdCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQudGhyb3dzID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3ModHJ1ZSwgYmxvY2ssIGVycm9yLCBtZXNzYWdlKTtcbn07XG5cbi8vIEVYVEVOU0lPTiEgVGhpcyBpcyBhbm5veWluZyB0byB3cml0ZSBvdXRzaWRlIHRoaXMgbW9kdWxlLlxuYXNzZXJ0LmRvZXNOb3RUaHJvdyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzKGZhbHNlLCBibG9jaywgZXJyb3IsIG1lc3NhZ2UpO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbihlcnIpIHsgaWYgKGVycikgdGhyb3cgZXJyOyB9O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXNPd24uY2FsbChvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9hc3NlcnQvYXNzZXJ0LmpzXG4vLyBtb2R1bGUgaWQgPSAyODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBtaW5pbWF0Y2hcbm1pbmltYXRjaC5NaW5pbWF0Y2ggPSBNaW5pbWF0Y2hcblxudmFyIHBhdGggPSB7IHNlcDogJy8nIH1cbnRyeSB7XG4gIHBhdGggPSByZXF1aXJlKCdwYXRoJylcbn0gY2F0Y2ggKGVyKSB7fVxuXG52YXIgR0xPQlNUQVIgPSBtaW5pbWF0Y2guR0xPQlNUQVIgPSBNaW5pbWF0Y2guR0xPQlNUQVIgPSB7fVxudmFyIGV4cGFuZCA9IHJlcXVpcmUoJ2JyYWNlLWV4cGFuc2lvbicpXG5cbnZhciBwbFR5cGVzID0ge1xuICAnISc6IHsgb3BlbjogJyg/Oig/ISg/OicsIGNsb3NlOiAnKSlbXi9dKj8pJ30sXG4gICc/JzogeyBvcGVuOiAnKD86JywgY2xvc2U6ICcpPycgfSxcbiAgJysnOiB7IG9wZW46ICcoPzonLCBjbG9zZTogJykrJyB9LFxuICAnKic6IHsgb3BlbjogJyg/OicsIGNsb3NlOiAnKSonIH0sXG4gICdAJzogeyBvcGVuOiAnKD86JywgY2xvc2U6ICcpJyB9XG59XG5cbi8vIGFueSBzaW5nbGUgdGhpbmcgb3RoZXIgdGhhbiAvXG4vLyBkb24ndCBuZWVkIHRvIGVzY2FwZSAvIHdoZW4gdXNpbmcgbmV3IFJlZ0V4cCgpXG52YXIgcW1hcmsgPSAnW14vXSdcblxuLy8gKiA9PiBhbnkgbnVtYmVyIG9mIGNoYXJhY3RlcnNcbnZhciBzdGFyID0gcW1hcmsgKyAnKj8nXG5cbi8vICoqIHdoZW4gZG90cyBhcmUgYWxsb3dlZC4gIEFueXRoaW5nIGdvZXMsIGV4Y2VwdCAuLiBhbmQgLlxuLy8gbm90ICheIG9yIC8gZm9sbG93ZWQgYnkgb25lIG9yIHR3byBkb3RzIGZvbGxvd2VkIGJ5ICQgb3IgLyksXG4vLyBmb2xsb3dlZCBieSBhbnl0aGluZywgYW55IG51bWJlciBvZiB0aW1lcy5cbnZhciB0d29TdGFyRG90ID0gJyg/Oig/ISg/OlxcXFxcXC98XikoPzpcXFxcLnsxLDJ9KSgkfFxcXFxcXC8pKS4pKj8nXG5cbi8vIG5vdCBhIF4gb3IgLyBmb2xsb3dlZCBieSBhIGRvdCxcbi8vIGZvbGxvd2VkIGJ5IGFueXRoaW5nLCBhbnkgbnVtYmVyIG9mIHRpbWVzLlxudmFyIHR3b1N0YXJOb0RvdCA9ICcoPzooPyEoPzpcXFxcXFwvfF4pXFxcXC4pLikqPydcblxuLy8gY2hhcmFjdGVycyB0aGF0IG5lZWQgdG8gYmUgZXNjYXBlZCBpbiBSZWdFeHAuXG52YXIgcmVTcGVjaWFscyA9IGNoYXJTZXQoJygpLip7fSs/W11eJFxcXFwhJylcblxuLy8gXCJhYmNcIiAtPiB7IGE6dHJ1ZSwgYjp0cnVlLCBjOnRydWUgfVxuZnVuY3Rpb24gY2hhclNldCAocykge1xuICByZXR1cm4gcy5zcGxpdCgnJykucmVkdWNlKGZ1bmN0aW9uIChzZXQsIGMpIHtcbiAgICBzZXRbY10gPSB0cnVlXG4gICAgcmV0dXJuIHNldFxuICB9LCB7fSlcbn1cblxuLy8gbm9ybWFsaXplcyBzbGFzaGVzLlxudmFyIHNsYXNoU3BsaXQgPSAvXFwvKy9cblxubWluaW1hdGNoLmZpbHRlciA9IGZpbHRlclxuZnVuY3Rpb24gZmlsdGVyIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHJldHVybiBmdW5jdGlvbiAocCwgaSwgbGlzdCkge1xuICAgIHJldHVybiBtaW5pbWF0Y2gocCwgcGF0dGVybiwgb3B0aW9ucylcbiAgfVxufVxuXG5mdW5jdGlvbiBleHQgKGEsIGIpIHtcbiAgYSA9IGEgfHwge31cbiAgYiA9IGIgfHwge31cbiAgdmFyIHQgPSB7fVxuICBPYmplY3Qua2V5cyhiKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgdFtrXSA9IGJba11cbiAgfSlcbiAgT2JqZWN0LmtleXMoYSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIHRba10gPSBhW2tdXG4gIH0pXG4gIHJldHVybiB0XG59XG5cbm1pbmltYXRjaC5kZWZhdWx0cyA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgaWYgKCFkZWYgfHwgIU9iamVjdC5rZXlzKGRlZikubGVuZ3RoKSByZXR1cm4gbWluaW1hdGNoXG5cbiAgdmFyIG9yaWcgPSBtaW5pbWF0Y2hcblxuICB2YXIgbSA9IGZ1bmN0aW9uIG1pbmltYXRjaCAocCwgcGF0dGVybiwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcmlnLm1pbmltYXRjaChwLCBwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSlcbiAgfVxuXG4gIG0uTWluaW1hdGNoID0gZnVuY3Rpb24gTWluaW1hdGNoIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBvcmlnLk1pbmltYXRjaChwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSlcbiAgfVxuXG4gIHJldHVybiBtXG59XG5cbk1pbmltYXRjaC5kZWZhdWx0cyA9IGZ1bmN0aW9uIChkZWYpIHtcbiAgaWYgKCFkZWYgfHwgIU9iamVjdC5rZXlzKGRlZikubGVuZ3RoKSByZXR1cm4gTWluaW1hdGNoXG4gIHJldHVybiBtaW5pbWF0Y2guZGVmYXVsdHMoZGVmKS5NaW5pbWF0Y2hcbn1cblxuZnVuY3Rpb24gbWluaW1hdGNoIChwLCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdnbG9iIHBhdHRlcm4gc3RyaW5nIHJlcXVpcmVkJylcbiAgfVxuXG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9XG5cbiAgLy8gc2hvcnRjdXQ6IGNvbW1lbnRzIG1hdGNoIG5vdGhpbmcuXG4gIGlmICghb3B0aW9ucy5ub2NvbW1lbnQgJiYgcGF0dGVybi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gXCJcIiBvbmx5IG1hdGNoZXMgXCJcIlxuICBpZiAocGF0dGVybi50cmltKCkgPT09ICcnKSByZXR1cm4gcCA9PT0gJydcblxuICByZXR1cm4gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKS5tYXRjaChwKVxufVxuXG5mdW5jdGlvbiBNaW5pbWF0Y2ggKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1pbmltYXRjaCkpIHtcbiAgICByZXR1cm4gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2dsb2IgcGF0dGVybiBzdHJpbmcgcmVxdWlyZWQnKVxuICB9XG5cbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge31cbiAgcGF0dGVybiA9IHBhdHRlcm4udHJpbSgpXG5cbiAgLy8gd2luZG93cyBzdXBwb3J0OiBuZWVkIHRvIHVzZSAvLCBub3QgXFxcbiAgaWYgKHBhdGguc2VwICE9PSAnLycpIHtcbiAgICBwYXR0ZXJuID0gcGF0dGVybi5zcGxpdChwYXRoLnNlcCkuam9pbignLycpXG4gIH1cblxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gIHRoaXMuc2V0ID0gW11cbiAgdGhpcy5wYXR0ZXJuID0gcGF0dGVyblxuICB0aGlzLnJlZ2V4cCA9IG51bGxcbiAgdGhpcy5uZWdhdGUgPSBmYWxzZVxuICB0aGlzLmNvbW1lbnQgPSBmYWxzZVxuICB0aGlzLmVtcHR5ID0gZmFsc2VcblxuICAvLyBtYWtlIHRoZSBzZXQgb2YgcmVnZXhwcyBldGMuXG4gIHRoaXMubWFrZSgpXG59XG5cbk1pbmltYXRjaC5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiAoKSB7fVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLm1ha2UgPSBtYWtlXG5mdW5jdGlvbiBtYWtlICgpIHtcbiAgLy8gZG9uJ3QgZG8gaXQgbW9yZSB0aGFuIG9uY2UuXG4gIGlmICh0aGlzLl9tYWRlKSByZXR1cm5cblxuICB2YXIgcGF0dGVybiA9IHRoaXMucGF0dGVyblxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gIC8vIGVtcHR5IHBhdHRlcm5zIGFuZCBjb21tZW50cyBtYXRjaCBub3RoaW5nLlxuICBpZiAoIW9wdGlvbnMubm9jb21tZW50ICYmIHBhdHRlcm4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICB0aGlzLmNvbW1lbnQgPSB0cnVlXG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFwYXR0ZXJuKSB7XG4gICAgdGhpcy5lbXB0eSA9IHRydWVcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIHN0ZXAgMTogZmlndXJlIG91dCBuZWdhdGlvbiwgZXRjLlxuICB0aGlzLnBhcnNlTmVnYXRlKClcblxuICAvLyBzdGVwIDI6IGV4cGFuZCBicmFjZXNcbiAgdmFyIHNldCA9IHRoaXMuZ2xvYlNldCA9IHRoaXMuYnJhY2VFeHBhbmQoKVxuXG4gIGlmIChvcHRpb25zLmRlYnVnKSB0aGlzLmRlYnVnID0gY29uc29sZS5lcnJvclxuXG4gIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCBzZXQpXG5cbiAgLy8gc3RlcCAzOiBub3cgd2UgaGF2ZSBhIHNldCwgc28gdHVybiBlYWNoIG9uZSBpbnRvIGEgc2VyaWVzIG9mIHBhdGgtcG9ydGlvblxuICAvLyBtYXRjaGluZyBwYXR0ZXJucy5cbiAgLy8gVGhlc2Ugd2lsbCBiZSByZWdleHBzLCBleGNlcHQgaW4gdGhlIGNhc2Ugb2YgXCIqKlwiLCB3aGljaCBpc1xuICAvLyBzZXQgdG8gdGhlIEdMT0JTVEFSIG9iamVjdCBmb3IgZ2xvYnN0YXIgYmVoYXZpb3IsXG4gIC8vIGFuZCB3aWxsIG5vdCBjb250YWluIGFueSAvIGNoYXJhY3RlcnNcbiAgc2V0ID0gdGhpcy5nbG9iUGFydHMgPSBzZXQubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHMuc3BsaXQoc2xhc2hTcGxpdClcbiAgfSlcblxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgc2V0KVxuXG4gIC8vIGdsb2IgLS0+IHJlZ2V4cHNcbiAgc2V0ID0gc2V0Lm1hcChmdW5jdGlvbiAocywgc2ksIHNldCkge1xuICAgIHJldHVybiBzLm1hcCh0aGlzLnBhcnNlLCB0aGlzKVxuICB9LCB0aGlzKVxuXG4gIHRoaXMuZGVidWcodGhpcy5wYXR0ZXJuLCBzZXQpXG5cbiAgLy8gZmlsdGVyIG91dCBldmVyeXRoaW5nIHRoYXQgZGlkbid0IGNvbXBpbGUgcHJvcGVybHkuXG4gIHNldCA9IHNldC5maWx0ZXIoZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gcy5pbmRleE9mKGZhbHNlKSA9PT0gLTFcbiAgfSlcblxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgc2V0KVxuXG4gIHRoaXMuc2V0ID0gc2V0XG59XG5cbk1pbmltYXRjaC5wcm90b3R5cGUucGFyc2VOZWdhdGUgPSBwYXJzZU5lZ2F0ZVxuZnVuY3Rpb24gcGFyc2VOZWdhdGUgKCkge1xuICB2YXIgcGF0dGVybiA9IHRoaXMucGF0dGVyblxuICB2YXIgbmVnYXRlID0gZmFsc2VcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcbiAgdmFyIG5lZ2F0ZU9mZnNldCA9IDBcblxuICBpZiAob3B0aW9ucy5ub25lZ2F0ZSkgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXR0ZXJuLmxlbmd0aFxuICAgIDsgaSA8IGwgJiYgcGF0dGVybi5jaGFyQXQoaSkgPT09ICchJ1xuICAgIDsgaSsrKSB7XG4gICAgbmVnYXRlID0gIW5lZ2F0ZVxuICAgIG5lZ2F0ZU9mZnNldCsrXG4gIH1cblxuICBpZiAobmVnYXRlT2Zmc2V0KSB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuLnN1YnN0cihuZWdhdGVPZmZzZXQpXG4gIHRoaXMubmVnYXRlID0gbmVnYXRlXG59XG5cbi8vIEJyYWNlIGV4cGFuc2lvbjpcbi8vIGF7YixjfWQgLT4gYWJkIGFjZFxuLy8gYXtiLH1jIC0+IGFiYyBhY1xuLy8gYXswLi4zfWQgLT4gYTBkIGExZCBhMmQgYTNkXG4vLyBhe2IsY3tkLGV9Zn1nIC0+IGFiZyBhY2RmZyBhY2VmZ1xuLy8gYXtiLGN9ZHtlLGZ9ZyAtPiBhYmRlZyBhY2RlZyBhYmRlZyBhYmRmZ1xuLy9cbi8vIEludmFsaWQgc2V0cyBhcmUgbm90IGV4cGFuZGVkLlxuLy8gYXsyLi59YiAtPiBhezIuLn1iXG4vLyBhe2J9YyAtPiBhe2J9Y1xubWluaW1hdGNoLmJyYWNlRXhwYW5kID0gZnVuY3Rpb24gKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGJyYWNlRXhwYW5kKHBhdHRlcm4sIG9wdGlvbnMpXG59XG5cbk1pbmltYXRjaC5wcm90b3R5cGUuYnJhY2VFeHBhbmQgPSBicmFjZUV4cGFuZFxuXG5mdW5jdGlvbiBicmFjZUV4cGFuZCAocGF0dGVybiwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIE1pbmltYXRjaCkge1xuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG4gIH1cblxuICBwYXR0ZXJuID0gdHlwZW9mIHBhdHRlcm4gPT09ICd1bmRlZmluZWQnXG4gICAgPyB0aGlzLnBhdHRlcm4gOiBwYXR0ZXJuXG5cbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VuZGVmaW5lZCBwYXR0ZXJuJylcbiAgfVxuXG4gIGlmIChvcHRpb25zLm5vYnJhY2UgfHxcbiAgICAhcGF0dGVybi5tYXRjaCgvXFx7LipcXH0vKSkge1xuICAgIC8vIHNob3J0Y3V0LiBubyBuZWVkIHRvIGV4cGFuZC5cbiAgICByZXR1cm4gW3BhdHRlcm5dXG4gIH1cblxuICByZXR1cm4gZXhwYW5kKHBhdHRlcm4pXG59XG5cbi8vIHBhcnNlIGEgY29tcG9uZW50IG9mIHRoZSBleHBhbmRlZCBzZXQuXG4vLyBBdCB0aGlzIHBvaW50LCBubyBwYXR0ZXJuIG1heSBjb250YWluIFwiL1wiIGluIGl0XG4vLyBzbyB3ZSdyZSBnb2luZyB0byByZXR1cm4gYSAyZCBhcnJheSwgd2hlcmUgZWFjaCBlbnRyeSBpcyB0aGUgZnVsbFxuLy8gcGF0dGVybiwgc3BsaXQgb24gJy8nLCBhbmQgdGhlbiB0dXJuZWQgaW50byBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbi8vIEEgcmVnZXhwIGlzIG1hZGUgYXQgdGhlIGVuZCB3aGljaCBqb2lucyBlYWNoIGFycmF5IHdpdGggYW5cbi8vIGVzY2FwZWQgLywgYW5kIGFub3RoZXIgZnVsbCBvbmUgd2hpY2ggam9pbnMgZWFjaCByZWdleHAgd2l0aCB8LlxuLy9cbi8vIEZvbGxvd2luZyB0aGUgbGVhZCBvZiBCYXNoIDQuMSwgbm90ZSB0aGF0IFwiKipcIiBvbmx5IGhhcyBzcGVjaWFsIG1lYW5pbmdcbi8vIHdoZW4gaXQgaXMgdGhlICpvbmx5KiB0aGluZyBpbiBhIHBhdGggcG9ydGlvbi4gIE90aGVyd2lzZSwgYW55IHNlcmllc1xuLy8gb2YgKiBpcyBlcXVpdmFsZW50IHRvIGEgc2luZ2xlICouICBHbG9ic3RhciBiZWhhdmlvciBpcyBlbmFibGVkIGJ5XG4vLyBkZWZhdWx0LCBhbmQgY2FuIGJlIGRpc2FibGVkIGJ5IHNldHRpbmcgb3B0aW9ucy5ub2dsb2JzdGFyLlxuTWluaW1hdGNoLnByb3RvdHlwZS5wYXJzZSA9IHBhcnNlXG52YXIgU1VCUEFSU0UgPSB7fVxuZnVuY3Rpb24gcGFyc2UgKHBhdHRlcm4sIGlzU3ViKSB7XG4gIGlmIChwYXR0ZXJuLmxlbmd0aCA+IDEwMjQgKiA2NCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhdHRlcm4gaXMgdG9vIGxvbmcnKVxuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcblxuICAvLyBzaG9ydGN1dHNcbiAgaWYgKCFvcHRpb25zLm5vZ2xvYnN0YXIgJiYgcGF0dGVybiA9PT0gJyoqJykgcmV0dXJuIEdMT0JTVEFSXG4gIGlmIChwYXR0ZXJuID09PSAnJykgcmV0dXJuICcnXG5cbiAgdmFyIHJlID0gJydcbiAgdmFyIGhhc01hZ2ljID0gISFvcHRpb25zLm5vY2FzZVxuICB2YXIgZXNjYXBpbmcgPSBmYWxzZVxuICAvLyA/ID0+IG9uZSBzaW5nbGUgY2hhcmFjdGVyXG4gIHZhciBwYXR0ZXJuTGlzdFN0YWNrID0gW11cbiAgdmFyIG5lZ2F0aXZlTGlzdHMgPSBbXVxuICB2YXIgc3RhdGVDaGFyXG4gIHZhciBpbkNsYXNzID0gZmFsc2VcbiAgdmFyIHJlQ2xhc3NTdGFydCA9IC0xXG4gIHZhciBjbGFzc1N0YXJ0ID0gLTFcbiAgLy8gLiBhbmQgLi4gbmV2ZXIgbWF0Y2ggYW55dGhpbmcgdGhhdCBkb2Vzbid0IHN0YXJ0IHdpdGggLixcbiAgLy8gZXZlbiB3aGVuIG9wdGlvbnMuZG90IGlzIHNldC5cbiAgdmFyIHBhdHRlcm5TdGFydCA9IHBhdHRlcm4uY2hhckF0KDApID09PSAnLicgPyAnJyAvLyBhbnl0aGluZ1xuICAvLyBub3QgKHN0YXJ0IG9yIC8gZm9sbG93ZWQgYnkgLiBvciAuLiBmb2xsb3dlZCBieSAvIG9yIGVuZClcbiAgOiBvcHRpb25zLmRvdCA/ICcoPyEoPzpefFxcXFxcXC8pXFxcXC57MSwyfSg/OiR8XFxcXFxcLykpJ1xuICA6ICcoPyFcXFxcLiknXG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGZ1bmN0aW9uIGNsZWFyU3RhdGVDaGFyICgpIHtcbiAgICBpZiAoc3RhdGVDaGFyKSB7XG4gICAgICAvLyB3ZSBoYWQgc29tZSBzdGF0ZS10cmFja2luZyBjaGFyYWN0ZXJcbiAgICAgIC8vIHRoYXQgd2Fzbid0IGNvbnN1bWVkIGJ5IHRoaXMgcGFzcy5cbiAgICAgIHN3aXRjaCAoc3RhdGVDaGFyKSB7XG4gICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgIHJlICs9IHN0YXJcbiAgICAgICAgICBoYXNNYWdpYyA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnPyc6XG4gICAgICAgICAgcmUgKz0gcW1hcmtcbiAgICAgICAgICBoYXNNYWdpYyA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZSArPSAnXFxcXCcgKyBzdGF0ZUNoYXJcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHNlbGYuZGVidWcoJ2NsZWFyU3RhdGVDaGFyICVqICVqJywgc3RhdGVDaGFyLCByZSlcbiAgICAgIHN0YXRlQ2hhciA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhdHRlcm4ubGVuZ3RoLCBjXG4gICAgOyAoaSA8IGxlbikgJiYgKGMgPSBwYXR0ZXJuLmNoYXJBdChpKSlcbiAgICA7IGkrKykge1xuICAgIHRoaXMuZGVidWcoJyVzXFx0JXMgJXMgJWonLCBwYXR0ZXJuLCBpLCByZSwgYylcblxuICAgIC8vIHNraXAgb3ZlciBhbnkgdGhhdCBhcmUgZXNjYXBlZC5cbiAgICBpZiAoZXNjYXBpbmcgJiYgcmVTcGVjaWFsc1tjXSkge1xuICAgICAgcmUgKz0gJ1xcXFwnICsgY1xuICAgICAgZXNjYXBpbmcgPSBmYWxzZVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGMpIHtcbiAgICAgIGNhc2UgJy8nOlxuICAgICAgICAvLyBjb21wbGV0ZWx5IG5vdCBhbGxvd2VkLCBldmVuIGVzY2FwZWQuXG4gICAgICAgIC8vIFNob3VsZCBhbHJlYWR5IGJlIHBhdGgtc3BsaXQgYnkgbm93LlxuICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgICAgZXNjYXBpbmcgPSB0cnVlXG4gICAgICBjb250aW51ZVxuXG4gICAgICAvLyB0aGUgdmFyaW91cyBzdGF0ZUNoYXIgdmFsdWVzXG4gICAgICAvLyBmb3IgdGhlIFwiZXh0Z2xvYlwiIHN0dWZmLlxuICAgICAgY2FzZSAnPyc6XG4gICAgICBjYXNlICcqJzpcbiAgICAgIGNhc2UgJysnOlxuICAgICAgY2FzZSAnQCc6XG4gICAgICBjYXNlICchJzpcbiAgICAgICAgdGhpcy5kZWJ1ZygnJXNcXHQlcyAlcyAlaiA8LS0gc3RhdGVDaGFyJywgcGF0dGVybiwgaSwgcmUsIGMpXG5cbiAgICAgICAgLy8gYWxsIG9mIHRob3NlIGFyZSBsaXRlcmFscyBpbnNpZGUgYSBjbGFzcywgZXhjZXB0IHRoYXRcbiAgICAgICAgLy8gdGhlIGdsb2IgWyFhXSBtZWFucyBbXmFdIGluIHJlZ2V4cFxuICAgICAgICBpZiAoaW5DbGFzcykge1xuICAgICAgICAgIHRoaXMuZGVidWcoJyAgaW4gY2xhc3MnKVxuICAgICAgICAgIGlmIChjID09PSAnIScgJiYgaSA9PT0gY2xhc3NTdGFydCArIDEpIGMgPSAnXidcbiAgICAgICAgICByZSArPSBjXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIGFscmVhZHkgaGF2ZSBhIHN0YXRlQ2hhciwgdGhlbiBpdCBtZWFuc1xuICAgICAgICAvLyB0aGF0IHRoZXJlIHdhcyBzb21ldGhpbmcgbGlrZSAqKiBvciArPyBpbiB0aGVyZS5cbiAgICAgICAgLy8gSGFuZGxlIHRoZSBzdGF0ZUNoYXIsIHRoZW4gcHJvY2VlZCB3aXRoIHRoaXMgb25lLlxuICAgICAgICBzZWxmLmRlYnVnKCdjYWxsIGNsZWFyU3RhdGVDaGFyICVqJywgc3RhdGVDaGFyKVxuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG4gICAgICAgIHN0YXRlQ2hhciA9IGNcbiAgICAgICAgLy8gaWYgZXh0Z2xvYiBpcyBkaXNhYmxlZCwgdGhlbiArKGFzZGZ8Zm9vKSBpc24ndCBhIHRoaW5nLlxuICAgICAgICAvLyBqdXN0IGNsZWFyIHRoZSBzdGF0ZWNoYXIgKm5vdyosIHJhdGhlciB0aGFuIGV2ZW4gZGl2aW5nIGludG9cbiAgICAgICAgLy8gdGhlIHBhdHRlcm5MaXN0IHN0dWZmLlxuICAgICAgICBpZiAob3B0aW9ucy5ub2V4dCkgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgY29udGludWVcblxuICAgICAgY2FzZSAnKCc6XG4gICAgICAgIGlmIChpbkNsYXNzKSB7XG4gICAgICAgICAgcmUgKz0gJygnXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc3RhdGVDaGFyKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFwoJ1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBwYXR0ZXJuTGlzdFN0YWNrLnB1c2goe1xuICAgICAgICAgIHR5cGU6IHN0YXRlQ2hhcixcbiAgICAgICAgICBzdGFydDogaSAtIDEsXG4gICAgICAgICAgcmVTdGFydDogcmUubGVuZ3RoLFxuICAgICAgICAgIG9wZW46IHBsVHlwZXNbc3RhdGVDaGFyXS5vcGVuLFxuICAgICAgICAgIGNsb3NlOiBwbFR5cGVzW3N0YXRlQ2hhcl0uY2xvc2VcbiAgICAgICAgfSlcbiAgICAgICAgLy8gbmVnYXRpb24gaXMgKD86KD8hanMpW14vXSopXG4gICAgICAgIHJlICs9IHN0YXRlQ2hhciA9PT0gJyEnID8gJyg/Oig/ISg/OicgOiAnKD86J1xuICAgICAgICB0aGlzLmRlYnVnKCdwbFR5cGUgJWogJWonLCBzdGF0ZUNoYXIsIHJlKVxuICAgICAgICBzdGF0ZUNoYXIgPSBmYWxzZVxuICAgICAgY29udGludWVcblxuICAgICAgY2FzZSAnKSc6XG4gICAgICAgIGlmIChpbkNsYXNzIHx8ICFwYXR0ZXJuTGlzdFN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgIHJlICs9ICdcXFxcKSdcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgICBoYXNNYWdpYyA9IHRydWVcbiAgICAgICAgdmFyIHBsID0gcGF0dGVybkxpc3RTdGFjay5wb3AoKVxuICAgICAgICAvLyBuZWdhdGlvbiBpcyAoPzooPyFqcylbXi9dKilcbiAgICAgICAgLy8gVGhlIG90aGVycyBhcmUgKD86PHBhdHRlcm4+KTx0eXBlPlxuICAgICAgICByZSArPSBwbC5jbG9zZVxuICAgICAgICBpZiAocGwudHlwZSA9PT0gJyEnKSB7XG4gICAgICAgICAgbmVnYXRpdmVMaXN0cy5wdXNoKHBsKVxuICAgICAgICB9XG4gICAgICAgIHBsLnJlRW5kID0gcmUubGVuZ3RoXG4gICAgICBjb250aW51ZVxuXG4gICAgICBjYXNlICd8JzpcbiAgICAgICAgaWYgKGluQ2xhc3MgfHwgIXBhdHRlcm5MaXN0U3RhY2subGVuZ3RoIHx8IGVzY2FwaW5nKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFx8J1xuICAgICAgICAgIGVzY2FwaW5nID0gZmFsc2VcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgICByZSArPSAnfCdcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIC8vIHRoZXNlIGFyZSBtb3N0bHkgdGhlIHNhbWUgaW4gcmVnZXhwIGFuZCBnbG9iXG4gICAgICBjYXNlICdbJzpcbiAgICAgICAgLy8gc3dhbGxvdyBhbnkgc3RhdGUtdHJhY2tpbmcgY2hhciBiZWZvcmUgdGhlIFtcbiAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuXG4gICAgICAgIGlmIChpbkNsYXNzKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFwnICsgY1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBpbkNsYXNzID0gdHJ1ZVxuICAgICAgICBjbGFzc1N0YXJ0ID0gaVxuICAgICAgICByZUNsYXNzU3RhcnQgPSByZS5sZW5ndGhcbiAgICAgICAgcmUgKz0gY1xuICAgICAgY29udGludWVcblxuICAgICAgY2FzZSAnXSc6XG4gICAgICAgIC8vICBhIHJpZ2h0IGJyYWNrZXQgc2hhbGwgbG9zZSBpdHMgc3BlY2lhbFxuICAgICAgICAvLyAgbWVhbmluZyBhbmQgcmVwcmVzZW50IGl0c2VsZiBpblxuICAgICAgICAvLyAgYSBicmFja2V0IGV4cHJlc3Npb24gaWYgaXQgb2NjdXJzXG4gICAgICAgIC8vICBmaXJzdCBpbiB0aGUgbGlzdC4gIC0tIFBPU0lYLjIgMi44LjMuMlxuICAgICAgICBpZiAoaSA9PT0gY2xhc3NTdGFydCArIDEgfHwgIWluQ2xhc3MpIHtcbiAgICAgICAgICByZSArPSAnXFxcXCcgKyBjXG4gICAgICAgICAgZXNjYXBpbmcgPSBmYWxzZVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgbGVmdCBhIGNsYXNzIG9wZW4uXG4gICAgICAgIC8vIFwiW3otYV1cIiBpcyB2YWxpZCwgZXF1aXZhbGVudCB0byBcIlxcW3otYVxcXVwiXG4gICAgICAgIGlmIChpbkNsYXNzKSB7XG4gICAgICAgICAgLy8gc3BsaXQgd2hlcmUgdGhlIGxhc3QgWyB3YXMsIG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlXG4gICAgICAgICAgLy8gYW4gaW52YWxpZCByZS4gaWYgc28sIHJlLXdhbGsgdGhlIGNvbnRlbnRzIG9mIHRoZVxuICAgICAgICAgIC8vIHdvdWxkLWJlIGNsYXNzIHRvIHJlLXRyYW5zbGF0ZSBhbnkgY2hhcmFjdGVycyB0aGF0XG4gICAgICAgICAgLy8gd2VyZSBwYXNzZWQgdGhyb3VnaCBhcy1pc1xuICAgICAgICAgIC8vIFRPRE86IEl0IHdvdWxkIHByb2JhYmx5IGJlIGZhc3RlciB0byBkZXRlcm1pbmUgdGhpc1xuICAgICAgICAgIC8vIHdpdGhvdXQgYSB0cnkvY2F0Y2ggYW5kIGEgbmV3IFJlZ0V4cCwgYnV0IGl0J3MgdHJpY2t5XG4gICAgICAgICAgLy8gdG8gZG8gc2FmZWx5LiAgRm9yIG5vdywgdGhpcyBpcyBzYWZlIGFuZCB3b3Jrcy5cbiAgICAgICAgICB2YXIgY3MgPSBwYXR0ZXJuLnN1YnN0cmluZyhjbGFzc1N0YXJ0ICsgMSwgaSlcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgUmVnRXhwKCdbJyArIGNzICsgJ10nKVxuICAgICAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgICAvLyBub3QgYSB2YWxpZCBjbGFzcyFcbiAgICAgICAgICAgIHZhciBzcCA9IHRoaXMucGFyc2UoY3MsIFNVQlBBUlNFKVxuICAgICAgICAgICAgcmUgPSByZS5zdWJzdHIoMCwgcmVDbGFzc1N0YXJ0KSArICdcXFxcWycgKyBzcFswXSArICdcXFxcXSdcbiAgICAgICAgICAgIGhhc01hZ2ljID0gaGFzTWFnaWMgfHwgc3BbMV1cbiAgICAgICAgICAgIGluQ2xhc3MgPSBmYWxzZVxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5pc2ggdXAgdGhlIGNsYXNzLlxuICAgICAgICBoYXNNYWdpYyA9IHRydWVcbiAgICAgICAgaW5DbGFzcyA9IGZhbHNlXG4gICAgICAgIHJlICs9IGNcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIHN3YWxsb3cgYW55IHN0YXRlIGNoYXIgdGhhdCB3YXNuJ3QgY29uc3VtZWRcbiAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuXG4gICAgICAgIGlmIChlc2NhcGluZykge1xuICAgICAgICAgIC8vIG5vIG5lZWRcbiAgICAgICAgICBlc2NhcGluZyA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSBpZiAocmVTcGVjaWFsc1tjXVxuICAgICAgICAgICYmICEoYyA9PT0gJ14nICYmIGluQ2xhc3MpKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFwnXG4gICAgICAgIH1cblxuICAgICAgICByZSArPSBjXG5cbiAgICB9IC8vIHN3aXRjaFxuICB9IC8vIGZvclxuXG4gIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB3ZSBsZWZ0IGEgY2xhc3Mgb3Blbi5cbiAgLy8gXCJbYWJjXCIgaXMgdmFsaWQsIGVxdWl2YWxlbnQgdG8gXCJcXFthYmNcIlxuICBpZiAoaW5DbGFzcykge1xuICAgIC8vIHNwbGl0IHdoZXJlIHRoZSBsYXN0IFsgd2FzLCBhbmQgZXNjYXBlIGl0XG4gICAgLy8gdGhpcyBpcyBhIGh1Z2UgcGl0YS4gIFdlIG5vdyBoYXZlIHRvIHJlLXdhbGtcbiAgICAvLyB0aGUgY29udGVudHMgb2YgdGhlIHdvdWxkLWJlIGNsYXNzIHRvIHJlLXRyYW5zbGF0ZVxuICAgIC8vIGFueSBjaGFyYWN0ZXJzIHRoYXQgd2VyZSBwYXNzZWQgdGhyb3VnaCBhcy1pc1xuICAgIGNzID0gcGF0dGVybi5zdWJzdHIoY2xhc3NTdGFydCArIDEpXG4gICAgc3AgPSB0aGlzLnBhcnNlKGNzLCBTVUJQQVJTRSlcbiAgICByZSA9IHJlLnN1YnN0cigwLCByZUNsYXNzU3RhcnQpICsgJ1xcXFxbJyArIHNwWzBdXG4gICAgaGFzTWFnaWMgPSBoYXNNYWdpYyB8fCBzcFsxXVxuICB9XG5cbiAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHdlIGhhZCBhICsoIHRoaW5nIGF0IHRoZSAqZW5kKlxuICAvLyBvZiB0aGUgcGF0dGVybi5cbiAgLy8gZWFjaCBwYXR0ZXJuIGxpc3Qgc3RhY2sgYWRkcyAzIGNoYXJzLCBhbmQgd2UgbmVlZCB0byBnbyB0aHJvdWdoXG4gIC8vIGFuZCBlc2NhcGUgYW55IHwgY2hhcnMgdGhhdCB3ZXJlIHBhc3NlZCB0aHJvdWdoIGFzLWlzIGZvciB0aGUgcmVnZXhwLlxuICAvLyBHbyB0aHJvdWdoIGFuZCBlc2NhcGUgdGhlbSwgdGFraW5nIGNhcmUgbm90IHRvIGRvdWJsZS1lc2NhcGUgYW55XG4gIC8vIHwgY2hhcnMgdGhhdCB3ZXJlIGFscmVhZHkgZXNjYXBlZC5cbiAgZm9yIChwbCA9IHBhdHRlcm5MaXN0U3RhY2sucG9wKCk7IHBsOyBwbCA9IHBhdHRlcm5MaXN0U3RhY2sucG9wKCkpIHtcbiAgICB2YXIgdGFpbCA9IHJlLnNsaWNlKHBsLnJlU3RhcnQgKyBwbC5vcGVuLmxlbmd0aClcbiAgICB0aGlzLmRlYnVnKCdzZXR0aW5nIHRhaWwnLCByZSwgcGwpXG4gICAgLy8gbWF5YmUgc29tZSBldmVuIG51bWJlciBvZiBcXCwgdGhlbiBtYXliZSAxIFxcLCBmb2xsb3dlZCBieSBhIHxcbiAgICB0YWlsID0gdGFpbC5yZXBsYWNlKC8oKD86XFxcXHsyfSl7MCw2NH0pKFxcXFw/KVxcfC9nLCBmdW5jdGlvbiAoXywgJDEsICQyKSB7XG4gICAgICBpZiAoISQyKSB7XG4gICAgICAgIC8vIHRoZSB8IGlzbid0IGFscmVhZHkgZXNjYXBlZCwgc28gZXNjYXBlIGl0LlxuICAgICAgICAkMiA9ICdcXFxcJ1xuICAgICAgfVxuXG4gICAgICAvLyBuZWVkIHRvIGVzY2FwZSBhbGwgdGhvc2Ugc2xhc2hlcyAqYWdhaW4qLCB3aXRob3V0IGVzY2FwaW5nIHRoZVxuICAgICAgLy8gb25lIHRoYXQgd2UgbmVlZCBmb3IgZXNjYXBpbmcgdGhlIHwgY2hhcmFjdGVyLiAgQXMgaXQgd29ya3Mgb3V0LFxuICAgICAgLy8gZXNjYXBpbmcgYW4gZXZlbiBudW1iZXIgb2Ygc2xhc2hlcyBjYW4gYmUgZG9uZSBieSBzaW1wbHkgcmVwZWF0aW5nXG4gICAgICAvLyBpdCBleGFjdGx5IGFmdGVyIGl0c2VsZi4gIFRoYXQncyB3aHkgdGhpcyB0cmljayB3b3Jrcy5cbiAgICAgIC8vXG4gICAgICAvLyBJIGFtIHNvcnJ5IHRoYXQgeW91IGhhdmUgdG8gc2VlIHRoaXMuXG4gICAgICByZXR1cm4gJDEgKyAkMSArICQyICsgJ3wnXG4gICAgfSlcblxuICAgIHRoaXMuZGVidWcoJ3RhaWw9JWpcXG4gICAlcycsIHRhaWwsIHRhaWwsIHBsLCByZSlcbiAgICB2YXIgdCA9IHBsLnR5cGUgPT09ICcqJyA/IHN0YXJcbiAgICAgIDogcGwudHlwZSA9PT0gJz8nID8gcW1hcmtcbiAgICAgIDogJ1xcXFwnICsgcGwudHlwZVxuXG4gICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgcmUgPSByZS5zbGljZSgwLCBwbC5yZVN0YXJ0KSArIHQgKyAnXFxcXCgnICsgdGFpbFxuICB9XG5cbiAgLy8gaGFuZGxlIHRyYWlsaW5nIHRoaW5ncyB0aGF0IG9ubHkgbWF0dGVyIGF0IHRoZSB2ZXJ5IGVuZC5cbiAgY2xlYXJTdGF0ZUNoYXIoKVxuICBpZiAoZXNjYXBpbmcpIHtcbiAgICAvLyB0cmFpbGluZyBcXFxcXG4gICAgcmUgKz0gJ1xcXFxcXFxcJ1xuICB9XG5cbiAgLy8gb25seSBuZWVkIHRvIGFwcGx5IHRoZSBub2RvdCBzdGFydCBpZiB0aGUgcmUgc3RhcnRzIHdpdGhcbiAgLy8gc29tZXRoaW5nIHRoYXQgY291bGQgY29uY2VpdmFibHkgY2FwdHVyZSBhIGRvdFxuICB2YXIgYWRkUGF0dGVyblN0YXJ0ID0gZmFsc2VcbiAgc3dpdGNoIChyZS5jaGFyQXQoMCkpIHtcbiAgICBjYXNlICcuJzpcbiAgICBjYXNlICdbJzpcbiAgICBjYXNlICcoJzogYWRkUGF0dGVyblN0YXJ0ID0gdHJ1ZVxuICB9XG5cbiAgLy8gSGFjayB0byB3b3JrIGFyb3VuZCBsYWNrIG9mIG5lZ2F0aXZlIGxvb2tiZWhpbmQgaW4gSlNcbiAgLy8gQSBwYXR0ZXJuIGxpa2U6ICouISh4KS4hKHl8eikgbmVlZHMgdG8gZW5zdXJlIHRoYXQgYSBuYW1lXG4gIC8vIGxpa2UgJ2EueHl6Lnl6JyBkb2Vzbid0IG1hdGNoLiAgU28sIHRoZSBmaXJzdCBuZWdhdGl2ZVxuICAvLyBsb29rYWhlYWQsIGhhcyB0byBsb29rIEFMTCB0aGUgd2F5IGFoZWFkLCB0byB0aGUgZW5kIG9mXG4gIC8vIHRoZSBwYXR0ZXJuLlxuICBmb3IgKHZhciBuID0gbmVnYXRpdmVMaXN0cy5sZW5ndGggLSAxOyBuID4gLTE7IG4tLSkge1xuICAgIHZhciBubCA9IG5lZ2F0aXZlTGlzdHNbbl1cblxuICAgIHZhciBubEJlZm9yZSA9IHJlLnNsaWNlKDAsIG5sLnJlU3RhcnQpXG4gICAgdmFyIG5sRmlyc3QgPSByZS5zbGljZShubC5yZVN0YXJ0LCBubC5yZUVuZCAtIDgpXG4gICAgdmFyIG5sTGFzdCA9IHJlLnNsaWNlKG5sLnJlRW5kIC0gOCwgbmwucmVFbmQpXG4gICAgdmFyIG5sQWZ0ZXIgPSByZS5zbGljZShubC5yZUVuZClcblxuICAgIG5sTGFzdCArPSBubEFmdGVyXG5cbiAgICAvLyBIYW5kbGUgbmVzdGVkIHN0dWZmIGxpa2UgKigqLmpzfCEoKi5qc29uKSksIHdoZXJlIG9wZW4gcGFyZW5zXG4gICAgLy8gbWVhbiB0aGF0IHdlIHNob3VsZCAqbm90KiBpbmNsdWRlIHRoZSApIGluIHRoZSBiaXQgdGhhdCBpcyBjb25zaWRlcmVkXG4gICAgLy8gXCJhZnRlclwiIHRoZSBuZWdhdGVkIHNlY3Rpb24uXG4gICAgdmFyIG9wZW5QYXJlbnNCZWZvcmUgPSBubEJlZm9yZS5zcGxpdCgnKCcpLmxlbmd0aCAtIDFcbiAgICB2YXIgY2xlYW5BZnRlciA9IG5sQWZ0ZXJcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3BlblBhcmVuc0JlZm9yZTsgaSsrKSB7XG4gICAgICBjbGVhbkFmdGVyID0gY2xlYW5BZnRlci5yZXBsYWNlKC9cXClbKyo/XT8vLCAnJylcbiAgICB9XG4gICAgbmxBZnRlciA9IGNsZWFuQWZ0ZXJcblxuICAgIHZhciBkb2xsYXIgPSAnJ1xuICAgIGlmIChubEFmdGVyID09PSAnJyAmJiBpc1N1YiAhPT0gU1VCUEFSU0UpIHtcbiAgICAgIGRvbGxhciA9ICckJ1xuICAgIH1cbiAgICB2YXIgbmV3UmUgPSBubEJlZm9yZSArIG5sRmlyc3QgKyBubEFmdGVyICsgZG9sbGFyICsgbmxMYXN0XG4gICAgcmUgPSBuZXdSZVxuICB9XG5cbiAgLy8gaWYgdGhlIHJlIGlzIG5vdCBcIlwiIGF0IHRoaXMgcG9pbnQsIHRoZW4gd2UgbmVlZCB0byBtYWtlIHN1cmVcbiAgLy8gaXQgZG9lc24ndCBtYXRjaCBhZ2FpbnN0IGFuIGVtcHR5IHBhdGggcGFydC5cbiAgLy8gT3RoZXJ3aXNlIGEvKiB3aWxsIG1hdGNoIGEvLCB3aGljaCBpdCBzaG91bGQgbm90LlxuICBpZiAocmUgIT09ICcnICYmIGhhc01hZ2ljKSB7XG4gICAgcmUgPSAnKD89LiknICsgcmVcbiAgfVxuXG4gIGlmIChhZGRQYXR0ZXJuU3RhcnQpIHtcbiAgICByZSA9IHBhdHRlcm5TdGFydCArIHJlXG4gIH1cblxuICAvLyBwYXJzaW5nIGp1c3QgYSBwaWVjZSBvZiBhIGxhcmdlciBwYXR0ZXJuLlxuICBpZiAoaXNTdWIgPT09IFNVQlBBUlNFKSB7XG4gICAgcmV0dXJuIFtyZSwgaGFzTWFnaWNdXG4gIH1cblxuICAvLyBza2lwIHRoZSByZWdleHAgZm9yIG5vbi1tYWdpY2FsIHBhdHRlcm5zXG4gIC8vIHVuZXNjYXBlIGFueXRoaW5nIGluIGl0LCB0aG91Z2gsIHNvIHRoYXQgaXQnbGwgYmVcbiAgLy8gYW4gZXhhY3QgbWF0Y2ggYWdhaW5zdCBhIGZpbGUgZXRjLlxuICBpZiAoIWhhc01hZ2ljKSB7XG4gICAgcmV0dXJuIGdsb2JVbmVzY2FwZShwYXR0ZXJuKVxuICB9XG5cbiAgdmFyIGZsYWdzID0gb3B0aW9ucy5ub2Nhc2UgPyAnaScgOiAnJ1xuICB0cnkge1xuICAgIHZhciByZWdFeHAgPSBuZXcgUmVnRXhwKCdeJyArIHJlICsgJyQnLCBmbGFncylcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICAvLyBJZiBpdCB3YXMgYW4gaW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24sIHRoZW4gaXQgY2FuJ3QgbWF0Y2hcbiAgICAvLyBhbnl0aGluZy4gIFRoaXMgdHJpY2sgbG9va3MgZm9yIGEgY2hhcmFjdGVyIGFmdGVyIHRoZSBlbmQgb2ZcbiAgICAvLyB0aGUgc3RyaW5nLCB3aGljaCBpcyBvZiBjb3Vyc2UgaW1wb3NzaWJsZSwgZXhjZXB0IGluIG11bHRpLWxpbmVcbiAgICAvLyBtb2RlLCBidXQgaXQncyBub3QgYSAvbSByZWdleC5cbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnJC4nKVxuICB9XG5cbiAgcmVnRXhwLl9nbG9iID0gcGF0dGVyblxuICByZWdFeHAuX3NyYyA9IHJlXG5cbiAgcmV0dXJuIHJlZ0V4cFxufVxuXG5taW5pbWF0Y2gubWFrZVJlID0gZnVuY3Rpb24gKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucyB8fCB7fSkubWFrZVJlKClcbn1cblxuTWluaW1hdGNoLnByb3RvdHlwZS5tYWtlUmUgPSBtYWtlUmVcbmZ1bmN0aW9uIG1ha2VSZSAoKSB7XG4gIGlmICh0aGlzLnJlZ2V4cCB8fCB0aGlzLnJlZ2V4cCA9PT0gZmFsc2UpIHJldHVybiB0aGlzLnJlZ2V4cFxuXG4gIC8vIGF0IHRoaXMgcG9pbnQsIHRoaXMuc2V0IGlzIGEgMmQgYXJyYXkgb2YgcGFydGlhbFxuICAvLyBwYXR0ZXJuIHN0cmluZ3MsIG9yIFwiKipcIi5cbiAgLy9cbiAgLy8gSXQncyBiZXR0ZXIgdG8gdXNlIC5tYXRjaCgpLiAgVGhpcyBmdW5jdGlvbiBzaG91bGRuJ3RcbiAgLy8gYmUgdXNlZCwgcmVhbGx5LCBidXQgaXQncyBwcmV0dHkgY29udmVuaWVudCBzb21ldGltZXMsXG4gIC8vIHdoZW4geW91IGp1c3Qgd2FudCB0byB3b3JrIHdpdGggYSByZWdleC5cbiAgdmFyIHNldCA9IHRoaXMuc2V0XG5cbiAgaWYgKCFzZXQubGVuZ3RoKSB7XG4gICAgdGhpcy5yZWdleHAgPSBmYWxzZVxuICAgIHJldHVybiB0aGlzLnJlZ2V4cFxuICB9XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgdmFyIHR3b1N0YXIgPSBvcHRpb25zLm5vZ2xvYnN0YXIgPyBzdGFyXG4gICAgOiBvcHRpb25zLmRvdCA/IHR3b1N0YXJEb3RcbiAgICA6IHR3b1N0YXJOb0RvdFxuICB2YXIgZmxhZ3MgPSBvcHRpb25zLm5vY2FzZSA/ICdpJyA6ICcnXG5cbiAgdmFyIHJlID0gc2V0Lm1hcChmdW5jdGlvbiAocGF0dGVybikge1xuICAgIHJldHVybiBwYXR0ZXJuLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIChwID09PSBHTE9CU1RBUikgPyB0d29TdGFyXG4gICAgICA6ICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpID8gcmVnRXhwRXNjYXBlKHApXG4gICAgICA6IHAuX3NyY1xuICAgIH0pLmpvaW4oJ1xcXFxcXC8nKVxuICB9KS5qb2luKCd8JylcblxuICAvLyBtdXN0IG1hdGNoIGVudGlyZSBwYXR0ZXJuXG4gIC8vIGVuZGluZyBpbiBhICogb3IgKiogd2lsbCBtYWtlIGl0IGxlc3Mgc3RyaWN0LlxuICByZSA9ICdeKD86JyArIHJlICsgJykkJ1xuXG4gIC8vIGNhbiBtYXRjaCBhbnl0aGluZywgYXMgbG9uZyBhcyBpdCdzIG5vdCB0aGlzLlxuICBpZiAodGhpcy5uZWdhdGUpIHJlID0gJ14oPyEnICsgcmUgKyAnKS4qJCdcblxuICB0cnkge1xuICAgIHRoaXMucmVnZXhwID0gbmV3IFJlZ0V4cChyZSwgZmxhZ3MpXG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgdGhpcy5yZWdleHAgPSBmYWxzZVxuICB9XG4gIHJldHVybiB0aGlzLnJlZ2V4cFxufVxuXG5taW5pbWF0Y2gubWF0Y2ggPSBmdW5jdGlvbiAobGlzdCwgcGF0dGVybiwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgbW0gPSBuZXcgTWluaW1hdGNoKHBhdHRlcm4sIG9wdGlvbnMpXG4gIGxpc3QgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAoZikge1xuICAgIHJldHVybiBtbS5tYXRjaChmKVxuICB9KVxuICBpZiAobW0ub3B0aW9ucy5ub251bGwgJiYgIWxpc3QubGVuZ3RoKSB7XG4gICAgbGlzdC5wdXNoKHBhdHRlcm4pXG4gIH1cbiAgcmV0dXJuIGxpc3Rcbn1cblxuTWluaW1hdGNoLnByb3RvdHlwZS5tYXRjaCA9IG1hdGNoXG5mdW5jdGlvbiBtYXRjaCAoZiwgcGFydGlhbCkge1xuICB0aGlzLmRlYnVnKCdtYXRjaCcsIGYsIHRoaXMucGF0dGVybilcbiAgLy8gc2hvcnQtY2lyY3VpdCBpbiB0aGUgY2FzZSBvZiBidXN0ZWQgdGhpbmdzLlxuICAvLyBjb21tZW50cywgZXRjLlxuICBpZiAodGhpcy5jb21tZW50KSByZXR1cm4gZmFsc2VcbiAgaWYgKHRoaXMuZW1wdHkpIHJldHVybiBmID09PSAnJ1xuXG4gIGlmIChmID09PSAnLycgJiYgcGFydGlhbCkgcmV0dXJuIHRydWVcblxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gIC8vIHdpbmRvd3M6IG5lZWQgdG8gdXNlIC8sIG5vdCBcXFxuICBpZiAocGF0aC5zZXAgIT09ICcvJykge1xuICAgIGYgPSBmLnNwbGl0KHBhdGguc2VwKS5qb2luKCcvJylcbiAgfVxuXG4gIC8vIHRyZWF0IHRoZSB0ZXN0IHBhdGggYXMgYSBzZXQgb2YgcGF0aHBhcnRzLlxuICBmID0gZi5zcGxpdChzbGFzaFNwbGl0KVxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgJ3NwbGl0JywgZilcblxuICAvLyBqdXN0IE9ORSBvZiB0aGUgcGF0dGVybiBzZXRzIGluIHRoaXMuc2V0IG5lZWRzIHRvIG1hdGNoXG4gIC8vIGluIG9yZGVyIGZvciBpdCB0byBiZSB2YWxpZC4gIElmIG5lZ2F0aW5nLCB0aGVuIGp1c3Qgb25lXG4gIC8vIG1hdGNoIG1lYW5zIHRoYXQgd2UgaGF2ZSBmYWlsZWQuXG4gIC8vIEVpdGhlciB3YXksIHJldHVybiBvbiB0aGUgZmlyc3QgaGl0LlxuXG4gIHZhciBzZXQgPSB0aGlzLnNldFxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgJ3NldCcsIHNldClcblxuICAvLyBGaW5kIHRoZSBiYXNlbmFtZSBvZiB0aGUgcGF0aCBieSBsb29raW5nIGZvciB0aGUgbGFzdCBub24tZW1wdHkgc2VnbWVudFxuICB2YXIgZmlsZW5hbWVcbiAgdmFyIGlcbiAgZm9yIChpID0gZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGZpbGVuYW1lID0gZltpXVxuICAgIGlmIChmaWxlbmFtZSkgYnJlYWtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGF0dGVybiA9IHNldFtpXVxuICAgIHZhciBmaWxlID0gZlxuICAgIGlmIChvcHRpb25zLm1hdGNoQmFzZSAmJiBwYXR0ZXJuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZmlsZSA9IFtmaWxlbmFtZV1cbiAgICB9XG4gICAgdmFyIGhpdCA9IHRoaXMubWF0Y2hPbmUoZmlsZSwgcGF0dGVybiwgcGFydGlhbClcbiAgICBpZiAoaGl0KSB7XG4gICAgICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSByZXR1cm4gdHJ1ZVxuICAgICAgcmV0dXJuICF0aGlzLm5lZ2F0ZVxuICAgIH1cbiAgfVxuXG4gIC8vIGRpZG4ndCBnZXQgYW55IGhpdHMuICB0aGlzIGlzIHN1Y2Nlc3MgaWYgaXQncyBhIG5lZ2F0aXZlXG4gIC8vIHBhdHRlcm4sIGZhaWx1cmUgb3RoZXJ3aXNlLlxuICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSByZXR1cm4gZmFsc2VcbiAgcmV0dXJuIHRoaXMubmVnYXRlXG59XG5cbi8vIHNldCBwYXJ0aWFsIHRvIHRydWUgdG8gdGVzdCBpZiwgZm9yIGV4YW1wbGUsXG4vLyBcIi9hL2JcIiBtYXRjaGVzIHRoZSBzdGFydCBvZiBcIi8qL2IvKi9kXCJcbi8vIFBhcnRpYWwgbWVhbnMsIGlmIHlvdSBydW4gb3V0IG9mIGZpbGUgYmVmb3JlIHlvdSBydW5cbi8vIG91dCBvZiBwYXR0ZXJuLCB0aGVuIHRoYXQncyBmaW5lLCBhcyBsb25nIGFzIGFsbFxuLy8gdGhlIHBhcnRzIG1hdGNoLlxuTWluaW1hdGNoLnByb3RvdHlwZS5tYXRjaE9uZSA9IGZ1bmN0aW9uIChmaWxlLCBwYXR0ZXJuLCBwYXJ0aWFsKSB7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUnLFxuICAgIHsgJ3RoaXMnOiB0aGlzLCBmaWxlOiBmaWxlLCBwYXR0ZXJuOiBwYXR0ZXJuIH0pXG5cbiAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUnLCBmaWxlLmxlbmd0aCwgcGF0dGVybi5sZW5ndGgpXG5cbiAgZm9yICh2YXIgZmkgPSAwLFxuICAgICAgcGkgPSAwLFxuICAgICAgZmwgPSBmaWxlLmxlbmd0aCxcbiAgICAgIHBsID0gcGF0dGVybi5sZW5ndGhcbiAgICAgIDsgKGZpIDwgZmwpICYmIChwaSA8IHBsKVxuICAgICAgOyBmaSsrLCBwaSsrKSB7XG4gICAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUgbG9vcCcpXG4gICAgdmFyIHAgPSBwYXR0ZXJuW3BpXVxuICAgIHZhciBmID0gZmlsZVtmaV1cblxuICAgIHRoaXMuZGVidWcocGF0dGVybiwgcCwgZilcblxuICAgIC8vIHNob3VsZCBiZSBpbXBvc3NpYmxlLlxuICAgIC8vIHNvbWUgaW52YWxpZCByZWdleHAgc3R1ZmYgaW4gdGhlIHNldC5cbiAgICBpZiAocCA9PT0gZmFsc2UpIHJldHVybiBmYWxzZVxuXG4gICAgaWYgKHAgPT09IEdMT0JTVEFSKSB7XG4gICAgICB0aGlzLmRlYnVnKCdHTE9CU1RBUicsIFtwYXR0ZXJuLCBwLCBmXSlcblxuICAgICAgLy8gXCIqKlwiXG4gICAgICAvLyBhLyoqL2IvKiovYyB3b3VsZCBtYXRjaCB0aGUgZm9sbG93aW5nOlxuICAgICAgLy8gYS9iL3gveS96L2NcbiAgICAgIC8vIGEveC95L3ovYi9jXG4gICAgICAvLyBhL2IveC9iL3gvY1xuICAgICAgLy8gYS9iL2NcbiAgICAgIC8vIFRvIGRvIHRoaXMsIHRha2UgdGhlIHJlc3Qgb2YgdGhlIHBhdHRlcm4gYWZ0ZXJcbiAgICAgIC8vIHRoZSAqKiwgYW5kIHNlZSBpZiBpdCB3b3VsZCBtYXRjaCB0aGUgZmlsZSByZW1haW5kZXIuXG4gICAgICAvLyBJZiBzbywgcmV0dXJuIHN1Y2Nlc3MuXG4gICAgICAvLyBJZiBub3QsIHRoZSAqKiBcInN3YWxsb3dzXCIgYSBzZWdtZW50LCBhbmQgdHJ5IGFnYWluLlxuICAgICAgLy8gVGhpcyBpcyByZWN1cnNpdmVseSBhd2Z1bC5cbiAgICAgIC8vXG4gICAgICAvLyBhLyoqL2IvKiovYyBtYXRjaGluZyBhL2IveC95L3ovY1xuICAgICAgLy8gLSBhIG1hdGNoZXMgYVxuICAgICAgLy8gLSBkb3VibGVzdGFyXG4gICAgICAvLyAgIC0gbWF0Y2hPbmUoYi94L3kvei9jLCBiLyoqL2MpXG4gICAgICAvLyAgICAgLSBiIG1hdGNoZXMgYlxuICAgICAgLy8gICAgIC0gZG91Ymxlc3RhclxuICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh4L3kvei9jLCBjKSAtPiBub1xuICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh5L3ovYywgYykgLT4gbm9cbiAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoei9jLCBjKSAtPiBub1xuICAgICAgLy8gICAgICAgLSBtYXRjaE9uZShjLCBjKSB5ZXMsIGhpdFxuICAgICAgdmFyIGZyID0gZmlcbiAgICAgIHZhciBwciA9IHBpICsgMVxuICAgICAgaWYgKHByID09PSBwbCkge1xuICAgICAgICB0aGlzLmRlYnVnKCcqKiBhdCB0aGUgZW5kJylcbiAgICAgICAgLy8gYSAqKiBhdCB0aGUgZW5kIHdpbGwganVzdCBzd2FsbG93IHRoZSByZXN0LlxuICAgICAgICAvLyBXZSBoYXZlIGZvdW5kIGEgbWF0Y2guXG4gICAgICAgIC8vIGhvd2V2ZXIsIGl0IHdpbGwgbm90IHN3YWxsb3cgLy54LCB1bmxlc3NcbiAgICAgICAgLy8gb3B0aW9ucy5kb3QgaXMgc2V0LlxuICAgICAgICAvLyAuIGFuZCAuLiBhcmUgKm5ldmVyKiBtYXRjaGVkIGJ5ICoqLCBmb3IgZXhwbG9zaXZlbHlcbiAgICAgICAgLy8gZXhwb25lbnRpYWwgcmVhc29ucy5cbiAgICAgICAgZm9yICg7IGZpIDwgZmw7IGZpKyspIHtcbiAgICAgICAgICBpZiAoZmlsZVtmaV0gPT09ICcuJyB8fCBmaWxlW2ZpXSA9PT0gJy4uJyB8fFxuICAgICAgICAgICAgKCFvcHRpb25zLmRvdCAmJiBmaWxlW2ZpXS5jaGFyQXQoMCkgPT09ICcuJykpIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICAgIC8vIG9rLCBsZXQncyBzZWUgaWYgd2UgY2FuIHN3YWxsb3cgd2hhdGV2ZXIgd2UgY2FuLlxuICAgICAgd2hpbGUgKGZyIDwgZmwpIHtcbiAgICAgICAgdmFyIHN3YWxsb3dlZSA9IGZpbGVbZnJdXG5cbiAgICAgICAgdGhpcy5kZWJ1ZygnXFxuZ2xvYnN0YXIgd2hpbGUnLCBmaWxlLCBmciwgcGF0dGVybiwgcHIsIHN3YWxsb3dlZSlcblxuICAgICAgICAvLyBYWFggcmVtb3ZlIHRoaXMgc2xpY2UuICBKdXN0IHBhc3MgdGhlIHN0YXJ0IGluZGV4LlxuICAgICAgICBpZiAodGhpcy5tYXRjaE9uZShmaWxlLnNsaWNlKGZyKSwgcGF0dGVybi5zbGljZShwciksIHBhcnRpYWwpKSB7XG4gICAgICAgICAgdGhpcy5kZWJ1ZygnZ2xvYnN0YXIgZm91bmQgbWF0Y2ghJywgZnIsIGZsLCBzd2FsbG93ZWUpXG4gICAgICAgICAgLy8gZm91bmQgYSBtYXRjaC5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNhbid0IHN3YWxsb3cgXCIuXCIgb3IgXCIuLlwiIGV2ZXIuXG4gICAgICAgICAgLy8gY2FuIG9ubHkgc3dhbGxvdyBcIi5mb29cIiB3aGVuIGV4cGxpY2l0bHkgYXNrZWQuXG4gICAgICAgICAgaWYgKHN3YWxsb3dlZSA9PT0gJy4nIHx8IHN3YWxsb3dlZSA9PT0gJy4uJyB8fFxuICAgICAgICAgICAgKCFvcHRpb25zLmRvdCAmJiBzd2FsbG93ZWUuY2hhckF0KDApID09PSAnLicpKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKCdkb3QgZGV0ZWN0ZWQhJywgZmlsZSwgZnIsIHBhdHRlcm4sIHByKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAqKiBzd2FsbG93cyBhIHNlZ21lbnQsIGFuZCBjb250aW51ZS5cbiAgICAgICAgICB0aGlzLmRlYnVnKCdnbG9ic3RhciBzd2FsbG93IGEgc2VnbWVudCwgYW5kIGNvbnRpbnVlJylcbiAgICAgICAgICBmcisrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbm8gbWF0Y2ggd2FzIGZvdW5kLlxuICAgICAgLy8gSG93ZXZlciwgaW4gcGFydGlhbCBtb2RlLCB3ZSBjYW4ndCBzYXkgdGhpcyBpcyBuZWNlc3NhcmlseSBvdmVyLlxuICAgICAgLy8gSWYgdGhlcmUncyBtb3JlICpwYXR0ZXJuKiBsZWZ0LCB0aGVuXG4gICAgICBpZiAocGFydGlhbCkge1xuICAgICAgICAvLyByYW4gb3V0IG9mIGZpbGVcbiAgICAgICAgdGhpcy5kZWJ1ZygnXFxuPj4+IG5vIG1hdGNoLCBwYXJ0aWFsPycsIGZpbGUsIGZyLCBwYXR0ZXJuLCBwcilcbiAgICAgICAgaWYgKGZyID09PSBmbCkgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIHNvbWV0aGluZyBvdGhlciB0aGFuICoqXG4gICAgLy8gbm9uLW1hZ2ljIHBhdHRlcm5zIGp1c3QgaGF2ZSB0byBtYXRjaCBleGFjdGx5XG4gICAgLy8gcGF0dGVybnMgd2l0aCBtYWdpYyBoYXZlIGJlZW4gdHVybmVkIGludG8gcmVnZXhwcy5cbiAgICB2YXIgaGl0XG4gICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKG9wdGlvbnMubm9jYXNlKSB7XG4gICAgICAgIGhpdCA9IGYudG9Mb3dlckNhc2UoKSA9PT0gcC50b0xvd2VyQ2FzZSgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoaXQgPSBmID09PSBwXG4gICAgICB9XG4gICAgICB0aGlzLmRlYnVnKCdzdHJpbmcgbWF0Y2gnLCBwLCBmLCBoaXQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGhpdCA9IGYubWF0Y2gocClcbiAgICAgIHRoaXMuZGVidWcoJ3BhdHRlcm4gbWF0Y2gnLCBwLCBmLCBoaXQpXG4gICAgfVxuXG4gICAgaWYgKCFoaXQpIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gTm90ZTogZW5kaW5nIGluIC8gbWVhbnMgdGhhdCB3ZSdsbCBnZXQgYSBmaW5hbCBcIlwiXG4gIC8vIGF0IHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4uICBUaGlzIGNhbiBvbmx5IG1hdGNoIGFcbiAgLy8gY29ycmVzcG9uZGluZyBcIlwiIGF0IHRoZSBlbmQgb2YgdGhlIGZpbGUuXG4gIC8vIElmIHRoZSBmaWxlIGVuZHMgaW4gLywgdGhlbiBpdCBjYW4gb25seSBtYXRjaCBhXG4gIC8vIGEgcGF0dGVybiB0aGF0IGVuZHMgaW4gLywgdW5sZXNzIHRoZSBwYXR0ZXJuIGp1c3RcbiAgLy8gZG9lc24ndCBoYXZlIGFueSBtb3JlIGZvciBpdC4gQnV0LCBhL2IvIHNob3VsZCAqbm90KlxuICAvLyBtYXRjaCBcImEvYi8qXCIsIGV2ZW4gdGhvdWdoIFwiXCIgbWF0Y2hlcyBhZ2FpbnN0IHRoZVxuICAvLyBbXi9dKj8gcGF0dGVybiwgZXhjZXB0IGluIHBhcnRpYWwgbW9kZSwgd2hlcmUgaXQgbWlnaHRcbiAgLy8gc2ltcGx5IG5vdCBiZSByZWFjaGVkIHlldC5cbiAgLy8gSG93ZXZlciwgYS9iLyBzaG91bGQgc3RpbGwgc2F0aXNmeSBhLypcblxuICAvLyBub3cgZWl0aGVyIHdlIGZlbGwgb2ZmIHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4sIG9yIHdlJ3JlIGRvbmUuXG4gIGlmIChmaSA9PT0gZmwgJiYgcGkgPT09IHBsKSB7XG4gICAgLy8gcmFuIG91dCBvZiBwYXR0ZXJuIGFuZCBmaWxlbmFtZSBhdCB0aGUgc2FtZSB0aW1lLlxuICAgIC8vIGFuIGV4YWN0IGhpdCFcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYgKGZpID09PSBmbCkge1xuICAgIC8vIHJhbiBvdXQgb2YgZmlsZSwgYnV0IHN0aWxsIGhhZCBwYXR0ZXJuIGxlZnQuXG4gICAgLy8gdGhpcyBpcyBvayBpZiB3ZSdyZSBkb2luZyB0aGUgbWF0Y2ggYXMgcGFydCBvZlxuICAgIC8vIGEgZ2xvYiBmcyB0cmF2ZXJzYWwuXG4gICAgcmV0dXJuIHBhcnRpYWxcbiAgfSBlbHNlIGlmIChwaSA9PT0gcGwpIHtcbiAgICAvLyByYW4gb3V0IG9mIHBhdHRlcm4sIHN0aWxsIGhhdmUgZmlsZSBsZWZ0LlxuICAgIC8vIHRoaXMgaXMgb25seSBhY2NlcHRhYmxlIGlmIHdlJ3JlIG9uIHRoZSB2ZXJ5IGxhc3RcbiAgICAvLyBlbXB0eSBzZWdtZW50IG9mIGEgZmlsZSB3aXRoIGEgdHJhaWxpbmcgc2xhc2guXG4gICAgLy8gYS8qIHNob3VsZCBtYXRjaCBhL2IvXG4gICAgdmFyIGVtcHR5RmlsZUVuZCA9IChmaSA9PT0gZmwgLSAxKSAmJiAoZmlsZVtmaV0gPT09ICcnKVxuICAgIHJldHVybiBlbXB0eUZpbGVFbmRcbiAgfVxuXG4gIC8vIHNob3VsZCBiZSB1bnJlYWNoYWJsZS5cbiAgdGhyb3cgbmV3IEVycm9yKCd3dGY/Jylcbn1cblxuLy8gcmVwbGFjZSBzdHVmZiBsaWtlIFxcKiB3aXRoICpcbmZ1bmN0aW9uIGdsb2JVbmVzY2FwZSAocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9cXFxcKC4pL2csICckMScpXG59XG5cbmZ1bmN0aW9uIHJlZ0V4cEVzY2FwZSAocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9bLVtcXF17fSgpKis/LixcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbWluaW1hdGNoL21pbmltYXRjaC5qc1xuLy8gbW9kdWxlIGlkID0gMjg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb25jYXRNYXAgPSByZXF1aXJlKCdjb25jYXQtbWFwJyk7XG52YXIgYmFsYW5jZWQgPSByZXF1aXJlKCdiYWxhbmNlZC1tYXRjaCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cGFuZFRvcDtcblxudmFyIGVzY1NsYXNoID0gJ1xcMFNMQVNIJytNYXRoLnJhbmRvbSgpKydcXDAnO1xudmFyIGVzY09wZW4gPSAnXFwwT1BFTicrTWF0aC5yYW5kb20oKSsnXFwwJztcbnZhciBlc2NDbG9zZSA9ICdcXDBDTE9TRScrTWF0aC5yYW5kb20oKSsnXFwwJztcbnZhciBlc2NDb21tYSA9ICdcXDBDT01NQScrTWF0aC5yYW5kb20oKSsnXFwwJztcbnZhciBlc2NQZXJpb2QgPSAnXFwwUEVSSU9EJytNYXRoLnJhbmRvbSgpKydcXDAnO1xuXG5mdW5jdGlvbiBudW1lcmljKHN0cikge1xuICByZXR1cm4gcGFyc2VJbnQoc3RyLCAxMCkgPT0gc3RyXG4gICAgPyBwYXJzZUludChzdHIsIDEwKVxuICAgIDogc3RyLmNoYXJDb2RlQXQoMCk7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZUJyYWNlcyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdCgnXFxcXFxcXFwnKS5qb2luKGVzY1NsYXNoKVxuICAgICAgICAgICAgLnNwbGl0KCdcXFxceycpLmpvaW4oZXNjT3BlbilcbiAgICAgICAgICAgIC5zcGxpdCgnXFxcXH0nKS5qb2luKGVzY0Nsb3NlKVxuICAgICAgICAgICAgLnNwbGl0KCdcXFxcLCcpLmpvaW4oZXNjQ29tbWEpXG4gICAgICAgICAgICAuc3BsaXQoJ1xcXFwuJykuam9pbihlc2NQZXJpb2QpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZUJyYWNlcyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdChlc2NTbGFzaCkuam9pbignXFxcXCcpXG4gICAgICAgICAgICAuc3BsaXQoZXNjT3Blbikuam9pbigneycpXG4gICAgICAgICAgICAuc3BsaXQoZXNjQ2xvc2UpLmpvaW4oJ30nKVxuICAgICAgICAgICAgLnNwbGl0KGVzY0NvbW1hKS5qb2luKCcsJylcbiAgICAgICAgICAgIC5zcGxpdChlc2NQZXJpb2QpLmpvaW4oJy4nKTtcbn1cblxuXG4vLyBCYXNpY2FsbHkganVzdCBzdHIuc3BsaXQoXCIsXCIpLCBidXQgaGFuZGxpbmcgY2FzZXNcbi8vIHdoZXJlIHdlIGhhdmUgbmVzdGVkIGJyYWNlZCBzZWN0aW9ucywgd2hpY2ggc2hvdWxkIGJlXG4vLyB0cmVhdGVkIGFzIGluZGl2aWR1YWwgbWVtYmVycywgbGlrZSB7YSx7YixjfSxkfVxuZnVuY3Rpb24gcGFyc2VDb21tYVBhcnRzKHN0cikge1xuICBpZiAoIXN0cilcbiAgICByZXR1cm4gWycnXTtcblxuICB2YXIgcGFydHMgPSBbXTtcbiAgdmFyIG0gPSBiYWxhbmNlZCgneycsICd9Jywgc3RyKTtcblxuICBpZiAoIW0pXG4gICAgcmV0dXJuIHN0ci5zcGxpdCgnLCcpO1xuXG4gIHZhciBwcmUgPSBtLnByZTtcbiAgdmFyIGJvZHkgPSBtLmJvZHk7XG4gIHZhciBwb3N0ID0gbS5wb3N0O1xuICB2YXIgcCA9IHByZS5zcGxpdCgnLCcpO1xuXG4gIHBbcC5sZW5ndGgtMV0gKz0gJ3snICsgYm9keSArICd9JztcbiAgdmFyIHBvc3RQYXJ0cyA9IHBhcnNlQ29tbWFQYXJ0cyhwb3N0KTtcbiAgaWYgKHBvc3QubGVuZ3RoKSB7XG4gICAgcFtwLmxlbmd0aC0xXSArPSBwb3N0UGFydHMuc2hpZnQoKTtcbiAgICBwLnB1c2guYXBwbHkocCwgcG9zdFBhcnRzKTtcbiAgfVxuXG4gIHBhcnRzLnB1c2guYXBwbHkocGFydHMsIHApO1xuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuZnVuY3Rpb24gZXhwYW5kVG9wKHN0cikge1xuICBpZiAoIXN0cilcbiAgICByZXR1cm4gW107XG5cbiAgLy8gSSBkb24ndCBrbm93IHdoeSBCYXNoIDQuMyBkb2VzIHRoaXMsIGJ1dCBpdCBkb2VzLlxuICAvLyBBbnl0aGluZyBzdGFydGluZyB3aXRoIHt9IHdpbGwgaGF2ZSB0aGUgZmlyc3QgdHdvIGJ5dGVzIHByZXNlcnZlZFxuICAvLyBidXQgKm9ubHkqIGF0IHRoZSB0b3AgbGV2ZWwsIHNvIHt9LGF9YiB3aWxsIG5vdCBleHBhbmQgdG8gYW55dGhpbmcsXG4gIC8vIGJ1dCBhe30sYn1jIHdpbGwgYmUgZXhwYW5kZWQgdG8gW2F9YyxhYmNdLlxuICAvLyBPbmUgY291bGQgYXJndWUgdGhhdCB0aGlzIGlzIGEgYnVnIGluIEJhc2gsIGJ1dCBzaW5jZSB0aGUgZ29hbCBvZlxuICAvLyB0aGlzIG1vZHVsZSBpcyB0byBtYXRjaCBCYXNoJ3MgcnVsZXMsIHdlIGVzY2FwZSBhIGxlYWRpbmcge31cbiAgaWYgKHN0ci5zdWJzdHIoMCwgMikgPT09ICd7fScpIHtcbiAgICBzdHIgPSAnXFxcXHtcXFxcfScgKyBzdHIuc3Vic3RyKDIpO1xuICB9XG5cbiAgcmV0dXJuIGV4cGFuZChlc2NhcGVCcmFjZXMoc3RyKSwgdHJ1ZSkubWFwKHVuZXNjYXBlQnJhY2VzKTtcbn1cblxuZnVuY3Rpb24gaWRlbnRpdHkoZSkge1xuICByZXR1cm4gZTtcbn1cblxuZnVuY3Rpb24gZW1icmFjZShzdHIpIHtcbiAgcmV0dXJuICd7JyArIHN0ciArICd9Jztcbn1cbmZ1bmN0aW9uIGlzUGFkZGVkKGVsKSB7XG4gIHJldHVybiAvXi0/MFxcZC8udGVzdChlbCk7XG59XG5cbmZ1bmN0aW9uIGx0ZShpLCB5KSB7XG4gIHJldHVybiBpIDw9IHk7XG59XG5mdW5jdGlvbiBndGUoaSwgeSkge1xuICByZXR1cm4gaSA+PSB5O1xufVxuXG5mdW5jdGlvbiBleHBhbmQoc3RyLCBpc1RvcCkge1xuICB2YXIgZXhwYW5zaW9ucyA9IFtdO1xuXG4gIHZhciBtID0gYmFsYW5jZWQoJ3snLCAnfScsIHN0cik7XG4gIGlmICghbSB8fCAvXFwkJC8udGVzdChtLnByZSkpIHJldHVybiBbc3RyXTtcblxuICB2YXIgaXNOdW1lcmljU2VxdWVuY2UgPSAvXi0/XFxkK1xcLlxcLi0/XFxkKyg/OlxcLlxcLi0/XFxkKyk/JC8udGVzdChtLmJvZHkpO1xuICB2YXIgaXNBbHBoYVNlcXVlbmNlID0gL15bYS16QS1aXVxcLlxcLlthLXpBLVpdKD86XFwuXFwuLT9cXGQrKT8kLy50ZXN0KG0uYm9keSk7XG4gIHZhciBpc1NlcXVlbmNlID0gaXNOdW1lcmljU2VxdWVuY2UgfHwgaXNBbHBoYVNlcXVlbmNlO1xuICB2YXIgaXNPcHRpb25zID0gL14oLiosKSsoLispPyQvLnRlc3QobS5ib2R5KTtcbiAgaWYgKCFpc1NlcXVlbmNlICYmICFpc09wdGlvbnMpIHtcbiAgICAvLyB7YX0sYn1cbiAgICBpZiAobS5wb3N0Lm1hdGNoKC8sLipcXH0vKSkge1xuICAgICAgc3RyID0gbS5wcmUgKyAneycgKyBtLmJvZHkgKyBlc2NDbG9zZSArIG0ucG9zdDtcbiAgICAgIHJldHVybiBleHBhbmQoc3RyKTtcbiAgICB9XG4gICAgcmV0dXJuIFtzdHJdO1xuICB9XG5cbiAgdmFyIG47XG4gIGlmIChpc1NlcXVlbmNlKSB7XG4gICAgbiA9IG0uYm9keS5zcGxpdCgvXFwuXFwuLyk7XG4gIH0gZWxzZSB7XG4gICAgbiA9IHBhcnNlQ29tbWFQYXJ0cyhtLmJvZHkpO1xuICAgIGlmIChuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8geHt7YSxifX15ID09PiB4e2F9eSB4e2J9eVxuICAgICAgbiA9IGV4cGFuZChuWzBdLCBmYWxzZSkubWFwKGVtYnJhY2UpO1xuICAgICAgaWYgKG4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhciBwb3N0ID0gbS5wb3N0Lmxlbmd0aFxuICAgICAgICAgID8gZXhwYW5kKG0ucG9zdCwgZmFsc2UpXG4gICAgICAgICAgOiBbJyddO1xuICAgICAgICByZXR1cm4gcG9zdC5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHJldHVybiBtLnByZSArIG5bMF0gKyBwO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBhdCB0aGlzIHBvaW50LCBuIGlzIHRoZSBwYXJ0cywgYW5kIHdlIGtub3cgaXQncyBub3QgYSBjb21tYSBzZXRcbiAgLy8gd2l0aCBhIHNpbmdsZSBlbnRyeS5cblxuICAvLyBubyBuZWVkIHRvIGV4cGFuZCBwcmUsIHNpbmNlIGl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgZnJlZSBvZiBicmFjZS1zZXRzXG4gIHZhciBwcmUgPSBtLnByZTtcbiAgdmFyIHBvc3QgPSBtLnBvc3QubGVuZ3RoXG4gICAgPyBleHBhbmQobS5wb3N0LCBmYWxzZSlcbiAgICA6IFsnJ107XG5cbiAgdmFyIE47XG5cbiAgaWYgKGlzU2VxdWVuY2UpIHtcbiAgICB2YXIgeCA9IG51bWVyaWMoblswXSk7XG4gICAgdmFyIHkgPSBudW1lcmljKG5bMV0pO1xuICAgIHZhciB3aWR0aCA9IE1hdGgubWF4KG5bMF0ubGVuZ3RoLCBuWzFdLmxlbmd0aClcbiAgICB2YXIgaW5jciA9IG4ubGVuZ3RoID09IDNcbiAgICAgID8gTWF0aC5hYnMobnVtZXJpYyhuWzJdKSlcbiAgICAgIDogMTtcbiAgICB2YXIgdGVzdCA9IGx0ZTtcbiAgICB2YXIgcmV2ZXJzZSA9IHkgPCB4O1xuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBpbmNyICo9IC0xO1xuICAgICAgdGVzdCA9IGd0ZTtcbiAgICB9XG4gICAgdmFyIHBhZCA9IG4uc29tZShpc1BhZGRlZCk7XG5cbiAgICBOID0gW107XG5cbiAgICBmb3IgKHZhciBpID0geDsgdGVzdChpLCB5KTsgaSArPSBpbmNyKSB7XG4gICAgICB2YXIgYztcbiAgICAgIGlmIChpc0FscGhhU2VxdWVuY2UpIHtcbiAgICAgICAgYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG4gICAgICAgIGlmIChjID09PSAnXFxcXCcpXG4gICAgICAgICAgYyA9ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYyA9IFN0cmluZyhpKTtcbiAgICAgICAgaWYgKHBhZCkge1xuICAgICAgICAgIHZhciBuZWVkID0gd2lkdGggLSBjLmxlbmd0aDtcbiAgICAgICAgICBpZiAobmVlZCA+IDApIHtcbiAgICAgICAgICAgIHZhciB6ID0gbmV3IEFycmF5KG5lZWQgKyAxKS5qb2luKCcwJyk7XG4gICAgICAgICAgICBpZiAoaSA8IDApXG4gICAgICAgICAgICAgIGMgPSAnLScgKyB6ICsgYy5zbGljZSgxKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYyA9IHogKyBjO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgTi5wdXNoKGMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBOID0gY29uY2F0TWFwKG4sIGZ1bmN0aW9uKGVsKSB7IHJldHVybiBleHBhbmQoZWwsIGZhbHNlKSB9KTtcbiAgfVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgTi5sZW5ndGg7IGorKykge1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcG9zdC5sZW5ndGg7IGsrKykge1xuICAgICAgdmFyIGV4cGFuc2lvbiA9IHByZSArIE5bal0gKyBwb3N0W2tdO1xuICAgICAgaWYgKCFpc1RvcCB8fCBpc1NlcXVlbmNlIHx8IGV4cGFuc2lvbilcbiAgICAgICAgZXhwYW5zaW9ucy5wdXNoKGV4cGFuc2lvbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cGFuc2lvbnM7XG59XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9icmFjZS1leHBhbnNpb24vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh4cywgZm4pIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgeCA9IGZuKHhzW2ldLCBpKTtcbiAgICAgICAgaWYgKGlzQXJyYXkoeCkpIHJlcy5wdXNoLmFwcGx5KHJlcywgeCk7XG4gICAgICAgIGVsc2UgcmVzLnB1c2goeCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2NvbmNhdC1tYXAvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGJhbGFuY2VkO1xuZnVuY3Rpb24gYmFsYW5jZWQoYSwgYiwgc3RyKSB7XG4gIGlmIChhIGluc3RhbmNlb2YgUmVnRXhwKSBhID0gbWF5YmVNYXRjaChhLCBzdHIpO1xuICBpZiAoYiBpbnN0YW5jZW9mIFJlZ0V4cCkgYiA9IG1heWJlTWF0Y2goYiwgc3RyKTtcblxuICB2YXIgciA9IHJhbmdlKGEsIGIsIHN0cik7XG5cbiAgcmV0dXJuIHIgJiYge1xuICAgIHN0YXJ0OiByWzBdLFxuICAgIGVuZDogclsxXSxcbiAgICBwcmU6IHN0ci5zbGljZSgwLCByWzBdKSxcbiAgICBib2R5OiBzdHIuc2xpY2UoclswXSArIGEubGVuZ3RoLCByWzFdKSxcbiAgICBwb3N0OiBzdHIuc2xpY2UoclsxXSArIGIubGVuZ3RoKVxuICB9O1xufVxuXG5mdW5jdGlvbiBtYXliZU1hdGNoKHJlZywgc3RyKSB7XG4gIHZhciBtID0gc3RyLm1hdGNoKHJlZyk7XG4gIHJldHVybiBtID8gbVswXSA6IG51bGw7XG59XG5cbmJhbGFuY2VkLnJhbmdlID0gcmFuZ2U7XG5mdW5jdGlvbiByYW5nZShhLCBiLCBzdHIpIHtcbiAgdmFyIGJlZ3MsIGJlZywgbGVmdCwgcmlnaHQsIHJlc3VsdDtcbiAgdmFyIGFpID0gc3RyLmluZGV4T2YoYSk7XG4gIHZhciBiaSA9IHN0ci5pbmRleE9mKGIsIGFpICsgMSk7XG4gIHZhciBpID0gYWk7XG5cbiAgaWYgKGFpID49IDAgJiYgYmkgPiAwKSB7XG4gICAgYmVncyA9IFtdO1xuICAgIGxlZnQgPSBzdHIubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGkgPj0gMCAmJiAhcmVzdWx0KSB7XG4gICAgICBpZiAoaSA9PSBhaSkge1xuICAgICAgICBiZWdzLnB1c2goaSk7XG4gICAgICAgIGFpID0gc3RyLmluZGV4T2YoYSwgaSArIDEpO1xuICAgICAgfSBlbHNlIGlmIChiZWdzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHJlc3VsdCA9IFsgYmVncy5wb3AoKSwgYmkgXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJlZyA9IGJlZ3MucG9wKCk7XG4gICAgICAgIGlmIChiZWcgPCBsZWZ0KSB7XG4gICAgICAgICAgbGVmdCA9IGJlZztcbiAgICAgICAgICByaWdodCA9IGJpO1xuICAgICAgICB9XG5cbiAgICAgICAgYmkgPSBzdHIuaW5kZXhPZihiLCBpICsgMSk7XG4gICAgICB9XG5cbiAgICAgIGkgPSBhaSA8IGJpICYmIGFpID49IDAgPyBhaSA6IGJpO1xuICAgIH1cblxuICAgIGlmIChiZWdzLmxlbmd0aCkge1xuICAgICAgcmVzdWx0ID0gWyBsZWZ0LCByaWdodCBdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vYmFsYW5jZWQtbWF0Y2gvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicgPyBzZXRJbW1lZGlhdGUgOlxuXHRmdW5jdGlvbiBzZXRJbW1lZGlhdGUoKSB7XG5cdFx0dmFyIGFyZ3MgPSBbXS5zbGljZS5hcHBseShhcmd1bWVudHMpO1xuXHRcdGFyZ3Muc3BsaWNlKDEsIDAsIDApO1xuXHRcdHNldFRpbWVvdXQuYXBwbHkobnVsbCwgYXJncyk7XG5cdH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2V0LWltbWVkaWF0ZS1zaGltL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2kgPSAgcmVxdWlyZSgnc2V0LWltbWVkaWF0ZS1zaGltJyk7XG52YXIgc3RyZWFtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIFJlYWRhYmxlID0gc3RyZWFtLlJlYWRhYmxlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRkaXJwUmVhZGFibGU7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGRpcnBSZWFkYWJsZSwgUmVhZGFibGUpO1xuXG5mdW5jdGlvbiBSZWFkZGlycFJlYWRhYmxlIChvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkZGlycFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkZGlycFJlYWRhYmxlKG9wdHMpO1xuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIG9wdHMub2JqZWN0TW9kZSA9IHRydWU7XG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgLy8gYmFja3ByZXNzdXJlIG5vdCBpbXBsZW1lbnRlZCBhdCB0aGlzIHBvaW50XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IEluZmluaXR5O1xuXG4gIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgdGhpcy5fd2FybmluZ3MgPSBbXTtcbiAgdGhpcy5fZXJyb3JzID0gW107XG5cbiAgdGhpcy5fcGF1c2VSZXN1bWVFcnJvcnMoKTtcbn1cblxudmFyIHByb3RvID0gUmVhZGRpcnBSZWFkYWJsZS5wcm90b3R5cGU7XG5cbnByb3RvLl9wYXVzZVJlc3VtZUVycm9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLm9uKCdwYXVzZScsIGZ1bmN0aW9uICgpIHsgc2VsZi5fcGF1c2VkID0gdHJ1ZSB9KTtcbiAgc2VsZi5vbigncmVzdW1lJywgZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxmLl9kZXN0cm95ZWQpIHJldHVybjtcbiAgICBzZWxmLl9wYXVzZWQgPSBmYWxzZTtcblxuICAgIHNlbGYuX3dhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGVycikgeyBzZWxmLmVtaXQoJ3dhcm4nLCBlcnIpIH0pO1xuICAgIHNlbGYuX3dhcm5pbmdzLmxlbmd0aCA9IDA7XG5cbiAgICBzZWxmLl9lcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZXJyKSB7IHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpIH0pO1xuICAgIHNlbGYuX2Vycm9ycy5sZW5ndGggPSAwO1xuICB9KVxufVxuXG4vLyBjYWxsZWQgZm9yIGVhY2ggZW50cnlcbnByb3RvLl9wcm9jZXNzRW50cnkgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkgcmV0dXJuO1xuICB0aGlzLnB1c2goZW50cnkpO1xufVxuXG5wcm90by5fcmVhZCA9IGZ1bmN0aW9uICgpIHsgfVxuXG5wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAvLyB3aGVuIHN0cmVhbSBpcyBkZXN0cm95ZWQgaXQgd2lsbCBlbWl0IG5vdGhpbmcgZnVydGhlciwgbm90IGV2ZW4gZXJyb3JzIG9yIHdhcm5pbmdzXG4gIHRoaXMucHVzaChudWxsKTtcbiAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG59XG5cbnByb3RvLl9kb25lID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnB1c2gobnVsbCk7XG59XG5cbi8vIHdlIGVtaXQgZXJyb3JzIGFuZCB3YXJuaW5ncyBhc3luYyBzaW5jZSB3ZSBtYXkgaGFuZGxlIGVycm9ycyBsaWtlIGludmFsaWQgYXJnc1xuLy8gd2l0aGluIHRoZSBpbml0aWFsIGV2ZW50IGxvb3AgYmVmb3JlIGFueSBldmVudCBsaXN0ZW5lcnMgc3Vic2NyaWJlZFxucHJvdG8uX2hhbmRsZUVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNpKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZi5fcGF1c2VkKSByZXR1cm4gc2VsZi5fd2FybmluZ3MucHVzaChlcnIpO1xuICAgIGlmICghc2VsZi5fZGVzdHJveWVkKSBzZWxmLmVtaXQoJ3dhcm4nLCBlcnIpO1xuICB9KTtcbn1cblxucHJvdG8uX2hhbmRsZUZhdGFsRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2koZnVuY3Rpb24gKCkge1xuICAgIGlmIChzZWxmLl9wYXVzZWQpIHJldHVybiBzZWxmLl9lcnJvcnMucHVzaChlcnIpO1xuICAgIGlmICghc2VsZi5fZGVzdHJveWVkKSBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbUFQSSAoKSB7XG4gIHZhciBzdHJlYW0gPSBuZXcgUmVhZGRpcnBSZWFkYWJsZSgpO1xuXG4gIHJldHVybiB7XG4gICAgICBzdHJlYW0gICAgICAgICAgIDogIHN0cmVhbVxuICAgICwgcHJvY2Vzc0VudHJ5ICAgICA6ICBzdHJlYW0uX3Byb2Nlc3NFbnRyeS5iaW5kKHN0cmVhbSlcbiAgICAsIGRvbmUgICAgICAgICAgICAgOiAgc3RyZWFtLl9kb25lLmJpbmQoc3RyZWFtKVxuICAgICwgaGFuZGxlRXJyb3IgICAgICA6ICBzdHJlYW0uX2hhbmRsZUVycm9yLmJpbmQoc3RyZWFtKVxuICAgICwgaGFuZGxlRmF0YWxFcnJvciA6ICBzdHJlYW0uX2hhbmRsZUZhdGFsRXJyb3IuYmluZChzdHJlYW0pXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlU3RyZWFtQVBJO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3JlYWRkaXJwL3N0cmVhbS1hcGkuanNcbi8vIG1vZHVsZSBpZCA9IDI5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBiaW5hcnlFeHRlbnNpb25zID0gcmVxdWlyZSgnYmluYXJ5LWV4dGVuc2lvbnMnKTtcbnZhciBleHRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuYmluYXJ5RXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuXHRleHRzW2VsXSA9IHRydWU7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZmlsZXBhdGgpIHtcblx0cmV0dXJuIHBhdGguZXh0bmFtZShmaWxlcGF0aCkuc2xpY2UoMSkudG9Mb3dlckNhc2UoKSBpbiBleHRzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9pcy1iaW5hcnktcGF0aC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIltcblx0XCIzZHNcIixcblx0XCIzZzJcIixcblx0XCIzZ3BcIixcblx0XCI3elwiLFxuXHRcImFcIixcblx0XCJhYWNcIixcblx0XCJhZHBcIixcblx0XCJhaVwiLFxuXHRcImFpZlwiLFxuXHRcImFpZmZcIixcblx0XCJhbHpcIixcblx0XCJhcGVcIixcblx0XCJhcGtcIixcblx0XCJhclwiLFxuXHRcImFyalwiLFxuXHRcImFzZlwiLFxuXHRcImF1XCIsXG5cdFwiYXZpXCIsXG5cdFwiYmFrXCIsXG5cdFwiYmhcIixcblx0XCJiaW5cIixcblx0XCJia1wiLFxuXHRcImJtcFwiLFxuXHRcImJ0aWZcIixcblx0XCJiejJcIixcblx0XCJiemlwMlwiLFxuXHRcImNhYlwiLFxuXHRcImNhZlwiLFxuXHRcImNnbVwiLFxuXHRcImNsYXNzXCIsXG5cdFwiY214XCIsXG5cdFwiY3Bpb1wiLFxuXHRcImNyMlwiLFxuXHRcImNzdlwiLFxuXHRcImN1clwiLFxuXHRcImRhdFwiLFxuXHRcImRlYlwiLFxuXHRcImRleFwiLFxuXHRcImRqdnVcIixcblx0XCJkbGxcIixcblx0XCJkbWdcIixcblx0XCJkbmdcIixcblx0XCJkb2NcIixcblx0XCJkb2NtXCIsXG5cdFwiZG9jeFwiLFxuXHRcImRvdFwiLFxuXHRcImRvdG1cIixcblx0XCJkcmFcIixcblx0XCJEU19TdG9yZVwiLFxuXHRcImRza1wiLFxuXHRcImR0c1wiLFxuXHRcImR0c2hkXCIsXG5cdFwiZHZiXCIsXG5cdFwiZHdnXCIsXG5cdFwiZHhmXCIsXG5cdFwiZWNlbHA0ODAwXCIsXG5cdFwiZWNlbHA3NDcwXCIsXG5cdFwiZWNlbHA5NjAwXCIsXG5cdFwiZWdnXCIsXG5cdFwiZW9sXCIsXG5cdFwiZW90XCIsXG5cdFwiZXB1YlwiLFxuXHRcImV4ZVwiLFxuXHRcImY0dlwiLFxuXHRcImZic1wiLFxuXHRcImZoXCIsXG5cdFwiZmxhXCIsXG5cdFwiZmxhY1wiLFxuXHRcImZsaVwiLFxuXHRcImZsdlwiLFxuXHRcImZweFwiLFxuXHRcImZzdFwiLFxuXHRcImZ2dFwiLFxuXHRcImczXCIsXG5cdFwiZ2lmXCIsXG5cdFwiZ3JhZmZsZVwiLFxuXHRcImd6XCIsXG5cdFwiZ3ppcFwiLFxuXHRcImgyNjFcIixcblx0XCJoMjYzXCIsXG5cdFwiaDI2NFwiLFxuXHRcImljb1wiLFxuXHRcImllZlwiLFxuXHRcImltZ1wiLFxuXHRcImlwYVwiLFxuXHRcImlzb1wiLFxuXHRcImphclwiLFxuXHRcImpwZWdcIixcblx0XCJqcGdcIixcblx0XCJqcGd2XCIsXG5cdFwianBtXCIsXG5cdFwianhyXCIsXG5cdFwia2V5XCIsXG5cdFwia3R4XCIsXG5cdFwibGhhXCIsXG5cdFwibHZwXCIsXG5cdFwibHpcIixcblx0XCJsemhcIixcblx0XCJsem1hXCIsXG5cdFwibHpvXCIsXG5cdFwibTN1XCIsXG5cdFwibTRhXCIsXG5cdFwibTR2XCIsXG5cdFwibWFyXCIsXG5cdFwibWRpXCIsXG5cdFwibWh0XCIsXG5cdFwibWlkXCIsXG5cdFwibWlkaVwiLFxuXHRcIm1qMlwiLFxuXHRcIm1rYVwiLFxuXHRcIm1rdlwiLFxuXHRcIm1tclwiLFxuXHRcIm1uZ1wiLFxuXHRcIm1vYmlcIixcblx0XCJtb3ZcIixcblx0XCJtb3ZpZVwiLFxuXHRcIm1wM1wiLFxuXHRcIm1wNFwiLFxuXHRcIm1wNGFcIixcblx0XCJtcGVnXCIsXG5cdFwibXBnXCIsXG5cdFwibXBnYVwiLFxuXHRcIm14dVwiLFxuXHRcIm5lZlwiLFxuXHRcIm5weFwiLFxuXHRcIm51bWJlcnNcIixcblx0XCJvXCIsXG5cdFwib2dhXCIsXG5cdFwib2dnXCIsXG5cdFwib2d2XCIsXG5cdFwib3RmXCIsXG5cdFwicGFnZXNcIixcblx0XCJwYm1cIixcblx0XCJwY3hcIixcblx0XCJwZGZcIixcblx0XCJwZWFcIixcblx0XCJwZ21cIixcblx0XCJwaWNcIixcblx0XCJwbmdcIixcblx0XCJwbm1cIixcblx0XCJwb3RcIixcblx0XCJwb3RtXCIsXG5cdFwicG90eFwiLFxuXHRcInBwYVwiLFxuXHRcInBwYW1cIixcblx0XCJwcG1cIixcblx0XCJwcHNcIixcblx0XCJwcHNtXCIsXG5cdFwicHBzeFwiLFxuXHRcInBwdFwiLFxuXHRcInBwdG1cIixcblx0XCJwcHR4XCIsXG5cdFwicHNkXCIsXG5cdFwicHlhXCIsXG5cdFwicHljXCIsXG5cdFwicHlvXCIsXG5cdFwicHl2XCIsXG5cdFwicXRcIixcblx0XCJyYXJcIixcblx0XCJyYXNcIixcblx0XCJyYXdcIixcblx0XCJyZ2JcIixcblx0XCJyaXBcIixcblx0XCJybGNcIixcblx0XCJybWZcIixcblx0XCJybXZiXCIsXG5cdFwicnRmXCIsXG5cdFwicnpcIixcblx0XCJzM21cIixcblx0XCJzN3pcIixcblx0XCJzY3B0XCIsXG5cdFwic2dpXCIsXG5cdFwic2hhclwiLFxuXHRcInNpbFwiLFxuXHRcInNrZXRjaFwiLFxuXHRcInNsa1wiLFxuXHRcInNtdlwiLFxuXHRcInNvXCIsXG5cdFwic3ViXCIsXG5cdFwic3dmXCIsXG5cdFwidGFyXCIsXG5cdFwidGJ6XCIsXG5cdFwidGJ6MlwiLFxuXHRcInRnYVwiLFxuXHRcInRnelwiLFxuXHRcInRobXhcIixcblx0XCJ0aWZcIixcblx0XCJ0aWZmXCIsXG5cdFwidGx6XCIsXG5cdFwidHRjXCIsXG5cdFwidHRmXCIsXG5cdFwidHh6XCIsXG5cdFwidWRmXCIsXG5cdFwidXZoXCIsXG5cdFwidXZpXCIsXG5cdFwidXZtXCIsXG5cdFwidXZwXCIsXG5cdFwidXZzXCIsXG5cdFwidXZ1XCIsXG5cdFwidml2XCIsXG5cdFwidm9iXCIsXG5cdFwid2FyXCIsXG5cdFwid2F2XCIsXG5cdFwid2F4XCIsXG5cdFwid2JtcFwiLFxuXHRcIndkcFwiLFxuXHRcIndlYmFcIixcblx0XCJ3ZWJtXCIsXG5cdFwid2VicFwiLFxuXHRcIndobFwiLFxuXHRcIndpbVwiLFxuXHRcIndtXCIsXG5cdFwid21hXCIsXG5cdFwid212XCIsXG5cdFwid214XCIsXG5cdFwid29mZlwiLFxuXHRcIndvZmYyXCIsXG5cdFwid3Z4XCIsXG5cdFwieGJtXCIsXG5cdFwieGlmXCIsXG5cdFwieGxhXCIsXG5cdFwieGxhbVwiLFxuXHRcInhsc1wiLFxuXHRcInhsc2JcIixcblx0XCJ4bHNtXCIsXG5cdFwieGxzeFwiLFxuXHRcInhsdFwiLFxuXHRcInhsdG1cIixcblx0XCJ4bHR4XCIsXG5cdFwieG1cIixcblx0XCJ4bWluZFwiLFxuXHRcInhwaVwiLFxuXHRcInhwbVwiLFxuXHRcInh3ZFwiLFxuXHRcInh6XCIsXG5cdFwielwiLFxuXHRcInppcFwiLFxuXHRcInppcHhcIlxuXVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JpbmFyeS1leHRlbnNpb25zL2JpbmFyeS1leHRlbnNpb25zLmpzb25cbi8vIG1vZHVsZSBpZCA9IDI5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgc3lzUGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciByZWFkZGlycCA9IHJlcXVpcmUoJ3JlYWRkaXJwJyk7XG52YXIgZnNldmVudHM7XG50cnkgeyBmc2V2ZW50cyA9IHJlcXVpcmUoJ2ZzZXZlbnRzJyk7IH0gY2F0Y2ggKGVycm9yKSB7fVxuXG4vLyBmc2V2ZW50cyBpbnN0YW5jZSBoZWxwZXIgZnVuY3Rpb25zXG5cbi8vIG9iamVjdCB0byBob2xkIHBlci1wcm9jZXNzIGZzZXZlbnRzIGluc3RhbmNlc1xuLy8gKG1heSBiZSBzaGFyZWQgYWNyb3NzIGNob2tpZGFyIEZTV2F0Y2hlciBpbnN0YW5jZXMpXG52YXIgRlNFdmVudHNXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbi8vIFRocmVzaG9sZCBvZiBkdXBsaWNhdGUgcGF0aCBwcmVmaXhlcyBhdCB3aGljaCB0byBzdGFydFxuLy8gY29uc29saWRhdGluZyBnb2luZyBmb3J3YXJkXG52YXIgY29uc29saWRhdGVUaHJlc2hob2xkID0gMTA7XG5cbi8vIFByaXZhdGUgZnVuY3Rpb246IEluc3RhbnRpYXRlcyB0aGUgZnNldmVudHMgaW50ZXJmYWNlXG5cbi8vICogcGF0aCAgICAgICAtIHN0cmluZywgcGF0aCB0byBiZSB3YXRjaGVkXG4vLyAqIGNhbGxiYWNrICAgLSBmdW5jdGlvbiwgY2FsbGVkIHdoZW4gZnNldmVudHMgaXMgYm91bmQgYW5kIHJlYWR5XG5cbi8vIFJldHVybnMgbmV3IGZzZXZlbnRzIGluc3RhbmNlXG5mdW5jdGlvbiBjcmVhdGVGU0V2ZW50c0luc3RhbmNlKHBhdGgsIGNhbGxiYWNrKSB7XG4gIHJldHVybiAobmV3IGZzZXZlbnRzKHBhdGgpKS5vbignZnNldmVudCcsIGNhbGxiYWNrKS5zdGFydCgpO1xufVxuXG4vLyBQcml2YXRlIGZ1bmN0aW9uOiBJbnN0YW50aWF0ZXMgdGhlIGZzZXZlbnRzIGludGVyZmFjZSBvciBiaW5kcyBsaXN0ZW5lcnNcbi8vIHRvIGFuIGV4aXN0aW5nIG9uZSBjb3ZlcmluZyB0aGUgc2FtZSBmaWxlIHRyZWVcblxuLy8gKiBwYXRoICAgICAgIC0gc3RyaW5nLCBwYXRoIHRvIGJlIHdhdGNoZWRcbi8vICogcmVhbFBhdGggICAtIHN0cmluZywgcmVhbCBwYXRoIChpbiBjYXNlIG9mIHN5bWxpbmtzKVxuLy8gKiBsaXN0ZW5lciAgIC0gZnVuY3Rpb24sIGNhbGxlZCB3aGVuIGZzZXZlbnRzIGVtaXRzIGV2ZW50c1xuLy8gKiByYXdFbWl0dGVyIC0gZnVuY3Rpb24sIHBhc3NlcyBkYXRhIHRvIGxpc3RlbmVycyBvZiB0aGUgJ3JhdycgZXZlbnRcblxuLy8gUmV0dXJucyBjbG9zZSBmdW5jdGlvblxuZnVuY3Rpb24gc2V0RlNFdmVudHNMaXN0ZW5lcihwYXRoLCByZWFsUGF0aCwgbGlzdGVuZXIsIHJhd0VtaXR0ZXIpIHtcbiAgdmFyIHdhdGNoUGF0aCA9IHN5c1BhdGguZXh0bmFtZShwYXRoKSA/IHN5c1BhdGguZGlybmFtZShwYXRoKSA6IHBhdGg7XG4gIHZhciB3YXRjaENvbnRhaW5lcjtcbiAgdmFyIHBhcmVudFBhdGggPSBzeXNQYXRoLmRpcm5hbWUod2F0Y2hQYXRoKTtcblxuICAvLyBJZiB3ZSd2ZSBhY2N1bXVsYXRlZCBhIHN1YnN0YW50aWFsIG51bWJlciBvZiBwYXRocyB0aGF0XG4gIC8vIGNvdWxkIGhhdmUgYmVlbiBjb25zb2xpZGF0ZWQgYnkgd2F0Y2hpbmcgb25lIGRpcmVjdG9yeVxuICAvLyBhYm92ZSB0aGUgY3VycmVudCBvbmUsIGNyZWF0ZSBhIHdhdGNoZXIgb24gdGhlIHBhcmVudFxuICAvLyBwYXRoIGluc3RlYWQsIHNvIHRoYXQgd2UgZG8gY29uc29saWRhdGUgZ29pbmcgZm9yd2FyZC5cbiAgaWYgKGNvdWxkQ29uc29saWRhdGUocGFyZW50UGF0aCkpIHtcbiAgICB3YXRjaFBhdGggPSBwYXJlbnRQYXRoO1xuICB9XG5cbiAgdmFyIHJlc29sdmVkUGF0aCA9IHN5c1BhdGgucmVzb2x2ZShwYXRoKTtcbiAgdmFyIGhhc1N5bWxpbmsgPSByZXNvbHZlZFBhdGggIT09IHJlYWxQYXRoO1xuICBmdW5jdGlvbiBmaWx0ZXJlZExpc3RlbmVyKGZ1bGxQYXRoLCBmbGFncywgaW5mbykge1xuICAgIGlmIChoYXNTeW1saW5rKSBmdWxsUGF0aCA9IGZ1bGxQYXRoLnJlcGxhY2UocmVhbFBhdGgsIHJlc29sdmVkUGF0aCk7XG4gICAgaWYgKFxuICAgICAgZnVsbFBhdGggPT09IHJlc29sdmVkUGF0aCB8fFxuICAgICAgIWZ1bGxQYXRoLmluZGV4T2YocmVzb2x2ZWRQYXRoICsgc3lzUGF0aC5zZXApXG4gICAgKSBsaXN0ZW5lcihmdWxsUGF0aCwgZmxhZ3MsIGluZm8pO1xuICB9XG5cbiAgLy8gY2hlY2sgaWYgdGhlcmUgaXMgYWxyZWFkeSBhIHdhdGNoZXIgb24gYSBwYXJlbnQgcGF0aFxuICAvLyBtb2RpZmllcyBgd2F0Y2hQYXRoYCB0byB0aGUgcGFyZW50IHBhdGggd2hlbiBpdCBmaW5kcyBhIG1hdGNoXG4gIGZ1bmN0aW9uIHdhdGNoZWRQYXJlbnQoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKEZTRXZlbnRzV2F0Y2hlcnMpLnNvbWUoZnVuY3Rpb24od2F0Y2hlZFBhdGgpIHtcbiAgICAgIC8vIGNvbmRpdGlvbiBpcyBtZXQgd2hlbiBpbmRleE9mIHJldHVybnMgMFxuICAgICAgaWYgKCFyZWFsUGF0aC5pbmRleE9mKHN5c1BhdGgucmVzb2x2ZSh3YXRjaGVkUGF0aCkgKyBzeXNQYXRoLnNlcCkpIHtcbiAgICAgICAgd2F0Y2hQYXRoID0gd2F0Y2hlZFBhdGg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHdhdGNoUGF0aCBpbiBGU0V2ZW50c1dhdGNoZXJzIHx8IHdhdGNoZWRQYXJlbnQoKSkge1xuICAgIHdhdGNoQ29udGFpbmVyID0gRlNFdmVudHNXYXRjaGVyc1t3YXRjaFBhdGhdO1xuICAgIHdhdGNoQ29udGFpbmVyLmxpc3RlbmVycy5wdXNoKGZpbHRlcmVkTGlzdGVuZXIpO1xuICB9IGVsc2Uge1xuICAgIHdhdGNoQ29udGFpbmVyID0gRlNFdmVudHNXYXRjaGVyc1t3YXRjaFBhdGhdID0ge1xuICAgICAgbGlzdGVuZXJzOiBbZmlsdGVyZWRMaXN0ZW5lcl0sXG4gICAgICByYXdFbWl0dGVyczogW3Jhd0VtaXR0ZXJdLFxuICAgICAgd2F0Y2hlcjogY3JlYXRlRlNFdmVudHNJbnN0YW5jZSh3YXRjaFBhdGgsIGZ1bmN0aW9uKGZ1bGxQYXRoLCBmbGFncykge1xuICAgICAgICB2YXIgaW5mbyA9IGZzZXZlbnRzLmdldEluZm8oZnVsbFBhdGgsIGZsYWdzKTtcbiAgICAgICAgd2F0Y2hDb250YWluZXIubGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICAgICAgICBsaXN0ZW5lcihmdWxsUGF0aCwgZmxhZ3MsIGluZm8pO1xuICAgICAgICB9KTtcbiAgICAgICAgd2F0Y2hDb250YWluZXIucmF3RW1pdHRlcnMuZm9yRWFjaChmdW5jdGlvbihlbWl0dGVyKSB7XG4gICAgICAgICAgZW1pdHRlcihpbmZvLmV2ZW50LCBmdWxsUGF0aCwgaW5mbyk7XG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHZhciBsaXN0ZW5lckluZGV4ID0gd2F0Y2hDb250YWluZXIubGlzdGVuZXJzLmxlbmd0aCAtIDE7XG5cbiAgLy8gcmVtb3ZlcyB0aGlzIGluc3RhbmNlJ3MgbGlzdGVuZXJzIGFuZCBjbG9zZXMgdGhlIHVuZGVybHlpbmcgZnNldmVudHNcbiAgLy8gaW5zdGFuY2UgaWYgdGhlcmUgYXJlIG5vIG1vcmUgbGlzdGVuZXJzIGxlZnRcbiAgcmV0dXJuIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGRlbGV0ZSB3YXRjaENvbnRhaW5lci5saXN0ZW5lcnNbbGlzdGVuZXJJbmRleF07XG4gICAgZGVsZXRlIHdhdGNoQ29udGFpbmVyLnJhd0VtaXR0ZXJzW2xpc3RlbmVySW5kZXhdO1xuICAgIGlmICghT2JqZWN0LmtleXMod2F0Y2hDb250YWluZXIubGlzdGVuZXJzKS5sZW5ndGgpIHtcbiAgICAgIHdhdGNoQ29udGFpbmVyLndhdGNoZXIuc3RvcCgpO1xuICAgICAgZGVsZXRlIEZTRXZlbnRzV2F0Y2hlcnNbd2F0Y2hQYXRoXTtcbiAgICB9XG4gIH07XG59XG5cbi8vIERlY2lkZSB3aGV0aGVyIG9yIG5vdCB3ZSBzaG91bGQgc3RhcnQgYSBuZXcgaGlnaGVyLWxldmVsXG4vLyBwYXJlbnQgd2F0Y2hlclxuZnVuY3Rpb24gY291bGRDb25zb2xpZGF0ZShwYXRoKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoRlNFdmVudHNXYXRjaGVycyk7XG4gIHZhciBjb3VudCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgd2F0Y2hQYXRoID0ga2V5c1tpXTtcbiAgICBpZiAod2F0Y2hQYXRoLmluZGV4T2YocGF0aCkgPT09IDApIHtcbiAgICAgIGNvdW50Kys7XG4gICAgICBpZiAoY291bnQgPj0gY29uc29saWRhdGVUaHJlc2hob2xkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gcmV0dXJucyBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBmc2V2ZW50cyBjYW4gYmUgdXNlZFxuZnVuY3Rpb24gY2FuVXNlKCkge1xuICByZXR1cm4gZnNldmVudHMgJiYgT2JqZWN0LmtleXMoRlNFdmVudHNXYXRjaGVycykubGVuZ3RoIDwgMTI4O1xufVxuXG4vLyBkZXRlcm1pbmVzIHN1YmRpcmVjdG9yeSB0cmF2ZXJzYWwgbGV2ZWxzIGZyb20gcm9vdCB0byBwYXRoXG5mdW5jdGlvbiBkZXB0aChwYXRoLCByb290KSB7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKCFwYXRoLmluZGV4T2Yocm9vdCkgJiYgKHBhdGggPSBzeXNQYXRoLmRpcm5hbWUocGF0aCkpICE9PSByb290KSBpKys7XG4gIHJldHVybiBpO1xufVxuXG4vLyBmYWtlIGNvbnN0cnVjdG9yIGZvciBhdHRhY2hpbmcgZnNldmVudHMtc3BlY2lmaWMgcHJvdG90eXBlIG1ldGhvZHMgdGhhdFxuLy8gd2lsbCBiZSBjb3BpZWQgdG8gRlNXYXRjaGVyJ3MgcHJvdG90eXBlXG5mdW5jdGlvbiBGc0V2ZW50c0hhbmRsZXIoKSB7fVxuXG4vLyBQcml2YXRlIG1ldGhvZDogSGFuZGxlIHN5bWxpbmtzIGVuY291bnRlcmVkIGR1cmluZyBkaXJlY3Rvcnkgc2NhblxuXG4vLyAqIHdhdGNoUGF0aCAgLSBzdHJpbmcsIGZpbGUvZGlyIHBhdGggdG8gYmUgd2F0Y2hlZCB3aXRoIGZzZXZlbnRzXG4vLyAqIHJlYWxQYXRoICAgLSBzdHJpbmcsIHJlYWwgcGF0aCAoaW4gY2FzZSBvZiBzeW1saW5rcylcbi8vICogdHJhbnNmb3JtICAtIGZ1bmN0aW9uLCBwYXRoIHRyYW5zZm9ybWVyXG4vLyAqIGdsb2JGaWx0ZXIgLSBmdW5jdGlvbiwgcGF0aCBmaWx0ZXIgaW4gY2FzZSBhIGdsb2IgcGF0dGVybiB3YXMgcHJvdmlkZWRcblxuLy8gUmV0dXJucyBjbG9zZSBmdW5jdGlvbiBmb3IgdGhlIHdhdGNoZXIgaW5zdGFuY2VcbkZzRXZlbnRzSGFuZGxlci5wcm90b3R5cGUuX3dhdGNoV2l0aEZzRXZlbnRzID1cbmZ1bmN0aW9uKHdhdGNoUGF0aCwgcmVhbFBhdGgsIHRyYW5zZm9ybSwgZ2xvYkZpbHRlcikge1xuICBpZiAodGhpcy5faXNJZ25vcmVkKHdhdGNoUGF0aCkpIHJldHVybjtcbiAgdmFyIHdhdGNoQ2FsbGJhY2sgPSBmdW5jdGlvbihmdWxsUGF0aCwgZmxhZ3MsIGluZm8pIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLm9wdGlvbnMuZGVwdGggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgZGVwdGgoZnVsbFBhdGgsIHJlYWxQYXRoKSA+IHRoaXMub3B0aW9ucy5kZXB0aFxuICAgICkgcmV0dXJuO1xuICAgIHZhciBwYXRoID0gdHJhbnNmb3JtKHN5c1BhdGguam9pbihcbiAgICAgIHdhdGNoUGF0aCwgc3lzUGF0aC5yZWxhdGl2ZSh3YXRjaFBhdGgsIGZ1bGxQYXRoKVxuICAgICkpO1xuICAgIGlmIChnbG9iRmlsdGVyICYmICFnbG9iRmlsdGVyKHBhdGgpKSByZXR1cm47XG4gICAgLy8gZW5zdXJlIGRpcmVjdG9yaWVzIGFyZSB0cmFja2VkXG4gICAgdmFyIHBhcmVudCA9IHN5c1BhdGguZGlybmFtZShwYXRoKTtcbiAgICB2YXIgaXRlbSA9IHN5c1BhdGguYmFzZW5hbWUocGF0aCk7XG4gICAgdmFyIHdhdGNoZWREaXIgPSB0aGlzLl9nZXRXYXRjaGVkRGlyKFxuICAgICAgaW5mby50eXBlID09PSAnZGlyZWN0b3J5JyA/IHBhdGggOiBwYXJlbnRcbiAgICApO1xuICAgIHZhciBjaGVja0lnbm9yZWQgPSBmdW5jdGlvbihzdGF0cykge1xuICAgICAgaWYgKHRoaXMuX2lzSWdub3JlZChwYXRoLCBzdGF0cykpIHtcbiAgICAgICAgdGhpcy5faWdub3JlZFBhdGhzW3BhdGhdID0gdHJ1ZTtcbiAgICAgICAgaWYgKHN0YXRzICYmIHN0YXRzLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICB0aGlzLl9pZ25vcmVkUGF0aHNbcGF0aCArICcvKiovKiddID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9pZ25vcmVkUGF0aHNbcGF0aF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9pZ25vcmVkUGF0aHNbcGF0aCArICcvKiovKiddO1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHZhciBoYW5kbGVFdmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBpZiAoY2hlY2tJZ25vcmVkKCkpIHJldHVybjtcblxuICAgICAgaWYgKGV2ZW50ID09PSAndW5saW5rJykge1xuICAgICAgICAvLyBzdXBwcmVzcyB1bmxpbmsgZXZlbnRzIG9uIG5ldmVyIGJlZm9yZSBzZWVuIGZpbGVzXG4gICAgICAgIGlmIChpbmZvLnR5cGUgPT09ICdkaXJlY3RvcnknIHx8IHdhdGNoZWREaXIuaGFzKGl0ZW0pKSB7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlKHBhcmVudCwgaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChldmVudCA9PT0gJ2FkZCcpIHtcbiAgICAgICAgICAvLyB0cmFjayBuZXcgZGlyZWN0b3JpZXNcbiAgICAgICAgICBpZiAoaW5mby50eXBlID09PSAnZGlyZWN0b3J5JykgdGhpcy5fZ2V0V2F0Y2hlZERpcihwYXRoKTtcblxuICAgICAgICAgIGlmIChpbmZvLnR5cGUgPT09ICdzeW1saW5rJyAmJiB0aGlzLm9wdGlvbnMuZm9sbG93U3ltbGlua3MpIHtcbiAgICAgICAgICAgIC8vIHB1c2ggc3ltbGlua3MgYmFjayB0byB0aGUgdG9wIG9mIHRoZSBzdGFjayB0byBnZXQgaGFuZGxlZFxuICAgICAgICAgICAgdmFyIGN1ckRlcHRoID0gdGhpcy5vcHRpb25zLmRlcHRoID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICB1bmRlZmluZWQgOiBkZXB0aChmdWxsUGF0aCwgcmVhbFBhdGgpICsgMTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRUb0ZzRXZlbnRzKHBhdGgsIGZhbHNlLCB0cnVlLCBjdXJEZXB0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRyYWNrIG5ldyBwYXRoc1xuICAgICAgICAgICAgLy8gKG90aGVyIHRoYW4gc3ltbGlua3MgYmVpbmcgZm9sbG93ZWQsIHdoaWNoIHdpbGwgYmUgdHJhY2tlZCBzb29uKVxuICAgICAgICAgICAgdGhpcy5fZ2V0V2F0Y2hlZERpcihwYXJlbnQpLmFkZChpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IGluZm8udHlwZSA9PT0gJ2RpcmVjdG9yeScgPyBldmVudCArICdEaXInIDogZXZlbnQ7XG4gICAgICAgIHRoaXMuX2VtaXQoZXZlbnROYW1lLCBwYXRoKTtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ2FkZERpcicpIHRoaXMuX2FkZFRvRnNFdmVudHMocGF0aCwgZmFsc2UsIHRydWUpO1xuICAgICAgfVxuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIGZ1bmN0aW9uIGFkZE9yQ2hhbmdlKCkge1xuICAgICAgaGFuZGxlRXZlbnQod2F0Y2hlZERpci5oYXMoaXRlbSkgPyAnY2hhbmdlJyA6ICdhZGQnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tGZCgpIHtcbiAgICAgIGZzLm9wZW4ocGF0aCwgJ3InLCBmdW5jdGlvbihlcnJvciwgZmQpIHtcbiAgICAgICAgaWYgKGZkKSBmcy5jbG9zZShmZCk7XG4gICAgICAgIGVycm9yICYmIGVycm9yLmNvZGUgIT09ICdFQUNDRVMnID9cbiAgICAgICAgICBoYW5kbGVFdmVudCgndW5saW5rJykgOiBhZGRPckNoYW5nZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGNvcnJlY3QgZm9yIHdyb25nIGV2ZW50cyBlbWl0dGVkXG4gICAgdmFyIHdyb25nRXZlbnRGbGFncyA9IFtcbiAgICAgIDY5ODg4LCA3MDQwMCwgNzE0MjQsIDcyNzA0LCA3MzQ3MiwgMTMxMzI4LCAxMzE4NDAsIDI2MjkxMlxuICAgIF07XG4gICAgaWYgKHdyb25nRXZlbnRGbGFncy5pbmRleE9mKGZsYWdzKSAhPT0gLTEgfHwgaW5mby5ldmVudCA9PT0gJ3Vua25vd24nKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5pZ25vcmVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZzLnN0YXQocGF0aCwgZnVuY3Rpb24oZXJyb3IsIHN0YXRzKSB7XG4gICAgICAgICAgaWYgKGNoZWNrSWdub3JlZChzdGF0cykpIHJldHVybjtcbiAgICAgICAgICBzdGF0cyA/IGFkZE9yQ2hhbmdlKCkgOiBoYW5kbGVFdmVudCgndW5saW5rJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2tGZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGluZm8uZXZlbnQpIHtcbiAgICAgIGNhc2UgJ2NyZWF0ZWQnOlxuICAgICAgY2FzZSAnbW9kaWZpZWQnOlxuICAgICAgICByZXR1cm4gYWRkT3JDaGFuZ2UoKTtcbiAgICAgIGNhc2UgJ2RlbGV0ZWQnOlxuICAgICAgY2FzZSAnbW92ZWQnOlxuICAgICAgICByZXR1cm4gY2hlY2tGZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfS5iaW5kKHRoaXMpO1xuXG4gIHZhciBjbG9zZXIgPSBzZXRGU0V2ZW50c0xpc3RlbmVyKFxuICAgIHdhdGNoUGF0aCxcbiAgICByZWFsUGF0aCxcbiAgICB3YXRjaENhbGxiYWNrLFxuICAgIHRoaXMuZW1pdC5iaW5kKHRoaXMsICdyYXcnKVxuICApO1xuXG4gIHRoaXMuX2VtaXRSZWFkeSgpO1xuICByZXR1cm4gY2xvc2VyO1xufTtcblxuLy8gUHJpdmF0ZSBtZXRob2Q6IEhhbmRsZSBzeW1saW5rcyBlbmNvdW50ZXJlZCBkdXJpbmcgZGlyZWN0b3J5IHNjYW5cblxuLy8gKiBsaW5rUGF0aCAgIC0gc3RyaW5nLCBwYXRoIHRvIHN5bWxpbmtcbi8vICogZnVsbFBhdGggICAtIHN0cmluZywgYWJzb2x1dGUgcGF0aCB0byB0aGUgc3ltbGlua1xuLy8gKiB0cmFuc2Zvcm0gIC0gZnVuY3Rpb24sIHByZS1leGlzdGluZyBwYXRoIHRyYW5zZm9ybWVyXG4vLyAqIGN1ckRlcHRoICAgLSBpbnQsIGxldmVsIG9mIHN1YmRpcmVjdG9yaWVzIHRyYXZlcnNlZCB0byB3aGVyZSBzeW1saW5rIGlzXG5cbi8vIFJldHVybnMgbm90aGluZ1xuRnNFdmVudHNIYW5kbGVyLnByb3RvdHlwZS5faGFuZGxlRnNFdmVudHNTeW1saW5rID1cbmZ1bmN0aW9uKGxpbmtQYXRoLCBmdWxsUGF0aCwgdHJhbnNmb3JtLCBjdXJEZXB0aCkge1xuICAvLyBkb24ndCBmb2xsb3cgdGhlIHNhbWUgc3ltbGluayBtb3JlIHRoYW4gb25jZVxuICBpZiAodGhpcy5fc3ltbGlua1BhdGhzW2Z1bGxQYXRoXSkgcmV0dXJuO1xuICBlbHNlIHRoaXMuX3N5bWxpbmtQYXRoc1tmdWxsUGF0aF0gPSB0cnVlO1xuXG4gIHRoaXMuX3JlYWR5Q291bnQrKztcblxuICBmcy5yZWFscGF0aChsaW5rUGF0aCwgZnVuY3Rpb24oZXJyb3IsIGxpbmtUYXJnZXQpIHtcbiAgICBpZiAodGhpcy5faGFuZGxlRXJyb3IoZXJyb3IpIHx8IHRoaXMuX2lzSWdub3JlZChsaW5rVGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VtaXRSZWFkeSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlYWR5Q291bnQrKztcblxuICAgIC8vIGFkZCB0aGUgbGlua1RhcmdldCBmb3Igd2F0Y2hpbmcgd2l0aCBhIHdyYXBwZXIgZm9yIHRyYW5zZm9ybVxuICAgIC8vIHRoYXQgY2F1c2VzIGVtaXR0ZWQgcGF0aHMgdG8gaW5jb3Jwb3JhdGUgdGhlIGxpbmsncyBwYXRoXG4gICAgdGhpcy5fYWRkVG9Gc0V2ZW50cyhsaW5rVGFyZ2V0IHx8IGxpbmtQYXRoLCBmdW5jdGlvbihwYXRoKSB7XG4gICAgICB2YXIgZG90U2xhc2ggPSAnLicgKyBzeXNQYXRoLnNlcDtcbiAgICAgIHZhciBhbGlhc2VkUGF0aCA9IGxpbmtQYXRoO1xuICAgICAgaWYgKGxpbmtUYXJnZXQgJiYgbGlua1RhcmdldCAhPT0gZG90U2xhc2gpIHtcbiAgICAgICAgYWxpYXNlZFBhdGggPSBwYXRoLnJlcGxhY2UobGlua1RhcmdldCwgbGlua1BhdGgpO1xuICAgICAgfSBlbHNlIGlmIChwYXRoICE9PSBkb3RTbGFzaCkge1xuICAgICAgICBhbGlhc2VkUGF0aCA9IHN5c1BhdGguam9pbihsaW5rUGF0aCwgcGF0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJhbnNmb3JtKGFsaWFzZWRQYXRoKTtcbiAgICB9LCBmYWxzZSwgY3VyRGVwdGgpO1xuICB9LmJpbmQodGhpcykpO1xufTtcblxuLy8gUHJpdmF0ZSBtZXRob2Q6IEhhbmRsZSBhZGRlZCBwYXRoIHdpdGggZnNldmVudHNcblxuLy8gKiBwYXRoICAgICAgIC0gc3RyaW5nLCBmaWxlL2RpcmVjdG9yeSBwYXRoIG9yIGdsb2IgcGF0dGVyblxuLy8gKiB0cmFuc2Zvcm0gIC0gZnVuY3Rpb24sIGNvbnZlcnRzIHdvcmtpbmcgcGF0aCB0byB3aGF0IHRoZSB1c2VyIGV4cGVjdHNcbi8vICogZm9yY2VBZGQgICAtIGJvb2xlYW4sIGVuc3VyZSBhZGQgaXMgZW1pdHRlZFxuLy8gKiBwcmlvckRlcHRoIC0gaW50LCBsZXZlbCBvZiBzdWJkaXJlY3RvcmllcyBhbHJlYWR5IHRyYXZlcnNlZFxuXG4vLyBSZXR1cm5zIG5vdGhpbmdcbkZzRXZlbnRzSGFuZGxlci5wcm90b3R5cGUuX2FkZFRvRnNFdmVudHMgPVxuZnVuY3Rpb24ocGF0aCwgdHJhbnNmb3JtLCBmb3JjZUFkZCwgcHJpb3JEZXB0aCkge1xuXG4gIC8vIGFwcGxpZXMgdHJhbnNmb3JtIGlmIHByb3ZpZGVkLCBvdGhlcndpc2UgcmV0dXJucyBzYW1lIHZhbHVlXG4gIHZhciBwcm9jZXNzUGF0aCA9IHR5cGVvZiB0cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicgP1xuICAgIHRyYW5zZm9ybSA6IGZ1bmN0aW9uKHZhbCkgeyByZXR1cm4gdmFsOyB9O1xuXG4gIHZhciBlbWl0QWRkID0gZnVuY3Rpb24obmV3UGF0aCwgc3RhdHMpIHtcbiAgICB2YXIgcHAgPSBwcm9jZXNzUGF0aChuZXdQYXRoKTtcbiAgICB2YXIgaXNEaXIgPSBzdGF0cy5pc0RpcmVjdG9yeSgpO1xuICAgIHZhciBkaXJPYmogPSB0aGlzLl9nZXRXYXRjaGVkRGlyKHN5c1BhdGguZGlybmFtZShwcCkpO1xuICAgIHZhciBiYXNlID0gc3lzUGF0aC5iYXNlbmFtZShwcCk7XG5cbiAgICAvLyBlbnN1cmUgZW1wdHkgZGlycyBnZXQgdHJhY2tlZFxuICAgIGlmIChpc0RpcikgdGhpcy5fZ2V0V2F0Y2hlZERpcihwcCk7XG5cbiAgICBpZiAoZGlyT2JqLmhhcyhiYXNlKSkgcmV0dXJuO1xuICAgIGRpck9iai5hZGQoYmFzZSk7XG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5pZ25vcmVJbml0aWFsIHx8IGZvcmNlQWRkID09PSB0cnVlKSB7XG4gICAgICB0aGlzLl9lbWl0KGlzRGlyID8gJ2FkZERpcicgOiAnYWRkJywgcHAsIHN0YXRzKTtcbiAgICB9XG4gIH0uYmluZCh0aGlzKTtcblxuICB2YXIgd2ggPSB0aGlzLl9nZXRXYXRjaEhlbHBlcnMocGF0aCk7XG5cbiAgLy8gZXZhbHVhdGUgd2hhdCBpcyBhdCB0aGUgcGF0aCB3ZSdyZSBiZWluZyBhc2tlZCB0byB3YXRjaFxuICBmc1t3aC5zdGF0TWV0aG9kXSh3aC53YXRjaFBhdGgsIGZ1bmN0aW9uKGVycm9yLCBzdGF0cykge1xuICAgIGlmICh0aGlzLl9oYW5kbGVFcnJvcihlcnJvcikgfHwgdGhpcy5faXNJZ25vcmVkKHdoLndhdGNoUGF0aCwgc3RhdHMpKSB7XG4gICAgICB0aGlzLl9lbWl0UmVhZHkoKTtcbiAgICAgIHJldHVybiB0aGlzLl9lbWl0UmVhZHkoKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgLy8gZW1pdCBhZGREaXIgdW5sZXNzIHRoaXMgaXMgYSBnbG9iIHBhcmVudFxuICAgICAgaWYgKCF3aC5nbG9iRmlsdGVyKSBlbWl0QWRkKHByb2Nlc3NQYXRoKHBhdGgpLCBzdGF0cyk7XG5cbiAgICAgIC8vIGRvbid0IHJlY3Vyc2UgZnVydGhlciBpZiBpdCB3b3VsZCBleGNlZWQgZGVwdGggc2V0dGluZ1xuICAgICAgaWYgKHByaW9yRGVwdGggJiYgcHJpb3JEZXB0aCA+IHRoaXMub3B0aW9ucy5kZXB0aCkgcmV0dXJuO1xuXG4gICAgICAvLyBzY2FuIHRoZSBjb250ZW50cyBvZiB0aGUgZGlyXG4gICAgICByZWFkZGlycCh7XG4gICAgICAgIHJvb3Q6IHdoLndhdGNoUGF0aCxcbiAgICAgICAgZW50cnlUeXBlOiAnYWxsJyxcbiAgICAgICAgZmlsZUZpbHRlcjogd2guZmlsdGVyUGF0aCxcbiAgICAgICAgZGlyZWN0b3J5RmlsdGVyOiB3aC5maWx0ZXJEaXIsXG4gICAgICAgIGxzdGF0OiB0cnVlLFxuICAgICAgICBkZXB0aDogdGhpcy5vcHRpb25zLmRlcHRoIC0gKHByaW9yRGVwdGggfHwgMClcbiAgICAgIH0pLm9uKCdkYXRhJywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgLy8gbmVlZCB0byBjaGVjayBmaWx0ZXJQYXRoIG9uIGRpcnMgYi9jIGZpbHRlckRpciBpcyBsZXNzIHJlc3RyaWN0aXZlXG4gICAgICAgIGlmIChlbnRyeS5zdGF0LmlzRGlyZWN0b3J5KCkgJiYgIXdoLmZpbHRlclBhdGgoZW50cnkpKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGpvaW5lZFBhdGggPSBzeXNQYXRoLmpvaW4od2gud2F0Y2hQYXRoLCBlbnRyeS5wYXRoKTtcbiAgICAgICAgdmFyIGZ1bGxQYXRoID0gZW50cnkuZnVsbFBhdGg7XG5cbiAgICAgICAgaWYgKHdoLmZvbGxvd1N5bWxpbmtzICYmIGVudHJ5LnN0YXQuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICAgIC8vIHByZXNlcnZlIHRoZSBjdXJyZW50IGRlcHRoIGhlcmUgc2luY2UgaXQgY2FuJ3QgYmUgZGVyaXZlZCBmcm9tXG4gICAgICAgICAgLy8gcmVhbCBwYXRocyBwYXN0IHRoZSBzeW1saW5rXG4gICAgICAgICAgdmFyIGN1ckRlcHRoID0gdGhpcy5vcHRpb25zLmRlcHRoID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgdW5kZWZpbmVkIDogZGVwdGgoam9pbmVkUGF0aCwgc3lzUGF0aC5yZXNvbHZlKHdoLndhdGNoUGF0aCkpICsgMTtcblxuICAgICAgICAgIHRoaXMuX2hhbmRsZUZzRXZlbnRzU3ltbGluayhqb2luZWRQYXRoLCBmdWxsUGF0aCwgcHJvY2Vzc1BhdGgsIGN1ckRlcHRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbWl0QWRkKGpvaW5lZFBhdGgsIGVudHJ5LnN0YXQpO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpLm9uKCdlcnJvcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBJZ25vcmUgcmVhZGRpcnAgZXJyb3JzXG4gICAgICB9KS5vbignZW5kJywgdGhpcy5fZW1pdFJlYWR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdEFkZCh3aC53YXRjaFBhdGgsIHN0YXRzKTtcbiAgICAgIHRoaXMuX2VtaXRSZWFkeSgpO1xuICAgIH1cbiAgfS5iaW5kKHRoaXMpKTtcblxuICBpZiAodGhpcy5vcHRpb25zLnBlcnNpc3RlbnQgJiYgZm9yY2VBZGQgIT09IHRydWUpIHtcbiAgICB2YXIgaW5pdFdhdGNoID0gZnVuY3Rpb24oZXJyb3IsIHJlYWxQYXRoKSB7XG4gICAgICB2YXIgY2xvc2VyID0gdGhpcy5fd2F0Y2hXaXRoRnNFdmVudHMoXG4gICAgICAgIHdoLndhdGNoUGF0aCxcbiAgICAgICAgc3lzUGF0aC5yZXNvbHZlKHJlYWxQYXRoIHx8IHdoLndhdGNoUGF0aCksXG4gICAgICAgIHByb2Nlc3NQYXRoLFxuICAgICAgICB3aC5nbG9iRmlsdGVyXG4gICAgICApO1xuICAgICAgaWYgKGNsb3NlcikgdGhpcy5fY2xvc2Vyc1twYXRoXSA9IGNsb3NlcjtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICBpZiAodHlwZW9mIHRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gcmVhbHBhdGggaGFzIGFscmVhZHkgYmVlbiByZXNvbHZlZFxuICAgICAgaW5pdFdhdGNoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZzLnJlYWxwYXRoKHdoLndhdGNoUGF0aCwgaW5pdFdhdGNoKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRnNFdmVudHNIYW5kbGVyO1xubW9kdWxlLmV4cG9ydHMuY2FuVXNlID0gY2FuVXNlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nob2tpZGFyL2xpYi9mc2V2ZW50cy1oYW5kbGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIGZzID0gcmVxdWlyZShcImZzXCIpO1xyXG52YXIgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xyXG52YXIgbWtkaXJwID0gcmVxdWlyZShcIm1rZGlycFwiKTtcclxuXHJcbmZ1bmN0aW9uIE5vZGVPdXRwdXRGaWxlU3lzdGVtKCkge31cclxubW9kdWxlLmV4cG9ydHMgPSBOb2RlT3V0cHV0RmlsZVN5c3RlbTtcclxuXHJcbk5vZGVPdXRwdXRGaWxlU3lzdGVtLnByb3RvdHlwZS5ta2RpcnAgPSBta2RpcnA7XHJcbk5vZGVPdXRwdXRGaWxlU3lzdGVtLnByb3RvdHlwZS5ta2RpciA9IGZzLm1rZGlyLmJpbmQodGhpcyk7XHJcbk5vZGVPdXRwdXRGaWxlU3lzdGVtLnByb3RvdHlwZS5ybWRpciA9IGZzLnJtZGlyLmJpbmQodGhpcyk7XHJcbk5vZGVPdXRwdXRGaWxlU3lzdGVtLnByb3RvdHlwZS51bmxpbmsgPSBmcy51bmxpbmsuYmluZCh0aGlzKTtcclxuTm9kZU91dHB1dEZpbGVTeXN0ZW0ucHJvdG90eXBlLndyaXRlRmlsZSA9IGZzLndyaXRlRmlsZS5iaW5kKGZzKTtcclxuTm9kZU91dHB1dEZpbGVTeXN0ZW0ucHJvdG90eXBlLmpvaW4gPSBwYXRoLmpvaW4uYmluZChwYXRoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9ub2RlL05vZGVPdXRwdXRGaWxlU3lzdGVtLmpzXG4vLyBtb2R1bGUgaWQgPSAyOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIF8wNzc3ID0gcGFyc2VJbnQoJzA3NzcnLCA4KTtcblxubW9kdWxlLmV4cG9ydHMgPSBta2RpclAubWtkaXJwID0gbWtkaXJQLm1rZGlyUCA9IG1rZGlyUDtcblxuZnVuY3Rpb24gbWtkaXJQIChwLCBvcHRzLCBmLCBtYWRlKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGYgPSBvcHRzO1xuICAgICAgICBvcHRzID0ge307XG4gICAgfVxuICAgIGVsc2UgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRzID0geyBtb2RlOiBvcHRzIH07XG4gICAgfVxuICAgIFxuICAgIHZhciBtb2RlID0gb3B0cy5tb2RlO1xuICAgIHZhciB4ZnMgPSBvcHRzLmZzIHx8IGZzO1xuICAgIFxuICAgIGlmIChtb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbW9kZSA9IF8wNzc3ICYgKH5wcm9jZXNzLnVtYXNrKCkpO1xuICAgIH1cbiAgICBpZiAoIW1hZGUpIG1hZGUgPSBudWxsO1xuICAgIFxuICAgIHZhciBjYiA9IGYgfHwgZnVuY3Rpb24gKCkge307XG4gICAgcCA9IHBhdGgucmVzb2x2ZShwKTtcbiAgICBcbiAgICB4ZnMubWtkaXIocCwgbW9kZSwgZnVuY3Rpb24gKGVyKSB7XG4gICAgICAgIGlmICghZXIpIHtcbiAgICAgICAgICAgIG1hZGUgPSBtYWRlIHx8IHA7XG4gICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgbWFkZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChlci5jb2RlKSB7XG4gICAgICAgICAgICBjYXNlICdFTk9FTlQnOlxuICAgICAgICAgICAgICAgIG1rZGlyUChwYXRoLmRpcm5hbWUocCksIG9wdHMsIGZ1bmN0aW9uIChlciwgbWFkZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXIpIGNiKGVyLCBtYWRlKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBta2RpclAocCwgb3B0cywgY2IsIG1hZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBhbnkgb3RoZXIgZXJyb3IsIGp1c3Qgc2VlIGlmIHRoZXJlJ3MgYSBkaXJcbiAgICAgICAgICAgIC8vIHRoZXJlIGFscmVhZHkuICBJZiBzbywgdGhlbiBob29yYXkhICBJZiBub3QsIHRoZW4gc29tZXRoaW5nXG4gICAgICAgICAgICAvLyBpcyBib3JrZWQuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHhmcy5zdGF0KHAsIGZ1bmN0aW9uIChlcjIsIHN0YXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHN0YXQgZmFpbHMsIHRoZW4gdGhhdCdzIHN1cGVyIHdlaXJkLlxuICAgICAgICAgICAgICAgICAgICAvLyBsZXQgdGhlIG9yaWdpbmFsIGVycm9yIGJlIHRoZSBmYWlsdXJlIHJlYXNvbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyMiB8fCAhc3RhdC5pc0RpcmVjdG9yeSgpKSBjYihlciwgbWFkZSlcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBjYihudWxsLCBtYWRlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5ta2RpclAuc3luYyA9IGZ1bmN0aW9uIHN5bmMgKHAsIG9wdHMsIG1hZGUpIHtcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9wdHMgPSB7IG1vZGU6IG9wdHMgfTtcbiAgICB9XG4gICAgXG4gICAgdmFyIG1vZGUgPSBvcHRzLm1vZGU7XG4gICAgdmFyIHhmcyA9IG9wdHMuZnMgfHwgZnM7XG4gICAgXG4gICAgaWYgKG1vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtb2RlID0gXzA3NzcgJiAofnByb2Nlc3MudW1hc2soKSk7XG4gICAgfVxuICAgIGlmICghbWFkZSkgbWFkZSA9IG51bGw7XG5cbiAgICBwID0gcGF0aC5yZXNvbHZlKHApO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgeGZzLm1rZGlyU3luYyhwLCBtb2RlKTtcbiAgICAgICAgbWFkZSA9IG1hZGUgfHwgcDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycjApIHtcbiAgICAgICAgc3dpdGNoIChlcnIwLmNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0VOT0VOVCcgOlxuICAgICAgICAgICAgICAgIG1hZGUgPSBzeW5jKHBhdGguZGlybmFtZShwKSwgb3B0cywgbWFkZSk7XG4gICAgICAgICAgICAgICAgc3luYyhwLCBvcHRzLCBtYWRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYW55IG90aGVyIGVycm9yLCBqdXN0IHNlZSBpZiB0aGVyZSdzIGEgZGlyXG4gICAgICAgICAgICAvLyB0aGVyZSBhbHJlYWR5LiAgSWYgc28sIHRoZW4gaG9vcmF5ISAgSWYgbm90LCB0aGVuIHNvbWV0aGluZ1xuICAgICAgICAgICAgLy8gaXMgYm9ya2VkLlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB2YXIgc3RhdDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ID0geGZzLnN0YXRTeW5jKHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnIwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXN0YXQuaXNEaXJlY3RvcnkoKSkgdGhyb3cgZXJyMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYWRlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9ta2RpcnAvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgZnMgPSByZXF1aXJlKFwiZ3JhY2VmdWwtZnNcIik7XHJcblxyXG5mdW5jdGlvbiBOb2RlSnNJbnB1dEZpbGVTeXN0ZW0oKSB7fVxyXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGVKc0lucHV0RmlsZVN5c3RlbTtcclxuXHJcbk5vZGVKc0lucHV0RmlsZVN5c3RlbS5wcm90b3R5cGUuaXNTeW5jID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuTm9kZUpzSW5wdXRGaWxlU3lzdGVtLnByb3RvdHlwZS5zdGF0ID0gZnMuc3RhdC5iaW5kKGZzKTtcclxuTm9kZUpzSW5wdXRGaWxlU3lzdGVtLnByb3RvdHlwZS5yZWFkZGlyID0gZnVuY3Rpb24gcmVhZGRpcihwYXRoLCBjYWxsYmFjaykge1xyXG5cdGZzLnJlYWRkaXIocGF0aCwgZnVuY3Rpb24gKGVyciwgZmlsZXMpIHtcclxuXHRcdGNhbGxiYWNrKGVyciwgZmlsZXMgJiYgZmlsZXMubWFwKGZ1bmN0aW9uIChmaWxlKSB7XHJcblx0XHRcdHJldHVybiBmaWxlLm5vcm1hbGl6ZSA/IGZpbGUubm9ybWFsaXplKFwiTkZDXCIpIDogZmlsZTtcclxuXHRcdH0pKTtcclxuXHR9KTtcclxufTtcclxuTm9kZUpzSW5wdXRGaWxlU3lzdGVtLnByb3RvdHlwZS5yZWFkRmlsZSA9IGZzLnJlYWRGaWxlLmJpbmQoZnMpO1xyXG5Ob2RlSnNJbnB1dEZpbGVTeXN0ZW0ucHJvdG90eXBlLnJlYWRsaW5rID0gZnMucmVhZGxpbmsuYmluZChmcyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2VuaGFuY2VkLXJlc29sdmUvbGliL05vZGVKc0lucHV0RmlsZVN5c3RlbS5qc1xuLy8gbW9kdWxlIGlkID0gMzAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbmZ1bmN0aW9uIFN0b3JhZ2UoZHVyYXRpb24pIHtcclxuXHR0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XHJcblx0dGhpcy5ydW5uaW5nID0ge307XHJcblx0dGhpcy5kYXRhID0ge307XHJcblx0dGhpcy5sZXZlbHMgPSBbXTtcclxuXHRpZihkdXJhdGlvbiA+IDApIHtcclxuXHRcdHRoaXMubGV2ZWxzLnB1c2goW10sIFtdLCBbXSwgW10sIFtdLCBbXSwgW10sIFtdLCBbXSk7XHJcblx0XHRmb3IodmFyIGkgPSA4MDAwOyBpIDwgZHVyYXRpb247IGkrPTUwMClcclxuXHRcdFx0dGhpcy5sZXZlbHMucHVzaChbXSk7XHJcblx0fVxyXG5cdHRoaXMuY291bnQgPSAwO1xyXG5cdHRoaXMuaW50ZXJ2YWwgPSBudWxsO1xyXG5cdHRoaXMubmVlZFRpY2tDaGVjayA9IGZhbHNlO1xyXG5cdHRoaXMubmV4dFRpY2sgPSBudWxsO1xyXG5cdHRoaXMucGFzc2l2ZSA9IHRydWU7XHJcbn1cclxuXHJcblN0b3JhZ2UucHJvdG90eXBlLmVuc3VyZVRpY2sgPSBmdW5jdGlvbigpIHtcclxuXHRpZighdGhpcy5pbnRlcnZhbCAmJiB0aGlzLmR1cmF0aW9uID4gMCAmJiAhdGhpcy5uZXh0VGljaylcclxuXHRcdHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh0aGlzLnRpY2suYmluZCh0aGlzKSwgTWF0aC5mbG9vcih0aGlzLmR1cmF0aW9uIC8gdGhpcy5sZXZlbHMubGVuZ3RoKSk7XHJcbn07XHJcblxyXG5TdG9yYWdlLnByb3RvdHlwZS5maW5pc2hlZCA9IGZ1bmN0aW9uKG5hbWUpIHtcclxuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcblx0dmFyIGNhbGxiYWNrcyA9IHRoaXMucnVubmluZ1tuYW1lXTtcclxuXHRkZWxldGUgdGhpcy5ydW5uaW5nW25hbWVdO1xyXG5cdGlmKHRoaXMuZHVyYXRpb24gPiAwKSB7XHJcblx0XHR0aGlzLmNvdW50Kys7XHJcblx0XHR0aGlzLmRhdGFbbmFtZV0gPSBhcmdzO1xyXG5cdFx0dGhpcy5sZXZlbHNbMF0ucHVzaChuYW1lKTtcclxuXHRcdHRoaXMuZW5zdXJlVGljaygpO1xyXG5cdH1cclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRjYWxsYmFja3NbaV0uYXBwbHkobnVsbCwgYXJncyk7XHJcblx0fVxyXG59O1xyXG5cclxuU3RvcmFnZS5wcm90b3R5cGUucHJvdmlkZSA9IGZ1bmN0aW9uKG5hbWUsIHByb3ZpZGVyLCBjYWxsYmFjaykge1xyXG5cdHZhciBydW5uaW5nID0gdGhpcy5ydW5uaW5nW25hbWVdO1xyXG5cdGlmKHJ1bm5pbmcpIHtcclxuXHRcdHJ1bm5pbmcucHVzaChjYWxsYmFjayk7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cdGlmKHRoaXMuZHVyYXRpb24gPiAwKSB7XHJcblx0XHR0aGlzLmNoZWNrVGlja3MoKTtcclxuXHRcdHZhciBkYXRhID0gdGhpcy5kYXRhW25hbWVdO1xyXG5cdFx0aWYoZGF0YSkge1xyXG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgZGF0YSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHRoaXMucnVubmluZ1tuYW1lXSA9IHJ1bm5pbmcgPSBbY2FsbGJhY2tdO1xyXG5cdHByb3ZpZGVyKG5hbWUsIHRoaXMuZmluaXNoZWQuYmluZCh0aGlzLCBuYW1lKSk7XHJcbn07XHJcblxyXG5TdG9yYWdlLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGRlY2F5ID0gdGhpcy5sZXZlbHMucG9wKCk7XHJcblx0Zm9yKHZhciBpID0gZGVjYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdGRlbGV0ZSB0aGlzLmRhdGFbZGVjYXlbaV1dO1xyXG5cdH1cclxuXHR0aGlzLmNvdW50IC09IGRlY2F5Lmxlbmd0aDtcclxuXHRkZWNheS5sZW5ndGggPSAwO1xyXG5cdHRoaXMubGV2ZWxzLnVuc2hpZnQoZGVjYXkpO1xyXG5cdGlmKHRoaXMuY291bnQgPT0gMCkge1xyXG5cdFx0Y2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcclxuXHRcdHRoaXMuaW50ZXJ2YWwgPSBudWxsO1xyXG5cdFx0dGhpcy5uZXh0VGljayA9IG51bGw7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9IGVsc2UgaWYodGhpcy5uZXh0VGljaykge1xyXG5cdFx0dGhpcy5uZXh0VGljayArPSBNYXRoLmZsb29yKHRoaXMuZHVyYXRpb24gLyB0aGlzLmxldmVscy5sZW5ndGgpO1xyXG5cdFx0dmFyIHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuXHRcdGlmKHRoaXMubmV4dFRpY2sgPiB0aW1lKSB7XHJcblx0XHRcdHRoaXMubmV4dFRpY2sgPSBudWxsO1xyXG5cdFx0XHR0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwodGhpcy50aWNrLmJpbmQodGhpcyksIE1hdGguZmxvb3IodGhpcy5kdXJhdGlvbiAvIHRoaXMubGV2ZWxzLmxlbmd0aCkpO1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHR9IGVsc2UgaWYodGhpcy5wYXNzaXZlKSB7XHJcblx0XHRjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpO1xyXG5cdFx0dGhpcy5pbnRlcnZhbCA9IG51bGw7XHJcblx0XHR0aGlzLm5leHRUaWNrID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBNYXRoLmZsb29yKHRoaXMuZHVyYXRpb24gLyB0aGlzLmxldmVscy5sZW5ndGgpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR0aGlzLnBhc3NpdmUgPSB0cnVlO1xyXG5cdH1cclxufTtcclxuXHJcblN0b3JhZ2UucHJvdG90eXBlLmNoZWNrVGlja3MgPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLnBhc3NpdmUgPSBmYWxzZTtcclxuXHRpZih0aGlzLm5leHRUaWNrKSB7XHJcblx0XHR3aGlsZSghdGhpcy50aWNrKCkpO1xyXG5cdH1cclxufTtcclxuXHJcblN0b3JhZ2UucHJvdG90eXBlLnB1cmdlID0gZnVuY3Rpb24od2hhdCkge1xyXG5cdGlmKCF3aGF0KSB7XHJcblx0XHR0aGlzLmNvdW50ID0gMDtcclxuXHRcdGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XHJcblx0XHR0aGlzLm5leHRUaWNrID0gbnVsbDtcclxuXHRcdHRoaXMuZGF0YSA9IHt9O1xyXG5cdFx0dGhpcy5sZXZlbHMuZm9yRWFjaChmdW5jdGlvbihsZXZlbCkge1xyXG5cdFx0XHRsZXZlbC5sZW5ndGggPSAwO1xyXG5cdFx0fSk7XHJcblx0fSBlbHNlIGlmKHR5cGVvZiB3aGF0ID09PSBcInN0cmluZ1wiKSB7XHJcblx0XHRPYmplY3Qua2V5cyh0aGlzLmRhdGEpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XHJcblx0XHRcdGlmKGtleS5pbmRleE9mKHdoYXQpID09PSAwKVxyXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmRhdGFba2V5XTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRmb3IodmFyIGkgPSB3aGF0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdHRoaXMucHVyZ2Uod2hhdFtpXSk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuXHJcbmZ1bmN0aW9uIENhY2hlZElucHV0RmlsZVN5c3RlbShmaWxlU3lzdGVtLCBkdXJhdGlvbikge1xyXG5cdHRoaXMuZmlsZVN5c3RlbSA9IGZpbGVTeXN0ZW07XHJcblx0dGhpcy5fc3RhdFN0b3JhZ2UgPSBuZXcgU3RvcmFnZShkdXJhdGlvbik7XHJcblx0dGhpcy5fcmVhZGRpclN0b3JhZ2UgPSBuZXcgU3RvcmFnZShkdXJhdGlvbik7XHJcblx0dGhpcy5fcmVhZEZpbGVTdG9yYWdlID0gbmV3IFN0b3JhZ2UoZHVyYXRpb24pO1xyXG5cdHRoaXMuX3JlYWRsaW5rU3RvcmFnZSA9IG5ldyBTdG9yYWdlKGR1cmF0aW9uKTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IENhY2hlZElucHV0RmlsZVN5c3RlbTtcclxuXHJcbkNhY2hlZElucHV0RmlsZVN5c3RlbS5wcm90b3R5cGUuaXNTeW5jID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuZmlsZVN5c3RlbS5pc1N5bmMoKTtcclxufTtcclxuXHJcbkNhY2hlZElucHV0RmlsZVN5c3RlbS5wcm90b3R5cGUuc3RhdCA9IGZ1bmN0aW9uKHBhdGgsIGNhbGxiYWNrKSB7XHJcblx0dGhpcy5fc3RhdFN0b3JhZ2UucHJvdmlkZShwYXRoLCB0aGlzLmZpbGVTeXN0ZW0uc3RhdC5iaW5kKHRoaXMuZmlsZVN5c3RlbSksIGNhbGxiYWNrKTtcclxufTtcclxuXHJcbkNhY2hlZElucHV0RmlsZVN5c3RlbS5wcm90b3R5cGUucmVhZGRpciA9IGZ1bmN0aW9uKHBhdGgsIGNhbGxiYWNrKSB7XHJcblx0dGhpcy5fcmVhZGRpclN0b3JhZ2UucHJvdmlkZShwYXRoLCB0aGlzLmZpbGVTeXN0ZW0ucmVhZGRpci5iaW5kKHRoaXMuZmlsZVN5c3RlbSksIGNhbGxiYWNrKTtcclxufTtcclxuXHJcbkNhY2hlZElucHV0RmlsZVN5c3RlbS5wcm90b3R5cGUucmVhZEZpbGUgPSBmdW5jdGlvbihwYXRoLCBjYWxsYmFjaykge1xyXG5cdHRoaXMuX3JlYWRGaWxlU3RvcmFnZS5wcm92aWRlKHBhdGgsIHRoaXMuZmlsZVN5c3RlbS5yZWFkRmlsZS5iaW5kKHRoaXMuZmlsZVN5c3RlbSksIGNhbGxiYWNrKTtcclxufTtcclxuXHJcbkNhY2hlZElucHV0RmlsZVN5c3RlbS5wcm90b3R5cGUucmVhZGxpbmsgPSBmdW5jdGlvbihwYXRoLCBjYWxsYmFjaykge1xyXG5cdHRoaXMuX3JlYWRsaW5rU3RvcmFnZS5wcm92aWRlKHBhdGgsIHRoaXMuZmlsZVN5c3RlbS5yZWFkbGluay5iaW5kKHRoaXMuZmlsZVN5c3RlbSksIGNhbGxiYWNrKTtcclxufTtcclxuXHJcbkNhY2hlZElucHV0RmlsZVN5c3RlbS5wcm90b3R5cGUucHVyZ2UgPSBmdW5jdGlvbih3aGF0KSB7XHJcblx0dGhpcy5fc3RhdFN0b3JhZ2UucHVyZ2Uod2hhdCk7XHJcblx0dGhpcy5fcmVhZGRpclN0b3JhZ2UucHVyZ2Uod2hhdCk7XHJcblx0dGhpcy5fcmVhZEZpbGVTdG9yYWdlLnB1cmdlKHdoYXQpO1xyXG5cdHRoaXMuX3JlYWRsaW5rU3RvcmFnZS5wdXJnZSh3aGF0KTtcclxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZW5oYW5jZWQtcmVzb2x2ZS9saWIvQ2FjaGVkSW5wdXRGaWxlU3lzdGVtLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIENvbmNhdFNvdXJjZSA9IHJlcXVpcmUoXCJ3ZWJwYWNrLWNvcmUvbGliL0NvbmNhdFNvdXJjZVwiKTtcclxuXHJcbmZ1bmN0aW9uIE5vZGVIb3RVcGRhdGVDaHVua1RlbXBsYXRlUGx1Z2luKCkge31cclxubW9kdWxlLmV4cG9ydHMgPSBOb2RlSG90VXBkYXRlQ2h1bmtUZW1wbGF0ZVBsdWdpbjtcclxuXHJcbk5vZGVIb3RVcGRhdGVDaHVua1RlbXBsYXRlUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGhvdFVwZGF0ZUNodW5rVGVtcGxhdGUpIHtcclxuXHRob3RVcGRhdGVDaHVua1RlbXBsYXRlLnBsdWdpbihcInJlbmRlclwiLCBmdW5jdGlvbihtb2R1bGVzU291cmNlLCBtb2R1bGVzLCBoYXNoLCBpZCkge1xyXG5cdFx0dmFyIHNvdXJjZSA9IG5ldyBDb25jYXRTb3VyY2UoKTtcclxuXHRcdHNvdXJjZS5hZGQoXCJleHBvcnRzLmlkID0gXCIgKyBKU09OLnN0cmluZ2lmeShpZCkgKyBcIjtcXG5leHBvcnRzLm1vZHVsZXMgPSBcIik7XHJcblx0XHRzb3VyY2UuYWRkKG1vZHVsZXNTb3VyY2UpO1xyXG5cdFx0c291cmNlLmFkZChcIjtcIik7XHJcblx0XHRyZXR1cm4gc291cmNlO1xyXG5cdH0pO1xyXG5cdGhvdFVwZGF0ZUNodW5rVGVtcGxhdGUucGx1Z2luKFwiaGFzaFwiLCBmdW5jdGlvbihoYXNoKSB7XHJcblx0XHRoYXNoLnVwZGF0ZShcIk5vZGVIb3RVcGRhdGVDaHVua1RlbXBsYXRlUGx1Z2luXCIpO1xyXG5cdFx0aGFzaC51cGRhdGUoXCIzXCIpO1xyXG5cdFx0aGFzaC51cGRhdGUodGhpcy5vdXRwdXRPcHRpb25zLmhvdFVwZGF0ZUZ1bmN0aW9uICsgXCJcIik7XHJcblx0XHRoYXNoLnVwZGF0ZSh0aGlzLm91dHB1dE9wdGlvbnMubGlicmFyeSArIFwiXCIpO1xyXG5cdH0pO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL25vZGUvTm9kZUhvdFVwZGF0ZUNodW5rVGVtcGxhdGVQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDMwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgRXh0ZXJuYWxzUGx1Z2luID0gcmVxdWlyZShcIi4uL0V4dGVybmFsc1BsdWdpblwiKTtcclxuXHJcbmZ1bmN0aW9uIE5vZGVUYXJnZXRQbHVnaW4oKSB7fVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBOb2RlVGFyZ2V0UGx1Z2luO1xyXG5Ob2RlVGFyZ2V0UGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGNvbXBpbGVyKSB7XHJcblx0bmV3IEV4dGVybmFsc1BsdWdpbihcImNvbW1vbmpzXCIsIE9iamVjdC5rZXlzKHByb2Nlc3MuYmluZGluZyhcIm5hdGl2ZXNcIikpKS5hcHBseShjb21waWxlcik7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvbm9kZS9Ob2RlVGFyZ2V0UGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIEV4dGVybmFsTW9kdWxlRmFjdG9yeVBsdWdpbiA9IHJlcXVpcmUoXCIuL0V4dGVybmFsTW9kdWxlRmFjdG9yeVBsdWdpblwiKTtcclxuXHJcbmZ1bmN0aW9uIEV4dGVybmFsc1BsdWdpbih0eXBlLCBleHRlcm5hbHMpIHtcclxuXHR0aGlzLnR5cGUgPSB0eXBlO1xyXG5cdHRoaXMuZXh0ZXJuYWxzID0gZXh0ZXJuYWxzO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gRXh0ZXJuYWxzUGx1Z2luO1xyXG5FeHRlcm5hbHNQbHVnaW4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oY29tcGlsZXIpIHtcclxuXHRjb21waWxlci5wbHVnaW4oXCJjb21waWxlXCIsIGZ1bmN0aW9uKHBhcmFtcykge1xyXG5cdFx0cGFyYW1zLm5vcm1hbE1vZHVsZUZhY3RvcnkuYXBwbHkobmV3IEV4dGVybmFsTW9kdWxlRmFjdG9yeVBsdWdpbih0aGlzLnR5cGUsIHRoaXMuZXh0ZXJuYWxzKSk7XHJcblx0fS5iaW5kKHRoaXMpKTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9FeHRlcm5hbHNQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDMwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgRXh0ZXJuYWxNb2R1bGUgPSByZXF1aXJlKFwiLi9FeHRlcm5hbE1vZHVsZVwiKTtcclxuXHJcbmZ1bmN0aW9uIEV4dGVybmFsTW9kdWxlRmFjdG9yeVBsdWdpbih0eXBlLCBleHRlcm5hbHMpIHtcclxuXHR0aGlzLnR5cGUgPSB0eXBlO1xyXG5cdHRoaXMuZXh0ZXJuYWxzID0gZXh0ZXJuYWxzO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gRXh0ZXJuYWxNb2R1bGVGYWN0b3J5UGx1Z2luO1xyXG5cclxuRXh0ZXJuYWxNb2R1bGVGYWN0b3J5UGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKG5vcm1hbE1vZHVsZUZhY3RvcnkpIHtcclxuXHR2YXIgZ2xvYmFsVHlwZSA9IHRoaXMudHlwZTtcclxuXHRub3JtYWxNb2R1bGVGYWN0b3J5LnBsdWdpbihcImZhY3RvcnlcIiwgZnVuY3Rpb24oZmFjdG9yeSkge1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XHJcblx0XHRcdHZhciBjb250ZXh0ID0gZGF0YS5jb250ZXh0O1xyXG5cdFx0XHR2YXIgZGVwZW5kZW5jeSA9IGRhdGEuZGVwZW5kZW5jeTtcclxuXHJcblx0XHRcdGZ1bmN0aW9uIGhhbmRsZUV4dGVybmFsKHZhbHVlLCB0eXBlLCBjYWxsYmFjaykge1xyXG5cdFx0XHRcdGlmKHR5cGVvZiB0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdFx0XHRcdGNhbGxiYWNrID0gdHlwZTtcclxuXHRcdFx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHZhbHVlID09PSBmYWxzZSkgcmV0dXJuIGZhY3RvcnkoZGF0YSwgY2FsbGJhY2spO1xyXG5cdFx0XHRcdGlmKHZhbHVlID09PSB0cnVlKSB2YWx1ZSA9IGRlcGVuZGVuY3kucmVxdWVzdDtcclxuXHRcdFx0XHRpZih0eXBlb2YgdHlwZSA9PT0gXCJ1bmRlZmluZWRcIiAmJiAvXlthLXowLTldKyAvLnRlc3QodmFsdWUpKSB7XHJcblx0XHRcdFx0XHR2YXIgaWR4ID0gdmFsdWUuaW5kZXhPZihcIiBcIik7XHJcblx0XHRcdFx0XHR0eXBlID0gdmFsdWUuc3Vic3RyKDAsIGlkeCk7XHJcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnN1YnN0cihpZHggKyAxKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgbmV3IEV4dGVybmFsTW9kdWxlKHZhbHVlLCB0eXBlIHx8IGdsb2JhbFR5cGUpKTtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHQoZnVuY3Rpb24gaGFuZGxlRXh0ZXJuYWxzKGV4dGVybmFscywgY2FsbGJhY2spIHtcclxuXHRcdFx0XHRpZih0eXBlb2YgZXh0ZXJuYWxzID09PSBcInN0cmluZ1wiKSB7XHJcblx0XHRcdFx0XHRpZihleHRlcm5hbHMgPT09IGRlcGVuZGVuY3kucmVxdWVzdCkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gaGFuZGxlRXh0ZXJuYWwoZGVwZW5kZW5jeS5yZXF1ZXN0LCBjYWxsYmFjayk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIGlmKEFycmF5LmlzQXJyYXkoZXh0ZXJuYWxzKSkge1xyXG5cdFx0XHRcdFx0dmFyIGkgPSAwO1xyXG5cdFx0XHRcdFx0KGZ1bmN0aW9uIG5leHQoKSB7XHJcblx0XHRcdFx0XHRcdGRvIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgYXN5bmMgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdGlmKGkgPj0gZXh0ZXJuYWxzLmxlbmd0aCkgcmV0dXJuIGNhbGxiYWNrKCk7XHJcblx0XHRcdFx0XHRcdFx0aGFuZGxlRXh0ZXJuYWxzKGV4dGVybmFsc1tpKytdLCBmdW5jdGlvbihlcnIsIG1vZHVsZSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHRcdFx0XHRcdFx0XHRcdGlmKCFtb2R1bGUpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYoYXN5bmMpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhc3luYyA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbmV4dCgpO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgbW9kdWxlKTtcclxuXHRcdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdFx0fSB3aGlsZSAoIWFzeW5jKTtcclxuXHRcdFx0XHRcdFx0YXN5bmMgPSBmYWxzZTtcclxuXHRcdFx0XHRcdH0oKSk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fSBlbHNlIGlmKGV4dGVybmFscyBpbnN0YW5jZW9mIFJlZ0V4cCkge1xyXG5cdFx0XHRcdFx0aWYoZXh0ZXJuYWxzLnRlc3QoZGVwZW5kZW5jeS5yZXF1ZXN0KSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gaGFuZGxlRXh0ZXJuYWwoZGVwZW5kZW5jeS5yZXF1ZXN0LCBjYWxsYmFjayk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIGlmKHR5cGVvZiBleHRlcm5hbHMgPT09IFwiZnVuY3Rpb25cIikge1xyXG5cdFx0XHRcdFx0ZXh0ZXJuYWxzLmNhbGwobnVsbCwgY29udGV4dCwgZGVwZW5kZW5jeS5yZXF1ZXN0LCBmdW5jdGlvbihlcnIsIHZhbHVlLCB0eXBlKSB7XHJcblx0XHRcdFx0XHRcdGlmKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcblx0XHRcdFx0XHRcdGlmKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0XHRcdFx0XHRcdGhhbmRsZUV4dGVybmFsKHZhbHVlLCB0eXBlLCBjYWxsYmFjayk7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fSBlbHNlIGlmKHR5cGVvZiBleHRlcm5hbHMgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4dGVybmFscywgZGVwZW5kZW5jeS5yZXF1ZXN0KSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGhhbmRsZUV4dGVybmFsKGV4dGVybmFsc1tkZXBlbmRlbmN5LnJlcXVlc3RdLCBjYWxsYmFjayk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHRcdH0odGhpcy5leHRlcm5hbHMsIGZ1bmN0aW9uKGVyciwgbW9kdWxlKSB7XHJcblx0XHRcdFx0aWYoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHRcdFx0XHRpZighbW9kdWxlKSByZXR1cm4gaGFuZGxlRXh0ZXJuYWwoZmFsc2UsIGNhbGxiYWNrKTtcclxuXHRcdFx0XHRyZXR1cm4gY2FsbGJhY2sobnVsbCwgbW9kdWxlKTtcclxuXHRcdFx0fSkpO1xyXG5cdFx0fS5iaW5kKHRoaXMpO1xyXG5cdH0uYmluZCh0aGlzKSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvRXh0ZXJuYWxNb2R1bGVGYWN0b3J5UGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIE1vZHVsZSA9IHJlcXVpcmUoXCIuL01vZHVsZVwiKTtcclxudmFyIE9yaWdpbmFsU291cmNlID0gcmVxdWlyZShcIndlYnBhY2stY29yZS9saWIvT3JpZ2luYWxTb3VyY2VcIik7XHJcbnZhciBSYXdTb3VyY2UgPSByZXF1aXJlKFwid2VicGFjay1jb3JlL2xpYi9SYXdTb3VyY2VcIik7XHJcbnZhciBXZWJwYWNrTWlzc2luZ01vZHVsZSA9IHJlcXVpcmUoXCIuL2RlcGVuZGVuY2llcy9XZWJwYWNrTWlzc2luZ01vZHVsZVwiKTtcclxuXHJcbmZ1bmN0aW9uIEV4dGVybmFsTW9kdWxlKHJlcXVlc3QsIHR5cGUpIHtcclxuXHRNb2R1bGUuY2FsbCh0aGlzKTtcclxuXHR0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xyXG5cdHRoaXMudHlwZSA9IHR5cGU7XHJcblx0dGhpcy5idWlsdCA9IGZhbHNlO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gRXh0ZXJuYWxNb2R1bGU7XHJcblxyXG5FeHRlcm5hbE1vZHVsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE1vZHVsZS5wcm90b3R5cGUpO1xyXG5cclxuRXh0ZXJuYWxNb2R1bGUucHJvdG90eXBlLmV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbkV4dGVybmFsTW9kdWxlLnByb3RvdHlwZS5pZGVudGlmaWVyID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIFwiZXh0ZXJuYWwgXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnJlcXVlc3QpO1xyXG59O1xyXG5cclxuRXh0ZXJuYWxNb2R1bGUucHJvdG90eXBlLnJlYWRhYmxlSWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBcImV4dGVybmFsIFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy5yZXF1ZXN0KTtcclxufTtcclxuXHJcbkV4dGVybmFsTW9kdWxlLnByb3RvdHlwZS5uZWVkUmVidWlsZCA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBmYWxzZTtcclxufTtcclxuXHJcbkV4dGVybmFsTW9kdWxlLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNvbXBpbGF0aW9uLCByZXNvbHZlciwgZnMsIGNhbGxiYWNrKSB7XHJcblx0dGhpcy5idWlsdFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuXHRjYWxsYmFjaygpO1xyXG59O1xyXG5cclxuRXh0ZXJuYWxNb2R1bGUucHJvdG90eXBlLnNvdXJjZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBzdHIgPSBcInRocm93IG5ldyBFcnJvcignRXh0ZXJuYWxzIG5vdCBzdXBwb3J0ZWQnKTtcIjtcclxuXHR2YXIgcmVxdWVzdCA9IHRoaXMucmVxdWVzdDtcclxuXHRpZih0eXBlb2YgcmVxdWVzdCA9PT0gXCJvYmplY3RcIikgcmVxdWVzdCA9IHJlcXVlc3RbdGhpcy50eXBlXTtcclxuXHRzd2l0Y2godGhpcy50eXBlKSB7XHJcblx0XHRjYXNlIFwidGhpc1wiOlxyXG5cdFx0Y2FzZSBcIndpbmRvd1wiOlxyXG5cdFx0Y2FzZSBcImdsb2JhbFwiOlxyXG5cdFx0XHRpZihBcnJheS5pc0FycmF5KHJlcXVlc3QpKSB7XHJcblx0XHRcdFx0c3RyID0gXCIoZnVuY3Rpb24oKSB7IG1vZHVsZS5leHBvcnRzID0gXCIgKyB0aGlzLnR5cGUgKyByZXF1ZXN0Lm1hcChmdW5jdGlvbihyKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gXCJbXCIgKyBKU09OLnN0cmluZ2lmeShyKSArIFwiXVwiO1xyXG5cdFx0XHRcdH0pLmpvaW4oXCJcIikgKyBcIjsgfSgpKTtcIjtcclxuXHRcdFx0fSBlbHNlXHJcblx0XHRcdFx0c3RyID0gXCIoZnVuY3Rpb24oKSB7IG1vZHVsZS5leHBvcnRzID0gXCIgKyB0aGlzLnR5cGUgKyBcIltcIiArIEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpICsgXCJdOyB9KCkpO1wiO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgXCJjb21tb25qc1wiOlxyXG5cdFx0Y2FzZSBcImNvbW1vbmpzMlwiOlxyXG5cdFx0XHRpZihBcnJheS5pc0FycmF5KHJlcXVlc3QpKSB7XHJcblx0XHRcdFx0c3RyID0gXCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIgKyBKU09OLnN0cmluZ2lmeShyZXF1ZXN0WzBdKSArIFwiKVwiICsgcmVxdWVzdC5zbGljZSgxKS5tYXAoZnVuY3Rpb24ocikge1xyXG5cdFx0XHRcdFx0cmV0dXJuIFwiW1wiICsgSlNPTi5zdHJpbmdpZnkocikgKyBcIl1cIjtcclxuXHRcdFx0XHR9KS5qb2luKFwiXCIpICsgXCI7XCI7XHJcblx0XHRcdH0gZWxzZVxyXG5cdFx0XHRcdHN0ciA9IFwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiICsgSlNPTi5zdHJpbmdpZnkocmVxdWVzdCkgKyBcIik7XCI7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBcImFtZFwiOlxyXG5cdFx0Y2FzZSBcInVtZFwiOlxyXG5cdFx0Y2FzZSBcInVtZDJcIjpcclxuXHRcdFx0c3RyID0gXCJcIjtcclxuXHRcdFx0aWYodGhpcy5vcHRpb25hbCkge1xyXG5cdFx0XHRcdHN0ciArPSBcImlmKHR5cGVvZiBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX1wiICsgdGhpcy5pZCArIFwiX18gPT09ICd1bmRlZmluZWQnKSB7XCIgKyBXZWJwYWNrTWlzc2luZ01vZHVsZS5tb2R1bGVDb2RlKHJlcXVlc3QpICsgXCJ9XFxuXCI7XHJcblx0XHRcdH1cclxuXHRcdFx0c3RyICs9IFwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX1wiICsgdGhpcy5pZCArIFwiX187XCI7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0c3RyID0gXCJcIjtcclxuXHRcdFx0aWYodGhpcy5vcHRpb25hbCkge1xyXG5cdFx0XHRcdHN0ciArPSBcImlmKHR5cGVvZiBcIiArIHJlcXVlc3QgKyBcIiA9PT0gJ3VuZGVmaW5lZCcpIHtcIiArIFdlYnBhY2tNaXNzaW5nTW9kdWxlLm1vZHVsZUNvZGUocmVxdWVzdCkgKyBcIn1cXG5cIjtcclxuXHRcdFx0fVxyXG5cdFx0XHRzdHIgKz0gXCJtb2R1bGUuZXhwb3J0cyA9IFwiICsgcmVxdWVzdCArIFwiO1wiO1xyXG5cdFx0XHRicmVhaztcclxuXHR9XHJcblx0aWYodGhpcy51c2VTb3VyY2VNYXApIHtcclxuXHRcdHJldHVybiBuZXcgT3JpZ2luYWxTb3VyY2Uoc3RyLCB0aGlzLmlkZW50aWZpZXIoKSk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHJldHVybiBuZXcgUmF3U291cmNlKHN0cik7XHJcblx0fVxyXG59O1xyXG5cclxuRXh0ZXJuYWxNb2R1bGUucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gNDI7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvRXh0ZXJuYWxNb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDMwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgZnMgPSByZXF1aXJlKFwiZnNcIik7XHJcbnZhciBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbnZhciBhc3luYyA9IHJlcXVpcmUoXCJhc3luY1wiKTtcclxuXHJcbmZ1bmN0aW9uIE9sZE5vZGVXYXRjaEZpbGVTeXN0ZW0oaW5wdXRGaWxlU3lzdGVtKSB7XHJcblx0dGhpcy5pbnB1dEZpbGVTeXN0ZW0gPSBpbnB1dEZpbGVTeXN0ZW07XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBPbGROb2RlV2F0Y2hGaWxlU3lzdGVtO1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBmaWxlcyB7U3RyaW5nW119IGEgc29ydGVkIGFycmF5IG9mIHBhdGhzIHRvIGZpbGVzXHJcbiAqIEBwYXJhbSBkaXJzIHtTdHJpbmdbXX0gYSBzb3J0ZWQgYXJyYXkgb2YgcGF0aHMgdG8gZGlyZWN0b3JpZXNcclxuICogQHBhcmFtIHN0YXJ0VGltZSB7bnVtYmVyfSB0aGUgdmlydHVhbCBzdGFydCB0aW1lXHJcbiAqIEBwYXJhbSBkZWxheSB7bnVtYmVyfSBpbiBtcywgdGhlIHRpbWUgdG8gd2FpdCB0byBzaWduYWwgYWZ0ZXIgdGhlIGZpcnN0IGNoYW5nZVxyXG4gKiBAcGFyYW0gY2FsbGJhY2sge2Z1bmN0aW9uKGVyciwgZmlsZXNNb2RpZmllZDogU3RyaW5nW10sIGRpcnNNb2RpZmllZDogU3RyaW5nW10sIGZpbGVUaW1lc3RhbXBzOiBPYmplY3QsIGRpclRpbWVzdGFtcHM6IE9iamVjdCldIGNhbGxlZCBvbmNlIGFmdGVyIGNoYW5nZSBwbHVzIGRlbGF5XHJcbiAqIEBwYXJhbSBjYWxsYmFja1VuZGVsYXllZCB7ZnVuY3Rpb24oKX0gY2FsbGVkIG9uY2UgYWZ0ZXIgZmlyc3QgY2hhbmdlXHJcbiAqL1xyXG5PbGROb2RlV2F0Y2hGaWxlU3lzdGVtLnByb3RvdHlwZS53YXRjaCA9IGZ1bmN0aW9uKGZpbGVzLCBkaXJzLCBtaXNzaW5nLCBzdGFydFRpbWUsIGRlbGF5LCBjYWxsYmFjaywgY2FsbGJhY2tVbmRlbGF5ZWQpIHtcclxuXHR2YXIgaW5wdXRGaWxlU3lzdGVtID0gdGhpcy5pbnB1dEZpbGVTeXN0ZW07XHJcblxyXG5cdGlmKCFjYWxsYmFja1VuZGVsYXllZCkgY2FsbGJhY2tVbmRlbGF5ZWQgPSBmdW5jdGlvbigpIHt9O1xyXG5cdHZhciBjbG9zZWQgPSBmYWxzZTtcclxuXHR2YXIgZmlsZVRpbWVzdGFtcHMgPSB7fTtcclxuXHR2YXIgZGlyVGltZXN0YW1wcyA9IHt9O1xyXG5cdHZhciBmaWxlc01vZGlmaWVkID0ge307XHJcblx0dmFyIGRpcnNNb2RpZmllZCA9IHt9O1xyXG5cclxuXHR2YXIgbGFzdENoYW5nZVRpbWU7XHJcblxyXG5cdHN0YXJ0VGltZSA9IE1hdGguZmxvb3Ioc3RhcnRUaW1lIC8gMTAwMCkgKiAxMDAwOyAvLyBvbmx5IDEgc2Vjb25kIGFjY3VyYWN5XHJcblxyXG5cdHZhciBkaXJlY3RvcmllcyA9IHt9O1xyXG5cdGRpcnMuZm9yRWFjaChmdW5jdGlvbihkaXIpIHtcclxuXHRcdGRpcmVjdG9yaWVzW2Rpcl0gPSB7XHJcblx0XHRcdGNvbnRleHQ6IGRpcixcclxuXHRcdFx0ZmlsZXM6IFtdXHJcblx0XHR9O1xyXG5cdH0pO1xyXG5cdGZpbGVzLmZvckVhY2goZnVuY3Rpb24oZmlsZSkge1xyXG5cdFx0dmFyIGRpciA9IHBhdGguZGlybmFtZShmaWxlKTtcclxuXHRcdGlmKCFkaXJlY3Rvcmllc1tkaXJdKSBkaXJlY3Rvcmllc1tkaXJdID0ge1xyXG5cdFx0XHRmaWxlczogW11cclxuXHRcdH07XHJcblx0XHRkaXJlY3Rvcmllc1tkaXJdLmZpbGVzLnB1c2goZmlsZSk7XHJcblx0fSk7XHJcblxyXG5cdHZhciBpdGVtcyA9IE9iamVjdC5rZXlzKGRpcmVjdG9yaWVzKS5tYXAoZnVuY3Rpb24oZGlyKSB7XHJcblx0XHRkaXJlY3Rvcmllc1tkaXJdLnBhdGggPSBkaXI7XHJcblx0XHRyZXR1cm4gZGlyZWN0b3JpZXNbZGlyXTtcclxuXHR9KTtcclxuXHRpdGVtcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdGlmKGEucGF0aCA9PT0gYi5wYXRoKSByZXR1cm4gMDtcclxuXHRcdHJldHVybiBhLnBhdGggPCBiLnBhdGggPyAtMSA6IDE7XHJcblx0fSk7XHJcblx0aXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRpZihpdGVtLmZpbGVzKSB7XHJcblx0XHRcdGl0ZW0uZmlsZXMuc29ydCgpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHR2YXIgaW5pdGlhbENoYW5nZSA9IGZhbHNlO1xyXG5cdHZhciBjaGFuZ2UgPSBmdW5jdGlvbigpIHtcclxuXHRcdGluaXRpYWxDaGFuZ2UgPSB0cnVlO1xyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHJlYWRTdGF0KGl0ZW0sIGNhbGxiYWNrKSB7XHJcblx0XHRpZihpdGVtLmNvbnRleHQpIHtcclxuXHRcdFx0ZnMucmVhZGRpcihpdGVtLnBhdGgsIGZ1bmN0aW9uKGVyciwgZmlsZXMpIHtcclxuXHRcdFx0XHRmdW5jdGlvbiBvblRpbWVzdGFtcCh0cykge1xyXG5cdFx0XHRcdFx0aWYoIWRpclRpbWVzdGFtcHNbaXRlbS5jb250ZXh0XSB8fCBkaXJUaW1lc3RhbXBzW2l0ZW0uY29udGV4dF0gPCB0cylcclxuXHRcdFx0XHRcdFx0ZGlyVGltZXN0YW1wc1tpdGVtLmNvbnRleHRdID0gdHM7XHJcblx0XHRcdFx0XHRpZih0cyA+PSBzdGFydFRpbWUpIHtcclxuXHRcdFx0XHRcdFx0ZGlyc01vZGlmaWVkW2l0ZW0uY29udGV4dF0gPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRjaGFuZ2UoaXRlbS5wYXRoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiBjYWxsYmFjaygpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihlcnIpIHJldHVybiBvblRpbWVzdGFtcChJbmZpbml0eSk7XHJcblx0XHRcdFx0YXN5bmMubWFwKGZpbGVzLCBmdW5jdGlvbihmaWxlLCBjYWxsYmFjaykge1xyXG5cdFx0XHRcdFx0ZmlsZSA9IHBhdGguam9pbihpdGVtLnBhdGgsIGZpbGUpO1xyXG5cdFx0XHRcdFx0dmFyIGlzRmlsZSA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0aWYoaXRlbS5maWxlcykge1xyXG5cdFx0XHRcdFx0XHRpZihiaW5hcnlTZWFyY2goaXRlbS5maWxlcywgZnVuY3Rpb24ocGF0aCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYocGF0aCA9PT0gZmlsZSkgcmV0dXJuIDA7XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcGF0aCA8IGZpbGUgPyAtMSA6IDE7XHJcblx0XHRcdFx0XHRcdFx0fSkgPj0gMCkge1xyXG5cdFx0XHRcdFx0XHRcdGlzRmlsZSA9IHRydWU7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGZzLnN0YXQoZmlsZSwgZnVuY3Rpb24oZXJyLCBzdGF0KSB7XHJcblx0XHRcdFx0XHRcdHZhciB0cyA9IGVyciA/IEluZmluaXR5IDogc3RhdC5tdGltZS5nZXRUaW1lKCk7XHJcblx0XHRcdFx0XHRcdGlmKGlzRmlsZSkge1xyXG5cdFx0XHRcdFx0XHRcdGZpbGVUaW1lc3RhbXBzW2ZpbGVdID0gdHM7XHJcblx0XHRcdFx0XHRcdFx0aWYodHMgPj0gc3RhcnRUaW1lKSBmaWxlc01vZGlmaWVkW2ZpbGVdID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gY2FsbGJhY2sobnVsbCwgdHMpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fSwgZnVuY3Rpb24oZXJyLCB0aW1lc3RhbXBzKSB7XHJcblx0XHRcdFx0XHRpZihlcnIpIHJldHVybiBvblRpbWVzdGFtcChJbmZpbml0eSk7XHJcblx0XHRcdFx0XHR2YXIgdHMgPSB0aW1lc3RhbXBzLnJlZHVjZShmdW5jdGlvbihtYXgsIHRzKSB7XHJcblx0XHRcdFx0XHRcdGlmKHRzID4gbWF4KVxyXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cztcclxuXHRcdFx0XHRcdFx0cmV0dXJuIG1heDtcclxuXHRcdFx0XHRcdH0sIDApO1xyXG5cdFx0XHRcdFx0b25UaW1lc3RhbXAodHMpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGFzeW5jLmZvckVhY2goaXRlbS5maWxlcywgZnVuY3Rpb24oZmlsZSwgY2FsbGJhY2spIHtcclxuXHRcdFx0XHRmcy5zdGF0KGZpbGUsIGZ1bmN0aW9uKGVyciwgc3RhdCkge1xyXG5cdFx0XHRcdFx0dmFyIHRzID0gZXJyID8gSW5maW5pdHkgOiBzdGF0Lm10aW1lLmdldFRpbWUoKTtcclxuXHRcdFx0XHRcdGZpbGVUaW1lc3RhbXBzW2ZpbGVdID0gdHM7XHJcblx0XHRcdFx0XHRpZih0cyA+PSBzdGFydFRpbWUpIHtcclxuXHRcdFx0XHRcdFx0ZmlsZXNNb2RpZmllZFtmaWxlXSA9IHRydWU7XHJcblx0XHRcdFx0XHRcdGNoYW5nZShmaWxlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiBjYWxsYmFjayhudWxsLCB0cyk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0sIGNhbGxiYWNrKTtcclxuXHRcdH1cclxuXHR9XHJcblx0YXN5bmMuZm9yRWFjaChpdGVtcywgZnVuY3Rpb24gcHJvY2Vzc0l0ZW0oaXRlbSwgY2FsbGJhY2spIHtcclxuXHRcdHZhciBpc1J1bm5pbmcgPSBmYWxzZTtcclxuXHRcdHZhciBpc1NjaGVkdWxlZCA9IGZhbHNlO1xyXG5cdFx0aXRlbS53YXRjaGVyID0gZnMud2F0Y2goaXRlbS5wYXRoLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0aWYoaXNSdW5uaW5nKSB7XHJcblx0XHRcdFx0aXNTY2hlZHVsZWQgPSB0cnVlO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHRpc1J1bm5pbmcgPSB0cnVlO1xyXG5cdFx0XHRyZWFkU3RhdChpdGVtLCBkb25lKTtcclxuXHRcdH0pO1xyXG5cdFx0aWYoaXRlbS5jb250ZXh0KSB7XHJcblx0XHRcdGl0ZW0uY2hpbGRyZW4gPSBbXTtcclxuXHRcdFx0ZnMucmVhZGRpcihpdGVtLnBhdGgsIGZ1bmN0aW9uKGVyciwgZmlsZXMpIHtcclxuXHRcdFx0XHRpZihlcnIpIHtcclxuXHRcdFx0XHRcdGNoYW5nZSgpO1xyXG5cdFx0XHRcdFx0b25XYXRjaGVyQXBwbGllZCgpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRhc3luYy5mb3JFYWNoKGZpbGVzLCBmdW5jdGlvbihmaWxlLCBjYWxsYmFjaykge1xyXG5cdFx0XHRcdFx0ZmlsZSA9IHBhdGguam9pbihpdGVtLnBhdGgsIGZpbGUpO1xyXG5cdFx0XHRcdFx0ZnMuc3RhdChmaWxlLCBmdW5jdGlvbihlcnIsIHN0YXQpIHtcclxuXHRcdFx0XHRcdFx0aWYoZXJyKSB7XHJcblx0XHRcdFx0XHRcdFx0Y2hhbmdlKGZpbGUpO1xyXG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGlmKCFzdGF0LmlzRGlyZWN0b3J5KCkpIHJldHVybiBjYWxsYmFjaygpO1xyXG5cdFx0XHRcdFx0XHR2YXIgc3ViaXRlbSA9IHtcclxuXHRcdFx0XHRcdFx0XHRwYXRoOiBmaWxlLFxyXG5cdFx0XHRcdFx0XHRcdGNvbnRleHQ6IGl0ZW0uY29udGV4dFxyXG5cdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0XHRpdGVtLmNoaWxkcmVuLnB1c2goc3ViaXRlbSk7XHJcblx0XHRcdFx0XHRcdHByb2Nlc3NJdGVtKHN1Yml0ZW0sIGNhbGxiYWNrKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0sIG9uV2F0Y2hlckFwcGxpZWQpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSBvbldhdGNoZXJBcHBsaWVkKCk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gb25XYXRjaGVyQXBwbGllZCgpIHtcclxuXHRcdFx0cmVhZFN0YXQoaXRlbSwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdFx0XHRkb25lKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGRvbmUoKSB7XHJcblx0XHRcdGlmKGNsb3NlZCkgcmV0dXJuO1xyXG5cdFx0XHRpZihpc1NjaGVkdWxlZCkge1xyXG5cdFx0XHRcdGlzU2NoZWR1bGVkID0gZmFsc2U7XHJcblx0XHRcdFx0cmVhZFN0YXQoaXRlbSwgZG9uZSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aXNSdW5uaW5nID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LCBmdW5jdGlvbigpIHtcclxuXHRcdHZhciB0aW1lb3V0O1xyXG5cdFx0aWYoaW5pdGlhbENoYW5nZSkge1xyXG5cclxuXHRcdFx0Y2FsbGJhY2tVbmRlbGF5ZWQoKTtcclxuXHRcdFx0aWYoZGVsYXkpIHtcclxuXHRcdFx0XHRsYXN0Q2hhbmdlVGltZSA9IERhdGUubm93KCk7XHJcblx0XHRcdFx0Y2hhbmdlID0gcmVzdGFydERlbGF5O1xyXG5cdFx0XHRcdHRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uVGltZW91dCwgZGVsYXkpO1xyXG5cdFx0XHR9IGVsc2Ugb25UaW1lb3V0KCk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNoYW5nZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdFx0XHRjYWxsYmFja1VuZGVsYXllZCgpO1xyXG5cdFx0XHRcdGlmKGRlbGF5KSB7XHJcblx0XHRcdFx0XHRsYXN0Q2hhbmdlVGltZSA9IERhdGUubm93KCk7XHJcblx0XHRcdFx0XHRjaGFuZ2UgPSByZXN0YXJ0RGVsYXk7XHJcblx0XHRcdFx0XHR0aW1lb3V0ID0gc2V0VGltZW91dChvblRpbWVvdXQsIGRlbGF5KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Y2hhbmdlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdFx0XHRcdG9uVGltZW91dCgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcmVzdGFydERlbGF5KCkge1xyXG5cdFx0XHRsYXN0Q2hhbmdlVGltZSA9IERhdGUubm93KCk7XHJcblx0XHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcclxuXHRcdFx0dGltZW91dCA9IHNldFRpbWVvdXQob25UaW1lb3V0LCBkZWxheSk7XHJcblx0XHR9XHJcblxyXG5cdH0pO1xyXG5cclxuXHQvLyA3LlxyXG5cdGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcclxuXHRcdHZhciBuZXh0U2Vjb25kID0gTWF0aC5jZWlsKGxhc3RDaGFuZ2VUaW1lIC8gMTAwMCkgKiAxMDAwO1xyXG5cdFx0dmFyIHRpbWVUb05leHRTZWNvbmQgPSBuZXh0U2Vjb25kIC0gRGF0ZS5ub3coKTtcclxuXHRcdGlmKHRpbWVUb05leHRTZWNvbmQgPiAwKSB7XHJcblx0XHRcdHNldFRpbWVvdXQob25UaW1lb3V0LCB0aW1lVG9OZXh0U2Vjb25kKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0Y2hhbmdlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdGlmKGNsb3NlZCkgcmV0dXJuO1xyXG5cdFx0dmFyIG91dGRhdGVkRmlsZXMgPSBPYmplY3Qua2V5cyhmaWxlc01vZGlmaWVkKS5zb3J0KCk7XHJcblx0XHR2YXIgb3V0ZGF0ZWREaXJzID0gT2JqZWN0LmtleXMoZGlyc01vZGlmaWVkKS5zb3J0KCk7XHJcblx0XHRpZihpbnB1dEZpbGVTeXN0ZW0gJiYgaW5wdXRGaWxlU3lzdGVtLnB1cmdlKSB7XHJcblx0XHRcdGlucHV0RmlsZVN5c3RlbS5wdXJnZShvdXRkYXRlZEZpbGVzKTtcclxuXHRcdFx0aW5wdXRGaWxlU3lzdGVtLnB1cmdlKG91dGRhdGVkRGlycyk7XHJcblx0XHR9XHJcblx0XHRjYWxsYmFjayhudWxsLCBvdXRkYXRlZEZpbGVzLCBvdXRkYXRlZERpcnMsIFtdLCBmaWxlVGltZXN0YW1wcywgZGlyVGltZXN0YW1wcyk7XHJcblxyXG5cdFx0Y2xvc2UoKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNsb3NlKCkge1xyXG5cdFx0Y2xvc2VkID0gdHJ1ZTtcclxuXHRcdGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gY2xvc2VJdGVtKGl0ZW0pIHtcclxuXHRcdFx0aXRlbS53YXRjaGVyLmNsb3NlKCk7XHJcblx0XHRcdGlmKGl0ZW0uY2hpbGRyZW4pIGl0ZW0uY2hpbGRyZW4uZm9yRWFjaChjbG9zZUl0ZW0pO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0Y2xvc2U6IGNsb3NlLFxyXG5cdFx0cGF1c2U6IGNsb3NlXHJcblx0fTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaChhcnJheSwgY29tcGFyYXRvcikge1xyXG5cdHZhciBsZWZ0ID0gMDtcclxuXHR2YXIgcmlnaHQgPSBhcnJheS5sZW5ndGggLSAxO1xyXG5cclxuXHR3aGlsZShsZWZ0IDw9IHJpZ2h0KSB7XHJcblx0XHR2YXIgbWlkZGxlID0gKChsZWZ0ICsgcmlnaHQpIC8gMikgfCAwO1xyXG5cdFx0dmFyIGNvbXAgPSBjb21wYXJhdG9yKGFycmF5W21pZGRsZV0pO1xyXG5cdFx0aWYoY29tcCA9PT0gMCkgcmV0dXJuIG1pZGRsZTtcclxuXHRcdGlmKGNvbXAgPiAwKSByaWdodCA9IG1pZGRsZSAtIDE7XHJcblx0XHRpZihjb21wIDwgMCkgbGVmdCA9IG1pZGRsZSArIDE7XHJcblx0fVxyXG5cdHJldHVybiAtMTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL25vZGUvT2xkTm9kZVdhdGNoRmlsZVN5c3RlbS5qc1xuLy8gbW9kdWxlIGlkID0gMzA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBTZXRWYXJNYWluVGVtcGxhdGVQbHVnaW4gPSByZXF1aXJlKFwiLi9TZXRWYXJNYWluVGVtcGxhdGVQbHVnaW5cIik7XHJcblxyXG5mdW5jdGlvbiBhY2Nlc3NvclRvT2JqZWN0QWNjZXNzKGFjY2Vzc29yKSB7XHJcblx0cmV0dXJuIGFjY2Vzc29yLm1hcChmdW5jdGlvbihhKSB7XHJcblx0XHRyZXR1cm4gXCJbXCIgKyBKU09OLnN0cmluZ2lmeShhKSArIFwiXVwiO1xyXG5cdH0pLmpvaW4oXCJcIik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFjY2Vzc29yQWNjZXNzKGJhc2UsIGFjY2Vzc29yLCBqb2luV2l0aCkge1xyXG5cdGFjY2Vzc29yID0gW10uY29uY2F0KGFjY2Vzc29yKTtcclxuXHRyZXR1cm4gYWNjZXNzb3IubWFwKGZ1bmN0aW9uKGEsIGlkeCkge1xyXG5cdFx0YSA9IGJhc2UgP1xyXG5cdFx0XHRiYXNlICsgYWNjZXNzb3JUb09iamVjdEFjY2VzcyhhY2Nlc3Nvci5zbGljZSgwLCBpZHggKyAxKSkgOlxyXG5cdFx0XHRhY2Nlc3NvclswXSArIGFjY2Vzc29yVG9PYmplY3RBY2Nlc3MoYWNjZXNzb3Iuc2xpY2UoMSwgaWR4ICsgMSkpO1xyXG5cdFx0aWYoaWR4ID09PSBhY2Nlc3Nvci5sZW5ndGggLSAxKSByZXR1cm4gYTtcclxuXHRcdGlmKGlkeCA9PT0gMCAmJiB0eXBlb2YgYmFzZSA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGEgKyBcIiA9IHR5cGVvZiBcIiArIGEgKyBcIiA9PT0gXFxcIm9iamVjdFxcXCIgPyBcIiArIGEgKyBcIiA6IHt9XCI7XHJcblx0XHRyZXR1cm4gYSArIFwiID0gXCIgKyBhICsgXCIgfHwge31cIjtcclxuXHR9KS5qb2luKGpvaW5XaXRoIHx8IFwiOyBcIik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIExpYnJhcnlUZW1wbGF0ZVBsdWdpbihuYW1lLCB0YXJnZXQsIHVtZE5hbWVkRGVmaW5lKSB7XHJcblx0dGhpcy5uYW1lID0gbmFtZTtcclxuXHR0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuXHR0aGlzLnVtZE5hbWVkRGVmaW5lID0gdW1kTmFtZWREZWZpbmU7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBMaWJyYXJ5VGVtcGxhdGVQbHVnaW47XHJcbkxpYnJhcnlUZW1wbGF0ZVBsdWdpbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbihjb21waWxlcikge1xyXG5cdGNvbXBpbGVyLnBsdWdpbihcInRoaXMtY29tcGlsYXRpb25cIiwgZnVuY3Rpb24oY29tcGlsYXRpb24pIHtcclxuXHRcdHN3aXRjaCh0aGlzLnRhcmdldCkge1xyXG5cdFx0XHRjYXNlIFwidmFyXCI6XHJcblx0XHRcdFx0Y29tcGlsYXRpb24uYXBwbHkobmV3IFNldFZhck1haW5UZW1wbGF0ZVBsdWdpbihcInZhciBcIiArIGFjY2Vzc29yQWNjZXNzKGZhbHNlLCB0aGlzLm5hbWUpKSk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgXCJhc3NpZ25cIjpcclxuXHRcdFx0XHRjb21waWxhdGlvbi5hcHBseShuZXcgU2V0VmFyTWFpblRlbXBsYXRlUGx1Z2luKGFjY2Vzc29yQWNjZXNzKHVuZGVmaW5lZCwgdGhpcy5uYW1lKSkpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwidGhpc1wiOlxyXG5cdFx0XHRjYXNlIFwid2luZG93XCI6XHJcblx0XHRcdGNhc2UgXCJnbG9iYWxcIjpcclxuXHRcdFx0XHRpZih0aGlzLm5hbWUpXHJcblx0XHRcdFx0XHRjb21waWxhdGlvbi5hcHBseShuZXcgU2V0VmFyTWFpblRlbXBsYXRlUGx1Z2luKGFjY2Vzc29yQWNjZXNzKHRoaXMudGFyZ2V0LCB0aGlzLm5hbWUpKSk7XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0Y29tcGlsYXRpb24uYXBwbHkobmV3IFNldFZhck1haW5UZW1wbGF0ZVBsdWdpbih0aGlzLnRhcmdldCwgdHJ1ZSkpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwiY29tbW9uanNcIjpcclxuXHRcdFx0XHRpZih0aGlzLm5hbWUpXHJcblx0XHRcdFx0XHRjb21waWxhdGlvbi5hcHBseShuZXcgU2V0VmFyTWFpblRlbXBsYXRlUGx1Z2luKGFjY2Vzc29yQWNjZXNzKFwiZXhwb3J0c1wiLCB0aGlzLm5hbWUpKSk7XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0Y29tcGlsYXRpb24uYXBwbHkobmV3IFNldFZhck1haW5UZW1wbGF0ZVBsdWdpbihcImV4cG9ydHNcIiwgdHJ1ZSkpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwiY29tbW9uanMyXCI6XHJcblx0XHRcdFx0Y29tcGlsYXRpb24uYXBwbHkobmV3IFNldFZhck1haW5UZW1wbGF0ZVBsdWdpbihcIm1vZHVsZS5leHBvcnRzXCIpKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBcImFtZFwiOlxyXG5cdFx0XHRcdHZhciBBbWRNYWluVGVtcGxhdGVQbHVnaW4gPSByZXF1aXJlKFwiLi9BbWRNYWluVGVtcGxhdGVQbHVnaW5cIik7XHJcblx0XHRcdFx0Y29tcGlsYXRpb24uYXBwbHkobmV3IEFtZE1haW5UZW1wbGF0ZVBsdWdpbih0aGlzLm5hbWUpKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBcInVtZFwiOlxyXG5cdFx0XHRjYXNlIFwidW1kMlwiOlxyXG5cdFx0XHRcdHZhciBVbWRNYWluVGVtcGxhdGVQbHVnaW4gPSByZXF1aXJlKFwiLi9VbWRNYWluVGVtcGxhdGVQbHVnaW5cIik7XHJcblx0XHRcdFx0Y29tcGlsYXRpb24uYXBwbHkobmV3IFVtZE1haW5UZW1wbGF0ZVBsdWdpbih0aGlzLm5hbWUsIHtcclxuXHRcdFx0XHRcdG9wdGlvbmFsQW1kRXh0ZXJuYWxBc0dsb2JhbDogdGhpcy50YXJnZXQgPT09IFwidW1kMlwiLFxyXG5cdFx0XHRcdFx0bmFtZWREZWZpbmU6IHRoaXMudW1kTmFtZWREZWZpbmVcclxuXHRcdFx0XHR9KSk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgXCJqc29ucFwiOlxyXG5cdFx0XHRcdHZhciBKc29ucEV4cG9ydE1haW5UZW1wbGF0ZVBsdWdpbiA9IHJlcXVpcmUoXCIuL0pzb25wRXhwb3J0TWFpblRlbXBsYXRlUGx1Z2luXCIpO1xyXG5cdFx0XHRcdGNvbXBpbGF0aW9uLmFwcGx5KG5ldyBKc29ucEV4cG9ydE1haW5UZW1wbGF0ZVBsdWdpbih0aGlzLm5hbWUpKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IodGhpcy50YXJnZXQgKyBcIiBpcyBub3QgYSB2YWxpZCBMaWJyYXJ5IHRhcmdldFwiKTtcclxuXHRcdH1cclxuXHR9LmJpbmQodGhpcykpO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL0xpYnJhcnlUZW1wbGF0ZVBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMzA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBDb25jYXRTb3VyY2UgPSByZXF1aXJlKFwid2VicGFjay1jb3JlL2xpYi9Db25jYXRTb3VyY2VcIik7XHJcblxyXG5mdW5jdGlvbiBTZXRWYXJNYWluVGVtcGxhdGVQbHVnaW4odmFyRXhwcmVzc2lvbiwgY29weU9iamVjdCkge1xyXG5cdHRoaXMudmFyRXhwcmVzc2lvbiA9IHZhckV4cHJlc3Npb247XHJcblx0dGhpcy5jb3B5T2JqZWN0ID0gY29weU9iamVjdDtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IFNldFZhck1haW5UZW1wbGF0ZVBsdWdpbjtcclxuU2V0VmFyTWFpblRlbXBsYXRlUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGNvbXBpbGF0aW9uKSB7XHJcblx0dmFyIG1haW5UZW1wbGF0ZSA9IGNvbXBpbGF0aW9uLm1haW5UZW1wbGF0ZTtcclxuXHRjb21waWxhdGlvbi50ZW1wbGF0ZXNQbHVnaW4oXCJyZW5kZXItd2l0aC1lbnRyeVwiLCBmdW5jdGlvbihzb3VyY2UsIGNodW5rLCBoYXNoKSB7XHJcblx0XHR2YXIgdmFyRXhwcmVzc2lvbiA9IG1haW5UZW1wbGF0ZS5hcHBseVBsdWdpbnNXYXRlcmZhbGwoXCJhc3NldC1wYXRoXCIsIHRoaXMudmFyRXhwcmVzc2lvbiwge1xyXG5cdFx0XHRoYXNoOiBoYXNoLFxyXG5cdFx0XHRjaHVuazogY2h1bmtcclxuXHRcdH0pO1xyXG5cdFx0aWYodGhpcy5jb3B5T2JqZWN0KSB7XHJcblx0XHRcdHJldHVybiBuZXcgQ29uY2F0U291cmNlKFwiKGZ1bmN0aW9uKGUsIGEpIHsgZm9yKHZhciBpIGluIGEpIGVbaV0gPSBhW2ldOyB9KFwiICtcclxuXHRcdFx0XHR2YXJFeHByZXNzaW9uICsgXCIsIFwiLCBzb3VyY2UsIFwiKSlcIik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgcHJlZml4ID0gdmFyRXhwcmVzc2lvbiArIFwiID1cXG5cIjtcclxuXHRcdFx0cmV0dXJuIG5ldyBDb25jYXRTb3VyY2UocHJlZml4LCBzb3VyY2UpO1xyXG5cdFx0fVxyXG5cdH0uYmluZCh0aGlzKSk7XHJcblx0bWFpblRlbXBsYXRlLnBsdWdpbihcImdsb2JhbC1oYXNoLXBhdGhzXCIsIGZ1bmN0aW9uKHBhdGhzKSB7XHJcblx0XHRpZih0aGlzLnZhckV4cHJlc3Npb24pIHBhdGhzLnB1c2godGhpcy52YXJFeHByZXNzaW9uKTtcclxuXHRcdHJldHVybiBwYXRocztcclxuXHR9KTtcclxuXHRtYWluVGVtcGxhdGUucGx1Z2luKFwiaGFzaFwiLCBmdW5jdGlvbihoYXNoKSB7XHJcblx0XHRoYXNoLnVwZGF0ZShcInNldCB2YXJcIik7XHJcblx0XHRoYXNoLnVwZGF0ZSh0aGlzLnZhckV4cHJlc3Npb24gKyBcIlwiKTtcclxuXHRcdGhhc2gudXBkYXRlKHRoaXMuY29weU9iamVjdCArIFwiXCIpO1xyXG5cdH0uYmluZCh0aGlzKSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvU2V0VmFyTWFpblRlbXBsYXRlUGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSAzMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIENvbmNhdFNvdXJjZSA9IHJlcXVpcmUoXCJ3ZWJwYWNrLWNvcmUvbGliL0NvbmNhdFNvdXJjZVwiKTtcclxuXHJcbmZ1bmN0aW9uIEFtZE1haW5UZW1wbGF0ZVBsdWdpbihuYW1lKSB7XHJcblx0dGhpcy5uYW1lID0gbmFtZTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IEFtZE1haW5UZW1wbGF0ZVBsdWdpbjtcclxuQW1kTWFpblRlbXBsYXRlUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGNvbXBpbGF0aW9uKSB7XHJcblx0dmFyIG1haW5UZW1wbGF0ZSA9IGNvbXBpbGF0aW9uLm1haW5UZW1wbGF0ZTtcclxuXHRjb21waWxhdGlvbi50ZW1wbGF0ZXNQbHVnaW4oXCJyZW5kZXItd2l0aC1lbnRyeVwiLCBmdW5jdGlvbihzb3VyY2UsIGNodW5rLCBoYXNoKSB7XHJcblx0XHR2YXIgZXh0ZXJuYWxzID0gY2h1bmsubW9kdWxlcy5maWx0ZXIoZnVuY3Rpb24obSkge1xyXG5cdFx0XHRyZXR1cm4gbS5leHRlcm5hbDtcclxuXHRcdH0pO1xyXG5cdFx0dmFyIGV4dGVybmFsc0RlcHNBcnJheSA9IEpTT04uc3RyaW5naWZ5KGV4dGVybmFscy5tYXAoZnVuY3Rpb24obSkge1xyXG5cdFx0XHRyZXR1cm4gdHlwZW9mIG0ucmVxdWVzdCA9PT0gXCJvYmplY3RcIiA/IG0ucmVxdWVzdC5hbWQgOiBtLnJlcXVlc3Q7XHJcblx0XHR9KSk7XHJcblx0XHR2YXIgZXh0ZXJuYWxzQXJndW1lbnRzID0gZXh0ZXJuYWxzLm1hcChmdW5jdGlvbihtKSB7XHJcblx0XHRcdHJldHVybiBcIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXCIgKyBtLmlkICsgXCJfX1wiO1xyXG5cdFx0fSkuam9pbihcIiwgXCIpO1xyXG5cdFx0aWYodGhpcy5uYW1lKSB7XHJcblx0XHRcdHZhciBuYW1lID0gbWFpblRlbXBsYXRlLmFwcGx5UGx1Z2luc1dhdGVyZmFsbChcImFzc2V0LXBhdGhcIiwgdGhpcy5uYW1lLCB7XHJcblx0XHRcdFx0aGFzaDogaGFzaCxcclxuXHRcdFx0XHRjaHVuazogY2h1bmtcclxuXHRcdFx0fSk7XHJcblx0XHRcdHJldHVybiBuZXcgQ29uY2F0U291cmNlKFwiZGVmaW5lKFwiICsgSlNPTi5zdHJpbmdpZnkobmFtZSkgKyBcIiwgXCIgKyBleHRlcm5hbHNEZXBzQXJyYXkgKyBcIiwgZnVuY3Rpb24oXCIgKyBleHRlcm5hbHNBcmd1bWVudHMgKyBcIikgeyByZXR1cm4gXCIsIHNvdXJjZSwgXCJ9KTtcIik7XHJcblx0XHR9IGVsc2UgaWYoZXh0ZXJuYWxzQXJndW1lbnRzKSB7XHJcblx0XHRcdHJldHVybiBuZXcgQ29uY2F0U291cmNlKFwiZGVmaW5lKFwiICsgZXh0ZXJuYWxzRGVwc0FycmF5ICsgXCIsIGZ1bmN0aW9uKFwiICsgZXh0ZXJuYWxzQXJndW1lbnRzICsgXCIpIHsgcmV0dXJuIFwiLCBzb3VyY2UsIFwifSk7XCIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBDb25jYXRTb3VyY2UoXCJkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBcIiwgc291cmNlLCBcIn0pO1wiKTtcclxuXHRcdH1cclxuXHR9LmJpbmQodGhpcykpO1xyXG5cdG1haW5UZW1wbGF0ZS5wbHVnaW4oXCJnbG9iYWwtaGFzaC1wYXRoc1wiLCBmdW5jdGlvbihwYXRocykge1xyXG5cdFx0aWYodGhpcy5uYW1lKSBwYXRocy5wdXNoKHRoaXMubmFtZSk7XHJcblx0XHRyZXR1cm4gcGF0aHM7XHJcblx0fS5iaW5kKHRoaXMpKTtcclxuXHRtYWluVGVtcGxhdGUucGx1Z2luKFwiaGFzaFwiLCBmdW5jdGlvbihoYXNoKSB7XHJcblx0XHRoYXNoLnVwZGF0ZShcImV4cG9ydHMgYW1kXCIpO1xyXG5cdFx0aGFzaC51cGRhdGUodGhpcy5uYW1lICsgXCJcIik7XHJcblx0fS5iaW5kKHRoaXMpKTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9BbWRNYWluVGVtcGxhdGVQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDMxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgQ29uY2F0U291cmNlID0gcmVxdWlyZShcIndlYnBhY2stY29yZS9saWIvQ29uY2F0U291cmNlXCIpO1xyXG52YXIgT3JpZ2luYWxTb3VyY2UgPSByZXF1aXJlKFwid2VicGFjay1jb3JlL2xpYi9PcmlnaW5hbFNvdXJjZVwiKTtcclxuXHJcbmZ1bmN0aW9uIGFjY2Vzc29yVG9PYmplY3RBY2Nlc3MoYWNjZXNzb3IpIHtcclxuXHRyZXR1cm4gYWNjZXNzb3IubWFwKGZ1bmN0aW9uKGEpIHtcclxuXHRcdHJldHVybiBcIltcIiArIEpTT04uc3RyaW5naWZ5KGEpICsgXCJdXCI7XHJcblx0fSkuam9pbihcIlwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWNjZXNzb3JBY2Nlc3MoYmFzZSwgYWNjZXNzb3IpIHtcclxuXHRhY2Nlc3NvciA9IFtdLmNvbmNhdChhY2Nlc3Nvcik7XHJcblx0cmV0dXJuIGFjY2Vzc29yLm1hcChmdW5jdGlvbihhLCBpZHgpIHtcclxuXHRcdGEgPSBiYXNlICsgYWNjZXNzb3JUb09iamVjdEFjY2VzcyhhY2Nlc3Nvci5zbGljZSgwLCBpZHggKyAxKSk7XHJcblx0XHRpZihpZHggPT09IGFjY2Vzc29yLmxlbmd0aCAtIDEpIHJldHVybiBhO1xyXG5cdFx0cmV0dXJuIGEgKyBcIiA9IFwiICsgYSArIFwiIHx8IHt9XCI7XHJcblx0fSkuam9pbihcIiwgXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBVbWRNYWluVGVtcGxhdGVQbHVnaW4obmFtZSwgb3B0aW9ucykge1xyXG5cdHRoaXMubmFtZSA9IG5hbWU7XHJcblx0dGhpcy5vcHRpb25hbEFtZEV4dGVybmFsQXNHbG9iYWwgPSBvcHRpb25zLm9wdGlvbmFsQW1kRXh0ZXJuYWxBc0dsb2JhbDtcclxuXHR0aGlzLm5hbWVkRGVmaW5lID0gb3B0aW9ucy5uYW1lZERlZmluZTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IFVtZE1haW5UZW1wbGF0ZVBsdWdpbjtcclxuVW1kTWFpblRlbXBsYXRlUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGNvbXBpbGF0aW9uKSB7XHJcblx0dmFyIG1haW5UZW1wbGF0ZSA9IGNvbXBpbGF0aW9uLm1haW5UZW1wbGF0ZTtcclxuXHRjb21waWxhdGlvbi50ZW1wbGF0ZXNQbHVnaW4oXCJyZW5kZXItd2l0aC1lbnRyeVwiLCBmdW5jdGlvbihzb3VyY2UsIGNodW5rLCBoYXNoKSB7XHJcblx0XHR2YXIgZXh0ZXJuYWxzID0gY2h1bmsubW9kdWxlcy5maWx0ZXIoZnVuY3Rpb24obSkge1xyXG5cdFx0XHRyZXR1cm4gbS5leHRlcm5hbDtcclxuXHRcdH0pO1xyXG5cdFx0dmFyIG9wdGlvbmFsRXh0ZXJuYWxzID0gW10sXHJcblx0XHRcdHJlcXVpcmVkRXh0ZXJuYWxzID0gW107XHJcblx0XHRpZih0aGlzLm9wdGlvbmFsQW1kRXh0ZXJuYWxBc0dsb2JhbCkge1xyXG5cdFx0XHRleHRlcm5hbHMuZm9yRWFjaChmdW5jdGlvbihtKSB7XHJcblx0XHRcdFx0aWYobS5vcHRpb25hbCkge1xyXG5cdFx0XHRcdFx0b3B0aW9uYWxFeHRlcm5hbHMucHVzaChtKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0cmVxdWlyZWRFeHRlcm5hbHMucHVzaChtKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRleHRlcm5hbHMgPSByZXF1aXJlZEV4dGVybmFscy5jb25jYXQob3B0aW9uYWxFeHRlcm5hbHMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmVxdWlyZWRFeHRlcm5hbHMgPSBleHRlcm5hbHM7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcmVwbGFjZUtleXMoc3RyKSB7XHJcblx0XHRcdHJldHVybiBtYWluVGVtcGxhdGUuYXBwbHlQbHVnaW5zV2F0ZXJmYWxsKFwiYXNzZXQtcGF0aFwiLCBzdHIsIHtcclxuXHRcdFx0XHRoYXNoOiBoYXNoLFxyXG5cdFx0XHRcdGNodW5rOiBjaHVua1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBleHRlcm5hbHNEZXBzQXJyYXkobW9kdWxlcykge1xyXG5cdFx0XHRyZXR1cm4gXCJbXCIgKyByZXBsYWNlS2V5cyhtb2R1bGVzLm1hcChmdW5jdGlvbihtKSB7XHJcblx0XHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHR5cGVvZiBtLnJlcXVlc3QgPT09IFwib2JqZWN0XCIgPyBtLnJlcXVlc3QuYW1kIDogbS5yZXF1ZXN0KTtcclxuXHRcdFx0fSkuam9pbihcIiwgXCIpKSArIFwiXVwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGV4dGVybmFsc1Jvb3RBcnJheShtb2R1bGVzKSB7XHJcblx0XHRcdHJldHVybiByZXBsYWNlS2V5cyhtb2R1bGVzLm1hcChmdW5jdGlvbihtKSB7XHJcblx0XHRcdFx0dmFyIHJlcXVlc3QgPSBtLnJlcXVlc3Q7XHJcblx0XHRcdFx0aWYodHlwZW9mIHJlcXVlc3QgPT09IFwib2JqZWN0XCIpIHJlcXVlc3QgPSByZXF1ZXN0LnJvb3Q7XHJcblx0XHRcdFx0cmV0dXJuIFwicm9vdFwiICsgYWNjZXNzb3JUb09iamVjdEFjY2VzcyhbXS5jb25jYXQocmVxdWVzdCkpO1xyXG5cdFx0XHR9KS5qb2luKFwiLCBcIikpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGV4dGVybmFsc1JlcXVpcmVBcnJheSh0eXBlKSB7XHJcblx0XHRcdHJldHVybiByZXBsYWNlS2V5cyhleHRlcm5hbHMubWFwKGZ1bmN0aW9uKG0pIHtcclxuXHRcdFx0XHR2YXIgcmVxdWVzdCA9IG0ucmVxdWVzdDtcclxuXHRcdFx0XHRpZih0eXBlb2YgcmVxdWVzdCA9PT0gXCJvYmplY3RcIikgcmVxdWVzdCA9IHJlcXVlc3RbdHlwZV07XHJcblx0XHRcdFx0aWYoQXJyYXkuaXNBcnJheShyZXF1ZXN0KSkge1xyXG5cdFx0XHRcdFx0dmFyIGV4cHIgPSBcInJlcXVpcmUoXCIgKyBKU09OLnN0cmluZ2lmeShyZXF1ZXN0WzBdKSArIFwiKVwiICsgYWNjZXNzb3JUb09iamVjdEFjY2VzcyhyZXF1ZXN0LnNsaWNlKDEpKTtcclxuXHRcdFx0XHR9IGVsc2VcclxuXHRcdFx0XHRcdHZhciBleHByID0gXCJyZXF1aXJlKFwiICsgSlNPTi5zdHJpbmdpZnkocmVxdWVzdCkgKyBcIilcIjtcclxuXHRcdFx0XHRpZihtLm9wdGlvbmFsKSB7XHJcblx0XHRcdFx0XHRleHByID0gXCIoZnVuY3Rpb24gd2VicGFja0xvYWRPcHRpb25hbEV4dGVybmFsTW9kdWxlKCkgeyB0cnkgeyByZXR1cm4gXCIgKyBleHByICsgXCI7IH0gY2F0Y2goZSkge30gfSgpKVwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gZXhwcjtcclxuXHRcdFx0fSkuam9pbihcIiwgXCIpKTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBleHRlcm5hbHNBcmd1bWVudHMobW9kdWxlcykge1xyXG5cdFx0XHRyZXR1cm4gbW9kdWxlcy5tYXAoZnVuY3Rpb24obSkge1xyXG5cdFx0XHRcdHJldHVybiBcIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXCIgKyBtLmlkICsgXCJfX1wiO1xyXG5cdFx0XHR9KS5qb2luKFwiLCBcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gbGlicmFyeU5hbWUobGlicmFyeSkge1xyXG5cdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVwbGFjZUtleXMoW10uY29uY2F0KGxpYnJhcnkpLnBvcCgpKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYob3B0aW9uYWxFeHRlcm5hbHMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHR2YXIgYW1kRmFjdG9yeSA9IFwiZnVuY3Rpb24gd2VicGFja0xvYWRPcHRpb25hbEV4dGVybmFsTW9kdWxlQW1kKFwiICsgZXh0ZXJuYWxzQXJndW1lbnRzKHJlcXVpcmVkRXh0ZXJuYWxzKSArIFwiKSB7XFxuXCIgK1xyXG5cdFx0XHRcdFwiXHRcdFx0cmV0dXJuIGZhY3RvcnkoXCIgKyAoXHJcblx0XHRcdFx0XHRyZXF1aXJlZEV4dGVybmFscy5sZW5ndGggPiAwID9cclxuXHRcdFx0XHRcdGV4dGVybmFsc0FyZ3VtZW50cyhyZXF1aXJlZEV4dGVybmFscykgKyBcIiwgXCIgKyBleHRlcm5hbHNSb290QXJyYXkob3B0aW9uYWxFeHRlcm5hbHMpIDpcclxuXHRcdFx0XHRcdGV4dGVybmFsc1Jvb3RBcnJheShvcHRpb25hbEV4dGVybmFscylcclxuXHRcdFx0XHQpICsgXCIpO1xcblwiICtcclxuXHRcdFx0XHRcIlx0XHR9XCI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgYW1kRmFjdG9yeSA9IFwiZmFjdG9yeVwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXcgQ29uY2F0U291cmNlKG5ldyBPcmlnaW5hbFNvdXJjZShcclxuXHRcdFx0XCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xcblwiICtcclxuXHRcdFx0XCJcdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JylcXG5cIiArXHJcblx0XHRcdFwiXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcIiArIGV4dGVybmFsc1JlcXVpcmVBcnJheShcImNvbW1vbmpzMlwiKSArIFwiKTtcXG5cIiArXHJcblx0XHRcdFwiXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcXG5cIiArXHJcblx0XHRcdChyZXF1aXJlZEV4dGVybmFscy5sZW5ndGggPiAwID9cclxuXHRcdFx0XHQodGhpcy5uYW1lICYmIHRoaXMubmFtZWREZWZpbmUgPT09IHRydWUgP1xyXG5cdFx0XHRcdFx0XCJcdFx0ZGVmaW5lKFwiICsgbGlicmFyeU5hbWUodGhpcy5uYW1lKSArIFwiLCBcIiArIGV4dGVybmFsc0RlcHNBcnJheShyZXF1aXJlZEV4dGVybmFscykgKyBcIiwgXCIgKyBhbWRGYWN0b3J5ICsgXCIpO1xcblwiIDpcclxuXHRcdFx0XHRcdFwiXHRcdGRlZmluZShcIiArIGV4dGVybmFsc0RlcHNBcnJheShyZXF1aXJlZEV4dGVybmFscykgKyBcIiwgXCIgKyBhbWRGYWN0b3J5ICsgXCIpO1xcblwiXHJcblx0XHRcdFx0KSA6XHJcblx0XHRcdFx0KHRoaXMubmFtZSAmJiB0aGlzLm5hbWVkRGVmaW5lID09PSB0cnVlID9cclxuXHRcdFx0XHRcdFwiXHRcdGRlZmluZShcIiArIGxpYnJhcnlOYW1lKHRoaXMubmFtZSkgKyBcIiwgW10sIFwiICsgYW1kRmFjdG9yeSArIFwiKTtcXG5cIiA6XHJcblx0XHRcdFx0XHRcIlx0XHRkZWZpbmUoW10sIFwiICsgYW1kRmFjdG9yeSArIFwiKTtcXG5cIlxyXG5cdFx0XHRcdClcclxuXHRcdFx0KSArXHJcblx0XHRcdCh0aGlzLm5hbWUgP1xyXG5cdFx0XHRcdFwiXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JylcXG5cIiArXHJcblx0XHRcdFx0XCJcdFx0ZXhwb3J0c1tcIiArIGxpYnJhcnlOYW1lKHRoaXMubmFtZSkgKyBcIl0gPSBmYWN0b3J5KFwiICsgZXh0ZXJuYWxzUmVxdWlyZUFycmF5KFwiY29tbW9uanNcIikgKyBcIik7XFxuXCIgK1xyXG5cdFx0XHRcdFwiXHRlbHNlXFxuXCIgK1xyXG5cdFx0XHRcdFwiXHRcdFwiICsgcmVwbGFjZUtleXMoYWNjZXNzb3JBY2Nlc3MoXCJyb290XCIsIHRoaXMubmFtZSkpICsgXCIgPSBmYWN0b3J5KFwiICsgZXh0ZXJuYWxzUm9vdEFycmF5KGV4dGVybmFscykgKyBcIik7XFxuXCIgOlxyXG5cdFx0XHRcdFwiXHRlbHNlIHtcXG5cIiArXHJcblx0XHRcdFx0KGV4dGVybmFscy5sZW5ndGggPiAwID9cclxuXHRcdFx0XHRcdFwiXHRcdHZhciBhID0gdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZmFjdG9yeShcIiArIGV4dGVybmFsc1JlcXVpcmVBcnJheShcImNvbW1vbmpzXCIpICsgXCIpIDogZmFjdG9yeShcIiArIGV4dGVybmFsc1Jvb3RBcnJheShleHRlcm5hbHMpICsgXCIpO1xcblwiIDpcclxuXHRcdFx0XHRcdFwiXHRcdHZhciBhID0gZmFjdG9yeSgpO1xcblwiXHJcblx0XHRcdFx0KSArXHJcblx0XHRcdFx0XCJcdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xcblwiICtcclxuXHRcdFx0XHRcIlx0fVxcblwiXHJcblx0XHRcdCkgK1xyXG5cdFx0XHRcIn0pKHRoaXMsIGZ1bmN0aW9uKFwiICsgZXh0ZXJuYWxzQXJndW1lbnRzKGV4dGVybmFscykgKyBcIikge1xcbnJldHVybiBcIiwgXCJ3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb25cIiksIHNvdXJjZSwgXCJcXG59KTtcXG5cIik7XHJcblx0fS5iaW5kKHRoaXMpKTtcclxuXHRtYWluVGVtcGxhdGUucGx1Z2luKFwiZ2xvYmFsLWhhc2gtcGF0aHNcIiwgZnVuY3Rpb24ocGF0aHMpIHtcclxuXHRcdGlmKHRoaXMubmFtZSkgcGF0aHMgPSBwYXRocy5jb25jYXQodGhpcy5uYW1lKTtcclxuXHRcdHJldHVybiBwYXRocztcclxuXHR9LmJpbmQodGhpcykpO1xyXG5cdG1haW5UZW1wbGF0ZS5wbHVnaW4oXCJoYXNoXCIsIGZ1bmN0aW9uKGhhc2gpIHtcclxuXHRcdGhhc2gudXBkYXRlKFwidW1kXCIpO1xyXG5cdFx0aGFzaC51cGRhdGUodGhpcy5uYW1lICsgXCJcIik7XHJcblx0fS5iaW5kKHRoaXMpKTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9VbWRNYWluVGVtcGxhdGVQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDMxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgQ29uY2F0U291cmNlID0gcmVxdWlyZShcIndlYnBhY2stY29yZS9saWIvQ29uY2F0U291cmNlXCIpO1xyXG5cclxuZnVuY3Rpb24gSnNvbnBFeHBvcnRNYWluVGVtcGxhdGVQbHVnaW4obmFtZSkge1xyXG5cdHRoaXMubmFtZSA9IG5hbWU7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBKc29ucEV4cG9ydE1haW5UZW1wbGF0ZVBsdWdpbjtcclxuSnNvbnBFeHBvcnRNYWluVGVtcGxhdGVQbHVnaW4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oY29tcGlsYXRpb24pIHtcclxuXHR2YXIgbWFpblRlbXBsYXRlID0gY29tcGlsYXRpb24ubWFpblRlbXBsYXRlO1xyXG5cdGNvbXBpbGF0aW9uLnRlbXBsYXRlc1BsdWdpbihcInJlbmRlci13aXRoLWVudHJ5XCIsIGZ1bmN0aW9uKHNvdXJjZSwgY2h1bmssIGhhc2gpIHtcclxuXHRcdHZhciBuYW1lID0gbWFpblRlbXBsYXRlLmFwcGx5UGx1Z2luc1dhdGVyZmFsbChcImFzc2V0LXBhdGhcIiwgdGhpcy5uYW1lIHx8IFwiXCIsIHtcclxuXHRcdFx0aGFzaDogaGFzaCxcclxuXHRcdFx0Y2h1bms6IGNodW5rXHJcblx0XHR9KTtcclxuXHRcdHJldHVybiBuZXcgQ29uY2F0U291cmNlKG5hbWUgKyBcIihcIiwgc291cmNlLCBcIik7XCIpO1xyXG5cdH0uYmluZCh0aGlzKSk7XHJcblx0bWFpblRlbXBsYXRlLnBsdWdpbihcImdsb2JhbC1oYXNoLXBhdGhzXCIsIGZ1bmN0aW9uKHBhdGhzKSB7XHJcblx0XHRpZih0aGlzLm5hbWUpIHBhdGhzLnB1c2godGhpcy5uYW1lKTtcclxuXHRcdHJldHVybiBwYXRocztcclxuXHR9LmJpbmQodGhpcykpO1xyXG5cdG1haW5UZW1wbGF0ZS5wbHVnaW4oXCJoYXNoXCIsIGZ1bmN0aW9uKGhhc2gpIHtcclxuXHRcdGhhc2gudXBkYXRlKFwianNvbnAgZXhwb3J0XCIpO1xyXG5cdFx0aGFzaC51cGRhdGUodGhpcy5uYW1lICsgXCJcIik7XHJcblx0fS5iaW5kKHRoaXMpKTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9Kc29ucEV4cG9ydE1haW5UZW1wbGF0ZVBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMzEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBUZW1wbGF0ZSA9IHJlcXVpcmUoXCIuL1RlbXBsYXRlXCIpO1xyXG52YXIgQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uID0gcmVxdWlyZShcIi4vQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uXCIpO1xyXG52YXIgTW9kdWxlSG90QWNjZXB0RGVwZW5kZW5jeSA9IHJlcXVpcmUoXCIuL2RlcGVuZGVuY2llcy9Nb2R1bGVIb3RBY2NlcHREZXBlbmRlbmN5XCIpO1xyXG52YXIgTW9kdWxlSG90RGVjbGluZURlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9kZXBlbmRlbmNpZXMvTW9kdWxlSG90RGVjbGluZURlcGVuZGVuY3lcIik7XHJcbnZhciBSYXdTb3VyY2UgPSByZXF1aXJlKFwid2VicGFjay1jb3JlL2xpYi9SYXdTb3VyY2VcIik7XHJcbnZhciBDb25zdERlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9kZXBlbmRlbmNpZXMvQ29uc3REZXBlbmRlbmN5XCIpO1xyXG52YXIgTnVsbEZhY3RvcnkgPSByZXF1aXJlKFwiLi9OdWxsRmFjdG9yeVwiKTtcclxuXHJcbmZ1bmN0aW9uIEhvdE1vZHVsZVJlcGxhY2VtZW50UGx1Z2luKCkge31cclxubW9kdWxlLmV4cG9ydHMgPSBIb3RNb2R1bGVSZXBsYWNlbWVudFBsdWdpbjtcclxuXHJcbkhvdE1vZHVsZVJlcGxhY2VtZW50UGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGNvbXBpbGVyKSB7XHJcblx0dmFyIGhvdFVwZGF0ZUNodW5rRmlsZW5hbWUgPSBjb21waWxlci5vcHRpb25zLm91dHB1dC5ob3RVcGRhdGVDaHVua0ZpbGVuYW1lO1xyXG5cdHZhciBob3RVcGRhdGVNYWluRmlsZW5hbWUgPSBjb21waWxlci5vcHRpb25zLm91dHB1dC5ob3RVcGRhdGVNYWluRmlsZW5hbWU7XHJcblx0Y29tcGlsZXIucGx1Z2luKFwiY29tcGlsYXRpb25cIiwgZnVuY3Rpb24oY29tcGlsYXRpb24sIHBhcmFtcykge1xyXG5cdFx0dmFyIGhvdFVwZGF0ZUNodW5rVGVtcGxhdGUgPSBjb21waWxhdGlvbi5ob3RVcGRhdGVDaHVua1RlbXBsYXRlO1xyXG5cdFx0aWYoIWhvdFVwZGF0ZUNodW5rVGVtcGxhdGUpIHJldHVybjtcclxuXHJcblx0XHR2YXIgbm9ybWFsTW9kdWxlRmFjdG9yeSA9IHBhcmFtcy5ub3JtYWxNb2R1bGVGYWN0b3J5O1xyXG5cclxuXHRcdGNvbXBpbGF0aW9uLmRlcGVuZGVuY3lGYWN0b3JpZXMuc2V0KENvbnN0RGVwZW5kZW5jeSwgbmV3IE51bGxGYWN0b3J5KCkpO1xyXG5cdFx0Y29tcGlsYXRpb24uZGVwZW5kZW5jeVRlbXBsYXRlcy5zZXQoQ29uc3REZXBlbmRlbmN5LCBuZXcgQ29uc3REZXBlbmRlbmN5LlRlbXBsYXRlKCkpO1xyXG5cclxuXHRcdGNvbXBpbGF0aW9uLmRlcGVuZGVuY3lGYWN0b3JpZXMuc2V0KE1vZHVsZUhvdEFjY2VwdERlcGVuZGVuY3ksIG5vcm1hbE1vZHVsZUZhY3RvcnkpO1xyXG5cdFx0Y29tcGlsYXRpb24uZGVwZW5kZW5jeVRlbXBsYXRlcy5zZXQoTW9kdWxlSG90QWNjZXB0RGVwZW5kZW5jeSwgbmV3IE1vZHVsZUhvdEFjY2VwdERlcGVuZGVuY3kuVGVtcGxhdGUoKSk7XHJcblxyXG5cdFx0Y29tcGlsYXRpb24uZGVwZW5kZW5jeUZhY3Rvcmllcy5zZXQoTW9kdWxlSG90RGVjbGluZURlcGVuZGVuY3ksIG5vcm1hbE1vZHVsZUZhY3RvcnkpO1xyXG5cdFx0Y29tcGlsYXRpb24uZGVwZW5kZW5jeVRlbXBsYXRlcy5zZXQoTW9kdWxlSG90RGVjbGluZURlcGVuZGVuY3ksIG5ldyBNb2R1bGVIb3REZWNsaW5lRGVwZW5kZW5jeS5UZW1wbGF0ZSgpKTtcclxuXHJcblx0XHRjb21waWxhdGlvbi5wbHVnaW4oXCJyZWNvcmRcIiwgZnVuY3Rpb24oY29tcGlsYXRpb24sIHJlY29yZHMpIHtcclxuXHRcdFx0aWYocmVjb3Jkcy5oYXNoID09PSB0aGlzLmhhc2gpIHJldHVybjtcclxuXHRcdFx0cmVjb3Jkcy5oYXNoID0gY29tcGlsYXRpb24uaGFzaDtcclxuXHRcdFx0cmVjb3Jkcy5tb2R1bGVIYXNocyA9IHt9O1xyXG5cdFx0XHR0aGlzLm1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRcdFx0XHR2YXIgaWRlbnRpZmllciA9IG1vZHVsZS5pZGVudGlmaWVyKCk7XHJcblx0XHRcdFx0dmFyIGhhc2ggPSByZXF1aXJlKFwiY3J5cHRvXCIpLmNyZWF0ZUhhc2goXCJtZDVcIik7XHJcblx0XHRcdFx0bW9kdWxlLnVwZGF0ZUhhc2goaGFzaCk7XHJcblx0XHRcdFx0cmVjb3Jkcy5tb2R1bGVIYXNoc1tpZGVudGlmaWVyXSA9IGhhc2guZGlnZXN0KFwiaGV4XCIpO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0cmVjb3Jkcy5jaHVua0hhc2hzID0ge307XHJcblx0XHRcdHRoaXMuY2h1bmtzLmZvckVhY2goZnVuY3Rpb24oY2h1bmspIHtcclxuXHRcdFx0XHRyZWNvcmRzLmNodW5rSGFzaHNbY2h1bmsuaWRdID0gY2h1bmsuaGFzaDtcclxuXHRcdFx0fSk7XHJcblx0XHRcdHJlY29yZHMuY2h1bmtNb2R1bGVJZHMgPSB7fTtcclxuXHRcdFx0dGhpcy5jaHVua3MuZm9yRWFjaChmdW5jdGlvbihjaHVuaykge1xyXG5cdFx0XHRcdHJlY29yZHMuY2h1bmtNb2R1bGVJZHNbY2h1bmsuaWRdID0gY2h1bmsubW9kdWxlcy5tYXAoZnVuY3Rpb24obSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIG0uaWQ7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0XHRjb21waWxhdGlvbi5wbHVnaW4oXCJhZnRlci1oYXNoXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR2YXIgcmVjb3JkcyA9IHRoaXMucmVjb3JkcztcclxuXHRcdFx0aWYoIXJlY29yZHMpIHJldHVybjtcclxuXHRcdFx0dmFyIHByZUhhc2ggPSByZWNvcmRzLnByZUhhc2ggfHwgXCJ4XCI7XHJcblx0XHRcdHZhciBwcmVwcmVIYXNoID0gcmVjb3Jkcy5wcmVwcmVIYXNoIHx8IFwieFwiO1xyXG5cdFx0XHRpZihwcmVIYXNoID09PSB0aGlzLmhhc2gpIHtcclxuXHRcdFx0XHR0aGlzLm1vZGlmeUhhc2gocHJlcHJlSGFzaCk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJlY29yZHMucHJlcHJlSGFzaCA9IHJlY29yZHMuaGFzaCB8fCBcInhcIjtcclxuXHRcdFx0cmVjb3Jkcy5wcmVIYXNoID0gdGhpcy5oYXNoO1xyXG5cdFx0XHR0aGlzLm1vZGlmeUhhc2gocmVjb3Jkcy5wcmVwcmVIYXNoKTtcclxuXHRcdH0pO1xyXG5cdFx0Y29tcGlsYXRpb24ucGx1Z2luKFwiYWRkaXRpb25hbC1jaHVuay1hc3NldHNcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciByZWNvcmRzID0gdGhpcy5yZWNvcmRzO1xyXG5cdFx0XHRpZihyZWNvcmRzLmhhc2ggPT09IHRoaXMuaGFzaCkgcmV0dXJuO1xyXG5cdFx0XHRpZighcmVjb3Jkcy5tb2R1bGVIYXNocyB8fCAhcmVjb3Jkcy5jaHVua0hhc2hzIHx8ICFyZWNvcmRzLmNodW5rTW9kdWxlSWRzKSByZXR1cm47XHJcblx0XHRcdHRoaXMubW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdFx0XHRcdHZhciBpZGVudGlmaWVyID0gbW9kdWxlLmlkZW50aWZpZXIoKTtcclxuXHRcdFx0XHR2YXIgaGFzaCA9IHJlcXVpcmUoXCJjcnlwdG9cIikuY3JlYXRlSGFzaChcIm1kNVwiKTtcclxuXHRcdFx0XHRtb2R1bGUudXBkYXRlSGFzaChoYXNoKTtcclxuXHRcdFx0XHRoYXNoID0gaGFzaC5kaWdlc3QoXCJoZXhcIik7XHJcblx0XHRcdFx0bW9kdWxlLmhvdFVwZGF0ZSA9IHJlY29yZHMubW9kdWxlSGFzaHNbaWRlbnRpZmllcl0gIT09IGhhc2g7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHR2YXIgaG90VXBkYXRlTWFpbkNvbnRlbnQgPSB7XHJcblx0XHRcdFx0aDogdGhpcy5oYXNoLFxyXG5cdFx0XHRcdGM6IFtdXHJcblx0XHRcdH07XHJcblx0XHRcdE9iamVjdC5rZXlzKHJlY29yZHMuY2h1bmtIYXNocykuZm9yRWFjaChmdW5jdGlvbihjaHVua0lkKSB7XHJcblx0XHRcdFx0Y2h1bmtJZCA9ICtjaHVua0lkO1xyXG5cdFx0XHRcdHZhciBjdXJyZW50Q2h1bmsgPSB0aGlzLmNodW5rcy5maWx0ZXIoZnVuY3Rpb24oY2h1bmspIHtcclxuXHRcdFx0XHRcdHJldHVybiBjaHVuay5pZCA9PT0gY2h1bmtJZDtcclxuXHRcdFx0XHR9KVswXTtcclxuXHRcdFx0XHRpZihjdXJyZW50Q2h1bmspIHtcclxuXHRcdFx0XHRcdHZhciBuZXdNb2R1bGVzID0gY3VycmVudENodW5rLm1vZHVsZXMuZmlsdGVyKGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gbW9kdWxlLmhvdFVwZGF0ZTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0aWYobmV3TW9kdWxlcy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0XHRcdHZhciBzb3VyY2UgPSBob3RVcGRhdGVDaHVua1RlbXBsYXRlLnJlbmRlcihjaHVua0lkLCBuZXdNb2R1bGVzLCB0aGlzLmhhc2gsIHRoaXMubW9kdWxlVGVtcGxhdGUsIHRoaXMuZGVwZW5kZW5jeVRlbXBsYXRlcyk7XHJcblx0XHRcdFx0XHRcdHZhciBmaWxlbmFtZSA9IHRoaXMuZ2V0UGF0aChob3RVcGRhdGVDaHVua0ZpbGVuYW1lLCB7XHJcblx0XHRcdFx0XHRcdFx0aGFzaDogcmVjb3Jkcy5oYXNoLFxyXG5cdFx0XHRcdFx0XHRcdGNodW5rOiBjdXJyZW50Q2h1bmtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHRcdHRoaXMuYWRkaXRpb25hbENodW5rQXNzZXRzLnB1c2goZmlsZW5hbWUpO1xyXG5cdFx0XHRcdFx0XHR0aGlzLmFzc2V0c1tmaWxlbmFtZV0gPSBzb3VyY2U7XHJcblx0XHRcdFx0XHRcdGhvdFVwZGF0ZU1haW5Db250ZW50LmMucHVzaChjaHVua0lkKTtcclxuXHRcdFx0XHRcdFx0Y3VycmVudENodW5rLmZpbGVzLnB1c2goZmlsZW5hbWUpO1xyXG5cdFx0XHRcdFx0XHR0aGlzLmFwcGx5UGx1Z2lucyhcImNodW5rLWFzc2V0XCIsIGN1cnJlbnRDaHVuaywgZmlsZW5hbWUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSwgdGhpcyk7XHJcblx0XHRcdHZhciBzb3VyY2UgPSBuZXcgUmF3U291cmNlKEpTT04uc3RyaW5naWZ5KGhvdFVwZGF0ZU1haW5Db250ZW50KSk7XHJcblx0XHRcdHZhciBmaWxlbmFtZSA9IHRoaXMuZ2V0UGF0aChob3RVcGRhdGVNYWluRmlsZW5hbWUsIHtcclxuXHRcdFx0XHRoYXNoOiByZWNvcmRzLmhhc2hcclxuXHRcdFx0fSk7XHJcblx0XHRcdHRoaXMuYXNzZXRzW2ZpbGVuYW1lXSA9IHNvdXJjZTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdGNvbXBpbGF0aW9uLm1haW5UZW1wbGF0ZS5wbHVnaW4oXCJoYXNoXCIsIGZ1bmN0aW9uKGhhc2gpIHtcclxuXHRcdFx0aGFzaC51cGRhdGUoXCJIb3RNYWluVGVtcGxhdGVEZWNvcmF0b3JcIik7XHJcblx0XHR9KTtcclxuXHJcblx0XHRjb21waWxhdGlvbi5tYWluVGVtcGxhdGUucGx1Z2luKFwibW9kdWxlLXJlcXVpcmVcIiwgZnVuY3Rpb24oXywgY2h1bmssIGhhc2gsIHZhck1vZHVsZUlkKSB7XHJcblx0XHRcdHJldHVybiBcImhvdENyZWF0ZVJlcXVpcmUoXCIgKyB2YXJNb2R1bGVJZCArIFwiKVwiO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Y29tcGlsYXRpb24ubWFpblRlbXBsYXRlLnBsdWdpbihcInJlcXVpcmUtZXh0ZW5zaW9uc1wiLCBmdW5jdGlvbihzb3VyY2UpIHtcclxuXHRcdFx0dmFyIGJ1ZiA9IFtzb3VyY2VdO1xyXG5cdFx0XHRidWYucHVzaChcIlwiKTtcclxuXHRcdFx0YnVmLnB1c2goXCIvLyBfX3dlYnBhY2tfaGFzaF9fXCIpO1xyXG5cdFx0XHRidWYucHVzaCh0aGlzLnJlcXVpcmVGbiArIFwiLmggPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhvdEN1cnJlbnRIYXNoOyB9O1wiKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYXNTdHJpbmcoYnVmKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdGNvbXBpbGF0aW9uLm1haW5UZW1wbGF0ZS5wbHVnaW4oXCJib290c3RyYXBcIiwgZnVuY3Rpb24oc291cmNlLCBjaHVuaywgaGFzaCkge1xyXG5cdFx0XHRzb3VyY2UgPSB0aGlzLmFwcGx5UGx1Z2luc1dhdGVyZmFsbChcImhvdC1ib290c3RyYXBcIiwgc291cmNlLCBjaHVuaywgaGFzaCk7XHJcblx0XHRcdHJldHVybiB0aGlzLmFzU3RyaW5nKFtcclxuXHRcdFx0XHRzb3VyY2UsXHJcblx0XHRcdFx0XCJcIixcclxuXHRcdFx0XHRob3RJbml0Q29kZVxyXG5cdFx0XHRcdC5yZXBsYWNlKC9cXCRyZXF1aXJlXFwkL2csIHRoaXMucmVxdWlyZUZuKVxyXG5cdFx0XHRcdC5yZXBsYWNlKC9cXCRoYXNoXFwkL2csIEpTT04uc3RyaW5naWZ5KGhhc2gpKVxyXG5cdFx0XHRcdC5yZXBsYWNlKC9cXC9cXCpmb3JlYWNoSW5zdGFsbGVkQ2h1bmtzXFwqXFwvL2csIGNodW5rLmNodW5rcy5sZW5ndGggPiAwID8gXCJmb3IodmFyIGNodW5rSWQgaW4gaW5zdGFsbGVkQ2h1bmtzKVwiIDogXCJ2YXIgY2h1bmtJZCA9IFwiICsgY2h1bmsuaWQgKyBcIjtcIilcclxuXHRcdFx0XSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRjb21waWxhdGlvbi5tYWluVGVtcGxhdGUucGx1Z2luKFwiZ2xvYmFsLWhhc2hcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Y29tcGlsYXRpb24ubWFpblRlbXBsYXRlLnBsdWdpbihcImN1cnJlbnQtaGFzaFwiLCBmdW5jdGlvbihfLCBsZW5ndGgpIHtcclxuXHRcdFx0aWYoaXNGaW5pdGUobGVuZ3RoKSlcclxuXHRcdFx0XHRyZXR1cm4gXCJob3RDdXJyZW50SGFzaC5zdWJzdHIoMCwgXCIgKyBsZW5ndGggKyBcIilcIjtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHJldHVybiBcImhvdEN1cnJlbnRIYXNoXCI7XHJcblx0XHR9KTtcclxuXHJcblx0XHRjb21waWxhdGlvbi5tYWluVGVtcGxhdGUucGx1Z2luKFwibW9kdWxlLW9ialwiLCBmdW5jdGlvbihzb3VyY2UsIGNodW5rLCBoYXNoLCB2YXJNb2R1bGVJZCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hc1N0cmluZyhbXHJcblx0XHRcdFx0c291cmNlICsgXCIsXCIsXHJcblx0XHRcdFx0XCJob3Q6IGhvdENyZWF0ZU1vZHVsZShcIiArIHZhck1vZHVsZUlkICsgXCIpLFwiLFxyXG5cdFx0XHRcdFwicGFyZW50czogaG90Q3VycmVudFBhcmVudHMsXCIsXHJcblx0XHRcdFx0XCJjaGlsZHJlbjogW11cIlxyXG5cdFx0XHRdKTtcclxuXHRcdH0pO1xyXG5cclxuXHR9KTtcclxuXHRjb21waWxlci5wYXJzZXIucGx1Z2luKFwiZXhwcmVzc2lvbiBfX3dlYnBhY2tfaGFzaF9fXCIsIGZ1bmN0aW9uKGV4cHIpIHtcclxuXHRcdHZhciBkZXAgPSBuZXcgQ29uc3REZXBlbmRlbmN5KFwiX193ZWJwYWNrX3JlcXVpcmVfXy5oKClcIiwgZXhwci5yYW5nZSk7XHJcblx0XHRkZXAubG9jID0gZXhwci5sb2M7XHJcblx0XHR0aGlzLnN0YXRlLmN1cnJlbnQuYWRkRGVwZW5kZW5jeShkZXApO1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSk7XHJcblx0Y29tcGlsZXIucGFyc2VyLnBsdWdpbihcImV2YWx1YXRlIHR5cGVvZiBfX3dlYnBhY2tfaGFzaF9fXCIsIGZ1bmN0aW9uKGV4cHIpIHtcclxuXHRcdHJldHVybiBuZXcgQmFzaWNFdmFsdWF0ZWRFeHByZXNzaW9uKCkuc2V0U3RyaW5nKFwic3RyaW5nXCIpLnNldFJhbmdlKGV4cHIucmFuZ2UpO1xyXG5cdH0pO1xyXG5cdGNvbXBpbGVyLnBhcnNlci5wbHVnaW4oXCJldmFsdWF0ZSBJZGVudGlmaWVyIG1vZHVsZS5ob3RcIiwgZnVuY3Rpb24oZXhwcikge1xyXG5cdFx0cmV0dXJuIG5ldyBCYXNpY0V2YWx1YXRlZEV4cHJlc3Npb24oKVxyXG5cdFx0XHQuc2V0Qm9vbGVhbighIXRoaXMuc3RhdGUuY29tcGlsYXRpb24uaG90VXBkYXRlQ2h1bmtUZW1wbGF0ZSlcclxuXHRcdFx0LnNldFJhbmdlKGV4cHIucmFuZ2UpO1xyXG5cdH0pO1xyXG5cdGNvbXBpbGVyLnBhcnNlci5wbHVnaW4oXCJjYWxsIG1vZHVsZS5ob3QuYWNjZXB0XCIsIGZ1bmN0aW9uKGV4cHIpIHtcclxuXHRcdGlmKCF0aGlzLnN0YXRlLmNvbXBpbGF0aW9uLmhvdFVwZGF0ZUNodW5rVGVtcGxhdGUpIHJldHVybiBmYWxzZTtcclxuXHRcdGlmKGV4cHIuYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0dmFyIGFyZyA9IHRoaXMuZXZhbHVhdGVFeHByZXNzaW9uKGV4cHIuYXJndW1lbnRzWzBdKTtcclxuXHRcdFx0dmFyIHBhcmFtcyA9IFtdO1xyXG5cdFx0XHRpZihhcmcuaXNTdHJpbmcoKSkge1xyXG5cdFx0XHRcdHBhcmFtcyA9IFthcmddO1xyXG5cdFx0XHR9IGVsc2UgaWYoYXJnLmlzQXJyYXkoKSkge1xyXG5cdFx0XHRcdHBhcmFtcyA9IGFyZy5pdGVtcy5maWx0ZXIoZnVuY3Rpb24ocGFyYW0pIHtcclxuXHRcdFx0XHRcdHJldHVybiBwYXJhbS5pc1N0cmluZygpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtLCBpZHgpIHtcclxuXHRcdFx0XHR2YXIgZGVwID0gbmV3IE1vZHVsZUhvdEFjY2VwdERlcGVuZGVuY3kocGFyYW0uc3RyaW5nLCBwYXJhbS5yYW5nZSk7XHJcblx0XHRcdFx0ZGVwLm9wdGlvbmFsID0gdHJ1ZTtcclxuXHRcdFx0XHRkZXAubG9jID0gT2JqZWN0LmNyZWF0ZShleHByLmxvYyk7XHJcblx0XHRcdFx0ZGVwLmxvYy5pbmRleCA9IGlkeDtcclxuXHRcdFx0XHR0aGlzLnN0YXRlLm1vZHVsZS5hZGREZXBlbmRlbmN5KGRlcCk7XHJcblx0XHRcdH0uYmluZCh0aGlzKSk7XHJcblx0XHR9XHJcblx0fSk7XHJcblx0Y29tcGlsZXIucGFyc2VyLnBsdWdpbihcImNhbGwgbW9kdWxlLmhvdC5kZWNsaW5lXCIsIGZ1bmN0aW9uKGV4cHIpIHtcclxuXHRcdGlmKCF0aGlzLnN0YXRlLmNvbXBpbGF0aW9uLmhvdFVwZGF0ZUNodW5rVGVtcGxhdGUpIHJldHVybiBmYWxzZTtcclxuXHRcdGlmKGV4cHIuYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0XHR2YXIgYXJnID0gdGhpcy5ldmFsdWF0ZUV4cHJlc3Npb24oZXhwci5hcmd1bWVudHNbMF0pO1xyXG5cdFx0XHR2YXIgcGFyYW1zID0gW107XHJcblx0XHRcdGlmKGFyZy5pc1N0cmluZygpKSB7XHJcblx0XHRcdFx0cGFyYW1zID0gW2FyZ107XHJcblx0XHRcdH0gZWxzZSBpZihhcmcuaXNBcnJheSgpKSB7XHJcblx0XHRcdFx0cGFyYW1zID0gYXJnLml0ZW1zLmZpbHRlcihmdW5jdGlvbihwYXJhbSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHBhcmFtLmlzU3RyaW5nKCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cGFyYW1zLmZvckVhY2goZnVuY3Rpb24ocGFyYW0sIGlkeCkge1xyXG5cdFx0XHRcdHZhciBkZXAgPSBuZXcgTW9kdWxlSG90RGVjbGluZURlcGVuZGVuY3kocGFyYW0uc3RyaW5nLCBwYXJhbS5yYW5nZSk7XHJcblx0XHRcdFx0ZGVwLm9wdGlvbmFsID0gdHJ1ZTtcclxuXHRcdFx0XHRkZXAubG9jID0gT2JqZWN0LmNyZWF0ZShleHByLmxvYyk7XHJcblx0XHRcdFx0ZGVwLmxvYy5pbmRleCA9IGlkeDtcclxuXHRcdFx0XHR0aGlzLnN0YXRlLm1vZHVsZS5hZGREZXBlbmRlbmN5KGRlcCk7XHJcblx0XHRcdH0uYmluZCh0aGlzKSk7XHJcblx0XHR9XHJcblx0fSk7XHJcblx0Y29tcGlsZXIucGFyc2VyLnBsdWdpbihcImV4cHJlc3Npb24gbW9kdWxlLmhvdFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0pO1xyXG59O1xyXG5cclxudmFyIGhvdEluaXRDb2RlID0gVGVtcGxhdGUuZ2V0RnVuY3Rpb25Db250ZW50KHJlcXVpcmUoXCIuL0hvdE1vZHVsZVJlcGxhY2VtZW50LnJ1bnRpbWUuanNcIikpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL0hvdE1vZHVsZVJlcGxhY2VtZW50UGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIE1vZHVsZURlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9Nb2R1bGVEZXBlbmRlbmN5XCIpO1xyXG5cclxuZnVuY3Rpb24gTW9kdWxlSG90QWNjZXB0RGVwZW5kZW5jeShyZXF1ZXN0LCByYW5nZSkge1xyXG5cdE1vZHVsZURlcGVuZGVuY3kuY2FsbCh0aGlzLCByZXF1ZXN0KTtcclxuXHR0aGlzLnJhbmdlID0gcmFuZ2U7XHJcblx0dGhpcy53ZWFrID0gdHJ1ZTtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IE1vZHVsZUhvdEFjY2VwdERlcGVuZGVuY3k7XHJcblxyXG5Nb2R1bGVIb3RBY2NlcHREZXBlbmRlbmN5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTW9kdWxlRGVwZW5kZW5jeS5wcm90b3R5cGUpO1xyXG5Nb2R1bGVIb3RBY2NlcHREZXBlbmRlbmN5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1vZHVsZUhvdEFjY2VwdERlcGVuZGVuY3k7XHJcbk1vZHVsZUhvdEFjY2VwdERlcGVuZGVuY3kucHJvdG90eXBlLnR5cGUgPSBcIm1vZHVsZS5ob3QuYWNjZXB0XCI7XHJcblxyXG5Nb2R1bGVIb3RBY2NlcHREZXBlbmRlbmN5LlRlbXBsYXRlID0gcmVxdWlyZShcIi4vTW9kdWxlRGVwZW5kZW5jeVRlbXBsYXRlQXNJZFwiKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvTW9kdWxlSG90QWNjZXB0RGVwZW5kZW5jeS5qc1xuLy8gbW9kdWxlIGlkID0gMzE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBNb2R1bGVEZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4vTW9kdWxlRGVwZW5kZW5jeVwiKTtcclxuXHJcbmZ1bmN0aW9uIE1vZHVsZUhvdERlY2xpbmVEZXBlbmRlbmN5KHJlcXVlc3QsIHJhbmdlKSB7XHJcblx0TW9kdWxlRGVwZW5kZW5jeS5jYWxsKHRoaXMsIHJlcXVlc3QpO1xyXG5cdHRoaXMucmFuZ2UgPSByYW5nZTtcclxuXHR0aGlzLndlYWsgPSB0cnVlO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gTW9kdWxlSG90RGVjbGluZURlcGVuZGVuY3k7XHJcblxyXG5Nb2R1bGVIb3REZWNsaW5lRGVwZW5kZW5jeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE1vZHVsZURlcGVuZGVuY3kucHJvdG90eXBlKTtcclxuTW9kdWxlSG90RGVjbGluZURlcGVuZGVuY3kucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTW9kdWxlSG90RGVjbGluZURlcGVuZGVuY3k7XHJcbk1vZHVsZUhvdERlY2xpbmVEZXBlbmRlbmN5LnByb3RvdHlwZS50eXBlID0gXCJtb2R1bGUuaG90LmRlY2xpbmVcIjtcclxuXHJcbk1vZHVsZUhvdERlY2xpbmVEZXBlbmRlbmN5LlRlbXBsYXRlID0gcmVxdWlyZShcIi4vTW9kdWxlRGVwZW5kZW5jeVRlbXBsYXRlQXNJZFwiKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9kZXBlbmRlbmNpZXMvTW9kdWxlSG90RGVjbGluZURlcGVuZGVuY3kuanNcbi8vIG1vZHVsZSBpZCA9IDMxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG4vKmdsb2JhbCAkaGFzaCQgaW5zdGFsbGVkTW9kdWxlcyAkcmVxdWlyZSQgaG90RG93bmxvYWRNYW5pZmVzdCBob3REb3dubG9hZFVwZGF0ZUNodW5rIG1vZHVsZXMgKi9cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0Ly8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvYmVmNDViMC9zcmMvc2hhcmVkL3V0aWxzL2NhbkRlZmluZVByb3BlcnR5LmpzXHJcblx0dmFyIGNhbkRlZmluZVByb3BlcnR5ID0gZmFsc2U7XHJcblx0dHJ5IHtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgXCJ4XCIsIHtcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHt9XHJcblx0XHR9KTtcclxuXHRcdGNhbkRlZmluZVByb3BlcnR5ID0gdHJ1ZTtcclxuXHR9IGNhdGNoKHgpIHtcclxuXHRcdC8vIElFIHdpbGwgZmFpbCBvbiBkZWZpbmVQcm9wZXJ0eVxyXG5cdH1cclxuXHJcblx0dmFyIGhvdEFwcGx5T25VcGRhdGUgPSB0cnVlO1xyXG5cdHZhciBob3RDdXJyZW50SGFzaCA9ICRoYXNoJDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG5cdHZhciBob3RDdXJyZW50TW9kdWxlRGF0YSA9IHt9O1xyXG5cdHZhciBob3RDdXJyZW50UGFyZW50cyA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcblxyXG5cdGZ1bmN0aW9uIGhvdENyZWF0ZVJlcXVpcmUobW9kdWxlSWQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG5cdFx0dmFyIG1lID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcblx0XHRpZighbWUpIHJldHVybiAkcmVxdWlyZSQ7XHJcblx0XHR2YXIgZm4gPSBmdW5jdGlvbihyZXF1ZXN0KSB7XHJcblx0XHRcdGlmKG1lLmhvdC5hY3RpdmUpIHtcclxuXHRcdFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW3JlcXVlc3RdKSB7XHJcblx0XHRcdFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW3JlcXVlc3RdLnBhcmVudHMuaW5kZXhPZihtb2R1bGVJZCkgPCAwKVxyXG5cdFx0XHRcdFx0XHRpbnN0YWxsZWRNb2R1bGVzW3JlcXVlc3RdLnBhcmVudHMucHVzaChtb2R1bGVJZCk7XHJcblx0XHRcdFx0XHRpZihtZS5jaGlsZHJlbi5pbmRleE9mKHJlcXVlc3QpIDwgMClcclxuXHRcdFx0XHRcdFx0bWUuY2hpbGRyZW4ucHVzaChyZXF1ZXN0KTtcclxuXHRcdFx0XHR9IGVsc2UgaG90Q3VycmVudFBhcmVudHMgPSBbbW9kdWxlSWRdO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNvbnNvbGUud2FybihcIltITVJdIHVuZXhwZWN0ZWQgcmVxdWlyZShcIiArIHJlcXVlc3QgKyBcIikgZnJvbSBkaXNwb3NlZCBtb2R1bGUgXCIgKyBtb2R1bGVJZCk7XHJcblx0XHRcdFx0aG90Q3VycmVudFBhcmVudHMgPSBbXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gJHJlcXVpcmUkKHJlcXVlc3QpO1xyXG5cdFx0fTtcclxuXHRcdGZvcih2YXIgbmFtZSBpbiAkcmVxdWlyZSQpIHtcclxuXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCRyZXF1aXJlJCwgbmFtZSkpIHtcclxuXHRcdFx0XHRpZihjYW5EZWZpbmVQcm9wZXJ0eSkge1xyXG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBuYW1lLCAoZnVuY3Rpb24obmFtZSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuXHRcdFx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRcdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gJHJlcXVpcmUkW25hbWVdO1xyXG5cdFx0XHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRcdFx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0JHJlcXVpcmUkW25hbWVdID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0fShuYW1lKSkpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRmbltuYW1lXSA9ICRyZXF1aXJlJFtuYW1lXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBlbnN1cmUoY2h1bmtJZCwgY2FsbGJhY2spIHtcclxuXHRcdFx0aWYoaG90U3RhdHVzID09PSBcInJlYWR5XCIpXHJcblx0XHRcdFx0aG90U2V0U3RhdHVzKFwicHJlcGFyZVwiKTtcclxuXHRcdFx0aG90Q2h1bmtzTG9hZGluZysrO1xyXG5cdFx0XHQkcmVxdWlyZSQuZShjaHVua0lkLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2suY2FsbChudWxsLCBmbik7XHJcblx0XHRcdFx0fSBmaW5hbGx5IHtcclxuXHRcdFx0XHRcdGZpbmlzaENodW5rTG9hZGluZygpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZnVuY3Rpb24gZmluaXNoQ2h1bmtMb2FkaW5nKCkge1xyXG5cdFx0XHRcdFx0aG90Q2h1bmtzTG9hZGluZy0tO1xyXG5cdFx0XHRcdFx0aWYoaG90U3RhdHVzID09PSBcInByZXBhcmVcIikge1xyXG5cdFx0XHRcdFx0XHRpZighaG90V2FpdGluZ0ZpbGVzTWFwW2NodW5rSWRdKSB7XHJcblx0XHRcdFx0XHRcdFx0aG90RW5zdXJlVXBkYXRlQ2h1bmsoY2h1bmtJZCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0aWYoaG90Q2h1bmtzTG9hZGluZyA9PT0gMCAmJiBob3RXYWl0aW5nRmlsZXMgPT09IDApIHtcclxuXHRcdFx0XHRcdFx0XHRob3RVcGRhdGVEb3dubG9hZGVkKCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdFx0aWYoY2FuRGVmaW5lUHJvcGVydHkpIHtcclxuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBcImVcIiwge1xyXG5cdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdFx0dmFsdWU6IGVuc3VyZVxyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGZuLmUgPSBlbnN1cmU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZm47XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBob3RDcmVhdGVNb2R1bGUobW9kdWxlSWQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG5cdFx0dmFyIGhvdCA9IHtcclxuXHRcdFx0Ly8gcHJpdmF0ZSBzdHVmZlxyXG5cdFx0XHRfYWNjZXB0ZWREZXBlbmRlbmNpZXM6IHt9LFxyXG5cdFx0XHRfZGVjbGluZWREZXBlbmRlbmNpZXM6IHt9LFxyXG5cdFx0XHRfc2VsZkFjY2VwdGVkOiBmYWxzZSxcclxuXHRcdFx0X3NlbGZEZWNsaW5lZDogZmFsc2UsXHJcblx0XHRcdF9kaXNwb3NlSGFuZGxlcnM6IFtdLFxyXG5cclxuXHRcdFx0Ly8gTW9kdWxlIEFQSVxyXG5cdFx0XHRhY3RpdmU6IHRydWUsXHJcblx0XHRcdGFjY2VwdDogZnVuY3Rpb24oZGVwLCBjYWxsYmFjaykge1xyXG5cdFx0XHRcdGlmKHR5cGVvZiBkZXAgPT09IFwidW5kZWZpbmVkXCIpXHJcblx0XHRcdFx0XHRob3QuX3NlbGZBY2NlcHRlZCA9IHRydWU7XHJcblx0XHRcdFx0ZWxzZSBpZih0eXBlb2YgZGVwID09PSBcImZ1bmN0aW9uXCIpXHJcblx0XHRcdFx0XHRob3QuX3NlbGZBY2NlcHRlZCA9IGRlcDtcclxuXHRcdFx0XHRlbHNlIGlmKHR5cGVvZiBkZXAgPT09IFwib2JqZWN0XCIpXHJcblx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgZGVwLmxlbmd0aDsgaSsrKVxyXG5cdFx0XHRcdFx0XHRob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW2RlcFtpXV0gPSBjYWxsYmFjaztcclxuXHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW2RlcF0gPSBjYWxsYmFjaztcclxuXHRcdFx0fSxcclxuXHRcdFx0ZGVjbGluZTogZnVuY3Rpb24oZGVwKSB7XHJcblx0XHRcdFx0aWYodHlwZW9mIGRlcCA9PT0gXCJ1bmRlZmluZWRcIilcclxuXHRcdFx0XHRcdGhvdC5fc2VsZkRlY2xpbmVkID0gdHJ1ZTtcclxuXHRcdFx0XHRlbHNlIGlmKHR5cGVvZiBkZXAgPT09IFwibnVtYmVyXCIpXHJcblx0XHRcdFx0XHRob3QuX2RlY2xpbmVkRGVwZW5kZW5jaWVzW2RlcF0gPSB0cnVlO1xyXG5cdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBkZXAubGVuZ3RoOyBpKyspXHJcblx0XHRcdFx0XHRcdGhvdC5fZGVjbGluZWREZXBlbmRlbmNpZXNbZGVwW2ldXSA9IHRydWU7XHJcblx0XHRcdH0sXHJcblx0XHRcdGRpc3Bvc2U6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcblx0XHRcdFx0aG90Ll9kaXNwb3NlSGFuZGxlcnMucHVzaChjYWxsYmFjayk7XHJcblx0XHRcdH0sXHJcblx0XHRcdGFkZERpc3Bvc2VIYW5kbGVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xyXG5cdFx0XHRcdGhvdC5fZGlzcG9zZUhhbmRsZXJzLnB1c2goY2FsbGJhY2spO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRyZW1vdmVEaXNwb3NlSGFuZGxlcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuXHRcdFx0XHR2YXIgaWR4ID0gaG90Ll9kaXNwb3NlSGFuZGxlcnMuaW5kZXhPZihjYWxsYmFjayk7XHJcblx0XHRcdFx0aWYoaWR4ID49IDApIGhvdC5fZGlzcG9zZUhhbmRsZXJzLnNwbGljZShpZHgsIDEpO1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gTWFuYWdlbWVudCBBUElcclxuXHRcdFx0Y2hlY2s6IGhvdENoZWNrLFxyXG5cdFx0XHRhcHBseTogaG90QXBwbHksXHJcblx0XHRcdHN0YXR1czogZnVuY3Rpb24obCkge1xyXG5cdFx0XHRcdGlmKCFsKSByZXR1cm4gaG90U3RhdHVzO1xyXG5cdFx0XHRcdGhvdFN0YXR1c0hhbmRsZXJzLnB1c2gobCk7XHJcblx0XHRcdH0sXHJcblx0XHRcdGFkZFN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uKGwpIHtcclxuXHRcdFx0XHRob3RTdGF0dXNIYW5kbGVycy5wdXNoKGwpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRyZW1vdmVTdGF0dXNIYW5kbGVyOiBmdW5jdGlvbihsKSB7XHJcblx0XHRcdFx0dmFyIGlkeCA9IGhvdFN0YXR1c0hhbmRsZXJzLmluZGV4T2YobCk7XHJcblx0XHRcdFx0aWYoaWR4ID49IDApIGhvdFN0YXR1c0hhbmRsZXJzLnNwbGljZShpZHgsIDEpO1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly9pbmhlcml0IGZyb20gcHJldmlvdXMgZGlzcG9zZSBjYWxsXHJcblx0XHRcdGRhdGE6IGhvdEN1cnJlbnRNb2R1bGVEYXRhW21vZHVsZUlkXVxyXG5cdFx0fTtcclxuXHRcdHJldHVybiBob3Q7XHJcblx0fVxyXG5cclxuXHR2YXIgaG90U3RhdHVzSGFuZGxlcnMgPSBbXTtcclxuXHR2YXIgaG90U3RhdHVzID0gXCJpZGxlXCI7XHJcblxyXG5cdGZ1bmN0aW9uIGhvdFNldFN0YXR1cyhuZXdTdGF0dXMpIHtcclxuXHRcdGhvdFN0YXR1cyA9IG5ld1N0YXR1cztcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBob3RTdGF0dXNIYW5kbGVycy5sZW5ndGg7IGkrKylcclxuXHRcdFx0aG90U3RhdHVzSGFuZGxlcnNbaV0uY2FsbChudWxsLCBuZXdTdGF0dXMpO1xyXG5cdH1cclxuXHJcblx0Ly8gd2hpbGUgZG93bmxvYWRpbmdcclxuXHR2YXIgaG90V2FpdGluZ0ZpbGVzID0gMDtcclxuXHR2YXIgaG90Q2h1bmtzTG9hZGluZyA9IDA7XHJcblx0dmFyIGhvdFdhaXRpbmdGaWxlc01hcCA9IHt9O1xyXG5cdHZhciBob3RSZXF1ZXN0ZWRGaWxlc01hcCA9IHt9O1xyXG5cdHZhciBob3RBdmFpbGlibGVGaWxlc01hcCA9IHt9O1xyXG5cdHZhciBob3RDYWxsYmFjaztcclxuXHJcblx0Ly8gVGhlIHVwZGF0ZSBpbmZvXHJcblx0dmFyIGhvdFVwZGF0ZSwgaG90VXBkYXRlTmV3SGFzaDtcclxuXHJcblx0ZnVuY3Rpb24gdG9Nb2R1bGVJZChpZCkge1xyXG5cdFx0dmFyIGlzTnVtYmVyID0gKCtpZCkgKyBcIlwiID09PSBpZDtcclxuXHRcdHJldHVybiBpc051bWJlciA/ICtpZCA6IGlkO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaG90Q2hlY2soYXBwbHksIGNhbGxiYWNrKSB7XHJcblx0XHRpZihob3RTdGF0dXMgIT09IFwiaWRsZVwiKSB0aHJvdyBuZXcgRXJyb3IoXCJjaGVjaygpIGlzIG9ubHkgYWxsb3dlZCBpbiBpZGxlIHN0YXR1c1wiKTtcclxuXHRcdGlmKHR5cGVvZiBhcHBseSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHRcdGhvdEFwcGx5T25VcGRhdGUgPSBmYWxzZTtcclxuXHRcdFx0Y2FsbGJhY2sgPSBhcHBseTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGhvdEFwcGx5T25VcGRhdGUgPSBhcHBseTtcclxuXHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbihlcnIpIHtcclxuXHRcdFx0XHRpZihlcnIpIHRocm93IGVycjtcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHRcdGhvdFNldFN0YXR1cyhcImNoZWNrXCIpO1xyXG5cdFx0aG90RG93bmxvYWRNYW5pZmVzdChmdW5jdGlvbihlcnIsIHVwZGF0ZSkge1xyXG5cdFx0XHRpZihlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG5cdFx0XHRpZighdXBkYXRlKSB7XHJcblx0XHRcdFx0aG90U2V0U3RhdHVzKFwiaWRsZVwiKTtcclxuXHRcdFx0XHRjYWxsYmFjayhudWxsLCBudWxsKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGhvdFJlcXVlc3RlZEZpbGVzTWFwID0ge307XHJcblx0XHRcdGhvdEF2YWlsaWJsZUZpbGVzTWFwID0ge307XHJcblx0XHRcdGhvdFdhaXRpbmdGaWxlc01hcCA9IHt9O1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdXBkYXRlLmMubGVuZ3RoOyBpKyspXHJcblx0XHRcdFx0aG90QXZhaWxpYmxlRmlsZXNNYXBbdXBkYXRlLmNbaV1dID0gdHJ1ZTtcclxuXHRcdFx0aG90VXBkYXRlTmV3SGFzaCA9IHVwZGF0ZS5oO1xyXG5cclxuXHRcdFx0aG90U2V0U3RhdHVzKFwicHJlcGFyZVwiKTtcclxuXHRcdFx0aG90Q2FsbGJhY2sgPSBjYWxsYmFjaztcclxuXHRcdFx0aG90VXBkYXRlID0ge307XHJcblx0XHRcdC8qZm9yZWFjaEluc3RhbGxlZENodW5rcyovXHJcblx0XHRcdHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sb25lLWJsb2Nrc1xyXG5cdFx0XHRcdC8qZ2xvYmFscyBjaHVua0lkICovXHJcblx0XHRcdFx0aG90RW5zdXJlVXBkYXRlQ2h1bmsoY2h1bmtJZCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoaG90U3RhdHVzID09PSBcInByZXBhcmVcIiAmJiBob3RDaHVua3NMb2FkaW5nID09PSAwICYmIGhvdFdhaXRpbmdGaWxlcyA9PT0gMCkge1xyXG5cdFx0XHRcdGhvdFVwZGF0ZURvd25sb2FkZWQoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBob3RBZGRVcGRhdGVDaHVuayhjaHVua0lkLCBtb3JlTW9kdWxlcykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcblx0XHRpZighaG90QXZhaWxpYmxlRmlsZXNNYXBbY2h1bmtJZF0gfHwgIWhvdFJlcXVlc3RlZEZpbGVzTWFwW2NodW5rSWRdKVxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHRob3RSZXF1ZXN0ZWRGaWxlc01hcFtjaHVua0lkXSA9IGZhbHNlO1xyXG5cdFx0Zm9yKHZhciBtb2R1bGVJZCBpbiBtb3JlTW9kdWxlcykge1xyXG5cdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9yZU1vZHVsZXMsIG1vZHVsZUlkKSkge1xyXG5cdFx0XHRcdGhvdFVwZGF0ZVttb2R1bGVJZF0gPSBtb3JlTW9kdWxlc1ttb2R1bGVJZF07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmKC0taG90V2FpdGluZ0ZpbGVzID09PSAwICYmIGhvdENodW5rc0xvYWRpbmcgPT09IDApIHtcclxuXHRcdFx0aG90VXBkYXRlRG93bmxvYWRlZCgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaG90RW5zdXJlVXBkYXRlQ2h1bmsoY2h1bmtJZCkge1xyXG5cdFx0aWYoIWhvdEF2YWlsaWJsZUZpbGVzTWFwW2NodW5rSWRdKSB7XHJcblx0XHRcdGhvdFdhaXRpbmdGaWxlc01hcFtjaHVua0lkXSA9IHRydWU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRob3RSZXF1ZXN0ZWRGaWxlc01hcFtjaHVua0lkXSA9IHRydWU7XHJcblx0XHRcdGhvdFdhaXRpbmdGaWxlcysrO1xyXG5cdFx0XHRob3REb3dubG9hZFVwZGF0ZUNodW5rKGNodW5rSWQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaG90VXBkYXRlRG93bmxvYWRlZCgpIHtcclxuXHRcdGhvdFNldFN0YXR1cyhcInJlYWR5XCIpO1xyXG5cdFx0dmFyIGNhbGxiYWNrID0gaG90Q2FsbGJhY2s7XHJcblx0XHRob3RDYWxsYmFjayA9IG51bGw7XHJcblx0XHRpZighY2FsbGJhY2spIHJldHVybjtcclxuXHRcdGlmKGhvdEFwcGx5T25VcGRhdGUpIHtcclxuXHRcdFx0aG90QXBwbHkoaG90QXBwbHlPblVwZGF0ZSwgY2FsbGJhY2spO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFtdO1xyXG5cdFx0XHRmb3IodmFyIGlkIGluIGhvdFVwZGF0ZSkge1xyXG5cdFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChob3RVcGRhdGUsIGlkKSkge1xyXG5cdFx0XHRcdFx0b3V0ZGF0ZWRNb2R1bGVzLnB1c2godG9Nb2R1bGVJZChpZCkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRjYWxsYmFjayhudWxsLCBvdXRkYXRlZE1vZHVsZXMpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaG90QXBwbHkob3B0aW9ucywgY2FsbGJhY2spIHtcclxuXHRcdGlmKGhvdFN0YXR1cyAhPT0gXCJyZWFkeVwiKSB0aHJvdyBuZXcgRXJyb3IoXCJhcHBseSgpIGlzIG9ubHkgYWxsb3dlZCBpbiByZWFkeSBzdGF0dXNcIik7XHJcblx0XHRpZih0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHRcdGNhbGxiYWNrID0gb3B0aW9ucztcclxuXHRcdFx0b3B0aW9ucyA9IHt9O1xyXG5cdFx0fSBlbHNlIGlmKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgPT09IFwib2JqZWN0XCIpIHtcclxuXHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbihlcnIpIHtcclxuXHRcdFx0XHRpZihlcnIpIHRocm93IGVycjtcclxuXHRcdFx0fTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9wdGlvbnMgPSB7fTtcclxuXHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbihlcnIpIHtcclxuXHRcdFx0XHRpZihlcnIpIHRocm93IGVycjtcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXRBZmZlY3RlZFN0dWZmKG1vZHVsZSkge1xyXG5cdFx0XHR2YXIgb3V0ZGF0ZWRNb2R1bGVzID0gW21vZHVsZV07XHJcblx0XHRcdHZhciBvdXRkYXRlZERlcGVuZGVuY2llcyA9IHt9O1xyXG5cclxuXHRcdFx0dmFyIHF1ZXVlID0gb3V0ZGF0ZWRNb2R1bGVzLnNsaWNlKCk7XHJcblx0XHRcdHdoaWxlKHF1ZXVlLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHR2YXIgbW9kdWxlSWQgPSBxdWV1ZS5wb3AoKTtcclxuXHRcdFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcblx0XHRcdFx0aWYoIW1vZHVsZSB8fCBtb2R1bGUuaG90Ll9zZWxmQWNjZXB0ZWQpXHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRpZihtb2R1bGUuaG90Ll9zZWxmRGVjbGluZWQpIHtcclxuXHRcdFx0XHRcdHJldHVybiBuZXcgRXJyb3IoXCJBYm9ydGVkIGJlY2F1c2Ugb2Ygc2VsZiBkZWNsaW5lOiBcIiArIG1vZHVsZUlkKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYobW9kdWxlSWQgPT09IDApIHtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1vZHVsZS5wYXJlbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgcGFyZW50SWQgPSBtb2R1bGUucGFyZW50c1tpXTtcclxuXHRcdFx0XHRcdHZhciBwYXJlbnQgPSBpbnN0YWxsZWRNb2R1bGVzW3BhcmVudElkXTtcclxuXHRcdFx0XHRcdGlmKHBhcmVudC5ob3QuX2RlY2xpbmVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IEVycm9yKFwiQWJvcnRlZCBiZWNhdXNlIG9mIGRlY2xpbmVkIGRlcGVuZGVuY3k6IFwiICsgbW9kdWxlSWQgKyBcIiBpbiBcIiArIHBhcmVudElkKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKG91dGRhdGVkTW9kdWxlcy5pbmRleE9mKHBhcmVudElkKSA+PSAwKSBjb250aW51ZTtcclxuXHRcdFx0XHRcdGlmKHBhcmVudC5ob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSkge1xyXG5cdFx0XHRcdFx0XHRpZighb3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdKVxyXG5cdFx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXSA9IFtdO1xyXG5cdFx0XHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0sIFttb2R1bGVJZF0pO1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGRlbGV0ZSBvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF07XHJcblx0XHRcdFx0XHRvdXRkYXRlZE1vZHVsZXMucHVzaChwYXJlbnRJZCk7XHJcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKHBhcmVudElkKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBbb3V0ZGF0ZWRNb2R1bGVzLCBvdXRkYXRlZERlcGVuZGVuY2llc107XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gYWRkQWxsVG9TZXQoYSwgYikge1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdHZhciBpdGVtID0gYltpXTtcclxuXHRcdFx0XHRpZihhLmluZGV4T2YoaXRlbSkgPCAwKVxyXG5cdFx0XHRcdFx0YS5wdXNoKGl0ZW0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYXQgYmVnaW4gYWxsIHVwZGF0ZXMgbW9kdWxlcyBhcmUgb3V0ZGF0ZWRcclxuXHRcdC8vIHRoZSBcIm91dGRhdGVkXCIgc3RhdHVzIGNhbiBwcm9wYWdhdGUgdG8gcGFyZW50cyBpZiB0aGV5IGRvbid0IGFjY2VwdCB0aGUgY2hpbGRyZW5cclxuXHRcdHZhciBvdXRkYXRlZERlcGVuZGVuY2llcyA9IHt9O1xyXG5cdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFtdO1xyXG5cdFx0dmFyIGFwcGxpZWRVcGRhdGUgPSB7fTtcclxuXHRcdGZvcih2YXIgaWQgaW4gaG90VXBkYXRlKSB7XHJcblx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChob3RVcGRhdGUsIGlkKSkge1xyXG5cdFx0XHRcdHZhciBtb2R1bGVJZCA9IHRvTW9kdWxlSWQoaWQpO1xyXG5cdFx0XHRcdHZhciByZXN1bHQgPSBnZXRBZmZlY3RlZFN0dWZmKG1vZHVsZUlkKTtcclxuXHRcdFx0XHRpZighcmVzdWx0KSB7XHJcblx0XHRcdFx0XHRpZihvcHRpb25zLmlnbm9yZVVuYWNjZXB0ZWQpXHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0aG90U2V0U3RhdHVzKFwiYWJvcnRcIik7XHJcblx0XHRcdFx0XHRyZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKFwiQWJvcnRlZCBiZWNhdXNlIFwiICsgbW9kdWxlSWQgKyBcIiBpcyBub3QgYWNjZXB0ZWRcIikpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xyXG5cdFx0XHRcdFx0aG90U2V0U3RhdHVzKFwiYWJvcnRcIik7XHJcblx0XHRcdFx0XHRyZXR1cm4gY2FsbGJhY2socmVzdWx0KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0YXBwbGllZFVwZGF0ZVttb2R1bGVJZF0gPSBob3RVcGRhdGVbbW9kdWxlSWRdO1xyXG5cdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkTW9kdWxlcywgcmVzdWx0WzBdKTtcclxuXHRcdFx0XHRmb3IodmFyIG1vZHVsZUlkIGluIHJlc3VsdFsxXSkge1xyXG5cdFx0XHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdFsxXSwgbW9kdWxlSWQpKSB7XHJcblx0XHRcdFx0XHRcdGlmKCFvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pXHJcblx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdID0gW107XHJcblx0XHRcdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSwgcmVzdWx0WzFdW21vZHVsZUlkXSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU3RvcmUgc2VsZiBhY2NlcHRlZCBvdXRkYXRlZCBtb2R1bGVzIHRvIHJlcXVpcmUgdGhlbSBsYXRlciBieSB0aGUgbW9kdWxlIHN5c3RlbVxyXG5cdFx0dmFyIG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcyA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IG91dGRhdGVkTW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgbW9kdWxlSWQgPSBvdXRkYXRlZE1vZHVsZXNbaV07XHJcblx0XHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdICYmIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmhvdC5fc2VsZkFjY2VwdGVkKVxyXG5cdFx0XHRcdG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcy5wdXNoKHtcclxuXHRcdFx0XHRcdG1vZHVsZTogbW9kdWxlSWQsXHJcblx0XHRcdFx0XHRlcnJvckhhbmRsZXI6IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmhvdC5fc2VsZkFjY2VwdGVkXHJcblx0XHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gTm93IGluIFwiZGlzcG9zZVwiIHBoYXNlXHJcblx0XHRob3RTZXRTdGF0dXMoXCJkaXNwb3NlXCIpO1xyXG5cdFx0dmFyIHF1ZXVlID0gb3V0ZGF0ZWRNb2R1bGVzLnNsaWNlKCk7XHJcblx0XHR3aGlsZShxdWV1ZS5sZW5ndGggPiAwKSB7XHJcblx0XHRcdHZhciBtb2R1bGVJZCA9IHF1ZXVlLnBvcCgpO1xyXG5cdFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcblx0XHRcdGlmKCFtb2R1bGUpIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0dmFyIGRhdGEgPSB7fTtcclxuXHJcblx0XHRcdC8vIENhbGwgZGlzcG9zZSBoYW5kbGVyc1xyXG5cdFx0XHR2YXIgZGlzcG9zZUhhbmRsZXJzID0gbW9kdWxlLmhvdC5fZGlzcG9zZUhhbmRsZXJzO1xyXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZGlzcG9zZUhhbmRsZXJzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0dmFyIGNiID0gZGlzcG9zZUhhbmRsZXJzW2pdO1xyXG5cdFx0XHRcdGNiKGRhdGEpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGhvdEN1cnJlbnRNb2R1bGVEYXRhW21vZHVsZUlkXSA9IGRhdGE7XHJcblxyXG5cdFx0XHQvLyBkaXNhYmxlIG1vZHVsZSAodGhpcyBkaXNhYmxlcyByZXF1aXJlcyBmcm9tIHRoaXMgbW9kdWxlKVxyXG5cdFx0XHRtb2R1bGUuaG90LmFjdGl2ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0Ly8gcmVtb3ZlIG1vZHVsZSBmcm9tIGNhY2hlXHJcblx0XHRcdGRlbGV0ZSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcclxuXHJcblx0XHRcdC8vIHJlbW92ZSBcInBhcmVudHNcIiByZWZlcmVuY2VzIGZyb20gYWxsIGNoaWxkcmVuXHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBtb2R1bGUuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHR2YXIgY2hpbGQgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZS5jaGlsZHJlbltqXV07XHJcblx0XHRcdFx0aWYoIWNoaWxkKSBjb250aW51ZTtcclxuXHRcdFx0XHR2YXIgaWR4ID0gY2hpbGQucGFyZW50cy5pbmRleE9mKG1vZHVsZUlkKTtcclxuXHRcdFx0XHRpZihpZHggPj0gMCkge1xyXG5cdFx0XHRcdFx0Y2hpbGQucGFyZW50cy5zcGxpY2UoaWR4LCAxKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyByZW1vdmUgb3V0ZGF0ZWQgZGVwZW5kZW5jeSBmcm9tIG1vZHVsZSBjaGlsZHJlblxyXG5cdFx0Zm9yKHZhciBtb2R1bGVJZCBpbiBvdXRkYXRlZERlcGVuZGVuY2llcykge1xyXG5cdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3V0ZGF0ZWREZXBlbmRlbmNpZXMsIG1vZHVsZUlkKSkge1xyXG5cdFx0XHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcclxuXHRcdFx0XHR2YXIgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSBvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF07XHJcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0XHR2YXIgZGVwZW5kZW5jeSA9IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzW2pdO1xyXG5cdFx0XHRcdFx0dmFyIGlkeCA9IG1vZHVsZS5jaGlsZHJlbi5pbmRleE9mKGRlcGVuZGVuY3kpO1xyXG5cdFx0XHRcdFx0aWYoaWR4ID49IDApIG1vZHVsZS5jaGlsZHJlbi5zcGxpY2UoaWR4LCAxKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBOb3QgaW4gXCJhcHBseVwiIHBoYXNlXHJcblx0XHRob3RTZXRTdGF0dXMoXCJhcHBseVwiKTtcclxuXHJcblx0XHRob3RDdXJyZW50SGFzaCA9IGhvdFVwZGF0ZU5ld0hhc2g7XHJcblxyXG5cdFx0Ly8gaW5zZXJ0IG5ldyBjb2RlXHJcblx0XHRmb3IodmFyIG1vZHVsZUlkIGluIGFwcGxpZWRVcGRhdGUpIHtcclxuXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcGxpZWRVcGRhdGUsIG1vZHVsZUlkKSkge1xyXG5cdFx0XHRcdG1vZHVsZXNbbW9kdWxlSWRdID0gYXBwbGllZFVwZGF0ZVttb2R1bGVJZF07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBjYWxsIGFjY2VwdCBoYW5kbGVyc1xyXG5cdFx0dmFyIGVycm9yID0gbnVsbDtcclxuXHRcdGZvcih2YXIgbW9kdWxlSWQgaW4gb3V0ZGF0ZWREZXBlbmRlbmNpZXMpIHtcclxuXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG91dGRhdGVkRGVwZW5kZW5jaWVzLCBtb2R1bGVJZCkpIHtcclxuXHRcdFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcblx0XHRcdFx0dmFyIG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzID0gb3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdO1xyXG5cdFx0XHRcdHZhciBjYWxsYmFja3MgPSBbXTtcclxuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdHZhciBkZXBlbmRlbmN5ID0gbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXNbaV07XHJcblx0XHRcdFx0XHR2YXIgY2IgPSBtb2R1bGUuaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1tkZXBlbmRlbmN5XTtcclxuXHRcdFx0XHRcdGlmKGNhbGxiYWNrcy5pbmRleE9mKGNiKSA+PSAwKSBjb250aW51ZTtcclxuXHRcdFx0XHRcdGNhbGxiYWNrcy5wdXNoKGNiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0dmFyIGNiID0gY2FsbGJhY2tzW2ldO1xyXG5cdFx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdFx0Y2Iob3V0ZGF0ZWREZXBlbmRlbmNpZXMpO1xyXG5cdFx0XHRcdFx0fSBjYXRjaChlcnIpIHtcclxuXHRcdFx0XHRcdFx0aWYoIWVycm9yKVxyXG5cdFx0XHRcdFx0XHRcdGVycm9yID0gZXJyO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIExvYWQgc2VsZiBhY2NlcHRlZCBtb2R1bGVzXHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzW2ldO1xyXG5cdFx0XHR2YXIgbW9kdWxlSWQgPSBpdGVtLm1vZHVsZTtcclxuXHRcdFx0aG90Q3VycmVudFBhcmVudHMgPSBbbW9kdWxlSWRdO1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdCRyZXF1aXJlJChtb2R1bGVJZCk7XHJcblx0XHRcdH0gY2F0Y2goZXJyKSB7XHJcblx0XHRcdFx0aWYodHlwZW9mIGl0ZW0uZXJyb3JIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdGl0ZW0uZXJyb3JIYW5kbGVyKGVycik7XHJcblx0XHRcdFx0XHR9IGNhdGNoKGVycikge1xyXG5cdFx0XHRcdFx0XHRpZighZXJyb3IpXHJcblx0XHRcdFx0XHRcdFx0ZXJyb3IgPSBlcnI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIGlmKCFlcnJvcilcclxuXHRcdFx0XHRcdGVycm9yID0gZXJyO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaGFuZGxlIGVycm9ycyBpbiBhY2NlcHQgaGFuZGxlcnMgYW5kIHNlbGYgYWNjZXB0ZWQgbW9kdWxlIGxvYWRcclxuXHRcdGlmKGVycm9yKSB7XHJcblx0XHRcdGhvdFNldFN0YXR1cyhcImZhaWxcIik7XHJcblx0XHRcdHJldHVybiBjYWxsYmFjayhlcnJvcik7XHJcblx0XHR9XHJcblxyXG5cdFx0aG90U2V0U3RhdHVzKFwiaWRsZVwiKTtcclxuXHRcdGNhbGxiYWNrKG51bGwsIG91dGRhdGVkTW9kdWxlcyk7XHJcblx0fVxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL0hvdE1vZHVsZVJlcGxhY2VtZW50LnJ1bnRpbWUuanNcbi8vIG1vZHVsZSBpZCA9IDMxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgUHJlZmV0Y2hEZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4vZGVwZW5kZW5jaWVzL1ByZWZldGNoRGVwZW5kZW5jeVwiKTtcclxuXHJcbmZ1bmN0aW9uIFByZWZldGNoUGx1Z2luKGNvbnRleHQsIHJlcXVlc3QpIHtcclxuXHRpZighcmVxdWVzdCkge1xyXG5cdFx0dGhpcy5yZXF1ZXN0ID0gY29udGV4dDtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuXHRcdHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XHJcblx0fVxyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gUHJlZmV0Y2hQbHVnaW47XHJcblByZWZldGNoUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGNvbXBpbGVyKSB7XHJcblx0Y29tcGlsZXIucGx1Z2luKFwiY29tcGlsYXRpb25cIiwgZnVuY3Rpb24oY29tcGlsYXRpb24sIHBhcmFtcykge1xyXG5cdFx0dmFyIG5vcm1hbE1vZHVsZUZhY3RvcnkgPSBwYXJhbXMubm9ybWFsTW9kdWxlRmFjdG9yeTtcclxuXHJcblx0XHRjb21waWxhdGlvbi5kZXBlbmRlbmN5RmFjdG9yaWVzLnNldChQcmVmZXRjaERlcGVuZGVuY3ksIG5vcm1hbE1vZHVsZUZhY3RvcnkpO1xyXG5cdH0pO1xyXG5cdGNvbXBpbGVyLnBsdWdpbihcIm1ha2VcIiwgZnVuY3Rpb24oY29tcGlsYXRpb24sIGNhbGxiYWNrKSB7XHJcblx0XHRjb21waWxhdGlvbi5wcmVmZXRjaCh0aGlzLmNvbnRleHQgfHwgY29tcGlsZXIuY29udGV4dCwgbmV3IFByZWZldGNoRGVwZW5kZW5jeSh0aGlzLnJlcXVlc3QpLCBjYWxsYmFjayk7XHJcblx0fS5iaW5kKHRoaXMpKTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2xpYi9QcmVmZXRjaFBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMzE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBNb2R1bGVEZXBlbmRlbmN5ID0gcmVxdWlyZShcIi4vTW9kdWxlRGVwZW5kZW5jeVwiKTtcclxuXHJcbmZ1bmN0aW9uIFByZWZldGNoRGVwZW5kZW5jeShyZXF1ZXN0KSB7XHJcblx0TW9kdWxlRGVwZW5kZW5jeS5jYWxsKHRoaXMsIHJlcXVlc3QpO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gUHJlZmV0Y2hEZXBlbmRlbmN5O1xyXG5cclxuUHJlZmV0Y2hEZXBlbmRlbmN5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTW9kdWxlRGVwZW5kZW5jeS5wcm90b3R5cGUpO1xyXG5QcmVmZXRjaERlcGVuZGVuY3kucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHJlZmV0Y2hEZXBlbmRlbmN5O1xyXG5QcmVmZXRjaERlcGVuZGVuY3kucHJvdG90eXBlLnR5cGUgPSBcInByZWZldGNoXCI7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvZGVwZW5kZW5jaWVzL1ByZWZldGNoRGVwZW5kZW5jeS5qc1xuLy8gbW9kdWxlIGlkID0gMzE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbmZ1bmN0aW9uIE9jY3VycmVuY2VPcmRlclBsdWdpbihwcmVmZXJFbnRyeSkge1xyXG5cdGlmKHByZWZlckVudHJ5ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHByZWZlckVudHJ5ICE9PSBcImJvb2xlYW5cIikge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgc2hvdWxkIGJlIGEgYm9vbGVhbi5cXG5Gb3IgbW9yZSBpbmZvIG9uIHRoaXMgcGx1Z2luLCBzZWUgaHR0cHM6Ly93ZWJwYWNrLmdpdGh1Yi5pby9kb2NzL2xpc3Qtb2YtcGx1Z2lucy5odG1sXCIpO1xyXG5cdH1cclxuXHR0aGlzLnByZWZlckVudHJ5ID0gcHJlZmVyRW50cnk7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBPY2N1cnJlbmNlT3JkZXJQbHVnaW47XHJcbk9jY3VycmVuY2VPcmRlclBsdWdpbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbihjb21waWxlcikge1xyXG5cdHZhciBwcmVmZXJFbnRyeSA9IHRoaXMucHJlZmVyRW50cnk7XHJcblx0Y29tcGlsZXIucGx1Z2luKFwiY29tcGlsYXRpb25cIiwgZnVuY3Rpb24oY29tcGlsYXRpb24pIHtcclxuXHRcdGNvbXBpbGF0aW9uLnBsdWdpbihcIm9wdGltaXplLW1vZHVsZS1vcmRlclwiLCBmdW5jdGlvbihtb2R1bGVzKSB7XHJcblx0XHRcdGZ1bmN0aW9uIGVudHJ5Q2h1bmtzKG0pIHtcclxuXHRcdFx0XHRyZXR1cm4gbS5jaHVua3MuZmlsdGVyKGZ1bmN0aW9uKGMpIHtcclxuXHRcdFx0XHRcdHJldHVybiBjLmluaXRpYWw7XHJcblx0XHRcdFx0fSkubGVuZ3RoO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmdW5jdGlvbiBvY2N1cnNJbkVudHJ5KG0pIHtcclxuXHRcdFx0XHRyZXR1cm4gbS5yZWFzb25zLm1hcChmdW5jdGlvbihyKSB7XHJcblx0XHRcdFx0XHRpZighci5tb2R1bGUpIHJldHVybiAwO1xyXG5cdFx0XHRcdFx0cmV0dXJuIGVudHJ5Q2h1bmtzKHIubW9kdWxlKTtcclxuXHRcdFx0XHR9KS5yZWR1Y2UoZnVuY3Rpb24oYSwgYikge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGEgKyBiO1xyXG5cdFx0XHRcdH0sIDApICsgZW50cnlDaHVua3MobSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZ1bmN0aW9uIG9jY3VycyhtKSB7XHJcblx0XHRcdFx0cmV0dXJuIG0ucmVhc29ucy5tYXAoZnVuY3Rpb24ocikge1xyXG5cdFx0XHRcdFx0aWYoIXIubW9kdWxlKSByZXR1cm4gMDtcclxuXHRcdFx0XHRcdHJldHVybiByLm1vZHVsZS5jaHVua3MubGVuZ3RoO1xyXG5cdFx0XHRcdH0pLnJlZHVjZShmdW5jdGlvbihhLCBiKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gYSArIGI7XHJcblx0XHRcdFx0fSwgMCkgKyBtLmNodW5rcy5sZW5ndGg7XHJcblx0XHRcdH1cclxuXHRcdFx0bW9kdWxlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdFx0XHRpZihwcmVmZXJFbnRyeSkge1xyXG5cdFx0XHRcdFx0dmFyIGFFbnRyeU9jY3VycyA9IG9jY3Vyc0luRW50cnkoYSk7XHJcblx0XHRcdFx0XHR2YXIgYkVudHJ5T2NjdXJzID0gb2NjdXJzSW5FbnRyeShiKTtcclxuXHRcdFx0XHRcdGlmKGFFbnRyeU9jY3VycyA+IGJFbnRyeU9jY3VycykgcmV0dXJuIC0xO1xyXG5cdFx0XHRcdFx0aWYoYUVudHJ5T2NjdXJzIDwgYkVudHJ5T2NjdXJzKSByZXR1cm4gMTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dmFyIGFPY2N1cnMgPSBvY2N1cnMoYSk7XHJcblx0XHRcdFx0dmFyIGJPY2N1cnMgPSBvY2N1cnMoYik7XHJcblx0XHRcdFx0aWYoYU9jY3VycyA+IGJPY2N1cnMpIHJldHVybiAtMTtcclxuXHRcdFx0XHRpZihhT2NjdXJzIDwgYk9jY3VycykgcmV0dXJuIDE7XHJcblx0XHRcdFx0aWYoYS5pZGVudGlmaWVyKCkgPiBiLmlkZW50aWZpZXIoKSkgcmV0dXJuIDE7XHJcblx0XHRcdFx0aWYoYS5pZGVudGlmaWVyKCkgPCBiLmlkZW50aWZpZXIoKSkgcmV0dXJuIC0xO1xyXG5cdFx0XHRcdHJldHVybiAwO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdFx0Y29tcGlsYXRpb24ucGx1Z2luKFwib3B0aW1pemUtY2h1bmstb3JkZXJcIiwgZnVuY3Rpb24oY2h1bmtzKSB7XHJcblx0XHRcdGZ1bmN0aW9uIG9jY3Vyc0luRW50cnkoYykge1xyXG5cdFx0XHRcdHJldHVybiBjLnBhcmVudHMuZmlsdGVyKGZ1bmN0aW9uKHApIHtcclxuXHRcdFx0XHRcdHJldHVybiBwLmluaXRpYWw7XHJcblx0XHRcdFx0fSkubGVuZ3RoICsgKGMuZW50cnkgPyAxIDogMCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZ1bmN0aW9uIG9jY3VycyhjKSB7XHJcblx0XHRcdFx0cmV0dXJuIGMuYmxvY2tzLmxlbmd0aCArIChjLmVudHJ5ID8gMSA6IDApO1xyXG5cdFx0XHR9XHJcblx0XHRcdGNodW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcclxuXHRcdFx0XHRjLm1vZHVsZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XHJcblx0XHRcdFx0XHRpZihhLmlkZW50aWZpZXIoKSA+IGIuaWRlbnRpZmllcigpKSByZXR1cm4gMTtcclxuXHRcdFx0XHRcdGlmKGEuaWRlbnRpZmllcigpIDwgYi5pZGVudGlmaWVyKCkpIHJldHVybiAtMTtcclxuXHRcdFx0XHRcdHJldHVybiAwO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0Y2h1bmtzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xyXG5cdFx0XHRcdHZhciBhRW50cnlPY2N1cnMgPSBvY2N1cnNJbkVudHJ5KGEpO1xyXG5cdFx0XHRcdHZhciBiRW50cnlPY2N1cnMgPSBvY2N1cnNJbkVudHJ5KGIpO1xyXG5cdFx0XHRcdGlmKGFFbnRyeU9jY3VycyA+IGJFbnRyeU9jY3VycykgcmV0dXJuIC0xO1xyXG5cdFx0XHRcdGlmKGFFbnRyeU9jY3VycyA8IGJFbnRyeU9jY3VycykgcmV0dXJuIDE7XHJcblx0XHRcdFx0dmFyIGFPY2N1cnMgPSBvY2N1cnMoYSk7XHJcblx0XHRcdFx0dmFyIGJPY2N1cnMgPSBvY2N1cnMoYik7XHJcblx0XHRcdFx0aWYoYU9jY3VycyA+IGJPY2N1cnMpIHJldHVybiAtMTtcclxuXHRcdFx0XHRpZihhT2NjdXJzIDwgYk9jY3VycykgcmV0dXJuIDE7XHJcblx0XHRcdFx0aWYoYS5tb2R1bGVzLmxlbmd0aCA+IGIubW9kdWxlcy5sZW5ndGgpIHJldHVybiAtMTtcclxuXHRcdFx0XHRpZihhLm1vZHVsZXMubGVuZ3RoIDwgYi5tb2R1bGVzLmxlbmd0aCkgcmV0dXJuIDE7XHJcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGEubW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0aWYoYS5tb2R1bGVzW2ldLmlkZW50aWZpZXIoKSA+IGIubW9kdWxlc1tpXS5pZGVudGlmaWVyKCkpIHJldHVybiAtMTtcclxuXHRcdFx0XHRcdGlmKGEubW9kdWxlc1tpXS5pZGVudGlmaWVyKCkgPCBiLm1vZHVsZXNbaV0uaWRlbnRpZmllcigpKSByZXR1cm4gMTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIDA7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvb3B0aW1pemUvT2NjdXJyZW5jZU9yZGVyUGx1Z2luLmpzXG4vLyBtb2R1bGUgaWQgPSAzMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuZnVuY3Rpb24gTWluQ2h1bmtTaXplUGx1Z2luKG9wdGlvbnMpIHtcclxuXHRpZih0eXBlb2Ygb3B0aW9ucyAhPT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudCBzaG91bGQgYmUgYW4gb3B0aW9ucyBvYmplY3QuXFxuRm9yIG1vcmUgaW5mbyBvbiBvcHRpb25zLCBzZWUgaHR0cHM6Ly93ZWJwYWNrLmdpdGh1Yi5pby9kb2NzL2xpc3Qtb2YtcGx1Z2lucy5odG1sXCIpO1xyXG5cdH1cclxuXHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gTWluQ2h1bmtTaXplUGx1Z2luO1xyXG5cclxuTWluQ2h1bmtTaXplUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGNvbXBpbGVyKSB7XHJcblx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblx0dmFyIG1pbkNodW5rU2l6ZSA9IG9wdGlvbnMubWluQ2h1bmtTaXplO1xyXG5cdGNvbXBpbGVyLnBsdWdpbihcImNvbXBpbGF0aW9uXCIsIGZ1bmN0aW9uKGNvbXBpbGF0aW9uKSB7XHJcblx0XHRjb21waWxhdGlvbi5wbHVnaW4oXCJvcHRpbWl6ZS1jaHVua3NcIiwgZnVuY3Rpb24oY2h1bmtzKSB7XHJcblxyXG5cdFx0XHR2YXIgY29tYmluYXRpb25zID0gW107XHJcblx0XHRcdGNodW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGEsIGlkeCkge1xyXG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBpZHg7IGkrKykge1xyXG5cdFx0XHRcdFx0dmFyIGIgPSBjaHVua3NbaV07XHJcblx0XHRcdFx0XHRjb21iaW5hdGlvbnMucHVzaChbYiwgYV0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHR2YXIgZXF1YWxPcHRpb25zID0ge1xyXG5cdFx0XHRcdGNodW5rT3ZlcmhlYWQ6IDEsXHJcblx0XHRcdFx0ZW50cnlDaHVua011bHRpcGxpY2F0b3I6IDFcclxuXHRcdFx0fTtcclxuXHRcdFx0Y29tYmluYXRpb25zID0gY29tYmluYXRpb25zLmZpbHRlcihmdW5jdGlvbihwYWlyKSB7XHJcblx0XHRcdFx0cmV0dXJuIHBhaXJbMF0uc2l6ZShlcXVhbE9wdGlvbnMpIDwgbWluQ2h1bmtTaXplIHx8IHBhaXJbMV0uc2l6ZShlcXVhbE9wdGlvbnMpIDwgbWluQ2h1bmtTaXplO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGNvbWJpbmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHBhaXIpIHtcclxuXHRcdFx0XHR2YXIgYSA9IHBhaXJbMF0uc2l6ZShvcHRpb25zKTtcclxuXHRcdFx0XHR2YXIgYiA9IHBhaXJbMV0uc2l6ZShvcHRpb25zKTtcclxuXHRcdFx0XHR2YXIgYWIgPSBwYWlyWzBdLmludGVncmF0ZWRTaXplKHBhaXJbMV0sIG9wdGlvbnMpO1xyXG5cdFx0XHRcdHBhaXIudW5zaGlmdChhICsgYiAtIGFiLCBhYik7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Y29tYmluYXRpb25zID0gY29tYmluYXRpb25zLmZpbHRlcihmdW5jdGlvbihwYWlyKSB7XHJcblx0XHRcdFx0cmV0dXJuIHBhaXJbMV0gIT09IGZhbHNlO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGlmKGNvbWJpbmF0aW9ucy5sZW5ndGggPT09IDApIHJldHVybjtcclxuXHJcblx0XHRcdGNvbWJpbmF0aW9ucy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdFx0XHR2YXIgZGlmZiA9IGJbMF0gLSBhWzBdO1xyXG5cdFx0XHRcdGlmKGRpZmYgIT09IDApIHJldHVybiBkaWZmO1xyXG5cdFx0XHRcdHJldHVybiBhWzFdIC0gYlsxXTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHR2YXIgcGFpciA9IGNvbWJpbmF0aW9uc1swXTtcclxuXHJcblx0XHRcdHBhaXJbMl0uaW50ZWdyYXRlKHBhaXJbM10sIFwibWluLXNpemVcIik7XHJcblx0XHRcdGNodW5rcy5zcGxpY2UoY2h1bmtzLmluZGV4T2YocGFpclszXSksIDEpO1xyXG5cdFx0XHR0aGlzLnJlc3RhcnRBcHBseVBsdWdpbnMoKTtcclxuXHRcdH0pO1xyXG5cdH0pO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL29wdGltaXplL01pbkNodW5rU2l6ZVBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMzIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbmZ1bmN0aW9uIExpbWl0Q2h1bmtDb3VudFBsdWdpbihvcHRpb25zKSB7XHJcblx0aWYob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRpb25zICE9PSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50IHNob3VsZCBiZSBhbiBvcHRpb25zIG9iamVjdC5cXG5Gb3IgbW9yZSBpbmZvIG9uIG9wdGlvbnMsIHNlZSBodHRwczovL3dlYnBhY2suZ2l0aHViLmlvL2RvY3MvbGlzdC1vZi1wbHVnaW5zLmh0bWxcIik7XHJcblx0fVxyXG5cdHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBMaW1pdENodW5rQ291bnRQbHVnaW47XHJcblxyXG5MaW1pdENodW5rQ291bnRQbHVnaW4ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oY29tcGlsZXIpIHtcclxuXHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHRjb21waWxlci5wbHVnaW4oXCJjb21waWxhdGlvblwiLCBmdW5jdGlvbihjb21waWxhdGlvbikge1xyXG5cdFx0Y29tcGlsYXRpb24ucGx1Z2luKFwib3B0aW1pemUtY2h1bmtzXCIsIGZ1bmN0aW9uKGNodW5rcykge1xyXG5cdFx0XHR2YXIgbWF4Q2h1bmtzID0gb3B0aW9ucy5tYXhDaHVua3M7XHJcblx0XHRcdGlmKCFtYXhDaHVua3MpIHJldHVybjtcclxuXHRcdFx0aWYobWF4Q2h1bmtzIDwgMSkgcmV0dXJuO1xyXG5cdFx0XHRpZihjaHVua3MubGVuZ3RoIDw9IG1heENodW5rcykgcmV0dXJuO1xyXG5cclxuXHRcdFx0aWYoY2h1bmtzLmxlbmd0aCA+IG1heENodW5rcykge1xyXG5cdFx0XHRcdHZhciBjb21iaW5hdGlvbnMgPSBbXTtcclxuXHRcdFx0XHRjaHVua3MuZm9yRWFjaChmdW5jdGlvbihhLCBpZHgpIHtcclxuXHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBpZHg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHR2YXIgYiA9IGNodW5rc1tpXTtcclxuXHRcdFx0XHRcdFx0Y29tYmluYXRpb25zLnB1c2goW2IsIGFdKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0Y29tYmluYXRpb25zLmZvckVhY2goZnVuY3Rpb24ocGFpcikge1xyXG5cdFx0XHRcdFx0dmFyIGEgPSBwYWlyWzBdLnNpemUob3B0aW9ucyk7XHJcblx0XHRcdFx0XHR2YXIgYiA9IHBhaXJbMV0uc2l6ZShvcHRpb25zKTtcclxuXHRcdFx0XHRcdHZhciBhYiA9IHBhaXJbMF0uaW50ZWdyYXRlZFNpemUocGFpclsxXSwgb3B0aW9ucyk7XHJcblx0XHRcdFx0XHRwYWlyLnVuc2hpZnQoYSArIGIgLSBhYiwgYWIpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdGNvbWJpbmF0aW9ucyA9IGNvbWJpbmF0aW9ucy5maWx0ZXIoZnVuY3Rpb24ocGFpcikge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHBhaXJbMV0gIT09IGZhbHNlO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdGNvbWJpbmF0aW9ucy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdFx0XHRcdHZhciBkaWZmID0gYlswXSAtIGFbMF07XHJcblx0XHRcdFx0XHRpZihkaWZmICE9PSAwKSByZXR1cm4gZGlmZjtcclxuXHRcdFx0XHRcdHJldHVybiBhWzFdIC0gYlsxXTtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0dmFyIHBhaXIgPSBjb21iaW5hdGlvbnNbMF07XHJcblxyXG5cdFx0XHRcdGlmKHBhaXIgJiYgcGFpclsyXS5pbnRlZ3JhdGUocGFpclszXSwgXCJsaW1pdFwiKSkge1xyXG5cdFx0XHRcdFx0Y2h1bmtzLnNwbGljZShjaHVua3MuaW5kZXhPZihwYWlyWzNdKSwgMSk7XHJcblx0XHRcdFx0XHR0aGlzLnJlc3RhcnRBcHBseVBsdWdpbnMoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH0pO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvbGliL29wdGltaXplL0xpbWl0Q2h1bmtDb3VudFBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMzIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBTb3VyY2VNYXBDb25zdW1lciA9IHJlcXVpcmUoXCJ3ZWJwYWNrLWNvcmUvbGliL3NvdXJjZS1tYXBcIikuU291cmNlTWFwQ29uc3VtZXI7XHJcbnZhciBTb3VyY2VNYXBTb3VyY2UgPSByZXF1aXJlKFwid2VicGFjay1jb3JlL2xpYi9Tb3VyY2VNYXBTb3VyY2VcIik7XHJcbnZhciBSYXdTb3VyY2UgPSByZXF1aXJlKFwid2VicGFjay1jb3JlL2xpYi9SYXdTb3VyY2VcIik7XHJcbnZhciBSZXF1ZXN0U2hvcnRlbmVyID0gcmVxdWlyZShcIi4uL1JlcXVlc3RTaG9ydGVuZXJcIik7XHJcbnZhciBNb2R1bGVGaWxlbmFtZUhlbHBlcnMgPSByZXF1aXJlKFwiLi4vTW9kdWxlRmlsZW5hbWVIZWxwZXJzXCIpO1xyXG52YXIgdWdsaWZ5ID0gcmVxdWlyZShcInVnbGlmeS1qc1wiKTtcclxuXHJcbmZ1bmN0aW9uIFVnbGlmeUpzUGx1Z2luKG9wdGlvbnMpIHtcclxuXHRpZih0eXBlb2Ygb3B0aW9ucyAhPT0gXCJvYmplY3RcIikgb3B0aW9ucyA9IHt9O1xyXG5cdGlmKHR5cGVvZiBvcHRpb25zLmNvbXByZXNzb3IgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdG9wdGlvbnMuY29tcHJlc3MgPSBvcHRpb25zLmNvbXByZXNzb3I7XHJcblx0fVxyXG5cdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBVZ2xpZnlKc1BsdWdpbjtcclxuXHJcblVnbGlmeUpzUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGNvbXBpbGVyKSB7XHJcblx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblx0b3B0aW9ucy50ZXN0ID0gb3B0aW9ucy50ZXN0IHx8IC9cXC5qcygkfFxcPykvaTtcclxuXHJcblx0dmFyIHJlcXVlc3RTaG9ydGVuZXIgPSBuZXcgUmVxdWVzdFNob3J0ZW5lcihjb21waWxlci5jb250ZXh0KTtcclxuXHRjb21waWxlci5wbHVnaW4oXCJjb21waWxhdGlvblwiLCBmdW5jdGlvbihjb21waWxhdGlvbikge1xyXG5cdFx0aWYob3B0aW9ucy5zb3VyY2VNYXAgIT09IGZhbHNlKSB7XHJcblx0XHRcdGNvbXBpbGF0aW9uLnBsdWdpbihcImJ1aWxkLW1vZHVsZVwiLCBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRcdFx0XHQvLyB0byBnZXQgZGV0YWlsZWQgbG9jYXRpb24gaW5mbyBhYm91dCBlcnJvcnNcclxuXHRcdFx0XHRtb2R1bGUudXNlU291cmNlTWFwID0gdHJ1ZTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0XHRjb21waWxhdGlvbi5wbHVnaW4oXCJvcHRpbWl6ZS1jaHVuay1hc3NldHNcIiwgZnVuY3Rpb24oY2h1bmtzLCBjYWxsYmFjaykge1xyXG5cdFx0XHR2YXIgZmlsZXMgPSBbXTtcclxuXHRcdFx0Y2h1bmtzLmZvckVhY2goZnVuY3Rpb24oY2h1bmspIHtcclxuXHRcdFx0XHRjaHVuay5maWxlcy5mb3JFYWNoKGZ1bmN0aW9uKGZpbGUpIHtcclxuXHRcdFx0XHRcdGZpbGVzLnB1c2goZmlsZSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRjb21waWxhdGlvbi5hZGRpdGlvbmFsQ2h1bmtBc3NldHMuZm9yRWFjaChmdW5jdGlvbihmaWxlKSB7XHJcblx0XHRcdFx0ZmlsZXMucHVzaChmaWxlKTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGZpbGVzID0gZmlsZXMuZmlsdGVyKE1vZHVsZUZpbGVuYW1lSGVscGVycy5tYXRjaE9iamVjdC5iaW5kKHVuZGVmaW5lZCwgb3B0aW9ucykpO1xyXG5cdFx0XHRmaWxlcy5mb3JFYWNoKGZ1bmN0aW9uKGZpbGUpIHtcclxuXHRcdFx0XHR2YXIgb2xkV2FybkZ1bmN0aW9uID0gdWdsaWZ5LkFTVF9Ob2RlLndhcm5fZnVuY3Rpb247XHJcblx0XHRcdFx0dmFyIHdhcm5pbmdzID0gW107XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdHZhciBhc3NldCA9IGNvbXBpbGF0aW9uLmFzc2V0c1tmaWxlXTtcclxuXHRcdFx0XHRcdGlmKGFzc2V0Ll9fVWdsaWZ5SnNQbHVnaW4pIHtcclxuXHRcdFx0XHRcdFx0Y29tcGlsYXRpb24uYXNzZXRzW2ZpbGVdID0gYXNzZXQuX19VZ2xpZnlKc1BsdWdpbjtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYob3B0aW9ucy5zb3VyY2VNYXAgIT09IGZhbHNlKSB7XHJcblx0XHRcdFx0XHRcdGlmKGFzc2V0LnNvdXJjZUFuZE1hcCkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBzb3VyY2VBbmRNYXAgPSBhc3NldC5zb3VyY2VBbmRNYXAoKTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgaW5wdXRTb3VyY2VNYXAgPSBzb3VyY2VBbmRNYXAubWFwO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBpbnB1dCA9IHNvdXJjZUFuZE1hcC5zb3VyY2U7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGlucHV0U291cmNlTWFwID0gYXNzZXQubWFwKCk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGlucHV0ID0gYXNzZXQuc291cmNlKCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0dmFyIHNvdXJjZU1hcCA9IG5ldyBTb3VyY2VNYXBDb25zdW1lcihpbnB1dFNvdXJjZU1hcCk7XHJcblx0XHRcdFx0XHRcdHVnbGlmeS5BU1RfTm9kZS53YXJuX2Z1bmN0aW9uID0gZnVuY3Rpb24od2FybmluZykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxyXG5cdFx0XHRcdFx0XHRcdHZhciBtYXRjaCA9IC9cXFsuKzooWzAtOV0rKSwoWzAtOV0rKVxcXS8uZXhlYyh3YXJuaW5nKTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgbGluZSA9ICttYXRjaFsxXTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgY29sdW1uID0gK21hdGNoWzJdO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBvcmlnaW5hbCA9IHNvdXJjZU1hcC5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcclxuXHRcdFx0XHRcdFx0XHRcdGxpbmU6IGxpbmUsXHJcblx0XHRcdFx0XHRcdFx0XHRjb2x1bW46IGNvbHVtblxyXG5cdFx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0XHRcdGlmKCFvcmlnaW5hbCB8fCAhb3JpZ2luYWwuc291cmNlIHx8IG9yaWdpbmFsLnNvdXJjZSA9PT0gZmlsZSkgcmV0dXJuO1xyXG5cdFx0XHRcdFx0XHRcdHdhcm5pbmdzLnB1c2god2FybmluZy5yZXBsYWNlKC9cXFsuKzooWzAtOV0rKSwoWzAtOV0rKVxcXS8sIFwiXCIpICtcclxuXHRcdFx0XHRcdFx0XHRcdFwiW1wiICsgcmVxdWVzdFNob3J0ZW5lci5zaG9ydGVuKG9yaWdpbmFsLnNvdXJjZSkgKyBcIjpcIiArIG9yaWdpbmFsLmxpbmUgKyBcIixcIiArIG9yaWdpbmFsLmNvbHVtbiArIFwiXVwiKTtcclxuXHRcdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHZhciBpbnB1dCA9IGFzc2V0LnNvdXJjZSgpO1xyXG5cdFx0XHRcdFx0XHR1Z2xpZnkuQVNUX05vZGUud2Fybl9mdW5jdGlvbiA9IGZ1bmN0aW9uKHdhcm5pbmcpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcclxuXHRcdFx0XHRcdFx0XHR3YXJuaW5ncy5wdXNoKHdhcm5pbmcpO1xyXG5cdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dWdsaWZ5LmJhc2U1NC5yZXNldCgpO1xyXG5cdFx0XHRcdFx0dmFyIGFzdCA9IHVnbGlmeS5wYXJzZShpbnB1dCwge1xyXG5cdFx0XHRcdFx0XHRmaWxlbmFtZTogZmlsZVxyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHRpZihvcHRpb25zLmNvbXByZXNzICE9PSBmYWxzZSkge1xyXG5cdFx0XHRcdFx0XHRhc3QuZmlndXJlX291dF9zY29wZSgpO1xyXG5cdFx0XHRcdFx0XHR2YXIgY29tcHJlc3MgPSB1Z2xpZnkuQ29tcHJlc3NvcihvcHRpb25zLmNvbXByZXNzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXHJcblx0XHRcdFx0XHRcdGFzdCA9IGFzdC50cmFuc2Zvcm0oY29tcHJlc3MpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYob3B0aW9ucy5tYW5nbGUgIT09IGZhbHNlKSB7XHJcblx0XHRcdFx0XHRcdGFzdC5maWd1cmVfb3V0X3Njb3BlKCk7XHJcblx0XHRcdFx0XHRcdGFzdC5jb21wdXRlX2NoYXJfZnJlcXVlbmN5KG9wdGlvbnMubWFuZ2xlIHx8IHt9KTtcclxuXHRcdFx0XHRcdFx0YXN0Lm1hbmdsZV9uYW1lcyhvcHRpb25zLm1hbmdsZSB8fCB7fSk7XHJcblx0XHRcdFx0XHRcdGlmKG9wdGlvbnMubWFuZ2xlICYmIG9wdGlvbnMubWFuZ2xlLnByb3BzKSB7XHJcblx0XHRcdFx0XHRcdFx0dWdsaWZ5Lm1hbmdsZV9wcm9wZXJ0aWVzKGFzdCwgb3B0aW9ucy5tYW5nbGUucHJvcHMpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR2YXIgb3V0cHV0ID0ge307XHJcblx0XHRcdFx0XHRvdXRwdXQuY29tbWVudHMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgXCJjb21tZW50c1wiKSA/IG9wdGlvbnMuY29tbWVudHMgOiAvXlxcKiohfEBwcmVzZXJ2ZXxAbGljZW5zZS87XHJcblx0XHRcdFx0XHRvdXRwdXQuYmVhdXRpZnkgPSBvcHRpb25zLmJlYXV0aWZ5O1xyXG5cdFx0XHRcdFx0Zm9yKHZhciBrIGluIG9wdGlvbnMub3V0cHV0KSB7XHJcblx0XHRcdFx0XHRcdG91dHB1dFtrXSA9IG9wdGlvbnMub3V0cHV0W2tdO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYob3B0aW9ucy5zb3VyY2VNYXAgIT09IGZhbHNlKSB7XHJcblx0XHRcdFx0XHRcdHZhciBtYXAgPSB1Z2xpZnkuU291cmNlTWFwKHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXHJcblx0XHRcdFx0XHRcdFx0ZmlsZTogZmlsZSxcclxuXHRcdFx0XHRcdFx0XHRyb290OiBcIlwiXHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0XHRvdXRwdXQuc291cmNlX21hcCA9IG1hcDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHZhciBzdHJlYW0gPSB1Z2xpZnkuT3V0cHV0U3RyZWFtKG91dHB1dCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxyXG5cdFx0XHRcdFx0YXN0LnByaW50KHN0cmVhbSk7XHJcblx0XHRcdFx0XHRpZihtYXApIG1hcCA9IG1hcCArIFwiXCI7XHJcblx0XHRcdFx0XHRzdHJlYW0gPSBzdHJlYW0gKyBcIlwiO1xyXG5cdFx0XHRcdFx0YXNzZXQuX19VZ2xpZnlKc1BsdWdpbiA9IGNvbXBpbGF0aW9uLmFzc2V0c1tmaWxlXSA9IChtYXAgP1xyXG5cdFx0XHRcdFx0XHRuZXcgU291cmNlTWFwU291cmNlKHN0cmVhbSwgZmlsZSwgSlNPTi5wYXJzZShtYXApLCBpbnB1dCwgaW5wdXRTb3VyY2VNYXApIDpcclxuXHRcdFx0XHRcdFx0bmV3IFJhd1NvdXJjZShzdHJlYW0pKTtcclxuXHRcdFx0XHRcdGlmKHdhcm5pbmdzLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRcdFx0Y29tcGlsYXRpb24ud2FybmluZ3MucHVzaChuZXcgRXJyb3IoZmlsZSArIFwiIGZyb20gVWdsaWZ5SnNcXG5cIiArIHdhcm5pbmdzLmpvaW4oXCJcXG5cIikpKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGNhdGNoKGVycikge1xyXG5cdFx0XHRcdFx0aWYoZXJyLmxpbmUpIHtcclxuXHRcdFx0XHRcdFx0dmFyIG9yaWdpbmFsID0gc291cmNlTWFwICYmIHNvdXJjZU1hcC5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcclxuXHRcdFx0XHRcdFx0XHRsaW5lOiBlcnIubGluZSxcclxuXHRcdFx0XHRcdFx0XHRjb2x1bW46IGVyci5jb2xcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHRcdGlmKG9yaWdpbmFsICYmIG9yaWdpbmFsLnNvdXJjZSkge1xyXG5cdFx0XHRcdFx0XHRcdGNvbXBpbGF0aW9uLmVycm9ycy5wdXNoKG5ldyBFcnJvcihmaWxlICsgXCIgZnJvbSBVZ2xpZnlKc1xcblwiICsgZXJyLm1lc3NhZ2UgKyBcIiBbXCIgKyByZXF1ZXN0U2hvcnRlbmVyLnNob3J0ZW4ob3JpZ2luYWwuc291cmNlKSArIFwiOlwiICsgb3JpZ2luYWwubGluZSArIFwiLFwiICsgb3JpZ2luYWwuY29sdW1uICsgXCJdXCIpKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRjb21waWxhdGlvbi5lcnJvcnMucHVzaChuZXcgRXJyb3IoZmlsZSArIFwiIGZyb20gVWdsaWZ5SnNcXG5cIiArIGVyci5tZXNzYWdlICsgXCIgW1wiICsgZmlsZSArIFwiOlwiICsgZXJyLmxpbmUgKyBcIixcIiArIGVyci5jb2wgKyBcIl1cIikpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoZXJyLm1zZykge1xyXG5cdFx0XHRcdFx0XHRjb21waWxhdGlvbi5lcnJvcnMucHVzaChuZXcgRXJyb3IoZmlsZSArIFwiIGZyb20gVWdsaWZ5SnNcXG5cIiArIGVyci5tc2cpKTtcclxuXHRcdFx0XHRcdH0gZWxzZVxyXG5cdFx0XHRcdFx0XHRjb21waWxhdGlvbi5lcnJvcnMucHVzaChuZXcgRXJyb3IoZmlsZSArIFwiIGZyb20gVWdsaWZ5SnNcXG5cIiArIGVyci5zdGFjaykpO1xyXG5cdFx0XHRcdH0gZmluYWxseSB7XHJcblx0XHRcdFx0XHR1Z2xpZnkuQVNUX05vZGUud2Fybl9mdW5jdGlvbiA9IG9sZFdhcm5GdW5jdGlvbjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0fSk7XHJcblx0XHRjb21waWxhdGlvbi5wbHVnaW4oXCJub3JtYWwtbW9kdWxlLWxvYWRlclwiLCBmdW5jdGlvbihjb250ZXh0KSB7XHJcblx0XHRcdGNvbnRleHQubWluaW1pemUgPSB0cnVlO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvb3B0aW1pemUvVWdsaWZ5SnNQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDMyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJzb3VyY2UtbWFwXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS1jb3JlL2xpYi9zb3VyY2UtbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gd29ya2Fyb3VuZCBmb3IgdHR5IG91dHB1dCB0cnVuY2F0aW9uIHVwb24gcHJvY2Vzcy5leGl0KClcbltwcm9jZXNzLnN0ZG91dCwgcHJvY2Vzcy5zdGRlcnJdLmZvckVhY2goZnVuY3Rpb24oc3RyZWFtKXtcbiAgICBpZiAoc3RyZWFtLl9oYW5kbGUgJiYgc3RyZWFtLl9oYW5kbGUuc2V0QmxvY2tpbmcpXG4gICAgICAgIHN0cmVhbS5faGFuZGxlLnNldEJsb2NraW5nKHRydWUpO1xufSk7XG5cbnZhciBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG52YXIgZnMgPSByZXF1aXJlKFwiZnNcIik7XG5cbnZhciBGSUxFUyA9IGV4cG9ydHMuRklMRVMgPSBbXG4gICAgXCIuLi9saWIvdXRpbHMuanNcIixcbiAgICBcIi4uL2xpYi9hc3QuanNcIixcbiAgICBcIi4uL2xpYi9wYXJzZS5qc1wiLFxuICAgIFwiLi4vbGliL3RyYW5zZm9ybS5qc1wiLFxuICAgIFwiLi4vbGliL3Njb3BlLmpzXCIsXG4gICAgXCIuLi9saWIvb3V0cHV0LmpzXCIsXG4gICAgXCIuLi9saWIvY29tcHJlc3MuanNcIixcbiAgICBcIi4uL2xpYi9zb3VyY2VtYXAuanNcIixcbiAgICBcIi4uL2xpYi9tb3ppbGxhLWFzdC5qc1wiLFxuICAgIFwiLi4vbGliL3Byb3BtYW5nbGUuanNcIixcbiAgICBcIi4vZXhwb3J0cy5qc1wiLFxuXS5tYXAoZnVuY3Rpb24oZmlsZSl7XG4gICAgcmV0dXJuIGZzLnJlYWxwYXRoU3luYyhwYXRoLmpvaW4ocGF0aC5kaXJuYW1lKF9fZmlsZW5hbWUpLCBmaWxlKSk7XG59KTtcblxudmFyIFVnbGlmeUpTID0gZXhwb3J0cztcblxubmV3IEZ1bmN0aW9uKFwiTU9aX1NvdXJjZU1hcFwiLCBcImV4cG9ydHNcIiwgXCJERUJVR1wiLCBGSUxFUy5tYXAoZnVuY3Rpb24oZmlsZSl7XG4gICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhmaWxlLCBcInV0ZjhcIik7XG59KS5qb2luKFwiXFxuXFxuXCIpKShcbiAgICByZXF1aXJlKFwic291cmNlLW1hcFwiKSxcbiAgICBVZ2xpZnlKUyxcbiAgICAhIWdsb2JhbC5VR0xJRllfREVCVUdcbik7XG5cblVnbGlmeUpTLkFTVF9Ob2RlLndhcm5fZnVuY3Rpb24gPSBmdW5jdGlvbih0eHQpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiV0FSTjogJXNcIiwgdHh0KTtcbn07XG5cbmV4cG9ydHMubWluaWZ5ID0gZnVuY3Rpb24oZmlsZXMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gVWdsaWZ5SlMuZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICBzcGlkZXJtb25rZXkgICAgIDogZmFsc2UsXG4gICAgICAgIG91dFNvdXJjZU1hcCAgICAgOiBudWxsLFxuICAgICAgICBvdXRGaWxlTmFtZSAgICAgIDogbnVsbCxcbiAgICAgICAgc291cmNlUm9vdCAgICAgICA6IG51bGwsXG4gICAgICAgIGluU291cmNlTWFwICAgICAgOiBudWxsLFxuICAgICAgICBzb3VyY2VNYXBVcmwgICAgIDogbnVsbCxcbiAgICAgICAgc291cmNlTWFwSW5saW5lICA6IGZhbHNlLFxuICAgICAgICBmcm9tU3RyaW5nICAgICAgIDogZmFsc2UsXG4gICAgICAgIHdhcm5pbmdzICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgbWFuZ2xlICAgICAgICAgICA6IHt9LFxuICAgICAgICBtYW5nbGVQcm9wZXJ0aWVzIDogZmFsc2UsXG4gICAgICAgIG5hbWVDYWNoZSAgICAgICAgOiBudWxsLFxuICAgICAgICBvdXRwdXQgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgY29tcHJlc3MgICAgICAgICA6IHt9LFxuICAgICAgICBwYXJzZSAgICAgICAgICAgIDoge31cbiAgICB9KTtcbiAgICBVZ2xpZnlKUy5iYXNlNTQucmVzZXQoKTtcblxuICAgIC8vIDEuIHBhcnNlXG4gICAgdmFyIHRvcGxldmVsID0gbnVsbCxcbiAgICAgICAgc291cmNlc0NvbnRlbnQgPSB7fTtcblxuICAgIGlmIChvcHRpb25zLnNwaWRlcm1vbmtleSkge1xuICAgICAgICB0b3BsZXZlbCA9IFVnbGlmeUpTLkFTVF9Ob2RlLmZyb21fbW96aWxsYV9hc3QoZmlsZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bmN0aW9uIGFkZEZpbGUoZmlsZSwgZmlsZVVybCkge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBvcHRpb25zLmZyb21TdHJpbmdcbiAgICAgICAgICAgICAgICA/IGZpbGVcbiAgICAgICAgICAgICAgICA6IGZzLnJlYWRGaWxlU3luYyhmaWxlLCBcInV0ZjhcIik7XG4gICAgICAgICAgICBzb3VyY2VzQ29udGVudFtmaWxlVXJsXSA9IGNvZGU7XG4gICAgICAgICAgICB0b3BsZXZlbCA9IFVnbGlmeUpTLnBhcnNlKGNvZGUsIHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogZmlsZVVybCxcbiAgICAgICAgICAgICAgICB0b3BsZXZlbDogdG9wbGV2ZWwsXG4gICAgICAgICAgICAgICAgYmFyZV9yZXR1cm5zOiBvcHRpb25zLnBhcnNlID8gb3B0aW9ucy5wYXJzZS5iYXJlX3JldHVybnMgOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucy5mcm9tU3RyaW5nKSBmaWxlcyA9IFVnbGlmeUpTLnNpbXBsZV9nbG9iKGZpbGVzKTtcbiAgICAgICAgW10uY29uY2F0KGZpbGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlcywgaSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBhZGRGaWxlKGZpbGVzLCBvcHRpb25zLmZyb21TdHJpbmcgPyBpIDogZmlsZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBmaWxlVXJsIGluIGZpbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZEZpbGUoZmlsZXNbZmlsZVVybF0sIGZpbGVVcmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLndyYXApIHtcbiAgICAgIHRvcGxldmVsID0gdG9wbGV2ZWwud3JhcF9jb21tb25qcyhvcHRpb25zLndyYXAsIG9wdGlvbnMuZXhwb3J0QWxsKTtcbiAgICB9XG5cbiAgICAvLyAyLiBjb21wcmVzc1xuICAgIGlmIChvcHRpb25zLmNvbXByZXNzKSB7XG4gICAgICAgIHZhciBjb21wcmVzcyA9IHsgd2FybmluZ3M6IG9wdGlvbnMud2FybmluZ3MgfTtcbiAgICAgICAgVWdsaWZ5SlMubWVyZ2UoY29tcHJlc3MsIG9wdGlvbnMuY29tcHJlc3MpO1xuICAgICAgICB0b3BsZXZlbC5maWd1cmVfb3V0X3Njb3BlKCk7XG4gICAgICAgIHZhciBzcSA9IFVnbGlmeUpTLkNvbXByZXNzb3IoY29tcHJlc3MpO1xuICAgICAgICB0b3BsZXZlbCA9IHNxLmNvbXByZXNzKHRvcGxldmVsKTtcbiAgICB9XG5cbiAgICAvLyAzLiBtYW5nbGUgcHJvcGVydGllc1xuICAgIGlmIChvcHRpb25zLm1hbmdsZVByb3BlcnRpZXMgfHwgb3B0aW9ucy5uYW1lQ2FjaGUpIHtcbiAgICAgICAgb3B0aW9ucy5tYW5nbGVQcm9wZXJ0aWVzLmNhY2hlID0gVWdsaWZ5SlMucmVhZE5hbWVDYWNoZShvcHRpb25zLm5hbWVDYWNoZSwgXCJwcm9wc1wiKTtcbiAgICAgICAgdG9wbGV2ZWwgPSBVZ2xpZnlKUy5tYW5nbGVfcHJvcGVydGllcyh0b3BsZXZlbCwgb3B0aW9ucy5tYW5nbGVQcm9wZXJ0aWVzKTtcbiAgICAgICAgVWdsaWZ5SlMud3JpdGVOYW1lQ2FjaGUob3B0aW9ucy5uYW1lQ2FjaGUsIFwicHJvcHNcIiwgb3B0aW9ucy5tYW5nbGVQcm9wZXJ0aWVzLmNhY2hlKTtcbiAgICB9XG5cbiAgICAvLyA0LiBtYW5nbGVcbiAgICBpZiAob3B0aW9ucy5tYW5nbGUpIHtcbiAgICAgICAgdG9wbGV2ZWwuZmlndXJlX291dF9zY29wZShvcHRpb25zLm1hbmdsZSk7XG4gICAgICAgIHRvcGxldmVsLmNvbXB1dGVfY2hhcl9mcmVxdWVuY3kob3B0aW9ucy5tYW5nbGUpO1xuICAgICAgICB0b3BsZXZlbC5tYW5nbGVfbmFtZXMob3B0aW9ucy5tYW5nbGUpO1xuICAgIH1cblxuICAgIC8vIDUuIG91dHB1dFxuICAgIHZhciBpbk1hcCA9IG9wdGlvbnMuaW5Tb3VyY2VNYXA7XG4gICAgdmFyIG91dHB1dCA9IHt9O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5pblNvdXJjZU1hcCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGluTWFwID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMob3B0aW9ucy5pblNvdXJjZU1hcCwgXCJ1dGY4XCIpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMub3V0U291cmNlTWFwIHx8IG9wdGlvbnMuc291cmNlTWFwSW5saW5lKSB7XG4gICAgICAgIG91dHB1dC5zb3VyY2VfbWFwID0gVWdsaWZ5SlMuU291cmNlTWFwKHtcbiAgICAgICAgICAgIC8vIHByZWZlciBvdXRGaWxlTmFtZSwgb3RoZXJ3aXNlIHVzZSBvdXRTb3VyY2VNYXAgd2l0aG91dCAubWFwIHN1ZmZpeFxuICAgICAgICAgICAgZmlsZTogb3B0aW9ucy5vdXRGaWxlTmFtZSB8fCAodHlwZW9mIG9wdGlvbnMub3V0U291cmNlTWFwID09PSAnc3RyaW5nJyA/IG9wdGlvbnMub3V0U291cmNlTWFwLnJlcGxhY2UoL1xcLm1hcCQvaSwgJycpIDogbnVsbCksXG4gICAgICAgICAgICBvcmlnOiBpbk1hcCxcbiAgICAgICAgICAgIHJvb3Q6IG9wdGlvbnMuc291cmNlUm9vdFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc291cmNlTWFwSW5jbHVkZVNvdXJjZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGZpbGUgaW4gc291cmNlc0NvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlc0NvbnRlbnQuaGFzT3duUHJvcGVydHkoZmlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnNvdXJjZV9tYXAuZ2V0KCkuc2V0U291cmNlQ29udGVudChmaWxlLCBzb3VyY2VzQ29udGVudFtmaWxlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMub3V0cHV0KSB7XG4gICAgICAgIFVnbGlmeUpTLm1lcmdlKG91dHB1dCwgb3B0aW9ucy5vdXRwdXQpO1xuICAgIH1cbiAgICB2YXIgc3RyZWFtID0gVWdsaWZ5SlMuT3V0cHV0U3RyZWFtKG91dHB1dCk7XG4gICAgdG9wbGV2ZWwucHJpbnQoc3RyZWFtKTtcblxuXG4gICAgdmFyIHNvdXJjZV9tYXAgPSBvdXRwdXQuc291cmNlX21hcDtcbiAgICBpZiAoc291cmNlX21hcCkge1xuICAgICAgICBzb3VyY2VfbWFwID0gc291cmNlX21hcCArIFwiXCI7XG4gICAgfVxuXG4gICAgdmFyIG1hcHBpbmdVcmxQcmVmaXggPSBcIlxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVwiO1xuICAgIGlmIChvcHRpb25zLnNvdXJjZU1hcElubGluZSkge1xuICAgICAgICBzdHJlYW0gKz0gbWFwcGluZ1VybFByZWZpeCArIFwiZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiICsgbmV3IEJ1ZmZlcihzb3VyY2VfbWFwKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMub3V0U291cmNlTWFwICYmIHR5cGVvZiBvcHRpb25zLm91dFNvdXJjZU1hcCA9PT0gXCJzdHJpbmdcIiAmJiBvcHRpb25zLnNvdXJjZU1hcFVybCAhPT0gZmFsc2UpIHtcbiAgICAgICAgc3RyZWFtICs9IG1hcHBpbmdVcmxQcmVmaXggKyAodHlwZW9mIG9wdGlvbnMuc291cmNlTWFwVXJsID09PSBcInN0cmluZ1wiID8gb3B0aW9ucy5zb3VyY2VNYXBVcmwgOiBvcHRpb25zLm91dFNvdXJjZU1hcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29kZSA6IHN0cmVhbSArIFwiXCIsXG4gICAgICAgIG1hcCAgOiBzb3VyY2VfbWFwXG4gICAgfTtcbn07XG5cbi8vIGV4cG9ydHMuZGVzY3JpYmVfYXN0ID0gZnVuY3Rpb24oKSB7XG4vLyAgICAgZnVuY3Rpb24gZG9pdGVtKGN0b3IpIHtcbi8vICAgICAgICAgdmFyIHN1YiA9IHt9O1xuLy8gICAgICAgICBjdG9yLlNVQkNMQVNTRVMuZm9yRWFjaChmdW5jdGlvbihjdG9yKXtcbi8vICAgICAgICAgICAgIHN1YltjdG9yLlRZUEVdID0gZG9pdGVtKGN0b3IpO1xuLy8gICAgICAgICB9KTtcbi8vICAgICAgICAgdmFyIHJldCA9IHt9O1xuLy8gICAgICAgICBpZiAoY3Rvci5TRUxGX1BST1BTLmxlbmd0aCA+IDApIHJldC5wcm9wcyA9IGN0b3IuU0VMRl9QUk9QUztcbi8vICAgICAgICAgaWYgKGN0b3IuU1VCQ0xBU1NFUy5sZW5ndGggPiAwKSByZXQuc3ViID0gc3ViO1xuLy8gICAgICAgICByZXR1cm4gcmV0O1xuLy8gICAgIH1cbi8vICAgICByZXR1cm4gZG9pdGVtKFVnbGlmeUpTLkFTVF9Ob2RlKS5zdWI7XG4vLyB9XG5cbmV4cG9ydHMuZGVzY3JpYmVfYXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IFVnbGlmeUpTLk91dHB1dFN0cmVhbSh7IGJlYXV0aWZ5OiB0cnVlIH0pO1xuICAgIGZ1bmN0aW9uIGRvaXRlbShjdG9yKSB7XG4gICAgICAgIG91dC5wcmludChcIkFTVF9cIiArIGN0b3IuVFlQRSk7XG4gICAgICAgIHZhciBwcm9wcyA9IGN0b3IuU0VMRl9QUk9QUy5maWx0ZXIoZnVuY3Rpb24ocHJvcCl7XG4gICAgICAgICAgICByZXR1cm4gIS9eXFwkLy50ZXN0KHByb3ApO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByb3BzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG91dC5zcGFjZSgpO1xuICAgICAgICAgICAgb3V0LndpdGhfcGFyZW5zKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgcHJvcHMuZm9yRWFjaChmdW5jdGlvbihwcm9wLCBpKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkpIG91dC5zcGFjZSgpO1xuICAgICAgICAgICAgICAgICAgICBvdXQucHJpbnQocHJvcCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3Rvci5kb2N1bWVudGF0aW9uKSB7XG4gICAgICAgICAgICBvdXQuc3BhY2UoKTtcbiAgICAgICAgICAgIG91dC5wcmludF9zdHJpbmcoY3Rvci5kb2N1bWVudGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3Rvci5TVUJDTEFTU0VTLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG91dC5zcGFjZSgpO1xuICAgICAgICAgICAgb3V0LndpdGhfYmxvY2soZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBjdG9yLlNVQkNMQVNTRVMuZm9yRWFjaChmdW5jdGlvbihjdG9yLCBpKXtcbiAgICAgICAgICAgICAgICAgICAgb3V0LmluZGVudCgpO1xuICAgICAgICAgICAgICAgICAgICBkb2l0ZW0oY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIG91dC5uZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZG9pdGVtKFVnbGlmeUpTLkFTVF9Ob2RlKTtcbiAgICByZXR1cm4gb3V0ICsgXCJcIjtcbn07XG5cbmZ1bmN0aW9uIHJlYWRSZXNlcnZlZEZpbGUoZmlsZW5hbWUsIHJlc2VydmVkKSB7XG4gICAgaWYgKCFyZXNlcnZlZCkge1xuICAgICAgICByZXNlcnZlZCA9IHsgdmFyczogW10sIHByb3BzOiBbXSB9O1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IGZzLnJlYWRGaWxlU3luYyhmaWxlbmFtZSwgXCJ1dGY4XCIpO1xuICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgIGlmIChkYXRhLnZhcnMpIHtcbiAgICAgICAgZGF0YS52YXJzLmZvckVhY2goZnVuY3Rpb24obmFtZSl7XG4gICAgICAgICAgICBVZ2xpZnlKUy5wdXNoX3VuaXEocmVzZXJ2ZWQudmFycywgbmFtZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZGF0YS5wcm9wcykge1xuICAgICAgICBkYXRhLnByb3BzLmZvckVhY2goZnVuY3Rpb24obmFtZSl7XG4gICAgICAgICAgICBVZ2xpZnlKUy5wdXNoX3VuaXEocmVzZXJ2ZWQucHJvcHMsIG5hbWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc2VydmVkO1xufVxuXG5leHBvcnRzLnJlYWRSZXNlcnZlZEZpbGUgPSByZWFkUmVzZXJ2ZWRGaWxlO1xuXG5leHBvcnRzLnJlYWREZWZhdWx0UmVzZXJ2ZWRGaWxlID0gZnVuY3Rpb24ocmVzZXJ2ZWQpIHtcbiAgICByZXR1cm4gcmVhZFJlc2VydmVkRmlsZShwYXRoLmpvaW4oX19kaXJuYW1lLCBcImRvbXByb3BzLmpzb25cIiksIHJlc2VydmVkKTtcbn07XG5cbmV4cG9ydHMucmVhZE5hbWVDYWNoZSA9IGZ1bmN0aW9uKGZpbGVuYW1lLCBrZXkpIHtcbiAgICB2YXIgY2FjaGUgPSBudWxsO1xuICAgIGlmIChmaWxlbmFtZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGNhY2hlID0gZnMucmVhZEZpbGVTeW5jKGZpbGVuYW1lLCBcInV0ZjhcIik7XG4gICAgICAgICAgICBjYWNoZSA9IEpTT04ucGFyc2UoY2FjaGUpW2tleV07XG4gICAgICAgICAgICBpZiAoIWNhY2hlKSB0aHJvdyBcImluaXRcIjtcbiAgICAgICAgICAgIGNhY2hlLnByb3BzID0gVWdsaWZ5SlMuRGljdGlvbmFyeS5mcm9tT2JqZWN0KGNhY2hlLnByb3BzKTtcbiAgICAgICAgfSBjYXRjaChleCkge1xuICAgICAgICAgICAgY2FjaGUgPSB7XG4gICAgICAgICAgICAgICAgY25hbWU6IC0xLFxuICAgICAgICAgICAgICAgIHByb3BzOiBuZXcgVWdsaWZ5SlMuRGljdGlvbmFyeSgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYWNoZTtcbn07XG5cbmV4cG9ydHMud3JpdGVOYW1lQ2FjaGUgPSBmdW5jdGlvbihmaWxlbmFtZSwga2V5LCBjYWNoZSkge1xuICAgIGlmIChmaWxlbmFtZSkge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRhdGEgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZW5hbWUsIFwidXRmOFwiKTtcbiAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICB9IGNhdGNoKGV4KSB7XG4gICAgICAgICAgICBkYXRhID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtrZXldID0ge1xuICAgICAgICAgICAgY25hbWU6IGNhY2hlLmNuYW1lLFxuICAgICAgICAgICAgcHJvcHM6IGNhY2hlLnByb3BzLnRvT2JqZWN0KClcbiAgICAgICAgfTtcbiAgICAgICAgZnMud3JpdGVGaWxlU3luYyhmaWxlbmFtZSwgSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMiksIFwidXRmOFwiKTtcbiAgICB9XG59O1xuXG4vLyBBIGZpbGUgZ2xvYiBmdW5jdGlvbiB0aGF0IG9ubHkgc3VwcG9ydHMgXCIqXCIgYW5kIFwiP1wiIHdpbGRjYXJkcyBpbiB0aGUgYmFzZW5hbWUuXG4vLyBFeGFtcGxlOiBcImZvby9iYXIvKmJhej8/LiouanNcIlxuLy8gQXJndW1lbnQgYGdsb2JgIG1heSBiZSBhIHN0cmluZyBvciBhbiBhcnJheSBvZiBzdHJpbmdzLlxuLy8gUmV0dXJucyBhbiBhcnJheSBvZiBzdHJpbmdzLiBHYXJiYWdlIGluLCBnYXJiYWdlIG91dC5cbmV4cG9ydHMuc2ltcGxlX2dsb2IgPSBmdW5jdGlvbiBzaW1wbGVfZ2xvYihnbG9iKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShnbG9iKSkge1xuICAgICAgICBnbG9iLmZvckVhY2goZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KHNpbXBsZV9nbG9iKGVsZW0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBpZiAoZ2xvYi5tYXRjaCgvXFwqfFxcPy8pKSB7XG4gICAgICAgIHZhciBkaXIgPSBwYXRoLmRpcm5hbWUoZ2xvYik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgZW50cmllcyA9IGZzLnJlYWRkaXJTeW5jKGRpcik7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7fVxuICAgICAgICBpZiAoZW50cmllcykge1xuICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBcIl5cIiArIChwYXRoLmJhc2VuYW1lKGdsb2IpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKC9nLCBcIlxcXFwoXCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKS9nLCBcIlxcXFwpXCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcey9nLCBcIlxcXFx7XCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcfS9nLCBcIlxcXFx9XCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcWy9nLCBcIlxcXFxbXCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXS9nLCBcIlxcXFxdXCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKy9nLCBcIlxcXFwrXCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXi9nLCBcIlxcXFxeXCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcJC9nLCBcIlxcXFwkXCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKi9nLCBcIlteL1xcXFxcXFxcXSpcIilcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwuL2csIFwiXFxcXC5cIilcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFw/L2csIFwiLlwiKSkgKyBcIiRcIjtcbiAgICAgICAgICAgIHZhciBtb2QgPSBwcm9jZXNzLnBsYXRmb3JtID09PSBcIndpbjMyXCIgPyBcImlcIiA6IFwiXCI7XG4gICAgICAgICAgICB2YXIgcnggPSBuZXcgUmVnRXhwKHBhdHRlcm4sIG1vZCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocngudGVzdChlbnRyaWVzW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGRpciArIFwiL1wiICsgZW50cmllc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlc3VsdHMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXN1bHRzID0gWyBnbG9iIF07XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3VnbGlmeS1qcy90b29scy9ub2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbiAqIENvcHlyaWdodCAyMDA5LTIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLnR4dCBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbmV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2UtbWFwLWNvbnN1bWVyJykuU291cmNlTWFwQ29uc3VtZXI7XG5leHBvcnRzLlNvdXJjZU5vZGUgPSByZXF1aXJlKCcuL2xpYi9zb3VyY2Utbm9kZScpLlNvdXJjZU5vZGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdWdsaWZ5LWpzL34vc291cmNlLW1hcC9zb3VyY2UtbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgYmFzZTY0VkxRID0gcmVxdWlyZSgnLi9iYXNlNjQtdmxxJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbnZhciBNYXBwaW5nTGlzdCA9IHJlcXVpcmUoJy4vbWFwcGluZy1saXN0JykuTWFwcGluZ0xpc3Q7XG5cbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhlIFNvdXJjZU1hcEdlbmVyYXRvciByZXByZXNlbnRzIGEgc291cmNlIG1hcCB3aGljaCBpc1xuICogYmVpbmcgYnVpbHQgaW5jcmVtZW50YWxseS4gWW91IG1heSBwYXNzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGZpbGU6IFRoZSBmaWxlbmFtZSBvZiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqICAgLSBzb3VyY2VSb290OiBBIHJvb3QgZm9yIGFsbCByZWxhdGl2ZSBVUkxzIGluIHRoaXMgc291cmNlIG1hcC5cbiAqL1xuZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKSB7XG4gIGlmICghYUFyZ3MpIHtcbiAgICBhQXJncyA9IHt9O1xuICB9XG4gIHRoaXMuX2ZpbGUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2ZpbGUnLCBudWxsKTtcbiAgdGhpcy5fc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICB0aGlzLl9za2lwVmFsaWRhdGlvbiA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc2tpcFZhbGlkYXRpb24nLCBmYWxzZSk7XG4gIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbWFwcGluZ3MgPSBuZXcgTWFwcGluZ0xpc3QoKTtcbiAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbn1cblxuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IgYmFzZWQgb24gYSBTb3VyY2VNYXBDb25zdW1lclxuICpcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLmZyb21Tb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIpIHtcbiAgICB2YXIgc291cmNlUm9vdCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VSb290O1xuICAgIHZhciBnZW5lcmF0b3IgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKHtcbiAgICAgIGZpbGU6IGFTb3VyY2VNYXBDb25zdW1lci5maWxlLFxuICAgICAgc291cmNlUm9vdDogc291cmNlUm9vdFxuICAgIH0pO1xuICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgdmFyIG5ld01hcHBpbmcgPSB7XG4gICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIG5ld01hcHBpbmcuc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbmV3TWFwcGluZy5zb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3TWFwcGluZy5vcmlnaW5hbCA9IHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLm5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZ2VuZXJhdG9yLmFkZE1hcHBpbmcobmV3TWFwcGluZyk7XG4gICAgfSk7XG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgZ2VuZXJhdG9yLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfTtcblxuLyoqXG4gKiBBZGQgYSBzaW5nbGUgbWFwcGluZyBmcm9tIG9yaWdpbmFsIHNvdXJjZSBsaW5lIGFuZCBjb2x1bW4gdG8gdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIGZvciB0aGlzIHNvdXJjZSBtYXAgYmVpbmcgY3JlYXRlZC4gVGhlIG1hcHBpbmdcbiAqIG9iamVjdCBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGdlbmVyYXRlZDogQW4gb2JqZWN0IHdpdGggdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zLlxuICogICAtIG9yaWdpbmFsOiBBbiBvYmplY3Qgd2l0aCB0aGUgb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSAocmVsYXRpdmUgdG8gdGhlIHNvdXJjZVJvb3QpLlxuICogICAtIG5hbWU6IEFuIG9wdGlvbmFsIG9yaWdpbmFsIHRva2VuIG5hbWUgZm9yIHRoaXMgbWFwcGluZy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hZGRNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2FkZE1hcHBpbmcoYUFyZ3MpIHtcbiAgICB2YXIgZ2VuZXJhdGVkID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdnZW5lcmF0ZWQnKTtcbiAgICB2YXIgb3JpZ2luYWwgPSB1dGlsLmdldEFyZyhhQXJncywgJ29yaWdpbmFsJywgbnVsbCk7XG4gICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJywgbnVsbCk7XG4gICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhhQXJncywgJ25hbWUnLCBudWxsKTtcblxuICAgIGlmICghdGhpcy5fc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlTWFwcGluZyhnZW5lcmF0ZWQsIG9yaWdpbmFsLCBzb3VyY2UsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgc291cmNlID0gU3RyaW5nKHNvdXJjZSk7XG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgICAgaWYgKCF0aGlzLl9uYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX21hcHBpbmdzLmFkZCh7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogZ2VuZXJhdGVkLmNvbHVtbixcbiAgICAgIG9yaWdpbmFsTGluZTogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5saW5lLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwuY29sdW1uLFxuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBuYW1lOiBuYW1lXG4gICAgfSk7XG4gIH07XG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgdmFyIHNvdXJjZSA9IGFTb3VyY2VGaWxlO1xuICAgIGlmICh0aGlzLl9zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5fc291cmNlUm9vdCwgc291cmNlKTtcbiAgICB9XG5cbiAgICBpZiAoYVNvdXJjZUNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgY29udGVudCB0byB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgX3NvdXJjZXNDb250ZW50cyBtYXAgaWYgdGhlIHByb3BlcnR5IGlzIG51bGwuXG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoc291cmNlKV0gPSBhU291cmNlQ29udGVudDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBzb3VyY2UgZmlsZSBmcm9tIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgIC8vIElmIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcCBpcyBlbXB0eSwgc2V0IHRoZSBwcm9wZXJ0eSB0byBudWxsLlxuICAgICAgZGVsZXRlIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuX3NvdXJjZXNDb250ZW50cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIG1hcHBpbmdzIG9mIGEgc3ViLXNvdXJjZS1tYXAgZm9yIGEgc3BlY2lmaWMgc291cmNlIGZpbGUgdG8gdGhlXG4gKiBzb3VyY2UgbWFwIGJlaW5nIGdlbmVyYXRlZC4gRWFjaCBtYXBwaW5nIHRvIHRoZSBzdXBwbGllZCBzb3VyY2UgZmlsZSBpc1xuICogcmV3cml0dGVuIHVzaW5nIHRoZSBzdXBwbGllZCBzb3VyY2UgbWFwLiBOb3RlOiBUaGUgcmVzb2x1dGlvbiBmb3IgdGhlXG4gKiByZXN1bHRpbmcgbWFwcGluZ3MgaXMgdGhlIG1pbmltaXVtIG9mIHRoaXMgbWFwIGFuZCB0aGUgc3VwcGxpZWQgbWFwLlxuICpcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZC5cbiAqIEBwYXJhbSBhU291cmNlRmlsZSBPcHRpb25hbC4gVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZS5cbiAqICAgICAgICBJZiBvbWl0dGVkLCBTb3VyY2VNYXBDb25zdW1lcidzIGZpbGUgcHJvcGVydHkgd2lsbCBiZSB1c2VkLlxuICogQHBhcmFtIGFTb3VyY2VNYXBQYXRoIE9wdGlvbmFsLiBUaGUgZGlybmFtZSBvZiB0aGUgcGF0aCB0byB0aGUgc291cmNlIG1hcFxuICogICAgICAgIHRvIGJlIGFwcGxpZWQuIElmIHJlbGF0aXZlLCBpdCBpcyByZWxhdGl2ZSB0byB0aGUgU291cmNlTWFwQ29uc3VtZXIuXG4gKiAgICAgICAgVGhpcyBwYXJhbWV0ZXIgaXMgbmVlZGVkIHdoZW4gdGhlIHR3byBzb3VyY2UgbWFwcyBhcmVuJ3QgaW4gdGhlIHNhbWVcbiAqICAgICAgICBkaXJlY3RvcnksIGFuZCB0aGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkIGNvbnRhaW5zIHJlbGF0aXZlIHNvdXJjZVxuICogICAgICAgIHBhdGhzLiBJZiBzbywgdGhvc2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIG5lZWQgdG8gYmUgcmV3cml0dGVuXG4gKiAgICAgICAgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hcHBseVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIsIGFTb3VyY2VGaWxlLCBhU291cmNlTWFwUGF0aCkge1xuICAgIHZhciBzb3VyY2VGaWxlID0gYVNvdXJjZUZpbGU7XG4gICAgLy8gSWYgYVNvdXJjZUZpbGUgaXMgb21pdHRlZCwgd2Ugd2lsbCB1c2UgdGhlIGZpbGUgcHJvcGVydHkgb2YgdGhlIFNvdXJjZU1hcFxuICAgIGlmIChhU291cmNlRmlsZSA9PSBudWxsKSB7XG4gICAgICBpZiAoYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1NvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgcmVxdWlyZXMgZWl0aGVyIGFuIGV4cGxpY2l0IHNvdXJjZSBmaWxlLCAnICtcbiAgICAgICAgICAnb3IgdGhlIHNvdXJjZSBtYXBcXCdzIFwiZmlsZVwiIHByb3BlcnR5LiBCb3RoIHdlcmUgb21pdHRlZC4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBzb3VyY2VGaWxlID0gYVNvdXJjZU1hcENvbnN1bWVyLmZpbGU7XG4gICAgfVxuICAgIHZhciBzb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICAvLyBNYWtlIFwic291cmNlRmlsZVwiIHJlbGF0aXZlIGlmIGFuIGFic29sdXRlIFVybCBpcyBwYXNzZWQuXG4gICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgc291cmNlRmlsZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgfVxuICAgIC8vIEFwcGx5aW5nIHRoZSBTb3VyY2VNYXAgY2FuIGFkZCBhbmQgcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIHNvdXJjZXMgYW5kXG4gICAgLy8gdGhlIG5hbWVzIGFycmF5LlxuICAgIHZhciBuZXdTb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgdmFyIG5ld05hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgICAvLyBGaW5kIG1hcHBpbmdzIGZvciB0aGUgXCJzb3VyY2VGaWxlXCJcbiAgICB0aGlzLl9tYXBwaW5ncy51bnNvcnRlZEZvckVhY2goZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gc291cmNlRmlsZSAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGl0IGNhbiBiZSBtYXBwZWQgYnkgdGhlIHNvdXJjZSBtYXAsIHRoZW4gdXBkYXRlIHRoZSBtYXBwaW5nLlxuICAgICAgICB2YXIgb3JpZ2luYWwgPSBhU291cmNlTWFwQ29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3JpZ2luYWwuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDb3B5IG1hcHBpbmdcbiAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9IG9yaWdpbmFsLmxpbmU7XG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgICAgICBpZiAob3JpZ2luYWwubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgIW5ld1NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgbmV3U291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICBpZiAobmFtZSAhPSBudWxsICYmICFuZXdOYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgbmV3TmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuXG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5fc291cmNlcyA9IG5ld1NvdXJjZXM7XG4gICAgdGhpcy5fbmFtZXMgPSBuZXdOYW1lcztcblxuICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnRzIG9mIGFwcGxpZWQgbWFwLlxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhU291cmNlTWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfTtcblxuLyoqXG4gKiBBIG1hcHBpbmcgY2FuIGhhdmUgb25lIG9mIHRoZSB0aHJlZSBsZXZlbHMgb2YgZGF0YTpcbiAqXG4gKiAgIDEuIEp1c3QgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbi5cbiAqICAgMi4gVGhlIEdlbmVyYXRlZCBwb3NpdGlvbiwgb3JpZ2luYWwgcG9zaXRpb24sIGFuZCBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIDMuIEdlbmVyYXRlZCBhbmQgb3JpZ2luYWwgcG9zaXRpb24sIG9yaWdpbmFsIHNvdXJjZSwgYXMgd2VsbCBhcyBhIG5hbWVcbiAqICAgICAgdG9rZW4uXG4gKlxuICogVG8gbWFpbnRhaW4gY29uc2lzdGVuY3ksIHdlIHZhbGlkYXRlIHRoYXQgYW55IG5ldyBtYXBwaW5nIGJlaW5nIGFkZGVkIGZhbGxzXG4gKiBpbiB0byBvbmUgb2YgdGhlc2UgY2F0ZWdvcmllcy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGVNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3ZhbGlkYXRlTWFwcGluZyhhR2VuZXJhdGVkLCBhT3JpZ2luYWwsIGFTb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYU5hbWUpIHtcbiAgICBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAmJiAhYU9yaWdpbmFsICYmICFhU291cmNlICYmICFhTmFtZSkge1xuICAgICAgLy8gQ2FzZSAxLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgICAgICAmJiBhT3JpZ2luYWwgJiYgJ2xpbmUnIGluIGFPcmlnaW5hbCAmJiAnY29sdW1uJyBpbiBhT3JpZ2luYWxcbiAgICAgICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgICAgICAmJiBhT3JpZ2luYWwubGluZSA+IDAgJiYgYU9yaWdpbmFsLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgJiYgYVNvdXJjZSkge1xuICAgICAgLy8gQ2FzZXMgMiBhbmQgMy5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWFwcGluZzogJyArIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgZ2VuZXJhdGVkOiBhR2VuZXJhdGVkLFxuICAgICAgICBzb3VyY2U6IGFTb3VyY2UsXG4gICAgICAgIG9yaWdpbmFsOiBhT3JpZ2luYWwsXG4gICAgICAgIG5hbWU6IGFOYW1lXG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gdG8gdGhlIHN0cmVhbSBvZiBiYXNlIDY0IFZMUXNcbiAqIHNwZWNpZmllZCBieSB0aGUgc291cmNlIG1hcCBmb3JtYXQuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3NlcmlhbGl6ZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NlcmlhbGl6ZU1hcHBpbmdzKCkge1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkTGluZSA9IDE7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzTmFtZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIG5leHQ7XG4gICAgdmFyIG1hcHBpbmc7XG4gICAgdmFyIG5hbWVJZHg7XG4gICAgdmFyIHNvdXJjZUlkeDtcblxuICAgIHZhciBtYXBwaW5ncyA9IHRoaXMuX21hcHBpbmdzLnRvQXJyYXkoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG1hcHBpbmcgPSBtYXBwaW5nc1tpXTtcbiAgICAgIG5leHQgPSAnJ1xuXG4gICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICB3aGlsZSAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBuZXh0ICs9ICc7JztcbiAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZExpbmUrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIGlmICghdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nLCBtYXBwaW5nc1tpIC0gMV0pKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dCArPSAnLCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZUlkeCA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShzb3VyY2VJZHggLSBwcmV2aW91c1NvdXJjZSk7XG4gICAgICAgIHByZXZpb3VzU291cmNlID0gc291cmNlSWR4O1xuXG4gICAgICAgIC8vIGxpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZCBpbiBTb3VyY2VNYXAgc3BlYyB2ZXJzaW9uIDNcbiAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxMaW5lKTtcbiAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDE7XG5cbiAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c09yaWdpbmFsQ29sdW1uKTtcbiAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgaWYgKG1hcHBpbmcubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmFtZUlkeCA9IHRoaXMuX25hbWVzLmluZGV4T2YobWFwcGluZy5uYW1lKTtcbiAgICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobmFtZUlkeCAtIHByZXZpb3VzTmFtZSk7XG4gICAgICAgICAgcHJldmlvdXNOYW1lID0gbmFtZUlkeDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXN1bHQgKz0gbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoYVNvdXJjZXMsIGFTb3VyY2VSb290KSB7XG4gICAgcmV0dXJuIGFTb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChhU291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUoYVNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdXRpbC50b1NldFN0cmluZyhzb3VyY2UpO1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9zb3VyY2VzQ29udGVudHMsIGtleSlcbiAgICAgICAgPyB0aGlzLl9zb3VyY2VzQ29udGVudHNba2V5XVxuICAgICAgICA6IG51bGw7XG4gICAgfSwgdGhpcyk7XG4gIH07XG5cbi8qKlxuICogRXh0ZXJuYWxpemUgdGhlIHNvdXJjZSBtYXAuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9KU09OID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvSlNPTigpIHtcbiAgICB2YXIgbWFwID0ge1xuICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcbiAgICAgIHNvdXJjZXM6IHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLFxuICAgICAgbmFtZXM6IHRoaXMuX25hbWVzLnRvQXJyYXkoKSxcbiAgICAgIG1hcHBpbmdzOiB0aGlzLl9zZXJpYWxpemVNYXBwaW5ncygpXG4gICAgfTtcbiAgICBpZiAodGhpcy5fZmlsZSAhPSBudWxsKSB7XG4gICAgICBtYXAuZmlsZSA9IHRoaXMuX2ZpbGU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIG1hcC5zb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgbWFwLnNvdXJjZXNDb250ZW50ID0gdGhpcy5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChtYXAuc291cmNlcywgbWFwLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXA7XG4gIH07XG5cbi8qKlxuICogUmVuZGVyIHRoZSBzb3VyY2UgbWFwIGJlaW5nIGdlbmVyYXRlZCB0byBhIHN0cmluZy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b1N0cmluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b1N0cmluZygpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSk7XG4gIH07XG5cbmV4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yID0gU291cmNlTWFwR2VuZXJhdG9yO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3VnbGlmeS1qcy9+L3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAtZ2VuZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAzMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqXG4gKiBCYXNlZCBvbiB0aGUgQmFzZSA2NCBWTFEgaW1wbGVtZW50YXRpb24gaW4gQ2xvc3VyZSBDb21waWxlcjpcbiAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2xvc3VyZS1jb21waWxlci9zb3VyY2UvYnJvd3NlL3RydW5rL3NyYy9jb20vZ29vZ2xlL2RlYnVnZ2luZy9zb3VyY2VtYXAvQmFzZTY0VkxRLmphdmFcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSBUaGUgQ2xvc3VyZSBDb21waWxlciBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4gKiBtZXQ6XG4gKlxuICogICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAqICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gKiAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcbiAqICAgIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbiAqICAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZFxuICogICAgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAqIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICogQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbiAqIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuICogU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4gKiBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbiAqIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuICogT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnLi9iYXNlNjQnKTtcblxuLy8gQSBzaW5nbGUgYmFzZSA2NCBkaWdpdCBjYW4gY29udGFpbiA2IGJpdHMgb2YgZGF0YS4gRm9yIHRoZSBiYXNlIDY0IHZhcmlhYmxlXG4vLyBsZW5ndGggcXVhbnRpdGllcyB3ZSB1c2UgaW4gdGhlIHNvdXJjZSBtYXAgc3BlYywgdGhlIGZpcnN0IGJpdCBpcyB0aGUgc2lnbixcbi8vIHRoZSBuZXh0IGZvdXIgYml0cyBhcmUgdGhlIGFjdHVhbCB2YWx1ZSwgYW5kIHRoZSA2dGggYml0IGlzIHRoZVxuLy8gY29udGludWF0aW9uIGJpdC4gVGhlIGNvbnRpbnVhdGlvbiBiaXQgdGVsbHMgdXMgd2hldGhlciB0aGVyZSBhcmUgbW9yZVxuLy8gZGlnaXRzIGluIHRoaXMgdmFsdWUgZm9sbG93aW5nIHRoaXMgZGlnaXQuXG4vL1xuLy8gICBDb250aW51YXRpb25cbi8vICAgfCAgICBTaWduXG4vLyAgIHwgICAgfFxuLy8gICBWICAgIFZcbi8vICAgMTAxMDExXG5cbnZhciBWTFFfQkFTRV9TSElGVCA9IDU7XG5cbi8vIGJpbmFyeTogMTAwMDAwXG52YXIgVkxRX0JBU0UgPSAxIDw8IFZMUV9CQVNFX1NISUZUO1xuXG4vLyBiaW5hcnk6IDAxMTExMVxudmFyIFZMUV9CQVNFX01BU0sgPSBWTFFfQkFTRSAtIDE7XG5cbi8vIGJpbmFyeTogMTAwMDAwXG52YXIgVkxRX0NPTlRJTlVBVElPTl9CSVQgPSBWTFFfQkFTRTtcblxuLyoqXG4gKiBDb252ZXJ0cyBmcm9tIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgdG8gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICogICAxIGJlY29tZXMgMiAoMTAgYmluYXJ5KSwgLTEgYmVjb21lcyAzICgxMSBiaW5hcnkpXG4gKiAgIDIgYmVjb21lcyA0ICgxMDAgYmluYXJ5KSwgLTIgYmVjb21lcyA1ICgxMDEgYmluYXJ5KVxuICovXG5mdW5jdGlvbiB0b1ZMUVNpZ25lZChhVmFsdWUpIHtcbiAgcmV0dXJuIGFWYWx1ZSA8IDBcbiAgICA/ICgoLWFWYWx1ZSkgPDwgMSkgKyAxXG4gICAgOiAoYVZhbHVlIDw8IDEpICsgMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0byBhIHR3by1jb21wbGVtZW50IHZhbHVlIGZyb20gYSB2YWx1ZSB3aGVyZSB0aGUgc2lnbiBiaXQgaXNcbiAqIHBsYWNlZCBpbiB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0LiAgRm9yIGV4YW1wbGUsIGFzIGRlY2ltYWxzOlxuICogICAyICgxMCBiaW5hcnkpIGJlY29tZXMgMSwgMyAoMTEgYmluYXJ5KSBiZWNvbWVzIC0xXG4gKiAgIDQgKDEwMCBiaW5hcnkpIGJlY29tZXMgMiwgNSAoMTAxIGJpbmFyeSkgYmVjb21lcyAtMlxuICovXG5mdW5jdGlvbiBmcm9tVkxRU2lnbmVkKGFWYWx1ZSkge1xuICB2YXIgaXNOZWdhdGl2ZSA9IChhVmFsdWUgJiAxKSA9PT0gMTtcbiAgdmFyIHNoaWZ0ZWQgPSBhVmFsdWUgPj4gMTtcbiAgcmV0dXJuIGlzTmVnYXRpdmVcbiAgICA/IC1zaGlmdGVkXG4gICAgOiBzaGlmdGVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGJhc2UgNjQgVkxRIGVuY29kZWQgdmFsdWUuXG4gKi9cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2VuY29kZShhVmFsdWUpIHtcbiAgdmFyIGVuY29kZWQgPSBcIlwiO1xuICB2YXIgZGlnaXQ7XG5cbiAgdmFyIHZscSA9IHRvVkxRU2lnbmVkKGFWYWx1ZSk7XG5cbiAgZG8ge1xuICAgIGRpZ2l0ID0gdmxxICYgVkxRX0JBU0VfTUFTSztcbiAgICB2bHEgPj4+PSBWTFFfQkFTRV9TSElGVDtcbiAgICBpZiAodmxxID4gMCkge1xuICAgICAgLy8gVGhlcmUgYXJlIHN0aWxsIG1vcmUgZGlnaXRzIGluIHRoaXMgdmFsdWUsIHNvIHdlIG11c3QgbWFrZSBzdXJlIHRoZVxuICAgICAgLy8gY29udGludWF0aW9uIGJpdCBpcyBtYXJrZWQuXG4gICAgICBkaWdpdCB8PSBWTFFfQ09OVElOVUFUSU9OX0JJVDtcbiAgICB9XG4gICAgZW5jb2RlZCArPSBiYXNlNjQuZW5jb2RlKGRpZ2l0KTtcbiAgfSB3aGlsZSAodmxxID4gMCk7XG5cbiAgcmV0dXJuIGVuY29kZWQ7XG59O1xuXG4vKipcbiAqIERlY29kZXMgdGhlIG5leHQgYmFzZSA2NCBWTFEgdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nIGFuZCByZXR1cm5zIHRoZVxuICogdmFsdWUgYW5kIHRoZSByZXN0IG9mIHRoZSBzdHJpbmcgdmlhIHRoZSBvdXQgcGFyYW1ldGVyLlxuICovXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9kZWNvZGUoYVN0ciwgYUluZGV4LCBhT3V0UGFyYW0pIHtcbiAgdmFyIHN0ckxlbiA9IGFTdHIubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gMDtcbiAgdmFyIHNoaWZ0ID0gMDtcbiAgdmFyIGNvbnRpbnVhdGlvbiwgZGlnaXQ7XG5cbiAgZG8ge1xuICAgIGlmIChhSW5kZXggPj0gc3RyTGVuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBtb3JlIGRpZ2l0cyBpbiBiYXNlIDY0IFZMUSB2YWx1ZS5cIik7XG4gICAgfVxuXG4gICAgZGlnaXQgPSBiYXNlNjQuZGVjb2RlKGFTdHIuY2hhckNvZGVBdChhSW5kZXgrKykpO1xuICAgIGlmIChkaWdpdCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTY0IGRpZ2l0OiBcIiArIGFTdHIuY2hhckF0KGFJbmRleCAtIDEpKTtcbiAgICB9XG5cbiAgICBjb250aW51YXRpb24gPSAhIShkaWdpdCAmIFZMUV9DT05USU5VQVRJT05fQklUKTtcbiAgICBkaWdpdCAmPSBWTFFfQkFTRV9NQVNLO1xuICAgIHJlc3VsdCA9IHJlc3VsdCArIChkaWdpdCA8PCBzaGlmdCk7XG4gICAgc2hpZnQgKz0gVkxRX0JBU0VfU0hJRlQ7XG4gIH0gd2hpbGUgKGNvbnRpbnVhdGlvbik7XG5cbiAgYU91dFBhcmFtLnZhbHVlID0gZnJvbVZMUVNpZ25lZChyZXN1bHQpO1xuICBhT3V0UGFyYW0ucmVzdCA9IGFJbmRleDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdWdsaWZ5LWpzL34vc291cmNlLW1hcC9saWIvYmFzZTY0LXZscS5qc1xuLy8gbW9kdWxlIGlkID0gMzI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIGludFRvQ2hhck1hcCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJy5zcGxpdCgnJyk7XG5cbi8qKlxuICogRW5jb2RlIGFuIGludGVnZXIgaW4gdGhlIHJhbmdlIG9mIDAgdG8gNjMgdG8gYSBzaW5nbGUgYmFzZSA2NCBkaWdpdC5cbiAqL1xuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gIGlmICgwIDw9IG51bWJlciAmJiBudW1iZXIgPCBpbnRUb0NoYXJNYXAubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGludFRvQ2hhck1hcFtudW1iZXJdO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJNdXN0IGJlIGJldHdlZW4gMCBhbmQgNjM6IFwiICsgbnVtYmVyKTtcbn07XG5cbi8qKlxuICogRGVjb2RlIGEgc2luZ2xlIGJhc2UgNjQgY2hhcmFjdGVyIGNvZGUgZGlnaXQgdG8gYW4gaW50ZWdlci4gUmV0dXJucyAtMSBvblxuICogZmFpbHVyZS5cbiAqL1xuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiAoY2hhckNvZGUpIHtcbiAgdmFyIGJpZ0EgPSA2NTsgICAgIC8vICdBJ1xuICB2YXIgYmlnWiA9IDkwOyAgICAgLy8gJ1onXG5cbiAgdmFyIGxpdHRsZUEgPSA5NzsgIC8vICdhJ1xuICB2YXIgbGl0dGxlWiA9IDEyMjsgLy8gJ3onXG5cbiAgdmFyIHplcm8gPSA0ODsgICAgIC8vICcwJ1xuICB2YXIgbmluZSA9IDU3OyAgICAgLy8gJzknXG5cbiAgdmFyIHBsdXMgPSA0MzsgICAgIC8vICcrJ1xuICB2YXIgc2xhc2ggPSA0NzsgICAgLy8gJy8nXG5cbiAgdmFyIGxpdHRsZU9mZnNldCA9IDI2O1xuICB2YXIgbnVtYmVyT2Zmc2V0ID0gNTI7XG5cbiAgLy8gMCAtIDI1OiBBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlxuICBpZiAoYmlnQSA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBiaWdaKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIGJpZ0EpO1xuICB9XG5cbiAgLy8gMjYgLSA1MTogYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcbiAgaWYgKGxpdHRsZUEgPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gbGl0dGxlWikge1xuICAgIHJldHVybiAoY2hhckNvZGUgLSBsaXR0bGVBICsgbGl0dGxlT2Zmc2V0KTtcbiAgfVxuXG4gIC8vIDUyIC0gNjE6IDAxMjM0NTY3ODlcbiAgaWYgKHplcm8gPD0gY2hhckNvZGUgJiYgY2hhckNvZGUgPD0gbmluZSkge1xuICAgIHJldHVybiAoY2hhckNvZGUgLSB6ZXJvICsgbnVtYmVyT2Zmc2V0KTtcbiAgfVxuXG4gIC8vIDYyOiArXG4gIGlmIChjaGFyQ29kZSA9PSBwbHVzKSB7XG4gICAgcmV0dXJuIDYyO1xuICB9XG5cbiAgLy8gNjM6IC9cbiAgaWYgKGNoYXJDb2RlID09IHNsYXNoKSB7XG4gICAgcmV0dXJuIDYzO1xuICB9XG5cbiAgLy8gSW52YWxpZCBiYXNlNjQgZGlnaXQuXG4gIHJldHVybiAtMTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdWdsaWZ5LWpzL34vc291cmNlLW1hcC9saWIvYmFzZTY0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG4vKipcbiAqIFRoaXMgaXMgYSBoZWxwZXIgZnVuY3Rpb24gZm9yIGdldHRpbmcgdmFsdWVzIGZyb20gcGFyYW1ldGVyL29wdGlvbnNcbiAqIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIGFyZ3MgVGhlIG9iamVjdCB3ZSBhcmUgZXh0cmFjdGluZyB2YWx1ZXMgZnJvbVxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdlIGFyZSBnZXR0aW5nLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBBbiBvcHRpb25hbCB2YWx1ZSB0byByZXR1cm4gaWYgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmdcbiAqIGZyb20gdGhlIG9iamVjdC4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkIGFuZCB0aGUgcHJvcGVydHkgaXMgbWlzc2luZywgYW5cbiAqIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICovXG5mdW5jdGlvbiBnZXRBcmcoYUFyZ3MsIGFOYW1lLCBhRGVmYXVsdFZhbHVlKSB7XG4gIGlmIChhTmFtZSBpbiBhQXJncykge1xuICAgIHJldHVybiBhQXJnc1thTmFtZV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHJldHVybiBhRGVmYXVsdFZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYU5hbWUgKyAnXCIgaXMgYSByZXF1aXJlZCBhcmd1bWVudC4nKTtcbiAgfVxufVxuZXhwb3J0cy5nZXRBcmcgPSBnZXRBcmc7XG5cbnZhciB1cmxSZWdleHAgPSAvXig/OihbXFx3K1xcLS5dKyk6KT9cXC9cXC8oPzooXFx3KzpcXHcrKUApPyhbXFx3Ll0qKSg/OjooXFxkKykpPyhcXFMqKSQvO1xudmFyIGRhdGFVcmxSZWdleHAgPSAvXmRhdGE6LitcXCwuKyQvO1xuXG5mdW5jdGlvbiB1cmxQYXJzZShhVXJsKSB7XG4gIHZhciBtYXRjaCA9IGFVcmwubWF0Y2godXJsUmVnZXhwKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgc2NoZW1lOiBtYXRjaFsxXSxcbiAgICBhdXRoOiBtYXRjaFsyXSxcbiAgICBob3N0OiBtYXRjaFszXSxcbiAgICBwb3J0OiBtYXRjaFs0XSxcbiAgICBwYXRoOiBtYXRjaFs1XVxuICB9O1xufVxuZXhwb3J0cy51cmxQYXJzZSA9IHVybFBhcnNlO1xuXG5mdW5jdGlvbiB1cmxHZW5lcmF0ZShhUGFyc2VkVXJsKSB7XG4gIHZhciB1cmwgPSAnJztcbiAgaWYgKGFQYXJzZWRVcmwuc2NoZW1lKSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwuc2NoZW1lICsgJzonO1xuICB9XG4gIHVybCArPSAnLy8nO1xuICBpZiAoYVBhcnNlZFVybC5hdXRoKSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwuYXV0aCArICdAJztcbiAgfVxuICBpZiAoYVBhcnNlZFVybC5ob3N0KSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwuaG9zdDtcbiAgfVxuICBpZiAoYVBhcnNlZFVybC5wb3J0KSB7XG4gICAgdXJsICs9IFwiOlwiICsgYVBhcnNlZFVybC5wb3J0XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwucGF0aCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLnBhdGg7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cbmV4cG9ydHMudXJsR2VuZXJhdGUgPSB1cmxHZW5lcmF0ZTtcblxuLyoqXG4gKiBOb3JtYWxpemVzIGEgcGF0aCwgb3IgdGhlIHBhdGggcG9ydGlvbiBvZiBhIFVSTDpcbiAqXG4gKiAtIFJlcGxhY2VzIGNvbnNlY3V0aXZlIHNsYXNoZXMgd2l0aCBvbmUgc2xhc2guXG4gKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJy4nIHBhcnRzLlxuICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICc8ZGlyPi8uLicgcGFydHMuXG4gKlxuICogQmFzZWQgb24gY29kZSBpbiB0aGUgTm9kZS5qcyAncGF0aCcgY29yZSBtb2R1bGUuXG4gKlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIHVybCB0byBub3JtYWxpemUuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShhUGF0aCkge1xuICB2YXIgcGF0aCA9IGFQYXRoO1xuICB2YXIgdXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICBpZiAodXJsKSB7XG4gICAgaWYgKCF1cmwucGF0aCkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cbiAgICBwYXRoID0gdXJsLnBhdGg7XG4gIH1cbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCk7XG5cbiAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgvXFwvKy8pO1xuICBmb3IgKHZhciBwYXJ0LCB1cCA9IDAsIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXAgPiAwKSB7XG4gICAgICBpZiAocGFydCA9PT0gJycpIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHBhcnQgaXMgYmxhbmsgaWYgdGhlIHBhdGggaXMgYWJzb2x1dGUuIFRyeWluZyB0byBnb1xuICAgICAgICAvLyBhYm92ZSB0aGUgcm9vdCBpcyBhIG5vLW9wLiBUaGVyZWZvcmUgd2UgY2FuIHJlbW92ZSBhbGwgJy4uJyBwYXJ0c1xuICAgICAgICAvLyBkaXJlY3RseSBhZnRlciB0aGUgcm9vdC5cbiAgICAgICAgcGFydHMuc3BsaWNlKGkgKyAxLCB1cCk7XG4gICAgICAgIHVwID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzLnNwbGljZShpLCAyKTtcbiAgICAgICAgdXAtLTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGF0aCA9IHBhcnRzLmpvaW4oJy8nKTtcblxuICBpZiAocGF0aCA9PT0gJycpIHtcbiAgICBwYXRoID0gaXNBYnNvbHV0ZSA/ICcvJyA6ICcuJztcbiAgfVxuXG4gIGlmICh1cmwpIHtcbiAgICB1cmwucGF0aCA9IHBhdGg7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKHVybCk7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcblxuLyoqXG4gKiBKb2lucyB0d28gcGF0aHMvVVJMcy5cbiAqXG4gKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIGpvaW5lZCB3aXRoIHRoZSByb290LlxuICpcbiAqIC0gSWYgYVBhdGggaXMgYSBVUkwgb3IgYSBkYXRhIFVSSSwgYVBhdGggaXMgcmV0dXJuZWQsIHVubGVzcyBhUGF0aCBpcyBhXG4gKiAgIHNjaGVtZS1yZWxhdGl2ZSBVUkw6IFRoZW4gdGhlIHNjaGVtZSBvZiBhUm9vdCwgaWYgYW55LCBpcyBwcmVwZW5kZWRcbiAqICAgZmlyc3QuXG4gKiAtIE90aGVyd2lzZSBhUGF0aCBpcyBhIHBhdGguIElmIGFSb290IGlzIGEgVVJMLCB0aGVuIGl0cyBwYXRoIHBvcnRpb25cbiAqICAgaXMgdXBkYXRlZCB3aXRoIHRoZSByZXN1bHQgYW5kIGFSb290IGlzIHJldHVybmVkLiBPdGhlcndpc2UgdGhlIHJlc3VsdFxuICogICBpcyByZXR1cm5lZC5cbiAqICAgLSBJZiBhUGF0aCBpcyBhYnNvbHV0ZSwgdGhlIHJlc3VsdCBpcyBhUGF0aC5cbiAqICAgLSBPdGhlcndpc2UgdGhlIHR3byBwYXRocyBhcmUgam9pbmVkIHdpdGggYSBzbGFzaC5cbiAqIC0gSm9pbmluZyBmb3IgZXhhbXBsZSAnaHR0cDovLycgYW5kICd3d3cuZXhhbXBsZS5jb20nIGlzIGFsc28gc3VwcG9ydGVkLlxuICovXG5mdW5jdGlvbiBqb2luKGFSb290LCBhUGF0aCkge1xuICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICBhUm9vdCA9IFwiLlwiO1xuICB9XG4gIGlmIChhUGF0aCA9PT0gXCJcIikge1xuICAgIGFQYXRoID0gXCIuXCI7XG4gIH1cbiAgdmFyIGFQYXRoVXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICB2YXIgYVJvb3RVcmwgPSB1cmxQYXJzZShhUm9vdCk7XG4gIGlmIChhUm9vdFVybCkge1xuICAgIGFSb290ID0gYVJvb3RVcmwucGF0aCB8fCAnLyc7XG4gIH1cblxuICAvLyBgam9pbihmb28sICcvL3d3dy5leGFtcGxlLm9yZycpYFxuICBpZiAoYVBhdGhVcmwgJiYgIWFQYXRoVXJsLnNjaGVtZSkge1xuICAgIGlmIChhUm9vdFVybCkge1xuICAgICAgYVBhdGhVcmwuc2NoZW1lID0gYVJvb3RVcmwuc2NoZW1lO1xuICAgIH1cbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVBhdGhVcmwpO1xuICB9XG5cbiAgaWYgKGFQYXRoVXJsIHx8IGFQYXRoLm1hdGNoKGRhdGFVcmxSZWdleHApKSB7XG4gICAgcmV0dXJuIGFQYXRoO1xuICB9XG5cbiAgLy8gYGpvaW4oJ2h0dHA6Ly8nLCAnd3d3LmV4YW1wbGUuY29tJylgXG4gIGlmIChhUm9vdFVybCAmJiAhYVJvb3RVcmwuaG9zdCAmJiAhYVJvb3RVcmwucGF0aCkge1xuICAgIGFSb290VXJsLmhvc3QgPSBhUGF0aDtcbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICB9XG5cbiAgdmFyIGpvaW5lZCA9IGFQYXRoLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgPyBhUGF0aFxuICAgIDogbm9ybWFsaXplKGFSb290LnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgYVBhdGgpO1xuXG4gIGlmIChhUm9vdFVybCkge1xuICAgIGFSb290VXJsLnBhdGggPSBqb2luZWQ7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgfVxuICByZXR1cm4gam9pbmVkO1xufVxuZXhwb3J0cy5qb2luID0gam9pbjtcblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24gKGFQYXRoKSB7XG4gIHJldHVybiBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJyB8fCAhIWFQYXRoLm1hdGNoKHVybFJlZ2V4cCk7XG59O1xuXG4vKipcbiAqIE1ha2UgYSBwYXRoIHJlbGF0aXZlIHRvIGEgVVJMIG9yIGFub3RoZXIgcGF0aC5cbiAqXG4gKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIG1hZGUgcmVsYXRpdmUgdG8gYVJvb3QuXG4gKi9cbmZ1bmN0aW9uIHJlbGF0aXZlKGFSb290LCBhUGF0aCkge1xuICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICBhUm9vdCA9IFwiLlwiO1xuICB9XG5cbiAgYVJvb3QgPSBhUm9vdC5yZXBsYWNlKC9cXC8kLywgJycpO1xuXG4gIC8vIEl0IGlzIHBvc3NpYmxlIGZvciB0aGUgcGF0aCB0byBiZSBhYm92ZSB0aGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBzaW1wbHlcbiAgLy8gY2hlY2tpbmcgd2hldGhlciB0aGUgcm9vdCBpcyBhIHByZWZpeCBvZiB0aGUgcGF0aCB3b24ndCB3b3JrLiBJbnN0ZWFkLCB3ZVxuICAvLyBuZWVkIHRvIHJlbW92ZSBjb21wb25lbnRzIGZyb20gdGhlIHJvb3Qgb25lIGJ5IG9uZSwgdW50aWwgZWl0aGVyIHdlIGZpbmRcbiAgLy8gYSBwcmVmaXggdGhhdCBmaXRzLCBvciB3ZSBydW4gb3V0IG9mIGNvbXBvbmVudHMgdG8gcmVtb3ZlLlxuICB2YXIgbGV2ZWwgPSAwO1xuICB3aGlsZSAoYVBhdGguaW5kZXhPZihhUm9vdCArICcvJykgIT09IDApIHtcbiAgICB2YXIgaW5kZXggPSBhUm9vdC5sYXN0SW5kZXhPZihcIi9cIik7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBvbmx5IHBhcnQgb2YgdGhlIHJvb3QgdGhhdCBpcyBsZWZ0IGlzIHRoZSBzY2hlbWUgKGkuZS4gaHR0cDovLyxcbiAgICAvLyBmaWxlOi8vLywgZXRjLiksIG9uZSBvciBtb3JlIHNsYXNoZXMgKC8pLCBvciBzaW1wbHkgbm90aGluZyBhdCBhbGwsIHdlXG4gICAgLy8gaGF2ZSBleGhhdXN0ZWQgYWxsIGNvbXBvbmVudHMsIHNvIHRoZSBwYXRoIGlzIG5vdCByZWxhdGl2ZSB0byB0aGUgcm9vdC5cbiAgICBhUm9vdCA9IGFSb290LnNsaWNlKDAsIGluZGV4KTtcbiAgICBpZiAoYVJvb3QubWF0Y2goL14oW15cXC9dKzpcXC8pP1xcLyokLykpIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICArK2xldmVsO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHdlIGFkZCBhIFwiLi4vXCIgZm9yIGVhY2ggY29tcG9uZW50IHdlIHJlbW92ZWQgZnJvbSB0aGUgcm9vdC5cbiAgcmV0dXJuIEFycmF5KGxldmVsICsgMSkuam9pbihcIi4uL1wiKSArIGFQYXRoLnN1YnN0cihhUm9vdC5sZW5ndGggKyAxKTtcbn1cbmV4cG9ydHMucmVsYXRpdmUgPSByZWxhdGl2ZTtcblxudmFyIHN1cHBvcnRzTnVsbFByb3RvID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAhKCdfX3Byb3RvX18nIGluIG9iaik7XG59KCkpO1xuXG5mdW5jdGlvbiBpZGVudGl0eSAocykge1xuICByZXR1cm4gcztcbn1cblxuLyoqXG4gKiBCZWNhdXNlIGJlaGF2aW9yIGdvZXMgd2Fja3kgd2hlbiB5b3Ugc2V0IGBfX3Byb3RvX19gIG9uIG9iamVjdHMsIHdlXG4gKiBoYXZlIHRvIHByZWZpeCBhbGwgdGhlIHN0cmluZ3MgaW4gb3VyIHNldCB3aXRoIGFuIGFyYml0cmFyeSBjaGFyYWN0ZXIuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvcHVsbC8zMSBhbmRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzMwXG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbmZ1bmN0aW9uIHRvU2V0U3RyaW5nKGFTdHIpIHtcbiAgaWYgKGlzUHJvdG9TdHJpbmcoYVN0cikpIHtcbiAgICByZXR1cm4gJyQnICsgYVN0cjtcbiAgfVxuXG4gIHJldHVybiBhU3RyO1xufVxuZXhwb3J0cy50b1NldFN0cmluZyA9IHN1cHBvcnRzTnVsbFByb3RvID8gaWRlbnRpdHkgOiB0b1NldFN0cmluZztcblxuZnVuY3Rpb24gZnJvbVNldFN0cmluZyhhU3RyKSB7XG4gIGlmIChpc1Byb3RvU3RyaW5nKGFTdHIpKSB7XG4gICAgcmV0dXJuIGFTdHIuc2xpY2UoMSk7XG4gIH1cblxuICByZXR1cm4gYVN0cjtcbn1cbmV4cG9ydHMuZnJvbVNldFN0cmluZyA9IHN1cHBvcnRzTnVsbFByb3RvID8gaWRlbnRpdHkgOiBmcm9tU2V0U3RyaW5nO1xuXG5mdW5jdGlvbiBpc1Byb3RvU3RyaW5nKHMpIHtcbiAgaWYgKCFzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IHMubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPCA5IC8qIFwiX19wcm90b19fXCIubGVuZ3RoICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHMuY2hhckNvZGVBdChsZW5ndGggLSAxKSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDIpICE9PSA5NSAgLyogJ18nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMykgIT09IDExMSAvKiAnbycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA0KSAhPT0gMTE2IC8qICd0JyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDUpICE9PSAxMTEgLyogJ28nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNikgIT09IDExNCAvKiAncicgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA3KSAhPT0gMTEyIC8qICdwJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDgpICE9PSA5NSAgLyogJ18nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gOSkgIT09IDk1ICAvKiAnXycgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTA7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKHMuY2hhckNvZGVBdChpKSAhPT0gMzYgLyogJyQnICovKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aGVyZSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqXG4gKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiwgYnV0IGRpZmZlcmVudCBnZW5lcmF0ZWRcbiAqIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhIG1hcHBpbmcgd2l0aCBhXG4gKiBzdHViYmVkIG91dCBtYXBwaW5nLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyhtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgdmFyIGNtcCA9IG1hcHBpbmdBLnNvdXJjZSAtIG1hcHBpbmdCLnNvdXJjZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gbWFwcGluZ0EubmFtZSAtIG1hcHBpbmdCLm5hbWU7XG59XG5leHBvcnRzLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zID0gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnM7XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGRlZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBpbmRpY2VzIHdoZXJlXG4gKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uLCBidXQgZGlmZmVyZW50XG4gKiBzb3VyY2UvbmFtZS9vcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYVxuICogbWFwcGluZyB3aXRoIGEgc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLnNvdXJjZSAtIG1hcHBpbmdCLnNvdXJjZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gbWFwcGluZ0EubmFtZSAtIG1hcHBpbmdCLm5hbWU7XG59XG5leHBvcnRzLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQ7XG5cbmZ1bmN0aW9uIHN0cmNtcChhU3RyMSwgYVN0cjIpIHtcbiAgaWYgKGFTdHIxID09PSBhU3RyMikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGFTdHIxID4gYVN0cjIpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdpdGggaW5mbGF0ZWQgc291cmNlIGFuZCBuYW1lIHN0cmluZ3Mgd2hlcmVcbiAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gIHZhciBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gc3RyY21wKG1hcHBpbmdBLnNvdXJjZSwgbWFwcGluZ0Iuc291cmNlKTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xufVxuZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3VnbGlmeS1qcy9+L3NvdXJjZS1tYXAvbGliL3V0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDMyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIGRhdGEgc3RydWN0dXJlIHdoaWNoIGlzIGEgY29tYmluYXRpb24gb2YgYW4gYXJyYXkgYW5kIGEgc2V0LiBBZGRpbmcgYSBuZXdcbiAqIG1lbWJlciBpcyBPKDEpLCB0ZXN0aW5nIGZvciBtZW1iZXJzaGlwIGlzIE8oMSksIGFuZCBmaW5kaW5nIHRoZSBpbmRleCBvZiBhblxuICogZWxlbWVudCBpcyBPKDEpLiBSZW1vdmluZyBlbGVtZW50cyBmcm9tIHRoZSBzZXQgaXMgbm90IHN1cHBvcnRlZC4gT25seVxuICogc3RyaW5ncyBhcmUgc3VwcG9ydGVkIGZvciBtZW1iZXJzaGlwLlxuICovXG5mdW5jdGlvbiBBcnJheVNldCgpIHtcbiAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgdGhpcy5fc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cblxuLyoqXG4gKiBTdGF0aWMgbWV0aG9kIGZvciBjcmVhdGluZyBBcnJheVNldCBpbnN0YW5jZXMgZnJvbSBhbiBleGlzdGluZyBhcnJheS5cbiAqL1xuQXJyYXlTZXQuZnJvbUFycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfZnJvbUFycmF5KGFBcnJheSwgYUFsbG93RHVwbGljYXRlcykge1xuICB2YXIgc2V0ID0gbmV3IEFycmF5U2V0KCk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhQXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzZXQuYWRkKGFBcnJheVtpXSwgYUFsbG93RHVwbGljYXRlcyk7XG4gIH1cbiAgcmV0dXJuIHNldDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGhvdyBtYW55IHVuaXF1ZSBpdGVtcyBhcmUgaW4gdGhpcyBBcnJheVNldC4gSWYgZHVwbGljYXRlcyBoYXZlIGJlZW5cbiAqIGFkZGVkLCB0aGFuIHRob3NlIGRvIG5vdCBjb3VudCB0b3dhcmRzIHRoZSBzaXplLlxuICpcbiAqIEByZXR1cm5zIE51bWJlclxuICovXG5BcnJheVNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIEFycmF5U2V0X3NpemUoKSB7XG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLl9zZXQpLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQWRkIHRoZSBnaXZlbiBzdHJpbmcgdG8gdGhpcyBzZXQuXG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBBcnJheVNldF9hZGQoYVN0ciwgYUFsbG93RHVwbGljYXRlcykge1xuICB2YXIgc1N0ciA9IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gIHZhciBpc0R1cGxpY2F0ZSA9IGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cik7XG4gIHZhciBpZHggPSB0aGlzLl9hcnJheS5sZW5ndGg7XG4gIGlmICghaXNEdXBsaWNhdGUgfHwgYUFsbG93RHVwbGljYXRlcykge1xuICAgIHRoaXMuX2FycmF5LnB1c2goYVN0cik7XG4gIH1cbiAgaWYgKCFpc0R1cGxpY2F0ZSkge1xuICAgIHRoaXMuX3NldFtzU3RyXSA9IGlkeDtcbiAgfVxufTtcblxuLyoqXG4gKiBJcyB0aGUgZ2l2ZW4gc3RyaW5nIGEgbWVtYmVyIG9mIHRoaXMgc2V0P1xuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gQXJyYXlTZXRfaGFzKGFTdHIpIHtcbiAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICByZXR1cm4gaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKTtcbn07XG5cbi8qKlxuICogV2hhdCBpcyB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIHN0cmluZyBpbiB0aGUgYXJyYXk/XG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gQXJyYXlTZXRfaW5kZXhPZihhU3RyKSB7XG4gIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgaWYgKGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cikpIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0W3NTdHJdO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignXCInICsgYVN0ciArICdcIiBpcyBub3QgaW4gdGhlIHNldC4nKTtcbn07XG5cbi8qKlxuICogV2hhdCBpcyB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXg/XG4gKlxuICogQHBhcmFtIE51bWJlciBhSWR4XG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIEFycmF5U2V0X2F0KGFJZHgpIHtcbiAgaWYgKGFJZHggPj0gMCAmJiBhSWR4IDwgdGhpcy5fYXJyYXkubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FycmF5W2FJZHhdO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignTm8gZWxlbWVudCBpbmRleGVkIGJ5ICcgKyBhSWR4KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzZXQgKHdoaWNoIGhhcyB0aGUgcHJvcGVyIGluZGljZXNcbiAqIGluZGljYXRlZCBieSBpbmRleE9mKS4gTm90ZSB0aGF0IHRoaXMgaXMgYSBjb3B5IG9mIHRoZSBpbnRlcm5hbCBhcnJheSB1c2VkXG4gKiBmb3Igc3RvcmluZyB0aGUgbWVtYmVycyBzbyB0aGF0IG5vIG9uZSBjYW4gbWVzcyB3aXRoIGludGVybmFsIHN0YXRlLlxuICovXG5BcnJheVNldC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X3RvQXJyYXkoKSB7XG4gIHJldHVybiB0aGlzLl9hcnJheS5zbGljZSgpO1xufTtcblxuZXhwb3J0cy5BcnJheVNldCA9IEFycmF5U2V0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3VnbGlmeS1qcy9+L3NvdXJjZS1tYXAvbGliL2FycmF5LXNldC5qc1xuLy8gbW9kdWxlIGlkID0gMzMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxNCBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciBtYXBwaW5nQiBpcyBhZnRlciBtYXBwaW5nQSB3aXRoIHJlc3BlY3QgdG8gZ2VuZXJhdGVkXG4gKiBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVkUG9zaXRpb25BZnRlcihtYXBwaW5nQSwgbWFwcGluZ0IpIHtcbiAgLy8gT3B0aW1pemVkIGZvciBtb3N0IGNvbW1vbiBjYXNlXG4gIHZhciBsaW5lQSA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmU7XG4gIHZhciBsaW5lQiA9IG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIHZhciBjb2x1bW5BID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uO1xuICB2YXIgY29sdW1uQiA9IG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgcmV0dXJuIGxpbmVCID4gbGluZUEgfHwgbGluZUIgPT0gbGluZUEgJiYgY29sdW1uQiA+PSBjb2x1bW5BIHx8XG4gICAgICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikgPD0gMDtcbn1cblxuLyoqXG4gKiBBIGRhdGEgc3RydWN0dXJlIHRvIHByb3ZpZGUgYSBzb3J0ZWQgdmlldyBvZiBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiBhXG4gKiBwZXJmb3JtYW5jZSBjb25zY2lvdXMgbWFubmVyLiBJdCB0cmFkZXMgYSBuZWdsaWJhYmxlIG92ZXJoZWFkIGluIGdlbmVyYWxcbiAqIGNhc2UgZm9yIGEgbGFyZ2Ugc3BlZWR1cCBpbiBjYXNlIG9mIG1hcHBpbmdzIGJlaW5nIGFkZGVkIGluIG9yZGVyLlxuICovXG5mdW5jdGlvbiBNYXBwaW5nTGlzdCgpIHtcbiAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgLy8gU2VydmVzIGFzIGluZmltdW1cbiAgdGhpcy5fbGFzdCA9IHtnZW5lcmF0ZWRMaW5lOiAtMSwgZ2VuZXJhdGVkQ29sdW1uOiAwfTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIHRocm91Z2ggaW50ZXJuYWwgaXRlbXMuIFRoaXMgbWV0aG9kIHRha2VzIHRoZSBzYW1lIGFyZ3VtZW50cyB0aGF0XG4gKiBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIHRha2VzLlxuICpcbiAqIE5PVEU6IFRoZSBvcmRlciBvZiB0aGUgbWFwcGluZ3MgaXMgTk9UIGd1YXJhbnRlZWQuXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS51bnNvcnRlZEZvckVhY2ggPVxuICBmdW5jdGlvbiBNYXBwaW5nTGlzdF9mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpIHtcbiAgICB0aGlzLl9hcnJheS5mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpO1xuICB9O1xuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gc291cmNlIG1hcHBpbmcuXG4gKlxuICogQHBhcmFtIE9iamVjdCBhTWFwcGluZ1xuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfYWRkKGFNYXBwaW5nKSB7XG4gIGlmIChnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKHRoaXMuX2xhc3QsIGFNYXBwaW5nKSkge1xuICAgIHRoaXMuX2xhc3QgPSBhTWFwcGluZztcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmbGF0LCBzb3J0ZWQgYXJyYXkgb2YgbWFwcGluZ3MuIFRoZSBtYXBwaW5ncyBhcmUgc29ydGVkIGJ5XG4gKiBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gKlxuICogV0FSTklORzogVGhpcyBtZXRob2QgcmV0dXJucyBpbnRlcm5hbCBkYXRhIHdpdGhvdXQgY29weWluZywgZm9yXG4gKiBwZXJmb3JtYW5jZS4gVGhlIHJldHVybiB2YWx1ZSBtdXN0IE5PVCBiZSBtdXRhdGVkLCBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXNcbiAqIGFuIGltbXV0YWJsZSBib3Jyb3cuIElmIHlvdSB3YW50IHRvIHRha2Ugb3duZXJzaGlwLCB5b3UgbXVzdCBtYWtlIHlvdXIgb3duXG4gKiBjb3B5LlxuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X3RvQXJyYXkoKSB7XG4gIGlmICghdGhpcy5fc29ydGVkKSB7XG4gICAgdGhpcy5fYXJyYXkuc29ydCh1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKTtcbiAgICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheTtcbn07XG5cbmV4cG9ydHMuTWFwcGluZ0xpc3QgPSBNYXBwaW5nTGlzdDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi91Z2xpZnktanMvfi9zb3VyY2UtbWFwL2xpYi9tYXBwaW5nLWxpc3QuanNcbi8vIG1vZHVsZSBpZCA9IDMzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgYmluYXJ5U2VhcmNoID0gcmVxdWlyZSgnLi9iaW5hcnktc2VhcmNoJyk7XG52YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xudmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xudmFyIHF1aWNrU29ydCA9IHJlcXVpcmUoJy4vcXVpY2stc29ydCcpLnF1aWNrU29ydDtcblxuZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IEpTT04ucGFyc2UoYVNvdXJjZU1hcC5yZXBsYWNlKC9eXFwpXFxdXFx9Jy8sICcnKSk7XG4gIH1cblxuICByZXR1cm4gc291cmNlTWFwLnNlY3Rpb25zICE9IG51bGxcbiAgICA/IG5ldyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwKVxuICAgIDogbmV3IEJhc2ljU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwKTtcbn1cblxuU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9IGZ1bmN0aW9uKGFTb3VyY2VNYXApIHtcbiAgcmV0dXJuIEJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcChhU291cmNlTWFwKTtcbn1cblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8vIGBfX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmQgYF9fb3JpZ2luYWxNYXBwaW5nc2AgYXJlIGFycmF5cyB0aGF0IGhvbGQgdGhlXG4vLyBwYXJzZWQgbWFwcGluZyBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgbWFwJ3MgXCJtYXBwaW5nc1wiIGF0dHJpYnV0ZS4gVGhleVxuLy8gYXJlIGxhemlseSBpbnN0YW50aWF0ZWQsIGFjY2Vzc2VkIHZpYSB0aGUgYF9nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4vLyBgX29yaWdpbmFsTWFwcGluZ3NgIGdldHRlcnMgcmVzcGVjdGl2ZWx5LCBhbmQgd2Ugb25seSBwYXJzZSB0aGUgbWFwcGluZ3Ncbi8vIGFuZCBjcmVhdGUgdGhlc2UgYXJyYXlzIG9uY2UgcXVlcmllZCBmb3IgYSBzb3VyY2UgbG9jYXRpb24uIFdlIGp1bXAgdGhyb3VnaFxuLy8gdGhlc2UgaG9vcHMgYmVjYXVzZSB0aGVyZSBjYW4gYmUgbWFueSB0aG91c2FuZHMgb2YgbWFwcGluZ3MsIGFuZCBwYXJzaW5nXG4vLyB0aGVtIGlzIGV4cGVuc2l2ZSwgc28gd2Ugb25seSB3YW50IHRvIGRvIGl0IGlmIHdlIG11c3QuXG4vL1xuLy8gRWFjaCBvYmplY3QgaW4gdGhlIGFycmF5cyBpcyBvZiB0aGUgZm9ybTpcbi8vXG4vLyAgICAge1xuLy8gICAgICAgZ2VuZXJhdGVkTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIGdlbmVyYXRlZENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgc291cmNlOiBUaGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgdGhhdCBnZW5lcmF0ZWQgdGhpc1xuLy8gICAgICAgICAgICAgICBjaHVuayBvZiBjb2RlLFxuLy8gICAgICAgb3JpZ2luYWxMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBvcmlnaW5hbENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBvcmlnaW5hbCBzeW1ib2wgd2hpY2ggZ2VuZXJhdGVkIHRoaXMgY2h1bmsgb2Zcbi8vICAgICAgICAgICAgIGNvZGUuXG4vLyAgICAgfVxuLy9cbi8vIEFsbCBwcm9wZXJ0aWVzIGV4Y2VwdCBmb3IgYGdlbmVyYXRlZExpbmVgIGFuZCBgZ2VuZXJhdGVkQ29sdW1uYCBjYW4gYmVcbi8vIGBudWxsYC5cbi8vXG4vLyBgX2dlbmVyYXRlZE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zLlxuLy9cbi8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zLlxuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IG51bGw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX2dlbmVyYXRlZE1hcHBpbmdzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncykge1xuICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzO1xuICB9XG59KTtcblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG51bGw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX29yaWdpbmFsTWFwcGluZ3MnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MpIHtcbiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzO1xuICB9XG59KTtcblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyLCBpbmRleCkge1xuICAgIHZhciBjID0gYVN0ci5jaGFyQXQoaW5kZXgpO1xuICAgIHJldHVybiBjID09PSBcIjtcIiB8fCBjID09PSBcIixcIjtcbiAgfTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IF9wYXJzZU1hcHBpbmdzXCIpO1xuICB9O1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVIgPSAxO1xuU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVIgPSAyO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG5Tb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGVhY2ggbWFwcGluZyBiZXR3ZWVuIGFuIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiBhbmQgYVxuICogZ2VuZXJhdGVkIGxpbmUvY29sdW1uIGluIHRoaXMgc291cmNlIG1hcC5cbiAqXG4gKiBAcGFyYW0gRnVuY3Rpb24gYUNhbGxiYWNrXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggZWFjaCBtYXBwaW5nLlxuICogQHBhcmFtIE9iamVjdCBhQ29udGV4dFxuICogICAgICAgIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIHZhbHVlIG9mIGB0aGlzYCBldmVyeVxuICogICAgICAgIHRpbWUgdGhhdCBgYUNhbGxiYWNrYCBpcyBjYWxsZWQuXG4gKiBAcGFyYW0gYU9yZGVyXG4gKiAgICAgICAgRWl0aGVyIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgIG9yXG4gKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSYC4gU3BlY2lmaWVzIHdoZXRoZXIgeW91IHdhbnQgdG9cbiAqICAgICAgICBpdGVyYXRlIG92ZXIgdGhlIG1hcHBpbmdzIHNvcnRlZCBieSB0aGUgZ2VuZXJhdGVkIGZpbGUncyBsaW5lL2NvbHVtblxuICogICAgICAgIG9yZGVyIG9yIHRoZSBvcmlnaW5hbCdzIHNvdXJjZS9saW5lL2NvbHVtbiBvcmRlciwgcmVzcGVjdGl2ZWx5LiBEZWZhdWx0cyB0b1xuICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZWFjaE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9lYWNoTWFwcGluZyhhQ2FsbGJhY2ssIGFDb250ZXh0LCBhT3JkZXIpIHtcbiAgICB2YXIgY29udGV4dCA9IGFDb250ZXh0IHx8IG51bGw7XG4gICAgdmFyIG9yZGVyID0gYU9yZGVyIHx8IFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjtcblxuICAgIHZhciBtYXBwaW5ncztcbiAgICBzd2l0Y2ggKG9yZGVyKSB7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI6XG4gICAgICBtYXBwaW5ncyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUjpcbiAgICAgIG1hcHBpbmdzID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5ncztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9yZGVyIG9mIGl0ZXJhdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLnNvdXJjZVJvb3Q7XG4gICAgbWFwcGluZ3MubWFwKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2UgPT09IG51bGwgPyBudWxsIDogdGhpcy5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbihzb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbixcbiAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgIG5hbWU6IG1hcHBpbmcubmFtZSA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpXG4gICAgICB9O1xuICAgIH0sIHRoaXMpLmZvckVhY2goYUNhbGxiYWNrLCBjb250ZXh0KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwcm92aWRlZC4gSWYgbm8gY29sdW1uIGlzIHByb3ZpZGVkLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byBhIGVpdGhlciB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciBvciB0aGUgbmV4dFxuICogY2xvc2VzdCBsaW5lIHRoYXQgaGFzIGFueSBtYXBwaW5ncy4gT3RoZXJ3aXNlLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbGluZSBhbmQgZWl0aGVyIHRoZSBjb2x1bW4gd2UgYXJlIHNlYXJjaGluZyBmb3JcbiAqIG9yIHRoZSBuZXh0IGNsb3Nlc3QgY29sdW1uIHRoYXQgaGFzIGFueSBvZmZzZXRzLlxuICpcbiAqIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IE9wdGlvbmFsLiB0aGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICpcbiAqIGFuZCBhbiBhcnJheSBvZiBvYmplY3RzIGlzIHJldHVybmVkLCBlYWNoIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2FsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvcihhQXJncykge1xuICAgIHZhciBsaW5lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyk7XG5cbiAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIGV4YWN0IG1hdGNoLCBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmdcbiAgICAvLyByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgY2xvc2VzdCBtYXBwaW5nIGxlc3MgdGhhbiB0aGUgbmVlZGxlLiBCeVxuICAgIC8vIHNldHRpbmcgbmVlZGxlLm9yaWdpbmFsQ29sdW1uIHRvIDAsIHdlIHRodXMgZmluZCB0aGUgbGFzdCBtYXBwaW5nIGZvclxuICAgIC8vIHRoZSBnaXZlbiBsaW5lLCBwcm92aWRlZCBzdWNoIGEgbWFwcGluZyBleGlzdHMuXG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIHNvdXJjZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSxcbiAgICAgIG9yaWdpbmFsTGluZTogbGluZSxcbiAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicsIDApXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgbmVlZGxlLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBuZWVkbGUuc291cmNlKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9zb3VyY2VzLmhhcyhuZWVkbGUuc291cmNlKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBuZWVkbGUuc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG5lZWRsZS5zb3VyY2UpO1xuXG4gICAgdmFyIG1hcHBpbmdzID0gW107XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhuZWVkbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChhQXJncy5jb2x1bW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgb3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSB1bnRpbCBlaXRoZXIgd2UgcnVuIG91dCBvZiBtYXBwaW5ncywgb3Igd2UgcnVuIGludG9cbiAgICAgICAgLy8gYSBtYXBwaW5nIGZvciBhIGRpZmZlcmVudCBsaW5lIHRoYW4gdGhlIG9uZSB3ZSBmb3VuZC4gU2luY2VcbiAgICAgICAgLy8gbWFwcGluZ3MgYXJlIHNvcnRlZCwgdGhpcyBpcyBndWFyYW50ZWVkIHRvIGZpbmQgYWxsIG1hcHBpbmdzIGZvclxuICAgICAgICAvLyB0aGUgbGluZSB3ZSBmb3VuZC5cbiAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IG9yaWdpbmFsTGluZSkge1xuICAgICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgLy8gSXRlcmF0ZSB1bnRpbCBlaXRoZXIgd2UgcnVuIG91dCBvZiBtYXBwaW5ncywgb3Igd2UgcnVuIGludG9cbiAgICAgICAgLy8gYSBtYXBwaW5nIGZvciBhIGRpZmZlcmVudCBsaW5lIHRoYW4gdGhlIG9uZSB3ZSB3ZXJlIHNlYXJjaGluZyBmb3IuXG4gICAgICAgIC8vIFNpbmNlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3JcbiAgICAgICAgLy8gdGhlIGxpbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuXG4gICAgICAgIHdoaWxlIChtYXBwaW5nICYmXG4gICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gbGluZSAmJlxuICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9PSBvcmlnaW5hbENvbHVtbikge1xuICAgICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFwcGluZ3M7XG4gIH07XG5cbmV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBBIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoIHdlIGNhblxuICogcXVlcnkgZm9yIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcmlnaW5hbCBmaWxlIHBvc2l0aW9ucyBieSBnaXZpbmcgaXQgYSBmaWxlXG4gKiBwb3NpdGlvbiBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqXG4gKiBUaGUgb25seSBwYXJhbWV0ZXIgaXMgdGhlIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3JcbiAqIGFscmVhZHkgcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYywgc291cmNlIG1hcHMgaGF2ZSB0aGVcbiAqIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICpcbiAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICogICAtIHNvdXJjZXM6IEFuIGFycmF5IG9mIFVSTHMgdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAqICAgLSBuYW1lczogQW4gYXJyYXkgb2YgaWRlbnRpZmllcnMgd2hpY2ggY2FuIGJlIHJlZmVycmVuY2VkIGJ5IGluZGl2aWR1YWwgbWFwcGluZ3MuXG4gKiAgIC0gc291cmNlUm9vdDogT3B0aW9uYWwuIFRoZSBVUkwgcm9vdCBmcm9tIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSByZWxhdGl2ZS5cbiAqICAgLSBzb3VyY2VzQ29udGVudDogT3B0aW9uYWwuIEFuIGFycmF5IG9mIGNvbnRlbnRzIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gKiAgIC0gbWFwcGluZ3M6IEEgc3RyaW5nIG9mIGJhc2U2NCBWTFFzIHdoaWNoIGNvbnRhaW4gdGhlIGFjdHVhbCBtYXBwaW5ncy5cbiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKlxuICogSGVyZSBpcyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXTpcbiAqXG4gKiAgICAge1xuICogICAgICAgdmVyc2lvbiA6IDMsXG4gKiAgICAgICBmaWxlOiBcIm91dC5qc1wiLFxuICogICAgICAgc291cmNlUm9vdCA6IFwiXCIsXG4gKiAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gKiAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAqICAgICAgIG1hcHBpbmdzOiBcIkFBLEFCOztBQkNERTtcIlxuICogICAgIH1cbiAqXG4gKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdD9wbGk9MSNcbiAqL1xuZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICB2YXIgc291cmNlcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXMnKTtcbiAgLy8gU2FzcyAzLjMgbGVhdmVzIG91dCB0aGUgJ25hbWVzJyBhcnJheSwgc28gd2UgZGV2aWF0ZSBmcm9tIHRoZSBzcGVjICh3aGljaFxuICAvLyByZXF1aXJlcyB0aGUgYXJyYXkpIHRvIHBsYXkgbmljZSBoZXJlLlxuICB2YXIgbmFtZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICduYW1lcycsIFtdKTtcbiAgdmFyIHNvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VSb290JywgbnVsbCk7XG4gIHZhciBzb3VyY2VzQ29udGVudCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXNDb250ZW50JywgbnVsbCk7XG4gIHZhciBtYXBwaW5ncyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ21hcHBpbmdzJyk7XG4gIHZhciBmaWxlID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnZmlsZScsIG51bGwpO1xuXG4gIC8vIE9uY2UgYWdhaW4sIFNhc3MgZGV2aWF0ZXMgZnJvbSB0aGUgc3BlYyBhbmQgc3VwcGxpZXMgdGhlIHZlcnNpb24gYXMgYVxuICAvLyBzdHJpbmcgcmF0aGVyIHRoYW4gYSBudW1iZXIsIHNvIHdlIHVzZSBsb29zZSBlcXVhbGl0eSBjaGVja2luZyBoZXJlLlxuICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gIH1cblxuICBzb3VyY2VzID0gc291cmNlc1xuICAgIC5tYXAoU3RyaW5nKVxuICAgIC8vIFNvbWUgc291cmNlIG1hcHMgcHJvZHVjZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbGlrZSBcIi4vZm9vLmpzXCIgaW5zdGVhZCBvZlxuICAgIC8vIFwiZm9vLmpzXCIuICBOb3JtYWxpemUgdGhlc2UgZmlyc3Qgc28gdGhhdCBmdXR1cmUgY29tcGFyaXNvbnMgd2lsbCBzdWNjZWVkLlxuICAgIC8vIFNlZSBidWd6aWwubGEvMTA5MDc2OC5cbiAgICAubWFwKHV0aWwubm9ybWFsaXplKVxuICAgIC8vIEFsd2F5cyBlbnN1cmUgdGhhdCBhYnNvbHV0ZSBzb3VyY2VzIGFyZSBpbnRlcm5hbGx5IHN0b3JlZCByZWxhdGl2ZSB0b1xuICAgIC8vIHRoZSBzb3VyY2Ugcm9vdCwgaWYgdGhlIHNvdXJjZSByb290IGlzIGFic29sdXRlLiBOb3QgZG9pbmcgdGhpcyB3b3VsZFxuICAgIC8vIGJlIHBhcnRpY3VsYXJseSBwcm9ibGVtYXRpYyB3aGVuIHRoZSBzb3VyY2Ugcm9vdCBpcyBhIHByZWZpeCBvZiB0aGVcbiAgICAvLyBzb3VyY2UgKHZhbGlkLCBidXQgd2h5Pz8pLiBTZWUgZ2l0aHViIGlzc3VlICMxOTkgYW5kIGJ1Z3ppbC5sYS8xMTg4OTgyLlxuICAgIC5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIHNvdXJjZVJvb3QgJiYgdXRpbC5pc0Fic29sdXRlKHNvdXJjZVJvb3QpICYmIHV0aWwuaXNBYnNvbHV0ZShzb3VyY2UpXG4gICAgICAgID8gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2UpXG4gICAgICAgIDogc291cmNlO1xuICAgIH0pO1xuXG4gIC8vIFBhc3MgYHRydWVgIGJlbG93IHRvIGFsbG93IGR1cGxpY2F0ZSBuYW1lcyBhbmQgc291cmNlcy4gV2hpbGUgc291cmNlIG1hcHNcbiAgLy8gYXJlIGludGVuZGVkIHRvIGJlIGNvbXByZXNzZWQgYW5kIGRlZHVwbGljYXRlZCwgdGhlIFR5cGVTY3JpcHQgY29tcGlsZXJcbiAgLy8gc29tZXRpbWVzIGdlbmVyYXRlcyBzb3VyY2UgbWFwcyB3aXRoIGR1cGxpY2F0ZXMgaW4gdGhlbS4gU2VlIEdpdGh1YiBpc3N1ZVxuICAvLyAjNzIgYW5kIGJ1Z3ppbC5sYS84ODk0OTIuXG4gIHRoaXMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KG5hbWVzLm1hcChTdHJpbmcpLCB0cnVlKTtcbiAgdGhpcy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShzb3VyY2VzLCB0cnVlKTtcblxuICB0aGlzLnNvdXJjZVJvb3QgPSBzb3VyY2VSb290O1xuICB0aGlzLnNvdXJjZXNDb250ZW50ID0gc291cmNlc0NvbnRlbnQ7XG4gIHRoaXMuX21hcHBpbmdzID0gbWFwcGluZ3M7XG4gIHRoaXMuZmlsZSA9IGZpbGU7XG59XG5cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBDcmVhdGUgYSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGZyb20gYSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gKlxuICogQHBhcmFtIFNvdXJjZU1hcEdlbmVyYXRvciBhU291cmNlTWFwXG4gKiAgICAgICAgVGhlIHNvdXJjZSBtYXAgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuICogQHJldHVybnMgQmFzaWNTb3VyY2VNYXBDb25zdW1lclxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXApIHtcbiAgICB2YXIgc21jID0gT2JqZWN0LmNyZWF0ZShCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5cbiAgICB2YXIgbmFtZXMgPSBzbWMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX25hbWVzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgdmFyIHNvdXJjZXMgPSBzbWMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fc291cmNlcy50b0FycmF5KCksIHRydWUpO1xuICAgIHNtYy5zb3VyY2VSb290ID0gYVNvdXJjZU1hcC5fc291cmNlUm9vdDtcbiAgICBzbWMuc291cmNlc0NvbnRlbnQgPSBhU291cmNlTWFwLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KHNtYy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbWMuc291cmNlUm9vdCk7XG4gICAgc21jLmZpbGUgPSBhU291cmNlTWFwLl9maWxlO1xuXG4gICAgLy8gQmVjYXVzZSB3ZSBhcmUgbW9kaWZ5aW5nIHRoZSBlbnRyaWVzIChieSBjb252ZXJ0aW5nIHN0cmluZyBzb3VyY2VzIGFuZFxuICAgIC8vIG5hbWVzIHRvIGluZGljZXMgaW50byB0aGUgc291cmNlcyBhbmQgbmFtZXMgQXJyYXlTZXRzKSwgd2UgaGF2ZSB0byBtYWtlXG4gICAgLy8gYSBjb3B5IG9mIHRoZSBlbnRyeSBvciBlbHNlIGJhZCB0aGluZ3MgaGFwcGVuLiBTaGFyZWQgbXV0YWJsZSBzdGF0ZVxuICAgIC8vIHN0cmlrZXMgYWdhaW4hIFNlZSBnaXRodWIgaXNzdWUgIzE5MS5cblxuICAgIHZhciBnZW5lcmF0ZWRNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnRvQXJyYXkoKS5zbGljZSgpO1xuICAgIHZhciBkZXN0R2VuZXJhdGVkTWFwcGluZ3MgPSBzbWMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBkZXN0T3JpZ2luYWxNYXBwaW5ncyA9IHNtYy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNyY01hcHBpbmcgPSBnZW5lcmF0ZWRNYXBwaW5nc1tpXTtcbiAgICAgIHZhciBkZXN0TWFwcGluZyA9IG5ldyBNYXBwaW5nO1xuICAgICAgZGVzdE1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkTGluZTtcbiAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICBpZiAoc3JjTWFwcGluZy5zb3VyY2UpIHtcbiAgICAgICAgZGVzdE1hcHBpbmcuc291cmNlID0gc291cmNlcy5pbmRleE9mKHNyY01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxMaW5lID0gc3JjTWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gc3JjTWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICBpZiAoc3JjTWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgZGVzdE1hcHBpbmcubmFtZSA9IG5hbWVzLmluZGV4T2Yoc3JjTWFwcGluZy5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlc3RPcmlnaW5hbE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO1xuICAgICAgfVxuXG4gICAgICBkZXN0R2VuZXJhdGVkTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHNtYy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuXG4gICAgcmV0dXJuIHNtYztcbiAgfTtcblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlcy50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VSb290ICE9IG51bGwgPyB1dGlsLmpvaW4odGhpcy5zb3VyY2VSb290LCBzKSA6IHM7XG4gICAgfSwgdGhpcyk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGUgdGhlIEpJVCB3aXRoIGEgbmljZSBzaGFwZSAvIGhpZGRlbiBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gTWFwcGluZygpIHtcbiAgdGhpcy5nZW5lcmF0ZWRMaW5lID0gMDtcbiAgdGhpcy5nZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gIHRoaXMub3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgdGhpcy5vcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gIHRoaXMubmFtZSA9IG51bGw7XG59XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB2YXIgZ2VuZXJhdGVkTGluZSA9IDE7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgIHZhciBsZW5ndGggPSBhU3RyLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBjYWNoZWRTZWdtZW50cyA9IHt9O1xuICAgIHZhciB0ZW1wID0ge307XG4gICAgdmFyIG9yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgbWFwcGluZywgc3RyLCBzZWdtZW50LCBlbmQsIHZhbHVlO1xuXG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnOycpIHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZSsrO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICcsJykge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG1hcHBpbmcgPSBuZXcgTWFwcGluZygpO1xuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBnZW5lcmF0ZWRMaW5lO1xuXG4gICAgICAgIC8vIEJlY2F1c2UgZWFjaCBvZmZzZXQgaXMgZW5jb2RlZCByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgb25lLFxuICAgICAgICAvLyBtYW55IHNlZ21lbnRzIG9mdGVuIGhhdmUgdGhlIHNhbWUgZW5jb2RpbmcuIFdlIGNhbiBleHBsb2l0IHRoaXNcbiAgICAgICAgLy8gZmFjdCBieSBjYWNoaW5nIHRoZSBwYXJzZWQgdmFyaWFibGUgbGVuZ3RoIGZpZWxkcyBvZiBlYWNoIHNlZ21lbnQsXG4gICAgICAgIC8vIGFsbG93aW5nIHVzIHRvIGF2b2lkIGEgc2Vjb25kIHBhcnNlIGlmIHdlIGVuY291bnRlciB0aGUgc2FtZVxuICAgICAgICAvLyBzZWdtZW50IGFnYWluLlxuICAgICAgICBmb3IgKGVuZCA9IGluZGV4OyBlbmQgPCBsZW5ndGg7IGVuZCsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0ciwgZW5kKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0ciA9IGFTdHIuc2xpY2UoaW5kZXgsIGVuZCk7XG5cbiAgICAgICAgc2VnbWVudCA9IGNhY2hlZFNlZ21lbnRzW3N0cl07XG4gICAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgICAgaW5kZXggKz0gc3RyLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWdtZW50ID0gW107XG4gICAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kKSB7XG4gICAgICAgICAgICBiYXNlNjRWTFEuZGVjb2RlKGFTdHIsIGluZGV4LCB0ZW1wKTtcbiAgICAgICAgICAgIHZhbHVlID0gdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIGluZGV4ID0gdGVtcC5yZXN0O1xuICAgICAgICAgICAgc2VnbWVudC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UsIGJ1dCBubyBsaW5lIGFuZCBjb2x1bW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UgYW5kIGxpbmUsIGJ1dCBubyBjb2x1bW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYWNoZWRTZWdtZW50c1tzdHJdID0gc2VnbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlZCBjb2x1bW4uXG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gKyBzZWdtZW50WzBdO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAvLyBPcmlnaW5hbCBzb3VyY2UuXG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBwcmV2aW91c1NvdXJjZSArIHNlZ21lbnRbMV07XG4gICAgICAgICAgcHJldmlvdXNTb3VyY2UgKz0gc2VnbWVudFsxXTtcblxuICAgICAgICAgIC8vIE9yaWdpbmFsIGxpbmUuXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBwcmV2aW91c09yaWdpbmFsTGluZSArIHNlZ21lbnRbMl07XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgICAvLyBMaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWRcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSArPSAxO1xuXG4gICAgICAgICAgLy8gT3JpZ2luYWwgY29sdW1uLlxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBwcmV2aW91c09yaWdpbmFsQ29sdW1uICsgc2VnbWVudFszXTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIG5hbWUuXG4gICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBwcmV2aW91c05hbWUgKyBzZWdtZW50WzRdO1xuICAgICAgICAgICAgcHJldmlvdXNOYW1lICs9IHNlZ21lbnRbNF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBvcmlnaW5hbE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBxdWlja1NvcnQoZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IGdlbmVyYXRlZE1hcHBpbmdzO1xuXG4gICAgcXVpY2tTb3J0KG9yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gb3JpZ2luYWxNYXBwaW5ncztcbiAgfTtcblxuLyoqXG4gKiBGaW5kIHRoZSBtYXBwaW5nIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBoeXBvdGhldGljYWwgXCJuZWVkbGVcIiBtYXBwaW5nIHRoYXRcbiAqIHdlIGFyZSBzZWFyY2hpbmcgZm9yIGluIHRoZSBnaXZlbiBcImhheXN0YWNrXCIgb2YgbWFwcGluZ3MuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nKGFOZWVkbGUsIGFNYXBwaW5ncywgYUxpbmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ29sdW1uTmFtZSwgYUNvbXBhcmF0b3IsIGFCaWFzKSB7XG4gICAgLy8gVG8gcmV0dXJuIHRoZSBwb3NpdGlvbiB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgd2UgbXVzdCBmaXJzdCBmaW5kIHRoZVxuICAgIC8vIG1hcHBpbmcgZm9yIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgdGhlbiByZXR1cm4gdGhlIG9wcG9zaXRlIHBvc2l0aW9uIGl0XG4gICAgLy8gcG9pbnRzIHRvLiBCZWNhdXNlIHRoZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB3ZSBjYW4gdXNlIGJpbmFyeSBzZWFyY2ggdG9cbiAgICAvLyBmaW5kIHRoZSBiZXN0IG1hcHBpbmcuXG5cbiAgICBpZiAoYU5lZWRsZVthTGluZU5hbWVdIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0xpbmUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMSwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FMaW5lTmFtZV0pO1xuICAgIH1cbiAgICBpZiAoYU5lZWRsZVthQ29sdW1uTmFtZV0gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb2x1bW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FDb2x1bW5OYW1lXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJpbmFyeVNlYXJjaC5zZWFyY2goYU5lZWRsZSwgYU1hcHBpbmdzLCBhQ29tcGFyYXRvciwgYUJpYXMpO1xuICB9O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGxhc3QgY29sdW1uIGZvciBlYWNoIGdlbmVyYXRlZCBtYXBwaW5nLiBUaGUgbGFzdCBjb2x1bW4gaXNcbiAqIGluY2x1c2l2ZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29tcHV0ZUNvbHVtblNwYW5zID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY29tcHV0ZUNvbHVtblNwYW5zKCkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAvLyBNYXBwaW5ncyBkbyBub3QgY29udGFpbiBhIGZpZWxkIGZvciB0aGUgbGFzdCBnZW5lcmF0ZWQgY29sdW1udC4gV2VcbiAgICAgIC8vIGNhbiBjb21lIHVwIHdpdGggYW4gb3B0aW1pc3RpYyBlc3RpbWF0ZSwgaG93ZXZlciwgYnkgYXNzdW1pbmcgdGhhdFxuICAgICAgLy8gbWFwcGluZ3MgYXJlIGNvbnRpZ3VvdXMgKGkuZS4gZ2l2ZW4gdHdvIGNvbnNlY3V0aXZlIG1hcHBpbmdzLCB0aGVcbiAgICAgIC8vIGZpcnN0IG1hcHBpbmcgZW5kcyB3aGVyZSB0aGUgc2Vjb25kIG9uZSBzdGFydHMpLlxuICAgICAgaWYgKGluZGV4ICsgMSA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV4dE1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleCArIDFdO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5leHRNYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLSAxO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBsYXN0IG1hcHBpbmcgZm9yIGVhY2ggbGluZSBzcGFucyB0aGUgZW50aXJlIGxpbmUuXG4gICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBJbmZpbml0eTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqICAgLSBiaWFzOiBFaXRoZXIgJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKiAgICAgRGVmYXVsdHMgdG8gJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKFxuICAgICAgbmVlZGxlLFxuICAgICAgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MsXG4gICAgICBcImdlbmVyYXRlZExpbmVcIixcbiAgICAgIFwiZ2VuZXJhdGVkQ29sdW1uXCIsXG4gICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkLFxuICAgICAgdXRpbC5nZXRBcmcoYUFyZ3MsICdiaWFzJywgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpXG4gICAgKTtcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdzb3VyY2UnLCBudWxsKTtcbiAgICAgICAgaWYgKHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuYXQoc291cmNlKTtcbiAgICAgICAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbih0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ25hbWUnLCBudWxsKTtcbiAgICAgICAgaWYgKG5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICBuYW1lID0gdGhpcy5fbmFtZXMuYXQobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGwsXG4gICAgICBuYW1lOiBudWxsXG4gICAgfTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5oYXNDb250ZW50c09mQWxsU291cmNlcyA9XG4gIGZ1bmN0aW9uIEJhc2ljU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50Lmxlbmd0aCA+PSB0aGlzLl9zb3VyY2VzLnNpemUoKSAmJlxuICAgICAgIXRoaXMuc291cmNlc0NvbnRlbnQuc29tZShmdW5jdGlvbiAoc2MpIHsgcmV0dXJuIHNjID09IG51bGw7IH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICogYXZhaWxhYmxlLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLCBudWxsT25NaXNzaW5nKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIGFTb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgYVNvdXJjZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NvdXJjZXMuaGFzKGFTb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoYVNvdXJjZSldO1xuICAgIH1cblxuICAgIHZhciB1cmw7XG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsXG4gICAgICAgICYmICh1cmwgPSB1dGlsLnVybFBhcnNlKHRoaXMuc291cmNlUm9vdCkpKSB7XG4gICAgICAvLyBYWFg6IGZpbGU6Ly8gVVJJcyBhbmQgYWJzb2x1dGUgcGF0aHMgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yIGZvclxuICAgICAgLy8gbWFueSB1c2Vycy4gV2UgY2FuIGhlbHAgdGhlbSBvdXQgd2hlbiB0aGV5IGV4cGVjdCBmaWxlOi8vIFVSSXMgdG9cbiAgICAgIC8vIGJlaGF2ZSBsaWtlIGl0IHdvdWxkIGlmIHRoZXkgd2VyZSBydW5uaW5nIGEgbG9jYWwgSFRUUCBzZXJ2ZXIuIFNlZVxuICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODg1NTk3LlxuICAgICAgdmFyIGZpbGVVcmlBYnNQYXRoID0gYVNvdXJjZS5yZXBsYWNlKC9eZmlsZTpcXC9cXC8vLCBcIlwiKTtcbiAgICAgIGlmICh1cmwuc2NoZW1lID09IFwiZmlsZVwiXG4gICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoZmlsZVVyaUFic1BhdGgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihmaWxlVXJpQWJzUGF0aCldXG4gICAgICB9XG5cbiAgICAgIGlmICgoIXVybC5wYXRoIHx8IHVybC5wYXRoID09IFwiL1wiKVxuICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKFwiL1wiICsgYVNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKFwiL1wiICsgYVNvdXJjZSldO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCByZWN1cnNpdmVseSBmcm9tXG4gICAgLy8gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yLiBJbiB0aGF0IGNhc2UsIHdlXG4gICAgLy8gZG9uJ3Qgd2FudCB0byB0aHJvdyBpZiB3ZSBjYW4ndCBmaW5kIHRoZSBzb3VyY2UgLSB3ZSBqdXN0IHdhbnQgdG9cbiAgICAvLyByZXR1cm4gbnVsbCwgc28gd2UgcHJvdmlkZSBhIGZsYWcgdG8gZXhpdCBncmFjZWZ1bGx5LlxuICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKTtcbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG5cbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBvcmlnaW5hbExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICBuZWVkbGUsXG4gICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICApO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gbmVlZGxlLnNvdXJjZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgIH07XG4gIH07XG5cbmV4cG9ydHMuQmFzaWNTb3VyY2VNYXBDb25zdW1lciA9IEJhc2ljU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQW4gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaFxuICogd2UgY2FuIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbi4gSXQgZGlmZmVycyBmcm9tIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5cbiAqIHRoYXQgaXQgdGFrZXMgXCJpbmRleGVkXCIgc291cmNlIG1hcHMgKGkuZS4gb25lcyB3aXRoIGEgXCJzZWN0aW9uc1wiIGZpZWxkKSBhc1xuICogaW5wdXQuXG4gKlxuICogVGhlIG9ubHkgcGFyYW1ldGVyIGlzIGEgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvciBhbHJlYWR5XG4gKiBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjIGZvciBpbmRleGVkIHNvdXJjZSBtYXBzLCB0aGV5XG4gKiBoYXZlIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAqXG4gKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKiAgIC0gc2VjdGlvbnM6IEEgbGlzdCBvZiBzZWN0aW9uIGRlZmluaXRpb25zLlxuICpcbiAqIEVhY2ggdmFsdWUgdW5kZXIgdGhlIFwic2VjdGlvbnNcIiBmaWVsZCBoYXMgdHdvIGZpZWxkczpcbiAqICAgLSBvZmZzZXQ6IFRoZSBvZmZzZXQgaW50byB0aGUgb3JpZ2luYWwgc3BlY2lmaWVkIGF0IHdoaWNoIHRoaXMgc2VjdGlvblxuICogICAgICAgYmVnaW5zIHRvIGFwcGx5LCBkZWZpbmVkIGFzIGFuIG9iamVjdCB3aXRoIGEgXCJsaW5lXCIgYW5kIFwiY29sdW1uXCJcbiAqICAgICAgIGZpZWxkLlxuICogICAtIG1hcDogQSBzb3VyY2UgbWFwIGRlZmluaXRpb24uIFRoaXMgc291cmNlIG1hcCBjb3VsZCBhbHNvIGJlIGluZGV4ZWQsXG4gKiAgICAgICBidXQgZG9lc24ndCBoYXZlIHRvIGJlLlxuICpcbiAqIEluc3RlYWQgb2YgdGhlIFwibWFwXCIgZmllbGQsIGl0J3MgYWxzbyBwb3NzaWJsZSB0byBoYXZlIGEgXCJ1cmxcIiBmaWVsZFxuICogc3BlY2lmeWluZyBhIFVSTCB0byByZXRyaWV2ZSBhIHNvdXJjZSBtYXAgZnJvbSwgYnV0IHRoYXQncyBjdXJyZW50bHlcbiAqIHVuc3VwcG9ydGVkLlxuICpcbiAqIEhlcmUncyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXSwgYnV0XG4gKiBtb2RpZmllZCB0byBvbWl0IGEgc2VjdGlvbiB3aGljaCB1c2VzIHRoZSBcInVybFwiIGZpZWxkLlxuICpcbiAqICB7XG4gKiAgICB2ZXJzaW9uIDogMyxcbiAqICAgIGZpbGU6IFwiYXBwLmpzXCIsXG4gKiAgICBzZWN0aW9uczogW3tcbiAqICAgICAgb2Zmc2V0OiB7bGluZToxMDAsIGNvbHVtbjoxMH0sXG4gKiAgICAgIG1hcDoge1xuICogICAgICAgIHZlcnNpb24gOiAzLFxuICogICAgICAgIGZpbGU6IFwic2VjdGlvbi5qc1wiLFxuICogICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAqICAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAqICAgICAgICBtYXBwaW5nczogXCJBQUFBLEU7O0FCQ0RFO1wiXG4gKiAgICAgIH1cbiAqICAgIH1dLFxuICogIH1cbiAqXG4gKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdCNoZWFkaW5nPWguNTM1ZXMzeGVwcmd0XG4gKi9cbmZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICB2YXIgc2VjdGlvbnMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzZWN0aW9ucycpO1xuXG4gIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICB2YXIgbGFzdE9mZnNldCA9IHtcbiAgICBsaW5lOiAtMSxcbiAgICBjb2x1bW46IDBcbiAgfTtcbiAgdGhpcy5fc2VjdGlvbnMgPSBzZWN0aW9ucy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICBpZiAocy51cmwpIHtcbiAgICAgIC8vIFRoZSB1cmwgZmllbGQgd2lsbCByZXF1aXJlIHN1cHBvcnQgZm9yIGFzeW5jaHJvbmljaXR5LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzE2XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBvcnQgZm9yIHVybCBmaWVsZCBpbiBzZWN0aW9ucyBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSB1dGlsLmdldEFyZyhzLCAnb2Zmc2V0Jyk7XG4gICAgdmFyIG9mZnNldExpbmUgPSB1dGlsLmdldEFyZyhvZmZzZXQsICdsaW5lJyk7XG4gICAgdmFyIG9mZnNldENvbHVtbiA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgJ2NvbHVtbicpO1xuXG4gICAgaWYgKG9mZnNldExpbmUgPCBsYXN0T2Zmc2V0LmxpbmUgfHxcbiAgICAgICAgKG9mZnNldExpbmUgPT09IGxhc3RPZmZzZXQubGluZSAmJiBvZmZzZXRDb2x1bW4gPCBsYXN0T2Zmc2V0LmNvbHVtbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2VjdGlvbiBvZmZzZXRzIG11c3QgYmUgb3JkZXJlZCBhbmQgbm9uLW92ZXJsYXBwaW5nLicpO1xuICAgIH1cbiAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdlbmVyYXRlZE9mZnNldDoge1xuICAgICAgICAvLyBUaGUgb2Zmc2V0IGZpZWxkcyBhcmUgMC1iYXNlZCwgYnV0IHdlIHVzZSAxLWJhc2VkIGluZGljZXMgd2hlblxuICAgICAgICAvLyBlbmNvZGluZy9kZWNvZGluZyBmcm9tIFZMUS5cbiAgICAgICAgZ2VuZXJhdGVkTGluZTogb2Zmc2V0TGluZSArIDEsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogb2Zmc2V0Q29sdW1uICsgMVxuICAgICAgfSxcbiAgICAgIGNvbnN1bWVyOiBuZXcgU291cmNlTWFwQ29uc3VtZXIodXRpbC5nZXRBcmcocywgJ21hcCcpKVxuICAgIH1cbiAgfSk7XG59XG5cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ3NvdXJjZXMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHNvdXJjZXMucHVzaCh0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZXM7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICAvLyBGaW5kIHRoZSBzZWN0aW9uIGNvbnRhaW5pbmcgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbiB3ZSdyZSB0cnlpbmcgdG8gbWFwXG4gICAgLy8gdG8gYW4gb3JpZ2luYWwgcG9zaXRpb24uXG4gICAgdmFyIHNlY3Rpb25JbmRleCA9IGJpbmFyeVNlYXJjaC5zZWFyY2gobmVlZGxlLCB0aGlzLl9zZWN0aW9ucyxcbiAgICAgIGZ1bmN0aW9uKG5lZWRsZSwgc2VjdGlvbikge1xuICAgICAgICB2YXIgY21wID0gbmVlZGxlLmdlbmVyYXRlZExpbmUgLSBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lO1xuICAgICAgICBpZiAoY21wKSB7XG4gICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgIH0pO1xuICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbc2VjdGlvbkluZGV4XTtcblxuICAgIGlmICghc2VjdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIG5hbWU6IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY3Rpb24uY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICBsaW5lOiBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtXG4gICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICBjb2x1bW46IG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmVcbiAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgOiAwKSxcbiAgICAgIGJpYXM6IGFBcmdzLmJpYXNcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWN0aW9ucy5ldmVyeShmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHMuY29uc3VtZXIuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKTtcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAqIGF2YWlsYWJsZS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgIHZhciBjb250ZW50ID0gc2VjdGlvbi5jb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIHRydWUpO1xuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuXG4gICAgICAvLyBPbmx5IGNvbnNpZGVyIHRoaXMgc2VjdGlvbiBpZiB0aGUgcmVxdWVzdGVkIHNvdXJjZSBpcyBpbiB0aGUgbGlzdCBvZlxuICAgICAgLy8gc291cmNlcyBvZiB0aGUgY29uc3VtZXIuXG4gICAgICBpZiAoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VzLmluZGV4T2YodXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSkgPT09IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGdlbmVyYXRlZFBvc2l0aW9uID0gc2VjdGlvbi5jb25zdW1lci5nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncyk7XG4gICAgICBpZiAoZ2VuZXJhdGVkUG9zaXRpb24pIHtcbiAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWRQb3NpdGlvbi5jb2x1bW4gK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmVcbiAgICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgICA6IDApXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGxcbiAgICB9O1xuICB9O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuICAgICAgdmFyIHNlY3Rpb25NYXBwaW5ncyA9IHNlY3Rpb24uY29uc3VtZXIuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWN0aW9uTWFwcGluZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSBzZWN0aW9uTWFwcGluZ3Nbal07XG5cbiAgICAgICAgdmFyIHNvdXJjZSA9IHNlY3Rpb24uY29uc3VtZXIuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBpZiAoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VSb290ICE9PSBudWxsKSB7XG4gICAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHNlY3Rpb24uY29uc3VtZXIuc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcblxuICAgICAgICB2YXIgbmFtZSA9IHNlY3Rpb24uY29uc3VtZXIuX25hbWVzLmF0KG1hcHBpbmcubmFtZSk7XG4gICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgbmFtZSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG5cbiAgICAgICAgLy8gVGhlIG1hcHBpbmdzIGNvbWluZyBmcm9tIHRoZSBjb25zdW1lciBmb3IgdGhlIHNlY3Rpb24gaGF2ZVxuICAgICAgICAvLyBnZW5lcmF0ZWQgcG9zaXRpb25zIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgc2VjdGlvbiwgc28gd2VcbiAgICAgICAgLy8gbmVlZCB0byBvZmZzZXQgdGhlbSB0byBiZSByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbmNhdGVuYXRlZFxuICAgICAgICAvLyBnZW5lcmF0ZWQgZmlsZS5cbiAgICAgICAgdmFyIGFkanVzdGVkTWFwcGluZyA9IHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUgK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBtYXBwaW5nLmdlbmVyYXRlZExpbmVcbiAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgOiAwKSxcbiAgICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICBpZiAodHlwZW9mIGFkanVzdGVkTWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCk7XG4gICAgcXVpY2tTb3J0KHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgfTtcblxuZXhwb3J0cy5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIgPSBJbmRleGVkU291cmNlTWFwQ29uc3VtZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdWdsaWZ5LWpzL34vc291cmNlLW1hcC9saWIvc291cmNlLW1hcC1jb25zdW1lci5qc1xuLy8gbW9kdWxlIGlkID0gMzMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuZXhwb3J0cy5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG5leHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EID0gMjtcblxuLyoqXG4gKiBSZWN1cnNpdmUgaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaC5cbiAqXG4gKiBAcGFyYW0gYUxvdyBJbmRpY2VzIGhlcmUgYW5kIGxvd2VyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gKiBAcGFyYW0gYUhpZ2ggSW5kaWNlcyBoZXJlIGFuZCBoaWdoZXIgZG8gbm90IGNvbnRhaW4gdGhlIG5lZWRsZS5cbiAqIEBwYXJhbSBhTmVlZGxlIFRoZSBlbGVtZW50IGJlaW5nIHNlYXJjaGVkIGZvci5cbiAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIG5vbi1lbXB0eSBhcnJheSBiZWluZyBzZWFyY2hlZC5cbiAqIEBwYXJhbSBhQ29tcGFyZSBGdW5jdGlvbiB3aGljaCB0YWtlcyB0d28gZWxlbWVudHMgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEuXG4gKiBAcGFyYW0gYUJpYXMgRWl0aGVyICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ2JpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiB0ZXJtaW5hdGVzIHdoZW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZTpcbiAgLy9cbiAgLy8gICAxLiBXZSBmaW5kIHRoZSBleGFjdCBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgLy9cbiAgLy8gICAyLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGJ1dCB3ZSBjYW4gcmV0dXJuIHRoZSBpbmRleCBvZlxuICAvLyAgICAgIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudC5cbiAgLy9cbiAgLy8gICAzLiBXZSBkaWQgbm90IGZpbmQgdGhlIGV4YWN0IGVsZW1lbnQsIGFuZCB0aGVyZSBpcyBubyBuZXh0LWNsb3Nlc3RcbiAgLy8gICAgICBlbGVtZW50IHRoYW4gdGhlIG9uZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgc28gd2UgcmV0dXJuIC0xLlxuICB2YXIgbWlkID0gTWF0aC5mbG9vcigoYUhpZ2ggLSBhTG93KSAvIDIpICsgYUxvdztcbiAgdmFyIGNtcCA9IGFDb21wYXJlKGFOZWVkbGUsIGFIYXlzdGFja1ttaWRdLCB0cnVlKTtcbiAgaWYgKGNtcCA9PT0gMCkge1xuICAgIC8vIEZvdW5kIHRoZSBlbGVtZW50IHdlIGFyZSBsb29raW5nIGZvci5cbiAgICByZXR1cm4gbWlkO1xuICB9XG4gIGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAvLyBPdXIgbmVlZGxlIGlzIGdyZWF0ZXIgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICBpZiAoYUhpZ2ggLSBtaWQgPiAxKSB7XG4gICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2gobWlkLCBhSGlnaCwgYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpO1xuICAgIH1cblxuICAgIC8vIFRoZSBleGFjdCBuZWVkbGUgZWxlbWVudCB3YXMgbm90IGZvdW5kIGluIHRoaXMgaGF5c3RhY2suIERldGVybWluZSBpZlxuICAgIC8vIHdlIGFyZSBpbiB0ZXJtaW5hdGlvbiBjYXNlICgzKSBvciAoMikgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgdGhpbmcuXG4gICAgaWYgKGFCaWFzID09IGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQpIHtcbiAgICAgIHJldHVybiBhSGlnaCA8IGFIYXlzdGFjay5sZW5ndGggPyBhSGlnaCA6IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWlkO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvLyBPdXIgbmVlZGxlIGlzIGxlc3MgdGhhbiBhSGF5c3RhY2tbbWlkXS5cbiAgICBpZiAobWlkIC0gYUxvdyA+IDEpIHtcbiAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGluIHRoZSBsb3dlciBoYWxmLlxuICAgICAgcmV0dXJuIHJlY3Vyc2l2ZVNlYXJjaChhTG93LCBtaWQsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICB9XG5cbiAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICByZXR1cm4gbWlkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYUxvdyA8IDAgPyAtMSA6IGFMb3c7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBiaW5hcnkgc2VhcmNoIHdoaWNoIHdpbGwgYWx3YXlzIHRyeSBhbmQgcmV0dXJuXG4gKiB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgZWxlbWVudCBpZiB0aGVyZSBpcyBubyBleGFjdCBoaXQuIFRoaXMgaXMgYmVjYXVzZVxuICogbWFwcGluZ3MgYmV0d2VlbiBvcmlnaW5hbCBhbmQgZ2VuZXJhdGVkIGxpbmUvY29sIHBhaXJzIGFyZSBzaW5nbGUgcG9pbnRzLFxuICogYW5kIHRoZXJlIGlzIGFuIGltcGxpY2l0IHJlZ2lvbiBiZXR3ZWVuIGVhY2ggb2YgdGhlbSwgc28gYSBtaXNzIGp1c3QgbWVhbnNcbiAqIHRoYXQgeW91IGFyZW4ndCBvbiB0aGUgdmVyeSBzdGFydCBvZiBhIHJlZ2lvbi5cbiAqXG4gKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCB5b3UgYXJlIGxvb2tpbmcgZm9yLlxuICogQHBhcmFtIGFIYXlzdGFjayBUaGUgYXJyYXkgdGhhdCBpcyBiZWluZyBzZWFyY2hlZC5cbiAqIEBwYXJhbSBhQ29tcGFyZSBBIGZ1bmN0aW9uIHdoaWNoIHRha2VzIHRoZSBuZWVkbGUgYW5kIGFuIGVsZW1lbnQgaW4gdGhlXG4gKiAgICAgYXJyYXkgYW5kIHJldHVybnMgLTEsIDAsIG9yIDEgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIG5lZWRsZSBpcyBsZXNzXG4gKiAgICAgdGhhbiwgZXF1YWwgdG8sIG9yIGdyZWF0ZXIgdGhhbiB0aGUgZWxlbWVudCwgcmVzcGVjdGl2ZWx5LlxuICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdiaW5hcnlTZWFyY2guR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICovXG5leHBvcnRzLnNlYXJjaCA9IGZ1bmN0aW9uIHNlYXJjaChhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcykge1xuICBpZiAoYUhheXN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIHZhciBpbmRleCA9IHJlY3Vyc2l2ZVNlYXJjaCgtMSwgYUhheXN0YWNrLmxlbmd0aCwgYU5lZWRsZSwgYUhheXN0YWNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbXBhcmUsIGFCaWFzIHx8IGV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLy8gV2UgaGF2ZSBmb3VuZCBlaXRoZXIgdGhlIGV4YWN0IGVsZW1lbnQsIG9yIHRoZSBuZXh0LWNsb3Nlc3QgZWxlbWVudCB0aGFuXG4gIC8vIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuIEhvd2V2ZXIsIHRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIHN1Y2hcbiAgLy8gZWxlbWVudC4gTWFrZSBzdXJlIHdlIGFsd2F5cyByZXR1cm4gdGhlIHNtYWxsZXN0IG9mIHRoZXNlLlxuICB3aGlsZSAoaW5kZXggLSAxID49IDApIHtcbiAgICBpZiAoYUNvbXBhcmUoYUhheXN0YWNrW2luZGV4XSwgYUhheXN0YWNrW2luZGV4IC0gMV0sIHRydWUpICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLS1pbmRleDtcbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdWdsaWZ5LWpzL34vc291cmNlLW1hcC9saWIvYmluYXJ5LXNlYXJjaC5qc1xuLy8gbW9kdWxlIGlkID0gMzMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxuLy8gSXQgdHVybnMgb3V0IHRoYXQgc29tZSAobW9zdD8pIEphdmFTY3JpcHQgZW5naW5lcyBkb24ndCBzZWxmLWhvc3Rcbi8vIGBBcnJheS5wcm90b3R5cGUuc29ydGAuIFRoaXMgbWFrZXMgc2Vuc2UgYmVjYXVzZSBDKysgd2lsbCBsaWtlbHkgcmVtYWluXG4vLyBmYXN0ZXIgdGhhbiBKUyB3aGVuIGRvaW5nIHJhdyBDUFUtaW50ZW5zaXZlIHNvcnRpbmcuIEhvd2V2ZXIsIHdoZW4gdXNpbmcgYVxuLy8gY3VzdG9tIGNvbXBhcmF0b3IgZnVuY3Rpb24sIGNhbGxpbmcgYmFjayBhbmQgZm9ydGggYmV0d2VlbiB0aGUgVk0ncyBDKysgYW5kXG4vLyBKSVQnZCBKUyBpcyByYXRoZXIgc2xvdyAqYW5kKiBsb3NlcyBKSVQgdHlwZSBpbmZvcm1hdGlvbiwgcmVzdWx0aW5nIGluXG4vLyB3b3JzZSBnZW5lcmF0ZWQgY29kZSBmb3IgdGhlIGNvbXBhcmF0b3IgZnVuY3Rpb24gdGhhbiB3b3VsZCBiZSBvcHRpbWFsLiBJblxuLy8gZmFjdCwgd2hlbiBzb3J0aW5nIHdpdGggYSBjb21wYXJhdG9yLCB0aGVzZSBjb3N0cyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgb2Zcbi8vIHNvcnRpbmcgaW4gQysrLiBCeSB1c2luZyBvdXIgb3duIEpTLWltcGxlbWVudGVkIFF1aWNrIFNvcnQgKGJlbG93KSwgd2UgZ2V0XG4vLyBhIH4zNTAwbXMgbWVhbiBzcGVlZC11cCBpbiBgYmVuY2gvYmVuY2guaHRtbGAuXG5cbi8qKlxuICogU3dhcCB0aGUgZWxlbWVudHMgaW5kZXhlZCBieSBgeGAgYW5kIGB5YCBpbiB0aGUgYXJyYXkgYGFyeWAuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgVGhlIGFycmF5LlxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqICAgICAgICBUaGUgaW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0uXG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogICAgICAgIFRoZSBpbmRleCBvZiB0aGUgc2Vjb25kIGl0ZW0uXG4gKi9cbmZ1bmN0aW9uIHN3YXAoYXJ5LCB4LCB5KSB7XG4gIHZhciB0ZW1wID0gYXJ5W3hdO1xuICBhcnlbeF0gPSBhcnlbeV07XG4gIGFyeVt5XSA9IHRlbXA7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIHdpdGhpbiB0aGUgcmFuZ2UgYGxvdyAuLiBoaWdoYCBpbmNsdXNpdmUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGxvd1xuICogICAgICAgIFRoZSBsb3dlciBib3VuZCBvbiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge051bWJlcn0gaGlnaFxuICogICAgICAgIFRoZSB1cHBlciBib3VuZCBvbiB0aGUgcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbUludEluUmFuZ2UobG93LCBoaWdoKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKGxvdyArIChNYXRoLnJhbmRvbSgpICogKGhpZ2ggLSBsb3cpKSk7XG59XG5cbi8qKlxuICogVGhlIFF1aWNrIFNvcnQgYWxnb3JpdGhtLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIEFuIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yXG4gKiAgICAgICAgRnVuY3Rpb24gdG8gdXNlIHRvIGNvbXBhcmUgdHdvIGl0ZW1zLlxuICogQHBhcmFtIHtOdW1iZXJ9IHBcbiAqICAgICAgICBTdGFydCBpbmRleCBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSByXG4gKiAgICAgICAgRW5kIGluZGV4IG9mIHRoZSBhcnJheVxuICovXG5mdW5jdGlvbiBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHAsIHIpIHtcbiAgLy8gSWYgb3VyIGxvd2VyIGJvdW5kIGlzIGxlc3MgdGhhbiBvdXIgdXBwZXIgYm91bmQsIHdlICgxKSBwYXJ0aXRpb24gdGhlXG4gIC8vIGFycmF5IGludG8gdHdvIHBpZWNlcyBhbmQgKDIpIHJlY3Vyc2Ugb24gZWFjaCBoYWxmLiBJZiBpdCBpcyBub3QsIHRoaXMgaXNcbiAgLy8gdGhlIGVtcHR5IGFycmF5IGFuZCBvdXIgYmFzZSBjYXNlLlxuXG4gIGlmIChwIDwgcikge1xuICAgIC8vICgxKSBQYXJ0aXRpb25pbmcuXG4gICAgLy9cbiAgICAvLyBUaGUgcGFydGl0aW9uaW5nIGNob29zZXMgYSBwaXZvdCBiZXR3ZWVuIGBwYCBhbmQgYHJgIGFuZCBtb3ZlcyBhbGxcbiAgICAvLyBlbGVtZW50cyB0aGF0IGFyZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBpdm90IHRvIHRoZSBiZWZvcmUgaXQsIGFuZFxuICAgIC8vIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBhcmUgZ3JlYXRlciB0aGFuIGl0IGFmdGVyIGl0LiBUaGUgZWZmZWN0IGlzIHRoYXRcbiAgICAvLyBvbmNlIHBhcnRpdGlvbiBpcyBkb25lLCB0aGUgcGl2b3QgaXMgaW4gdGhlIGV4YWN0IHBsYWNlIGl0IHdpbGwgYmUgd2hlblxuICAgIC8vIHRoZSBhcnJheSBpcyBwdXQgaW4gc29ydGVkIG9yZGVyLCBhbmQgaXQgd2lsbCBub3QgbmVlZCB0byBiZSBtb3ZlZFxuICAgIC8vIGFnYWluLiBUaGlzIHJ1bnMgaW4gTyhuKSB0aW1lLlxuXG4gICAgLy8gQWx3YXlzIGNob29zZSBhIHJhbmRvbSBwaXZvdCBzbyB0aGF0IGFuIGlucHV0IGFycmF5IHdoaWNoIGlzIHJldmVyc2VcbiAgICAvLyBzb3J0ZWQgZG9lcyBub3QgY2F1c2UgTyhuXjIpIHJ1bm5pbmcgdGltZS5cbiAgICB2YXIgcGl2b3RJbmRleCA9IHJhbmRvbUludEluUmFuZ2UocCwgcik7XG4gICAgdmFyIGkgPSBwIC0gMTtcblxuICAgIHN3YXAoYXJ5LCBwaXZvdEluZGV4LCByKTtcbiAgICB2YXIgcGl2b3QgPSBhcnlbcl07XG5cbiAgICAvLyBJbW1lZGlhdGVseSBhZnRlciBgamAgaXMgaW5jcmVtZW50ZWQgaW4gdGhpcyBsb29wLCB0aGUgZm9sbG93aW5nIGhvbGRcbiAgICAvLyB0cnVlOlxuICAgIC8vXG4gICAgLy8gICAqIEV2ZXJ5IGVsZW1lbnQgaW4gYGFyeVtwIC4uIGldYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHBpdm90LlxuICAgIC8vXG4gICAgLy8gICAqIEV2ZXJ5IGVsZW1lbnQgaW4gYGFyeVtpKzEgLi4gai0xXWAgaXMgZ3JlYXRlciB0aGFuIHRoZSBwaXZvdC5cbiAgICBmb3IgKHZhciBqID0gcDsgaiA8IHI7IGorKykge1xuICAgICAgaWYgKGNvbXBhcmF0b3IoYXJ5W2pdLCBwaXZvdCkgPD0gMCkge1xuICAgICAgICBpICs9IDE7XG4gICAgICAgIHN3YXAoYXJ5LCBpLCBqKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2FwKGFyeSwgaSArIDEsIGopO1xuICAgIHZhciBxID0gaSArIDE7XG5cbiAgICAvLyAoMikgUmVjdXJzZSBvbiBlYWNoIGhhbGYuXG5cbiAgICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHAsIHEgLSAxKTtcbiAgICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIHEgKyAxLCByKTtcbiAgfVxufVxuXG4vKipcbiAqIFNvcnQgdGhlIGdpdmVuIGFycmF5IGluLXBsYWNlIHdpdGggdGhlIGdpdmVuIGNvbXBhcmF0b3IgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgQW4gYXJyYXkgdG8gc29ydC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3JcbiAqICAgICAgICBGdW5jdGlvbiB0byB1c2UgdG8gY29tcGFyZSB0d28gaXRlbXMuXG4gKi9cbmV4cG9ydHMucXVpY2tTb3J0ID0gZnVuY3Rpb24gKGFyeSwgY29tcGFyYXRvcikge1xuICBkb1F1aWNrU29ydChhcnksIGNvbXBhcmF0b3IsIDAsIGFyeS5sZW5ndGggLSAxKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdWdsaWZ5LWpzL34vc291cmNlLW1hcC9saWIvcXVpY2stc29ydC5qc1xuLy8gbW9kdWxlIGlkID0gMzM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIFNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vLyBNYXRjaGVzIGEgV2luZG93cy1zdHlsZSBgXFxyXFxuYCBuZXdsaW5lIG9yIGEgYFxcbmAgbmV3bGluZSB1c2VkIGJ5IGFsbCBvdGhlclxuLy8gb3BlcmF0aW5nIHN5c3RlbXMgdGhlc2UgZGF5cyAoY2FwdHVyaW5nIHRoZSByZXN1bHQpLlxudmFyIFJFR0VYX05FV0xJTkUgPSAvKFxccj9cXG4pLztcblxuLy8gTmV3bGluZSBjaGFyYWN0ZXIgY29kZSBmb3IgY2hhckNvZGVBdCgpIGNvbXBhcmlzb25zXG52YXIgTkVXTElORV9DT0RFID0gMTA7XG5cbi8vIFByaXZhdGUgc3ltYm9sIGZvciBpZGVudGlmeWluZyBgU291cmNlTm9kZWBzIHdoZW4gbXVsdGlwbGUgdmVyc2lvbnMgb2Zcbi8vIHRoZSBzb3VyY2UtbWFwIGxpYnJhcnkgYXJlIGxvYWRlZC4gVGhpcyBNVVNUIE5PVCBDSEFOR0UgYWNyb3NzXG4vLyB2ZXJzaW9ucyFcbnZhciBpc1NvdXJjZU5vZGUgPSBcIiQkJGlzU291cmNlTm9kZSQkJFwiO1xuXG4vKipcbiAqIFNvdXJjZU5vZGVzIHByb3ZpZGUgYSB3YXkgdG8gYWJzdHJhY3Qgb3ZlciBpbnRlcnBvbGF0aW5nL2NvbmNhdGVuYXRpbmdcbiAqIHNuaXBwZXRzIG9mIGdlbmVyYXRlZCBKYXZhU2NyaXB0IHNvdXJjZSBjb2RlIHdoaWxlIG1haW50YWluaW5nIHRoZSBsaW5lIGFuZFxuICogY29sdW1uIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3JpZ2luYWwgc291cmNlIGNvZGUuXG4gKlxuICogQHBhcmFtIGFMaW5lIFRoZSBvcmlnaW5hbCBsaW5lIG51bWJlci5cbiAqIEBwYXJhbSBhQ29sdW1uIFRoZSBvcmlnaW5hbCBjb2x1bW4gbnVtYmVyLlxuICogQHBhcmFtIGFTb3VyY2UgVGhlIG9yaWdpbmFsIHNvdXJjZSdzIGZpbGVuYW1lLlxuICogQHBhcmFtIGFDaHVua3MgT3B0aW9uYWwuIEFuIGFycmF5IG9mIHN0cmluZ3Mgd2hpY2ggYXJlIHNuaXBwZXRzIG9mXG4gKiAgICAgICAgZ2VuZXJhdGVkIEpTLCBvciBvdGhlciBTb3VyY2VOb2Rlcy5cbiAqIEBwYXJhbSBhTmFtZSBUaGUgb3JpZ2luYWwgaWRlbnRpZmllci5cbiAqL1xuZnVuY3Rpb24gU291cmNlTm9kZShhTGluZSwgYUNvbHVtbiwgYVNvdXJjZSwgYUNodW5rcywgYU5hbWUpIHtcbiAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICB0aGlzLnNvdXJjZUNvbnRlbnRzID0ge307XG4gIHRoaXMubGluZSA9IGFMaW5lID09IG51bGwgPyBudWxsIDogYUxpbmU7XG4gIHRoaXMuY29sdW1uID0gYUNvbHVtbiA9PSBudWxsID8gbnVsbCA6IGFDb2x1bW47XG4gIHRoaXMuc291cmNlID0gYVNvdXJjZSA9PSBudWxsID8gbnVsbCA6IGFTb3VyY2U7XG4gIHRoaXMubmFtZSA9IGFOYW1lID09IG51bGwgPyBudWxsIDogYU5hbWU7XG4gIHRoaXNbaXNTb3VyY2VOb2RlXSA9IHRydWU7XG4gIGlmIChhQ2h1bmtzICE9IG51bGwpIHRoaXMuYWRkKGFDaHVua3MpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBTb3VyY2VOb2RlIGZyb20gZ2VuZXJhdGVkIGNvZGUgYW5kIGEgU291cmNlTWFwQ29uc3VtZXIuXG4gKlxuICogQHBhcmFtIGFHZW5lcmF0ZWRDb2RlIFRoZSBnZW5lcmF0ZWQgY29kZVxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwIGZvciB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAqIEBwYXJhbSBhUmVsYXRpdmVQYXRoIE9wdGlvbmFsLiBUaGUgcGF0aCB0aGF0IHJlbGF0aXZlIHNvdXJjZXMgaW4gdGhlXG4gKiAgICAgICAgU291cmNlTWFwQ29uc3VtZXIgc2hvdWxkIGJlIHJlbGF0aXZlIHRvLlxuICovXG5Tb3VyY2VOb2RlLmZyb21TdHJpbmdXaXRoU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV9mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcChhR2VuZXJhdGVkQ29kZSwgYVNvdXJjZU1hcENvbnN1bWVyLCBhUmVsYXRpdmVQYXRoKSB7XG4gICAgLy8gVGhlIFNvdXJjZU5vZGUgd2Ugd2FudCB0byBmaWxsIHdpdGggdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAgLy8gYW5kIHRoZSBTb3VyY2VNYXBcbiAgICB2YXIgbm9kZSA9IG5ldyBTb3VyY2VOb2RlKCk7XG5cbiAgICAvLyBBbGwgZXZlbiBpbmRpY2VzIG9mIHRoaXMgYXJyYXkgYXJlIG9uZSBsaW5lIG9mIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgICAvLyB3aGlsZSBhbGwgb2RkIGluZGljZXMgYXJlIHRoZSBuZXdsaW5lcyBiZXR3ZWVuIHR3byBhZGphY2VudCBsaW5lc1xuICAgIC8vIChzaW5jZSBgUkVHRVhfTkVXTElORWAgY2FwdHVyZXMgaXRzIG1hdGNoKS5cbiAgICAvLyBQcm9jZXNzZWQgZnJhZ21lbnRzIGFyZSByZW1vdmVkIGZyb20gdGhpcyBhcnJheSwgYnkgY2FsbGluZyBgc2hpZnROZXh0TGluZWAuXG4gICAgdmFyIHJlbWFpbmluZ0xpbmVzID0gYUdlbmVyYXRlZENvZGUuc3BsaXQoUkVHRVhfTkVXTElORSk7XG4gICAgdmFyIHNoaWZ0TmV4dExpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsaW5lQ29udGVudHMgPSByZW1haW5pbmdMaW5lcy5zaGlmdCgpO1xuICAgICAgLy8gVGhlIGxhc3QgbGluZSBvZiBhIGZpbGUgbWlnaHQgbm90IGhhdmUgYSBuZXdsaW5lLlxuICAgICAgdmFyIG5ld0xpbmUgPSByZW1haW5pbmdMaW5lcy5zaGlmdCgpIHx8IFwiXCI7XG4gICAgICByZXR1cm4gbGluZUNvbnRlbnRzICsgbmV3TGluZTtcbiAgICB9O1xuXG4gICAgLy8gV2UgbmVlZCB0byByZW1lbWJlciB0aGUgcG9zaXRpb24gb2YgXCJyZW1haW5pbmdMaW5lc1wiXG4gICAgdmFyIGxhc3RHZW5lcmF0ZWRMaW5lID0gMSwgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG5cbiAgICAvLyBUaGUgZ2VuZXJhdGUgU291cmNlTm9kZXMgd2UgbmVlZCBhIGNvZGUgcmFuZ2UuXG4gICAgLy8gVG8gZXh0cmFjdCBpdCBjdXJyZW50IGFuZCBsYXN0IG1hcHBpbmcgaXMgdXNlZC5cbiAgICAvLyBIZXJlIHdlIHN0b3JlIHRoZSBsYXN0IG1hcHBpbmcuXG4gICAgdmFyIGxhc3RNYXBwaW5nID0gbnVsbDtcblxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgaWYgKGxhc3RNYXBwaW5nICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFdlIGFkZCB0aGUgY29kZSBmcm9tIFwibGFzdE1hcHBpbmdcIiB0byBcIm1hcHBpbmdcIjpcbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlcmUgaXMgYSBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICBpZiAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAvLyBBc3NvY2lhdGUgZmlyc3QgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICAgIC8vIFRoZSByZW1haW5pbmcgY29kZSBpcyBhZGRlZCB3aXRob3V0IG1hcHBpbmdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgY29kZSBiZXR3ZWVuIFwibGFzdEdlbmVyYXRlZENvbHVtblwiIGFuZFxuICAgICAgICAgIC8vIFwibWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cIiB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzWzBdO1xuICAgICAgICAgIHZhciBjb2RlID0gbmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICByZW1haW5pbmdMaW5lc1swXSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgY29kZSk7XG4gICAgICAgICAgLy8gTm8gbW9yZSByZW1haW5pbmcgY29kZSwgY29udGludWVcbiAgICAgICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBXZSBhZGQgdGhlIGdlbmVyYXRlZCBjb2RlIHVudGlsIHRoZSBmaXJzdCBtYXBwaW5nXG4gICAgICAvLyB0byB0aGUgU291cmNlTm9kZSB3aXRob3V0IGFueSBtYXBwaW5nLlxuICAgICAgLy8gRWFjaCBsaW5lIGlzIGFkZGVkIGFzIHNlcGFyYXRlIHN0cmluZy5cbiAgICAgIHdoaWxlIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICBub2RlLmFkZChzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgfVxuICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRDb2x1bW4gPCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikge1xuICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1swXTtcbiAgICAgICAgbm9kZS5hZGQobmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSk7XG4gICAgICAgIHJlbWFpbmluZ0xpbmVzWzBdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgfVxuICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgIH0sIHRoaXMpO1xuICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBtYXBwaW5ncy5cbiAgICBpZiAocmVtYWluaW5nTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKGxhc3RNYXBwaW5nKSB7XG4gICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgcmVtYWluaW5nIGNvZGUgaW4gdGhlIGN1cnJlbnQgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICB9XG4gICAgICAvLyBhbmQgYWRkIHRoZSByZW1haW5pbmcgbGluZXMgd2l0aG91dCBhbnkgbWFwcGluZ1xuICAgICAgbm9kZS5hZGQocmVtYWluaW5nTGluZXMuam9pbihcIlwiKSk7XG4gICAgfVxuXG4gICAgLy8gQ29weSBzb3VyY2VzQ29udGVudCBpbnRvIFNvdXJjZU5vZGVcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYVJlbGF0aXZlUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbm9kZTtcblxuICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmdXaXRoQ29kZShtYXBwaW5nLCBjb2RlKSB7XG4gICAgICBpZiAobWFwcGluZyA9PT0gbnVsbCB8fCBtYXBwaW5nLnNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGUuYWRkKGNvZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFSZWxhdGl2ZVBhdGhcbiAgICAgICAgICA/IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICA6IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBub2RlLmFkZChuZXcgU291cmNlTm9kZShtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8qKlxuICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoaXMgc291cmNlIG5vZGUuXG4gKlxuICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gU291cmNlTm9kZV9hZGQoYUNodW5rKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICBhQ2h1bmsuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIHRoaXMuYWRkKGNodW5rKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxuICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKGFDaHVuaykge1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGFDaHVuayk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBzb3VyY2Ugbm9kZS5cbiAqXG4gKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gU291cmNlTm9kZV9wcmVwZW5kKGFDaHVuaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgZm9yICh2YXIgaSA9IGFDaHVuay5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRoaXMucHJlcGVuZChhQ2h1bmtbaV0pO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgdGhpcy5jaGlsZHJlbi51bnNoaWZ0KGFDaHVuayk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXCIgKyBhQ2h1bmtcbiAgICApO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgSlMgc25pcHBldHMgaW4gdGhpcyBub2RlIGFuZCBpdHMgY2hpbGRyZW4uIFRoZVxuICogd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgb25jZSBmb3IgZWFjaCBzbmlwcGV0IG9mIEpTIGFuZCBpcyBwYXNzZWQgdGhhdFxuICogc25pcHBldCBhbmQgdGhlIGl0cyBvcmlnaW5hbCBhc3NvY2lhdGVkIHNvdXJjZSdzIGxpbmUvY29sdW1uIGxvY2F0aW9uLlxuICpcbiAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2FsayhhRm4pIHtcbiAgdmFyIGNodW5rO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNodW5rID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICBpZiAoY2h1bmtbaXNTb3VyY2VOb2RlXSkge1xuICAgICAgY2h1bmsud2FsayhhRm4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChjaHVuayAhPT0gJycpIHtcbiAgICAgICAgYUZuKGNodW5rLCB7IHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBMaWtlIGBTdHJpbmcucHJvdG90eXBlLmpvaW5gIGV4Y2VwdCBmb3IgU291cmNlTm9kZXMuIEluc2VydHMgYGFTdHJgIGJldHdlZW5cbiAqIGVhY2ggb2YgYHRoaXMuY2hpbGRyZW5gLlxuICpcbiAqIEBwYXJhbSBhU2VwIFRoZSBzZXBhcmF0b3IuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2pvaW4oYVNlcCkge1xuICB2YXIgbmV3Q2hpbGRyZW47XG4gIHZhciBpO1xuICB2YXIgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbmV3Q2hpbGRyZW4gPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuLTE7IGkrKykge1xuICAgICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICAgIG5ld0NoaWxkcmVuLnB1c2goYVNlcCk7XG4gICAgfVxuICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSBvbiB0aGUgdmVyeSByaWdodC1tb3N0IHNvdXJjZSBzbmlwcGV0LiBVc2VmdWxcbiAqIGZvciB0cmltbWluZyB3aGl0ZXNwYWNlIGZyb20gdGhlIGVuZCBvZiBhIHNvdXJjZSBub2RlLCBldGMuXG4gKlxuICogQHBhcmFtIGFQYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHJlcGxhY2UuXG4gKiBAcGFyYW0gYVJlcGxhY2VtZW50IFRoZSB0aGluZyB0byByZXBsYWNlIHRoZSBwYXR0ZXJuIHdpdGguXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnJlcGxhY2VSaWdodCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpIHtcbiAgdmFyIGxhc3RDaGlsZCA9IHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgaWYgKGxhc3RDaGlsZFtpc1NvdXJjZU5vZGVdKSB7XG4gICAgbGFzdENoaWxkLnJlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgfVxuICBlbHNlIGlmICh0eXBlb2YgbGFzdENoaWxkID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXSA9IGxhc3RDaGlsZC5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuY2hpbGRyZW4ucHVzaCgnJy5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS4gVGhpcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3JcbiAqIGluIHRoZSBzb3VyY2VzQ29udGVudCBmaWVsZC5cbiAqXG4gKiBAcGFyYW0gYVNvdXJjZUZpbGUgVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZVxuICogQHBhcmFtIGFTb3VyY2VDb250ZW50IFRoZSBjb250ZW50IG9mIHRoZSBzb3VyY2UgZmlsZVxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgIHRoaXMuc291cmNlQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhhU291cmNlRmlsZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gIH07XG5cbi8qKlxuICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIFNvdXJjZU5vZGVzLiBUaGUgd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIGVhY2hcbiAqIHNvdXJjZSBmaWxlIGNvbnRlbnQgYW5kIGlzIHBhc3NlZCB0aGUgZmlsZW5hbWUgYW5kIHNvdXJjZSBjb250ZW50LlxuICpcbiAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUud2Fsa1NvdXJjZUNvbnRlbnRzID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV93YWxrU291cmNlQ29udGVudHMoYUZuKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldW2lzU291cmNlTm9kZV0pIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpXS53YWxrU291cmNlQ29udGVudHMoYUZuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc291cmNlcyA9IE9iamVjdC5rZXlzKHRoaXMuc291cmNlQ29udGVudHMpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhRm4odXRpbC5mcm9tU2V0U3RyaW5nKHNvdXJjZXNbaV0pLCB0aGlzLnNvdXJjZUNvbnRlbnRzW3NvdXJjZXNbaV1dKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZS4gV2Fsa3Mgb3ZlciB0aGUgdHJlZVxuICogYW5kIGNvbmNhdGVuYXRlcyBhbGwgdGhlIHZhcmlvdXMgc25pcHBldHMgdG9nZXRoZXIgdG8gb25lIHN0cmluZy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nKCkge1xuICB2YXIgc3RyID0gXCJcIjtcbiAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHN0ciArPSBjaHVuaztcbiAgfSk7XG4gIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlIGFsb25nIHdpdGggYSBzb3VyY2VcbiAqIG1hcC5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmdXaXRoU291cmNlTWFwID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZ1dpdGhTb3VyY2VNYXAoYUFyZ3MpIHtcbiAgdmFyIGdlbmVyYXRlZCA9IHtcbiAgICBjb2RlOiBcIlwiLFxuICAgIGxpbmU6IDEsXG4gICAgY29sdW1uOiAwXG4gIH07XG4gIHZhciBtYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKTtcbiAgdmFyIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgdmFyIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgdmFyIGxhc3RPcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxOYW1lID0gbnVsbDtcbiAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaywgb3JpZ2luYWwpIHtcbiAgICBnZW5lcmF0ZWQuY29kZSArPSBjaHVuaztcbiAgICBpZiAob3JpZ2luYWwuc291cmNlICE9PSBudWxsXG4gICAgICAgICYmIG9yaWdpbmFsLmxpbmUgIT09IG51bGxcbiAgICAgICAgJiYgb3JpZ2luYWwuY29sdW1uICE9PSBudWxsKSB7XG4gICAgICBpZihsYXN0T3JpZ2luYWxTb3VyY2UgIT09IG9yaWdpbmFsLnNvdXJjZVxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTGluZSAhPT0gb3JpZ2luYWwubGluZVxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsQ29sdW1uICE9PSBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbE5hbWUgIT09IG9yaWdpbmFsLm5hbWUpIHtcbiAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICBsYXN0T3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgIGxhc3RPcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgIGxhc3RPcmlnaW5hbE5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGlkeCA9IDAsIGxlbmd0aCA9IGNodW5rLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgaWYgKGNodW5rLmNoYXJDb2RlQXQoaWR4KSA9PT0gTkVXTElORV9DT0RFKSB7XG4gICAgICAgIGdlbmVyYXRlZC5saW5lKys7XG4gICAgICAgIGdlbmVyYXRlZC5jb2x1bW4gPSAwO1xuICAgICAgICAvLyBNYXBwaW5ncyBlbmQgYXQgZW9sXG4gICAgICAgIGlmIChpZHggKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW5lcmF0ZWQuY29sdW1uKys7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdGhpcy53YWxrU291cmNlQ29udGVudHMoZnVuY3Rpb24gKHNvdXJjZUZpbGUsIHNvdXJjZUNvbnRlbnQpIHtcbiAgICBtYXAuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHsgY29kZTogZ2VuZXJhdGVkLmNvZGUsIG1hcDogbWFwIH07XG59O1xuXG5leHBvcnRzLlNvdXJjZU5vZGUgPSBTb3VyY2VOb2RlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3VnbGlmeS1qcy9+L3NvdXJjZS1tYXAvbGliL3NvdXJjZS1ub2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIGFzeW5jID0gcmVxdWlyZShcImFzeW5jXCIpO1xyXG5cclxuZnVuY3Rpb24gQ2FjaGVQbHVnaW4oY2FjaGUpIHtcclxuXHR0aGlzLmNhY2hlID0gY2FjaGUgfHwge307XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBDYWNoZVBsdWdpbjtcclxuXHJcbkNhY2hlUGx1Z2luLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKGNvbXBpbGVyKSB7XHJcblx0aWYoQXJyYXkuaXNBcnJheShjb21waWxlci5jb21waWxlcnMpKSB7XHJcblx0XHRjb21waWxlci5jb21waWxlcnMuZm9yRWFjaChmdW5jdGlvbihjLCBpZHgpIHtcclxuXHRcdFx0Yy5hcHBseShuZXcgQ2FjaGVQbHVnaW4odGhpcy5jYWNoZVtpZHhdID0gdGhpcy5jYWNoZVtpZHhdIHx8IHt9KSk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Y29tcGlsZXIucGx1Z2luKFwiY29tcGlsYXRpb25cIiwgZnVuY3Rpb24oY29tcGlsYXRpb24pIHtcclxuXHRcdFx0Y29tcGlsYXRpb24uY2FjaGUgPSB0aGlzLmNhY2hlO1xyXG5cdFx0fS5iaW5kKHRoaXMpKTtcclxuXHRcdGNvbXBpbGVyLnBsdWdpbihcInJ1blwiLCBmdW5jdGlvbihjb21waWxlciwgY2FsbGJhY2spIHtcclxuXHRcdFx0aWYoIWNvbXBpbGVyLl9sYXN0Q29tcGlsYXRpb25GaWxlRGVwZW5kZW5jaWVzKSByZXR1cm4gY2FsbGJhY2soKTtcclxuXHRcdFx0dmFyIGZzID0gY29tcGlsZXIuaW5wdXRGaWxlU3lzdGVtO1xyXG5cdFx0XHR2YXIgZmlsZVRzID0gY29tcGlsZXIuZmlsZVRpbWVzdGFtcHMgPSB7fTtcclxuXHRcdFx0YXN5bmMuZm9yRWFjaChjb21waWxlci5fbGFzdENvbXBpbGF0aW9uRmlsZURlcGVuZGVuY2llcywgZnVuY3Rpb24oZmlsZSwgY2FsbGJhY2spIHtcclxuXHRcdFx0XHRmcy5zdGF0KGZpbGUsIGZ1bmN0aW9uKGVyciwgc3RhdCkge1xyXG5cdFx0XHRcdFx0aWYoZXJyKSB7XHJcblx0XHRcdFx0XHRcdGlmKGVyci5jb2RlID09PSBcIkVOT0VOVFwiKSByZXR1cm4gY2FsbGJhY2soKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKGVycik7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0ZmlsZVRzW2ZpbGVdID0gc3RhdC5tdGltZSB8fCBJbmZpbml0eTtcclxuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0sIGNhbGxiYWNrKTtcclxuXHRcdH0pO1xyXG5cdFx0Y29tcGlsZXIucGx1Z2luKFwiYWZ0ZXItY29tcGlsZVwiLCBmdW5jdGlvbihjb21waWxhdGlvbiwgY2FsbGJhY2spIHtcclxuXHRcdFx0Y29tcGlsYXRpb24uY29tcGlsZXIuX2xhc3RDb21waWxhdGlvbkZpbGVEZXBlbmRlbmNpZXMgPSBjb21waWxhdGlvbi5maWxlRGVwZW5kZW5jaWVzO1xyXG5cdFx0XHRjb21waWxhdGlvbi5jb21waWxlci5fbGFzdENvbXBpbGF0aW9uQ29udGV4dERlcGVuZGVuY2llcyA9IGNvbXBpbGF0aW9uLmNvbnRleHREZXBlbmRlbmNpZXM7XHJcblx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHR9KTtcclxuXHR9XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvQ2FjaGVQbHVnaW4uanNcbi8vIG1vZHVsZSBpZCA9IDMzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgTW9kdWxlUGFyc2VySGVscGVycyA9IHJlcXVpcmUoXCIuL01vZHVsZVBhcnNlckhlbHBlcnNcIik7XHJcbnZhciBDb25zdERlcGVuZGVuY3kgPSByZXF1aXJlKFwiLi9kZXBlbmRlbmNpZXMvQ29uc3REZXBlbmRlbmN5XCIpO1xyXG5cclxudmFyIE51bGxGYWN0b3J5ID0gcmVxdWlyZShcIi4vTnVsbEZhY3RvcnlcIik7XHJcblxyXG5mdW5jdGlvbiBQcm92aWRlUGx1Z2luKGRlZmluaXRpb25zKSB7XHJcblx0dGhpcy5kZWZpbml0aW9ucyA9IGRlZmluaXRpb25zO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gUHJvdmlkZVBsdWdpbjtcclxuUHJvdmlkZVBsdWdpbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbihjb21waWxlcikge1xyXG5cdGNvbXBpbGVyLnBsdWdpbihcImNvbXBpbGF0aW9uXCIsIGZ1bmN0aW9uKGNvbXBpbGF0aW9uKSB7XHJcblx0XHRjb21waWxhdGlvbi5kZXBlbmRlbmN5RmFjdG9yaWVzLnNldChDb25zdERlcGVuZGVuY3ksIG5ldyBOdWxsRmFjdG9yeSgpKTtcclxuXHRcdGNvbXBpbGF0aW9uLmRlcGVuZGVuY3lUZW1wbGF0ZXMuc2V0KENvbnN0RGVwZW5kZW5jeSwgbmV3IENvbnN0RGVwZW5kZW5jeS5UZW1wbGF0ZSgpKTtcclxuXHR9KTtcclxuXHRPYmplY3Qua2V5cyh0aGlzLmRlZmluaXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcclxuXHRcdHZhciByZXF1ZXN0ID0gdGhpcy5kZWZpbml0aW9uc1tuYW1lXTtcclxuXHRcdHZhciBzcGxpdHRlZE5hbWUgPSBuYW1lLnNwbGl0KFwiLlwiKTtcclxuXHRcdGlmKHNwbGl0dGVkTmFtZS5sZW5ndGggPiAwKSB7XHJcblx0XHRcdHNwbGl0dGVkTmFtZS5zbGljZSgxKS5mb3JFYWNoKGZ1bmN0aW9uKF8sIGkpIHtcclxuXHRcdFx0XHR2YXIgbmFtZSA9IHNwbGl0dGVkTmFtZS5zbGljZSgwLCBpICsgMSkuam9pbihcIi5cIik7XHJcblx0XHRcdFx0Y29tcGlsZXIucGFyc2VyLnBsdWdpbihcImNhbi1yZW5hbWUgXCIgKyBuYW1lLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHRcdGNvbXBpbGVyLnBhcnNlci5wbHVnaW4oXCJleHByZXNzaW9uIFwiICsgbmFtZSwgZnVuY3Rpb24oZXhwcikge1xyXG5cdFx0XHR2YXIgbmFtZUlkZW50aWZpZXIgPSBuYW1lO1xyXG5cdFx0XHR2YXIgc2NvcGVkTmFtZSA9IG5hbWUuaW5kZXhPZihcIi5cIikgPj0gMDtcclxuXHRcdFx0aWYoc2NvcGVkTmFtZSkge1xyXG5cdFx0XHRcdG5hbWVJZGVudGlmaWVyID0gXCJfX3dlYnBhY2tfcHJvdmlkZWRfXCIgKyBuYW1lLnJlcGxhY2UoL1xcLi9nLCBcIl9kb3RfXCIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKCFNb2R1bGVQYXJzZXJIZWxwZXJzLmFkZFBhcnNlZFZhcmlhYmxlKHRoaXMsIG5hbWVJZGVudGlmaWVyLCBcInJlcXVpcmUoXCIgKyBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSArIFwiKVwiKSkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihzY29wZWROYW1lKSB7XHJcblx0XHRcdFx0bmFtZUlkZW50aWZpZXIgPSBcIl9fd2VicGFja19wcm92aWRlZF9cIiArIG5hbWUucmVwbGFjZSgvXFwuL2csIFwiX2RvdF9cIik7XHJcblx0XHRcdFx0dmFyIGRlcCA9IG5ldyBDb25zdERlcGVuZGVuY3kobmFtZUlkZW50aWZpZXIsIGV4cHIucmFuZ2UpO1xyXG5cdFx0XHRcdGRlcC5sb2MgPSBleHByLmxvYztcclxuXHRcdFx0XHR0aGlzLnN0YXRlLmN1cnJlbnQuYWRkRGVwZW5kZW5jeShkZXApO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSk7XHJcblx0fSwgdGhpcyk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvUHJvdmlkZVBsdWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMzM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBPcHRpb25zRGVmYXVsdGVyID0gcmVxdWlyZShcIndlYnBhY2stY29yZS9saWIvT3B0aW9uc0RlZmF1bHRlclwiKTtcclxuXHJcbmZ1bmN0aW9uIFdlYnBhY2tPcHRpb25zRGVmYXVsdGVyKCkge1xyXG5cdE9wdGlvbnNEZWZhdWx0ZXIuY2FsbCh0aGlzKTtcclxuXHR0aGlzLnNldChcImRlYnVnXCIsIGZhbHNlKTtcclxuXHR0aGlzLnNldChcImRldnRvb2xcIiwgZmFsc2UpO1xyXG5cdHRoaXMuc2V0KFwiY2FjaGVcIiwgdHJ1ZSk7XHJcblxyXG5cdHRoaXMuc2V0KFwiY29udGV4dFwiLCBwcm9jZXNzLmN3ZCgpKTtcclxuXHR0aGlzLnNldChcInRhcmdldFwiLCBcIndlYlwiKTtcclxuXHR0aGlzLnNldChcIm91dHB1dFwiLCB7fSk7XHJcblx0dGhpcy5zZXQoXCJub2RlXCIsIHt9KTtcclxuXHR0aGlzLnNldChcInJlc29sdmVcIiwge30pO1xyXG5cdHRoaXMuc2V0KFwicmVzb2x2ZUxvYWRlclwiLCB7fSk7XHJcblxyXG5cdHRoaXMuc2V0KFwibW9kdWxlLnVua25vd25Db250ZXh0UmVxdWVzdFwiLCBcIi5cIik7XHJcblx0dGhpcy5zZXQoXCJtb2R1bGUudW5rbm93bkNvbnRleHRSZWN1cnNpdmVcIiwgdHJ1ZSk7XHJcblx0dGhpcy5zZXQoXCJtb2R1bGUudW5rbm93bkNvbnRleHRSZWdFeHBcIiwgL15cXC5cXC8uKiQvKTtcclxuXHR0aGlzLnNldChcIm1vZHVsZS51bmtub3duQ29udGV4dENyaXRpY2FsXCIsIHRydWUpO1xyXG5cdHRoaXMuc2V0KFwibW9kdWxlLmV4cHJDb250ZXh0UmVxdWVzdFwiLCBcIi5cIik7XHJcblx0dGhpcy5zZXQoXCJtb2R1bGUuZXhwckNvbnRleHRSZWdFeHBcIiwgL15cXC5cXC8uKiQvKTtcclxuXHR0aGlzLnNldChcIm1vZHVsZS5leHByQ29udGV4dFJlY3Vyc2l2ZVwiLCB0cnVlKTtcclxuXHR0aGlzLnNldChcIm1vZHVsZS5leHByQ29udGV4dENyaXRpY2FsXCIsIHRydWUpO1xyXG5cdHRoaXMuc2V0KFwibW9kdWxlLndyYXBwZWRDb250ZXh0UmVnRXhwXCIsIC8uKi8pO1xyXG5cdHRoaXMuc2V0KFwibW9kdWxlLndyYXBwZWRDb250ZXh0UmVjdXJzaXZlXCIsIHRydWUpO1xyXG5cdHRoaXMuc2V0KFwibW9kdWxlLndyYXBwZWRDb250ZXh0Q3JpdGljYWxcIiwgZmFsc2UpO1xyXG5cclxuXHR0aGlzLnNldChcIm91dHB1dC5saWJyYXJ5VGFyZ2V0XCIsIFwidmFyXCIpO1xyXG5cdHRoaXMuc2V0KFwib3V0cHV0LnBhdGhcIiwgXCJcIik7XHJcblx0dGhpcy5zZXQoXCJvdXRwdXQuc291cmNlTWFwRmlsZW5hbWVcIiwgXCJbZmlsZV0ubWFwW3F1ZXJ5XVwiKTtcclxuXHR0aGlzLnNldChcIm91dHB1dC5ob3RVcGRhdGVDaHVua0ZpbGVuYW1lXCIsIFwiW2lkXS5baGFzaF0uaG90LXVwZGF0ZS5qc1wiKTtcclxuXHR0aGlzLnNldChcIm91dHB1dC5ob3RVcGRhdGVNYWluRmlsZW5hbWVcIiwgXCJbaGFzaF0uaG90LXVwZGF0ZS5qc29uXCIpO1xyXG5cdHRoaXMuc2V0KFwib3V0cHV0LmNyb3NzT3JpZ2luTG9hZGluZ1wiLCBmYWxzZSk7XHJcblx0dGhpcy5zZXQoXCJvdXRwdXQuaGFzaEZ1bmN0aW9uXCIsIFwibWQ1XCIpO1xyXG5cdHRoaXMuc2V0KFwib3V0cHV0Lmhhc2hEaWdlc3RcIiwgXCJoZXhcIik7XHJcblx0dGhpcy5zZXQoXCJvdXRwdXQuaGFzaERpZ2VzdExlbmd0aFwiLCAyMCk7XHJcblx0dGhpcy5zZXQoXCJvdXRwdXQuc291cmNlUHJlZml4XCIsIFwiXFx0XCIpO1xyXG5cdHRoaXMuc2V0KFwib3V0cHV0LmRldnRvb2xMaW5lVG9MaW5lXCIsIGZhbHNlKTtcclxuXHJcblx0dGhpcy5zZXQoXCJub2RlLmNvbnNvbGVcIiwgZmFsc2UpO1xyXG5cdHRoaXMuc2V0KFwibm9kZS5wcm9jZXNzXCIsIHRydWUpO1xyXG5cdHRoaXMuc2V0KFwibm9kZS5nbG9iYWxcIiwgdHJ1ZSk7XHJcblx0Ly8gVE9ETzogYWRkIHRoaXMgaW4gbmV4dCBtYWpvciB2ZXJzaW9uXHJcblx0Ly8gdGhpcy5zZXQoXCJub2RlLkJ1ZmZlclwiLCB0cnVlKTtcclxuXHR0aGlzLnNldChcIm5vZGUuc2V0SW1tZWRpYXRlXCIsIHRydWUpO1xyXG5cdHRoaXMuc2V0KFwibm9kZS5fX2ZpbGVuYW1lXCIsIFwibW9ja1wiKTtcclxuXHR0aGlzLnNldChcIm5vZGUuX19kaXJuYW1lXCIsIFwibW9ja1wiKTtcclxuXHJcblx0dGhpcy5zZXQoXCJyZXNvbHZlLmZhc3RVbnNhZmVcIiwgW10pO1xyXG5cdHRoaXMuc2V0KFwicmVzb2x2ZUxvYWRlci5mYXN0VW5zYWZlXCIsIFtdKTtcclxuXHJcblx0dGhpcy5zZXQoXCJyZXNvbHZlLmFsaWFzXCIsIHt9KTtcclxuXHR0aGlzLnNldChcInJlc29sdmVMb2FkZXIuYWxpYXNcIiwge30pO1xyXG5cclxuXHR0aGlzLnNldChcIm9wdGltaXplLm9jY3VyZW5jZU9yZGVyUHJlZmVyRW50cnlcIiwgdHJ1ZSk7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBXZWJwYWNrT3B0aW9uc0RlZmF1bHRlcjtcclxuXHJcbldlYnBhY2tPcHRpb25zRGVmYXVsdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoT3B0aW9uc0RlZmF1bHRlci5wcm90b3R5cGUpO1xyXG5cclxuV2VicGFja09wdGlvbnNEZWZhdWx0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV2VicGFja09wdGlvbnNEZWZhdWx0ZXI7XHJcblxyXG5XZWJwYWNrT3B0aW9uc0RlZmF1bHRlci5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHRPcHRpb25zRGVmYXVsdGVyLnByb3RvdHlwZS5wcm9jZXNzLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdGlmKG9wdGlvbnMucmVzb2x2ZS5wYWNrYWdlQWxpYXMgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0aWYob3B0aW9ucy50YXJnZXQgPT09IFwid2ViXCIgfHwgb3B0aW9ucy50YXJnZXQgPT09IFwid2Vid29ya2VyXCIpXHJcblx0XHRcdG9wdGlvbnMucmVzb2x2ZS5wYWNrYWdlQWxpYXMgPSBcImJyb3dzZXJcIjtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGRlZmF1bHRCeVRhcmdldCh2YWx1ZSwgd2ViLCB3ZWJ3b3JrZXIsIG5vZGUsIG5vZGVXZWJraXQsIGRlZikge1xyXG5cdFx0aWYodmFsdWUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHZhbHVlO1xyXG5cdFx0c3dpdGNoKG9wdGlvbnMudGFyZ2V0KSB7XHJcblx0XHRcdGNhc2UgXCJ3ZWJcIjpcclxuXHRcdFx0XHRyZXR1cm4gd2ViO1xyXG5cdFx0XHRjYXNlIFwid2Vid29ya2VyXCI6XHJcblx0XHRcdFx0cmV0dXJuIHdlYndvcmtlcjtcclxuXHRcdFx0Y2FzZSBcIm5vZGVcIjpcclxuXHRcdFx0Y2FzZSBcImFzeW5jLW5vZGVcIjpcclxuXHRcdFx0XHRyZXR1cm4gbm9kZTtcclxuXHRcdFx0Y2FzZSBcIm5vZGUtd2Via2l0XCI6XHJcblx0XHRcdFx0cmV0dXJuIG5vZGVXZWJraXQ7XHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0cmV0dXJuIGRlZjtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdG9wdGlvbnMucmVzb2x2ZS5tb2R1bGVzRGlyZWN0b3JpZXMgPSBkZWZhdWx0QnlUYXJnZXQob3B0aW9ucy5yZXNvbHZlLm1vZHVsZXNEaXJlY3RvcmllcywgW1wid2ViX21vZHVsZXNcIiwgXCJub2RlX21vZHVsZXNcIl0sIFtcIndlYndvcmtlcl9tb2R1bGVzXCIsIFwid2ViX21vZHVsZXNcIiwgXCJub2RlX21vZHVsZXNcIl0sIFtcIm5vZGVfbW9kdWxlc1wiXSwgW1wibm9kZV9tb2R1bGVzXCIsIFwid2ViX21vZHVsZXNcIl0sIFtcIm5vZGVfbW9kdWxlc1wiXSk7XHJcblxyXG5cdG9wdGlvbnMucmVzb2x2ZUxvYWRlci5tb2R1bGVzRGlyZWN0b3JpZXMgPSBkZWZhdWx0QnlUYXJnZXQob3B0aW9ucy5yZXNvbHZlTG9hZGVyLm1vZHVsZXNEaXJlY3RvcmllcywgW1wid2ViX2xvYWRlcnNcIiwgXCJ3ZWJfbW9kdWxlc1wiLCBcIm5vZGVfbG9hZGVyc1wiLCBcIm5vZGVfbW9kdWxlc1wiXSwgW1wid2Vid29ya2VyX2xvYWRlcnNcIiwgXCJ3ZWJfbG9hZGVyc1wiLCBcIndlYl9tb2R1bGVzXCIsIFwibm9kZV9sb2FkZXJzXCIsIFwibm9kZV9tb2R1bGVzXCJdLCBbXCJub2RlX2xvYWRlcnNcIiwgXCJub2RlX21vZHVsZXNcIl0sIFtcIm5vZGVfbG9hZGVyc1wiLCBcIndlYl9sb2FkZXJzXCIsIFwibm9kZV9tb2R1bGVzXCIsIFwid2ViX21vZHVsZXNcIl0sIFtcIm5vZGVfbW9kdWxlc1wiXSk7XHJcblxyXG5cdG9wdGlvbnMucmVzb2x2ZS5wYWNrYWdlTWFpbnMgPSBkZWZhdWx0QnlUYXJnZXQob3B0aW9ucy5yZXNvbHZlLnBhY2thZ2VNYWlucywgW1wid2VicGFja1wiLCBcImJyb3dzZXJcIiwgXCJ3ZWJcIiwgXCJicm93c2VyaWZ5XCIsIFtcImphbVwiLCBcIm1haW5cIl0sIFwibWFpblwiXSwgW1wid2VicGFja1dvcmtlclwiLCBcIndlYndvcmtlclwiLCBcIndlYnBhY2tcIiwgXCJicm93c2VyXCIsIFwid2ViXCIsIFwiYnJvd3NlcmlmeVwiLCBbXCJqYW1cIiwgXCJtYWluXCJdLCBcIm1haW5cIl0sIFtcIndlYnBhY2tOb2RlXCIsIFwibm9kZVwiLCBcIm1haW5cIl0sIFtcIndlYnBhY2tOb2RlV2Via2l0XCIsIFwid2VicGFja05vZGVcIiwgXCJub2RlXCIsIFwibWFpblwiLCBcIndlYlwiXSwgW1wibWFpblwiXSk7XHJcblxyXG5cdG9wdGlvbnMucmVzb2x2ZS5wYWNrYWdlQWxpYXMgPSBkZWZhdWx0QnlUYXJnZXQob3B0aW9ucy5yZXNvbHZlLnBhY2thZ2VBbGlhcyxcclxuXHRcdFwiYnJvd3NlclwiLFxyXG5cdFx0XCJicm93c2VyXCIsXHJcblx0XHRmYWxzZSxcclxuXHRcdFwibm9kZS13ZWJraXRcIixcclxuXHRcdGZhbHNlKTtcclxuXHJcblx0b3B0aW9ucy5yZXNvbHZlTG9hZGVyLnBhY2thZ2VNYWlucyA9IGRlZmF1bHRCeVRhcmdldChvcHRpb25zLnJlc29sdmVMb2FkZXIucGFja2FnZU1haW5zLCBbXCJ3ZWJwYWNrTG9hZGVyXCIsIFwid2ViTG9hZGVyXCIsIFwibG9hZGVyXCIsIFwibWFpblwiXSwgW1wid2VicGFja1dvcmtlckxvYWRlclwiLCBcIndlYndvcmtlckxvYWRlclwiLCBcIndlYkxvYWRlclwiLCBcImxvYWRlclwiLCBcIm1haW5cIl0sIFtcIndlYnBhY2tOb2RlTG9hZGVyXCIsIFwibm9kZUxvYWRlclwiLCBcImxvYWRlclwiLCBcIm1haW5cIl0sIFtcIndlYnBhY2tOb2RlV2Via2l0TG9hZGVyXCIsIFwid2VicGFja05vZGVMb2FkZXJcIiwgXCJub2RlTG9hZGVyXCIsIFwibG9hZGVyXCIsIFwid2ViTG9hZGVyXCIsIFwibWFpblwiXSwgW1wibG9hZGVyXCIsIFwibWFpblwiXSk7XHJcblxyXG5cdG9wdGlvbnMucmVzb2x2ZS5leHRlbnNpb25zID0gZGVmYXVsdEJ5VGFyZ2V0KG9wdGlvbnMucmVzb2x2ZS5leHRlbnNpb25zLCBbXCJcIiwgXCIud2VicGFjay5qc1wiLCBcIi53ZWIuanNcIiwgXCIuanNcIiwgXCIuanNvblwiXSwgW1wiXCIsIFwiLndlYnBhY2std29ya2VyLmpzXCIsIFwiLndlYndvcmtlci5qc1wiLCBcIi53ZWIuanNcIiwgXCIuanNcIiwgXCIuanNvblwiXSwgW1wiXCIsIFwiLndlYnBhY2stbm9kZS5qc1wiLCBcIi5qc1wiLCBcIi5qc29uXCIsIFwiLm5vZGVcIl0sIFtcIlwiLCBcIi53ZWJwYWNrLW5vZGUtd2Via2l0LmpzXCIsIFwiLndlYnBhY2stbm9kZS5qc1wiLCBcIi5qc1wiLCBcIi5qc29uXCIsIFwiLm5vZGVcIiwgXCIud2ViLmpzXCJdLCBbXCJcIiwgXCIuanNcIiwgXCIuanNvblwiXSk7XHJcblxyXG5cdG9wdGlvbnMucmVzb2x2ZUxvYWRlci5leHRlbnNpb25zID0gZGVmYXVsdEJ5VGFyZ2V0KG9wdGlvbnMucmVzb2x2ZUxvYWRlci5leHRlbnNpb25zLCBbXCJcIiwgXCIud2VicGFjay1sb2FkZXIuanNcIiwgXCIud2ViLWxvYWRlci5qc1wiLCBcIi5sb2FkZXIuanNcIiwgXCIuanNcIl0sIFtcIlwiLCBcIi53ZWJwYWNrLXdvcmtlci1sb2FkZXIuanNcIiwgXCIud2VicGFjay1sb2FkZXIuanNcIiwgXCIud2Vid29ya2VyLWxvYWRlci5qc1wiLCBcIi53ZWItbG9hZGVyLmpzXCIsIFwiLmxvYWRlci5qc1wiLCBcIi5qc1wiXSwgW1wiXCIsIFwiLndlYnBhY2stbm9kZS1sb2FkZXIuanNcIiwgXCIubG9hZGVyLmpzXCIsIFwiLmpzXCJdLCBbXCJcIiwgXCIud2VicGFjay1ub2RlLXdlYmtpdC1sb2FkZXIuanNcIiwgXCIud2VicGFjay1ub2RlLWxvYWRlci5qc1wiLCBcIi5sb2FkZXIuanNcIiwgXCIud2ViLWxvYWRlci5qc1wiLCBcIi5qc1wiXSwgW1wiXCIsIFwiLmpzXCJdKTtcclxuXHJcblx0b3B0aW9ucy5yZXNvbHZlTG9hZGVyLm1vZHVsZVRlbXBsYXRlcyA9IGRlZmF1bHRCeVRhcmdldChvcHRpb25zLnJlc29sdmVMb2FkZXIubW9kdWxlVGVtcGxhdGVzLCBbXCIqLXdlYnBhY2stbG9hZGVyXCIsIFwiKi13ZWItbG9hZGVyXCIsIFwiKi1sb2FkZXJcIiwgXCIqXCJdLCBbXCIqLXdlYnBhY2std29ya2VyLWxvYWRlclwiLCBcIiotd2Vid29ya2VyLWxvYWRlclwiLCBcIiotd2ViLWxvYWRlclwiLCBcIiotbG9hZGVyXCIsIFwiKlwiXSwgW1wiKi13ZWJwYWNrLW5vZGUtbG9hZGVyXCIsIFwiKi1ub2RlLWxvYWRlclwiLCBcIiotbG9hZGVyXCIsIFwiKlwiXSwgW1wiKi13ZWJwYWNrLW5vZGUtd2Via2l0LWxvYWRlclwiLCBcIiotd2VicGFjay1ub2RlLWxvYWRlclwiLCBcIiotbm9kZS1sb2FkZXJcIiwgXCIqLWxvYWRlclwiLCBcIiotd2ViLWxvYWRlclwiLCBcIipcIl0sIFtcIiotbG9hZGVyXCIsIFwiKlwiXSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9saWIvV2VicGFja09wdGlvbnNEZWZhdWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG5mdW5jdGlvbiBPcHRpb25zRGVmYXVsdGVyKCkge1xyXG5cdHRoaXMuZGVmYXVsdHMgPSB7fTtcclxuXHR0aGlzLmNvbmZpZyA9IHt9O1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gT3B0aW9uc0RlZmF1bHRlcjtcclxuXHJcbmZ1bmN0aW9uIGdldFByb3BlcnR5KG9iaiwgbmFtZSkge1xyXG5cdG5hbWUgPSBuYW1lLnNwbGl0KFwiLlwiKTtcclxuXHRmb3IodmFyIGkgPSAwOyBpIDwgbmFtZS5sZW5ndGggLSAxOyBpKyspIHtcclxuXHRcdG9iaiA9IG9ialtuYW1lW2ldXTtcclxuXHRcdGlmKHR5cGVvZiBvYmogIT0gXCJvYmplY3RcIiB8fCAhb2JqKSByZXR1cm47XHJcblx0fVxyXG5cdHJldHVybiBvYmpbbmFtZS5wb3AoKV07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNldFByb3BlcnR5KG9iaiwgbmFtZSwgdmFsdWUpIHtcclxuXHRuYW1lID0gbmFtZS5zcGxpdChcIi5cIik7XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IG5hbWUubGVuZ3RoIC0gMTsgaSsrKSB7XHJcblx0XHRpZih0eXBlb2YgKG9ialtuYW1lW2ldXSkgIT09IFwib2JqZWN0XCIgfHwgIW9ialtuYW1lW2ldXSkgb2JqW25hbWVbaV1dID0ge307XHJcblx0XHRvYmogPSBvYmpbbmFtZVtpXV07XHJcblx0fVxyXG5cdG9ialtuYW1lLnBvcCgpXSA9IHZhbHVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoYXNQcm9wZXJ0eShvYmosIG5hbWUsIHZhbHVlKSB7XHJcblx0bmFtZSA9IG5hbWUuc3BsaXQoXCIuXCIpO1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aCAtIDE7IGkrKykge1xyXG5cdFx0b2JqID0gb2JqW25hbWVbaV1dO1xyXG5cdFx0aWYodHlwZW9mIG9iaiAhPSBcIm9iamVjdFwiIHx8ICFvYmopIHJldHVybiBmYWxzZTtcclxuXHR9XHJcblx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIG5hbWUucG9wKCkpO1xyXG59XHJcblxyXG5PcHRpb25zRGVmYXVsdGVyLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdGZvcih2YXIgbmFtZSBpbiB0aGlzLmRlZmF1bHRzKSB7XHJcblx0XHRzd2l0Y2godGhpcy5jb25maWdbbmFtZV0pIHtcclxuXHRcdGNhc2UgdW5kZWZpbmVkOlxyXG5cdFx0XHRpZihnZXRQcm9wZXJ0eShvcHRpb25zLCBuYW1lKSA9PT0gdW5kZWZpbmVkKVxyXG5cdFx0XHRcdHNldFByb3BlcnR5KG9wdGlvbnMsIG5hbWUsIHRoaXMuZGVmYXVsdHNbbmFtZV0pO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgXCJjYWxsXCI6XHJcblx0XHRcdHNldFByb3BlcnR5KG9wdGlvbnMsIG5hbWUsIHRoaXMuZGVmYXVsdHNbbmFtZV0uY2FsbCh0aGlzLCBnZXRQcm9wZXJ0eShvcHRpb25zLCBuYW1lKSksIG9wdGlvbnMpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgXCJhcHBlbmRcIjpcclxuXHRcdFx0dmFyIG9sZFZhbHVlID0gZ2V0UHJvcGVydHkob3B0aW9ucywgbmFtZSk7XHJcblx0XHRcdGlmKCFBcnJheS5pc0FycmF5KG9sZFZhbHVlKSkgb2xkVmFsdWUgPSBbXTtcclxuXHRcdFx0dGhpcy5kZWZhdWx0c1tuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHRcdFx0XHRvbGRWYWx1ZS5wdXNoKGl0ZW0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0c2V0UHJvcGVydHkob3B0aW9ucywgbmFtZSwgb2xkVmFsdWUpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIk9wdGlvbnNEZWZhdWx0ZXIgY2Fubm90IHByb2Nlc3MgXCIgKyB0aGlzLmNvbmZpZ1tuYW1lXSk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuT3B0aW9uc0RlZmF1bHRlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgY29uZmlnLCBkZWYpIHtcclxuXHRpZihhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XHJcblx0XHR0aGlzLmRlZmF1bHRzW25hbWVdID0gZGVmO1xyXG5cdFx0dGhpcy5jb25maWdbbmFtZV0gPSBjb25maWc7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRoaXMuZGVmYXVsdHNbbmFtZV0gPSBjb25maWc7XHJcblx0XHRkZWxldGUgdGhpcy5jb25maWdbbmFtZV07XHJcblx0fVxyXG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spLWNvcmUvbGliL09wdGlvbnNEZWZhdWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgQ29uY2F0U291cmNlID0gcmVxdWlyZShcIndlYnBhY2stc291cmNlc1wiKS5Db25jYXRTb3VyY2U7XHJcbnZhciBhc3luYyA9IHJlcXVpcmUoXCJhc3luY1wiKTtcclxudmFyIEV4dHJhY3RlZE1vZHVsZSA9IHJlcXVpcmUoXCIuL0V4dHJhY3RlZE1vZHVsZVwiKTtcclxudmFyIENodW5rID0gcmVxdWlyZShcIndlYnBhY2svbGliL0NodW5rXCIpO1xyXG52YXIgT3JkZXJVbmRlZmluZWRFcnJvciA9IHJlcXVpcmUoXCIuL09yZGVyVW5kZWZpbmVkRXJyb3JcIik7XHJcbnZhciBsb2FkZXJVdGlscyA9IHJlcXVpcmUoXCJsb2FkZXItdXRpbHNcIik7XHJcblxyXG52YXIgbmV4dElkID0gMDtcclxuXHJcbmZ1bmN0aW9uIEV4dHJhY3RUZXh0UGx1Z2luQ29tcGlsYXRpb24oKSB7XHJcblx0dGhpcy5tb2R1bGVzQnlJZGVudGlmaWVyID0ge307XHJcbn1cclxuXHJcbkV4dHJhY3RUZXh0UGx1Z2luLnByb3RvdHlwZS5tZXJnZU5vbkluaXRpYWxDaHVua3MgPSBmdW5jdGlvbihjaHVuaywgaW50b0NodW5rLCBjaGVja2VkQ2h1bmtzKSB7XHJcblx0aWYoIWludG9DaHVuaykge1xyXG5cdFx0Y2hlY2tlZENodW5rcyA9IFtdO1xyXG5cdFx0Y2h1bmsuY2h1bmtzLmZvckVhY2goZnVuY3Rpb24oYykge1xyXG5cdFx0XHRpZihjLmluaXRpYWwpIHJldHVybjtcclxuXHRcdFx0dGhpcy5tZXJnZU5vbkluaXRpYWxDaHVua3MoYywgY2h1bmssIGNoZWNrZWRDaHVua3MpO1xyXG5cdFx0fSwgdGhpcyk7XHJcblx0fSBlbHNlIGlmKGNoZWNrZWRDaHVua3MuaW5kZXhPZihjaHVuaykgPCAwKSB7XHJcblx0XHRjaGVja2VkQ2h1bmtzLnB1c2goY2h1bmspO1xyXG5cdFx0Y2h1bmsubW9kdWxlcy5zbGljZSgpLmZvckVhY2goZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0XHRcdGludG9DaHVuay5hZGRNb2R1bGUobW9kdWxlKTtcclxuXHRcdFx0bW9kdWxlLmFkZENodW5rKGludG9DaHVuayk7XHJcblx0XHR9KTtcclxuXHRcdGNodW5rLmNodW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcclxuXHRcdFx0aWYoYy5pbml0aWFsKSByZXR1cm47XHJcblx0XHRcdHRoaXMubWVyZ2VOb25Jbml0aWFsQ2h1bmtzKGMsIGludG9DaHVuaywgY2hlY2tlZENodW5rcyk7XHJcblx0XHR9LCB0aGlzKTtcclxuXHR9XHJcbn07XHJcblxyXG5FeHRyYWN0VGV4dFBsdWdpbkNvbXBpbGF0aW9uLnByb3RvdHlwZS5hZGRNb2R1bGUgPSBmdW5jdGlvbihpZGVudGlmaWVyLCBvcmlnaW5hbE1vZHVsZSwgc291cmNlLCBhZGRpdGlvbmFsSW5mb3JtYXRpb24sIHNvdXJjZU1hcCwgcHJldk1vZHVsZXMpIHtcclxuXHR2YXIgbTtcclxuXHRpZighdGhpcy5tb2R1bGVzQnlJZGVudGlmaWVyW2lkZW50aWZpZXJdKSB7XHJcblx0XHRtID0gdGhpcy5tb2R1bGVzQnlJZGVudGlmaWVyW2lkZW50aWZpZXJdID0gbmV3IEV4dHJhY3RlZE1vZHVsZShpZGVudGlmaWVyLCBvcmlnaW5hbE1vZHVsZSwgc291cmNlLCBzb3VyY2VNYXAsIGFkZGl0aW9uYWxJbmZvcm1hdGlvbiwgcHJldk1vZHVsZXMpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRtID0gdGhpcy5tb2R1bGVzQnlJZGVudGlmaWVyW2lkZW50aWZpZXJdO1xyXG5cdFx0bS5hZGRQcmV2TW9kdWxlcyhwcmV2TW9kdWxlcyk7XHJcblx0XHRpZihvcmlnaW5hbE1vZHVsZS5pbmRleDIgPCBtLmdldE9yaWdpbmFsTW9kdWxlKCkuaW5kZXgyKSB7XHJcblx0XHRcdG0uc2V0T3JpZ2luYWxNb2R1bGUob3JpZ2luYWxNb2R1bGUpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gbTtcclxufTtcclxuXHJcbkV4dHJhY3RUZXh0UGx1Z2luQ29tcGlsYXRpb24ucHJvdG90eXBlLmFkZFJlc3VsdFRvQ2h1bmsgPSBmdW5jdGlvbihpZGVudGlmaWVyLCByZXN1bHQsIG9yaWdpbmFsTW9kdWxlLCBleHRyYWN0ZWRDaHVuaykge1xyXG5cdGlmKCFBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcclxuXHRcdHJlc3VsdCA9IFtbaWRlbnRpZmllciwgcmVzdWx0XV07XHJcblx0fVxyXG5cdHZhciBjb3VudGVyTWFwID0ge307XHJcblx0dmFyIHByZXZNb2R1bGVzID0gW107XHJcblx0cmVzdWx0LmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xyXG5cdFx0dmFyIGMgPSBjb3VudGVyTWFwW2l0ZW1bMF1dO1xyXG5cdFx0dmFyIG1vZHVsZSA9IHRoaXMuYWRkTW9kdWxlLmNhbGwodGhpcywgaXRlbVswXSArIChjIHx8IFwiXCIpLCBvcmlnaW5hbE1vZHVsZSwgaXRlbVsxXSwgaXRlbVsyXSwgaXRlbVszXSwgcHJldk1vZHVsZXMuc2xpY2UoKSk7XHJcblx0XHRleHRyYWN0ZWRDaHVuay5hZGRNb2R1bGUobW9kdWxlKTtcclxuXHRcdG1vZHVsZS5hZGRDaHVuayhleHRyYWN0ZWRDaHVuayk7XHJcblx0XHRjb3VudGVyTWFwW2l0ZW1bMF1dID0gKGMgfHwgMCkgKyAxO1xyXG5cdFx0cHJldk1vZHVsZXMucHVzaChtb2R1bGUpO1xyXG5cdH0sIHRoaXMpO1xyXG59O1xyXG5cclxuRXh0cmFjdFRleHRQbHVnaW4ucHJvdG90eXBlLnJlbmRlckV4dHJhY3RlZENodW5rID0gZnVuY3Rpb24oY2h1bmspIHtcclxuXHR2YXIgc291cmNlID0gbmV3IENvbmNhdFNvdXJjZSgpO1xyXG5cdGNodW5rLm1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRcdHZhciBtb2R1bGVTb3VyY2UgPSBtb2R1bGUuc291cmNlKCk7XHJcblx0XHRzb3VyY2UuYWRkKHRoaXMuYXBwbHlBZGRpdGlvbmFsSW5mb3JtYXRpb24obW9kdWxlU291cmNlLCBtb2R1bGUuYWRkaXRpb25hbEluZm9ybWF0aW9uKSk7XHJcblx0fSwgdGhpcyk7XHJcblx0cmV0dXJuIHNvdXJjZTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIGlzSW52YWxpZE9yZGVyKGEsIGIpIHtcclxuXHR2YXIgYkJlZm9yZUEgPSBhLmdldFByZXZNb2R1bGVzKCkuaW5kZXhPZihiKSA+PSAwO1xyXG5cdHZhciBhQmVmb3JlQiA9IGIuZ2V0UHJldk1vZHVsZXMoKS5pbmRleE9mKGEpID49IDA7XHJcblx0cmV0dXJuIGFCZWZvcmVCICYmIGJCZWZvcmVBO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRPcmRlcihhLCBiKSB7XHJcblx0dmFyIGFPcmRlciA9IGEuZ2V0T3JkZXIoKTtcclxuXHR2YXIgYk9yZGVyID0gYi5nZXRPcmRlcigpO1xyXG5cdGlmKGFPcmRlciA8IGJPcmRlcikgcmV0dXJuIC0xO1xyXG5cdGlmKGFPcmRlciA+IGJPcmRlcikgcmV0dXJuIDE7XHJcblx0dmFyIGFJbmRleCA9IGEuZ2V0T3JpZ2luYWxNb2R1bGUoKS5pbmRleDI7XHJcblx0dmFyIGJJbmRleCA9IGIuZ2V0T3JpZ2luYWxNb2R1bGUoKS5pbmRleDI7XHJcblx0aWYoYUluZGV4IDwgYkluZGV4KSByZXR1cm4gLTE7XHJcblx0aWYoYUluZGV4ID4gYkluZGV4KSByZXR1cm4gMTtcclxuXHR2YXIgYkJlZm9yZUEgPSBhLmdldFByZXZNb2R1bGVzKCkuaW5kZXhPZihiKSA+PSAwO1xyXG5cdHZhciBhQmVmb3JlQiA9IGIuZ2V0UHJldk1vZHVsZXMoKS5pbmRleE9mKGEpID49IDA7XHJcblx0aWYoYUJlZm9yZUIgJiYgIWJCZWZvcmVBKSByZXR1cm4gLTE7XHJcblx0aWYoIWFCZWZvcmVCICYmIGJCZWZvcmVBKSByZXR1cm4gMTtcclxuXHR2YXIgYWkgPSBhLmlkZW50aWZpZXIoKTtcclxuXHR2YXIgYmkgPSBiLmlkZW50aWZpZXIoKTtcclxuXHRpZihhaSA8IGJpKSByZXR1cm4gLTE7XHJcblx0aWYoYWkgPiBiaSkgcmV0dXJuIDE7XHJcblx0cmV0dXJuIDA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEV4dHJhY3RUZXh0UGx1Z2luKGlkLCBmaWxlbmFtZSwgb3B0aW9ucykge1xyXG5cdGlmKHR5cGVvZiBmaWxlbmFtZSAhPT0gXCJzdHJpbmdcIikge1xyXG5cdFx0b3B0aW9ucyA9IGZpbGVuYW1lO1xyXG5cdFx0ZmlsZW5hbWUgPSBpZDtcclxuXHRcdGlkID0gKytuZXh0SWQ7XHJcblx0fVxyXG5cdGlmKCFvcHRpb25zKSBvcHRpb25zID0ge307XHJcblx0dGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xyXG5cdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcblx0dGhpcy5pZCA9IGlkO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gRXh0cmFjdFRleHRQbHVnaW47XHJcblxyXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMoYSwgYikge1xyXG5cdGlmKCFiKSByZXR1cm4gYTtcclxuXHRPYmplY3Qua2V5cyhiKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xyXG5cdFx0YVtrZXldID0gYltrZXldO1xyXG5cdH0pO1xyXG5cdHJldHVybiBhO1xyXG59XHJcblxyXG5FeHRyYWN0VGV4dFBsdWdpbi5sb2FkZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0cmV0dXJuIHJlcXVpcmUucmVzb2x2ZShcIi4vbG9hZGVyXCIpICsgKG9wdGlvbnMgPyBcIj9cIiArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpIDogXCJcIik7XHJcbn07XHJcblxyXG5FeHRyYWN0VGV4dFBsdWdpbi5leHRyYWN0ID0gZnVuY3Rpb24oYmVmb3JlLCBsb2FkZXIsIG9wdGlvbnMpIHtcclxuXHRpZih0eXBlb2YgbG9hZGVyID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkobG9hZGVyKSkge1xyXG5cdFx0aWYodHlwZW9mIGJlZm9yZSA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0XHRiZWZvcmUgPSBiZWZvcmUuc3BsaXQoXCIhXCIpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0RXh0cmFjdFRleHRQbHVnaW4ubG9hZGVyKG1lcmdlT3B0aW9ucyh7b21pdDogYmVmb3JlLmxlbmd0aCwgZXh0cmFjdDogdHJ1ZSwgcmVtb3ZlOiB0cnVlfSwgb3B0aW9ucykpXHJcblx0XHRdLmNvbmNhdChiZWZvcmUsIGxvYWRlcikuam9pbihcIiFcIik7XHJcblx0fSBlbHNlIHtcclxuXHRcdG9wdGlvbnMgPSBsb2FkZXI7XHJcblx0XHRsb2FkZXIgPSBiZWZvcmU7XHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHRFeHRyYWN0VGV4dFBsdWdpbi5sb2FkZXIobWVyZ2VPcHRpb25zKHtyZW1vdmU6IHRydWV9LCBvcHRpb25zKSlcclxuXHRcdF0uY29uY2F0KGxvYWRlcikuam9pbihcIiFcIik7XHJcblx0fVxyXG59O1xyXG5cclxuRXh0cmFjdFRleHRQbHVnaW4ucHJvdG90eXBlLmFwcGx5QWRkaXRpb25hbEluZm9ybWF0aW9uID0gZnVuY3Rpb24oc291cmNlLCBpbmZvKSB7XHJcblx0aWYoaW5mbykge1xyXG5cdFx0cmV0dXJuIG5ldyBDb25jYXRTb3VyY2UoXHJcblx0XHRcdFwiQG1lZGlhIFwiICsgaW5mb1swXSArIFwiIHtcIixcclxuXHRcdFx0c291cmNlLFxyXG5cdFx0XHRcIn1cIlxyXG5cdFx0KTtcclxuXHR9XHJcblx0cmV0dXJuIHNvdXJjZTtcclxufTtcclxuXHJcbkV4dHJhY3RUZXh0UGx1Z2luLnByb3RvdHlwZS5sb2FkZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0b3B0aW9ucyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob3B0aW9ucyB8fCB7fSkpO1xyXG5cdG9wdGlvbnMuaWQgPSB0aGlzLmlkO1xyXG5cdHJldHVybiBFeHRyYWN0VGV4dFBsdWdpbi5sb2FkZXIob3B0aW9ucyk7XHJcbn07XHJcblxyXG5FeHRyYWN0VGV4dFBsdWdpbi5wcm90b3R5cGUuZXh0cmFjdCA9IGZ1bmN0aW9uKGJlZm9yZSwgbG9hZGVyLCBvcHRpb25zKSB7XHJcblx0aWYodHlwZW9mIGxvYWRlciA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KGxvYWRlcikpIHtcclxuXHRcdGlmKHR5cGVvZiBiZWZvcmUgPT09IFwic3RyaW5nXCIpIHtcclxuXHRcdFx0YmVmb3JlID0gYmVmb3JlLnNwbGl0KFwiIVwiKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBbXHJcblx0XHRcdHRoaXMubG9hZGVyKG1lcmdlT3B0aW9ucyh7b21pdDogYmVmb3JlLmxlbmd0aCwgZXh0cmFjdDogdHJ1ZSwgcmVtb3ZlOiB0cnVlfSwgb3B0aW9ucykpXHJcblx0XHRdLmNvbmNhdChiZWZvcmUsIGxvYWRlcikuam9pbihcIiFcIik7XHJcblx0fSBlbHNlIHtcclxuXHRcdG9wdGlvbnMgPSBsb2FkZXI7XHJcblx0XHRsb2FkZXIgPSBiZWZvcmU7XHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHR0aGlzLmxvYWRlcihtZXJnZU9wdGlvbnMoe3JlbW92ZTogdHJ1ZX0sIG9wdGlvbnMpKVxyXG5cdFx0XS5jb25jYXQobG9hZGVyKS5qb2luKFwiIVwiKTtcclxuXHR9XHJcbn07XHJcblxyXG5FeHRyYWN0VGV4dFBsdWdpbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbihjb21waWxlcikge1xyXG5cdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cdGNvbXBpbGVyLnBsdWdpbihcInRoaXMtY29tcGlsYXRpb25cIiwgZnVuY3Rpb24oY29tcGlsYXRpb24pIHtcclxuXHRcdHZhciBleHRyYWN0Q29tcGlsYXRpb24gPSBuZXcgRXh0cmFjdFRleHRQbHVnaW5Db21waWxhdGlvbigpO1xyXG5cdFx0Y29tcGlsYXRpb24ucGx1Z2luKFwibm9ybWFsLW1vZHVsZS1sb2FkZXJcIiwgZnVuY3Rpb24obG9hZGVyQ29udGV4dCwgbW9kdWxlKSB7XHJcblx0XHRcdGxvYWRlckNvbnRleHRbX19kaXJuYW1lXSA9IGZ1bmN0aW9uKGNvbnRlbnQsIG9wdCkge1xyXG5cdFx0XHRcdGlmKG9wdGlvbnMuZGlzYWJsZSlcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHRpZighQXJyYXkuaXNBcnJheShjb250ZW50KSAmJiBjb250ZW50ICE9PSBudWxsKVxyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiRXhwb3J0ZWQgdmFsdWUgaXMgbm90IGEgc3RyaW5nLlwiKTtcclxuXHRcdFx0XHRtb2R1bGUubWV0YVtfX2Rpcm5hbWVdID0ge1xyXG5cdFx0XHRcdFx0Y29udGVudDogY29udGVudCxcclxuXHRcdFx0XHRcdG9wdGlvbnM6IG9wdCB8fCB7fVxyXG5cdFx0XHRcdH07XHJcblx0XHRcdFx0cmV0dXJuIG9wdGlvbnMuYWxsQ2h1bmtzIHx8IG1vZHVsZS5tZXRhW19fZGlybmFtZSArIFwiL2V4dHJhY3RcIl07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGF0aC1jb25jYXRcclxuXHRcdFx0fTtcclxuXHRcdH0pO1xyXG5cdFx0dmFyIGZpbGVuYW1lID0gdGhpcy5maWxlbmFtZTtcclxuXHRcdHZhciBpZCA9IHRoaXMuaWQ7XHJcblx0XHR2YXIgZXh0cmFjdGVkQ2h1bmtzLCBlbnRyeUNodW5rcywgaW5pdGlhbENodW5rcztcclxuXHRcdGNvbXBpbGF0aW9uLnBsdWdpbihcIm9wdGltaXplXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRlbnRyeUNodW5rcyA9IGNvbXBpbGF0aW9uLmNodW5rcy5maWx0ZXIoZnVuY3Rpb24oYykge1xyXG5cdFx0XHRcdHJldHVybiBjLmVudHJ5O1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0aW5pdGlhbENodW5rcyA9IGNvbXBpbGF0aW9uLmNodW5rcy5maWx0ZXIoZnVuY3Rpb24oYykge1xyXG5cdFx0XHRcdHJldHVybiBjLmluaXRpYWw7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0XHRjb21waWxhdGlvbi5wbHVnaW4oXCJvcHRpbWl6ZS10cmVlXCIsIGZ1bmN0aW9uKGNodW5rcywgbW9kdWxlcywgY2FsbGJhY2spIHtcclxuXHRcdFx0ZXh0cmFjdGVkQ2h1bmtzID0gY2h1bmtzLm1hcChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IENodW5rKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRjaHVua3MuZm9yRWFjaChmdW5jdGlvbihjaHVuaywgaSkge1xyXG5cdFx0XHRcdHZhciBleHRyYWN0ZWRDaHVuayA9IGV4dHJhY3RlZENodW5rc1tpXTtcclxuXHRcdFx0XHRleHRyYWN0ZWRDaHVuay5pbmRleCA9IGk7XHJcblx0XHRcdFx0ZXh0cmFjdGVkQ2h1bmsub3JpZ2luYWxDaHVuayA9IGNodW5rO1xyXG5cdFx0XHRcdGV4dHJhY3RlZENodW5rLm5hbWUgPSBjaHVuay5uYW1lO1xyXG5cdFx0XHRcdGV4dHJhY3RlZENodW5rLmVudHJ5ID0gY2h1bmsuZW50cnk7XHJcblx0XHRcdFx0ZXh0cmFjdGVkQ2h1bmsuaW5pdGlhbCA9IGNodW5rLmluaXRpYWw7XHJcblx0XHRcdFx0Y2h1bmsuY2h1bmtzLmZvckVhY2goZnVuY3Rpb24oYykge1xyXG5cdFx0XHRcdFx0ZXh0cmFjdGVkQ2h1bmsuYWRkQ2h1bmsoZXh0cmFjdGVkQ2h1bmtzW2NodW5rcy5pbmRleE9mKGMpXSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0Y2h1bmsucGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcclxuXHRcdFx0XHRcdGV4dHJhY3RlZENodW5rLmFkZFBhcmVudChleHRyYWN0ZWRDaHVua3NbY2h1bmtzLmluZGV4T2YoYyldKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGVudHJ5Q2h1bmtzLmZvckVhY2goZnVuY3Rpb24oY2h1bmspIHtcclxuXHRcdFx0XHR2YXIgaWR4ID0gY2h1bmtzLmluZGV4T2YoY2h1bmspO1xyXG5cdFx0XHRcdGlmKGlkeCA8IDApIHJldHVybjtcclxuXHRcdFx0XHR2YXIgZXh0cmFjdGVkQ2h1bmsgPSBleHRyYWN0ZWRDaHVua3NbaWR4XTtcclxuXHRcdFx0XHRleHRyYWN0ZWRDaHVuay5lbnRyeSA9IHRydWU7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpbml0aWFsQ2h1bmtzLmZvckVhY2goZnVuY3Rpb24oY2h1bmspIHtcclxuXHRcdFx0XHR2YXIgaWR4ID0gY2h1bmtzLmluZGV4T2YoY2h1bmspO1xyXG5cdFx0XHRcdGlmKGlkeCA8IDApIHJldHVybjtcclxuXHRcdFx0XHR2YXIgZXh0cmFjdGVkQ2h1bmsgPSBleHRyYWN0ZWRDaHVua3NbaWR4XTtcclxuXHRcdFx0XHRleHRyYWN0ZWRDaHVuay5pbml0aWFsID0gdHJ1ZTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGFzeW5jLmZvckVhY2goY2h1bmtzLCBmdW5jdGlvbihjaHVuaywgY2FsbGJhY2spIHtcclxuXHRcdFx0XHR2YXIgZXh0cmFjdGVkQ2h1bmsgPSBleHRyYWN0ZWRDaHVua3NbY2h1bmtzLmluZGV4T2YoY2h1bmspXTtcclxuXHRcdFx0XHR2YXIgc2hvdWxkRXh0cmFjdCA9ICEhKG9wdGlvbnMuYWxsQ2h1bmtzIHx8IGNodW5rLmluaXRpYWwpO1xyXG5cdFx0XHRcdGFzeW5jLmZvckVhY2goY2h1bmsubW9kdWxlcy5zbGljZSgpLCBmdW5jdGlvbihtb2R1bGUsIGNhbGxiYWNrKSB7XHJcblx0XHRcdFx0XHR2YXIgbWV0YSA9IG1vZHVsZS5tZXRhICYmIG1vZHVsZS5tZXRhW19fZGlybmFtZV07XHJcblx0XHRcdFx0XHRpZihtZXRhICYmICghbWV0YS5vcHRpb25zLmlkIHx8IG1ldGEub3B0aW9ucy5pZCA9PT0gaWQpKSB7XHJcblx0XHRcdFx0XHRcdHZhciB3YXNFeHRyYWN0ZWQgPSBBcnJheS5pc0FycmF5KG1ldGEuY29udGVudCk7XHJcblx0XHRcdFx0XHRcdGlmKHNob3VsZEV4dHJhY3QgIT09IHdhc0V4dHJhY3RlZCkge1xyXG5cdFx0XHRcdFx0XHRcdG1vZHVsZS5tZXRhW19fZGlybmFtZSArIFwiL2V4dHJhY3RcIl0gPSBzaG91bGRFeHRyYWN0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhdGgtY29uY2F0XHJcblx0XHRcdFx0XHRcdFx0Y29tcGlsYXRpb24ucmVidWlsZE1vZHVsZShtb2R1bGUsIGZ1bmN0aW9uKGVycikge1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYoZXJyKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBpbGF0aW9uLmVycm9ycy5wdXNoKGVycik7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBjYWxsYmFjaygpO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0bWV0YSA9IG1vZHVsZS5tZXRhW19fZGlybmFtZV07XHJcblx0XHRcdFx0XHRcdFx0XHRpZighQXJyYXkuaXNBcnJheShtZXRhLmNvbnRlbnQpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGVyciA9IG5ldyBFcnJvcihtb2R1bGUuaWRlbnRpZmllcigpICsgXCIgZG9lc24ndCBleHBvcnQgY29udGVudFwiKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGlsYXRpb24uZXJyb3JzLnB1c2goZXJyKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKCk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRpZihtZXRhLmNvbnRlbnQpXHJcblx0XHRcdFx0XHRcdFx0XHRcdGV4dHJhY3RDb21waWxhdGlvbi5hZGRSZXN1bHRUb0NodW5rKG1vZHVsZS5pZGVudGlmaWVyKCksIG1ldGEuY29udGVudCwgbW9kdWxlLCBleHRyYWN0ZWRDaHVuayk7XHJcblx0XHRcdFx0XHRcdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdGlmKG1ldGEuY29udGVudClcclxuXHRcdFx0XHRcdFx0XHRcdGV4dHJhY3RDb21waWxhdGlvbi5hZGRSZXN1bHRUb0NodW5rKG1vZHVsZS5pZGVudGlmaWVyKCksIG1ldGEuY29udGVudCwgbW9kdWxlLCBleHRyYWN0ZWRDaHVuayk7XHJcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSBlbHNlIGNhbGxiYWNrKCk7XHJcblx0XHRcdFx0fSwgZnVuY3Rpb24oZXJyKSB7XHJcblx0XHRcdFx0XHRpZihlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSwgZnVuY3Rpb24oZXJyKSB7XHJcblx0XHRcdFx0aWYoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHRcdFx0XHRleHRyYWN0ZWRDaHVua3MuZm9yRWFjaChmdW5jdGlvbihleHRyYWN0ZWRDaHVuaykge1xyXG5cdFx0XHRcdFx0aWYoZXh0cmFjdGVkQ2h1bmsuaW5pdGlhbClcclxuXHRcdFx0XHRcdFx0dGhpcy5tZXJnZU5vbkluaXRpYWxDaHVua3MoZXh0cmFjdGVkQ2h1bmspO1xyXG5cdFx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0XHRcdGV4dHJhY3RlZENodW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGV4dHJhY3RlZENodW5rKSB7XHJcblx0XHRcdFx0XHRpZighZXh0cmFjdGVkQ2h1bmsuaW5pdGlhbCkge1xyXG5cdFx0XHRcdFx0XHRleHRyYWN0ZWRDaHVuay5tb2R1bGVzLmZvckVhY2goZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0XHRcdFx0XHRcdFx0ZXh0cmFjdGVkQ2h1bmsucmVtb3ZlTW9kdWxlKG1vZHVsZSk7XHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdGNvbXBpbGF0aW9uLmFwcGx5UGx1Z2lucyhcIm9wdGltaXplLWV4dHJhY3RlZC1jaHVua3NcIiwgZXh0cmFjdGVkQ2h1bmtzKTtcclxuXHRcdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0XHR9LmJpbmQodGhpcykpO1xyXG5cdFx0fS5iaW5kKHRoaXMpKTtcclxuXHRcdGNvbXBpbGF0aW9uLnBsdWdpbihcImFkZGl0aW9uYWwtYXNzZXRzXCIsIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcblx0XHRcdGV4dHJhY3RlZENodW5rcy5mb3JFYWNoKGZ1bmN0aW9uKGV4dHJhY3RlZENodW5rKSB7XHJcblx0XHRcdFx0aWYoZXh0cmFjdGVkQ2h1bmsubW9kdWxlcy5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdGV4dHJhY3RlZENodW5rLm1vZHVsZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XHJcblx0XHRcdFx0XHRcdGlmKGlzSW52YWxpZE9yZGVyKGEsIGIpKSB7XHJcblx0XHRcdFx0XHRcdFx0Y29tcGlsYXRpb24uZXJyb3JzLnB1c2gobmV3IE9yZGVyVW5kZWZpbmVkRXJyb3IoYS5nZXRPcmlnaW5hbE1vZHVsZSgpKSk7XHJcblx0XHRcdFx0XHRcdFx0Y29tcGlsYXRpb24uZXJyb3JzLnB1c2gobmV3IE9yZGVyVW5kZWZpbmVkRXJyb3IoYi5nZXRPcmlnaW5hbE1vZHVsZSgpKSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0cmV0dXJuIGdldE9yZGVyKGEsIGIpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR2YXIgY2h1bmsgPSBleHRyYWN0ZWRDaHVuay5vcmlnaW5hbENodW5rO1xyXG5cdFx0XHRcdFx0dmFyIHNvdXJjZSA9IHRoaXMucmVuZGVyRXh0cmFjdGVkQ2h1bmsoZXh0cmFjdGVkQ2h1bmspO1xyXG5cdFx0XHRcdFx0dmFyIGZpbGUgPSBjb21waWxhdGlvbi5nZXRQYXRoKGZpbGVuYW1lLCB7XHJcblx0XHRcdFx0XHRcdGNodW5rOiBjaHVua1xyXG5cdFx0XHRcdFx0fSkucmVwbGFjZSgvXFxbKD86KFxcdyspOik/Y29udGVudGhhc2goPzo6KFthLXpdK1xcZCopKT8oPzo6KFxcZCspKT9cXF0vaWcsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gbG9hZGVyVXRpbHMuZ2V0SGFzaERpZ2VzdChzb3VyY2Uuc291cmNlKCksIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBwYXJzZUludChhcmd1bWVudHNbM10sIDEwKSk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdGNvbXBpbGF0aW9uLmFzc2V0c1tmaWxlXSA9IHNvdXJjZTtcclxuXHRcdFx0XHRcdGNodW5rLmZpbGVzLnB1c2goZmlsZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdH0uYmluZCh0aGlzKSk7XHJcblx0fS5iaW5kKHRoaXMpKTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2V4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbmV4cG9ydHMuU291cmNlID0gcmVxdWlyZShcIi4vU291cmNlXCIpO1xyXG5cclxuZXhwb3J0cy5SYXdTb3VyY2UgPSByZXF1aXJlKFwiLi9SYXdTb3VyY2VcIik7XHJcbmV4cG9ydHMuT3JpZ2luYWxTb3VyY2UgPSByZXF1aXJlKFwiLi9PcmlnaW5hbFNvdXJjZVwiKTtcclxuZXhwb3J0cy5Tb3VyY2VNYXBTb3VyY2UgPSByZXF1aXJlKFwiLi9Tb3VyY2VNYXBTb3VyY2VcIik7XHJcbmV4cG9ydHMuTGluZVRvTGluZU1hcHBlZFNvdXJjZSA9IHJlcXVpcmUoXCIuL0xpbmVUb0xpbmVNYXBwZWRTb3VyY2VcIik7XHJcblxyXG5leHBvcnRzLkNhY2hlZFNvdXJjZSA9IHJlcXVpcmUoXCIuL0NhY2hlZFNvdXJjZVwiKTtcclxuZXhwb3J0cy5Db25jYXRTb3VyY2UgPSByZXF1aXJlKFwiLi9Db25jYXRTb3VyY2VcIik7XHJcbmV4cG9ydHMuUmVwbGFjZVNvdXJjZSA9IHJlcXVpcmUoXCIuL1JlcGxhY2VTb3VyY2VcIik7XHJcbmV4cG9ydHMuUHJlZml4U291cmNlID0gcmVxdWlyZShcIi4vUHJlZml4U291cmNlXCIpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjayktc291cmNlcy9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgU291cmNlTm9kZSA9IHJlcXVpcmUoXCJzb3VyY2UtbWFwXCIpLlNvdXJjZU5vZGU7XHJcbnZhciBTb3VyY2VNYXBDb25zdW1lciA9IHJlcXVpcmUoXCJzb3VyY2UtbWFwXCIpLlNvdXJjZU1hcENvbnN1bWVyO1xyXG5cclxuZnVuY3Rpb24gU291cmNlKCkge31cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU291cmNlO1xyXG5cclxuU291cmNlLnByb3RvdHlwZS5zb3VyY2UgPSBudWxsO1xyXG5cclxuU291cmNlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuc291cmNlKCkubGVuZ3RoO1xyXG59O1xyXG5cclxuU291cmNlLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0cmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG5Tb3VyY2UucHJvdG90eXBlLnNvdXJjZUFuZE1hcCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4ge1xyXG5cdFx0c291cmNlOiB0aGlzLnNvdXJjZSgpLFxyXG5cdFx0bWFwOiB0aGlzLm1hcCgpXHJcblx0fTtcclxufTtcclxuXHJcblNvdXJjZS5wcm90b3R5cGUubm9kZSA9IG51bGw7XHJcblxyXG5Tb3VyY2UucHJvdG90eXBlLmxpc3ROb2RlID0gbnVsbDtcclxuXHJcblNvdXJjZS5wcm90b3R5cGUudXBkYXRlSGFzaCA9IGZ1bmN0aW9uKGhhc2gpIHtcclxuXHR2YXIgc291cmNlID0gdGhpcy5zb3VyY2UoKTtcclxuXHRoYXNoLnVwZGF0ZShzb3VyY2UgfHwgXCJcIik7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS1zb3VyY2VzL2xpYi9Tb3VyY2UuanNcbi8vIG1vZHVsZSBpZCA9IDM0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICogQ29weXJpZ2h0IDIwMDktMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0UudHh0IG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5leHBvcnRzLlNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJykuU291cmNlTWFwR2VuZXJhdG9yO1xuZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1tYXAtY29uc3VtZXInKS5Tb3VyY2VNYXBDb25zdW1lcjtcbmV4cG9ydHMuU291cmNlTm9kZSA9IHJlcXVpcmUoJy4vbGliL3NvdXJjZS1ub2RlJykuU291cmNlTm9kZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS1zb3VyY2VzL34vc291cmNlLW1hcC9zb3VyY2UtbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgYmFzZTY0VkxRID0gcmVxdWlyZSgnLi9iYXNlNjQtdmxxJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbnZhciBNYXBwaW5nTGlzdCA9IHJlcXVpcmUoJy4vbWFwcGluZy1saXN0JykuTWFwcGluZ0xpc3Q7XG5cbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgdGhlIFNvdXJjZU1hcEdlbmVyYXRvciByZXByZXNlbnRzIGEgc291cmNlIG1hcCB3aGljaCBpc1xuICogYmVpbmcgYnVpbHQgaW5jcmVtZW50YWxseS4gWW91IG1heSBwYXNzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGZpbGU6IFRoZSBmaWxlbmFtZSBvZiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqICAgLSBzb3VyY2VSb290OiBBIHJvb3QgZm9yIGFsbCByZWxhdGl2ZSBVUkxzIGluIHRoaXMgc291cmNlIG1hcC5cbiAqL1xuZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKSB7XG4gIGlmICghYUFyZ3MpIHtcbiAgICBhQXJncyA9IHt9O1xuICB9XG4gIHRoaXMuX2ZpbGUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2ZpbGUnLCBudWxsKTtcbiAgdGhpcy5fc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlUm9vdCcsIG51bGwpO1xuICB0aGlzLl9za2lwVmFsaWRhdGlvbiA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc2tpcFZhbGlkYXRpb24nLCBmYWxzZSk7XG4gIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbWFwcGluZ3MgPSBuZXcgTWFwcGluZ0xpc3QoKTtcbiAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gbnVsbDtcbn1cblxuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBTb3VyY2VNYXBHZW5lcmF0b3IgYmFzZWQgb24gYSBTb3VyY2VNYXBDb25zdW1lclxuICpcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLmZyb21Tb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZnJvbVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIpIHtcbiAgICB2YXIgc291cmNlUm9vdCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VSb290O1xuICAgIHZhciBnZW5lcmF0b3IgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKHtcbiAgICAgIGZpbGU6IGFTb3VyY2VNYXBDb25zdW1lci5maWxlLFxuICAgICAgc291cmNlUm9vdDogc291cmNlUm9vdFxuICAgIH0pO1xuICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgdmFyIG5ld01hcHBpbmcgPSB7XG4gICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIG5ld01hcHBpbmcuc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbmV3TWFwcGluZy5zb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3TWFwcGluZy5vcmlnaW5hbCA9IHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICBuZXdNYXBwaW5nLm5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZ2VuZXJhdG9yLmFkZE1hcHBpbmcobmV3TWFwcGluZyk7XG4gICAgfSk7XG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgZ2VuZXJhdG9yLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfTtcblxuLyoqXG4gKiBBZGQgYSBzaW5nbGUgbWFwcGluZyBmcm9tIG9yaWdpbmFsIHNvdXJjZSBsaW5lIGFuZCBjb2x1bW4gdG8gdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIGZvciB0aGlzIHNvdXJjZSBtYXAgYmVpbmcgY3JlYXRlZC4gVGhlIG1hcHBpbmdcbiAqIG9iamVjdCBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGdlbmVyYXRlZDogQW4gb2JqZWN0IHdpdGggdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zLlxuICogICAtIG9yaWdpbmFsOiBBbiBvYmplY3Qgd2l0aCB0aGUgb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSAocmVsYXRpdmUgdG8gdGhlIHNvdXJjZVJvb3QpLlxuICogICAtIG5hbWU6IEFuIG9wdGlvbmFsIG9yaWdpbmFsIHRva2VuIG5hbWUgZm9yIHRoaXMgbWFwcGluZy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hZGRNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2FkZE1hcHBpbmcoYUFyZ3MpIHtcbiAgICB2YXIgZ2VuZXJhdGVkID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdnZW5lcmF0ZWQnKTtcbiAgICB2YXIgb3JpZ2luYWwgPSB1dGlsLmdldEFyZyhhQXJncywgJ29yaWdpbmFsJywgbnVsbCk7XG4gICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJywgbnVsbCk7XG4gICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhhQXJncywgJ25hbWUnLCBudWxsKTtcblxuICAgIGlmICghdGhpcy5fc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgIHRoaXMuX3ZhbGlkYXRlTWFwcGluZyhnZW5lcmF0ZWQsIG9yaWdpbmFsLCBzb3VyY2UsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgc291cmNlID0gU3RyaW5nKHNvdXJjZSk7XG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgICAgaWYgKCF0aGlzLl9uYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX21hcHBpbmdzLmFkZCh7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogZ2VuZXJhdGVkLmNvbHVtbixcbiAgICAgIG9yaWdpbmFsTGluZTogb3JpZ2luYWwgIT0gbnVsbCAmJiBvcmlnaW5hbC5saW5lLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwuY29sdW1uLFxuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBuYW1lOiBuYW1lXG4gICAgfSk7XG4gIH07XG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NldFNvdXJjZUNvbnRlbnQoYVNvdXJjZUZpbGUsIGFTb3VyY2VDb250ZW50KSB7XG4gICAgdmFyIHNvdXJjZSA9IGFTb3VyY2VGaWxlO1xuICAgIGlmICh0aGlzLl9zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5fc291cmNlUm9vdCwgc291cmNlKTtcbiAgICB9XG5cbiAgICBpZiAoYVNvdXJjZUNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgLy8gQWRkIHRoZSBzb3VyY2UgY29udGVudCB0byB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgX3NvdXJjZXNDb250ZW50cyBtYXAgaWYgdGhlIHByb3BlcnR5IGlzIG51bGwuXG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoc291cmNlKV0gPSBhU291cmNlQ29udGVudDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBzb3VyY2UgZmlsZSBmcm9tIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcC5cbiAgICAgIC8vIElmIHRoZSBfc291cmNlc0NvbnRlbnRzIG1hcCBpcyBlbXB0eSwgc2V0IHRoZSBwcm9wZXJ0eSB0byBudWxsLlxuICAgICAgZGVsZXRlIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuX3NvdXJjZXNDb250ZW50cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIG1hcHBpbmdzIG9mIGEgc3ViLXNvdXJjZS1tYXAgZm9yIGEgc3BlY2lmaWMgc291cmNlIGZpbGUgdG8gdGhlXG4gKiBzb3VyY2UgbWFwIGJlaW5nIGdlbmVyYXRlZC4gRWFjaCBtYXBwaW5nIHRvIHRoZSBzdXBwbGllZCBzb3VyY2UgZmlsZSBpc1xuICogcmV3cml0dGVuIHVzaW5nIHRoZSBzdXBwbGllZCBzb3VyY2UgbWFwLiBOb3RlOiBUaGUgcmVzb2x1dGlvbiBmb3IgdGhlXG4gKiByZXN1bHRpbmcgbWFwcGluZ3MgaXMgdGhlIG1pbmltaXVtIG9mIHRoaXMgbWFwIGFuZCB0aGUgc3VwcGxpZWQgbWFwLlxuICpcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZC5cbiAqIEBwYXJhbSBhU291cmNlRmlsZSBPcHRpb25hbC4gVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZS5cbiAqICAgICAgICBJZiBvbWl0dGVkLCBTb3VyY2VNYXBDb25zdW1lcidzIGZpbGUgcHJvcGVydHkgd2lsbCBiZSB1c2VkLlxuICogQHBhcmFtIGFTb3VyY2VNYXBQYXRoIE9wdGlvbmFsLiBUaGUgZGlybmFtZSBvZiB0aGUgcGF0aCB0byB0aGUgc291cmNlIG1hcFxuICogICAgICAgIHRvIGJlIGFwcGxpZWQuIElmIHJlbGF0aXZlLCBpdCBpcyByZWxhdGl2ZSB0byB0aGUgU291cmNlTWFwQ29uc3VtZXIuXG4gKiAgICAgICAgVGhpcyBwYXJhbWV0ZXIgaXMgbmVlZGVkIHdoZW4gdGhlIHR3byBzb3VyY2UgbWFwcyBhcmVuJ3QgaW4gdGhlIHNhbWVcbiAqICAgICAgICBkaXJlY3RvcnksIGFuZCB0aGUgc291cmNlIG1hcCB0byBiZSBhcHBsaWVkIGNvbnRhaW5zIHJlbGF0aXZlIHNvdXJjZVxuICogICAgICAgIHBhdGhzLiBJZiBzbywgdGhvc2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIG5lZWQgdG8gYmUgcmV3cml0dGVuXG4gKiAgICAgICAgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBseVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hcHBseVNvdXJjZU1hcChhU291cmNlTWFwQ29uc3VtZXIsIGFTb3VyY2VGaWxlLCBhU291cmNlTWFwUGF0aCkge1xuICAgIHZhciBzb3VyY2VGaWxlID0gYVNvdXJjZUZpbGU7XG4gICAgLy8gSWYgYVNvdXJjZUZpbGUgaXMgb21pdHRlZCwgd2Ugd2lsbCB1c2UgdGhlIGZpbGUgcHJvcGVydHkgb2YgdGhlIFNvdXJjZU1hcFxuICAgIGlmIChhU291cmNlRmlsZSA9PSBudWxsKSB7XG4gICAgICBpZiAoYVNvdXJjZU1hcENvbnN1bWVyLmZpbGUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1NvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgcmVxdWlyZXMgZWl0aGVyIGFuIGV4cGxpY2l0IHNvdXJjZSBmaWxlLCAnICtcbiAgICAgICAgICAnb3IgdGhlIHNvdXJjZSBtYXBcXCdzIFwiZmlsZVwiIHByb3BlcnR5LiBCb3RoIHdlcmUgb21pdHRlZC4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBzb3VyY2VGaWxlID0gYVNvdXJjZU1hcENvbnN1bWVyLmZpbGU7XG4gICAgfVxuICAgIHZhciBzb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICAvLyBNYWtlIFwic291cmNlRmlsZVwiIHJlbGF0aXZlIGlmIGFuIGFic29sdXRlIFVybCBpcyBwYXNzZWQuXG4gICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgc291cmNlRmlsZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgfVxuICAgIC8vIEFwcGx5aW5nIHRoZSBTb3VyY2VNYXAgY2FuIGFkZCBhbmQgcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIHNvdXJjZXMgYW5kXG4gICAgLy8gdGhlIG5hbWVzIGFycmF5LlxuICAgIHZhciBuZXdTb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gICAgdmFyIG5ld05hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgICAvLyBGaW5kIG1hcHBpbmdzIGZvciB0aGUgXCJzb3VyY2VGaWxlXCJcbiAgICB0aGlzLl9tYXBwaW5ncy51bnNvcnRlZEZvckVhY2goZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gc291cmNlRmlsZSAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGl0IGNhbiBiZSBtYXBwZWQgYnkgdGhlIHNvdXJjZSBtYXAsIHRoZW4gdXBkYXRlIHRoZSBtYXBwaW5nLlxuICAgICAgICB2YXIgb3JpZ2luYWwgPSBhU291cmNlTWFwQ29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3JpZ2luYWwuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDb3B5IG1hcHBpbmdcbiAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IG9yaWdpbmFsLnNvdXJjZTtcbiAgICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIG1hcHBpbmcuc291cmNlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgbWFwcGluZy5zb3VyY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9IG9yaWdpbmFsLmxpbmU7XG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgICAgICBpZiAob3JpZ2luYWwubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2U7XG4gICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgIW5ld1NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgbmV3U291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSBtYXBwaW5nLm5hbWU7XG4gICAgICBpZiAobmFtZSAhPSBudWxsICYmICFuZXdOYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgbmV3TmFtZXMuYWRkKG5hbWUpO1xuICAgICAgfVxuXG4gICAgfSwgdGhpcyk7XG4gICAgdGhpcy5fc291cmNlcyA9IG5ld1NvdXJjZXM7XG4gICAgdGhpcy5fbmFtZXMgPSBuZXdOYW1lcztcblxuICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnRzIG9mIGFwcGxpZWQgbWFwLlxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChhU291cmNlTWFwUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhU291cmNlTWFwUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBjb250ZW50KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfTtcblxuLyoqXG4gKiBBIG1hcHBpbmcgY2FuIGhhdmUgb25lIG9mIHRoZSB0aHJlZSBsZXZlbHMgb2YgZGF0YTpcbiAqXG4gKiAgIDEuIEp1c3QgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbi5cbiAqICAgMi4gVGhlIEdlbmVyYXRlZCBwb3NpdGlvbiwgb3JpZ2luYWwgcG9zaXRpb24sIGFuZCBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIDMuIEdlbmVyYXRlZCBhbmQgb3JpZ2luYWwgcG9zaXRpb24sIG9yaWdpbmFsIHNvdXJjZSwgYXMgd2VsbCBhcyBhIG5hbWVcbiAqICAgICAgdG9rZW4uXG4gKlxuICogVG8gbWFpbnRhaW4gY29uc2lzdGVuY3ksIHdlIHZhbGlkYXRlIHRoYXQgYW55IG5ldyBtYXBwaW5nIGJlaW5nIGFkZGVkIGZhbGxzXG4gKiBpbiB0byBvbmUgb2YgdGhlc2UgY2F0ZWdvcmllcy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGVNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3ZhbGlkYXRlTWFwcGluZyhhR2VuZXJhdGVkLCBhT3JpZ2luYWwsIGFTb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYU5hbWUpIHtcbiAgICBpZiAoYUdlbmVyYXRlZCAmJiAnbGluZScgaW4gYUdlbmVyYXRlZCAmJiAnY29sdW1uJyBpbiBhR2VuZXJhdGVkXG4gICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAmJiAhYU9yaWdpbmFsICYmICFhU291cmNlICYmICFhTmFtZSkge1xuICAgICAgLy8gQ2FzZSAxLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgICAgICAmJiBhT3JpZ2luYWwgJiYgJ2xpbmUnIGluIGFPcmlnaW5hbCAmJiAnY29sdW1uJyBpbiBhT3JpZ2luYWxcbiAgICAgICAgICAgICAmJiBhR2VuZXJhdGVkLmxpbmUgPiAwICYmIGFHZW5lcmF0ZWQuY29sdW1uID49IDBcbiAgICAgICAgICAgICAmJiBhT3JpZ2luYWwubGluZSA+IDAgJiYgYU9yaWdpbmFsLmNvbHVtbiA+PSAwXG4gICAgICAgICAgICAgJiYgYVNvdXJjZSkge1xuICAgICAgLy8gQ2FzZXMgMiBhbmQgMy5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWFwcGluZzogJyArIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgZ2VuZXJhdGVkOiBhR2VuZXJhdGVkLFxuICAgICAgICBzb3VyY2U6IGFTb3VyY2UsXG4gICAgICAgIG9yaWdpbmFsOiBhT3JpZ2luYWwsXG4gICAgICAgIG5hbWU6IGFOYW1lXG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gdG8gdGhlIHN0cmVhbSBvZiBiYXNlIDY0IFZMUXNcbiAqIHNwZWNpZmllZCBieSB0aGUgc291cmNlIG1hcCBmb3JtYXQuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3NlcmlhbGl6ZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3NlcmlhbGl6ZU1hcHBpbmdzKCkge1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkTGluZSA9IDE7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4gPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsTGluZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzTmFtZSA9IDA7XG4gICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIG5leHQ7XG4gICAgdmFyIG1hcHBpbmc7XG4gICAgdmFyIG5hbWVJZHg7XG4gICAgdmFyIHNvdXJjZUlkeDtcblxuICAgIHZhciBtYXBwaW5ncyA9IHRoaXMuX21hcHBpbmdzLnRvQXJyYXkoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG1hcHBpbmcgPSBtYXBwaW5nc1tpXTtcbiAgICAgIG5leHQgPSAnJ1xuXG4gICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICB3aGlsZSAobWFwcGluZy5nZW5lcmF0ZWRMaW5lICE9PSBwcmV2aW91c0dlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBuZXh0ICs9ICc7JztcbiAgICAgICAgICBwcmV2aW91c0dlbmVyYXRlZExpbmUrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIGlmICghdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nLCBtYXBwaW5nc1tpIC0gMV0pKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dCArPSAnLCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZUlkeCA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShzb3VyY2VJZHggLSBwcmV2aW91c1NvdXJjZSk7XG4gICAgICAgIHByZXZpb3VzU291cmNlID0gc291cmNlSWR4O1xuXG4gICAgICAgIC8vIGxpbmVzIGFyZSBzdG9yZWQgMC1iYXNlZCBpbiBTb3VyY2VNYXAgc3BlYyB2ZXJzaW9uIDNcbiAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxMaW5lKTtcbiAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZSAtIDE7XG5cbiAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBwcmV2aW91c09yaWdpbmFsQ29sdW1uKTtcbiAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgaWYgKG1hcHBpbmcubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmFtZUlkeCA9IHRoaXMuX25hbWVzLmluZGV4T2YobWFwcGluZy5uYW1lKTtcbiAgICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobmFtZUlkeCAtIHByZXZpb3VzTmFtZSk7XG4gICAgICAgICAgcHJldmlvdXNOYW1lID0gbmFtZUlkeDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXN1bHQgKz0gbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoYVNvdXJjZXMsIGFTb3VyY2VSb290KSB7XG4gICAgcmV0dXJuIGFTb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICBpZiAoIXRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChhU291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUoYVNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdXRpbC50b1NldFN0cmluZyhzb3VyY2UpO1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9zb3VyY2VzQ29udGVudHMsIGtleSlcbiAgICAgICAgPyB0aGlzLl9zb3VyY2VzQ29udGVudHNba2V5XVxuICAgICAgICA6IG51bGw7XG4gICAgfSwgdGhpcyk7XG4gIH07XG5cbi8qKlxuICogRXh0ZXJuYWxpemUgdGhlIHNvdXJjZSBtYXAuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUudG9KU09OID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvSlNPTigpIHtcbiAgICB2YXIgbWFwID0ge1xuICAgICAgdmVyc2lvbjogdGhpcy5fdmVyc2lvbixcbiAgICAgIHNvdXJjZXM6IHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLFxuICAgICAgbmFtZXM6IHRoaXMuX25hbWVzLnRvQXJyYXkoKSxcbiAgICAgIG1hcHBpbmdzOiB0aGlzLl9zZXJpYWxpemVNYXBwaW5ncygpXG4gICAgfTtcbiAgICBpZiAodGhpcy5fZmlsZSAhPSBudWxsKSB7XG4gICAgICBtYXAuZmlsZSA9IHRoaXMuX2ZpbGU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIG1hcC5zb3VyY2VSb290ID0gdGhpcy5fc291cmNlUm9vdDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvdXJjZXNDb250ZW50cykge1xuICAgICAgbWFwLnNvdXJjZXNDb250ZW50ID0gdGhpcy5fZ2VuZXJhdGVTb3VyY2VzQ29udGVudChtYXAuc291cmNlcywgbWFwLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXA7XG4gIH07XG5cbi8qKlxuICogUmVuZGVyIHRoZSBzb3VyY2UgbWFwIGJlaW5nIGdlbmVyYXRlZCB0byBhIHN0cmluZy5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b1N0cmluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl90b1N0cmluZygpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSk7XG4gIH07XG5cbmV4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yID0gU291cmNlTWFwR2VuZXJhdG9yO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spLXNvdXJjZXMvfi9zb3VyY2UtbWFwL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMzQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKlxuICogQmFzZWQgb24gdGhlIEJhc2UgNjQgVkxRIGltcGxlbWVudGF0aW9uIGluIENsb3N1cmUgQ29tcGlsZXI6XG4gKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nsb3N1cmUtY29tcGlsZXIvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvY29tL2dvb2dsZS9kZWJ1Z2dpbmcvc291cmNlbWFwL0Jhc2U2NFZMUS5qYXZhXG4gKlxuICogQ29weXJpZ2h0IDIwMTEgVGhlIENsb3N1cmUgQ29tcGlsZXIgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gKiAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICogICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkXG4gKiAgICB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWRcbiAqICAgIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuICogREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gKiBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJy4vYmFzZTY0Jyk7XG5cbi8vIEEgc2luZ2xlIGJhc2UgNjQgZGlnaXQgY2FuIGNvbnRhaW4gNiBiaXRzIG9mIGRhdGEuIEZvciB0aGUgYmFzZSA2NCB2YXJpYWJsZVxuLy8gbGVuZ3RoIHF1YW50aXRpZXMgd2UgdXNlIGluIHRoZSBzb3VyY2UgbWFwIHNwZWMsIHRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ24sXG4vLyB0aGUgbmV4dCBmb3VyIGJpdHMgYXJlIHRoZSBhY3R1YWwgdmFsdWUsIGFuZCB0aGUgNnRoIGJpdCBpcyB0aGVcbi8vIGNvbnRpbnVhdGlvbiBiaXQuIFRoZSBjb250aW51YXRpb24gYml0IHRlbGxzIHVzIHdoZXRoZXIgdGhlcmUgYXJlIG1vcmVcbi8vIGRpZ2l0cyBpbiB0aGlzIHZhbHVlIGZvbGxvd2luZyB0aGlzIGRpZ2l0LlxuLy9cbi8vICAgQ29udGludWF0aW9uXG4vLyAgIHwgICAgU2lnblxuLy8gICB8ICAgIHxcbi8vICAgViAgICBWXG4vLyAgIDEwMTAxMVxuXG52YXIgVkxRX0JBU0VfU0hJRlQgPSA1O1xuXG4vLyBiaW5hcnk6IDEwMDAwMFxudmFyIFZMUV9CQVNFID0gMSA8PCBWTFFfQkFTRV9TSElGVDtcblxuLy8gYmluYXJ5OiAwMTExMTFcbnZhciBWTFFfQkFTRV9NQVNLID0gVkxRX0JBU0UgLSAxO1xuXG4vLyBiaW5hcnk6IDEwMDAwMFxudmFyIFZMUV9DT05USU5VQVRJT05fQklUID0gVkxRX0JBU0U7XG5cbi8qKlxuICogQ29udmVydHMgZnJvbSBhIHR3by1jb21wbGVtZW50IHZhbHVlIHRvIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gKiBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAqICAgMSBiZWNvbWVzIDIgKDEwIGJpbmFyeSksIC0xIGJlY29tZXMgMyAoMTEgYmluYXJ5KVxuICogICAyIGJlY29tZXMgNCAoMTAwIGJpbmFyeSksIC0yIGJlY29tZXMgNSAoMTAxIGJpbmFyeSlcbiAqL1xuZnVuY3Rpb24gdG9WTFFTaWduZWQoYVZhbHVlKSB7XG4gIHJldHVybiBhVmFsdWUgPCAwXG4gICAgPyAoKC1hVmFsdWUpIDw8IDEpICsgMVxuICAgIDogKGFWYWx1ZSA8PCAxKSArIDA7XG59XG5cbi8qKlxuICogQ29udmVydHMgdG8gYSB0d28tY29tcGxlbWVudCB2YWx1ZSBmcm9tIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gKiBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAqICAgMiAoMTAgYmluYXJ5KSBiZWNvbWVzIDEsIDMgKDExIGJpbmFyeSkgYmVjb21lcyAtMVxuICogICA0ICgxMDAgYmluYXJ5KSBiZWNvbWVzIDIsIDUgKDEwMSBiaW5hcnkpIGJlY29tZXMgLTJcbiAqL1xuZnVuY3Rpb24gZnJvbVZMUVNpZ25lZChhVmFsdWUpIHtcbiAgdmFyIGlzTmVnYXRpdmUgPSAoYVZhbHVlICYgMSkgPT09IDE7XG4gIHZhciBzaGlmdGVkID0gYVZhbHVlID4+IDE7XG4gIHJldHVybiBpc05lZ2F0aXZlXG4gICAgPyAtc2hpZnRlZFxuICAgIDogc2hpZnRlZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBiYXNlIDY0IFZMUSBlbmNvZGVkIHZhbHVlLlxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9lbmNvZGUoYVZhbHVlKSB7XG4gIHZhciBlbmNvZGVkID0gXCJcIjtcbiAgdmFyIGRpZ2l0O1xuXG4gIHZhciB2bHEgPSB0b1ZMUVNpZ25lZChhVmFsdWUpO1xuXG4gIGRvIHtcbiAgICBkaWdpdCA9IHZscSAmIFZMUV9CQVNFX01BU0s7XG4gICAgdmxxID4+Pj0gVkxRX0JBU0VfU0hJRlQ7XG4gICAgaWYgKHZscSA+IDApIHtcbiAgICAgIC8vIFRoZXJlIGFyZSBzdGlsbCBtb3JlIGRpZ2l0cyBpbiB0aGlzIHZhbHVlLCBzbyB3ZSBtdXN0IG1ha2Ugc3VyZSB0aGVcbiAgICAgIC8vIGNvbnRpbnVhdGlvbiBiaXQgaXMgbWFya2VkLlxuICAgICAgZGlnaXQgfD0gVkxRX0NPTlRJTlVBVElPTl9CSVQ7XG4gICAgfVxuICAgIGVuY29kZWQgKz0gYmFzZTY0LmVuY29kZShkaWdpdCk7XG4gIH0gd2hpbGUgKHZscSA+IDApO1xuXG4gIHJldHVybiBlbmNvZGVkO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIHRoZSBuZXh0IGJhc2UgNjQgVkxRIHZhbHVlIGZyb20gdGhlIGdpdmVuIHN0cmluZyBhbmQgcmV0dXJucyB0aGVcbiAqIHZhbHVlIGFuZCB0aGUgcmVzdCBvZiB0aGUgc3RyaW5nIHZpYSB0aGUgb3V0IHBhcmFtZXRlci5cbiAqL1xuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZGVjb2RlKGFTdHIsIGFJbmRleCwgYU91dFBhcmFtKSB7XG4gIHZhciBzdHJMZW4gPSBhU3RyLmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IDA7XG4gIHZhciBzaGlmdCA9IDA7XG4gIHZhciBjb250aW51YXRpb24sIGRpZ2l0O1xuXG4gIGRvIHtcbiAgICBpZiAoYUluZGV4ID49IHN0ckxlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbW9yZSBkaWdpdHMgaW4gYmFzZSA2NCBWTFEgdmFsdWUuXCIpO1xuICAgIH1cblxuICAgIGRpZ2l0ID0gYmFzZTY0LmRlY29kZShhU3RyLmNoYXJDb2RlQXQoYUluZGV4KyspKTtcbiAgICBpZiAoZGlnaXQgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJhc2U2NCBkaWdpdDogXCIgKyBhU3RyLmNoYXJBdChhSW5kZXggLSAxKSk7XG4gICAgfVxuXG4gICAgY29udGludWF0aW9uID0gISEoZGlnaXQgJiBWTFFfQ09OVElOVUFUSU9OX0JJVCk7XG4gICAgZGlnaXQgJj0gVkxRX0JBU0VfTUFTSztcbiAgICByZXN1bHQgPSByZXN1bHQgKyAoZGlnaXQgPDwgc2hpZnQpO1xuICAgIHNoaWZ0ICs9IFZMUV9CQVNFX1NISUZUO1xuICB9IHdoaWxlIChjb250aW51YXRpb24pO1xuXG4gIGFPdXRQYXJhbS52YWx1ZSA9IGZyb21WTFFTaWduZWQocmVzdWx0KTtcbiAgYU91dFBhcmFtLnJlc3QgPSBhSW5kZXg7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spLXNvdXJjZXMvfi9zb3VyY2UtbWFwL2xpYi9iYXNlNjQtdmxxLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgaW50VG9DaGFyTWFwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nLnNwbGl0KCcnKTtcblxuLyoqXG4gKiBFbmNvZGUgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2Ugb2YgMCB0byA2MyB0byBhIHNpbmdsZSBiYXNlIDY0IGRpZ2l0LlxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgaWYgKDAgPD0gbnVtYmVyICYmIG51bWJlciA8IGludFRvQ2hhck1hcC5sZW5ndGgpIHtcbiAgICByZXR1cm4gaW50VG9DaGFyTWFwW251bWJlcl07XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk11c3QgYmUgYmV0d2VlbiAwIGFuZCA2MzogXCIgKyBudW1iZXIpO1xufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBzaW5nbGUgYmFzZSA2NCBjaGFyYWN0ZXIgY29kZSBkaWdpdCB0byBhbiBpbnRlZ2VyLiBSZXR1cm5zIC0xIG9uXG4gKiBmYWlsdXJlLlxuICovXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICB2YXIgYmlnQSA9IDY1OyAgICAgLy8gJ0EnXG4gIHZhciBiaWdaID0gOTA7ICAgICAvLyAnWidcblxuICB2YXIgbGl0dGxlQSA9IDk3OyAgLy8gJ2EnXG4gIHZhciBsaXR0bGVaID0gMTIyOyAvLyAneidcblxuICB2YXIgemVybyA9IDQ4OyAgICAgLy8gJzAnXG4gIHZhciBuaW5lID0gNTc7ICAgICAvLyAnOSdcblxuICB2YXIgcGx1cyA9IDQzOyAgICAgLy8gJysnXG4gIHZhciBzbGFzaCA9IDQ3OyAgICAvLyAnLydcblxuICB2YXIgbGl0dGxlT2Zmc2V0ID0gMjY7XG4gIHZhciBudW1iZXJPZmZzZXQgPSA1MjtcblxuICAvLyAwIC0gMjU6IEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXG4gIGlmIChiaWdBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGJpZ1opIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gYmlnQSk7XG4gIH1cblxuICAvLyAyNiAtIDUxOiBhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elxuICBpZiAobGl0dGxlQSA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBsaXR0bGVaKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIGxpdHRsZUEgKyBsaXR0bGVPZmZzZXQpO1xuICB9XG5cbiAgLy8gNTIgLSA2MTogMDEyMzQ1Njc4OVxuICBpZiAoemVybyA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBuaW5lKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIHplcm8gKyBudW1iZXJPZmZzZXQpO1xuICB9XG5cbiAgLy8gNjI6ICtcbiAgaWYgKGNoYXJDb2RlID09IHBsdXMpIHtcbiAgICByZXR1cm4gNjI7XG4gIH1cblxuICAvLyA2MzogL1xuICBpZiAoY2hhckNvZGUgPT0gc2xhc2gpIHtcbiAgICByZXR1cm4gNjM7XG4gIH1cblxuICAvLyBJbnZhbGlkIGJhc2U2NCBkaWdpdC5cbiAgcmV0dXJuIC0xO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS1zb3VyY2VzL34vc291cmNlLW1hcC9saWIvYmFzZTY0LmpzXG4vLyBtb2R1bGUgaWQgPSAzNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG4vKipcbiAqIFRoaXMgaXMgYSBoZWxwZXIgZnVuY3Rpb24gZm9yIGdldHRpbmcgdmFsdWVzIGZyb20gcGFyYW1ldGVyL29wdGlvbnNcbiAqIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIGFyZ3MgVGhlIG9iamVjdCB3ZSBhcmUgZXh0cmFjdGluZyB2YWx1ZXMgZnJvbVxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdlIGFyZSBnZXR0aW5nLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBBbiBvcHRpb25hbCB2YWx1ZSB0byByZXR1cm4gaWYgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmdcbiAqIGZyb20gdGhlIG9iamVjdC4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkIGFuZCB0aGUgcHJvcGVydHkgaXMgbWlzc2luZywgYW5cbiAqIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICovXG5mdW5jdGlvbiBnZXRBcmcoYUFyZ3MsIGFOYW1lLCBhRGVmYXVsdFZhbHVlKSB7XG4gIGlmIChhTmFtZSBpbiBhQXJncykge1xuICAgIHJldHVybiBhQXJnc1thTmFtZV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHJldHVybiBhRGVmYXVsdFZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYU5hbWUgKyAnXCIgaXMgYSByZXF1aXJlZCBhcmd1bWVudC4nKTtcbiAgfVxufVxuZXhwb3J0cy5nZXRBcmcgPSBnZXRBcmc7XG5cbnZhciB1cmxSZWdleHAgPSAvXig/OihbXFx3K1xcLS5dKyk6KT9cXC9cXC8oPzooXFx3KzpcXHcrKUApPyhbXFx3Ll0qKSg/OjooXFxkKykpPyhcXFMqKSQvO1xudmFyIGRhdGFVcmxSZWdleHAgPSAvXmRhdGE6LitcXCwuKyQvO1xuXG5mdW5jdGlvbiB1cmxQYXJzZShhVXJsKSB7XG4gIHZhciBtYXRjaCA9IGFVcmwubWF0Y2godXJsUmVnZXhwKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgc2NoZW1lOiBtYXRjaFsxXSxcbiAgICBhdXRoOiBtYXRjaFsyXSxcbiAgICBob3N0OiBtYXRjaFszXSxcbiAgICBwb3J0OiBtYXRjaFs0XSxcbiAgICBwYXRoOiBtYXRjaFs1XVxuICB9O1xufVxuZXhwb3J0cy51cmxQYXJzZSA9IHVybFBhcnNlO1xuXG5mdW5jdGlvbiB1cmxHZW5lcmF0ZShhUGFyc2VkVXJsKSB7XG4gIHZhciB1cmwgPSAnJztcbiAgaWYgKGFQYXJzZWRVcmwuc2NoZW1lKSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwuc2NoZW1lICsgJzonO1xuICB9XG4gIHVybCArPSAnLy8nO1xuICBpZiAoYVBhcnNlZFVybC5hdXRoKSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwuYXV0aCArICdAJztcbiAgfVxuICBpZiAoYVBhcnNlZFVybC5ob3N0KSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwuaG9zdDtcbiAgfVxuICBpZiAoYVBhcnNlZFVybC5wb3J0KSB7XG4gICAgdXJsICs9IFwiOlwiICsgYVBhcnNlZFVybC5wb3J0XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwucGF0aCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLnBhdGg7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cbmV4cG9ydHMudXJsR2VuZXJhdGUgPSB1cmxHZW5lcmF0ZTtcblxuLyoqXG4gKiBOb3JtYWxpemVzIGEgcGF0aCwgb3IgdGhlIHBhdGggcG9ydGlvbiBvZiBhIFVSTDpcbiAqXG4gKiAtIFJlcGxhY2VzIGNvbnNlY3V0aXZlIHNsYXNoZXMgd2l0aCBvbmUgc2xhc2guXG4gKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJy4nIHBhcnRzLlxuICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICc8ZGlyPi8uLicgcGFydHMuXG4gKlxuICogQmFzZWQgb24gY29kZSBpbiB0aGUgTm9kZS5qcyAncGF0aCcgY29yZSBtb2R1bGUuXG4gKlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIHVybCB0byBub3JtYWxpemUuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShhUGF0aCkge1xuICB2YXIgcGF0aCA9IGFQYXRoO1xuICB2YXIgdXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICBpZiAodXJsKSB7XG4gICAgaWYgKCF1cmwucGF0aCkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cbiAgICBwYXRoID0gdXJsLnBhdGg7XG4gIH1cbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCk7XG5cbiAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgvXFwvKy8pO1xuICBmb3IgKHZhciBwYXJ0LCB1cCA9IDAsIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXAgPiAwKSB7XG4gICAgICBpZiAocGFydCA9PT0gJycpIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHBhcnQgaXMgYmxhbmsgaWYgdGhlIHBhdGggaXMgYWJzb2x1dGUuIFRyeWluZyB0byBnb1xuICAgICAgICAvLyBhYm92ZSB0aGUgcm9vdCBpcyBhIG5vLW9wLiBUaGVyZWZvcmUgd2UgY2FuIHJlbW92ZSBhbGwgJy4uJyBwYXJ0c1xuICAgICAgICAvLyBkaXJlY3RseSBhZnRlciB0aGUgcm9vdC5cbiAgICAgICAgcGFydHMuc3BsaWNlKGkgKyAxLCB1cCk7XG4gICAgICAgIHVwID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzLnNwbGljZShpLCAyKTtcbiAgICAgICAgdXAtLTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGF0aCA9IHBhcnRzLmpvaW4oJy8nKTtcblxuICBpZiAocGF0aCA9PT0gJycpIHtcbiAgICBwYXRoID0gaXNBYnNvbHV0ZSA/ICcvJyA6ICcuJztcbiAgfVxuXG4gIGlmICh1cmwpIHtcbiAgICB1cmwucGF0aCA9IHBhdGg7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKHVybCk7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcblxuLyoqXG4gKiBKb2lucyB0d28gcGF0aHMvVVJMcy5cbiAqXG4gKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIGpvaW5lZCB3aXRoIHRoZSByb290LlxuICpcbiAqIC0gSWYgYVBhdGggaXMgYSBVUkwgb3IgYSBkYXRhIFVSSSwgYVBhdGggaXMgcmV0dXJuZWQsIHVubGVzcyBhUGF0aCBpcyBhXG4gKiAgIHNjaGVtZS1yZWxhdGl2ZSBVUkw6IFRoZW4gdGhlIHNjaGVtZSBvZiBhUm9vdCwgaWYgYW55LCBpcyBwcmVwZW5kZWRcbiAqICAgZmlyc3QuXG4gKiAtIE90aGVyd2lzZSBhUGF0aCBpcyBhIHBhdGguIElmIGFSb290IGlzIGEgVVJMLCB0aGVuIGl0cyBwYXRoIHBvcnRpb25cbiAqICAgaXMgdXBkYXRlZCB3aXRoIHRoZSByZXN1bHQgYW5kIGFSb290IGlzIHJldHVybmVkLiBPdGhlcndpc2UgdGhlIHJlc3VsdFxuICogICBpcyByZXR1cm5lZC5cbiAqICAgLSBJZiBhUGF0aCBpcyBhYnNvbHV0ZSwgdGhlIHJlc3VsdCBpcyBhUGF0aC5cbiAqICAgLSBPdGhlcndpc2UgdGhlIHR3byBwYXRocyBhcmUgam9pbmVkIHdpdGggYSBzbGFzaC5cbiAqIC0gSm9pbmluZyBmb3IgZXhhbXBsZSAnaHR0cDovLycgYW5kICd3d3cuZXhhbXBsZS5jb20nIGlzIGFsc28gc3VwcG9ydGVkLlxuICovXG5mdW5jdGlvbiBqb2luKGFSb290LCBhUGF0aCkge1xuICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICBhUm9vdCA9IFwiLlwiO1xuICB9XG4gIGlmIChhUGF0aCA9PT0gXCJcIikge1xuICAgIGFQYXRoID0gXCIuXCI7XG4gIH1cbiAgdmFyIGFQYXRoVXJsID0gdXJsUGFyc2UoYVBhdGgpO1xuICB2YXIgYVJvb3RVcmwgPSB1cmxQYXJzZShhUm9vdCk7XG4gIGlmIChhUm9vdFVybCkge1xuICAgIGFSb290ID0gYVJvb3RVcmwucGF0aCB8fCAnLyc7XG4gIH1cblxuICAvLyBgam9pbihmb28sICcvL3d3dy5leGFtcGxlLm9yZycpYFxuICBpZiAoYVBhdGhVcmwgJiYgIWFQYXRoVXJsLnNjaGVtZSkge1xuICAgIGlmIChhUm9vdFVybCkge1xuICAgICAgYVBhdGhVcmwuc2NoZW1lID0gYVJvb3RVcmwuc2NoZW1lO1xuICAgIH1cbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVBhdGhVcmwpO1xuICB9XG5cbiAgaWYgKGFQYXRoVXJsIHx8IGFQYXRoLm1hdGNoKGRhdGFVcmxSZWdleHApKSB7XG4gICAgcmV0dXJuIGFQYXRoO1xuICB9XG5cbiAgLy8gYGpvaW4oJ2h0dHA6Ly8nLCAnd3d3LmV4YW1wbGUuY29tJylgXG4gIGlmIChhUm9vdFVybCAmJiAhYVJvb3RVcmwuaG9zdCAmJiAhYVJvb3RVcmwucGF0aCkge1xuICAgIGFSb290VXJsLmhvc3QgPSBhUGF0aDtcbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICB9XG5cbiAgdmFyIGpvaW5lZCA9IGFQYXRoLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgPyBhUGF0aFxuICAgIDogbm9ybWFsaXplKGFSb290LnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgYVBhdGgpO1xuXG4gIGlmIChhUm9vdFVybCkge1xuICAgIGFSb290VXJsLnBhdGggPSBqb2luZWQ7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgfVxuICByZXR1cm4gam9pbmVkO1xufVxuZXhwb3J0cy5qb2luID0gam9pbjtcblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24gKGFQYXRoKSB7XG4gIHJldHVybiBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJyB8fCAhIWFQYXRoLm1hdGNoKHVybFJlZ2V4cCk7XG59O1xuXG4vKipcbiAqIE1ha2UgYSBwYXRoIHJlbGF0aXZlIHRvIGEgVVJMIG9yIGFub3RoZXIgcGF0aC5cbiAqXG4gKiBAcGFyYW0gYVJvb3QgVGhlIHJvb3QgcGF0aCBvciBVUkwuXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgVVJMIHRvIGJlIG1hZGUgcmVsYXRpdmUgdG8gYVJvb3QuXG4gKi9cbmZ1bmN0aW9uIHJlbGF0aXZlKGFSb290LCBhUGF0aCkge1xuICBpZiAoYVJvb3QgPT09IFwiXCIpIHtcbiAgICBhUm9vdCA9IFwiLlwiO1xuICB9XG5cbiAgYVJvb3QgPSBhUm9vdC5yZXBsYWNlKC9cXC8kLywgJycpO1xuXG4gIC8vIEl0IGlzIHBvc3NpYmxlIGZvciB0aGUgcGF0aCB0byBiZSBhYm92ZSB0aGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBzaW1wbHlcbiAgLy8gY2hlY2tpbmcgd2hldGhlciB0aGUgcm9vdCBpcyBhIHByZWZpeCBvZiB0aGUgcGF0aCB3b24ndCB3b3JrLiBJbnN0ZWFkLCB3ZVxuICAvLyBuZWVkIHRvIHJlbW92ZSBjb21wb25lbnRzIGZyb20gdGhlIHJvb3Qgb25lIGJ5IG9uZSwgdW50aWwgZWl0aGVyIHdlIGZpbmRcbiAgLy8gYSBwcmVmaXggdGhhdCBmaXRzLCBvciB3ZSBydW4gb3V0IG9mIGNvbXBvbmVudHMgdG8gcmVtb3ZlLlxuICB2YXIgbGV2ZWwgPSAwO1xuICB3aGlsZSAoYVBhdGguaW5kZXhPZihhUm9vdCArICcvJykgIT09IDApIHtcbiAgICB2YXIgaW5kZXggPSBhUm9vdC5sYXN0SW5kZXhPZihcIi9cIik7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBvbmx5IHBhcnQgb2YgdGhlIHJvb3QgdGhhdCBpcyBsZWZ0IGlzIHRoZSBzY2hlbWUgKGkuZS4gaHR0cDovLyxcbiAgICAvLyBmaWxlOi8vLywgZXRjLiksIG9uZSBvciBtb3JlIHNsYXNoZXMgKC8pLCBvciBzaW1wbHkgbm90aGluZyBhdCBhbGwsIHdlXG4gICAgLy8gaGF2ZSBleGhhdXN0ZWQgYWxsIGNvbXBvbmVudHMsIHNvIHRoZSBwYXRoIGlzIG5vdCByZWxhdGl2ZSB0byB0aGUgcm9vdC5cbiAgICBhUm9vdCA9IGFSb290LnNsaWNlKDAsIGluZGV4KTtcbiAgICBpZiAoYVJvb3QubWF0Y2goL14oW15cXC9dKzpcXC8pP1xcLyokLykpIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICArK2xldmVsO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHdlIGFkZCBhIFwiLi4vXCIgZm9yIGVhY2ggY29tcG9uZW50IHdlIHJlbW92ZWQgZnJvbSB0aGUgcm9vdC5cbiAgcmV0dXJuIEFycmF5KGxldmVsICsgMSkuam9pbihcIi4uL1wiKSArIGFQYXRoLnN1YnN0cihhUm9vdC5sZW5ndGggKyAxKTtcbn1cbmV4cG9ydHMucmVsYXRpdmUgPSByZWxhdGl2ZTtcblxudmFyIHN1cHBvcnRzTnVsbFByb3RvID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAhKCdfX3Byb3RvX18nIGluIG9iaik7XG59KCkpO1xuXG5mdW5jdGlvbiBpZGVudGl0eSAocykge1xuICByZXR1cm4gcztcbn1cblxuLyoqXG4gKiBCZWNhdXNlIGJlaGF2aW9yIGdvZXMgd2Fja3kgd2hlbiB5b3Ugc2V0IGBfX3Byb3RvX19gIG9uIG9iamVjdHMsIHdlXG4gKiBoYXZlIHRvIHByZWZpeCBhbGwgdGhlIHN0cmluZ3MgaW4gb3VyIHNldCB3aXRoIGFuIGFyYml0cmFyeSBjaGFyYWN0ZXIuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvcHVsbC8zMSBhbmRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzMwXG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbmZ1bmN0aW9uIHRvU2V0U3RyaW5nKGFTdHIpIHtcbiAgaWYgKGlzUHJvdG9TdHJpbmcoYVN0cikpIHtcbiAgICByZXR1cm4gJyQnICsgYVN0cjtcbiAgfVxuXG4gIHJldHVybiBhU3RyO1xufVxuZXhwb3J0cy50b1NldFN0cmluZyA9IHN1cHBvcnRzTnVsbFByb3RvID8gaWRlbnRpdHkgOiB0b1NldFN0cmluZztcblxuZnVuY3Rpb24gZnJvbVNldFN0cmluZyhhU3RyKSB7XG4gIGlmIChpc1Byb3RvU3RyaW5nKGFTdHIpKSB7XG4gICAgcmV0dXJuIGFTdHIuc2xpY2UoMSk7XG4gIH1cblxuICByZXR1cm4gYVN0cjtcbn1cbmV4cG9ydHMuZnJvbVNldFN0cmluZyA9IHN1cHBvcnRzTnVsbFByb3RvID8gaWRlbnRpdHkgOiBmcm9tU2V0U3RyaW5nO1xuXG5mdW5jdGlvbiBpc1Byb3RvU3RyaW5nKHMpIHtcbiAgaWYgKCFzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IHMubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPCA5IC8qIFwiX19wcm90b19fXCIubGVuZ3RoICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHMuY2hhckNvZGVBdChsZW5ndGggLSAxKSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDIpICE9PSA5NSAgLyogJ18nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMykgIT09IDExMSAvKiAnbycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA0KSAhPT0gMTE2IC8qICd0JyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDUpICE9PSAxMTEgLyogJ28nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNikgIT09IDExNCAvKiAncicgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA3KSAhPT0gMTEyIC8qICdwJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDgpICE9PSA5NSAgLyogJ18nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gOSkgIT09IDk1ICAvKiAnXycgKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTA7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKHMuY2hhckNvZGVBdChpKSAhPT0gMzYgLyogJyQnICovKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aGVyZSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqXG4gKiBPcHRpb25hbGx5IHBhc3MgaW4gYHRydWVgIGFzIGBvbmx5Q29tcGFyZUdlbmVyYXRlZGAgdG8gY29uc2lkZXIgdHdvXG4gKiBtYXBwaW5ncyB3aXRoIHRoZSBzYW1lIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiwgYnV0IGRpZmZlcmVudCBnZW5lcmF0ZWRcbiAqIGxpbmUgYW5kIGNvbHVtbiB0aGUgc2FtZS4gVXNlZnVsIHdoZW4gc2VhcmNoaW5nIGZvciBhIG1hcHBpbmcgd2l0aCBhXG4gKiBzdHViYmVkIG91dCBtYXBwaW5nLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyhtYXBwaW5nQSwgbWFwcGluZ0IsIG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgdmFyIGNtcCA9IG1hcHBpbmdBLnNvdXJjZSAtIG1hcHBpbmdCLnNvdXJjZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gbWFwcGluZ0EubmFtZSAtIG1hcHBpbmdCLm5hbWU7XG59XG5leHBvcnRzLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zID0gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnM7XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGRlZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBpbmRpY2VzIHdoZXJlXG4gKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uLCBidXQgZGlmZmVyZW50XG4gKiBzb3VyY2UvbmFtZS9vcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYVxuICogbWFwcGluZyB3aXRoIGEgc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLnNvdXJjZSAtIG1hcHBpbmdCLnNvdXJjZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gbWFwcGluZ0EubmFtZSAtIG1hcHBpbmdCLm5hbWU7XG59XG5leHBvcnRzLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQ7XG5cbmZ1bmN0aW9uIHN0cmNtcChhU3RyMSwgYVN0cjIpIHtcbiAgaWYgKGFTdHIxID09PSBhU3RyMikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGFTdHIxID4gYVN0cjIpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdpdGggaW5mbGF0ZWQgc291cmNlIGFuZCBuYW1lIHN0cmluZ3Mgd2hlcmVcbiAqIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zIGFyZSBjb21wYXJlZC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gIHZhciBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW4gLSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gc3RyY21wKG1hcHBpbmdBLnNvdXJjZSwgbWFwcGluZ0Iuc291cmNlKTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xufVxuZXhwb3J0cy5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCA9IGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spLXNvdXJjZXMvfi9zb3VyY2UtbWFwL2xpYi91dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBkYXRhIHN0cnVjdHVyZSB3aGljaCBpcyBhIGNvbWJpbmF0aW9uIG9mIGFuIGFycmF5IGFuZCBhIHNldC4gQWRkaW5nIGEgbmV3XG4gKiBtZW1iZXIgaXMgTygxKSwgdGVzdGluZyBmb3IgbWVtYmVyc2hpcCBpcyBPKDEpLCBhbmQgZmluZGluZyB0aGUgaW5kZXggb2YgYW5cbiAqIGVsZW1lbnQgaXMgTygxKS4gUmVtb3ZpbmcgZWxlbWVudHMgZnJvbSB0aGUgc2V0IGlzIG5vdCBzdXBwb3J0ZWQuIE9ubHlcbiAqIHN0cmluZ3MgYXJlIHN1cHBvcnRlZCBmb3IgbWVtYmVyc2hpcC5cbiAqL1xuZnVuY3Rpb24gQXJyYXlTZXQoKSB7XG4gIHRoaXMuX2FycmF5ID0gW107XG4gIHRoaXMuX3NldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5cbi8qKlxuICogU3RhdGljIG1ldGhvZCBmb3IgY3JlYXRpbmcgQXJyYXlTZXQgaW5zdGFuY2VzIGZyb20gYW4gZXhpc3RpbmcgYXJyYXkuXG4gKi9cbkFycmF5U2V0LmZyb21BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X2Zyb21BcnJheShhQXJyYXksIGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgdmFyIHNldCA9IG5ldyBBcnJheVNldCgpO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYUFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgc2V0LmFkZChhQXJyYXlbaV0sIGFBbGxvd0R1cGxpY2F0ZXMpO1xuICB9XG4gIHJldHVybiBzZXQ7XG59O1xuXG4vKipcbiAqIFJldHVybiBob3cgbWFueSB1bmlxdWUgaXRlbXMgYXJlIGluIHRoaXMgQXJyYXlTZXQuIElmIGR1cGxpY2F0ZXMgaGF2ZSBiZWVuXG4gKiBhZGRlZCwgdGhhbiB0aG9zZSBkbyBub3QgY291bnQgdG93YXJkcyB0aGUgc2l6ZS5cbiAqXG4gKiBAcmV0dXJucyBOdW1iZXJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBBcnJheVNldF9zaXplKCkge1xuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5fc2V0KS5sZW5ndGg7XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gc3RyaW5nIHRvIHRoaXMgc2V0LlxuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gQXJyYXlTZXRfYWRkKGFTdHIsIGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICB2YXIgaXNEdXBsaWNhdGUgPSBoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpO1xuICB2YXIgaWR4ID0gdGhpcy5fYXJyYXkubGVuZ3RoO1xuICBpZiAoIWlzRHVwbGljYXRlIHx8IGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFTdHIpO1xuICB9XG4gIGlmICghaXNEdXBsaWNhdGUpIHtcbiAgICB0aGlzLl9zZXRbc1N0cl0gPSBpZHg7XG4gIH1cbn07XG5cbi8qKlxuICogSXMgdGhlIGdpdmVuIHN0cmluZyBhIG1lbWJlciBvZiB0aGlzIHNldD9cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIEFycmF5U2V0X2hhcyhhU3RyKSB7XG4gIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgcmV0dXJuIGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cik7XG59O1xuXG4vKipcbiAqIFdoYXQgaXMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBzdHJpbmcgaW4gdGhlIGFycmF5P1xuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIEFycmF5U2V0X2luZGV4T2YoYVN0cikge1xuICB2YXIgc1N0ciA9IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gIGlmIChoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldFtzU3RyXTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTdHIgKyAnXCIgaXMgbm90IGluIHRoZSBzZXQuJyk7XG59O1xuXG4vKipcbiAqIFdoYXQgaXMgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4P1xuICpcbiAqIEBwYXJhbSBOdW1iZXIgYUlkeFxuICovXG5BcnJheVNldC5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBBcnJheVNldF9hdChhSWR4KSB7XG4gIGlmIChhSWR4ID49IDAgJiYgYUlkeCA8IHRoaXMuX2FycmF5Lmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheVthSWR4XTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ05vIGVsZW1lbnQgaW5kZXhlZCBieSAnICsgYUlkeCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc2V0ICh3aGljaCBoYXMgdGhlIHByb3BlciBpbmRpY2VzXG4gKiBpbmRpY2F0ZWQgYnkgaW5kZXhPZikuIE5vdGUgdGhhdCB0aGlzIGlzIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgYXJyYXkgdXNlZFxuICogZm9yIHN0b3JpbmcgdGhlIG1lbWJlcnMgc28gdGhhdCBubyBvbmUgY2FuIG1lc3Mgd2l0aCBpbnRlcm5hbCBzdGF0ZS5cbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF90b0FycmF5KCkge1xuICByZXR1cm4gdGhpcy5fYXJyYXkuc2xpY2UoKTtcbn07XG5cbmV4cG9ydHMuQXJyYXlTZXQgPSBBcnJheVNldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS1zb3VyY2VzL34vc291cmNlLW1hcC9saWIvYXJyYXktc2V0LmpzXG4vLyBtb2R1bGUgaWQgPSAzNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDE0IE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIG1hcHBpbmdCIGlzIGFmdGVyIG1hcHBpbmdBIHdpdGggcmVzcGVjdCB0byBnZW5lcmF0ZWRcbiAqIHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICAvLyBPcHRpbWl6ZWQgZm9yIG1vc3QgY29tbW9uIGNhc2VcbiAgdmFyIGxpbmVBID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZTtcbiAgdmFyIGxpbmVCID0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgdmFyIGNvbHVtbkEgPSBtYXBwaW5nQS5nZW5lcmF0ZWRDb2x1bW47XG4gIHZhciBjb2x1bW5CID0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICByZXR1cm4gbGluZUIgPiBsaW5lQSB8fCBsaW5lQiA9PSBsaW5lQSAmJiBjb2x1bW5CID49IGNvbHVtbkEgfHxcbiAgICAgICAgIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCKSA8PSAwO1xufVxuXG4vKipcbiAqIEEgZGF0YSBzdHJ1Y3R1cmUgdG8gcHJvdmlkZSBhIHNvcnRlZCB2aWV3IG9mIGFjY3VtdWxhdGVkIG1hcHBpbmdzIGluIGFcbiAqIHBlcmZvcm1hbmNlIGNvbnNjaW91cyBtYW5uZXIuIEl0IHRyYWRlcyBhIG5lZ2xpYmFibGUgb3ZlcmhlYWQgaW4gZ2VuZXJhbFxuICogY2FzZSBmb3IgYSBsYXJnZSBzcGVlZHVwIGluIGNhc2Ugb2YgbWFwcGluZ3MgYmVpbmcgYWRkZWQgaW4gb3JkZXIuXG4gKi9cbmZ1bmN0aW9uIE1hcHBpbmdMaXN0KCkge1xuICB0aGlzLl9hcnJheSA9IFtdO1xuICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICAvLyBTZXJ2ZXMgYXMgaW5maW11bVxuICB0aGlzLl9sYXN0ID0ge2dlbmVyYXRlZExpbmU6IC0xLCBnZW5lcmF0ZWRDb2x1bW46IDB9O1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgdGhyb3VnaCBpbnRlcm5hbCBpdGVtcy4gVGhpcyBtZXRob2QgdGFrZXMgdGhlIHNhbWUgYXJndW1lbnRzIHRoYXRcbiAqIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgdGFrZXMuXG4gKlxuICogTk9URTogVGhlIG9yZGVyIG9mIHRoZSBtYXBwaW5ncyBpcyBOT1QgZ3VhcmFudGVlZC5cbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLnVuc29ydGVkRm9yRWFjaCA9XG4gIGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2ZvckVhY2goYUNhbGxiYWNrLCBhVGhpc0FyZykge1xuICAgIHRoaXMuX2FycmF5LmZvckVhY2goYUNhbGxiYWNrLCBhVGhpc0FyZyk7XG4gIH07XG5cbi8qKlxuICogQWRkIHRoZSBnaXZlbiBzb3VyY2UgbWFwcGluZy5cbiAqXG4gKiBAcGFyYW0gT2JqZWN0IGFNYXBwaW5nXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF9hZGQoYU1hcHBpbmcpIHtcbiAgaWYgKGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIodGhpcy5fbGFzdCwgYU1hcHBpbmcpKSB7XG4gICAgdGhpcy5fbGFzdCA9IGFNYXBwaW5nO1xuICAgIHRoaXMuX2FycmF5LnB1c2goYU1hcHBpbmcpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3NvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2FycmF5LnB1c2goYU1hcHBpbmcpO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZsYXQsIHNvcnRlZCBhcnJheSBvZiBtYXBwaW5ncy4gVGhlIG1hcHBpbmdzIGFyZSBzb3J0ZWQgYnlcbiAqIGdlbmVyYXRlZCBwb3NpdGlvbi5cbiAqXG4gKiBXQVJOSU5HOiBUaGlzIG1ldGhvZCByZXR1cm5zIGludGVybmFsIGRhdGEgd2l0aG91dCBjb3B5aW5nLCBmb3JcbiAqIHBlcmZvcm1hbmNlLiBUaGUgcmV0dXJuIHZhbHVlIG11c3QgTk9UIGJlIG11dGF0ZWQsIGFuZCBzaG91bGQgYmUgdHJlYXRlZCBhc1xuICogYW4gaW1tdXRhYmxlIGJvcnJvdy4gSWYgeW91IHdhbnQgdG8gdGFrZSBvd25lcnNoaXAsIHlvdSBtdXN0IG1ha2UgeW91ciBvd25cbiAqIGNvcHkuXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfdG9BcnJheSgpIHtcbiAgaWYgKCF0aGlzLl9zb3J0ZWQpIHtcbiAgICB0aGlzLl9hcnJheS5zb3J0KHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQpO1xuICAgIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5O1xufTtcblxuZXhwb3J0cy5NYXBwaW5nTGlzdCA9IE1hcHBpbmdMaXN0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spLXNvdXJjZXMvfi9zb3VyY2UtbWFwL2xpYi9tYXBwaW5nLWxpc3QuanNcbi8vIG1vZHVsZSBpZCA9IDM0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgYmluYXJ5U2VhcmNoID0gcmVxdWlyZSgnLi9iaW5hcnktc2VhcmNoJyk7XG52YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xudmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xudmFyIHF1aWNrU29ydCA9IHJlcXVpcmUoJy4vcXVpY2stc29ydCcpLnF1aWNrU29ydDtcblxuZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IEpTT04ucGFyc2UoYVNvdXJjZU1hcC5yZXBsYWNlKC9eXFwpXFxdXFx9Jy8sICcnKSk7XG4gIH1cblxuICByZXR1cm4gc291cmNlTWFwLnNlY3Rpb25zICE9IG51bGxcbiAgICA/IG5ldyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwKVxuICAgIDogbmV3IEJhc2ljU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwKTtcbn1cblxuU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9IGZ1bmN0aW9uKGFTb3VyY2VNYXApIHtcbiAgcmV0dXJuIEJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcChhU291cmNlTWFwKTtcbn1cblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8vIGBfX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmQgYF9fb3JpZ2luYWxNYXBwaW5nc2AgYXJlIGFycmF5cyB0aGF0IGhvbGQgdGhlXG4vLyBwYXJzZWQgbWFwcGluZyBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgbWFwJ3MgXCJtYXBwaW5nc1wiIGF0dHJpYnV0ZS4gVGhleVxuLy8gYXJlIGxhemlseSBpbnN0YW50aWF0ZWQsIGFjY2Vzc2VkIHZpYSB0aGUgYF9nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4vLyBgX29yaWdpbmFsTWFwcGluZ3NgIGdldHRlcnMgcmVzcGVjdGl2ZWx5LCBhbmQgd2Ugb25seSBwYXJzZSB0aGUgbWFwcGluZ3Ncbi8vIGFuZCBjcmVhdGUgdGhlc2UgYXJyYXlzIG9uY2UgcXVlcmllZCBmb3IgYSBzb3VyY2UgbG9jYXRpb24uIFdlIGp1bXAgdGhyb3VnaFxuLy8gdGhlc2UgaG9vcHMgYmVjYXVzZSB0aGVyZSBjYW4gYmUgbWFueSB0aG91c2FuZHMgb2YgbWFwcGluZ3MsIGFuZCBwYXJzaW5nXG4vLyB0aGVtIGlzIGV4cGVuc2l2ZSwgc28gd2Ugb25seSB3YW50IHRvIGRvIGl0IGlmIHdlIG11c3QuXG4vL1xuLy8gRWFjaCBvYmplY3QgaW4gdGhlIGFycmF5cyBpcyBvZiB0aGUgZm9ybTpcbi8vXG4vLyAgICAge1xuLy8gICAgICAgZ2VuZXJhdGVkTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIGdlbmVyYXRlZENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgc291cmNlOiBUaGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgdGhhdCBnZW5lcmF0ZWQgdGhpc1xuLy8gICAgICAgICAgICAgICBjaHVuayBvZiBjb2RlLFxuLy8gICAgICAgb3JpZ2luYWxMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBvcmlnaW5hbENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBvcmlnaW5hbCBzeW1ib2wgd2hpY2ggZ2VuZXJhdGVkIHRoaXMgY2h1bmsgb2Zcbi8vICAgICAgICAgICAgIGNvZGUuXG4vLyAgICAgfVxuLy9cbi8vIEFsbCBwcm9wZXJ0aWVzIGV4Y2VwdCBmb3IgYGdlbmVyYXRlZExpbmVgIGFuZCBgZ2VuZXJhdGVkQ29sdW1uYCBjYW4gYmVcbi8vIGBudWxsYC5cbi8vXG4vLyBgX2dlbmVyYXRlZE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zLlxuLy9cbi8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zLlxuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IG51bGw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX2dlbmVyYXRlZE1hcHBpbmdzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncykge1xuICAgICAgdGhpcy5fcGFyc2VNYXBwaW5ncyh0aGlzLl9tYXBwaW5ncywgdGhpcy5zb3VyY2VSb290KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzO1xuICB9XG59KTtcblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG51bGw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX29yaWdpbmFsTWFwcGluZ3MnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MpIHtcbiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzO1xuICB9XG59KTtcblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyLCBpbmRleCkge1xuICAgIHZhciBjID0gYVN0ci5jaGFyQXQoaW5kZXgpO1xuICAgIHJldHVybiBjID09PSBcIjtcIiB8fCBjID09PSBcIixcIjtcbiAgfTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IF9wYXJzZU1hcHBpbmdzXCIpO1xuICB9O1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVIgPSAxO1xuU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVIgPSAyO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG5Tb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGVhY2ggbWFwcGluZyBiZXR3ZWVuIGFuIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiBhbmQgYVxuICogZ2VuZXJhdGVkIGxpbmUvY29sdW1uIGluIHRoaXMgc291cmNlIG1hcC5cbiAqXG4gKiBAcGFyYW0gRnVuY3Rpb24gYUNhbGxiYWNrXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggZWFjaCBtYXBwaW5nLlxuICogQHBhcmFtIE9iamVjdCBhQ29udGV4dFxuICogICAgICAgIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIHZhbHVlIG9mIGB0aGlzYCBldmVyeVxuICogICAgICAgIHRpbWUgdGhhdCBgYUNhbGxiYWNrYCBpcyBjYWxsZWQuXG4gKiBAcGFyYW0gYU9yZGVyXG4gKiAgICAgICAgRWl0aGVyIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgIG9yXG4gKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSYC4gU3BlY2lmaWVzIHdoZXRoZXIgeW91IHdhbnQgdG9cbiAqICAgICAgICBpdGVyYXRlIG92ZXIgdGhlIG1hcHBpbmdzIHNvcnRlZCBieSB0aGUgZ2VuZXJhdGVkIGZpbGUncyBsaW5lL2NvbHVtblxuICogICAgICAgIG9yZGVyIG9yIHRoZSBvcmlnaW5hbCdzIHNvdXJjZS9saW5lL2NvbHVtbiBvcmRlciwgcmVzcGVjdGl2ZWx5LiBEZWZhdWx0cyB0b1xuICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZWFjaE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9lYWNoTWFwcGluZyhhQ2FsbGJhY2ssIGFDb250ZXh0LCBhT3JkZXIpIHtcbiAgICB2YXIgY29udGV4dCA9IGFDb250ZXh0IHx8IG51bGw7XG4gICAgdmFyIG9yZGVyID0gYU9yZGVyIHx8IFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjtcblxuICAgIHZhciBtYXBwaW5ncztcbiAgICBzd2l0Y2ggKG9yZGVyKSB7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI6XG4gICAgICBtYXBwaW5ncyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUjpcbiAgICAgIG1hcHBpbmdzID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5ncztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9yZGVyIG9mIGl0ZXJhdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLnNvdXJjZVJvb3Q7XG4gICAgbWFwcGluZ3MubWFwKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2UgPT09IG51bGwgPyBudWxsIDogdGhpcy5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICBpZiAoc291cmNlICE9IG51bGwgJiYgc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbihzb3VyY2VSb290LCBzb3VyY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbixcbiAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgIG5hbWU6IG1hcHBpbmcubmFtZSA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpXG4gICAgICB9O1xuICAgIH0sIHRoaXMpLmZvckVhY2goYUNhbGxiYWNrLCBjb250ZXh0KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwcm92aWRlZC4gSWYgbm8gY29sdW1uIGlzIHByb3ZpZGVkLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byBhIGVpdGhlciB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciBvciB0aGUgbmV4dFxuICogY2xvc2VzdCBsaW5lIHRoYXQgaGFzIGFueSBtYXBwaW5ncy4gT3RoZXJ3aXNlLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbGluZSBhbmQgZWl0aGVyIHRoZSBjb2x1bW4gd2UgYXJlIHNlYXJjaGluZyBmb3JcbiAqIG9yIHRoZSBuZXh0IGNsb3Nlc3QgY29sdW1uIHRoYXQgaGFzIGFueSBvZmZzZXRzLlxuICpcbiAqIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IE9wdGlvbmFsLiB0aGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICpcbiAqIGFuZCBhbiBhcnJheSBvZiBvYmplY3RzIGlzIHJldHVybmVkLCBlYWNoIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmFsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2FsbEdlbmVyYXRlZFBvc2l0aW9uc0ZvcihhQXJncykge1xuICAgIHZhciBsaW5lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyk7XG5cbiAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIGV4YWN0IG1hdGNoLCBCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmdcbiAgICAvLyByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgY2xvc2VzdCBtYXBwaW5nIGxlc3MgdGhhbiB0aGUgbmVlZGxlLiBCeVxuICAgIC8vIHNldHRpbmcgbmVlZGxlLm9yaWdpbmFsQ29sdW1uIHRvIDAsIHdlIHRodXMgZmluZCB0aGUgbGFzdCBtYXBwaW5nIGZvclxuICAgIC8vIHRoZSBnaXZlbiBsaW5lLCBwcm92aWRlZCBzdWNoIGEgbWFwcGluZyBleGlzdHMuXG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIHNvdXJjZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSxcbiAgICAgIG9yaWdpbmFsTGluZTogbGluZSxcbiAgICAgIG9yaWdpbmFsQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicsIDApXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgbmVlZGxlLnNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBuZWVkbGUuc291cmNlKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9zb3VyY2VzLmhhcyhuZWVkbGUuc291cmNlKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBuZWVkbGUuc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG5lZWRsZS5zb3VyY2UpO1xuXG4gICAgdmFyIG1hcHBpbmdzID0gW107XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhuZWVkbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxNYXBwaW5ncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmFyeVNlYXJjaC5MRUFTVF9VUFBFUl9CT1VORCk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChhQXJncy5jb2x1bW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgb3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSB1bnRpbCBlaXRoZXIgd2UgcnVuIG91dCBvZiBtYXBwaW5ncywgb3Igd2UgcnVuIGludG9cbiAgICAgICAgLy8gYSBtYXBwaW5nIGZvciBhIGRpZmZlcmVudCBsaW5lIHRoYW4gdGhlIG9uZSB3ZSBmb3VuZC4gU2luY2VcbiAgICAgICAgLy8gbWFwcGluZ3MgYXJlIHNvcnRlZCwgdGhpcyBpcyBndWFyYW50ZWVkIHRvIGZpbmQgYWxsIG1hcHBpbmdzIGZvclxuICAgICAgICAvLyB0aGUgbGluZSB3ZSBmb3VuZC5cbiAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IG9yaWdpbmFsTGluZSkge1xuICAgICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgLy8gSXRlcmF0ZSB1bnRpbCBlaXRoZXIgd2UgcnVuIG91dCBvZiBtYXBwaW5ncywgb3Igd2UgcnVuIGludG9cbiAgICAgICAgLy8gYSBtYXBwaW5nIGZvciBhIGRpZmZlcmVudCBsaW5lIHRoYW4gdGhlIG9uZSB3ZSB3ZXJlIHNlYXJjaGluZyBmb3IuXG4gICAgICAgIC8vIFNpbmNlIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3JcbiAgICAgICAgLy8gdGhlIGxpbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IuXG4gICAgICAgIHdoaWxlIChtYXBwaW5nICYmXG4gICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gbGluZSAmJlxuICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbiA9PSBvcmlnaW5hbENvbHVtbikge1xuICAgICAgICAgIG1hcHBpbmdzLnB1c2goe1xuICAgICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZENvbHVtbicsIG51bGwpLFxuICAgICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbKytpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFwcGluZ3M7XG4gIH07XG5cbmV4cG9ydHMuU291cmNlTWFwQ29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBBIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoIHdlIGNhblxuICogcXVlcnkgZm9yIGluZm9ybWF0aW9uIGFib3V0IHRoZSBvcmlnaW5hbCBmaWxlIHBvc2l0aW9ucyBieSBnaXZpbmcgaXQgYSBmaWxlXG4gKiBwb3NpdGlvbiBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqXG4gKiBUaGUgb25seSBwYXJhbWV0ZXIgaXMgdGhlIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3JcbiAqIGFscmVhZHkgcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYywgc291cmNlIG1hcHMgaGF2ZSB0aGVcbiAqIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICpcbiAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICogICAtIHNvdXJjZXM6IEFuIGFycmF5IG9mIFVSTHMgdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAqICAgLSBuYW1lczogQW4gYXJyYXkgb2YgaWRlbnRpZmllcnMgd2hpY2ggY2FuIGJlIHJlZmVycmVuY2VkIGJ5IGluZGl2aWR1YWwgbWFwcGluZ3MuXG4gKiAgIC0gc291cmNlUm9vdDogT3B0aW9uYWwuIFRoZSBVUkwgcm9vdCBmcm9tIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSByZWxhdGl2ZS5cbiAqICAgLSBzb3VyY2VzQ29udGVudDogT3B0aW9uYWwuIEFuIGFycmF5IG9mIGNvbnRlbnRzIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gKiAgIC0gbWFwcGluZ3M6IEEgc3RyaW5nIG9mIGJhc2U2NCBWTFFzIHdoaWNoIGNvbnRhaW4gdGhlIGFjdHVhbCBtYXBwaW5ncy5cbiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKlxuICogSGVyZSBpcyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXTpcbiAqXG4gKiAgICAge1xuICogICAgICAgdmVyc2lvbiA6IDMsXG4gKiAgICAgICBmaWxlOiBcIm91dC5qc1wiLFxuICogICAgICAgc291cmNlUm9vdCA6IFwiXCIsXG4gKiAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gKiAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAqICAgICAgIG1hcHBpbmdzOiBcIkFBLEFCOztBQkNERTtcIlxuICogICAgIH1cbiAqXG4gKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdD9wbGk9MSNcbiAqL1xuZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICB2YXIgc291cmNlcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXMnKTtcbiAgLy8gU2FzcyAzLjMgbGVhdmVzIG91dCB0aGUgJ25hbWVzJyBhcnJheSwgc28gd2UgZGV2aWF0ZSBmcm9tIHRoZSBzcGVjICh3aGljaFxuICAvLyByZXF1aXJlcyB0aGUgYXJyYXkpIHRvIHBsYXkgbmljZSBoZXJlLlxuICB2YXIgbmFtZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICduYW1lcycsIFtdKTtcbiAgdmFyIHNvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VSb290JywgbnVsbCk7XG4gIHZhciBzb3VyY2VzQ29udGVudCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXNDb250ZW50JywgbnVsbCk7XG4gIHZhciBtYXBwaW5ncyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ21hcHBpbmdzJyk7XG4gIHZhciBmaWxlID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnZmlsZScsIG51bGwpO1xuXG4gIC8vIE9uY2UgYWdhaW4sIFNhc3MgZGV2aWF0ZXMgZnJvbSB0aGUgc3BlYyBhbmQgc3VwcGxpZXMgdGhlIHZlcnNpb24gYXMgYVxuICAvLyBzdHJpbmcgcmF0aGVyIHRoYW4gYSBudW1iZXIsIHNvIHdlIHVzZSBsb29zZSBlcXVhbGl0eSBjaGVja2luZyBoZXJlLlxuICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gIH1cblxuICBzb3VyY2VzID0gc291cmNlc1xuICAgIC5tYXAoU3RyaW5nKVxuICAgIC8vIFNvbWUgc291cmNlIG1hcHMgcHJvZHVjZSByZWxhdGl2ZSBzb3VyY2UgcGF0aHMgbGlrZSBcIi4vZm9vLmpzXCIgaW5zdGVhZCBvZlxuICAgIC8vIFwiZm9vLmpzXCIuICBOb3JtYWxpemUgdGhlc2UgZmlyc3Qgc28gdGhhdCBmdXR1cmUgY29tcGFyaXNvbnMgd2lsbCBzdWNjZWVkLlxuICAgIC8vIFNlZSBidWd6aWwubGEvMTA5MDc2OC5cbiAgICAubWFwKHV0aWwubm9ybWFsaXplKVxuICAgIC8vIEFsd2F5cyBlbnN1cmUgdGhhdCBhYnNvbHV0ZSBzb3VyY2VzIGFyZSBpbnRlcm5hbGx5IHN0b3JlZCByZWxhdGl2ZSB0b1xuICAgIC8vIHRoZSBzb3VyY2Ugcm9vdCwgaWYgdGhlIHNvdXJjZSByb290IGlzIGFic29sdXRlLiBOb3QgZG9pbmcgdGhpcyB3b3VsZFxuICAgIC8vIGJlIHBhcnRpY3VsYXJseSBwcm9ibGVtYXRpYyB3aGVuIHRoZSBzb3VyY2Ugcm9vdCBpcyBhIHByZWZpeCBvZiB0aGVcbiAgICAvLyBzb3VyY2UgKHZhbGlkLCBidXQgd2h5Pz8pLiBTZWUgZ2l0aHViIGlzc3VlICMxOTkgYW5kIGJ1Z3ppbC5sYS8xMTg4OTgyLlxuICAgIC5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIHNvdXJjZVJvb3QgJiYgdXRpbC5pc0Fic29sdXRlKHNvdXJjZVJvb3QpICYmIHV0aWwuaXNBYnNvbHV0ZShzb3VyY2UpXG4gICAgICAgID8gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2UpXG4gICAgICAgIDogc291cmNlO1xuICAgIH0pO1xuXG4gIC8vIFBhc3MgYHRydWVgIGJlbG93IHRvIGFsbG93IGR1cGxpY2F0ZSBuYW1lcyBhbmQgc291cmNlcy4gV2hpbGUgc291cmNlIG1hcHNcbiAgLy8gYXJlIGludGVuZGVkIHRvIGJlIGNvbXByZXNzZWQgYW5kIGRlZHVwbGljYXRlZCwgdGhlIFR5cGVTY3JpcHQgY29tcGlsZXJcbiAgLy8gc29tZXRpbWVzIGdlbmVyYXRlcyBzb3VyY2UgbWFwcyB3aXRoIGR1cGxpY2F0ZXMgaW4gdGhlbS4gU2VlIEdpdGh1YiBpc3N1ZVxuICAvLyAjNzIgYW5kIGJ1Z3ppbC5sYS84ODk0OTIuXG4gIHRoaXMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KG5hbWVzLm1hcChTdHJpbmcpLCB0cnVlKTtcbiAgdGhpcy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShzb3VyY2VzLCB0cnVlKTtcblxuICB0aGlzLnNvdXJjZVJvb3QgPSBzb3VyY2VSb290O1xuICB0aGlzLnNvdXJjZXNDb250ZW50ID0gc291cmNlc0NvbnRlbnQ7XG4gIHRoaXMuX21hcHBpbmdzID0gbWFwcGluZ3M7XG4gIHRoaXMuZmlsZSA9IGZpbGU7XG59XG5cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29uc3VtZXIgPSBTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBDcmVhdGUgYSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGZyb20gYSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gKlxuICogQHBhcmFtIFNvdXJjZU1hcEdlbmVyYXRvciBhU291cmNlTWFwXG4gKiAgICAgICAgVGhlIHNvdXJjZSBtYXAgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuICogQHJldHVybnMgQmFzaWNTb3VyY2VNYXBDb25zdW1lclxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXApIHtcbiAgICB2YXIgc21jID0gT2JqZWN0LmNyZWF0ZShCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5cbiAgICB2YXIgbmFtZXMgPSBzbWMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX25hbWVzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgdmFyIHNvdXJjZXMgPSBzbWMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fc291cmNlcy50b0FycmF5KCksIHRydWUpO1xuICAgIHNtYy5zb3VyY2VSb290ID0gYVNvdXJjZU1hcC5fc291cmNlUm9vdDtcbiAgICBzbWMuc291cmNlc0NvbnRlbnQgPSBhU291cmNlTWFwLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KHNtYy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbWMuc291cmNlUm9vdCk7XG4gICAgc21jLmZpbGUgPSBhU291cmNlTWFwLl9maWxlO1xuXG4gICAgLy8gQmVjYXVzZSB3ZSBhcmUgbW9kaWZ5aW5nIHRoZSBlbnRyaWVzIChieSBjb252ZXJ0aW5nIHN0cmluZyBzb3VyY2VzIGFuZFxuICAgIC8vIG5hbWVzIHRvIGluZGljZXMgaW50byB0aGUgc291cmNlcyBhbmQgbmFtZXMgQXJyYXlTZXRzKSwgd2UgaGF2ZSB0byBtYWtlXG4gICAgLy8gYSBjb3B5IG9mIHRoZSBlbnRyeSBvciBlbHNlIGJhZCB0aGluZ3MgaGFwcGVuLiBTaGFyZWQgbXV0YWJsZSBzdGF0ZVxuICAgIC8vIHN0cmlrZXMgYWdhaW4hIFNlZSBnaXRodWIgaXNzdWUgIzE5MS5cblxuICAgIHZhciBnZW5lcmF0ZWRNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnRvQXJyYXkoKS5zbGljZSgpO1xuICAgIHZhciBkZXN0R2VuZXJhdGVkTWFwcGluZ3MgPSBzbWMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBkZXN0T3JpZ2luYWxNYXBwaW5ncyA9IHNtYy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNyY01hcHBpbmcgPSBnZW5lcmF0ZWRNYXBwaW5nc1tpXTtcbiAgICAgIHZhciBkZXN0TWFwcGluZyA9IG5ldyBNYXBwaW5nO1xuICAgICAgZGVzdE1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkTGluZTtcbiAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICBpZiAoc3JjTWFwcGluZy5zb3VyY2UpIHtcbiAgICAgICAgZGVzdE1hcHBpbmcuc291cmNlID0gc291cmNlcy5pbmRleE9mKHNyY01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxMaW5lID0gc3JjTWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gc3JjTWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICBpZiAoc3JjTWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgZGVzdE1hcHBpbmcubmFtZSA9IG5hbWVzLmluZGV4T2Yoc3JjTWFwcGluZy5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlc3RPcmlnaW5hbE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO1xuICAgICAgfVxuXG4gICAgICBkZXN0R2VuZXJhdGVkTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHNtYy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuXG4gICAgcmV0dXJuIHNtYztcbiAgfTtcblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlcy50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VSb290ICE9IG51bGwgPyB1dGlsLmpvaW4odGhpcy5zb3VyY2VSb290LCBzKSA6IHM7XG4gICAgfSwgdGhpcyk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGUgdGhlIEpJVCB3aXRoIGEgbmljZSBzaGFwZSAvIGhpZGRlbiBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gTWFwcGluZygpIHtcbiAgdGhpcy5nZW5lcmF0ZWRMaW5lID0gMDtcbiAgdGhpcy5nZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gIHRoaXMub3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgdGhpcy5vcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gIHRoaXMubmFtZSA9IG51bGw7XG59XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB2YXIgZ2VuZXJhdGVkTGluZSA9IDE7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgIHZhciBsZW5ndGggPSBhU3RyLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBjYWNoZWRTZWdtZW50cyA9IHt9O1xuICAgIHZhciB0ZW1wID0ge307XG4gICAgdmFyIG9yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgbWFwcGluZywgc3RyLCBzZWdtZW50LCBlbmQsIHZhbHVlO1xuXG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnOycpIHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZSsrO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICcsJykge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG1hcHBpbmcgPSBuZXcgTWFwcGluZygpO1xuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBnZW5lcmF0ZWRMaW5lO1xuXG4gICAgICAgIC8vIEJlY2F1c2UgZWFjaCBvZmZzZXQgaXMgZW5jb2RlZCByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgb25lLFxuICAgICAgICAvLyBtYW55IHNlZ21lbnRzIG9mdGVuIGhhdmUgdGhlIHNhbWUgZW5jb2RpbmcuIFdlIGNhbiBleHBsb2l0IHRoaXNcbiAgICAgICAgLy8gZmFjdCBieSBjYWNoaW5nIHRoZSBwYXJzZWQgdmFyaWFibGUgbGVuZ3RoIGZpZWxkcyBvZiBlYWNoIHNlZ21lbnQsXG4gICAgICAgIC8vIGFsbG93aW5nIHVzIHRvIGF2b2lkIGEgc2Vjb25kIHBhcnNlIGlmIHdlIGVuY291bnRlciB0aGUgc2FtZVxuICAgICAgICAvLyBzZWdtZW50IGFnYWluLlxuICAgICAgICBmb3IgKGVuZCA9IGluZGV4OyBlbmQgPCBsZW5ndGg7IGVuZCsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0ciwgZW5kKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0ciA9IGFTdHIuc2xpY2UoaW5kZXgsIGVuZCk7XG5cbiAgICAgICAgc2VnbWVudCA9IGNhY2hlZFNlZ21lbnRzW3N0cl07XG4gICAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgICAgaW5kZXggKz0gc3RyLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWdtZW50ID0gW107XG4gICAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kKSB7XG4gICAgICAgICAgICBiYXNlNjRWTFEuZGVjb2RlKGFTdHIsIGluZGV4LCB0ZW1wKTtcbiAgICAgICAgICAgIHZhbHVlID0gdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIGluZGV4ID0gdGVtcC5yZXN0O1xuICAgICAgICAgICAgc2VnbWVudC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UsIGJ1dCBubyBsaW5lIGFuZCBjb2x1bW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UgYW5kIGxpbmUsIGJ1dCBubyBjb2x1bW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYWNoZWRTZWdtZW50c1tzdHJdID0gc2VnbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlZCBjb2x1bW4uXG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gKyBzZWdtZW50WzBdO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAvLyBPcmlnaW5hbCBzb3VyY2UuXG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBwcmV2aW91c1NvdXJjZSArIHNlZ21lbnRbMV07XG4gICAgICAgICAgcHJldmlvdXNTb3VyY2UgKz0gc2VnbWVudFsxXTtcblxuICAgICAgICAgIC8vIE9yaWdpbmFsIGxpbmUuXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBwcmV2aW91c09yaWdpbmFsTGluZSArIHNlZ21lbnRbMl07XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgICAvLyBMaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWRcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSArPSAxO1xuXG4gICAgICAgICAgLy8gT3JpZ2luYWwgY29sdW1uLlxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBwcmV2aW91c09yaWdpbmFsQ29sdW1uICsgc2VnbWVudFszXTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIG5hbWUuXG4gICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBwcmV2aW91c05hbWUgKyBzZWdtZW50WzRdO1xuICAgICAgICAgICAgcHJldmlvdXNOYW1lICs9IHNlZ21lbnRbNF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBvcmlnaW5hbE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBxdWlja1NvcnQoZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IGdlbmVyYXRlZE1hcHBpbmdzO1xuXG4gICAgcXVpY2tTb3J0KG9yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gb3JpZ2luYWxNYXBwaW5ncztcbiAgfTtcblxuLyoqXG4gKiBGaW5kIHRoZSBtYXBwaW5nIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBoeXBvdGhldGljYWwgXCJuZWVkbGVcIiBtYXBwaW5nIHRoYXRcbiAqIHdlIGFyZSBzZWFyY2hpbmcgZm9yIGluIHRoZSBnaXZlbiBcImhheXN0YWNrXCIgb2YgbWFwcGluZ3MuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nKGFOZWVkbGUsIGFNYXBwaW5ncywgYUxpbmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ29sdW1uTmFtZSwgYUNvbXBhcmF0b3IsIGFCaWFzKSB7XG4gICAgLy8gVG8gcmV0dXJuIHRoZSBwb3NpdGlvbiB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgd2UgbXVzdCBmaXJzdCBmaW5kIHRoZVxuICAgIC8vIG1hcHBpbmcgZm9yIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgdGhlbiByZXR1cm4gdGhlIG9wcG9zaXRlIHBvc2l0aW9uIGl0XG4gICAgLy8gcG9pbnRzIHRvLiBCZWNhdXNlIHRoZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB3ZSBjYW4gdXNlIGJpbmFyeSBzZWFyY2ggdG9cbiAgICAvLyBmaW5kIHRoZSBiZXN0IG1hcHBpbmcuXG5cbiAgICBpZiAoYU5lZWRsZVthTGluZU5hbWVdIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0xpbmUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMSwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FMaW5lTmFtZV0pO1xuICAgIH1cbiAgICBpZiAoYU5lZWRsZVthQ29sdW1uTmFtZV0gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb2x1bW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FDb2x1bW5OYW1lXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJpbmFyeVNlYXJjaC5zZWFyY2goYU5lZWRsZSwgYU1hcHBpbmdzLCBhQ29tcGFyYXRvciwgYUJpYXMpO1xuICB9O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGxhc3QgY29sdW1uIGZvciBlYWNoIGdlbmVyYXRlZCBtYXBwaW5nLiBUaGUgbGFzdCBjb2x1bW4gaXNcbiAqIGluY2x1c2l2ZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29tcHV0ZUNvbHVtblNwYW5zID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY29tcHV0ZUNvbHVtblNwYW5zKCkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAvLyBNYXBwaW5ncyBkbyBub3QgY29udGFpbiBhIGZpZWxkIGZvciB0aGUgbGFzdCBnZW5lcmF0ZWQgY29sdW1udC4gV2VcbiAgICAgIC8vIGNhbiBjb21lIHVwIHdpdGggYW4gb3B0aW1pc3RpYyBlc3RpbWF0ZSwgaG93ZXZlciwgYnkgYXNzdW1pbmcgdGhhdFxuICAgICAgLy8gbWFwcGluZ3MgYXJlIGNvbnRpZ3VvdXMgKGkuZS4gZ2l2ZW4gdHdvIGNvbnNlY3V0aXZlIG1hcHBpbmdzLCB0aGVcbiAgICAgIC8vIGZpcnN0IG1hcHBpbmcgZW5kcyB3aGVyZSB0aGUgc2Vjb25kIG9uZSBzdGFydHMpLlxuICAgICAgaWYgKGluZGV4ICsgMSA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV4dE1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleCArIDFdO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5leHRNYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLSAxO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBsYXN0IG1hcHBpbmcgZm9yIGVhY2ggbGluZSBzcGFucyB0aGUgZW50aXJlIGxpbmUuXG4gICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBJbmZpbml0eTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS5cbiAqICAgLSBiaWFzOiBFaXRoZXIgJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdTb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCcuIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGVcbiAqICAgICBjbG9zZXN0IGVsZW1lbnQgdGhhdCBpcyBzbWFsbGVyIHRoYW4gb3IgZ3JlYXRlciB0aGFuIHRoZSBvbmUgd2UgYXJlXG4gKiAgICAgc2VhcmNoaW5nIGZvciwgcmVzcGVjdGl2ZWx5LCBpZiB0aGUgZXhhY3QgZWxlbWVudCBjYW5ub3QgYmUgZm91bmQuXG4gKiAgICAgRGVmYXVsdHMgdG8gJ1NvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKFxuICAgICAgbmVlZGxlLFxuICAgICAgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MsXG4gICAgICBcImdlbmVyYXRlZExpbmVcIixcbiAgICAgIFwiZ2VuZXJhdGVkQ29sdW1uXCIsXG4gICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkLFxuICAgICAgdXRpbC5nZXRBcmcoYUFyZ3MsICdiaWFzJywgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpXG4gICAgKTtcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdzb3VyY2UnLCBudWxsKTtcbiAgICAgICAgaWYgKHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuYXQoc291cmNlKTtcbiAgICAgICAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNvdXJjZSA9IHV0aWwuam9pbih0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ25hbWUnLCBudWxsKTtcbiAgICAgICAgaWYgKG5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICBuYW1lID0gdGhpcy5fbmFtZXMuYXQobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnb3JpZ2luYWxDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNvdXJjZTogbnVsbCxcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGwsXG4gICAgICBuYW1lOiBudWxsXG4gICAgfTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5oYXNDb250ZW50c09mQWxsU291cmNlcyA9XG4gIGZ1bmN0aW9uIEJhc2ljU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50Lmxlbmd0aCA+PSB0aGlzLl9zb3VyY2VzLnNpemUoKSAmJlxuICAgICAgIXRoaXMuc291cmNlc0NvbnRlbnQuc29tZShmdW5jdGlvbiAoc2MpIHsgcmV0dXJuIHNjID09IG51bGw7IH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICogYXZhaWxhYmxlLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLCBudWxsT25NaXNzaW5nKSB7XG4gICAgaWYgKCF0aGlzLnNvdXJjZXNDb250ZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIGFTb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgYVNvdXJjZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NvdXJjZXMuaGFzKGFTb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFt0aGlzLl9zb3VyY2VzLmluZGV4T2YoYVNvdXJjZSldO1xuICAgIH1cblxuICAgIHZhciB1cmw7XG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsXG4gICAgICAgICYmICh1cmwgPSB1dGlsLnVybFBhcnNlKHRoaXMuc291cmNlUm9vdCkpKSB7XG4gICAgICAvLyBYWFg6IGZpbGU6Ly8gVVJJcyBhbmQgYWJzb2x1dGUgcGF0aHMgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yIGZvclxuICAgICAgLy8gbWFueSB1c2Vycy4gV2UgY2FuIGhlbHAgdGhlbSBvdXQgd2hlbiB0aGV5IGV4cGVjdCBmaWxlOi8vIFVSSXMgdG9cbiAgICAgIC8vIGJlaGF2ZSBsaWtlIGl0IHdvdWxkIGlmIHRoZXkgd2VyZSBydW5uaW5nIGEgbG9jYWwgSFRUUCBzZXJ2ZXIuIFNlZVxuICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODg1NTk3LlxuICAgICAgdmFyIGZpbGVVcmlBYnNQYXRoID0gYVNvdXJjZS5yZXBsYWNlKC9eZmlsZTpcXC9cXC8vLCBcIlwiKTtcbiAgICAgIGlmICh1cmwuc2NoZW1lID09IFwiZmlsZVwiXG4gICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoZmlsZVVyaUFic1BhdGgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihmaWxlVXJpQWJzUGF0aCldXG4gICAgICB9XG5cbiAgICAgIGlmICgoIXVybC5wYXRoIHx8IHVybC5wYXRoID09IFwiL1wiKVxuICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKFwiL1wiICsgYVNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKFwiL1wiICsgYVNvdXJjZSldO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCByZWN1cnNpdmVseSBmcm9tXG4gICAgLy8gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yLiBJbiB0aGF0IGNhc2UsIHdlXG4gICAgLy8gZG9uJ3Qgd2FudCB0byB0aHJvdyBpZiB3ZSBjYW4ndCBmaW5kIHRoZSBzb3VyY2UgLSB3ZSBqdXN0IHdhbnQgdG9cbiAgICAvLyByZXR1cm4gbnVsbCwgc28gd2UgcHJvdmlkZSBhIGZsYWcgdG8gZXhpdCBncmFjZWZ1bGx5LlxuICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKTtcbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCBzb3VyY2UpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3NvdXJjZXMuaGFzKHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG5cbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBvcmlnaW5hbExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICBuZWVkbGUsXG4gICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICApO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gbmVlZGxlLnNvdXJjZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgIH07XG4gIH07XG5cbmV4cG9ydHMuQmFzaWNTb3VyY2VNYXBDb25zdW1lciA9IEJhc2ljU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQW4gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaFxuICogd2UgY2FuIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbi4gSXQgZGlmZmVycyBmcm9tIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5cbiAqIHRoYXQgaXQgdGFrZXMgXCJpbmRleGVkXCIgc291cmNlIG1hcHMgKGkuZS4gb25lcyB3aXRoIGEgXCJzZWN0aW9uc1wiIGZpZWxkKSBhc1xuICogaW5wdXQuXG4gKlxuICogVGhlIG9ubHkgcGFyYW1ldGVyIGlzIGEgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvciBhbHJlYWR5XG4gKiBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjIGZvciBpbmRleGVkIHNvdXJjZSBtYXBzLCB0aGV5XG4gKiBoYXZlIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAqXG4gKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKiAgIC0gc2VjdGlvbnM6IEEgbGlzdCBvZiBzZWN0aW9uIGRlZmluaXRpb25zLlxuICpcbiAqIEVhY2ggdmFsdWUgdW5kZXIgdGhlIFwic2VjdGlvbnNcIiBmaWVsZCBoYXMgdHdvIGZpZWxkczpcbiAqICAgLSBvZmZzZXQ6IFRoZSBvZmZzZXQgaW50byB0aGUgb3JpZ2luYWwgc3BlY2lmaWVkIGF0IHdoaWNoIHRoaXMgc2VjdGlvblxuICogICAgICAgYmVnaW5zIHRvIGFwcGx5LCBkZWZpbmVkIGFzIGFuIG9iamVjdCB3aXRoIGEgXCJsaW5lXCIgYW5kIFwiY29sdW1uXCJcbiAqICAgICAgIGZpZWxkLlxuICogICAtIG1hcDogQSBzb3VyY2UgbWFwIGRlZmluaXRpb24uIFRoaXMgc291cmNlIG1hcCBjb3VsZCBhbHNvIGJlIGluZGV4ZWQsXG4gKiAgICAgICBidXQgZG9lc24ndCBoYXZlIHRvIGJlLlxuICpcbiAqIEluc3RlYWQgb2YgdGhlIFwibWFwXCIgZmllbGQsIGl0J3MgYWxzbyBwb3NzaWJsZSB0byBoYXZlIGEgXCJ1cmxcIiBmaWVsZFxuICogc3BlY2lmeWluZyBhIFVSTCB0byByZXRyaWV2ZSBhIHNvdXJjZSBtYXAgZnJvbSwgYnV0IHRoYXQncyBjdXJyZW50bHlcbiAqIHVuc3VwcG9ydGVkLlxuICpcbiAqIEhlcmUncyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXSwgYnV0XG4gKiBtb2RpZmllZCB0byBvbWl0IGEgc2VjdGlvbiB3aGljaCB1c2VzIHRoZSBcInVybFwiIGZpZWxkLlxuICpcbiAqICB7XG4gKiAgICB2ZXJzaW9uIDogMyxcbiAqICAgIGZpbGU6IFwiYXBwLmpzXCIsXG4gKiAgICBzZWN0aW9uczogW3tcbiAqICAgICAgb2Zmc2V0OiB7bGluZToxMDAsIGNvbHVtbjoxMH0sXG4gKiAgICAgIG1hcDoge1xuICogICAgICAgIHZlcnNpb24gOiAzLFxuICogICAgICAgIGZpbGU6IFwic2VjdGlvbi5qc1wiLFxuICogICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAqICAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAqICAgICAgICBtYXBwaW5nczogXCJBQUFBLEU7O0FCQ0RFO1wiXG4gKiAgICAgIH1cbiAqICAgIH1dLFxuICogIH1cbiAqXG4gKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdCNoZWFkaW5nPWguNTM1ZXMzeGVwcmd0XG4gKi9cbmZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gSlNPTi5wYXJzZShhU291cmNlTWFwLnJlcGxhY2UoL15cXClcXF1cXH0nLywgJycpKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICB2YXIgc2VjdGlvbnMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzZWN0aW9ucycpO1xuXG4gIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICB2YXIgbGFzdE9mZnNldCA9IHtcbiAgICBsaW5lOiAtMSxcbiAgICBjb2x1bW46IDBcbiAgfTtcbiAgdGhpcy5fc2VjdGlvbnMgPSBzZWN0aW9ucy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICBpZiAocy51cmwpIHtcbiAgICAgIC8vIFRoZSB1cmwgZmllbGQgd2lsbCByZXF1aXJlIHN1cHBvcnQgZm9yIGFzeW5jaHJvbmljaXR5LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzE2XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBvcnQgZm9yIHVybCBmaWVsZCBpbiBzZWN0aW9ucyBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSB1dGlsLmdldEFyZyhzLCAnb2Zmc2V0Jyk7XG4gICAgdmFyIG9mZnNldExpbmUgPSB1dGlsLmdldEFyZyhvZmZzZXQsICdsaW5lJyk7XG4gICAgdmFyIG9mZnNldENvbHVtbiA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgJ2NvbHVtbicpO1xuXG4gICAgaWYgKG9mZnNldExpbmUgPCBsYXN0T2Zmc2V0LmxpbmUgfHxcbiAgICAgICAgKG9mZnNldExpbmUgPT09IGxhc3RPZmZzZXQubGluZSAmJiBvZmZzZXRDb2x1bW4gPCBsYXN0T2Zmc2V0LmNvbHVtbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2VjdGlvbiBvZmZzZXRzIG11c3QgYmUgb3JkZXJlZCBhbmQgbm9uLW92ZXJsYXBwaW5nLicpO1xuICAgIH1cbiAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdlbmVyYXRlZE9mZnNldDoge1xuICAgICAgICAvLyBUaGUgb2Zmc2V0IGZpZWxkcyBhcmUgMC1iYXNlZCwgYnV0IHdlIHVzZSAxLWJhc2VkIGluZGljZXMgd2hlblxuICAgICAgICAvLyBlbmNvZGluZy9kZWNvZGluZyBmcm9tIFZMUS5cbiAgICAgICAgZ2VuZXJhdGVkTGluZTogb2Zmc2V0TGluZSArIDEsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogb2Zmc2V0Q29sdW1uICsgMVxuICAgICAgfSxcbiAgICAgIGNvbnN1bWVyOiBuZXcgU291cmNlTWFwQ29uc3VtZXIodXRpbC5nZXRBcmcocywgJ21hcCcpKVxuICAgIH1cbiAgfSk7XG59XG5cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ3NvdXJjZXMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHNvdXJjZXMucHVzaCh0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZXM7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLlxuICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICAvLyBGaW5kIHRoZSBzZWN0aW9uIGNvbnRhaW5pbmcgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbiB3ZSdyZSB0cnlpbmcgdG8gbWFwXG4gICAgLy8gdG8gYW4gb3JpZ2luYWwgcG9zaXRpb24uXG4gICAgdmFyIHNlY3Rpb25JbmRleCA9IGJpbmFyeVNlYXJjaC5zZWFyY2gobmVlZGxlLCB0aGlzLl9zZWN0aW9ucyxcbiAgICAgIGZ1bmN0aW9uKG5lZWRsZSwgc2VjdGlvbikge1xuICAgICAgICB2YXIgY21wID0gbmVlZGxlLmdlbmVyYXRlZExpbmUgLSBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lO1xuICAgICAgICBpZiAoY21wKSB7XG4gICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgIH0pO1xuICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbc2VjdGlvbkluZGV4XTtcblxuICAgIGlmICghc2VjdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIG5hbWU6IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY3Rpb24uY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICBsaW5lOiBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtXG4gICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICBjb2x1bW46IG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmVcbiAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgOiAwKSxcbiAgICAgIGJpYXM6IGFBcmdzLmJpYXNcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWN0aW9ucy5ldmVyeShmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHMuY29uc3VtZXIuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKTtcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAqIGF2YWlsYWJsZS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgIHZhciBjb250ZW50ID0gc2VjdGlvbi5jb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIHRydWUpO1xuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZ2VuZXJhdGVkUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuXG4gICAgICAvLyBPbmx5IGNvbnNpZGVyIHRoaXMgc2VjdGlvbiBpZiB0aGUgcmVxdWVzdGVkIHNvdXJjZSBpcyBpbiB0aGUgbGlzdCBvZlxuICAgICAgLy8gc291cmNlcyBvZiB0aGUgY29uc3VtZXIuXG4gICAgICBpZiAoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VzLmluZGV4T2YodXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSkgPT09IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGdlbmVyYXRlZFBvc2l0aW9uID0gc2VjdGlvbi5jb25zdW1lci5nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncyk7XG4gICAgICBpZiAoZ2VuZXJhdGVkUG9zaXRpb24pIHtcbiAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWRQb3NpdGlvbi5jb2x1bW4gK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmVcbiAgICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgICA6IDApXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGxcbiAgICB9O1xuICB9O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuICAgICAgdmFyIHNlY3Rpb25NYXBwaW5ncyA9IHNlY3Rpb24uY29uc3VtZXIuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWN0aW9uTWFwcGluZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSBzZWN0aW9uTWFwcGluZ3Nbal07XG5cbiAgICAgICAgdmFyIHNvdXJjZSA9IHNlY3Rpb24uY29uc3VtZXIuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBpZiAoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VSb290ICE9PSBudWxsKSB7XG4gICAgICAgICAgc291cmNlID0gdXRpbC5qb2luKHNlY3Rpb24uY29uc3VtZXIuc291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zb3VyY2VzLmFkZChzb3VyY2UpO1xuICAgICAgICBzb3VyY2UgPSB0aGlzLl9zb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcblxuICAgICAgICB2YXIgbmFtZSA9IHNlY3Rpb24uY29uc3VtZXIuX25hbWVzLmF0KG1hcHBpbmcubmFtZSk7XG4gICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgbmFtZSA9IHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSk7XG5cbiAgICAgICAgLy8gVGhlIG1hcHBpbmdzIGNvbWluZyBmcm9tIHRoZSBjb25zdW1lciBmb3IgdGhlIHNlY3Rpb24gaGF2ZVxuICAgICAgICAvLyBnZW5lcmF0ZWQgcG9zaXRpb25zIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgc2VjdGlvbiwgc28gd2VcbiAgICAgICAgLy8gbmVlZCB0byBvZmZzZXQgdGhlbSB0byBiZSByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbmNhdGVuYXRlZFxuICAgICAgICAvLyBnZW5lcmF0ZWQgZmlsZS5cbiAgICAgICAgdmFyIGFkanVzdGVkTWFwcGluZyA9IHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUgK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBtYXBwaW5nLmdlbmVyYXRlZExpbmVcbiAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgOiAwKSxcbiAgICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICBpZiAodHlwZW9mIGFkanVzdGVkTWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCk7XG4gICAgcXVpY2tTb3J0KHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgfTtcblxuZXhwb3J0cy5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIgPSBJbmRleGVkU291cmNlTWFwQ29uc3VtZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjayktc291cmNlcy9+L3NvdXJjZS1tYXAvbGliL3NvdXJjZS1tYXAtY29uc3VtZXIuanNcbi8vIG1vZHVsZSBpZCA9IDM1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbmV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogUmVjdXJzaXZlIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2guXG4gKlxuICogQHBhcmFtIGFMb3cgSW5kaWNlcyBoZXJlIGFuZCBsb3dlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICogQHBhcmFtIGFIaWdoIEluZGljZXMgaGVyZSBhbmQgaGlnaGVyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCBiZWluZyBzZWFyY2hlZCBmb3IuXG4gKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBub24tZW1wdHkgYXJyYXkgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgRnVuY3Rpb24gd2hpY2ggdGFrZXMgdHdvIGVsZW1lbnRzIGFuZCByZXR1cm5zIC0xLCAwLCBvciAxLlxuICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICovXG5mdW5jdGlvbiByZWN1cnNpdmVTZWFyY2goYUxvdywgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gdGVybWluYXRlcyB3aGVuIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XG4gIC8vXG4gIC8vICAgMS4gV2UgZmluZCB0aGUgZXhhY3QgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gIC8vXG4gIC8vICAgMi4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBidXQgd2UgY2FuIHJldHVybiB0aGUgaW5kZXggb2ZcbiAgLy8gICAgICB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQuXG4gIC8vXG4gIC8vICAgMy4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBhbmQgdGhlcmUgaXMgbm8gbmV4dC1jbG9zZXN0XG4gIC8vICAgICAgZWxlbWVudCB0aGFuIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IsIHNvIHdlIHJldHVybiAtMS5cbiAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGFIaWdoIC0gYUxvdykgLyAyKSArIGFMb3c7XG4gIHZhciBjbXAgPSBhQ29tcGFyZShhTmVlZGxlLCBhSGF5c3RhY2tbbWlkXSwgdHJ1ZSk7XG4gIGlmIChjbXAgPT09IDApIHtcbiAgICAvLyBGb3VuZCB0aGUgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgcmV0dXJuIG1pZDtcbiAgfVxuICBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgLy8gT3VyIG5lZWRsZSBpcyBncmVhdGVyIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgaWYgKGFIaWdoIC0gbWlkID4gMSkge1xuICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKG1pZCwgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgZXhhY3QgbmVlZGxlIGVsZW1lbnQgd2FzIG5vdCBmb3VuZCBpbiB0aGlzIGhheXN0YWNrLiBEZXRlcm1pbmUgaWZcbiAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICByZXR1cm4gYUhpZ2ggPCBhSGF5c3RhY2subGVuZ3RoID8gYUhpZ2ggOiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gT3VyIG5lZWRsZSBpcyBsZXNzIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgaWYgKG1pZCAtIGFMb3cgPiAxKSB7XG4gICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgbG93ZXIgaGFsZi5cbiAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2goYUxvdywgbWlkLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcyk7XG4gICAgfVxuXG4gICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDMpIG9yICgyKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICBpZiAoYUJpYXMgPT0gZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCkge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFMb3cgPCAwID8gLTEgOiBhTG93O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaCB3aGljaCB3aWxsIGFsd2F5cyB0cnkgYW5kIHJldHVyblxuICogdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IGVsZW1lbnQgaWYgdGhlcmUgaXMgbm8gZXhhY3QgaGl0LiBUaGlzIGlzIGJlY2F1c2VcbiAqIG1hcHBpbmdzIGJldHdlZW4gb3JpZ2luYWwgYW5kIGdlbmVyYXRlZCBsaW5lL2NvbCBwYWlycyBhcmUgc2luZ2xlIHBvaW50cyxcbiAqIGFuZCB0aGVyZSBpcyBhbiBpbXBsaWNpdCByZWdpb24gYmV0d2VlbiBlYWNoIG9mIHRoZW0sIHNvIGEgbWlzcyBqdXN0IG1lYW5zXG4gKiB0aGF0IHlvdSBhcmVuJ3Qgb24gdGhlIHZlcnkgc3RhcnQgb2YgYSByZWdpb24uXG4gKlxuICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgeW91IGFyZSBsb29raW5nIGZvci5cbiAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIGFycmF5IHRoYXQgaXMgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgbmVlZGxlIGFuZCBhbiBlbGVtZW50IGluIHRoZVxuICogICAgIGFycmF5IGFuZCByZXR1cm5zIC0xLCAwLCBvciAxIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBuZWVkbGUgaXMgbGVzc1xuICogICAgIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlIGVsZW1lbnQsIHJlc3BlY3RpdmVseS5cbiAqIEBwYXJhbSBhQmlhcyBFaXRoZXIgJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqL1xuZXhwb3J0cy5zZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2goYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgaWYgKGFIYXlzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICB2YXIgaW5kZXggPSByZWN1cnNpdmVTZWFyY2goLTEsIGFIYXlzdGFjay5sZW5ndGgsIGFOZWVkbGUsIGFIYXlzdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb21wYXJlLCBhQmlhcyB8fCBleHBvcnRzLkdSRUFURVNUX0xPV0VSX0JPVU5EKTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8vIFdlIGhhdmUgZm91bmQgZWl0aGVyIHRoZSBleGFjdCBlbGVtZW50LCBvciB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQgdGhhblxuICAvLyB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLiBIb3dldmVyLCB0aGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBzdWNoXG4gIC8vIGVsZW1lbnQuIE1ha2Ugc3VyZSB3ZSBhbHdheXMgcmV0dXJuIHRoZSBzbWFsbGVzdCBvZiB0aGVzZS5cbiAgd2hpbGUgKGluZGV4IC0gMSA+PSAwKSB7XG4gICAgaWYgKGFDb21wYXJlKGFIYXlzdGFja1tpbmRleF0sIGFIYXlzdGFja1tpbmRleCAtIDFdLCB0cnVlKSAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC0taW5kZXg7XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spLXNvdXJjZXMvfi9zb3VyY2UtbWFwL2xpYi9iaW5hcnktc2VhcmNoLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG4vLyBJdCB0dXJucyBvdXQgdGhhdCBzb21lIChtb3N0PykgSmF2YVNjcmlwdCBlbmdpbmVzIGRvbid0IHNlbGYtaG9zdFxuLy8gYEFycmF5LnByb3RvdHlwZS5zb3J0YC4gVGhpcyBtYWtlcyBzZW5zZSBiZWNhdXNlIEMrKyB3aWxsIGxpa2VseSByZW1haW5cbi8vIGZhc3RlciB0aGFuIEpTIHdoZW4gZG9pbmcgcmF3IENQVS1pbnRlbnNpdmUgc29ydGluZy4gSG93ZXZlciwgd2hlbiB1c2luZyBhXG4vLyBjdXN0b20gY29tcGFyYXRvciBmdW5jdGlvbiwgY2FsbGluZyBiYWNrIGFuZCBmb3J0aCBiZXR3ZWVuIHRoZSBWTSdzIEMrKyBhbmRcbi8vIEpJVCdkIEpTIGlzIHJhdGhlciBzbG93ICphbmQqIGxvc2VzIEpJVCB0eXBlIGluZm9ybWF0aW9uLCByZXN1bHRpbmcgaW5cbi8vIHdvcnNlIGdlbmVyYXRlZCBjb2RlIGZvciB0aGUgY29tcGFyYXRvciBmdW5jdGlvbiB0aGFuIHdvdWxkIGJlIG9wdGltYWwuIEluXG4vLyBmYWN0LCB3aGVuIHNvcnRpbmcgd2l0aCBhIGNvbXBhcmF0b3IsIHRoZXNlIGNvc3RzIG91dHdlaWdoIHRoZSBiZW5lZml0cyBvZlxuLy8gc29ydGluZyBpbiBDKysuIEJ5IHVzaW5nIG91ciBvd24gSlMtaW1wbGVtZW50ZWQgUXVpY2sgU29ydCAoYmVsb3cpLCB3ZSBnZXRcbi8vIGEgfjM1MDBtcyBtZWFuIHNwZWVkLXVwIGluIGBiZW5jaC9iZW5jaC5odG1sYC5cblxuLyoqXG4gKiBTd2FwIHRoZSBlbGVtZW50cyBpbmRleGVkIGJ5IGB4YCBhbmQgYHlgIGluIHRoZSBhcnJheSBgYXJ5YC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBUaGUgYXJyYXkuXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogICAgICAgIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgaXRlbS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBzZWNvbmQgaXRlbS5cbiAqL1xuZnVuY3Rpb24gc3dhcChhcnksIHgsIHkpIHtcbiAgdmFyIHRlbXAgPSBhcnlbeF07XG4gIGFyeVt4XSA9IGFyeVt5XTtcbiAgYXJ5W3ldID0gdGVtcDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgd2l0aGluIHRoZSByYW5nZSBgbG93IC4uIGhpZ2hgIGluY2x1c2l2ZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbG93XG4gKiAgICAgICAgVGhlIGxvd2VyIGJvdW5kIG9uIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBoaWdoXG4gKiAgICAgICAgVGhlIHVwcGVyIGJvdW5kIG9uIHRoZSByYW5nZS5cbiAqL1xuZnVuY3Rpb24gcmFuZG9tSW50SW5SYW5nZShsb3csIGhpZ2gpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQobG93ICsgKE1hdGgucmFuZG9tKCkgKiAoaGlnaCAtIGxvdykpKTtcbn1cblxuLyoqXG4gKiBUaGUgUXVpY2sgU29ydCBhbGdvcml0aG0uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgQW4gYXJyYXkgdG8gc29ydC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3JcbiAqICAgICAgICBGdW5jdGlvbiB0byB1c2UgdG8gY29tcGFyZSB0d28gaXRlbXMuXG4gKiBAcGFyYW0ge051bWJlcn0gcFxuICogICAgICAgIFN0YXJ0IGluZGV4IG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IHJcbiAqICAgICAgICBFbmQgaW5kZXggb2YgdGhlIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcCwgcikge1xuICAvLyBJZiBvdXIgbG93ZXIgYm91bmQgaXMgbGVzcyB0aGFuIG91ciB1cHBlciBib3VuZCwgd2UgKDEpIHBhcnRpdGlvbiB0aGVcbiAgLy8gYXJyYXkgaW50byB0d28gcGllY2VzIGFuZCAoMikgcmVjdXJzZSBvbiBlYWNoIGhhbGYuIElmIGl0IGlzIG5vdCwgdGhpcyBpc1xuICAvLyB0aGUgZW1wdHkgYXJyYXkgYW5kIG91ciBiYXNlIGNhc2UuXG5cbiAgaWYgKHAgPCByKSB7XG4gICAgLy8gKDEpIFBhcnRpdGlvbmluZy5cbiAgICAvL1xuICAgIC8vIFRoZSBwYXJ0aXRpb25pbmcgY2hvb3NlcyBhIHBpdm90IGJldHdlZW4gYHBgIGFuZCBgcmAgYW5kIG1vdmVzIGFsbFxuICAgIC8vIGVsZW1lbnRzIHRoYXQgYXJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGl2b3QgdG8gdGhlIGJlZm9yZSBpdCwgYW5kXG4gICAgLy8gYWxsIHRoZSBlbGVtZW50cyB0aGF0IGFyZSBncmVhdGVyIHRoYW4gaXQgYWZ0ZXIgaXQuIFRoZSBlZmZlY3QgaXMgdGhhdFxuICAgIC8vIG9uY2UgcGFydGl0aW9uIGlzIGRvbmUsIHRoZSBwaXZvdCBpcyBpbiB0aGUgZXhhY3QgcGxhY2UgaXQgd2lsbCBiZSB3aGVuXG4gICAgLy8gdGhlIGFycmF5IGlzIHB1dCBpbiBzb3J0ZWQgb3JkZXIsIGFuZCBpdCB3aWxsIG5vdCBuZWVkIHRvIGJlIG1vdmVkXG4gICAgLy8gYWdhaW4uIFRoaXMgcnVucyBpbiBPKG4pIHRpbWUuXG5cbiAgICAvLyBBbHdheXMgY2hvb3NlIGEgcmFuZG9tIHBpdm90IHNvIHRoYXQgYW4gaW5wdXQgYXJyYXkgd2hpY2ggaXMgcmV2ZXJzZVxuICAgIC8vIHNvcnRlZCBkb2VzIG5vdCBjYXVzZSBPKG5eMikgcnVubmluZyB0aW1lLlxuICAgIHZhciBwaXZvdEluZGV4ID0gcmFuZG9tSW50SW5SYW5nZShwLCByKTtcbiAgICB2YXIgaSA9IHAgLSAxO1xuXG4gICAgc3dhcChhcnksIHBpdm90SW5kZXgsIHIpO1xuICAgIHZhciBwaXZvdCA9IGFyeVtyXTtcblxuICAgIC8vIEltbWVkaWF0ZWx5IGFmdGVyIGBqYCBpcyBpbmNyZW1lbnRlZCBpbiB0aGlzIGxvb3AsIHRoZSBmb2xsb3dpbmcgaG9sZFxuICAgIC8vIHRydWU6XG4gICAgLy9cbiAgICAvLyAgICogRXZlcnkgZWxlbWVudCBpbiBgYXJ5W3AgLi4gaV1gIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGl2b3QuXG4gICAgLy9cbiAgICAvLyAgICogRXZlcnkgZWxlbWVudCBpbiBgYXJ5W2krMSAuLiBqLTFdYCBpcyBncmVhdGVyIHRoYW4gdGhlIHBpdm90LlxuICAgIGZvciAodmFyIGogPSBwOyBqIDwgcjsgaisrKSB7XG4gICAgICBpZiAoY29tcGFyYXRvcihhcnlbal0sIHBpdm90KSA8PSAwKSB7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgc3dhcChhcnksIGksIGopO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3YXAoYXJ5LCBpICsgMSwgaik7XG4gICAgdmFyIHEgPSBpICsgMTtcblxuICAgIC8vICgyKSBSZWN1cnNlIG9uIGVhY2ggaGFsZi5cblxuICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcCwgcSAtIDEpO1xuICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcSArIDEsIHIpO1xuICB9XG59XG5cbi8qKlxuICogU29ydCB0aGUgZ2l2ZW4gYXJyYXkgaW4tcGxhY2Ugd2l0aCB0aGUgZ2l2ZW4gY29tcGFyYXRvciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICogICAgICAgIEZ1bmN0aW9uIHRvIHVzZSB0byBjb21wYXJlIHR3byBpdGVtcy5cbiAqL1xuZXhwb3J0cy5xdWlja1NvcnQgPSBmdW5jdGlvbiAoYXJ5LCBjb21wYXJhdG9yKSB7XG4gIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgMCwgYXJ5Lmxlbmd0aCAtIDEpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS1zb3VyY2VzL34vc291cmNlLW1hcC9saWIvcXVpY2stc29ydC5qc1xuLy8gbW9kdWxlIGlkID0gMzUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIFNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoJy4vc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG4vLyBNYXRjaGVzIGEgV2luZG93cy1zdHlsZSBgXFxyXFxuYCBuZXdsaW5lIG9yIGEgYFxcbmAgbmV3bGluZSB1c2VkIGJ5IGFsbCBvdGhlclxuLy8gb3BlcmF0aW5nIHN5c3RlbXMgdGhlc2UgZGF5cyAoY2FwdHVyaW5nIHRoZSByZXN1bHQpLlxudmFyIFJFR0VYX05FV0xJTkUgPSAvKFxccj9cXG4pLztcblxuLy8gTmV3bGluZSBjaGFyYWN0ZXIgY29kZSBmb3IgY2hhckNvZGVBdCgpIGNvbXBhcmlzb25zXG52YXIgTkVXTElORV9DT0RFID0gMTA7XG5cbi8vIFByaXZhdGUgc3ltYm9sIGZvciBpZGVudGlmeWluZyBgU291cmNlTm9kZWBzIHdoZW4gbXVsdGlwbGUgdmVyc2lvbnMgb2Zcbi8vIHRoZSBzb3VyY2UtbWFwIGxpYnJhcnkgYXJlIGxvYWRlZC4gVGhpcyBNVVNUIE5PVCBDSEFOR0UgYWNyb3NzXG4vLyB2ZXJzaW9ucyFcbnZhciBpc1NvdXJjZU5vZGUgPSBcIiQkJGlzU291cmNlTm9kZSQkJFwiO1xuXG4vKipcbiAqIFNvdXJjZU5vZGVzIHByb3ZpZGUgYSB3YXkgdG8gYWJzdHJhY3Qgb3ZlciBpbnRlcnBvbGF0aW5nL2NvbmNhdGVuYXRpbmdcbiAqIHNuaXBwZXRzIG9mIGdlbmVyYXRlZCBKYXZhU2NyaXB0IHNvdXJjZSBjb2RlIHdoaWxlIG1haW50YWluaW5nIHRoZSBsaW5lIGFuZFxuICogY29sdW1uIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3JpZ2luYWwgc291cmNlIGNvZGUuXG4gKlxuICogQHBhcmFtIGFMaW5lIFRoZSBvcmlnaW5hbCBsaW5lIG51bWJlci5cbiAqIEBwYXJhbSBhQ29sdW1uIFRoZSBvcmlnaW5hbCBjb2x1bW4gbnVtYmVyLlxuICogQHBhcmFtIGFTb3VyY2UgVGhlIG9yaWdpbmFsIHNvdXJjZSdzIGZpbGVuYW1lLlxuICogQHBhcmFtIGFDaHVua3MgT3B0aW9uYWwuIEFuIGFycmF5IG9mIHN0cmluZ3Mgd2hpY2ggYXJlIHNuaXBwZXRzIG9mXG4gKiAgICAgICAgZ2VuZXJhdGVkIEpTLCBvciBvdGhlciBTb3VyY2VOb2Rlcy5cbiAqIEBwYXJhbSBhTmFtZSBUaGUgb3JpZ2luYWwgaWRlbnRpZmllci5cbiAqL1xuZnVuY3Rpb24gU291cmNlTm9kZShhTGluZSwgYUNvbHVtbiwgYVNvdXJjZSwgYUNodW5rcywgYU5hbWUpIHtcbiAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICB0aGlzLnNvdXJjZUNvbnRlbnRzID0ge307XG4gIHRoaXMubGluZSA9IGFMaW5lID09IG51bGwgPyBudWxsIDogYUxpbmU7XG4gIHRoaXMuY29sdW1uID0gYUNvbHVtbiA9PSBudWxsID8gbnVsbCA6IGFDb2x1bW47XG4gIHRoaXMuc291cmNlID0gYVNvdXJjZSA9PSBudWxsID8gbnVsbCA6IGFTb3VyY2U7XG4gIHRoaXMubmFtZSA9IGFOYW1lID09IG51bGwgPyBudWxsIDogYU5hbWU7XG4gIHRoaXNbaXNTb3VyY2VOb2RlXSA9IHRydWU7XG4gIGlmIChhQ2h1bmtzICE9IG51bGwpIHRoaXMuYWRkKGFDaHVua3MpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBTb3VyY2VOb2RlIGZyb20gZ2VuZXJhdGVkIGNvZGUgYW5kIGEgU291cmNlTWFwQ29uc3VtZXIuXG4gKlxuICogQHBhcmFtIGFHZW5lcmF0ZWRDb2RlIFRoZSBnZW5lcmF0ZWQgY29kZVxuICogQHBhcmFtIGFTb3VyY2VNYXBDb25zdW1lciBUaGUgU291cmNlTWFwIGZvciB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAqIEBwYXJhbSBhUmVsYXRpdmVQYXRoIE9wdGlvbmFsLiBUaGUgcGF0aCB0aGF0IHJlbGF0aXZlIHNvdXJjZXMgaW4gdGhlXG4gKiAgICAgICAgU291cmNlTWFwQ29uc3VtZXIgc2hvdWxkIGJlIHJlbGF0aXZlIHRvLlxuICovXG5Tb3VyY2VOb2RlLmZyb21TdHJpbmdXaXRoU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV9mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcChhR2VuZXJhdGVkQ29kZSwgYVNvdXJjZU1hcENvbnN1bWVyLCBhUmVsYXRpdmVQYXRoKSB7XG4gICAgLy8gVGhlIFNvdXJjZU5vZGUgd2Ugd2FudCB0byBmaWxsIHdpdGggdGhlIGdlbmVyYXRlZCBjb2RlXG4gICAgLy8gYW5kIHRoZSBTb3VyY2VNYXBcbiAgICB2YXIgbm9kZSA9IG5ldyBTb3VyY2VOb2RlKCk7XG5cbiAgICAvLyBBbGwgZXZlbiBpbmRpY2VzIG9mIHRoaXMgYXJyYXkgYXJlIG9uZSBsaW5lIG9mIHRoZSBnZW5lcmF0ZWQgY29kZSxcbiAgICAvLyB3aGlsZSBhbGwgb2RkIGluZGljZXMgYXJlIHRoZSBuZXdsaW5lcyBiZXR3ZWVuIHR3byBhZGphY2VudCBsaW5lc1xuICAgIC8vIChzaW5jZSBgUkVHRVhfTkVXTElORWAgY2FwdHVyZXMgaXRzIG1hdGNoKS5cbiAgICAvLyBQcm9jZXNzZWQgZnJhZ21lbnRzIGFyZSByZW1vdmVkIGZyb20gdGhpcyBhcnJheSwgYnkgY2FsbGluZyBgc2hpZnROZXh0TGluZWAuXG4gICAgdmFyIHJlbWFpbmluZ0xpbmVzID0gYUdlbmVyYXRlZENvZGUuc3BsaXQoUkVHRVhfTkVXTElORSk7XG4gICAgdmFyIHNoaWZ0TmV4dExpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsaW5lQ29udGVudHMgPSByZW1haW5pbmdMaW5lcy5zaGlmdCgpO1xuICAgICAgLy8gVGhlIGxhc3QgbGluZSBvZiBhIGZpbGUgbWlnaHQgbm90IGhhdmUgYSBuZXdsaW5lLlxuICAgICAgdmFyIG5ld0xpbmUgPSByZW1haW5pbmdMaW5lcy5zaGlmdCgpIHx8IFwiXCI7XG4gICAgICByZXR1cm4gbGluZUNvbnRlbnRzICsgbmV3TGluZTtcbiAgICB9O1xuXG4gICAgLy8gV2UgbmVlZCB0byByZW1lbWJlciB0aGUgcG9zaXRpb24gb2YgXCJyZW1haW5pbmdMaW5lc1wiXG4gICAgdmFyIGxhc3RHZW5lcmF0ZWRMaW5lID0gMSwgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG5cbiAgICAvLyBUaGUgZ2VuZXJhdGUgU291cmNlTm9kZXMgd2UgbmVlZCBhIGNvZGUgcmFuZ2UuXG4gICAgLy8gVG8gZXh0cmFjdCBpdCBjdXJyZW50IGFuZCBsYXN0IG1hcHBpbmcgaXMgdXNlZC5cbiAgICAvLyBIZXJlIHdlIHN0b3JlIHRoZSBsYXN0IG1hcHBpbmcuXG4gICAgdmFyIGxhc3RNYXBwaW5nID0gbnVsbDtcblxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgaWYgKGxhc3RNYXBwaW5nICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFdlIGFkZCB0aGUgY29kZSBmcm9tIFwibGFzdE1hcHBpbmdcIiB0byBcIm1hcHBpbmdcIjpcbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlcmUgaXMgYSBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICBpZiAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAvLyBBc3NvY2lhdGUgZmlyc3QgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICAgIC8vIFRoZSByZW1haW5pbmcgY29kZSBpcyBhZGRlZCB3aXRob3V0IG1hcHBpbmdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgY29kZSBiZXR3ZWVuIFwibGFzdEdlbmVyYXRlZENvbHVtblwiIGFuZFxuICAgICAgICAgIC8vIFwibWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cIiB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzWzBdO1xuICAgICAgICAgIHZhciBjb2RlID0gbmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICByZW1haW5pbmdMaW5lc1swXSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgY29kZSk7XG4gICAgICAgICAgLy8gTm8gbW9yZSByZW1haW5pbmcgY29kZSwgY29udGludWVcbiAgICAgICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBXZSBhZGQgdGhlIGdlbmVyYXRlZCBjb2RlIHVudGlsIHRoZSBmaXJzdCBtYXBwaW5nXG4gICAgICAvLyB0byB0aGUgU291cmNlTm9kZSB3aXRob3V0IGFueSBtYXBwaW5nLlxuICAgICAgLy8gRWFjaCBsaW5lIGlzIGFkZGVkIGFzIHNlcGFyYXRlIHN0cmluZy5cbiAgICAgIHdoaWxlIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICBub2RlLmFkZChzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgfVxuICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRDb2x1bW4gPCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikge1xuICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1swXTtcbiAgICAgICAgbm9kZS5hZGQobmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSk7XG4gICAgICAgIHJlbWFpbmluZ0xpbmVzWzBdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgfVxuICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgIH0sIHRoaXMpO1xuICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBtYXBwaW5ncy5cbiAgICBpZiAocmVtYWluaW5nTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKGxhc3RNYXBwaW5nKSB7XG4gICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgcmVtYWluaW5nIGNvZGUgaW4gdGhlIGN1cnJlbnQgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICB9XG4gICAgICAvLyBhbmQgYWRkIHRoZSByZW1haW5pbmcgbGluZXMgd2l0aG91dCBhbnkgbWFwcGluZ1xuICAgICAgbm9kZS5hZGQocmVtYWluaW5nTGluZXMuam9pbihcIlwiKSk7XG4gICAgfVxuXG4gICAgLy8gQ29weSBzb3VyY2VzQ29udGVudCBpbnRvIFNvdXJjZU5vZGVcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYVJlbGF0aXZlUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbm9kZTtcblxuICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmdXaXRoQ29kZShtYXBwaW5nLCBjb2RlKSB7XG4gICAgICBpZiAobWFwcGluZyA9PT0gbnVsbCB8fCBtYXBwaW5nLnNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGUuYWRkKGNvZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFSZWxhdGl2ZVBhdGhcbiAgICAgICAgICA/IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICA6IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBub2RlLmFkZChuZXcgU291cmNlTm9kZShtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8qKlxuICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoaXMgc291cmNlIG5vZGUuXG4gKlxuICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gU291cmNlTm9kZV9hZGQoYUNodW5rKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICBhQ2h1bmsuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIHRoaXMuYWRkKGNodW5rKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxuICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKGFDaHVuaykge1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGFDaHVuayk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBzb3VyY2Ugbm9kZS5cbiAqXG4gKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gU291cmNlTm9kZV9wcmVwZW5kKGFDaHVuaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgZm9yICh2YXIgaSA9IGFDaHVuay5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRoaXMucHJlcGVuZChhQ2h1bmtbaV0pO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgdGhpcy5jaGlsZHJlbi51bnNoaWZ0KGFDaHVuayk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXCIgKyBhQ2h1bmtcbiAgICApO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgSlMgc25pcHBldHMgaW4gdGhpcyBub2RlIGFuZCBpdHMgY2hpbGRyZW4uIFRoZVxuICogd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgb25jZSBmb3IgZWFjaCBzbmlwcGV0IG9mIEpTIGFuZCBpcyBwYXNzZWQgdGhhdFxuICogc25pcHBldCBhbmQgdGhlIGl0cyBvcmlnaW5hbCBhc3NvY2lhdGVkIHNvdXJjZSdzIGxpbmUvY29sdW1uIGxvY2F0aW9uLlxuICpcbiAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2FsayhhRm4pIHtcbiAgdmFyIGNodW5rO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNodW5rID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICBpZiAoY2h1bmtbaXNTb3VyY2VOb2RlXSkge1xuICAgICAgY2h1bmsud2FsayhhRm4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChjaHVuayAhPT0gJycpIHtcbiAgICAgICAgYUZuKGNodW5rLCB7IHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBMaWtlIGBTdHJpbmcucHJvdG90eXBlLmpvaW5gIGV4Y2VwdCBmb3IgU291cmNlTm9kZXMuIEluc2VydHMgYGFTdHJgIGJldHdlZW5cbiAqIGVhY2ggb2YgYHRoaXMuY2hpbGRyZW5gLlxuICpcbiAqIEBwYXJhbSBhU2VwIFRoZSBzZXBhcmF0b3IuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2pvaW4oYVNlcCkge1xuICB2YXIgbmV3Q2hpbGRyZW47XG4gIHZhciBpO1xuICB2YXIgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbmV3Q2hpbGRyZW4gPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuLTE7IGkrKykge1xuICAgICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICAgIG5ld0NoaWxkcmVuLnB1c2goYVNlcCk7XG4gICAgfVxuICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSBvbiB0aGUgdmVyeSByaWdodC1tb3N0IHNvdXJjZSBzbmlwcGV0LiBVc2VmdWxcbiAqIGZvciB0cmltbWluZyB3aGl0ZXNwYWNlIGZyb20gdGhlIGVuZCBvZiBhIHNvdXJjZSBub2RlLCBldGMuXG4gKlxuICogQHBhcmFtIGFQYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHJlcGxhY2UuXG4gKiBAcGFyYW0gYVJlcGxhY2VtZW50IFRoZSB0aGluZyB0byByZXBsYWNlIHRoZSBwYXR0ZXJuIHdpdGguXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnJlcGxhY2VSaWdodCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpIHtcbiAgdmFyIGxhc3RDaGlsZCA9IHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgaWYgKGxhc3RDaGlsZFtpc1NvdXJjZU5vZGVdKSB7XG4gICAgbGFzdENoaWxkLnJlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgfVxuICBlbHNlIGlmICh0eXBlb2YgbGFzdENoaWxkID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXSA9IGxhc3RDaGlsZC5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuY2hpbGRyZW4ucHVzaCgnJy5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS4gVGhpcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3JcbiAqIGluIHRoZSBzb3VyY2VzQ29udGVudCBmaWVsZC5cbiAqXG4gKiBAcGFyYW0gYVNvdXJjZUZpbGUgVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZVxuICogQHBhcmFtIGFTb3VyY2VDb250ZW50IFRoZSBjb250ZW50IG9mIHRoZSBzb3VyY2UgZmlsZVxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgIHRoaXMuc291cmNlQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhhU291cmNlRmlsZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gIH07XG5cbi8qKlxuICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIFNvdXJjZU5vZGVzLiBUaGUgd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIGVhY2hcbiAqIHNvdXJjZSBmaWxlIGNvbnRlbnQgYW5kIGlzIHBhc3NlZCB0aGUgZmlsZW5hbWUgYW5kIHNvdXJjZSBjb250ZW50LlxuICpcbiAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUud2Fsa1NvdXJjZUNvbnRlbnRzID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV93YWxrU291cmNlQ29udGVudHMoYUZuKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldW2lzU291cmNlTm9kZV0pIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpXS53YWxrU291cmNlQ29udGVudHMoYUZuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc291cmNlcyA9IE9iamVjdC5rZXlzKHRoaXMuc291cmNlQ29udGVudHMpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhRm4odXRpbC5mcm9tU2V0U3RyaW5nKHNvdXJjZXNbaV0pLCB0aGlzLnNvdXJjZUNvbnRlbnRzW3NvdXJjZXNbaV1dKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZS4gV2Fsa3Mgb3ZlciB0aGUgdHJlZVxuICogYW5kIGNvbmNhdGVuYXRlcyBhbGwgdGhlIHZhcmlvdXMgc25pcHBldHMgdG9nZXRoZXIgdG8gb25lIHN0cmluZy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nKCkge1xuICB2YXIgc3RyID0gXCJcIjtcbiAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHN0ciArPSBjaHVuaztcbiAgfSk7XG4gIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlIGFsb25nIHdpdGggYSBzb3VyY2VcbiAqIG1hcC5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmdXaXRoU291cmNlTWFwID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZ1dpdGhTb3VyY2VNYXAoYUFyZ3MpIHtcbiAgdmFyIGdlbmVyYXRlZCA9IHtcbiAgICBjb2RlOiBcIlwiLFxuICAgIGxpbmU6IDEsXG4gICAgY29sdW1uOiAwXG4gIH07XG4gIHZhciBtYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKTtcbiAgdmFyIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgdmFyIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgdmFyIGxhc3RPcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxOYW1lID0gbnVsbDtcbiAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaywgb3JpZ2luYWwpIHtcbiAgICBnZW5lcmF0ZWQuY29kZSArPSBjaHVuaztcbiAgICBpZiAob3JpZ2luYWwuc291cmNlICE9PSBudWxsXG4gICAgICAgICYmIG9yaWdpbmFsLmxpbmUgIT09IG51bGxcbiAgICAgICAgJiYgb3JpZ2luYWwuY29sdW1uICE9PSBudWxsKSB7XG4gICAgICBpZihsYXN0T3JpZ2luYWxTb3VyY2UgIT09IG9yaWdpbmFsLnNvdXJjZVxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTGluZSAhPT0gb3JpZ2luYWwubGluZVxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsQ29sdW1uICE9PSBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbE5hbWUgIT09IG9yaWdpbmFsLm5hbWUpIHtcbiAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICBsYXN0T3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgIGxhc3RPcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgIGxhc3RPcmlnaW5hbE5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGlkeCA9IDAsIGxlbmd0aCA9IGNodW5rLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgaWYgKGNodW5rLmNoYXJDb2RlQXQoaWR4KSA9PT0gTkVXTElORV9DT0RFKSB7XG4gICAgICAgIGdlbmVyYXRlZC5saW5lKys7XG4gICAgICAgIGdlbmVyYXRlZC5jb2x1bW4gPSAwO1xuICAgICAgICAvLyBNYXBwaW5ncyBlbmQgYXQgZW9sXG4gICAgICAgIGlmIChpZHggKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW5lcmF0ZWQuY29sdW1uKys7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdGhpcy53YWxrU291cmNlQ29udGVudHMoZnVuY3Rpb24gKHNvdXJjZUZpbGUsIHNvdXJjZUNvbnRlbnQpIHtcbiAgICBtYXAuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHsgY29kZTogZ2VuZXJhdGVkLmNvZGUsIG1hcDogbWFwIH07XG59O1xuXG5leHBvcnRzLlNvdXJjZU5vZGUgPSBTb3VyY2VOb2RlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spLXNvdXJjZXMvfi9zb3VyY2UtbWFwL2xpYi9zb3VyY2Utbm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gMzUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBTb3VyY2UgPSByZXF1aXJlKFwiLi9Tb3VyY2VcIik7XHJcbnZhciBTb3VyY2VOb2RlID0gcmVxdWlyZShcInNvdXJjZS1tYXBcIikuU291cmNlTm9kZTtcclxudmFyIFNvdXJjZUxpc3RNYXAgPSByZXF1aXJlKFwic291cmNlLWxpc3QtbWFwXCIpLlNvdXJjZUxpc3RNYXA7XHJcblxyXG5mdW5jdGlvbiBSYXdTb3VyY2UodmFsdWUpIHtcclxuXHRTb3VyY2UuY2FsbCh0aGlzKTtcclxuXHR0aGlzLl92YWx1ZSA9IHZhbHVlO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gUmF3U291cmNlO1xyXG5cclxuUmF3U291cmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlLnByb3RvdHlwZSk7XHJcblJhd1NvdXJjZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSYXdTb3VyY2U7XHJcblxyXG5SYXdTb3VyY2UucHJvdG90eXBlLnNvdXJjZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLl92YWx1ZTtcclxufTtcclxuXHJcblJhd1NvdXJjZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuUmF3U291cmNlLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgU291cmNlTm9kZShudWxsLCBudWxsLCBudWxsLCB0aGlzLl92YWx1ZSk7XHJcbn07XHJcblxyXG5SYXdTb3VyY2UucHJvdG90eXBlLmxpc3RNYXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBTb3VyY2VMaXN0TWFwKHRoaXMuX3ZhbHVlKTtcclxufTtcclxuXHJcblJhd1NvdXJjZS5wcm90b3R5cGUudXBkYXRlSGFzaCA9IGZ1bmN0aW9uKGhhc2gpIHtcclxuXHRoYXNoLnVwZGF0ZSh0aGlzLl92YWx1ZSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS1zb3VyY2VzL2xpYi9SYXdTb3VyY2UuanNcbi8vIG1vZHVsZSBpZCA9IDM1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgU291cmNlTm9kZSA9IHJlcXVpcmUoXCJzb3VyY2UtbWFwXCIpLlNvdXJjZU5vZGU7XHJcbnZhciBTb3VyY2VNYXBDb25zdW1lciA9IHJlcXVpcmUoXCJzb3VyY2UtbWFwXCIpLlNvdXJjZU1hcENvbnN1bWVyO1xyXG52YXIgU291cmNlTGlzdE1hcCA9IHJlcXVpcmUoXCJzb3VyY2UtbGlzdC1tYXBcIikuU291cmNlTGlzdE1hcDtcclxudmFyIFNvdXJjZSA9IHJlcXVpcmUoXCIuL1NvdXJjZVwiKTtcclxuXHJcbmZ1bmN0aW9uIGlzU3BsaXR0ZXIoYykge1xyXG5cdHN3aXRjaChjKSB7XHJcblx0XHRjYXNlIDEwOiAvLyBcXG5cclxuXHRcdGNhc2UgMTM6IC8vIFxcclxyXG5cdFx0Y2FzZSA1OTogLy8gO1xyXG5cdFx0Y2FzZSAxMjM6IC8vIHtcclxuXHRcdGNhc2UgMTI1OiAvLyB9XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHRyZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9zcGxpdENvZGUoY29kZSkge1xyXG5cdHZhciByZXN1bHQgPSBbXTtcclxuXHR2YXIgaSA9IDA7XHJcblx0dmFyIGogPSAwO1xyXG5cdGZvcig7IGkgPCBjb2RlLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZihpc1NwbGl0dGVyKGNvZGUuY2hhckNvZGVBdChpKSkpIHtcclxuXHRcdFx0d2hpbGUoaXNTcGxpdHRlcihjb2RlLmNoYXJDb2RlQXQoKytpKSkpO1xyXG5cdFx0XHRyZXN1bHQucHVzaChjb2RlLnN1YnN0cmluZyhqLCBpKSk7XHJcblx0XHRcdGogPSBpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZihqIDwgY29kZS5sZW5ndGgpXHJcblx0XHRyZXN1bHQucHVzaChjb2RlLnN1YnN0cihqKSk7XHJcblx0cmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZnVuY3Rpb24gT3JpZ2luYWxTb3VyY2UodmFsdWUsIG5hbWUpIHtcclxuXHRTb3VyY2UuY2FsbCh0aGlzKTtcclxuXHR0aGlzLl92YWx1ZSA9IHZhbHVlO1xyXG5cdHRoaXMuX25hbWUgPSBuYW1lO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9yaWdpbmFsU291cmNlO1xyXG5cclxuT3JpZ2luYWxTb3VyY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2UucHJvdG90eXBlKTtcclxuT3JpZ2luYWxTb3VyY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT3JpZ2luYWxTb3VyY2U7XHJcblxyXG5PcmlnaW5hbFNvdXJjZS5wcm90b3R5cGUuc291cmNlID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuX3ZhbHVlO1xyXG59O1xyXG5cclxucmVxdWlyZShcIi4vU291cmNlQW5kTWFwTWl4aW5cIikoT3JpZ2luYWxTb3VyY2UucHJvdG90eXBlKTtcclxuXHJcbk9yaWdpbmFsU291cmNlLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdHZhciBzb3VyY2VNYXAgPSB0aGlzLl9zb3VyY2VNYXA7XHJcblx0dmFyIHZhbHVlID0gdGhpcy5fdmFsdWU7XHJcblx0dmFyIG5hbWUgPSB0aGlzLl9uYW1lO1xyXG5cdHZhciBsaW5lcyA9IHZhbHVlLnNwbGl0KFwiXFxuXCIpO1xyXG5cdHZhciBub2RlID0gbmV3IFNvdXJjZU5vZGUobnVsbCwgbnVsbCwgbnVsbCxcclxuXHRcdGxpbmVzLm1hcChmdW5jdGlvbihsaW5lLCBpZHgpIHtcclxuXHRcdFx0dmFyIHBvcyA9IDA7XHJcblx0XHRcdGlmKG9wdGlvbnMuY29sdW1ucyA9PT0gZmFsc2UpIHtcclxuXHRcdFx0XHR2YXIgY29udGVudCA9IGxpbmUgKyAoaWR4ICE9IGxpbmVzLmxlbmd0aCAtIDEgPyBcIlxcblwiIDogXCJcIik7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBTb3VyY2VOb2RlKGlkeCArIDEsIDAsIG5hbWUsIGNvbnRlbnQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBuZXcgU291cmNlTm9kZShudWxsLCBudWxsLCBudWxsLFxyXG5cdFx0XHRcdF9zcGxpdENvZGUobGluZSArIChpZHggIT0gbGluZXMubGVuZ3RoIC0gMSA/IFwiXFxuXCIgOiBcIlwiKSkubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHRcdFx0XHRcdGlmKC9eXFxzKiQvLnRlc3QoaXRlbSkpIHJldHVybiBpdGVtO1xyXG5cdFx0XHRcdFx0dmFyIHJlcyA9IG5ldyBTb3VyY2VOb2RlKGlkeCArIDEsIHBvcywgbmFtZSwgaXRlbSk7XHJcblx0XHRcdFx0XHRwb3MgKz0gaXRlbS5sZW5ndGg7XHJcblx0XHRcdFx0XHRyZXR1cm4gcmVzO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdCk7XHJcblx0XHR9KVxyXG5cdCk7XHJcblx0bm9kZS5zZXRTb3VyY2VDb250ZW50KG5hbWUsIHZhbHVlKTtcclxuXHRyZXR1cm4gbm9kZTtcclxufTtcclxuXHJcbk9yaWdpbmFsU291cmNlLnByb3RvdHlwZS5saXN0TWFwID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgU291cmNlTGlzdE1hcCh0aGlzLl92YWx1ZSwgdGhpcy5fbmFtZSwgdGhpcy5fdmFsdWUpXHJcbn07XHJcblxyXG5PcmlnaW5hbFNvdXJjZS5wcm90b3R5cGUudXBkYXRlSGFzaCA9IGZ1bmN0aW9uKGhhc2gpIHtcclxuXHRoYXNoLnVwZGF0ZSh0aGlzLl92YWx1ZSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS1zb3VyY2VzL2xpYi9PcmlnaW5hbFNvdXJjZS5qc1xuLy8gbW9kdWxlIGlkID0gMzU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWl4aW5Tb3VyY2VBbmRNYXAocHJvdG8pIHtcclxuXHRwcm90by5tYXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHRcdGlmKG9wdGlvbnMuY29sdW1ucyA9PT0gZmFsc2UpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMubGlzdE1hcChvcHRpb25zKS50b1N0cmluZ1dpdGhTb3VyY2VNYXAoe1xyXG5cdFx0XHRcdGZpbGU6IFwieFwiXHJcblx0XHRcdH0pLm1hcDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5ub2RlKG9wdGlvbnMpLnRvU3RyaW5nV2l0aFNvdXJjZU1hcCh7XHJcblx0XHRcdGZpbGU6IFwieFwiXHJcblx0XHR9KS5tYXAudG9KU09OKCk7XHJcblx0fTtcclxuXHJcblx0cHJvdG8uc291cmNlQW5kTWFwID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0XHRpZihvcHRpb25zLmNvbHVtbnMgPT09IGZhbHNlKSB7XHJcblx0XHRcdC8vY29uc29sZS5sb2codGhpcy5saXN0TWFwKG9wdGlvbnMpLmRlYnVnSW5mbygpKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMubGlzdE1hcChvcHRpb25zKS50b1N0cmluZ1dpdGhTb3VyY2VNYXAoe1xyXG5cdFx0XHRcdGZpbGU6IFwieFwiXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciByZXMgPSB0aGlzLm5vZGUob3B0aW9ucykudG9TdHJpbmdXaXRoU291cmNlTWFwKHtcclxuXHRcdFx0ZmlsZTogXCJ4XCJcclxuXHRcdH0pO1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0c291cmNlOiByZXMuY29kZSxcclxuXHRcdFx0bWFwOiByZXMubWFwLnRvSlNPTigpXHJcblx0XHR9O1xyXG5cdH07XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spLXNvdXJjZXMvbGliL1NvdXJjZUFuZE1hcE1peGluLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIFNvdXJjZU5vZGUgPSByZXF1aXJlKFwic291cmNlLW1hcFwiKS5Tb3VyY2VOb2RlO1xyXG52YXIgU291cmNlTWFwQ29uc3VtZXIgPSByZXF1aXJlKFwic291cmNlLW1hcFwiKS5Tb3VyY2VNYXBDb25zdW1lcjtcclxudmFyIFNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUoXCJzb3VyY2UtbWFwXCIpLlNvdXJjZU1hcEdlbmVyYXRvcjtcclxudmFyIFNvdXJjZUxpc3RNYXAgPSByZXF1aXJlKFwic291cmNlLWxpc3QtbWFwXCIpLlNvdXJjZUxpc3RNYXA7XHJcbnZhciBmcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCA9IHJlcXVpcmUoXCJzb3VyY2UtbGlzdC1tYXBcIikuZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXA7XHJcbnZhciBTb3VyY2UgPSByZXF1aXJlKFwiLi9Tb3VyY2VcIik7XHJcblxyXG5mdW5jdGlvbiBTb3VyY2VNYXBTb3VyY2UodmFsdWUsIG5hbWUsIHNvdXJjZU1hcCwgb3JpZ2luYWxTb3VyY2UsIGlubmVyU291cmNlTWFwKSB7XHJcblx0U291cmNlLmNhbGwodGhpcyk7XHJcblx0dGhpcy5fdmFsdWUgPSB2YWx1ZTtcclxuXHR0aGlzLl9uYW1lID0gbmFtZTtcclxuXHR0aGlzLl9zb3VyY2VNYXAgPSBzb3VyY2VNYXA7XHJcblx0dGhpcy5fb3JpZ2luYWxTb3VyY2UgPSBvcmlnaW5hbFNvdXJjZTtcclxuXHR0aGlzLl9pbm5lclNvdXJjZU1hcCA9IGlubmVyU291cmNlTWFwO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gU291cmNlTWFwU291cmNlO1xyXG5cclxuU291cmNlTWFwU291cmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlLnByb3RvdHlwZSk7XHJcblNvdXJjZU1hcFNvdXJjZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTb3VyY2VNYXBTb3VyY2U7XHJcblxyXG5Tb3VyY2VNYXBTb3VyY2UucHJvdG90eXBlLnNvdXJjZSA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLl92YWx1ZTtcclxufTtcclxuXHJcbnJlcXVpcmUoXCIuL1NvdXJjZUFuZE1hcE1peGluXCIpKFNvdXJjZU1hcFNvdXJjZS5wcm90b3R5cGUpO1xyXG5cclxuU291cmNlTWFwU291cmNlLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdHZhciBpbm5lclNvdXJjZU1hcCA9IHRoaXMuX2lubmVyU291cmNlTWFwO1xyXG5cdHZhciBzb3VyY2VNYXAgPSB0aGlzLl9zb3VyY2VNYXA7XHJcblx0aWYoaW5uZXJTb3VyY2VNYXApIHtcclxuXHRcdHNvdXJjZU1hcCA9IFNvdXJjZU1hcEdlbmVyYXRvci5mcm9tU291cmNlTWFwKG5ldyBTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXApKTtcclxuXHRcdGlmKHRoaXMuX29yaWdpbmFsU291cmNlKVxyXG5cdFx0XHRzb3VyY2VNYXAuc2V0U291cmNlQ29udGVudCh0aGlzLl9uYW1lLCB0aGlzLl9vcmlnaW5hbFNvdXJjZSk7XHJcblx0XHRpbm5lclNvdXJjZU1hcCA9IG5ldyBTb3VyY2VNYXBDb25zdW1lcihpbm5lclNvdXJjZU1hcCk7XHJcblx0XHRzb3VyY2VNYXAuYXBwbHlTb3VyY2VNYXAoaW5uZXJTb3VyY2VNYXAsIHRoaXMuX25hbWUpO1xyXG5cdFx0c291cmNlTWFwID0gc291cmNlTWFwLnRvSlNPTigpO1xyXG5cdH1cclxuXHRyZXR1cm4gU291cmNlTm9kZS5mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCh0aGlzLl92YWx1ZSwgbmV3IFNvdXJjZU1hcENvbnN1bWVyKHNvdXJjZU1hcCkpO1xyXG59O1xyXG5cclxuU291cmNlTWFwU291cmNlLnByb3RvdHlwZS5saXN0TWFwID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdGlmKG9wdGlvbnMubW9kdWxlID09PSBmYWxzZSlcclxuXHRcdHJldHVybiBuZXcgU291cmNlTGlzdE1hcCh0aGlzLl92YWx1ZSwgdGhpcy5fbmFtZSwgdGhpcy5fdmFsdWUpO1xyXG5cdHJldHVybiBmcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCh0aGlzLl92YWx1ZSwgdHlwZW9mIHRoaXMuX3NvdXJjZU1hcCA9PT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2UodGhpcy5fc291cmNlTWFwKSA6IHRoaXMuX3NvdXJjZU1hcCk7XHJcbn07XHJcblxyXG5Tb3VyY2VNYXBTb3VyY2UucHJvdG90eXBlLnVwZGF0ZUhhc2ggPSBmdW5jdGlvbihoYXNoKSB7XHJcblx0aGFzaC51cGRhdGUodGhpcy5fdmFsdWUpO1xyXG5cdGlmKHRoaXMuX29yaWdpbmFsU291cmNlKVxyXG5cdFx0aGFzaC51cGRhdGUodGhpcy5fb3JpZ2luYWxTb3VyY2UpO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjayktc291cmNlcy9saWIvU291cmNlTWFwU291cmNlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIFNvdXJjZU5vZGUgPSByZXF1aXJlKFwic291cmNlLW1hcFwiKS5Tb3VyY2VOb2RlO1xyXG52YXIgU291cmNlTWFwQ29uc3VtZXIgPSByZXF1aXJlKFwic291cmNlLW1hcFwiKS5Tb3VyY2VNYXBDb25zdW1lcjtcclxudmFyIFNvdXJjZUxpc3RNYXAgPSByZXF1aXJlKFwic291cmNlLWxpc3QtbWFwXCIpLlNvdXJjZUxpc3RNYXA7XHJcbnZhciBTb3VyY2UgPSByZXF1aXJlKFwiLi9Tb3VyY2VcIik7XHJcblxyXG5mdW5jdGlvbiBMaW5lVG9MaW5lTWFwcGVkU291cmNlKHZhbHVlLCBuYW1lLCBvcmlnaW5hbFNvdXJjZSkge1xyXG5cdFNvdXJjZS5jYWxsKHRoaXMpO1xyXG5cdHRoaXMuX3ZhbHVlID0gdmFsdWU7XHJcblx0dGhpcy5fbmFtZSA9IG5hbWU7XHJcblx0dGhpcy5fb3JpZ2luYWxTb3VyY2UgPSBvcmlnaW5hbFNvdXJjZTtcclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBMaW5lVG9MaW5lTWFwcGVkU291cmNlO1xyXG5cclxuTGluZVRvTGluZU1hcHBlZFNvdXJjZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZS5wcm90b3R5cGUpO1xyXG5MaW5lVG9MaW5lTWFwcGVkU291cmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmVUb0xpbmVNYXBwZWRTb3VyY2U7XHJcblxyXG5MaW5lVG9MaW5lTWFwcGVkU291cmNlLnByb3RvdHlwZS5zb3VyY2UgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5fdmFsdWU7XHJcbn07XHJcblxyXG5yZXF1aXJlKFwiLi9Tb3VyY2VBbmRNYXBNaXhpblwiKShMaW5lVG9MaW5lTWFwcGVkU291cmNlLnByb3RvdHlwZSk7XHJcblxyXG5MaW5lVG9MaW5lTWFwcGVkU291cmNlLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdHZhciB2YWx1ZSA9IHRoaXMuX3ZhbHVlO1xyXG5cdHZhciBuYW1lID0gdGhpcy5fbmFtZTtcclxuXHR2YXIgbGluZXMgPSB2YWx1ZS5zcGxpdChcIlxcblwiKTtcclxuXHR2YXIgbm9kZSA9IG5ldyBTb3VyY2VOb2RlKG51bGwsIG51bGwsIG51bGwsXHJcblx0XHRsaW5lcy5tYXAoZnVuY3Rpb24obGluZSwgaWR4KSB7XHJcblx0XHRcdHJldHVybiBuZXcgU291cmNlTm9kZShpZHggKyAxLCAwLCBuYW1lLCAobGluZSArIChpZHggIT0gbGluZXMubGVuZ3RoIC0gMSA/IFwiXFxuXCIgOiBcIlwiKSkpO1xyXG5cdFx0fSlcclxuXHQpO1xyXG5cdG5vZGUuc2V0U291cmNlQ29udGVudChuYW1lLCB0aGlzLl9vcmlnaW5hbFNvdXJjZSk7XHJcblx0cmV0dXJuIG5vZGU7XHJcbn07XHJcblxyXG5MaW5lVG9MaW5lTWFwcGVkU291cmNlLnByb3RvdHlwZS5saXN0TWFwID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgU291cmNlTGlzdE1hcCh0aGlzLl92YWx1ZSwgdGhpcy5fbmFtZSwgdGhpcy5fb3JpZ2luYWxTb3VyY2UpXHJcbn07XHJcblxyXG5MaW5lVG9MaW5lTWFwcGVkU291cmNlLnByb3RvdHlwZS51cGRhdGVIYXNoID0gZnVuY3Rpb24oaGFzaCkge1xyXG5cdGhhc2gudXBkYXRlKHRoaXMuX3ZhbHVlKTtcclxuXHRoYXNoLnVwZGF0ZSh0aGlzLl9vcmlnaW5hbFNvdXJjZSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS1zb3VyY2VzL2xpYi9MaW5lVG9MaW5lTWFwcGVkU291cmNlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuZnVuY3Rpb24gQ2FjaGVkU291cmNlKHNvdXJjZSkge1xyXG5cdHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcclxuXHR0aGlzLl9jYWNoZWRTb3VyY2UgPSB1bmRlZmluZWQ7XHJcblx0dGhpcy5fY2FjaGVkU2l6ZSA9IHVuZGVmaW5lZDtcclxuXHR0aGlzLl9jYWNoZWRNYXBzID0ge307XHJcblxyXG5cdGlmKHNvdXJjZS5ub2RlKSB0aGlzLm5vZGUgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291cmNlLm5vZGUob3B0aW9ucyk7XHJcblx0fTtcclxuXHJcblx0aWYoc291cmNlLmxpc3RNYXApIHRoaXMubGlzdE1hcCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zb3VyY2UubGlzdE1hcChvcHRpb25zKTtcclxuXHR9O1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gQ2FjaGVkU291cmNlO1xyXG5cclxuQ2FjaGVkU291cmNlLnByb3RvdHlwZS5zb3VyY2UgPSBmdW5jdGlvbigpIHtcclxuXHRpZih0eXBlb2YgdGhpcy5fY2FjaGVkU291cmNlICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gdGhpcy5fY2FjaGVkU291cmNlO1xyXG5cdHJldHVybiB0aGlzLl9jYWNoZWRTb3VyY2UgPSB0aGlzLl9zb3VyY2Uuc291cmNlKCk7XHJcbn07XHJcblxyXG5DYWNoZWRTb3VyY2UucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcclxuXHRpZih0eXBlb2YgdGhpcy5fY2FjaGVkU2l6ZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIHRoaXMuX2NhY2hlZFNpemU7XHJcblx0aWYodHlwZW9mIHRoaXMuX2NhY2hlZFNvdXJjZSAhPT0gXCJ1bmRlZmluZWRcIilcclxuXHRcdHJldHVybiB0aGlzLl9jYWNoZWRTaXplID0gdGhpcy5fY2FjaGVkU291cmNlLmxlbmd0aDtcclxuXHRyZXR1cm4gdGhpcy5fY2FjaGVkU2l6ZSA9IHRoaXMuX3NvdXJjZS5zaXplKCk7XHJcbn07XHJcblxyXG5DYWNoZWRTb3VyY2UucHJvdG90eXBlLnNvdXJjZUFuZE1hcCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHR2YXIga2V5ID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucyk7XHJcblx0aWYodHlwZW9mIHRoaXMuX2NhY2hlZFNvdXJjZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBrZXkgaW4gdGhpcy5fY2FjaGVkTWFwcylcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHNvdXJjZTogdGhpcy5fY2FjaGVkU291cmNlLFxyXG5cdFx0XHRtYXA6IHRoaXMuX2NhY2hlZE1hcHNba2V5XVxyXG5cdFx0fTtcclxuXHRlbHNlIGlmKHR5cGVvZiB0aGlzLl9jYWNoZWRTb3VyY2UgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHNvdXJjZTogdGhpcy5fY2FjaGVkU291cmNlLFxyXG5cdFx0XHRtYXA6IHRoaXMuX2NhY2hlZE1hcHNba2V5XSA9IHRoaXMuX3NvdXJjZS5tYXAob3B0aW9ucylcclxuXHRcdH07XHJcblx0fSBlbHNlIGlmKGtleSBpbiB0aGlzLl9jYWNoZWRNYXBzKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRzb3VyY2U6IHRoaXMuX2NhY2hlZFNvdXJjZSA9IHRoaXMuX3NvdXJjZS5zb3VyY2UoKSxcclxuXHRcdFx0bWFwOiB0aGlzLl9jYWNoZWRNYXBzW2tleV1cclxuXHRcdH07XHJcblx0fVxyXG5cdHZhciByZXN1bHQgPSB0aGlzLl9zb3VyY2Uuc291cmNlQW5kTWFwKG9wdGlvbnMpO1xyXG5cdHRoaXMuX2NhY2hlZFNvdXJjZSA9IHJlc3VsdC5zb3VyY2U7XHJcblx0dGhpcy5fY2FjaGVkTWFwc1trZXldID0gcmVzdWx0Lm1hcDtcclxuXHRyZXR1cm4ge1xyXG5cdFx0c291cmNlOiB0aGlzLl9jYWNoZWRTb3VyY2UsXHJcblx0XHRtYXA6IHRoaXMuX2NhY2hlZE1hcHNba2V5XVxyXG5cdH07XHJcbn07XHJcblxyXG5DYWNoZWRTb3VyY2UucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHRpZighb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xyXG5cdHZhciBrZXkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zKTtcclxuXHRpZihrZXkgaW4gdGhpcy5fY2FjaGVkTWFwcylcclxuXHRcdHJldHVybiB0aGlzLl9jYWNoZWRNYXBzW2tleV07XHJcblx0cmV0dXJuIHRoaXMuX2NhY2hlZE1hcHNba2V5XSA9IHRoaXMuX3NvdXJjZS5tYXAoKTtcclxufTtcclxuXHJcbkNhY2hlZFNvdXJjZS5wcm90b3R5cGUudXBkYXRlSGFzaCA9IGZ1bmN0aW9uKGhhc2gpIHtcclxuXHR0aGlzLl9zb3VyY2UudXBkYXRlSGFzaChoYXNoKTtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spLXNvdXJjZXMvbGliL0NhY2hlZFNvdXJjZS5qc1xuLy8gbW9kdWxlIGlkID0gMzU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBTb3VyY2VOb2RlID0gcmVxdWlyZShcInNvdXJjZS1tYXBcIikuU291cmNlTm9kZTtcclxudmFyIFNvdXJjZUxpc3RNYXAgPSByZXF1aXJlKFwic291cmNlLWxpc3QtbWFwXCIpLlNvdXJjZUxpc3RNYXA7XHJcbnZhciBTb3VyY2UgPSByZXF1aXJlKFwiLi9Tb3VyY2VcIik7XHJcblxyXG5mdW5jdGlvbiBDb25jYXRTb3VyY2UoKSB7XHJcblx0U291cmNlLmNhbGwodGhpcyk7XHJcblx0dGhpcy5jaGlsZHJlbiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBDb25jYXRTb3VyY2U7XHJcblxyXG5Db25jYXRTb3VyY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2UucHJvdG90eXBlKTtcclxuQ29uY2F0U291cmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbmNhdFNvdXJjZTtcclxuXHJcbkNvbmNhdFNvdXJjZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oaXRlbSkge1xyXG5cdHRoaXMuY2hpbGRyZW4ucHVzaChpdGVtKTtcclxufTtcclxuXHJcbkNvbmNhdFNvdXJjZS5wcm90b3R5cGUuc291cmNlID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHRcdHJldHVybiB0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIiA/IGl0ZW0gOiBpdGVtLnNvdXJjZSgpO1xyXG5cdH0pLmpvaW4oXCJcIik7XHJcbn07XHJcblxyXG5Db25jYXRTb3VyY2UucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oaXRlbSkge1xyXG5cdFx0cmV0dXJuIHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiID8gaXRlbS5sZW5ndGggOiBpdGVtLnNpemUoKTtcclxuXHR9KS5yZWR1Y2UoZnVuY3Rpb24oc3VtLCBzKSB7XHJcblx0XHRyZXR1cm4gc3VtICsgcztcclxuXHR9LCAwKTtcclxufTtcclxuXHJcbnJlcXVpcmUoXCIuL1NvdXJjZUFuZE1hcE1peGluXCIpKENvbmNhdFNvdXJjZS5wcm90b3R5cGUpO1xyXG5cclxuQ29uY2F0U291cmNlLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdHZhciBub2RlID0gbmV3IFNvdXJjZU5vZGUobnVsbCwgbnVsbCwgbnVsbCwgdGhpcy5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oaXRlbSkge1xyXG5cdFx0cmV0dXJuIHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiID8gaXRlbSA6IGl0ZW0ubm9kZShvcHRpb25zKTtcclxuXHR9KSk7XHJcblx0cmV0dXJuIG5vZGU7XHJcbn07XHJcblxyXG5Db25jYXRTb3VyY2UucHJvdG90eXBlLmxpc3RNYXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0dmFyIG1hcCA9IG5ldyBTb3VyY2VMaXN0TWFwKCk7XHJcblx0dGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHRcdGlmKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiKVxyXG5cdFx0XHRtYXAuYWRkKGl0ZW0pO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRtYXAuYWRkKGl0ZW0ubGlzdE1hcChvcHRpb25zKSk7XHJcblx0fSk7XHJcblx0cmV0dXJuIG1hcDtcclxufTtcclxuXHJcbkNvbmNhdFNvdXJjZS5wcm90b3R5cGUudXBkYXRlSGFzaCA9IGZ1bmN0aW9uKGhhc2gpIHtcclxuXHR0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xyXG5cdFx0aWYodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpXHJcblx0XHRcdGhhc2gudXBkYXRlKGl0ZW0pO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRpdGVtLnVwZGF0ZUhhc2goaGFzaCk7XHJcblx0fSk7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS1zb3VyY2VzL2xpYi9Db25jYXRTb3VyY2UuanNcbi8vIG1vZHVsZSBpZCA9IDM2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgU291cmNlID0gcmVxdWlyZShcIi4vU291cmNlXCIpO1xyXG52YXIgU291cmNlTm9kZSA9IHJlcXVpcmUoXCJzb3VyY2UtbWFwXCIpLlNvdXJjZU5vZGU7XHJcbnZhciBTb3VyY2VMaXN0TWFwID0gcmVxdWlyZShcInNvdXJjZS1saXN0LW1hcFwiKS5Tb3VyY2VMaXN0TWFwO1xyXG52YXIgZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAgPSByZXF1aXJlKFwic291cmNlLWxpc3QtbWFwXCIpLmZyb21TdHJpbmdXaXRoU291cmNlTWFwO1xyXG52YXIgU291cmNlTWFwQ29uc3VtZXIgPSByZXF1aXJlKFwic291cmNlLW1hcFwiKS5Tb3VyY2VNYXBDb25zdW1lcjtcclxuXHJcbmZ1bmN0aW9uIFJlcGxhY2VTb3VyY2Uoc291cmNlLCBuYW1lKSB7XHJcblx0U291cmNlLmNhbGwodGhpcyk7XHJcblx0dGhpcy5fc291cmNlID0gc291cmNlO1xyXG5cdHRoaXMuX25hbWUgPSBuYW1lO1xyXG5cdHRoaXMucmVwbGFjZW1lbnRzID0gW107XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBSZXBsYWNlU291cmNlO1xyXG5cclxuUmVwbGFjZVNvdXJjZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZS5wcm90b3R5cGUpO1xyXG5SZXBsYWNlU291cmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlcGxhY2VTb3VyY2U7XHJcblxyXG5SZXBsYWNlU291cmNlLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCwgbmV3VmFsdWUpIHtcclxuXHRpZih0eXBlb2YgbmV3VmFsdWUgIT09IFwic3RyaW5nXCIpXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJpbnNlcnRpb24gbXVzdCBiZSBhIHN0cmluZywgYnV0IGlzIGEgXCIgKyB0eXBlb2YgbmV3VmFsdWUpO1xyXG5cdHRoaXMucmVwbGFjZW1lbnRzLnB1c2goW3N0YXJ0LCBlbmQsIG5ld1ZhbHVlLCB0aGlzLnJlcGxhY2VtZW50cy5sZW5ndGhdKTtcclxufTtcclxuXHJcblJlcGxhY2VTb3VyY2UucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKHBvcywgbmV3VmFsdWUpIHtcclxuXHRpZih0eXBlb2YgbmV3VmFsdWUgIT09IFwic3RyaW5nXCIpXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJpbnNlcnRpb24gbXVzdCBiZSBhIHN0cmluZywgYnV0IGlzIGEgXCIgKyB0eXBlb2YgbmV3VmFsdWUgKyBcIjogXCIgKyBuZXdWYWx1ZSk7XHJcblx0dGhpcy5yZXBsYWNlbWVudHMucHVzaChbcG9zLCBwb3MgLSAxLCBuZXdWYWx1ZSwgdGhpcy5yZXBsYWNlbWVudHMubGVuZ3RoXSk7XHJcbn07XHJcblxyXG5SZXBsYWNlU291cmNlLnByb3RvdHlwZS5zb3VyY2UgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0cmV0dXJuIHRoaXMuX3JlcGxhY2VTdHJpbmcodGhpcy5fc291cmNlLnNvdXJjZSgpKTtcclxufTtcclxuXHJcblJlcGxhY2VTb3VyY2UucHJvdG90eXBlLl9zb3J0UmVwbGFjZW1lbnRzID0gZnVuY3Rpb24oKSB7XHJcblx0dGhpcy5yZXBsYWNlbWVudHMuc29ydChmdW5jdGlvbihhLCBiKSB7XHJcblx0XHR2YXIgZGlmZiA9IGJbMV0gLSBhWzFdO1xyXG5cdFx0aWYoZGlmZiAhPT0gMClcclxuXHRcdFx0cmV0dXJuIGRpZmY7XHJcblx0XHRkaWZmID0gYlswXSAtIGFbMF07XHJcblx0XHRpZihkaWZmICE9PSAwKVxyXG5cdFx0XHRyZXR1cm4gZGlmZjtcclxuXHRcdHJldHVybiBiWzNdIC0gYVszXTtcclxuXHR9KTtcclxufTtcclxuXHJcblJlcGxhY2VTb3VyY2UucHJvdG90eXBlLl9yZXBsYWNlU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XHJcblx0aWYodHlwZW9mIHN0ciAhPT0gXCJzdHJpbmdcIilcclxuXHRcdHRocm93IG5ldyBFcnJvcihcInN0ciBtdXN0IGJlIGEgc3RyaW5nLCBidXQgaXMgYSBcIiArIHR5cGVvZiBzdHIgKyBcIjogXCIgKyBzdHIpO1xyXG5cdHRoaXMuX3NvcnRSZXBsYWNlbWVudHMoKTtcclxuXHR2YXIgcmVzdWx0ID0gW3N0cl07XHJcblx0dGhpcy5yZXBsYWNlbWVudHMuZm9yRWFjaChmdW5jdGlvbihyZXBsKSB7XHJcblx0XHR2YXIgcmVtU291cmNlID0gcmVzdWx0LnBvcCgpO1xyXG5cdFx0dmFyIHNwbGl0dGVkMSA9IHRoaXMuX3NwbGl0U3RyaW5nKHJlbVNvdXJjZSwgTWF0aC5mbG9vcihyZXBsWzFdICsgMSkpO1xyXG5cdFx0dmFyIHNwbGl0dGVkMiA9IHRoaXMuX3NwbGl0U3RyaW5nKHNwbGl0dGVkMVswXSwgTWF0aC5mbG9vcihyZXBsWzBdKSk7XHJcblx0XHRyZXN1bHQucHVzaChzcGxpdHRlZDFbMV0sIHJlcGxbMl0sIHNwbGl0dGVkMlswXSk7XHJcblx0fSwgdGhpcyk7XHJcblx0cmVzdWx0ID0gcmVzdWx0LnJldmVyc2UoKTtcclxuXHRyZXR1cm4gcmVzdWx0LmpvaW4oXCJcIik7XHJcbn07XHJcblxyXG5yZXF1aXJlKFwiLi9Tb3VyY2VBbmRNYXBNaXhpblwiKShSZXBsYWNlU291cmNlLnByb3RvdHlwZSk7XHJcblxyXG5SZXBsYWNlU291cmNlLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdHRoaXMuX3NvcnRSZXBsYWNlbWVudHMoKTtcclxuXHR2YXIgcmVzdWx0ID0gW3RoaXMuX3NvdXJjZS5ub2RlKG9wdGlvbnMpXTtcclxuXHR0aGlzLnJlcGxhY2VtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHJlcGwpIHtcclxuXHRcdHZhciByZW1Tb3VyY2UgPSByZXN1bHQucG9wKCk7XHJcblx0XHR2YXIgc3BsaXR0ZWQxID0gdGhpcy5fc3BsaXRTb3VyY2VOb2RlKHJlbVNvdXJjZSwgTWF0aC5mbG9vcihyZXBsWzFdICsgMSkpO1xyXG5cdFx0dmFyIHNwbGl0dGVkMjtcclxuXHRcdGlmKEFycmF5LmlzQXJyYXkoc3BsaXR0ZWQxKSkge1xyXG5cdFx0XHRzcGxpdHRlZDIgPSB0aGlzLl9zcGxpdFNvdXJjZU5vZGUoc3BsaXR0ZWQxWzBdLCBNYXRoLmZsb29yKHJlcGxbMF0pKTtcclxuXHRcdFx0aWYoQXJyYXkuaXNBcnJheShzcGxpdHRlZDIpKSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goc3BsaXR0ZWQxWzFdLCB0aGlzLl9yZXBsYWNlbWVudFRvU291cmNlTm9kZShzcGxpdHRlZDJbMV0sIHJlcGxbMl0pLCBzcGxpdHRlZDJbMF0pO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKHNwbGl0dGVkMVsxXSwgdGhpcy5fcmVwbGFjZW1lbnRUb1NvdXJjZU5vZGUoc3BsaXR0ZWQxWzFdLCByZXBsWzJdKSwgc3BsaXR0ZWQxWzBdKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3BsaXR0ZWQyID0gdGhpcy5fc3BsaXRTb3VyY2VOb2RlKHJlbVNvdXJjZSwgTWF0aC5mbG9vcihyZXBsWzBdKSk7XHJcblx0XHRcdGlmKEFycmF5LmlzQXJyYXkoc3BsaXR0ZWQyKSkge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKHRoaXMuX3JlcGxhY2VtZW50VG9Tb3VyY2VOb2RlKHNwbGl0dGVkMlsxXSwgcmVwbFsyXSksIHNwbGl0dGVkMlswXSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2gocmVwbFsyXSwgcmVtU291cmNlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sIHRoaXMpO1xyXG5cdHJlc3VsdCA9IHJlc3VsdC5yZXZlcnNlKCk7XHJcblx0cmV0dXJuIG5ldyBTb3VyY2VOb2RlKG51bGwsIG51bGwsIG51bGwsIHJlc3VsdCk7XHJcbn07XHJcblxyXG5SZXBsYWNlU291cmNlLnByb3RvdHlwZS5saXN0TWFwID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdHZhciBtYXAgPSB0aGlzLl9zb3VyY2UubGlzdE1hcChvcHRpb25zKTtcclxuXHRpZihtYXAuY2hpbGRyZW4ubGVuZ3RoICE9PSAxKSB7XHJcblx0XHR2YXIgY29kZSA9IG1hcC50b1N0cmluZygpO1xyXG5cdFx0Y29kZSA9IHRoaXMuX3JlcGxhY2VTdHJpbmcoY29kZSkuc3BsaXQoXCJcXG5cIik7XHJcblx0XHR2YXIgY3VycmVudEluZGV4ID0gMDtcclxuXHRcdG1hcC5tYXBHZW5lcmF0ZWRDb2RlKGZ1bmN0aW9uKHN0cikge1xyXG5cdFx0XHR2YXIgaWR4ID0gLTE7XHJcblx0XHRcdHZhciBjb3VudCA9IC0xO1xyXG5cdFx0XHRkbyB7XHJcblx0XHRcdFx0Y291bnQrKztcclxuXHRcdFx0XHRpZHggPSBzdHIuaW5kZXhPZihcIlxcblwiLCBpZHggKyAxKTtcclxuXHRcdFx0fSB3aGlsZSAoaWR4ID49IDApO1xyXG5cdFx0XHRpZighY291bnQpIHJldHVybiBcIlwiO1xyXG5cdFx0XHR2YXIgcmVzdWx0ID0gY29kZS5zbGljZShjdXJyZW50SW5kZXgsIGN1cnJlbnRJbmRleCArIGNvdW50KS5qb2luKFwiXFxuXCIpICsgXCJcXG5cIjtcclxuXHRcdFx0Y3VycmVudEluZGV4ICs9IGNvdW50O1xyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdFx0fSk7XHJcblx0XHRtYXAuYWRkKGNvZGUuc2xpY2UoY3VycmVudEluZGV4KS5qb2luKFwiXFxuXCIpKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0bWFwLm1hcEdlbmVyYXRlZENvZGUodGhpcy5fcmVwbGFjZVN0cmluZy5iaW5kKHRoaXMpKTtcclxuXHR9XHJcblx0cmV0dXJuIG1hcDtcclxufTtcclxuXHJcblJlcGxhY2VTb3VyY2UucHJvdG90eXBlLl9yZXBsYWNlbWVudFRvU291cmNlTm9kZSA9IGZ1bmN0aW9uKG9sZE5vZGUsIG5ld1N0cmluZykge1xyXG5cdHZhciBtYXAgPSBvbGROb2RlLnRvU3RyaW5nV2l0aFNvdXJjZU1hcCh7XHJcblx0XHRmaWxlOiBcIj9cIlxyXG5cdH0pLm1hcDtcclxuXHR2YXIgb3JpZ2luYWwgPSBuZXcgU291cmNlTWFwQ29uc3VtZXIobWFwLnRvSlNPTigpKS5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcclxuXHRcdGxpbmU6IDEsXHJcblx0XHRjb2x1bW46IDBcclxuXHR9KTtcclxuXHRpZihvcmlnaW5hbCkge1xyXG5cdFx0cmV0dXJuIG5ldyBTb3VyY2VOb2RlKG9yaWdpbmFsLmxpbmUsIG9yaWdpbmFsLmNvbHVtbiwgb3JpZ2luYWwuc291cmNlLCBuZXdTdHJpbmcpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXR1cm4gbmV3U3RyaW5nO1xyXG5cdH1cclxufTtcclxuXHJcblJlcGxhY2VTb3VyY2UucHJvdG90eXBlLl9zcGxpdFNvdXJjZU5vZGUgPSBmdW5jdGlvbihub2RlLCBwb3NpdGlvbikge1xyXG5cdGlmKHR5cGVvZiBub2RlID09PSBcInN0cmluZ1wiKSB7XHJcblx0XHRpZihub2RlLmxlbmd0aCA8PSBwb3NpdGlvbikgcmV0dXJuIHBvc2l0aW9uIC0gbm9kZS5sZW5ndGg7XHJcblx0XHRyZXR1cm4gcG9zaXRpb24gPD0gMCA/IFtcIlwiLCBub2RlXSA6IFtub2RlLnN1YnN0cigwLCBwb3NpdGlvbiksIG5vZGUuc3Vic3RyKHBvc2l0aW9uKV07XHJcblx0fSBlbHNlIHtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHBvc2l0aW9uID0gdGhpcy5fc3BsaXRTb3VyY2VOb2RlKG5vZGUuY2hpbGRyZW5baV0sIHBvc2l0aW9uKTtcclxuXHRcdFx0aWYoQXJyYXkuaXNBcnJheShwb3NpdGlvbikpIHtcclxuXHRcdFx0XHR2YXIgbGVmdE5vZGUgPSBuZXcgU291cmNlTm9kZShcclxuXHRcdFx0XHRcdG5vZGUubGluZSxcclxuXHRcdFx0XHRcdG5vZGUuY29sdW1uLFxyXG5cdFx0XHRcdFx0bm9kZS5zb3VyY2UsXHJcblx0XHRcdFx0XHRub2RlLmNoaWxkcmVuLnNsaWNlKDAsIGkpLmNvbmNhdChbcG9zaXRpb25bMF1dKSxcclxuXHRcdFx0XHRcdG5vZGUubmFtZVxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdFx0dmFyIHJpZ2h0Tm9kZSA9IG5ldyBTb3VyY2VOb2RlKFxyXG5cdFx0XHRcdFx0bm9kZS5saW5lLFxyXG5cdFx0XHRcdFx0bm9kZS5jb2x1bW4sXHJcblx0XHRcdFx0XHRub2RlLnNvdXJjZSwgW3Bvc2l0aW9uWzFdXS5jb25jYXQobm9kZS5jaGlsZHJlbi5zbGljZShpICsgMSkpLFxyXG5cdFx0XHRcdFx0bm9kZS5uYW1lXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0XHRsZWZ0Tm9kZS5zb3VyY2VDb250ZW50cyA9IG5vZGUuc291cmNlQ29udGVudHM7XHJcblx0XHRcdFx0cmV0dXJuIFtsZWZ0Tm9kZSwgcmlnaHROb2RlXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHBvc2l0aW9uO1xyXG5cdH1cclxufTtcclxuXHJcblJlcGxhY2VTb3VyY2UucHJvdG90eXBlLl9zcGxpdFN0cmluZyA9IGZ1bmN0aW9uKHN0ciwgcG9zaXRpb24pIHtcclxuXHRyZXR1cm4gcG9zaXRpb24gPD0gMCA/IFtcIlwiLCBzdHJdIDogW3N0ci5zdWJzdHIoMCwgcG9zaXRpb24pLCBzdHIuc3Vic3RyKHBvc2l0aW9uKV07XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS1zb3VyY2VzL2xpYi9SZXBsYWNlU291cmNlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIFNvdXJjZSA9IHJlcXVpcmUoXCIuL1NvdXJjZVwiKTtcclxudmFyIFNvdXJjZU5vZGUgPSByZXF1aXJlKFwic291cmNlLW1hcFwiKS5Tb3VyY2VOb2RlO1xyXG5cclxuZnVuY3Rpb24gUHJlZml4U291cmNlKHByZWZpeCwgc291cmNlKSB7XHJcblx0U291cmNlLmNhbGwodGhpcyk7XHJcblx0dGhpcy5fc291cmNlID0gc291cmNlO1xyXG5cdHRoaXMuX3ByZWZpeCA9IHByZWZpeDtcclxufVxyXG5tb2R1bGUuZXhwb3J0cyA9IFByZWZpeFNvdXJjZTtcclxuXHJcblByZWZpeFNvdXJjZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZS5wcm90b3R5cGUpO1xyXG5QcmVmaXhTb3VyY2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHJlZml4U291cmNlO1xyXG5cclxuUHJlZml4U291cmNlLnByb3RvdHlwZS5zb3VyY2UgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgbm9kZSA9IHR5cGVvZiB0aGlzLl9zb3VyY2UgPT09IFwic3RyaW5nXCIgPyB0aGlzLl9zb3VyY2UgOiB0aGlzLl9zb3VyY2Uuc291cmNlKCk7XHJcblx0dmFyIHByZWZpeCA9IHRoaXMuX3ByZWZpeDtcclxuXHRyZXR1cm4gcHJlZml4ICsgbm9kZS5yZXBsYWNlKC9cXG4oLikvZywgXCJcXG5cIiArIHByZWZpeCArIFwiJDFcIik7XHJcbn07XHJcblxyXG5yZXF1aXJlKFwiLi9Tb3VyY2VBbmRNYXBNaXhpblwiKShQcmVmaXhTb3VyY2UucHJvdG90eXBlKTtcclxuXHJcblByZWZpeFNvdXJjZS5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHR2YXIgbm9kZSA9IHRoaXMuX3NvdXJjZS5ub2RlKG9wdGlvbnMpO1xyXG5cdHZhciBhcHBlbmQgPSBbdGhpcy5fcHJlZml4XTtcclxuXHRyZXR1cm4gbmV3IFNvdXJjZU5vZGUobnVsbCwgbnVsbCwgbnVsbCwgW1xyXG5cdFx0Y2xvbmVBbmRQcmVmaXgobm9kZSwgdGhpcy5fcHJlZml4LCBhcHBlbmQpXHJcblx0XSk7XHJcbn07XHJcblxyXG5QcmVmaXhTb3VyY2UucHJvdG90eXBlLmxpc3RNYXAgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0dmFyIHByZWZpeCA9IHRoaXMuX3ByZWZpeDtcclxuXHR2YXIgbWFwID0gdGhpcy5fc291cmNlLmxpc3RNYXAob3B0aW9ucyk7XHJcblx0bWFwLm1hcEdlbmVyYXRlZENvZGUoZnVuY3Rpb24oY29kZSkge1xyXG5cdFx0cmV0dXJuIHByZWZpeCArIGNvZGUucmVwbGFjZSgvXFxuKC4pL2csIFwiXFxuXCIgKyBwcmVmaXggKyBcIiQxXCIpO1xyXG5cdH0pO1xyXG5cdHJldHVybiBtYXA7XHJcbn07XHJcblxyXG5QcmVmaXhTb3VyY2UucHJvdG90eXBlLnVwZGF0ZUhhc2ggPSBmdW5jdGlvbihoYXNoKSB7XHJcblx0aWYodHlwZW9mIHRoaXMuX3NvdXJjZSA9PT0gXCJzdHJpbmdcIilcclxuXHRcdGhhc2gudXBkYXRlKHRoaXMuX3NvdXJjZSk7XHJcblx0ZWxzZVxyXG5cdFx0dGhpcy5fc291cmNlLnVwZGF0ZUhhc2goaGFzaCk7XHJcblx0aWYodHlwZW9mIHRoaXMuX3ByZWZpeCA9PT0gXCJzdHJpbmdcIilcclxuXHRcdGhhc2gudXBkYXRlKHRoaXMuX3ByZWZpeCk7XHJcblx0ZWxzZVxyXG5cdFx0dGhpcy5fcHJlZml4LnVwZGF0ZUhhc2goaGFzaCk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBjbG9uZUFuZFByZWZpeChub2RlLCBwcmVmaXgsIGFwcGVuZCkge1xyXG5cdGlmKHR5cGVvZiBub2RlID09PSBcInN0cmluZ1wiKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gbm9kZS5yZXBsYWNlKC9cXG4oLikvZywgXCJcXG5cIiArIHByZWZpeCArIFwiJDFcIik7XHJcblx0XHRpZihhcHBlbmQubGVuZ3RoID4gMCkgcmVzdWx0ID0gYXBwZW5kLnBvcCgpICsgcmVzdWx0O1xyXG5cdFx0aWYoL1xcbiQvLnRlc3Qobm9kZSkpIGFwcGVuZC5wdXNoKHByZWZpeCk7XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgbmV3Tm9kZSA9IG5ldyBTb3VyY2VOb2RlKFxyXG5cdFx0XHRub2RlLmxpbmUsXHJcblx0XHRcdG5vZGUuY29sdW1uLFxyXG5cdFx0XHRub2RlLnNvdXJjZSxcclxuXHRcdFx0bm9kZS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24obm9kZSkge1xyXG5cdFx0XHRcdHJldHVybiBjbG9uZUFuZFByZWZpeChub2RlLCBwcmVmaXgsIGFwcGVuZCk7XHJcblx0XHRcdH0pLFxyXG5cdFx0XHRub2RlLm5hbWVcclxuXHRcdCk7XHJcblx0XHRuZXdOb2RlLnNvdXJjZUNvbnRlbnRzID0gbm9kZS5zb3VyY2VDb250ZW50cztcclxuXHRcdHJldHVybiBuZXdOb2RlO1xyXG5cdH1cclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spLXNvdXJjZXMvbGliL1ByZWZpeFNvdXJjZS5qc1xuLy8gbW9kdWxlIGlkID0gMzYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbnZhciBTb3VyY2VNYXBTb3VyY2UgPSByZXF1aXJlKFwid2VicGFjay1zb3VyY2VzXCIpLlNvdXJjZU1hcFNvdXJjZTtcclxudmFyIFJhd1NvdXJjZSA9IHJlcXVpcmUoXCJ3ZWJwYWNrLXNvdXJjZXNcIikuUmF3U291cmNlO1xyXG5cclxuZnVuY3Rpb24gRXh0cmFjdGVkTW9kdWxlKGlkZW50aWZpZXIsIG9yaWdpbmFsTW9kdWxlLCBzb3VyY2UsIHNvdXJjZU1hcCwgYWRkdGl0aW9uYWxJbmZvcm1hdGlvbiwgcHJldk1vZHVsZXMpIHtcclxuXHR0aGlzLl9pZGVudGlmaWVyID0gaWRlbnRpZmllcjtcclxuXHR0aGlzLl9vcmlnaW5hbE1vZHVsZSA9IG9yaWdpbmFsTW9kdWxlO1xyXG5cdHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcclxuXHR0aGlzLl9zb3VyY2VNYXAgPSBzb3VyY2VNYXA7XHJcblx0dGhpcy5fcHJldk1vZHVsZXMgPSBwcmV2TW9kdWxlcztcclxuXHR0aGlzLmFkZHRpdGlvbmFsSW5mb3JtYXRpb24gPSBhZGR0aXRpb25hbEluZm9ybWF0aW9uO1xyXG5cdHRoaXMuY2h1bmtzID0gW107XHJcbn1cclxubW9kdWxlLmV4cG9ydHMgPSBFeHRyYWN0ZWRNb2R1bGU7XHJcblxyXG5FeHRyYWN0ZWRNb2R1bGUucHJvdG90eXBlLmdldE9yZGVyID0gZnVuY3Rpb24oKSB7XHJcblx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTQ2NzY2NjUvMTQ1ODE2MlxyXG5cdHJldHVybiAvXkBpbXBvcnQgdXJsLy50ZXN0KHRoaXMuX3NvdXJjZSkgPyAwIDogMTtcclxufTtcclxuXHJcbkV4dHJhY3RlZE1vZHVsZS5wcm90b3R5cGUuYWRkQ2h1bmsgPSBmdW5jdGlvbihjaHVuaykge1xyXG5cdHZhciBpZHggPSB0aGlzLmNodW5rcy5pbmRleE9mKGNodW5rKTtcclxuXHRpZihpZHggPCAwKVxyXG5cdFx0dGhpcy5jaHVua3MucHVzaChjaHVuayk7XHJcbn07XHJcblxyXG5FeHRyYWN0ZWRNb2R1bGUucHJvdG90eXBlLl9yZW1vdmVBbmREbyA9IHJlcXVpcmUoXCJ3ZWJwYWNrL2xpYi9yZW1vdmVBbmREb1wiKTtcclxuXHJcbkV4dHJhY3RlZE1vZHVsZS5wcm90b3R5cGUucmVtb3ZlQ2h1bmsgPSBmdW5jdGlvbihjaHVuaykge1xyXG5cdHJldHVybiB0aGlzLl9yZW1vdmVBbmREbyhcImNodW5rc1wiLCBjaHVuaywgXCJyZW1vdmVNb2R1bGVcIik7XHJcbn07XHJcblxyXG5FeHRyYWN0ZWRNb2R1bGUucHJvdG90eXBlLnJld3JpdGVDaHVua0luUmVhc29ucyA9IGZ1bmN0aW9uKG9sZENodW5rLCBuZXdDaHVua3MpIHsgfTtcclxuXHJcbkV4dHJhY3RlZE1vZHVsZS5wcm90b3R5cGUuaWRlbnRpZmllciA9IGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzLl9pZGVudGlmaWVyO1xyXG59O1xyXG5cclxuRXh0cmFjdGVkTW9kdWxlLnByb3RvdHlwZS5zb3VyY2UgPSBmdW5jdGlvbigpIHtcclxuXHRpZih0aGlzLl9zb3VyY2VNYXApXHJcblx0XHRyZXR1cm4gbmV3IFNvdXJjZU1hcFNvdXJjZSh0aGlzLl9zb3VyY2UsIG51bGwsIHRoaXMuX3NvdXJjZU1hcCk7XHJcblx0ZWxzZVxyXG5cdFx0cmV0dXJuIG5ldyBSYXdTb3VyY2UodGhpcy5fc291cmNlKTtcclxufTtcclxuXHJcbkV4dHJhY3RlZE1vZHVsZS5wcm90b3R5cGUuZ2V0T3JpZ2luYWxNb2R1bGUgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcy5fb3JpZ2luYWxNb2R1bGU7XHJcbn07XHJcblxyXG5FeHRyYWN0ZWRNb2R1bGUucHJvdG90eXBlLmdldFByZXZNb2R1bGVzID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMuX3ByZXZNb2R1bGVzO1xyXG59O1xyXG5cclxuRXh0cmFjdGVkTW9kdWxlLnByb3RvdHlwZS5hZGRQcmV2TW9kdWxlcyA9IGZ1bmN0aW9uKHByZXZNb2R1bGVzKSB7XHJcblx0cHJldk1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbihtKSB7XHJcblx0XHRpZih0aGlzLl9wcmV2TW9kdWxlcy5pbmRleE9mKG0pIDwgMClcclxuXHRcdFx0dGhpcy5fcHJldk1vZHVsZXMucHVzaChtKTtcclxuXHR9LCB0aGlzKTtcclxufTtcclxuXHJcbkV4dHJhY3RlZE1vZHVsZS5wcm90b3R5cGUuc2V0T3JpZ2luYWxNb2R1bGUgPSBmdW5jdGlvbihvcmlnaW5hbE1vZHVsZSkge1xyXG5cdHRoaXMuX29yaWdpbmFsTW9kdWxlID0gb3JpZ2luYWxNb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9leHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW4vRXh0cmFjdGVkTW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxuZnVuY3Rpb24gT3JkZXJVbmRlZmluZWRFcnJvcihtb2R1bGUpIHtcclxuXHRFcnJvci5jYWxsKHRoaXMpO1xyXG5cdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIE9yZGVyVW5kZWZpbmVkRXJyb3IpO1xyXG5cdHRoaXMubmFtZSA9IFwiT3JkZXJVbmRlZmluZWRFcnJvclwiO1xyXG5cdHRoaXMubWVzc2FnZSA9IFwiT3JkZXIgaW4gZXh0cmFjdGVkIGNodW5rIHVuZGVmaW5lZFwiO1xyXG5cdHRoaXMubW9kdWxlID0gbW9kdWxlO1xyXG59XHJcbm1vZHVsZS5leHBvcnRzID0gT3JkZXJVbmRlZmluZWRFcnJvcjtcclxuXHJcbk9yZGVyVW5kZWZpbmVkRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL09yZGVyVW5kZWZpbmVkRXJyb3IuanNcbi8vIG1vZHVsZSBpZCA9IDM2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgSlNPTjUgPSByZXF1aXJlKFwianNvbjVcIik7XHJcbnZhciBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcbnZhciBhc3NpZ24gPSByZXF1aXJlKFwib2JqZWN0LWFzc2lnblwiKTtcclxudmFyIGVtb2ppUmVnZXggPSAvW1xcdUQ4MDAtXFx1REZGRl0uLztcclxudmFyIGVtb2ppTGlzdCA9IHJlcXVpcmUoXCJlbW9qaXMtbGlzdFwiKS5maWx0ZXIoZnVuY3Rpb24oZW1vamkpIHtcclxuXHRyZXR1cm4gZW1vamlSZWdleC50ZXN0KGVtb2ppKVxyXG59KTtcclxuXHJcbnZhciBiYXNlRW5jb2RlVGFibGVzID0ge1xyXG5cdDI2OiBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIsXHJcblx0MzI6IFwiMTIzNDU2Nzg5YWJjZGVmZ2hqa21ucHFyc3R1dnd4eXpcIiwgLy8gbm8gMGxpb1xyXG5cdDM2OiBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiLFxyXG5cdDQ5OiBcImFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVpcIiwgLy8gbm8gbElPXHJcblx0NTI6IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiLFxyXG5cdDU4OiBcIjEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVpcIiwgLy8gbm8gMGxJT1xyXG5cdDYyOiBcIjAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCIsXHJcblx0NjQ6IFwiMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVotX1wiXHJcbn07XHJcbnZhciBlbW9qaUNhY2hlID0ge307XHJcblxyXG5mdW5jdGlvbiBlbmNvZGVTdHJpbmdUb0Vtb2ppKGNvbnRlbnQsIGxlbmd0aCkge1xyXG5cdGlmIChlbW9qaUNhY2hlW2NvbnRlbnRdKSByZXR1cm4gZW1vamlDYWNoZVtjb250ZW50XTtcclxuXHRsZW5ndGggPSBsZW5ndGggfHwgMTtcclxuXHR2YXIgZW1vamlzID0gW107XHJcblx0ZG8ge1xyXG5cdFx0dmFyIGluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogZW1vamlMaXN0Lmxlbmd0aCk7XHJcblx0XHRlbW9qaXMucHVzaChlbW9qaUxpc3RbaW5kZXhdKTtcclxuXHRcdGVtb2ppTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cdH0gd2hpbGUgKC0tbGVuZ3RoID4gMCk7XHJcblx0dmFyIGVtb2ppRW5jb2RpbmcgPSBlbW9qaXMuam9pbignJyk7XHJcblx0ZW1vamlDYWNoZVtjb250ZW50XSA9IGVtb2ppRW5jb2Rpbmc7XHJcblx0cmV0dXJuIGVtb2ppRW5jb2Rpbmc7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuY29kZUJ1ZmZlclRvQmFzZShidWZmZXIsIGJhc2UpIHtcclxuXHR2YXIgZW5jb2RlVGFibGUgPSBiYXNlRW5jb2RlVGFibGVzW2Jhc2VdO1xyXG5cdGlmICghZW5jb2RlVGFibGUpIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZW5jb2RpbmcgYmFzZVwiICsgYmFzZSk7XHJcblxyXG5cdHZhciByZWFkTGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcclxuXHJcblx0dmFyIEJpZyA9IHJlcXVpcmUoJ2JpZy5qcycpO1xyXG5cdEJpZy5STSA9IEJpZy5EUCA9IDA7XHJcblx0dmFyIGIgPSBuZXcgQmlnKDApO1xyXG5cdGZvciAodmFyIGkgPSByZWFkTGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdGIgPSBiLnRpbWVzKDI1NikucGx1cyhidWZmZXJbaV0pO1xyXG5cdH1cclxuXHJcblx0dmFyIG91dHB1dCA9IFwiXCI7XHJcblx0d2hpbGUgKGIuZ3QoMCkpIHtcclxuXHRcdG91dHB1dCA9IGVuY29kZVRhYmxlW2IubW9kKGJhc2UpXSArIG91dHB1dDtcclxuXHRcdGIgPSBiLmRpdihiYXNlKTtcclxuXHR9XHJcblxyXG5cdEJpZy5EUCA9IDIwO1xyXG5cdEJpZy5STSA9IDE7XHJcblxyXG5cdHJldHVybiBvdXRwdXQ7XHJcbn1cclxuXHJcbmV4cG9ydHMucGFyc2VRdWVyeSA9IGZ1bmN0aW9uIHBhcnNlUXVlcnkocXVlcnkpIHtcclxuXHR2YXIgc3BlY2lhbFZhbHVlcyA9IHtcclxuXHRcdCdudWxsJzogbnVsbCxcclxuXHRcdCd0cnVlJzogdHJ1ZSxcclxuXHRcdCdmYWxzZSc6IGZhbHNlXHJcblx0fTtcclxuXHRpZighcXVlcnkpIHJldHVybiB7fTtcclxuXHRpZih0eXBlb2YgcXVlcnkgIT09IFwic3RyaW5nXCIpXHJcblx0XHRyZXR1cm4gcXVlcnk7XHJcblx0aWYocXVlcnkuc3Vic3RyKDAsIDEpICE9PSBcIj9cIilcclxuXHRcdHRocm93IG5ldyBFcnJvcihcImEgdmFsaWQgcXVlcnkgc3RyaW5nIHBhc3NlZCB0byBwYXJzZVF1ZXJ5IHNob3VsZCBiZWdpbiB3aXRoICc/J1wiKTtcclxuXHRxdWVyeSA9IHF1ZXJ5LnN1YnN0cigxKTtcclxuXHR2YXIgcXVlcnlMZW5ndGggPSBxdWVyeS5sZW5ndGg7XHJcblx0aWYocXVlcnkuc3Vic3RyKDAsIDEpID09PSBcIntcIiAmJiBxdWVyeS5zdWJzdHIoLTEpID09PSBcIn1cIikge1xyXG5cdFx0cmV0dXJuIEpTT041LnBhcnNlKHF1ZXJ5KTtcclxuXHR9XHJcblx0dmFyIHF1ZXJ5QXJncyA9IHF1ZXJ5LnNwbGl0KC9bLFxcJl0vZyk7XHJcblx0dmFyIHJlc3VsdCA9IHt9O1xyXG5cdHF1ZXJ5QXJncy5mb3JFYWNoKGZ1bmN0aW9uKGFyZykge1xyXG5cdFx0dmFyIGlkeCA9IGFyZy5pbmRleE9mKFwiPVwiKTtcclxuXHRcdGlmKGlkeCA+PSAwKSB7XHJcblx0XHRcdHZhciBuYW1lID0gYXJnLnN1YnN0cigwLCBpZHgpO1xyXG5cdFx0XHR2YXIgdmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQoYXJnLnN1YnN0cihpZHgrMSkpO1xyXG5cdFx0XHRpZiAoc3BlY2lhbFZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkpIHtcclxuXHRcdFx0XHR2YWx1ZSA9IHNwZWNpYWxWYWx1ZXNbdmFsdWVdO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKG5hbWUuc3Vic3RyKC0yKSA9PT0gXCJbXVwiKSB7XHJcblx0XHRcdFx0bmFtZSA9IGRlY29kZVVSSUNvbXBvbmVudChuYW1lLnN1YnN0cigwLCBuYW1lLmxlbmd0aC0yKSk7XHJcblx0XHRcdFx0aWYoIUFycmF5LmlzQXJyYXkocmVzdWx0W25hbWVdKSlcclxuXHRcdFx0XHRcdHJlc3VsdFtuYW1lXSA9IFtdO1xyXG5cdFx0XHRcdHJlc3VsdFtuYW1lXS5wdXNoKHZhbHVlKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRuYW1lID0gZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpO1xyXG5cdFx0XHRcdHJlc3VsdFtuYW1lXSA9IHZhbHVlO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZihhcmcuc3Vic3RyKDAsIDEpID09PSBcIi1cIikge1xyXG5cdFx0XHRcdHJlc3VsdFtkZWNvZGVVUklDb21wb25lbnQoYXJnLnN1YnN0cigxKSldID0gZmFsc2U7XHJcblx0XHRcdH0gZWxzZSBpZihhcmcuc3Vic3RyKDAsIDEpID09PSBcIitcIikge1xyXG5cdFx0XHRcdHJlc3VsdFtkZWNvZGVVUklDb21wb25lbnQoYXJnLnN1YnN0cigxKSldID0gdHJ1ZTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXN1bHRbZGVjb2RlVVJJQ29tcG9uZW50KGFyZyldID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0pO1xyXG5cdHJldHVybiByZXN1bHQ7XHJcbn07XHJcblxyXG5leHBvcnRzLmdldExvYWRlckNvbmZpZyA9IGZ1bmN0aW9uKGxvYWRlckNvbnRleHQsIGRlZmF1bHRDb25maWdLZXkpIHtcclxuXHR2YXIgcXVlcnkgPSBleHBvcnRzLnBhcnNlUXVlcnkobG9hZGVyQ29udGV4dC5xdWVyeSk7XHJcblx0dmFyIGNvbmZpZ0tleSA9IHF1ZXJ5LmNvbmZpZyB8fCBkZWZhdWx0Q29uZmlnS2V5O1xyXG5cdGlmIChjb25maWdLZXkpIHtcclxuXHRcdHZhciBjb25maWcgPSBsb2FkZXJDb250ZXh0Lm9wdGlvbnNbY29uZmlnS2V5XSB8fCB7fTtcclxuXHRcdGRlbGV0ZSBxdWVyeS5jb25maWc7XHJcblx0XHRyZXR1cm4gYXNzaWduKHt9LCBjb25maWcsIHF1ZXJ5KTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBxdWVyeTtcclxufTtcclxuXHJcbmV4cG9ydHMuc3RyaW5naWZ5UmVxdWVzdCA9IGZ1bmN0aW9uKGxvYWRlckNvbnRleHQsIHJlcXVlc3QpIHtcclxuXHR2YXIgc3BsaXR0ZWQgPSByZXF1ZXN0LnNwbGl0KFwiIVwiKTtcclxuXHR2YXIgY29udGV4dCA9IGxvYWRlckNvbnRleHQuY29udGV4dCB8fCAobG9hZGVyQ29udGV4dC5vcHRpb25zICYmIGxvYWRlckNvbnRleHQub3B0aW9ucy5jb250ZXh0KTtcclxuXHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3BsaXR0ZWQubWFwKGZ1bmN0aW9uKHBhcnQpIHtcclxuXHRcdGlmKC9eXFwvfF5bQS1aXTovaS50ZXN0KHBhcnQpICYmIGNvbnRleHQpIHtcclxuXHRcdFx0cGFydCA9IHBhdGgucmVsYXRpdmUoY29udGV4dCwgcGFydCk7XHJcblx0XHRcdGlmKC9eW0EtWl06L2kudGVzdChwYXJ0KSkge1xyXG5cdFx0XHRcdHJldHVybiBwYXJ0O1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldHVybiBcIi4vXCIgKyBwYXJ0LnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcGFydDtcclxuXHR9KS5qb2luKFwiIVwiKSk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBkb3RSZXF1ZXN0KG9iaikge1xyXG5cdHJldHVybiBvYmoucmVxdWVzdDtcclxufVxyXG5cclxuZXhwb3J0cy5nZXRSZW1haW5pbmdSZXF1ZXN0ID0gZnVuY3Rpb24obG9hZGVyQ29udGV4dCkge1xyXG5cdGlmKGxvYWRlckNvbnRleHQucmVtYWluaW5nUmVxdWVzdClcclxuXHRcdHJldHVybiBsb2FkZXJDb250ZXh0LnJlbWFpbmluZ1JlcXVlc3Q7XHJcblx0dmFyIHJlcXVlc3QgPSBsb2FkZXJDb250ZXh0LmxvYWRlcnMuc2xpY2UobG9hZGVyQ29udGV4dC5sb2FkZXJJbmRleCsxKS5tYXAoZG90UmVxdWVzdCkuY29uY2F0KFtsb2FkZXJDb250ZXh0LnJlc291cmNlXSk7XHJcblx0cmV0dXJuIHJlcXVlc3Quam9pbihcIiFcIik7XHJcbn07XHJcblxyXG5leHBvcnRzLmdldEN1cnJlbnRSZXF1ZXN0ID0gZnVuY3Rpb24obG9hZGVyQ29udGV4dCkge1xyXG5cdGlmKGxvYWRlckNvbnRleHQuY3VycmVudFJlcXVlc3QpXHJcblx0XHRyZXR1cm4gbG9hZGVyQ29udGV4dC5jdXJyZW50UmVxdWVzdDtcclxuXHR2YXIgcmVxdWVzdCA9IGxvYWRlckNvbnRleHQubG9hZGVycy5zbGljZShsb2FkZXJDb250ZXh0LmxvYWRlckluZGV4KS5tYXAoZG90UmVxdWVzdCkuY29uY2F0KFtsb2FkZXJDb250ZXh0LnJlc291cmNlXSk7XHJcblx0cmV0dXJuIHJlcXVlc3Quam9pbihcIiFcIik7XHJcbn07XHJcblxyXG5leHBvcnRzLmlzVXJsUmVxdWVzdCA9IGZ1bmN0aW9uKHVybCwgcm9vdCkge1xyXG5cdC8vIEFuIFVSTCBpcyBub3QgYW4gcmVxdWVzdCBpZlxyXG5cdC8vIDEuIGl0J3MgYSBEYXRhIFVybFxyXG5cdC8vIDIuIGl0J3MgYW4gYWJzb2x1dGUgdXJsIG9yIGFuZCBwcm90b2NvbC1yZWxhdGl2ZVxyXG5cdC8vIDMuIGl0J3Mgc29tZSBraW5kIG9mIHVybCBmb3IgYSB0ZW1wbGF0ZVxyXG5cdGlmKC9eZGF0YTp8XmNocm9tZS1leHRlbnNpb246fF4oaHR0cHM/Oik/XFwvXFwvfF5bXFx7XFx9XFxbXFxdIyo7LCfCp1xcJCUmXFwoPT9gwrRcXF7CsDw+XS8udGVzdCh1cmwpKSByZXR1cm4gZmFsc2U7XHJcblx0Ly8gNC4gSXQncyBhbHNvIG5vdCBhbiByZXF1ZXN0IGlmIHJvb3QgaXNuJ3Qgc2V0IGFuZCBpdCdzIGEgcm9vdC1yZWxhdGl2ZSB1cmxcclxuXHRpZigocm9vdCA9PT0gdW5kZWZpbmVkIHx8IHJvb3QgPT09IGZhbHNlKSAmJiAvXlxcLy8udGVzdCh1cmwpKSByZXR1cm4gZmFsc2U7XHJcblx0cmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5leHBvcnRzLnVybFRvUmVxdWVzdCA9IGZ1bmN0aW9uKHVybCwgcm9vdCkge1xyXG5cdHZhciBtb2R1bGVSZXF1ZXN0UmVnZXggPSAvXlteP10qfi87XHJcblx0dmFyIHJlcXVlc3Q7XHJcblxyXG5cdGlmKC9eW2EtekEtWl06XFxcXHxeXFxcXFxcXFwvLnRlc3QodXJsKSkge1xyXG5cdFx0Ly8gYWJzb2x1dGUgd2luZG93cyBwYXRoLCBrZWVwIGl0XHJcblx0XHRyZXF1ZXN0ID0gdXJsO1xyXG5cdH0gZWxzZSBpZihyb290ICE9PSB1bmRlZmluZWQgJiYgcm9vdCAhPT0gZmFsc2UgJiYgL15cXC8vLnRlc3QodXJsKSkge1xyXG5cdFx0Ly8gaWYgcm9vdCBpcyBzZXQgYW5kIHRoZSB1cmwgaXMgcm9vdC1yZWxhdGl2ZVxyXG5cdFx0c3dpdGNoKHR5cGVvZiByb290KSB7XHJcblx0XHRcdC8vIDEuIHJvb3QgaXMgYSBzdHJpbmc6IHJvb3QgaXMgcHJlZml4ZWQgdG8gdGhlIHVybFxyXG5cdFx0XHRjYXNlIFwic3RyaW5nXCI6XHJcblx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlOiBgfmAgcm9vdHMgY29udmVydCB0byBtb2R1bGUgcmVxdWVzdFxyXG5cdFx0XHRcdGlmIChtb2R1bGVSZXF1ZXN0UmVnZXgudGVzdChyb290KSkge1xyXG5cdFx0XHRcdFx0cmVxdWVzdCA9IHJvb3QucmVwbGFjZSgvKFteflxcL10pJC8sIFwiJDEvXCIpICsgdXJsLnNsaWNlKDEpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRyZXF1ZXN0ID0gcm9vdCArIHVybDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdC8vIDIuIHJvb3QgaXMgYHRydWVgOiBhYnNvbHV0ZSBwYXRocyBhcmUgYWxsb3dlZFxyXG5cdFx0XHQvLyAgICAqbml4IG9ubHksIHdpbmRvd3Mtc3R5bGUgYWJzb2x1dGUgcGF0aHMgYXJlIGFsd2F5cyBhbGxvd2VkIGFzIHRoZXkgZG9lc24ndCBzdGFydCB3aXRoIGEgYC9gXHJcblx0XHRcdGNhc2UgXCJib29sZWFuXCI6XHJcblx0XHRcdFx0cmVxdWVzdCA9IHVybDtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHBhcmFtZXRlcnMgdG8gbG9hZGVyLXV0aWxzICd1cmxUb1JlcXVlc3QnOiB1cmwgPSBcIiArIHVybCArIFwiLCByb290ID0gXCIgKyByb290ICsgXCIuXCIpO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZigvXlxcLlxcLj9cXC8vLnRlc3QodXJsKSkge1xyXG5cdFx0Ly8gQSByZWxhdGl2ZSB1cmwgc3RheXNcclxuXHRcdHJlcXVlc3QgPSB1cmw7XHJcblx0fSBlbHNlIHtcclxuXHRcdC8vIGV2ZXJ5IG90aGVyIHVybCBpcyB0aHJlYWRlZCBsaWtlIGEgcmVsYXRpdmUgdXJsXHJcblx0XHRyZXF1ZXN0ID0gXCIuL1wiICsgdXJsO1xyXG5cdH1cclxuXHJcblx0Ly8gQSBgfmAgbWFrZXMgdGhlIHVybCBhbiBtb2R1bGVcclxuXHRpZiAobW9kdWxlUmVxdWVzdFJlZ2V4LnRlc3QocmVxdWVzdCkpIHtcclxuXHRcdHJlcXVlc3QgPSByZXF1ZXN0LnJlcGxhY2UobW9kdWxlUmVxdWVzdFJlZ2V4LCBcIlwiKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiByZXF1ZXN0O1xyXG59O1xyXG5cclxuZXhwb3J0cy5wYXJzZVN0cmluZyA9IGZ1bmN0aW9uIHBhcnNlU3RyaW5nKHN0cikge1xyXG5cdHRyeSB7XHJcblx0XHRpZihzdHJbMF0gPT09ICdcIicpIHJldHVybiBKU09OLnBhcnNlKHN0cik7XHJcblx0XHRpZihzdHJbMF0gPT09IFwiJ1wiICYmIHN0ci5zdWJzdHIoc3RyLmxlbmd0aCAtIDEpID09PSBcIidcIikge1xyXG5cdFx0XHRyZXR1cm4gcGFyc2VTdHJpbmcoc3RyLnJlcGxhY2UoL1xcXFwufFwiL2csIGZ1bmN0aW9uKHgpIHtcclxuXHRcdFx0XHRpZih4ID09PSAnXCInKSByZXR1cm4gJ1xcXFxcIic7XHJcblx0XHRcdFx0cmV0dXJuIHg7XHJcblx0XHRcdH0pLnJlcGxhY2UoL14nfCckL2csICdcIicpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBKU09OLnBhcnNlKCdcIicgKyBzdHIgKyAnXCInKTtcclxuXHR9IGNhdGNoKGUpIHtcclxuXHRcdHJldHVybiBzdHI7XHJcblx0fVxyXG59O1xyXG5cclxuZXhwb3J0cy5nZXRIYXNoRGlnZXN0ID0gZnVuY3Rpb24gZ2V0SGFzaERpZ2VzdChidWZmZXIsIGhhc2hUeXBlLCBkaWdlc3RUeXBlLCBtYXhMZW5ndGgpIHtcclxuXHRoYXNoVHlwZSA9IGhhc2hUeXBlIHx8IFwibWQ1XCI7XHJcblx0bWF4TGVuZ3RoID0gbWF4TGVuZ3RoIHx8IDk5OTk7XHJcblx0dmFyIGhhc2ggPSByZXF1aXJlKFwiY3J5cHRvXCIpLmNyZWF0ZUhhc2goaGFzaFR5cGUpO1xyXG5cdGhhc2gudXBkYXRlKGJ1ZmZlcik7XHJcblx0aWYgKGRpZ2VzdFR5cGUgPT09IFwiYmFzZTI2XCIgfHwgZGlnZXN0VHlwZSA9PT0gXCJiYXNlMzJcIiB8fCBkaWdlc3RUeXBlID09PSBcImJhc2UzNlwiIHx8XHJcblx0ICAgIGRpZ2VzdFR5cGUgPT09IFwiYmFzZTQ5XCIgfHwgZGlnZXN0VHlwZSA9PT0gXCJiYXNlNTJcIiB8fCBkaWdlc3RUeXBlID09PSBcImJhc2U1OFwiIHx8XHJcblx0ICAgIGRpZ2VzdFR5cGUgPT09IFwiYmFzZTYyXCIgfHwgZGlnZXN0VHlwZSA9PT0gXCJiYXNlNjRcIikge1xyXG5cdFx0cmV0dXJuIGVuY29kZUJ1ZmZlclRvQmFzZShoYXNoLmRpZ2VzdCgpLCBkaWdlc3RUeXBlLnN1YnN0cig0KSkuc3Vic3RyKDAsIG1heExlbmd0aCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHJldHVybiBoYXNoLmRpZ2VzdChkaWdlc3RUeXBlIHx8IFwiaGV4XCIpLnN1YnN0cigwLCBtYXhMZW5ndGgpO1xyXG5cdH1cclxufTtcclxuXHJcbmV4cG9ydHMuaW50ZXJwb2xhdGVOYW1lID0gZnVuY3Rpb24gaW50ZXJwb2xhdGVOYW1lKGxvYWRlckNvbnRleHQsIG5hbWUsIG9wdGlvbnMpIHtcclxuXHR2YXIgZmlsZW5hbWUgPSBuYW1lIHx8IFwiW2hhc2hdLltleHRdXCI7XHJcblx0dmFyIGNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQ7XHJcblx0dmFyIGNvbnRlbnQgPSBvcHRpb25zLmNvbnRlbnQ7XHJcblx0dmFyIHJlZ0V4cCA9IG9wdGlvbnMucmVnRXhwO1xyXG5cdHZhciBleHQgPSBcImJpblwiO1xyXG5cdHZhciBiYXNlbmFtZSA9IFwiZmlsZVwiO1xyXG5cdHZhciBkaXJlY3RvcnkgPSBcIlwiO1xyXG5cdHZhciBmb2xkZXIgPSBcIlwiO1xyXG5cdGlmKGxvYWRlckNvbnRleHQucmVzb3VyY2VQYXRoKSB7XHJcblx0XHR2YXIgcmVzb3VyY2VQYXRoID0gbG9hZGVyQ29udGV4dC5yZXNvdXJjZVBhdGg7XHJcblx0XHR2YXIgaWR4ID0gcmVzb3VyY2VQYXRoLmxhc3RJbmRleE9mKFwiLlwiKTtcclxuXHRcdHZhciBpID0gcmVzb3VyY2VQYXRoLmxhc3RJbmRleE9mKFwiXFxcXFwiKTtcclxuXHRcdHZhciBqID0gcmVzb3VyY2VQYXRoLmxhc3RJbmRleE9mKFwiL1wiKTtcclxuXHRcdHZhciBwID0gaSA8IDAgPyBqIDogaiA8IDAgPyBpIDogaSA8IGogPyBpIDogajtcclxuXHRcdGlmKGlkeCA+PSAwKSB7XHJcblx0XHRcdGV4dCA9IHJlc291cmNlUGF0aC5zdWJzdHIoaWR4KzEpO1xyXG5cdFx0XHRyZXNvdXJjZVBhdGggPSByZXNvdXJjZVBhdGguc3Vic3RyKDAsIGlkeCk7XHJcblx0XHR9XHJcblx0XHRpZihwID49IDApIHtcclxuXHRcdFx0YmFzZW5hbWUgPSByZXNvdXJjZVBhdGguc3Vic3RyKHArMSk7XHJcblx0XHRcdHJlc291cmNlUGF0aCA9IHJlc291cmNlUGF0aC5zdWJzdHIoMCwgcCsxKTtcclxuXHRcdH1cclxuXHRcdGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0ZGlyZWN0b3J5ID0gcGF0aC5yZWxhdGl2ZShjb250ZXh0LCByZXNvdXJjZVBhdGggKyBcIl9cIikucmVwbGFjZSgvXFxcXC9nLCBcIi9cIikucmVwbGFjZSgvXFwuXFwuKFxcLyk/L2csIFwiXyQxXCIpO1xyXG5cdFx0XHRkaXJlY3RvcnkgPSBkaXJlY3Rvcnkuc3Vic3RyKDAsIGRpcmVjdG9yeS5sZW5ndGgtMSk7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0ZGlyZWN0b3J5ID0gcmVzb3VyY2VQYXRoLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpLnJlcGxhY2UoL1xcLlxcLihcXC8pPy9nLCBcIl8kMVwiKTtcclxuXHRcdH1cclxuXHRcdGlmIChkaXJlY3RvcnkubGVuZ3RoID09PSAxKSB7XHJcblx0XHRcdGRpcmVjdG9yeSA9IFwiXCI7XHJcblx0XHR9IGVsc2UgaWYgKGRpcmVjdG9yeS5sZW5ndGggPiAxKSB7XHJcblx0XHRcdGZvbGRlciA9IHBhdGguYmFzZW5hbWUoZGlyZWN0b3J5KTtcclxuXHRcdH1cclxuXHR9XHJcblx0dmFyIHVybCA9IGZpbGVuYW1lO1xyXG5cdGlmKGNvbnRlbnQpIHtcclxuXHRcdC8vIE1hdGNoIGhhc2ggdGVtcGxhdGVcclxuXHRcdHVybCA9IHVybC5yZXBsYWNlKC9cXFsoPzooXFx3Kyk6KT9oYXNoKD86OihbYS16XStcXGQqKSk/KD86OihcXGQrKSk/XFxdL2lnLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIGV4cG9ydHMuZ2V0SGFzaERpZ2VzdChjb250ZW50LCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgcGFyc2VJbnQoYXJndW1lbnRzWzNdLCAxMCkpO1xyXG5cdFx0fSkucmVwbGFjZSgvXFxbZW1vamkoPzo6KFxcZCspKT9cXF0vaWcsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gZW5jb2RlU3RyaW5nVG9FbW9qaShjb250ZW50LCBhcmd1bWVudHNbMV0pO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cdHVybCA9IHVybC5yZXBsYWNlKC9cXFtleHRcXF0vaWcsIGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIGV4dDtcclxuXHR9KS5yZXBsYWNlKC9cXFtuYW1lXFxdL2lnLCBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBiYXNlbmFtZTtcclxuXHR9KS5yZXBsYWNlKC9cXFtwYXRoXFxdL2lnLCBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBkaXJlY3Rvcnk7XHJcblx0fSkucmVwbGFjZSgvXFxbZm9sZGVyXFxdL2lnLCBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBmb2xkZXI7XHJcblx0fSk7XHJcblx0aWYocmVnRXhwICYmIGxvYWRlckNvbnRleHQucmVzb3VyY2VQYXRoKSB7XHJcblx0XHR2YXIgcmUgPSBuZXcgUmVnRXhwKHJlZ0V4cCk7XHJcblx0XHR2YXIgbWF0Y2ggPSBsb2FkZXJDb250ZXh0LnJlc291cmNlUGF0aC5tYXRjaChyZSk7XHJcblx0XHRpZihtYXRjaCkge1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIHJlID0gbmV3IFJlZ0V4cChcIlxcXFxbXCIgKyBpICsgXCJcXFxcXVwiLCBcImlnXCIpO1xyXG5cdFx0XHRcdHVybCA9IHVybC5yZXBsYWNlKHJlLCBtYXRjaFtpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0aWYodHlwZW9mIGxvYWRlckNvbnRleHQub3B0aW9ucyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbG9hZGVyQ29udGV4dC5vcHRpb25zLmN1c3RvbUludGVycG9sYXRlTmFtZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHR1cmwgPSBsb2FkZXJDb250ZXh0Lm9wdGlvbnMuY3VzdG9tSW50ZXJwb2xhdGVOYW1lLmNhbGwobG9hZGVyQ29udGV4dCwgdXJsLCBuYW1lLCBvcHRpb25zKTtcclxuXHR9XHJcblx0cmV0dXJuIHVybDtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2xvYWRlci11dGlscy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIGpzb241LmpzXG4vLyBNb2Rlcm4gSlNPTi4gU2VlIFJFQURNRS5tZCBmb3IgZGV0YWlscy5cbi8vXG4vLyBUaGlzIGZpbGUgaXMgYmFzZWQgZGlyZWN0bHkgb2ZmIG9mIERvdWdsYXMgQ3JvY2tmb3JkJ3MganNvbl9wYXJzZS5qczpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kb3VnbGFzY3JvY2tmb3JkL0pTT04tanMvYmxvYi9tYXN0ZXIvanNvbl9wYXJzZS5qc1xuXG52YXIgSlNPTjUgPSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHt9KTtcblxuSlNPTjUucGFyc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4vLyBUaGlzIGlzIGEgZnVuY3Rpb24gdGhhdCBjYW4gcGFyc2UgYSBKU09ONSB0ZXh0LCBwcm9kdWNpbmcgYSBKYXZhU2NyaXB0XG4vLyBkYXRhIHN0cnVjdHVyZS4gSXQgaXMgYSBzaW1wbGUsIHJlY3Vyc2l2ZSBkZXNjZW50IHBhcnNlci4gSXQgZG9lcyBub3QgdXNlXG4vLyBldmFsIG9yIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIHNvIGl0IGNhbiBiZSB1c2VkIGFzIGEgbW9kZWwgZm9yIGltcGxlbWVudGluZ1xuLy8gYSBKU09ONSBwYXJzZXIgaW4gb3RoZXIgbGFuZ3VhZ2VzLlxuXG4vLyBXZSBhcmUgZGVmaW5pbmcgdGhlIGZ1bmN0aW9uIGluc2lkZSBvZiBhbm90aGVyIGZ1bmN0aW9uIHRvIGF2b2lkIGNyZWF0aW5nXG4vLyBnbG9iYWwgdmFyaWFibGVzLlxuXG4gICAgdmFyIGF0LCAgICAgICAgICAgLy8gVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGNoYXJhY3RlclxuICAgICAgICBsaW5lTnVtYmVyLCAgIC8vIFRoZSBjdXJyZW50IGxpbmUgbnVtYmVyXG4gICAgICAgIGNvbHVtbk51bWJlciwgLy8gVGhlIGN1cnJlbnQgY29sdW1uIG51bWJlclxuICAgICAgICBjaCwgICAgICAgICAgIC8vIFRoZSBjdXJyZW50IGNoYXJhY3RlclxuICAgICAgICBlc2NhcGVlID0ge1xuICAgICAgICAgICAgXCInXCI6ICBcIidcIixcbiAgICAgICAgICAgICdcIic6ICAnXCInLFxuICAgICAgICAgICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgICAgICAgICAnLyc6ICAnLycsXG4gICAgICAgICAgICAnXFxuJzogJycsICAgICAgIC8vIFJlcGxhY2UgZXNjYXBlZCBuZXdsaW5lcyBpbiBzdHJpbmdzIHcvIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgYjogICAgJ1xcYicsXG4gICAgICAgICAgICBmOiAgICAnXFxmJyxcbiAgICAgICAgICAgIG46ICAgICdcXG4nLFxuICAgICAgICAgICAgcjogICAgJ1xccicsXG4gICAgICAgICAgICB0OiAgICAnXFx0J1xuICAgICAgICB9LFxuICAgICAgICB3cyA9IFtcbiAgICAgICAgICAgICcgJyxcbiAgICAgICAgICAgICdcXHQnLFxuICAgICAgICAgICAgJ1xccicsXG4gICAgICAgICAgICAnXFxuJyxcbiAgICAgICAgICAgICdcXHYnLFxuICAgICAgICAgICAgJ1xcZicsXG4gICAgICAgICAgICAnXFx4QTAnLFxuICAgICAgICAgICAgJ1xcdUZFRkYnXG4gICAgICAgIF0sXG4gICAgICAgIHRleHQsXG5cbiAgICAgICAgcmVuZGVyQ2hhciA9IGZ1bmN0aW9uIChjaHIpIHtcbiAgICAgICAgICAgIHJldHVybiBjaHIgPT09ICcnID8gJ0VPRicgOiBcIidcIiArIGNociArIFwiJ1wiO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVycm9yID0gZnVuY3Rpb24gKG0pIHtcblxuLy8gQ2FsbCBlcnJvciB3aGVuIHNvbWV0aGluZyBpcyB3cm9uZy5cblxuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IFN5bnRheEVycm9yKCk7XG4gICAgICAgICAgICAvLyBiZWdpbm5pbmcgb2YgbWVzc2FnZSBzdWZmaXggdG8gYWdyZWUgd2l0aCB0aGF0IHByb3ZpZGVkIGJ5IEdlY2tvIC0gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0pTT04vcGFyc2VcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBtICsgXCIgYXQgbGluZSBcIiArIGxpbmVOdW1iZXIgKyBcIiBjb2x1bW4gXCIgKyBjb2x1bW5OdW1iZXIgKyBcIiBvZiB0aGUgSlNPTjUgZGF0YS4gU3RpbGwgdG8gcmVhZDogXCIgKyBKU09OLnN0cmluZ2lmeSh0ZXh0LnN1YnN0cmluZyhhdCAtIDEsIGF0ICsgMTkpKTtcbiAgICAgICAgICAgIGVycm9yLmF0ID0gYXQ7XG4gICAgICAgICAgICAvLyBUaGVzZSB0d28gcHJvcGVydHkgbmFtZXMgaGF2ZSBiZWVuIGNob3NlbiB0byBhZ3JlZSB3aXRoIHRoZSBvbmVzIGluIEdlY2tvLCB0aGUgb25seSBwb3B1bGFyXG4gICAgICAgICAgICAvLyBlbnZpcm9ubWVudCB3aGljaCBzZWVtcyB0byBzdXBwbHkgdGhpcyBpbmZvIG9uIEpTT04ucGFyc2VcbiAgICAgICAgICAgIGVycm9yLmxpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICAgICAgZXJyb3IuY29sdW1uTnVtYmVyID0gY29sdW1uTnVtYmVyO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbmV4dCA9IGZ1bmN0aW9uIChjKSB7XG5cbi8vIElmIGEgYyBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIHZlcmlmeSB0aGF0IGl0IG1hdGNoZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyLlxuXG4gICAgICAgICAgICBpZiAoYyAmJiBjICE9PSBjaCkge1xuICAgICAgICAgICAgICAgIGVycm9yKFwiRXhwZWN0ZWQgXCIgKyByZW5kZXJDaGFyKGMpICsgXCIgaW5zdGVhZCBvZiBcIiArIHJlbmRlckNoYXIoY2gpKTtcbiAgICAgICAgICAgIH1cblxuLy8gR2V0IHRoZSBuZXh0IGNoYXJhY3Rlci4gV2hlbiB0aGVyZSBhcmUgbm8gbW9yZSBjaGFyYWN0ZXJzLFxuLy8gcmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcuXG5cbiAgICAgICAgICAgIGNoID0gdGV4dC5jaGFyQXQoYXQpO1xuICAgICAgICAgICAgYXQrKztcbiAgICAgICAgICAgIGNvbHVtbk51bWJlcisrO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXFxuJyB8fCBjaCA9PT0gJ1xccicgJiYgcGVlaygpICE9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXIrKztcbiAgICAgICAgICAgICAgICBjb2x1bW5OdW1iZXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNoO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBlZWsgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIEdldCB0aGUgbmV4dCBjaGFyYWN0ZXIgd2l0aG91dCBjb25zdW1pbmcgaXQgb3Jcbi8vIGFzc2lnbmluZyBpdCB0byB0aGUgY2ggdmFyYWlibGUuXG5cbiAgICAgICAgICAgIHJldHVybiB0ZXh0LmNoYXJBdChhdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYW4gaWRlbnRpZmllci4gTm9ybWFsbHksIHJlc2VydmVkIHdvcmRzIGFyZSBkaXNhbGxvd2VkIGhlcmUsIGJ1dCB3ZVxuLy8gb25seSB1c2UgdGhpcyBmb3IgdW5xdW90ZWQgb2JqZWN0IGtleXMsIHdoZXJlIHJlc2VydmVkIHdvcmRzIGFyZSBhbGxvd2VkLFxuLy8gc28gd2UgZG9uJ3QgY2hlY2sgZm9yIHRob3NlIGhlcmUuIFJlZmVyZW5jZXM6XG4vLyAtIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDcuNlxuLy8gLSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9Db3JlX0phdmFTY3JpcHRfMS41X0d1aWRlL0NvcmVfTGFuZ3VhZ2VfRmVhdHVyZXMjVmFyaWFibGVzXG4vLyAtIGh0dHA6Ly9kb2NzdG9yZS5taWsudWEvb3JlbGx5L3dlYnByb2cvanNjcmlwdC9jaDAyXzA3Lmh0bVxuLy8gVE9ETyBJZGVudGlmaWVycyBjYW4gaGF2ZSBVbmljb2RlIFwibGV0dGVyc1wiIGluIHRoZW07IGFkZCBzdXBwb3J0IGZvciB0aG9zZS5cblxuICAgICAgICAgICAgdmFyIGtleSA9IGNoO1xuXG4gICAgICAgICAgICAvLyBJZGVudGlmaWVycyBtdXN0IHN0YXJ0IHdpdGggYSBsZXR0ZXIsIF8gb3IgJC5cbiAgICAgICAgICAgIGlmICgoY2ggIT09ICdfJyAmJiBjaCAhPT0gJyQnKSAmJlxuICAgICAgICAgICAgICAgICAgICAoY2ggPCAnYScgfHwgY2ggPiAneicpICYmXG4gICAgICAgICAgICAgICAgICAgIChjaCA8ICdBJyB8fCBjaCA+ICdaJykpIHtcbiAgICAgICAgICAgICAgICBlcnJvcihcIkJhZCBpZGVudGlmaWVyIGFzIHVucXVvdGVkIGtleVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3Vic2VxdWVudCBjaGFyYWN0ZXJzIGNhbiBjb250YWluIGRpZ2l0cy5cbiAgICAgICAgICAgIHdoaWxlIChuZXh0KCkgJiYgKFxuICAgICAgICAgICAgICAgICAgICBjaCA9PT0gJ18nIHx8IGNoID09PSAnJCcgfHxcbiAgICAgICAgICAgICAgICAgICAgKGNoID49ICdhJyAmJiBjaCA8PSAneicpIHx8XG4gICAgICAgICAgICAgICAgICAgIChjaCA+PSAnQScgJiYgY2ggPD0gJ1onKSB8fFxuICAgICAgICAgICAgICAgICAgICAoY2ggPj0gJzAnICYmIGNoIDw9ICc5JykpKSB7XG4gICAgICAgICAgICAgICAga2V5ICs9IGNoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9LFxuXG4gICAgICAgIG51bWJlciA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYSBudW1iZXIgdmFsdWUuXG5cbiAgICAgICAgICAgIHZhciBudW1iZXIsXG4gICAgICAgICAgICAgICAgc2lnbiA9ICcnLFxuICAgICAgICAgICAgICAgIHN0cmluZyA9ICcnLFxuICAgICAgICAgICAgICAgIGJhc2UgPSAxMDtcblxuICAgICAgICAgICAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykge1xuICAgICAgICAgICAgICAgIHNpZ24gPSBjaDtcbiAgICAgICAgICAgICAgICBuZXh0KGNoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc3VwcG9ydCBmb3IgSW5maW5pdHkgKGNvdWxkIHR3ZWFrIHRvIGFsbG93IG90aGVyIHdvcmRzKTpcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ0knKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyID0gd29yZCgpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbnVtYmVyICE9PSAnbnVtYmVyJyB8fCBpc05hTihudW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKCdVbmV4cGVjdGVkIHdvcmQgZm9yIG51bWJlcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKHNpZ24gPT09ICctJykgPyAtbnVtYmVyIDogbnVtYmVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzdXBwb3J0IGZvciBOYU5cbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ04nICkge1xuICAgICAgICAgICAgICBudW1iZXIgPSB3b3JkKCk7XG4gICAgICAgICAgICAgIGlmICghaXNOYU4obnVtYmVyKSkge1xuICAgICAgICAgICAgICAgIGVycm9yKCdleHBlY3RlZCB3b3JkIHRvIGJlIE5hTicpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGlnbm9yZSBzaWduIGFzIC1OYU4gYWxzbyBpcyBOYU5cbiAgICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3gnIHx8IGNoID09PSAnWCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSAxNjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ09jdGFsIGxpdGVyYWwnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAoYmFzZSkge1xuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICB3aGlsZSAoY2ggPj0gJzAnICYmIGNoIDw9ICc5JyApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSAnLic7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0KCkgJiYgY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICB3aGlsZSAoY2ggPj0gJzAnICYmIGNoIDw9ICc5JyB8fCBjaCA+PSAnQScgJiYgY2ggPD0gJ0YnIHx8IGNoID49ICdhJyAmJiBjaCA8PSAnZicpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihzaWduID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICBudW1iZXIgPSAtc3RyaW5nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBudW1iZXIgPSArc3RyaW5nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzRmluaXRlKG51bWJlcikpIHtcbiAgICAgICAgICAgICAgICBlcnJvcihcIkJhZCBudW1iZXJcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXG4vLyBQYXJzZSBhIHN0cmluZyB2YWx1ZS5cblxuICAgICAgICAgICAgdmFyIGhleCxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIHN0cmluZyA9ICcnLFxuICAgICAgICAgICAgICAgIGRlbGltLCAgICAgIC8vIGRvdWJsZSBxdW90ZSBvciBzaW5nbGUgcXVvdGVcbiAgICAgICAgICAgICAgICB1ZmZmZjtcblxuLy8gV2hlbiBwYXJzaW5nIGZvciBzdHJpbmcgdmFsdWVzLCB3ZSBtdXN0IGxvb2sgZm9yICcgb3IgXCIgYW5kIFxcIGNoYXJhY3RlcnMuXG5cbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ1wiJyB8fCBjaCA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgICAgICBkZWxpbSA9IGNoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSBkZWxpbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd1Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVmZmZmID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhleCA9IHBhcnNlSW50KG5leHQoKSwgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKGhleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVmZmZmID0gdWZmZmYgKiAxNiArIGhleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodWZmZmYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xccicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVlaygpID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXNjYXBlZVtjaF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGVzY2FwZWVbY2hdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVuZXNjYXBlZCBuZXdsaW5lcyBhcmUgaW52YWxpZDsgc2VlOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FzZWVtay9qc29uNS9pc3N1ZXMvMjRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBmZWVscyBzcGVjaWFsLWNhc2VkOyBhcmUgdGhlcmUgb3RoZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGludmFsaWQgdW5lc2NhcGVkIGNoYXJzP1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcihcIkJhZCBzdHJpbmdcIik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5saW5lQ29tbWVudCA9IGZ1bmN0aW9uICgpIHtcblxuLy8gU2tpcCBhbiBpbmxpbmUgY29tbWVudCwgYXNzdW1pbmcgdGhpcyBpcyBvbmUuIFRoZSBjdXJyZW50IGNoYXJhY3RlciBzaG91bGRcbi8vIGJlIHRoZSBzZWNvbmQgLyBjaGFyYWN0ZXIgaW4gdGhlIC8vIHBhaXIgdGhhdCBiZWdpbnMgdGhpcyBpbmxpbmUgY29tbWVudC5cbi8vIFRvIGZpbmlzaCB0aGUgaW5saW5lIGNvbW1lbnQsIHdlIGxvb2sgZm9yIGEgbmV3bGluZSBvciB0aGUgZW5kIG9mIHRoZSB0ZXh0LlxuXG4gICAgICAgICAgICBpZiAoY2ggIT09ICcvJykge1xuICAgICAgICAgICAgICAgIGVycm9yKFwiTm90IGFuIGlubGluZSBjb21tZW50XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcbicgfHwgY2ggPT09ICdcXHInKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKGNoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBibG9ja0NvbW1lbnQgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFNraXAgYSBibG9jayBjb21tZW50LCBhc3N1bWluZyB0aGlzIGlzIG9uZS4gVGhlIGN1cnJlbnQgY2hhcmFjdGVyIHNob3VsZCBiZVxuLy8gdGhlICogY2hhcmFjdGVyIGluIHRoZSAvKiBwYWlyIHRoYXQgYmVnaW5zIHRoaXMgYmxvY2sgY29tbWVudC5cbi8vIFRvIGZpbmlzaCB0aGUgYmxvY2sgY29tbWVudCwgd2UgbG9vayBmb3IgYW4gZW5kaW5nICovIHBhaXIgb2YgY2hhcmFjdGVycyxcbi8vIGJ1dCB3ZSBhbHNvIHdhdGNoIGZvciB0aGUgZW5kIG9mIHRleHQgYmVmb3JlIHRoZSBjb21tZW50IGlzIHRlcm1pbmF0ZWQuXG5cbiAgICAgICAgICAgIGlmIChjaCAhPT0gJyonKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoXCJOb3QgYSBibG9jayBjb21tZW50XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjaCA9PT0gJyonKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJyonKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoJy8nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKGNoKTtcblxuICAgICAgICAgICAgZXJyb3IoXCJVbnRlcm1pbmF0ZWQgYmxvY2sgY29tbWVudFwiKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb21tZW50ID0gZnVuY3Rpb24gKCkge1xuXG4vLyBTa2lwIGEgY29tbWVudCwgd2hldGhlciBpbmxpbmUgb3IgYmxvY2stbGV2ZWwsIGFzc3VtaW5nIHRoaXMgaXMgb25lLlxuLy8gQ29tbWVudHMgYWx3YXlzIGJlZ2luIHdpdGggYSAvIGNoYXJhY3Rlci5cblxuICAgICAgICAgICAgaWYgKGNoICE9PSAnLycpIHtcbiAgICAgICAgICAgICAgICBlcnJvcihcIk5vdCBhIGNvbW1lbnRcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5leHQoJy8nKTtcblxuICAgICAgICAgICAgaWYgKGNoID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICBpbmxpbmVDb21tZW50KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICBibG9ja0NvbW1lbnQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoXCJVbnJlY29nbml6ZWQgY29tbWVudFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB3aGl0ZSA9IGZ1bmN0aW9uICgpIHtcblxuLy8gU2tpcCB3aGl0ZXNwYWNlIGFuZCBjb21tZW50cy5cbi8vIE5vdGUgdGhhdCB3ZSdyZSBkZXRlY3RpbmcgY29tbWVudHMgYnkgb25seSBhIHNpbmdsZSAvIGNoYXJhY3Rlci5cbi8vIFRoaXMgd29ya3Mgc2luY2UgcmVndWxhciBleHByZXNzaW9ucyBhcmUgbm90IHZhbGlkIEpTT04oNSksIGJ1dCB0aGlzIHdpbGxcbi8vIGJyZWFrIGlmIHRoZXJlIGFyZSBvdGhlciB2YWxpZCB2YWx1ZXMgdGhhdCBiZWdpbiB3aXRoIGEgLyBjaGFyYWN0ZXIhXG5cbiAgICAgICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHdzLmluZGV4T2YoY2gpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgd29yZCA9IGZ1bmN0aW9uICgpIHtcblxuLy8gdHJ1ZSwgZmFsc2UsIG9yIG51bGwuXG5cbiAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgIG5leHQoJ3QnKTtcbiAgICAgICAgICAgICAgICBuZXh0KCdyJyk7XG4gICAgICAgICAgICAgICAgbmV4dCgndScpO1xuICAgICAgICAgICAgICAgIG5leHQoJ2UnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgIG5leHQoJ2YnKTtcbiAgICAgICAgICAgICAgICBuZXh0KCdhJyk7XG4gICAgICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgICAgIG5leHQoJ3MnKTtcbiAgICAgICAgICAgICAgICBuZXh0KCdlJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgbmV4dCgnbicpO1xuICAgICAgICAgICAgICAgIG5leHQoJ3UnKTtcbiAgICAgICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY2FzZSAnSSc6XG4gICAgICAgICAgICAgICAgbmV4dCgnSScpO1xuICAgICAgICAgICAgICAgIG5leHQoJ24nKTtcbiAgICAgICAgICAgICAgICBuZXh0KCdmJyk7XG4gICAgICAgICAgICAgICAgbmV4dCgnaScpO1xuICAgICAgICAgICAgICAgIG5leHQoJ24nKTtcbiAgICAgICAgICAgICAgICBuZXh0KCdpJyk7XG4gICAgICAgICAgICAgICAgbmV4dCgndCcpO1xuICAgICAgICAgICAgICAgIG5leHQoJ3knKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgICAgICBjYXNlICdOJzpcbiAgICAgICAgICAgICAgbmV4dCggJ04nICk7XG4gICAgICAgICAgICAgIG5leHQoICdhJyApO1xuICAgICAgICAgICAgICBuZXh0KCAnTicgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yKFwiVW5leHBlY3RlZCBcIiArIHJlbmRlckNoYXIoY2gpKTtcbiAgICAgICAgfSxcblxuICAgICAgICB2YWx1ZSwgIC8vIFBsYWNlIGhvbGRlciBmb3IgdGhlIHZhbHVlIGZ1bmN0aW9uLlxuXG4gICAgICAgIGFycmF5ID0gZnVuY3Rpb24gKCkge1xuXG4vLyBQYXJzZSBhbiBhcnJheSB2YWx1ZS5cblxuICAgICAgICAgICAgdmFyIGFycmF5ID0gW107XG5cbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgnWycpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCddJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7ICAgLy8gUG90ZW50aWFsbHkgZW1wdHkgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBFUzUgYWxsb3dzIG9taXR0aW5nIGVsZW1lbnRzIGluIGFycmF5cywgZS5nLiBbLF0gYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIFssbnVsbF0uIFdlIGRvbid0IGFsbG93IHRoaXMgaW4gSlNPTjUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJywnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcihcIk1pc3NpbmcgYXJyYXkgZWxlbWVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5LnB1c2godmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBubyBjb21tYSBhZnRlciB0aGlzIHZhbHVlLCB0aGlzIG5lZWRzIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggIT09ICcsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgnXScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJywnKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcihcIkJhZCBhcnJheVwiKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvYmplY3QgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFBhcnNlIGFuIG9iamVjdCB2YWx1ZS5cblxuICAgICAgICAgICAgdmFyIGtleSxcbiAgICAgICAgICAgICAgICBvYmplY3QgPSB7fTtcblxuICAgICAgICAgICAgaWYgKGNoID09PSAneycpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCd7Jyk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoJ30nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7ICAgLy8gUG90ZW50aWFsbHkgZW1wdHkgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBLZXlzIGNhbiBiZSB1bnF1b3RlZC4gSWYgdGhleSBhcmUsIHRoZXkgbmVlZCB0byBiZVxuICAgICAgICAgICAgICAgICAgICAvLyB2YWxpZCBKUyBpZGVudGlmaWVycy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXCInIHx8IGNoID09PSBcIidcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBpZGVudGlmaWVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFtrZXldID0gdmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBubyBjb21tYSBhZnRlciB0aGlzIHBhaXIsIHRoaXMgbmVlZHMgdG8gYmVcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggIT09ICcsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgnfScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXh0KCcsJyk7XG4gICAgICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IoXCJCYWQgb2JqZWN0XCIpO1xuICAgICAgICB9O1xuXG4gICAgdmFsdWUgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFBhcnNlIGEgSlNPTiB2YWx1ZS4gSXQgY291bGQgYmUgYW4gb2JqZWN0LCBhbiBhcnJheSwgYSBzdHJpbmcsIGEgbnVtYmVyLFxuLy8gb3IgYSB3b3JkLlxuXG4gICAgICAgIHdoaXRlKCk7XG4gICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0KCk7XG4gICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgcmV0dXJuIGFycmF5KCk7XG4gICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcoKTtcbiAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIoKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknID8gbnVtYmVyKCkgOiB3b3JkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4vLyBSZXR1cm4gdGhlIGpzb25fcGFyc2UgZnVuY3Rpb24uIEl0IHdpbGwgaGF2ZSBhY2Nlc3MgdG8gYWxsIG9mIHRoZSBhYm92ZVxuLy8gZnVuY3Rpb25zIGFuZCB2YXJpYWJsZXMuXG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSwgcmV2aXZlcikge1xuICAgICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICAgIHRleHQgPSBTdHJpbmcoc291cmNlKTtcbiAgICAgICAgYXQgPSAwO1xuICAgICAgICBsaW5lTnVtYmVyID0gMTtcbiAgICAgICAgY29sdW1uTnVtYmVyID0gMTtcbiAgICAgICAgY2ggPSAnICc7XG4gICAgICAgIHJlc3VsdCA9IHZhbHVlKCk7XG4gICAgICAgIHdoaXRlKCk7XG4gICAgICAgIGlmIChjaCkge1xuICAgICAgICAgICAgZXJyb3IoXCJTeW50YXggZXJyb3JcIik7XG4gICAgICAgIH1cblxuLy8gSWYgdGhlcmUgaXMgYSByZXZpdmVyIGZ1bmN0aW9uLCB3ZSByZWN1cnNpdmVseSB3YWxrIHRoZSBuZXcgc3RydWN0dXJlLFxuLy8gcGFzc2luZyBlYWNoIG5hbWUvdmFsdWUgcGFpciB0byB0aGUgcmV2aXZlciBmdW5jdGlvbiBmb3IgcG9zc2libGVcbi8vIHRyYW5zZm9ybWF0aW9uLCBzdGFydGluZyB3aXRoIGEgdGVtcG9yYXJ5IHJvb3Qgb2JqZWN0IHRoYXQgaG9sZHMgdGhlIHJlc3VsdFxuLy8gaW4gYW4gZW1wdHkga2V5LiBJZiB0aGVyZSBpcyBub3QgYSByZXZpdmVyIGZ1bmN0aW9uLCB3ZSBzaW1wbHkgcmV0dXJuIHRoZVxuLy8gcmVzdWx0LlxuXG4gICAgICAgIHJldHVybiB0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJyA/IChmdW5jdGlvbiB3YWxrKGhvbGRlciwga2V5KSB7XG4gICAgICAgICAgICB2YXIgaywgdiwgdmFsdWUgPSBob2xkZXJba2V5XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gd2Fsayh2YWx1ZSwgayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVba10gPSB2O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV2aXZlci5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH0oeycnOiByZXN1bHR9LCAnJykpIDogcmVzdWx0O1xuICAgIH07XG59KCkpO1xuXG4vLyBKU09ONSBzdHJpbmdpZnkgd2lsbCBub3QgcXVvdGUga2V5cyB3aGVyZSBhcHByb3ByaWF0ZVxuSlNPTjUuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKG9iaiwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gICAgaWYgKHJlcGxhY2VyICYmICh0eXBlb2YocmVwbGFjZXIpICE9PSBcImZ1bmN0aW9uXCIgJiYgIWlzQXJyYXkocmVwbGFjZXIpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcGxhY2VyIG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBhcnJheScpO1xuICAgIH1cbiAgICB2YXIgZ2V0UmVwbGFjZWRWYWx1ZU9yVW5kZWZpbmVkID0gZnVuY3Rpb24oaG9sZGVyLCBrZXksIGlzVG9wTGV2ZWwpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaG9sZGVyW2tleV07XG5cbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgdmFsdWUgd2l0aCBpdHMgdG9KU09OIHZhbHVlIGZpcnN0LCBpZiBwb3NzaWJsZVxuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUudG9KU09OICYmIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSB1c2VyLXN1cHBsaWVkIHJlcGxhY2VyIGlmIGEgZnVuY3Rpb24sIGNhbGwgaXQuIElmIGl0J3MgYW4gYXJyYXksIGNoZWNrIG9iamVjdHMnIHN0cmluZyBrZXlzIGZvclxuICAgICAgICAvLyBwcmVzZW5jZSBpbiB0aGUgYXJyYXkgKHJlbW92aW5nIHRoZSBrZXkvdmFsdWUgcGFpciBmcm9tIHRoZSByZXN1bHRpbmcgSlNPTiBpZiB0aGUga2V5IGlzIG1pc3NpbmcpLlxuICAgICAgICBpZiAodHlwZW9mKHJlcGxhY2VyKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZXIuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYocmVwbGFjZXIpIHtcbiAgICAgICAgICAgIGlmIChpc1RvcExldmVsIHx8IGlzQXJyYXkoaG9sZGVyKSB8fCByZXBsYWNlci5pbmRleE9mKGtleSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpc1dvcmRDaGFyKGMpIHtcbiAgICAgICAgcmV0dXJuIChjID49ICdhJyAmJiBjIDw9ICd6JykgfHxcbiAgICAgICAgICAgIChjID49ICdBJyAmJiBjIDw9ICdaJykgfHxcbiAgICAgICAgICAgIChjID49ICcwJyAmJiBjIDw9ICc5JykgfHxcbiAgICAgICAgICAgIGMgPT09ICdfJyB8fCBjID09PSAnJCc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNXb3JkU3RhcnQoYykge1xuICAgICAgICByZXR1cm4gKGMgPj0gJ2EnICYmIGMgPD0gJ3onKSB8fFxuICAgICAgICAgICAgKGMgPj0gJ0EnICYmIGMgPD0gJ1onKSB8fFxuICAgICAgICAgICAgYyA9PT0gJ18nIHx8IGMgPT09ICckJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1dvcmQoa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNXb3JkU3RhcnQoa2V5WzBdKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpID0gMSwgbGVuZ3RoID0ga2V5Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghaXNXb3JkQ2hhcihrZXlbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGV4cG9ydCBmb3IgdXNlIGluIHRlc3RzXG4gICAgSlNPTjUuaXNXb3JkID0gaXNXb3JkO1xuXG4gICAgLy8gcG9seWZpbGxzXG4gICAgZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RhdGUob2JqKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xuICAgIH1cblxuICAgIHZhciBvYmpTdGFjayA9IFtdO1xuICAgIGZ1bmN0aW9uIGNoZWNrRm9yQ2lyY3VsYXIob2JqKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqU3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChvYmpTdGFja1tpXSA9PT0gb2JqKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNvbnZlcnRpbmcgY2lyY3VsYXIgc3RydWN0dXJlIHRvIEpTT05cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlSW5kZW50KHN0ciwgbnVtLCBub05ld0xpbmUpIHtcbiAgICAgICAgaWYgKCFzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIGluZGVudGF0aW9uIG5vIG1vcmUgdGhhbiAxMCBjaGFyc1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRlbnQgPSBub05ld0xpbmUgPyBcIlwiIDogXCJcXG5cIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgICAgICAgICAgaW5kZW50ICs9IHN0cjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmRlbnQ7XG4gICAgfVxuXG4gICAgdmFyIGluZGVudFN0cjtcbiAgICBpZiAoc3BhY2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaW5kZW50U3RyID0gc3BhY2U7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNwYWNlID09PSBcIm51bWJlclwiICYmIHNwYWNlID49IDApIHtcbiAgICAgICAgICAgIGluZGVudFN0ciA9IG1ha2VJbmRlbnQoXCIgXCIsIHNwYWNlLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBzcGFjZSBwYXJhbWV0ZXJcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvcGllZCBmcm9tIENyb2tmb3JkJ3MgaW1wbGVtZW50YXRpb24gb2YgSlNPTlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZG91Z2xhc2Nyb2NrZm9yZC9KU09OLWpzL2Jsb2IvZTM5ZGI0YjdlNjI0OWYwNGExOTVlN2RkMDg0MGU2MTBjYzllOTQxZS9qc29uMi5qcyNMMTk1XG4gICAgLy8gQmVnaW5cbiAgICB2YXIgY3ggPSAvW1xcdTAwMDBcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICAgICAgZXNjYXBhYmxlID0gL1tcXFxcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx4OWZcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICAgICAgbWV0YSA9IHsgLy8gdGFibGUgb2YgY2hhcmFjdGVyIHN1YnN0aXR1dGlvbnNcbiAgICAgICAgJ1xcYic6ICdcXFxcYicsXG4gICAgICAgICdcXHQnOiAnXFxcXHQnLFxuICAgICAgICAnXFxuJzogJ1xcXFxuJyxcbiAgICAgICAgJ1xcZic6ICdcXFxcZicsXG4gICAgICAgICdcXHInOiAnXFxcXHInLFxuICAgICAgICAnXCInIDogJ1xcXFxcIicsXG4gICAgICAgICdcXFxcJzogJ1xcXFxcXFxcJ1xuICAgIH07XG4gICAgZnVuY3Rpb24gZXNjYXBlU3RyaW5nKHN0cmluZykge1xuXG4vLyBJZiB0aGUgc3RyaW5nIGNvbnRhaW5zIG5vIGNvbnRyb2wgY2hhcmFjdGVycywgbm8gcXVvdGUgY2hhcmFjdGVycywgYW5kIG5vXG4vLyBiYWNrc2xhc2ggY2hhcmFjdGVycywgdGhlbiB3ZSBjYW4gc2FmZWx5IHNsYXAgc29tZSBxdW90ZXMgYXJvdW5kIGl0LlxuLy8gT3RoZXJ3aXNlIHdlIG11c3QgYWxzbyByZXBsYWNlIHRoZSBvZmZlbmRpbmcgY2hhcmFjdGVycyB3aXRoIHNhZmUgZXNjYXBlXG4vLyBzZXF1ZW5jZXMuXG4gICAgICAgIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICByZXR1cm4gZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKSA/ICdcIicgKyBzdHJpbmcucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICB2YXIgYyA9IG1ldGFbYV07XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGMgPT09ICdzdHJpbmcnID9cbiAgICAgICAgICAgICAgICBjIDpcbiAgICAgICAgICAgICAgICAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICAgICAgfSkgKyAnXCInIDogJ1wiJyArIHN0cmluZyArICdcIic7XG4gICAgfVxuICAgIC8vIEVuZFxuXG4gICAgZnVuY3Rpb24gaW50ZXJuYWxTdHJpbmdpZnkoaG9sZGVyLCBrZXksIGlzVG9wTGV2ZWwpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciwgcmVzO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIHZhbHVlLCBpZiBuZWNlc3NhcnlcbiAgICAgICAgdmFyIG9ial9wYXJ0ID0gZ2V0UmVwbGFjZWRWYWx1ZU9yVW5kZWZpbmVkKGhvbGRlciwga2V5LCBpc1RvcExldmVsKTtcblxuICAgICAgICBpZiAob2JqX3BhcnQgJiYgIWlzRGF0ZShvYmpfcGFydCkpIHtcbiAgICAgICAgICAgIC8vIHVuYm94IG9iamVjdHNcbiAgICAgICAgICAgIC8vIGRvbid0IHVuYm94IGRhdGVzLCBzaW5jZSB3aWxsIHR1cm4gaXQgaW50byBudW1iZXJcbiAgICAgICAgICAgIG9ial9wYXJ0ID0gb2JqX3BhcnQudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCh0eXBlb2Ygb2JqX3BhcnQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ial9wYXJ0LnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4ob2JqX3BhcnQpIHx8ICFpc0Zpbml0ZShvYmpfcGFydCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqX3BhcnQudG9TdHJpbmcoKTtcblxuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBlc2NhcGVTdHJpbmcob2JqX3BhcnQudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgICAgICBpZiAob2JqX3BhcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpfcGFydCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tGb3JDaXJjdWxhcihvYmpfcGFydCk7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IFwiW1wiO1xuICAgICAgICAgICAgICAgICAgICBvYmpTdGFjay5wdXNoKG9ial9wYXJ0KTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9ial9wYXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBpbnRlcm5hbFN0cmluZ2lmeShvYmpfcGFydCwgaSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyICs9IG1ha2VJbmRlbnQoaW5kZW50U3RyLCBvYmpTdGFjay5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcyA9PT0gbnVsbCB8fCB0eXBlb2YgcmVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyICs9IFwibnVsbFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgKz0gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBvYmpfcGFydC5sZW5ndGgtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciArPSBcIixcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZW50U3RyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyICs9IFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb2JqU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmpfcGFydC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciArPSBtYWtlSW5kZW50KGluZGVudFN0ciwgb2JqU3RhY2subGVuZ3RoLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciArPSBcIl1cIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGVja0ZvckNpcmN1bGFyKG9ial9wYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gXCJ7XCI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub25FbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBvYmpTdGFjay5wdXNoKG9ial9wYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBvYmpfcGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9ial9wYXJ0Lmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gaW50ZXJuYWxTdHJpbmdpZnkob2JqX3BhcnQsIHByb3AsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1RvcExldmVsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgKz0gbWFrZUluZGVudChpbmRlbnRTdHIsIG9ialN0YWNrLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vbkVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gaXNXb3JkKHByb3ApID8gcHJvcCA6IGVzY2FwZVN0cmluZyhwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyICs9IGtleSArIFwiOlwiICsgKGluZGVudFN0ciA/ICcgJyA6ICcnKSArIHZhbHVlICsgXCIsXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9ialN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9uRW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zdWJzdHJpbmcoMCwgYnVmZmVyLmxlbmd0aC0xKSArIG1ha2VJbmRlbnQoaW5kZW50U3RyLCBvYmpTdGFjay5sZW5ndGgpICsgXCJ9XCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSAne30nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9ucyBhbmQgdW5kZWZpbmVkIHNob3VsZCBiZSBpZ25vcmVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNwZWNpYWwgY2FzZS4uLndoZW4gdW5kZWZpbmVkIGlzIHVzZWQgaW5zaWRlIG9mXG4gICAgLy8gYSBjb21wb3VuZCBvYmplY3QvYXJyYXksIHJldHVybiBudWxsLlxuICAgIC8vIGJ1dCB3aGVuIHRvcC1sZXZlbCwgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHZhciB0b3BMZXZlbEhvbGRlciA9IHtcIlwiOm9ian07XG4gICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBnZXRSZXBsYWNlZFZhbHVlT3JVbmRlZmluZWQodG9wTGV2ZWxIb2xkZXIsICcnLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGludGVybmFsU3RyaW5naWZ5KHRvcExldmVsSG9sZGVyLCAnJywgdHJ1ZSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2pzb241L2xpYi9qc29uNS5qc1xuLy8gbW9kdWxlIGlkID0gMzY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vb2JqZWN0LWFzc2lnbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gW1xuICBcIvCfgIRcIixcbiAgXCLwn4OPXCIsXG4gIFwi8J+FsFwiLFxuICBcIvCfhbFcIixcbiAgXCLwn4W+XCIsXG4gIFwi8J+Fv1wiLFxuICBcIvCfho5cIixcbiAgXCLwn4aRXCIsXG4gIFwi8J+GklwiLFxuICBcIvCfhpNcIixcbiAgXCLwn4aUXCIsXG4gIFwi8J+GlVwiLFxuICBcIvCfhpZcIixcbiAgXCLwn4aXXCIsXG4gIFwi8J+GmFwiLFxuICBcIvCfhplcIixcbiAgXCLwn4aaXCIsXG4gIFwi8J+HpvCfh6hcIixcbiAgXCLwn4em8J+HqVwiLFxuICBcIvCfh6bwn4eqXCIsXG4gIFwi8J+HpvCfh6tcIixcbiAgXCLwn4em8J+HrFwiLFxuICBcIvCfh6bwn4euXCIsXG4gIFwi8J+HpvCfh7FcIixcbiAgXCLwn4em8J+HslwiLFxuICBcIvCfh6bwn4e0XCIsXG4gIFwi8J+HpvCfh7ZcIixcbiAgXCLwn4em8J+Ht1wiLFxuICBcIvCfh6bwn4e4XCIsXG4gIFwi8J+HpvCfh7lcIixcbiAgXCLwn4em8J+HulwiLFxuICBcIvCfh6bwn4e8XCIsXG4gIFwi8J+HpvCfh71cIixcbiAgXCLwn4em8J+Hv1wiLFxuICBcIvCfh6ZcIixcbiAgXCLwn4en8J+HplwiLFxuICBcIvCfh6fwn4enXCIsXG4gIFwi8J+Hp/Cfh6lcIixcbiAgXCLwn4en8J+HqlwiLFxuICBcIvCfh6fwn4erXCIsXG4gIFwi8J+Hp/Cfh6xcIixcbiAgXCLwn4en8J+HrVwiLFxuICBcIvCfh6fwn4euXCIsXG4gIFwi8J+Hp/Cfh69cIixcbiAgXCLwn4en8J+HsVwiLFxuICBcIvCfh6fwn4eyXCIsXG4gIFwi8J+Hp/Cfh7NcIixcbiAgXCLwn4en8J+HtFwiLFxuICBcIvCfh6fwn4e2XCIsXG4gIFwi8J+Hp/Cfh7dcIixcbiAgXCLwn4en8J+HuFwiLFxuICBcIvCfh6fwn4e5XCIsXG4gIFwi8J+Hp/Cfh7tcIixcbiAgXCLwn4en8J+HvFwiLFxuICBcIvCfh6fwn4e+XCIsXG4gIFwi8J+Hp/Cfh79cIixcbiAgXCLwn4enXCIsXG4gIFwi8J+HqPCfh6ZcIixcbiAgXCLwn4eo8J+HqFwiLFxuICBcIvCfh6jwn4epXCIsXG4gIFwi8J+HqPCfh6tcIixcbiAgXCLwn4eo8J+HrFwiLFxuICBcIvCfh6jwn4etXCIsXG4gIFwi8J+HqPCfh65cIixcbiAgXCLwn4eo8J+HsFwiLFxuICBcIvCfh6jwn4exXCIsXG4gIFwi8J+HqPCfh7JcIixcbiAgXCLwn4eo8J+Hs1wiLFxuICBcIvCfh6jwn4e0XCIsXG4gIFwi8J+HqPCfh7VcIixcbiAgXCLwn4eo8J+Ht1wiLFxuICBcIvCfh6jwn4e6XCIsXG4gIFwi8J+HqPCfh7tcIixcbiAgXCLwn4eo8J+HvFwiLFxuICBcIvCfh6jwn4e9XCIsXG4gIFwi8J+HqPCfh75cIixcbiAgXCLwn4eo8J+Hv1wiLFxuICBcIvCfh6hcIixcbiAgXCLwn4ep8J+HqlwiLFxuICBcIvCfh6nwn4esXCIsXG4gIFwi8J+HqfCfh69cIixcbiAgXCLwn4ep8J+HsFwiLFxuICBcIvCfh6nwn4eyXCIsXG4gIFwi8J+HqfCfh7RcIixcbiAgXCLwn4ep8J+Hv1wiLFxuICBcIvCfh6lcIixcbiAgXCLwn4eq8J+HplwiLFxuICBcIvCfh6rwn4eoXCIsXG4gIFwi8J+HqvCfh6pcIixcbiAgXCLwn4eq8J+HrFwiLFxuICBcIvCfh6rwn4etXCIsXG4gIFwi8J+HqvCfh7dcIixcbiAgXCLwn4eq8J+HuFwiLFxuICBcIvCfh6rwn4e5XCIsXG4gIFwi8J+HqvCfh7pcIixcbiAgXCLwn4eqXCIsXG4gIFwi8J+Hq/Cfh65cIixcbiAgXCLwn4er8J+Hr1wiLFxuICBcIvCfh6vwn4ewXCIsXG4gIFwi8J+Hq/Cfh7JcIixcbiAgXCLwn4er8J+HtFwiLFxuICBcIvCfh6vwn4e3XCIsXG4gIFwi8J+Hq1wiLFxuICBcIvCfh6zwn4emXCIsXG4gIFwi8J+HrPCfh6dcIixcbiAgXCLwn4es8J+HqVwiLFxuICBcIvCfh6zwn4eqXCIsXG4gIFwi8J+HrPCfh6tcIixcbiAgXCLwn4es8J+HrFwiLFxuICBcIvCfh6zwn4etXCIsXG4gIFwi8J+HrPCfh65cIixcbiAgXCLwn4es8J+HsVwiLFxuICBcIvCfh6zwn4eyXCIsXG4gIFwi8J+HrPCfh7NcIixcbiAgXCLwn4es8J+HtVwiLFxuICBcIvCfh6zwn4e2XCIsXG4gIFwi8J+HrPCfh7dcIixcbiAgXCLwn4es8J+HuFwiLFxuICBcIvCfh6zwn4e5XCIsXG4gIFwi8J+HrPCfh7pcIixcbiAgXCLwn4es8J+HvFwiLFxuICBcIvCfh6zwn4e+XCIsXG4gIFwi8J+HrFwiLFxuICBcIvCfh63wn4ewXCIsXG4gIFwi8J+HrfCfh7JcIixcbiAgXCLwn4et8J+Hs1wiLFxuICBcIvCfh63wn4e3XCIsXG4gIFwi8J+HrfCfh7lcIixcbiAgXCLwn4et8J+HulwiLFxuICBcIvCfh61cIixcbiAgXCLwn4eu8J+HqFwiLFxuICBcIvCfh67wn4epXCIsXG4gIFwi8J+HrvCfh6pcIixcbiAgXCLwn4eu8J+HsVwiLFxuICBcIvCfh67wn4eyXCIsXG4gIFwi8J+HrvCfh7NcIixcbiAgXCLwn4eu8J+HtFwiLFxuICBcIvCfh67wn4e2XCIsXG4gIFwi8J+HrvCfh7dcIixcbiAgXCLwn4eu8J+HuFwiLFxuICBcIvCfh67wn4e5XCIsXG4gIFwi8J+HrlwiLFxuICBcIvCfh6/wn4eqXCIsXG4gIFwi8J+Hr/Cfh7JcIixcbiAgXCLwn4ev8J+HtFwiLFxuICBcIvCfh6/wn4e1XCIsXG4gIFwi8J+Hr1wiLFxuICBcIvCfh7Dwn4eqXCIsXG4gIFwi8J+HsPCfh6xcIixcbiAgXCLwn4ew8J+HrVwiLFxuICBcIvCfh7Dwn4euXCIsXG4gIFwi8J+HsPCfh7JcIixcbiAgXCLwn4ew8J+Hs1wiLFxuICBcIvCfh7Dwn4e1XCIsXG4gIFwi8J+HsPCfh7dcIixcbiAgXCLwn4ew8J+HvFwiLFxuICBcIvCfh7Dwn4e+XCIsXG4gIFwi8J+HsPCfh79cIixcbiAgXCLwn4ewXCIsXG4gIFwi8J+HsfCfh6ZcIixcbiAgXCLwn4ex8J+Hp1wiLFxuICBcIvCfh7Hwn4eoXCIsXG4gIFwi8J+HsfCfh65cIixcbiAgXCLwn4ex8J+HsFwiLFxuICBcIvCfh7Hwn4e3XCIsXG4gIFwi8J+HsfCfh7hcIixcbiAgXCLwn4ex8J+HuVwiLFxuICBcIvCfh7Hwn4e6XCIsXG4gIFwi8J+HsfCfh7tcIixcbiAgXCLwn4ex8J+HvlwiLFxuICBcIvCfh7FcIixcbiAgXCLwn4ey8J+HplwiLFxuICBcIvCfh7Lwn4eoXCIsXG4gIFwi8J+HsvCfh6lcIixcbiAgXCLwn4ey8J+HqlwiLFxuICBcIvCfh7Lwn4erXCIsXG4gIFwi8J+HsvCfh6xcIixcbiAgXCLwn4ey8J+HrVwiLFxuICBcIvCfh7Lwn4ewXCIsXG4gIFwi8J+HsvCfh7FcIixcbiAgXCLwn4ey8J+HslwiLFxuICBcIvCfh7Lwn4ezXCIsXG4gIFwi8J+HsvCfh7RcIixcbiAgXCLwn4ey8J+HtVwiLFxuICBcIvCfh7Lwn4e2XCIsXG4gIFwi8J+HsvCfh7dcIixcbiAgXCLwn4ey8J+HuFwiLFxuICBcIvCfh7Lwn4e5XCIsXG4gIFwi8J+HsvCfh7pcIixcbiAgXCLwn4ey8J+Hu1wiLFxuICBcIvCfh7Lwn4e8XCIsXG4gIFwi8J+HsvCfh71cIixcbiAgXCLwn4ey8J+HvlwiLFxuICBcIvCfh7Lwn4e/XCIsXG4gIFwi8J+HslwiLFxuICBcIvCfh7Pwn4emXCIsXG4gIFwi8J+Hs/Cfh6hcIixcbiAgXCLwn4ez8J+HqlwiLFxuICBcIvCfh7Pwn4erXCIsXG4gIFwi8J+Hs/Cfh6xcIixcbiAgXCLwn4ez8J+HrlwiLFxuICBcIvCfh7Pwn4exXCIsXG4gIFwi8J+Hs/Cfh7RcIixcbiAgXCLwn4ez8J+HtVwiLFxuICBcIvCfh7Pwn4e3XCIsXG4gIFwi8J+Hs/Cfh7pcIixcbiAgXCLwn4ez8J+Hv1wiLFxuICBcIvCfh7NcIixcbiAgXCLwn4e08J+HslwiLFxuICBcIvCfh7RcIixcbiAgXCLwn4e18J+HplwiLFxuICBcIvCfh7Xwn4eqXCIsXG4gIFwi8J+HtfCfh6tcIixcbiAgXCLwn4e18J+HrFwiLFxuICBcIvCfh7Xwn4etXCIsXG4gIFwi8J+HtfCfh7BcIixcbiAgXCLwn4e18J+HsVwiLFxuICBcIvCfh7Xwn4eyXCIsXG4gIFwi8J+HtfCfh7NcIixcbiAgXCLwn4e18J+Ht1wiLFxuICBcIvCfh7Xwn4e4XCIsXG4gIFwi8J+HtfCfh7lcIixcbiAgXCLwn4e18J+HvFwiLFxuICBcIvCfh7Xwn4e+XCIsXG4gIFwi8J+HtVwiLFxuICBcIvCfh7bwn4emXCIsXG4gIFwi8J+HtlwiLFxuICBcIvCfh7fwn4eqXCIsXG4gIFwi8J+Ht/Cfh7RcIixcbiAgXCLwn4e38J+HuFwiLFxuICBcIvCfh7fwn4e6XCIsXG4gIFwi8J+Ht/Cfh7xcIixcbiAgXCLwn4e3XCIsXG4gIFwi8J+HuPCfh6ZcIixcbiAgXCLwn4e48J+Hp1wiLFxuICBcIvCfh7jwn4eoXCIsXG4gIFwi8J+HuPCfh6lcIixcbiAgXCLwn4e48J+HqlwiLFxuICBcIvCfh7jwn4esXCIsXG4gIFwi8J+HuPCfh61cIixcbiAgXCLwn4e48J+HrlwiLFxuICBcIvCfh7jwn4evXCIsXG4gIFwi8J+HuPCfh7BcIixcbiAgXCLwn4e48J+HsVwiLFxuICBcIvCfh7jwn4eyXCIsXG4gIFwi8J+HuPCfh7NcIixcbiAgXCLwn4e48J+HtFwiLFxuICBcIvCfh7jwn4e3XCIsXG4gIFwi8J+HuPCfh7hcIixcbiAgXCLwn4e48J+HuVwiLFxuICBcIvCfh7jwn4e7XCIsXG4gIFwi8J+HuPCfh71cIixcbiAgXCLwn4e48J+HvlwiLFxuICBcIvCfh7jwn4e/XCIsXG4gIFwi8J+HuFwiLFxuICBcIvCfh7nwn4emXCIsXG4gIFwi8J+HufCfh6hcIixcbiAgXCLwn4e58J+HqVwiLFxuICBcIvCfh7nwn4erXCIsXG4gIFwi8J+HufCfh6xcIixcbiAgXCLwn4e58J+HrVwiLFxuICBcIvCfh7nwn4evXCIsXG4gIFwi8J+HufCfh7BcIixcbiAgXCLwn4e58J+HsVwiLFxuICBcIvCfh7nwn4eyXCIsXG4gIFwi8J+HufCfh7NcIixcbiAgXCLwn4e58J+HtFwiLFxuICBcIvCfh7nwn4e3XCIsXG4gIFwi8J+HufCfh7lcIixcbiAgXCLwn4e58J+Hu1wiLFxuICBcIvCfh7nwn4e8XCIsXG4gIFwi8J+HufCfh79cIixcbiAgXCLwn4e5XCIsXG4gIFwi8J+HuvCfh6ZcIixcbiAgXCLwn4e68J+HrFwiLFxuICBcIvCfh7rwn4eyXCIsXG4gIFwi8J+HuvCfh7NcIixcbiAgXCLwn4e68J+HuFwiLFxuICBcIvCfh7rwn4e+XCIsXG4gIFwi8J+HuvCfh79cIixcbiAgXCLwn4e6XCIsXG4gIFwi8J+Hu/Cfh6ZcIixcbiAgXCLwn4e78J+HqFwiLFxuICBcIvCfh7vwn4eqXCIsXG4gIFwi8J+Hu/Cfh6xcIixcbiAgXCLwn4e78J+HrlwiLFxuICBcIvCfh7vwn4ezXCIsXG4gIFwi8J+Hu/Cfh7pcIixcbiAgXCLwn4e7XCIsXG4gIFwi8J+HvPCfh6tcIixcbiAgXCLwn4e88J+HuFwiLFxuICBcIvCfh7xcIixcbiAgXCLwn4e98J+HsFwiLFxuICBcIvCfh71cIixcbiAgXCLwn4e+8J+HqlwiLFxuICBcIvCfh77wn4e5XCIsXG4gIFwi8J+HvlwiLFxuICBcIvCfh7/wn4emXCIsXG4gIFwi8J+Hv/Cfh7JcIixcbiAgXCLwn4e/8J+HvFwiLFxuICBcIvCfh79cIixcbiAgXCLwn4iBXCIsXG4gIFwi8J+IglwiLFxuICBcIvCfiJpcIixcbiAgXCLwn4ivXCIsXG4gIFwi8J+IslwiLFxuICBcIvCfiLNcIixcbiAgXCLwn4i0XCIsXG4gIFwi8J+ItVwiLFxuICBcIvCfiLZcIixcbiAgXCLwn4i3XCIsXG4gIFwi8J+IuFwiLFxuICBcIvCfiLlcIixcbiAgXCLwn4i6XCIsXG4gIFwi8J+JkFwiLFxuICBcIvCfiZFcIixcbiAgXCLwn4yAXCIsXG4gIFwi8J+MgVwiLFxuICBcIvCfjIJcIixcbiAgXCLwn4yDXCIsXG4gIFwi8J+MhFwiLFxuICBcIvCfjIVcIixcbiAgXCLwn4yGXCIsXG4gIFwi8J+Mh1wiLFxuICBcIvCfjIhcIixcbiAgXCLwn4yJXCIsXG4gIFwi8J+MilwiLFxuICBcIvCfjItcIixcbiAgXCLwn4yMXCIsXG4gIFwi8J+MjVwiLFxuICBcIvCfjI5cIixcbiAgXCLwn4yPXCIsXG4gIFwi8J+MkFwiLFxuICBcIvCfjJFcIixcbiAgXCLwn4ySXCIsXG4gIFwi8J+Mk1wiLFxuICBcIvCfjJRcIixcbiAgXCLwn4yVXCIsXG4gIFwi8J+MllwiLFxuICBcIvCfjJdcIixcbiAgXCLwn4yYXCIsXG4gIFwi8J+MmVwiLFxuICBcIvCfjJpcIixcbiAgXCLwn4ybXCIsXG4gIFwi8J+MnFwiLFxuICBcIvCfjJ1cIixcbiAgXCLwn4yeXCIsXG4gIFwi8J+Mn1wiLFxuICBcIvCfjKBcIixcbiAgXCLwn4yhXCIsXG4gIFwi8J+MpFwiLFxuICBcIvCfjKVcIixcbiAgXCLwn4ymXCIsXG4gIFwi8J+Mp1wiLFxuICBcIvCfjKhcIixcbiAgXCLwn4ypXCIsXG4gIFwi8J+MqlwiLFxuICBcIvCfjKtcIixcbiAgXCLwn4ysXCIsXG4gIFwi8J+MrVwiLFxuICBcIvCfjK5cIixcbiAgXCLwn4yvXCIsXG4gIFwi8J+MsFwiLFxuICBcIvCfjLFcIixcbiAgXCLwn4yyXCIsXG4gIFwi8J+Ms1wiLFxuICBcIvCfjLRcIixcbiAgXCLwn4y1XCIsXG4gIFwi8J+MtlwiLFxuICBcIvCfjLdcIixcbiAgXCLwn4y4XCIsXG4gIFwi8J+MuVwiLFxuICBcIvCfjLpcIixcbiAgXCLwn4y7XCIsXG4gIFwi8J+MvFwiLFxuICBcIvCfjL1cIixcbiAgXCLwn4y+XCIsXG4gIFwi8J+Mv1wiLFxuICBcIvCfjYBcIixcbiAgXCLwn42BXCIsXG4gIFwi8J+NglwiLFxuICBcIvCfjYNcIixcbiAgXCLwn42EXCIsXG4gIFwi8J+NhVwiLFxuICBcIvCfjYZcIixcbiAgXCLwn42HXCIsXG4gIFwi8J+NiFwiLFxuICBcIvCfjYlcIixcbiAgXCLwn42KXCIsXG4gIFwi8J+Ni1wiLFxuICBcIvCfjYxcIixcbiAgXCLwn42NXCIsXG4gIFwi8J+NjlwiLFxuICBcIvCfjY9cIixcbiAgXCLwn42QXCIsXG4gIFwi8J+NkVwiLFxuICBcIvCfjZJcIixcbiAgXCLwn42TXCIsXG4gIFwi8J+NlFwiLFxuICBcIvCfjZVcIixcbiAgXCLwn42WXCIsXG4gIFwi8J+Nl1wiLFxuICBcIvCfjZhcIixcbiAgXCLwn42ZXCIsXG4gIFwi8J+NmlwiLFxuICBcIvCfjZtcIixcbiAgXCLwn42cXCIsXG4gIFwi8J+NnVwiLFxuICBcIvCfjZ5cIixcbiAgXCLwn42fXCIsXG4gIFwi8J+NoFwiLFxuICBcIvCfjaFcIixcbiAgXCLwn42iXCIsXG4gIFwi8J+No1wiLFxuICBcIvCfjaRcIixcbiAgXCLwn42lXCIsXG4gIFwi8J+NplwiLFxuICBcIvCfjadcIixcbiAgXCLwn42oXCIsXG4gIFwi8J+NqVwiLFxuICBcIvCfjapcIixcbiAgXCLwn42rXCIsXG4gIFwi8J+NrFwiLFxuICBcIvCfja1cIixcbiAgXCLwn42uXCIsXG4gIFwi8J+Nr1wiLFxuICBcIvCfjbBcIixcbiAgXCLwn42xXCIsXG4gIFwi8J+NslwiLFxuICBcIvCfjbNcIixcbiAgXCLwn420XCIsXG4gIFwi8J+NtVwiLFxuICBcIvCfjbZcIixcbiAgXCLwn423XCIsXG4gIFwi8J+NuFwiLFxuICBcIvCfjblcIixcbiAgXCLwn426XCIsXG4gIFwi8J+Nu1wiLFxuICBcIvCfjbxcIixcbiAgXCLwn429XCIsXG4gIFwi8J+NvlwiLFxuICBcIvCfjb9cIixcbiAgXCLwn46AXCIsXG4gIFwi8J+OgVwiLFxuICBcIvCfjoJcIixcbiAgXCLwn46DXCIsXG4gIFwi8J+OhFwiLFxuICBcIvCfjoXwn4+7XCIsXG4gIFwi8J+OhfCfj7xcIixcbiAgXCLwn46F8J+PvVwiLFxuICBcIvCfjoXwn4++XCIsXG4gIFwi8J+OhfCfj79cIixcbiAgXCLwn46FXCIsXG4gIFwi8J+OhlwiLFxuICBcIvCfjodcIixcbiAgXCLwn46IXCIsXG4gIFwi8J+OiVwiLFxuICBcIvCfjopcIixcbiAgXCLwn46LXCIsXG4gIFwi8J+OjFwiLFxuICBcIvCfjo1cIixcbiAgXCLwn46OXCIsXG4gIFwi8J+Oj1wiLFxuICBcIvCfjpBcIixcbiAgXCLwn46RXCIsXG4gIFwi8J+OklwiLFxuICBcIvCfjpNcIixcbiAgXCLwn46WXCIsXG4gIFwi8J+Ol1wiLFxuICBcIvCfjplcIixcbiAgXCLwn46aXCIsXG4gIFwi8J+Om1wiLFxuICBcIvCfjp5cIixcbiAgXCLwn46fXCIsXG4gIFwi8J+OoFwiLFxuICBcIvCfjqFcIixcbiAgXCLwn46iXCIsXG4gIFwi8J+Oo1wiLFxuICBcIvCfjqRcIixcbiAgXCLwn46lXCIsXG4gIFwi8J+OplwiLFxuICBcIvCfjqdcIixcbiAgXCLwn46oXCIsXG4gIFwi8J+OqVwiLFxuICBcIvCfjqpcIixcbiAgXCLwn46rXCIsXG4gIFwi8J+OrFwiLFxuICBcIvCfjq1cIixcbiAgXCLwn46uXCIsXG4gIFwi8J+Or1wiLFxuICBcIvCfjrBcIixcbiAgXCLwn46xXCIsXG4gIFwi8J+OslwiLFxuICBcIvCfjrNcIixcbiAgXCLwn460XCIsXG4gIFwi8J+OtVwiLFxuICBcIvCfjrZcIixcbiAgXCLwn463XCIsXG4gIFwi8J+OuFwiLFxuICBcIvCfjrlcIixcbiAgXCLwn466XCIsXG4gIFwi8J+Ou1wiLFxuICBcIvCfjrxcIixcbiAgXCLwn469XCIsXG4gIFwi8J+OvlwiLFxuICBcIvCfjr9cIixcbiAgXCLwn4+AXCIsXG4gIFwi8J+PgVwiLFxuICBcIvCfj4Lwn4+7XCIsXG4gIFwi8J+PgvCfj7xcIixcbiAgXCLwn4+C8J+PvVwiLFxuICBcIvCfj4Lwn4++XCIsXG4gIFwi8J+PgvCfj79cIixcbiAgXCLwn4+CXCIsXG4gIFwi8J+Pg/Cfj7vigI3imYDvuI9cIixcbiAgXCLwn4+D8J+Pu+KAjeKZgu+4j1wiLFxuICBcIvCfj4Pwn4+7XCIsXG4gIFwi8J+Pg/Cfj7zigI3imYDvuI9cIixcbiAgXCLwn4+D8J+PvOKAjeKZgu+4j1wiLFxuICBcIvCfj4Pwn4+8XCIsXG4gIFwi8J+Pg/Cfj73igI3imYDvuI9cIixcbiAgXCLwn4+D8J+PveKAjeKZgu+4j1wiLFxuICBcIvCfj4Pwn4+9XCIsXG4gIFwi8J+Pg/Cfj77igI3imYDvuI9cIixcbiAgXCLwn4+D8J+PvuKAjeKZgu+4j1wiLFxuICBcIvCfj4Pwn4++XCIsXG4gIFwi8J+Pg/Cfj7/igI3imYDvuI9cIixcbiAgXCLwn4+D8J+Pv+KAjeKZgu+4j1wiLFxuICBcIvCfj4Pwn4+/XCIsXG4gIFwi8J+Pg+KAjeKZgO+4j1wiLFxuICBcIvCfj4PigI3imYLvuI9cIixcbiAgXCLwn4+DXCIsXG4gIFwi8J+PhPCfj7vigI3imYDvuI9cIixcbiAgXCLwn4+E8J+Pu+KAjeKZgu+4j1wiLFxuICBcIvCfj4Twn4+7XCIsXG4gIFwi8J+PhPCfj7zigI3imYDvuI9cIixcbiAgXCLwn4+E8J+PvOKAjeKZgu+4j1wiLFxuICBcIvCfj4Twn4+8XCIsXG4gIFwi8J+PhPCfj73igI3imYDvuI9cIixcbiAgXCLwn4+E8J+PveKAjeKZgu+4j1wiLFxuICBcIvCfj4Twn4+9XCIsXG4gIFwi8J+PhPCfj77igI3imYDvuI9cIixcbiAgXCLwn4+E8J+PvuKAjeKZgu+4j1wiLFxuICBcIvCfj4Twn4++XCIsXG4gIFwi8J+PhPCfj7/igI3imYDvuI9cIixcbiAgXCLwn4+E8J+Pv+KAjeKZgu+4j1wiLFxuICBcIvCfj4Twn4+/XCIsXG4gIFwi8J+PhOKAjeKZgO+4j1wiLFxuICBcIvCfj4TigI3imYLvuI9cIixcbiAgXCLwn4+EXCIsXG4gIFwi8J+PhVwiLFxuICBcIvCfj4ZcIixcbiAgXCLwn4+H8J+Pu1wiLFxuICBcIvCfj4fwn4+8XCIsXG4gIFwi8J+Ph/Cfj71cIixcbiAgXCLwn4+H8J+PvlwiLFxuICBcIvCfj4fwn4+/XCIsXG4gIFwi8J+Ph1wiLFxuICBcIvCfj4hcIixcbiAgXCLwn4+JXCIsXG4gIFwi8J+PivCfj7vigI3imYDvuI9cIixcbiAgXCLwn4+K8J+Pu+KAjeKZgu+4j1wiLFxuICBcIvCfj4rwn4+7XCIsXG4gIFwi8J+PivCfj7zigI3imYDvuI9cIixcbiAgXCLwn4+K8J+PvOKAjeKZgu+4j1wiLFxuICBcIvCfj4rwn4+8XCIsXG4gIFwi8J+PivCfj73igI3imYDvuI9cIixcbiAgXCLwn4+K8J+PveKAjeKZgu+4j1wiLFxuICBcIvCfj4rwn4+9XCIsXG4gIFwi8J+PivCfj77igI3imYDvuI9cIixcbiAgXCLwn4+K8J+PvuKAjeKZgu+4j1wiLFxuICBcIvCfj4rwn4++XCIsXG4gIFwi8J+PivCfj7/igI3imYDvuI9cIixcbiAgXCLwn4+K8J+Pv+KAjeKZgu+4j1wiLFxuICBcIvCfj4rwn4+/XCIsXG4gIFwi8J+PiuKAjeKZgO+4j1wiLFxuICBcIvCfj4rigI3imYLvuI9cIixcbiAgXCLwn4+KXCIsXG4gIFwi8J+Pi/Cfj7vigI3imYDvuI9cIixcbiAgXCLwn4+L8J+Pu+KAjeKZgu+4j1wiLFxuICBcIvCfj4vwn4+7XCIsXG4gIFwi8J+Pi/Cfj7zigI3imYDvuI9cIixcbiAgXCLwn4+L8J+PvOKAjeKZgu+4j1wiLFxuICBcIvCfj4vwn4+8XCIsXG4gIFwi8J+Pi/Cfj73igI3imYDvuI9cIixcbiAgXCLwn4+L8J+PveKAjeKZgu+4j1wiLFxuICBcIvCfj4vwn4+9XCIsXG4gIFwi8J+Pi/Cfj77igI3imYDvuI9cIixcbiAgXCLwn4+L8J+PvuKAjeKZgu+4j1wiLFxuICBcIvCfj4vwn4++XCIsXG4gIFwi8J+Pi/Cfj7/igI3imYDvuI9cIixcbiAgXCLwn4+L8J+Pv+KAjeKZgu+4j1wiLFxuICBcIvCfj4vwn4+/XCIsXG4gIFwi8J+Pi++4j+KAjeKZgO+4j1wiLFxuICBcIvCfj4vvuI/igI3imYLvuI9cIixcbiAgXCLwn4+LXCIsXG4gIFwi8J+PjPCfj7vigI3imYDvuI9cIixcbiAgXCLwn4+M8J+Pu+KAjeKZgu+4j1wiLFxuICBcIvCfj4zwn4+7XCIsXG4gIFwi8J+PjPCfj7zigI3imYDvuI9cIixcbiAgXCLwn4+M8J+PvOKAjeKZgu+4j1wiLFxuICBcIvCfj4zwn4+8XCIsXG4gIFwi8J+PjPCfj73igI3imYDvuI9cIixcbiAgXCLwn4+M8J+PveKAjeKZgu+4j1wiLFxuICBcIvCfj4zwn4+9XCIsXG4gIFwi8J+PjPCfj77igI3imYDvuI9cIixcbiAgXCLwn4+M8J+PvuKAjeKZgu+4j1wiLFxuICBcIvCfj4zwn4++XCIsXG4gIFwi8J+PjPCfj7/igI3imYDvuI9cIixcbiAgXCLwn4+M8J+Pv+KAjeKZgu+4j1wiLFxuICBcIvCfj4zwn4+/XCIsXG4gIFwi8J+PjO+4j+KAjeKZgO+4j1wiLFxuICBcIvCfj4zvuI/igI3imYLvuI9cIixcbiAgXCLwn4+MXCIsXG4gIFwi8J+PjVwiLFxuICBcIvCfj45cIixcbiAgXCLwn4+PXCIsXG4gIFwi8J+PkFwiLFxuICBcIvCfj5FcIixcbiAgXCLwn4+SXCIsXG4gIFwi8J+Pk1wiLFxuICBcIvCfj5RcIixcbiAgXCLwn4+VXCIsXG4gIFwi8J+PllwiLFxuICBcIvCfj5dcIixcbiAgXCLwn4+YXCIsXG4gIFwi8J+PmVwiLFxuICBcIvCfj5pcIixcbiAgXCLwn4+bXCIsXG4gIFwi8J+PnFwiLFxuICBcIvCfj51cIixcbiAgXCLwn4+eXCIsXG4gIFwi8J+Pn1wiLFxuICBcIvCfj6BcIixcbiAgXCLwn4+hXCIsXG4gIFwi8J+PolwiLFxuICBcIvCfj6NcIixcbiAgXCLwn4+kXCIsXG4gIFwi8J+PpVwiLFxuICBcIvCfj6ZcIixcbiAgXCLwn4+nXCIsXG4gIFwi8J+PqFwiLFxuICBcIvCfj6lcIixcbiAgXCLwn4+qXCIsXG4gIFwi8J+Pq1wiLFxuICBcIvCfj6xcIixcbiAgXCLwn4+tXCIsXG4gIFwi8J+PrlwiLFxuICBcIvCfj69cIixcbiAgXCLwn4+wXCIsXG4gIFwi8J+Ps++4j+KAjfCfjIhcIixcbiAgXCLwn4+zXCIsXG4gIFwi8J+PtOKAjeKYoO+4j1wiLFxuICBcIvCfj7RcIixcbiAgXCLwn4+1XCIsXG4gIFwi8J+Pt1wiLFxuICBcIvCfj7hcIixcbiAgXCLwn4+5XCIsXG4gIFwi8J+PulwiLFxuICBcIvCfj7tcIixcbiAgXCLwn4+8XCIsXG4gIFwi8J+PvVwiLFxuICBcIvCfj75cIixcbiAgXCLwn4+/XCIsXG4gIFwi8J+QgFwiLFxuICBcIvCfkIFcIixcbiAgXCLwn5CCXCIsXG4gIFwi8J+Qg1wiLFxuICBcIvCfkIRcIixcbiAgXCLwn5CFXCIsXG4gIFwi8J+QhlwiLFxuICBcIvCfkIdcIixcbiAgXCLwn5CIXCIsXG4gIFwi8J+QiVwiLFxuICBcIvCfkIpcIixcbiAgXCLwn5CLXCIsXG4gIFwi8J+QjFwiLFxuICBcIvCfkI1cIixcbiAgXCLwn5COXCIsXG4gIFwi8J+Qj1wiLFxuICBcIvCfkJBcIixcbiAgXCLwn5CRXCIsXG4gIFwi8J+QklwiLFxuICBcIvCfkJNcIixcbiAgXCLwn5CUXCIsXG4gIFwi8J+QlVwiLFxuICBcIvCfkJZcIixcbiAgXCLwn5CXXCIsXG4gIFwi8J+QmFwiLFxuICBcIvCfkJlcIixcbiAgXCLwn5CaXCIsXG4gIFwi8J+Qm1wiLFxuICBcIvCfkJxcIixcbiAgXCLwn5CdXCIsXG4gIFwi8J+QnlwiLFxuICBcIvCfkJ9cIixcbiAgXCLwn5CgXCIsXG4gIFwi8J+QoVwiLFxuICBcIvCfkKJcIixcbiAgXCLwn5CjXCIsXG4gIFwi8J+QpFwiLFxuICBcIvCfkKVcIixcbiAgXCLwn5CmXCIsXG4gIFwi8J+Qp1wiLFxuICBcIvCfkKhcIixcbiAgXCLwn5CpXCIsXG4gIFwi8J+QqlwiLFxuICBcIvCfkKtcIixcbiAgXCLwn5CsXCIsXG4gIFwi8J+QrVwiLFxuICBcIvCfkK5cIixcbiAgXCLwn5CvXCIsXG4gIFwi8J+QsFwiLFxuICBcIvCfkLFcIixcbiAgXCLwn5CyXCIsXG4gIFwi8J+Qs1wiLFxuICBcIvCfkLRcIixcbiAgXCLwn5C1XCIsXG4gIFwi8J+QtlwiLFxuICBcIvCfkLdcIixcbiAgXCLwn5C4XCIsXG4gIFwi8J+QuVwiLFxuICBcIvCfkLpcIixcbiAgXCLwn5C7XCIsXG4gIFwi8J+QvFwiLFxuICBcIvCfkL1cIixcbiAgXCLwn5C+XCIsXG4gIFwi8J+Qv1wiLFxuICBcIvCfkYBcIixcbiAgXCLwn5GB4oCN8J+XqFwiLFxuICBcIvCfkYFcIixcbiAgXCLwn5GC8J+Pu1wiLFxuICBcIvCfkYLwn4+8XCIsXG4gIFwi8J+RgvCfj71cIixcbiAgXCLwn5GC8J+PvlwiLFxuICBcIvCfkYLwn4+/XCIsXG4gIFwi8J+RglwiLFxuICBcIvCfkYPwn4+7XCIsXG4gIFwi8J+Rg/Cfj7xcIixcbiAgXCLwn5GD8J+PvVwiLFxuICBcIvCfkYPwn4++XCIsXG4gIFwi8J+Rg/Cfj79cIixcbiAgXCLwn5GDXCIsXG4gIFwi8J+RhFwiLFxuICBcIvCfkYVcIixcbiAgXCLwn5GG8J+Pu1wiLFxuICBcIvCfkYbwn4+8XCIsXG4gIFwi8J+RhvCfj71cIixcbiAgXCLwn5GG8J+PvlwiLFxuICBcIvCfkYbwn4+/XCIsXG4gIFwi8J+RhlwiLFxuICBcIvCfkYfwn4+7XCIsXG4gIFwi8J+Rh/Cfj7xcIixcbiAgXCLwn5GH8J+PvVwiLFxuICBcIvCfkYfwn4++XCIsXG4gIFwi8J+Rh/Cfj79cIixcbiAgXCLwn5GHXCIsXG4gIFwi8J+RiPCfj7tcIixcbiAgXCLwn5GI8J+PvFwiLFxuICBcIvCfkYjwn4+9XCIsXG4gIFwi8J+RiPCfj75cIixcbiAgXCLwn5GI8J+Pv1wiLFxuICBcIvCfkYhcIixcbiAgXCLwn5GJ8J+Pu1wiLFxuICBcIvCfkYnwn4+8XCIsXG4gIFwi8J+RifCfj71cIixcbiAgXCLwn5GJ8J+PvlwiLFxuICBcIvCfkYnwn4+/XCIsXG4gIFwi8J+RiVwiLFxuICBcIvCfkYrwn4+7XCIsXG4gIFwi8J+RivCfj7xcIixcbiAgXCLwn5GK8J+PvVwiLFxuICBcIvCfkYrwn4++XCIsXG4gIFwi8J+RivCfj79cIixcbiAgXCLwn5GKXCIsXG4gIFwi8J+Ri/Cfj7tcIixcbiAgXCLwn5GL8J+PvFwiLFxuICBcIvCfkYvwn4+9XCIsXG4gIFwi8J+Ri/Cfj75cIixcbiAgXCLwn5GL8J+Pv1wiLFxuICBcIvCfkYtcIixcbiAgXCLwn5GM8J+Pu1wiLFxuICBcIvCfkYzwn4+8XCIsXG4gIFwi8J+RjPCfj71cIixcbiAgXCLwn5GM8J+PvlwiLFxuICBcIvCfkYzwn4+/XCIsXG4gIFwi8J+RjFwiLFxuICBcIvCfkY3wn4+7XCIsXG4gIFwi8J+RjfCfj7xcIixcbiAgXCLwn5GN8J+PvVwiLFxuICBcIvCfkY3wn4++XCIsXG4gIFwi8J+RjfCfj79cIixcbiAgXCLwn5GNXCIsXG4gIFwi8J+RjvCfj7tcIixcbiAgXCLwn5GO8J+PvFwiLFxuICBcIvCfkY7wn4+9XCIsXG4gIFwi8J+RjvCfj75cIixcbiAgXCLwn5GO8J+Pv1wiLFxuICBcIvCfkY5cIixcbiAgXCLwn5GP8J+Pu1wiLFxuICBcIvCfkY/wn4+8XCIsXG4gIFwi8J+Rj/Cfj71cIixcbiAgXCLwn5GP8J+PvlwiLFxuICBcIvCfkY/wn4+/XCIsXG4gIFwi8J+Rj1wiLFxuICBcIvCfkZDwn4+7XCIsXG4gIFwi8J+RkPCfj7xcIixcbiAgXCLwn5GQ8J+PvVwiLFxuICBcIvCfkZDwn4++XCIsXG4gIFwi8J+RkPCfj79cIixcbiAgXCLwn5GQXCIsXG4gIFwi8J+RkVwiLFxuICBcIvCfkZJcIixcbiAgXCLwn5GTXCIsXG4gIFwi8J+RlFwiLFxuICBcIvCfkZVcIixcbiAgXCLwn5GWXCIsXG4gIFwi8J+Rl1wiLFxuICBcIvCfkZhcIixcbiAgXCLwn5GZXCIsXG4gIFwi8J+RmlwiLFxuICBcIvCfkZtcIixcbiAgXCLwn5GcXCIsXG4gIFwi8J+RnVwiLFxuICBcIvCfkZ5cIixcbiAgXCLwn5GfXCIsXG4gIFwi8J+RoFwiLFxuICBcIvCfkaFcIixcbiAgXCLwn5GiXCIsXG4gIFwi8J+Ro1wiLFxuICBcIvCfkaRcIixcbiAgXCLwn5GlXCIsXG4gIFwi8J+RpvCfj7tcIixcbiAgXCLwn5Gm8J+PvFwiLFxuICBcIvCfkabwn4+9XCIsXG4gIFwi8J+RpvCfj75cIixcbiAgXCLwn5Gm8J+Pv1wiLFxuICBcIvCfkaZcIixcbiAgXCLwn5Gn8J+Pu1wiLFxuICBcIvCfkafwn4+8XCIsXG4gIFwi8J+Rp/Cfj71cIixcbiAgXCLwn5Gn8J+PvlwiLFxuICBcIvCfkafwn4+/XCIsXG4gIFwi8J+Rp1wiLFxuICBcIvCfkajwn4+74oCN8J+MvlwiLFxuICBcIvCfkajwn4+74oCN8J+Ns1wiLFxuICBcIvCfkajwn4+74oCN8J+Ok1wiLFxuICBcIvCfkajwn4+74oCN8J+OpFwiLFxuICBcIvCfkajwn4+74oCN8J+OqFwiLFxuICBcIvCfkajwn4+74oCN8J+Pq1wiLFxuICBcIvCfkajwn4+74oCN8J+PrVwiLFxuICBcIvCfkajwn4+74oCN8J+Su1wiLFxuICBcIvCfkajwn4+74oCN8J+SvFwiLFxuICBcIvCfkajwn4+74oCN8J+Up1wiLFxuICBcIvCfkajwn4+74oCN8J+UrFwiLFxuICBcIvCfkajwn4+74oCN8J+agFwiLFxuICBcIvCfkajwn4+74oCN8J+aklwiLFxuICBcIvCfkajwn4+74oCN4pqV77iPXCIsXG4gIFwi8J+RqPCfj7vigI3impbvuI9cIixcbiAgXCLwn5Go8J+Pu+KAjeKciO+4j1wiLFxuICBcIvCfkajwn4+7XCIsXG4gIFwi8J+RqPCfj7zigI3wn4y+XCIsXG4gIFwi8J+RqPCfj7zigI3wn42zXCIsXG4gIFwi8J+RqPCfj7zigI3wn46TXCIsXG4gIFwi8J+RqPCfj7zigI3wn46kXCIsXG4gIFwi8J+RqPCfj7zigI3wn46oXCIsXG4gIFwi8J+RqPCfj7zigI3wn4+rXCIsXG4gIFwi8J+RqPCfj7zigI3wn4+tXCIsXG4gIFwi8J+RqPCfj7zigI3wn5K7XCIsXG4gIFwi8J+RqPCfj7zigI3wn5K8XCIsXG4gIFwi8J+RqPCfj7zigI3wn5SnXCIsXG4gIFwi8J+RqPCfj7zigI3wn5SsXCIsXG4gIFwi8J+RqPCfj7zigI3wn5qAXCIsXG4gIFwi8J+RqPCfj7zigI3wn5qSXCIsXG4gIFwi8J+RqPCfj7zigI3impXvuI9cIixcbiAgXCLwn5Go8J+PvOKAjeKalu+4j1wiLFxuICBcIvCfkajwn4+84oCN4pyI77iPXCIsXG4gIFwi8J+RqPCfj7xcIixcbiAgXCLwn5Go8J+PveKAjfCfjL5cIixcbiAgXCLwn5Go8J+PveKAjfCfjbNcIixcbiAgXCLwn5Go8J+PveKAjfCfjpNcIixcbiAgXCLwn5Go8J+PveKAjfCfjqRcIixcbiAgXCLwn5Go8J+PveKAjfCfjqhcIixcbiAgXCLwn5Go8J+PveKAjfCfj6tcIixcbiAgXCLwn5Go8J+PveKAjfCfj61cIixcbiAgXCLwn5Go8J+PveKAjfCfkrtcIixcbiAgXCLwn5Go8J+PveKAjfCfkrxcIixcbiAgXCLwn5Go8J+PveKAjfCflKdcIixcbiAgXCLwn5Go8J+PveKAjfCflKxcIixcbiAgXCLwn5Go8J+PveKAjfCfmoBcIixcbiAgXCLwn5Go8J+PveKAjfCfmpJcIixcbiAgXCLwn5Go8J+PveKAjeKale+4j1wiLFxuICBcIvCfkajwn4+94oCN4pqW77iPXCIsXG4gIFwi8J+RqPCfj73igI3inIjvuI9cIixcbiAgXCLwn5Go8J+PvVwiLFxuICBcIvCfkajwn4++4oCN8J+MvlwiLFxuICBcIvCfkajwn4++4oCN8J+Ns1wiLFxuICBcIvCfkajwn4++4oCN8J+Ok1wiLFxuICBcIvCfkajwn4++4oCN8J+OpFwiLFxuICBcIvCfkajwn4++4oCN8J+OqFwiLFxuICBcIvCfkajwn4++4oCN8J+Pq1wiLFxuICBcIvCfkajwn4++4oCN8J+PrVwiLFxuICBcIvCfkajwn4++4oCN8J+Su1wiLFxuICBcIvCfkajwn4++4oCN8J+SvFwiLFxuICBcIvCfkajwn4++4oCN8J+Up1wiLFxuICBcIvCfkajwn4++4oCN8J+UrFwiLFxuICBcIvCfkajwn4++4oCN8J+agFwiLFxuICBcIvCfkajwn4++4oCN8J+aklwiLFxuICBcIvCfkajwn4++4oCN4pqV77iPXCIsXG4gIFwi8J+RqPCfj77igI3impbvuI9cIixcbiAgXCLwn5Go8J+PvuKAjeKciO+4j1wiLFxuICBcIvCfkajwn4++XCIsXG4gIFwi8J+RqPCfj7/igI3wn4y+XCIsXG4gIFwi8J+RqPCfj7/igI3wn42zXCIsXG4gIFwi8J+RqPCfj7/igI3wn46TXCIsXG4gIFwi8J+RqPCfj7/igI3wn46kXCIsXG4gIFwi8J+RqPCfj7/igI3wn46oXCIsXG4gIFwi8J+RqPCfj7/igI3wn4+rXCIsXG4gIFwi8J+RqPCfj7/igI3wn4+tXCIsXG4gIFwi8J+RqPCfj7/igI3wn5K7XCIsXG4gIFwi8J+RqPCfj7/igI3wn5K8XCIsXG4gIFwi8J+RqPCfj7/igI3wn5SnXCIsXG4gIFwi8J+RqPCfj7/igI3wn5SsXCIsXG4gIFwi8J+RqPCfj7/igI3wn5qAXCIsXG4gIFwi8J+RqPCfj7/igI3wn5qSXCIsXG4gIFwi8J+RqPCfj7/igI3impXvuI9cIixcbiAgXCLwn5Go8J+Pv+KAjeKalu+4j1wiLFxuICBcIvCfkajwn4+/4oCN4pyI77iPXCIsXG4gIFwi8J+RqPCfj79cIixcbiAgXCLwn5Go4oCN8J+MvlwiLFxuICBcIvCfkajigI3wn42zXCIsXG4gIFwi8J+RqOKAjfCfjpNcIixcbiAgXCLwn5Go4oCN8J+OpFwiLFxuICBcIvCfkajigI3wn46oXCIsXG4gIFwi8J+RqOKAjfCfj6tcIixcbiAgXCLwn5Go4oCN8J+PrVwiLFxuICBcIvCfkajigI3wn5Gm4oCN8J+RplwiLFxuICBcIvCfkajigI3wn5GmXCIsXG4gIFwi8J+RqOKAjfCfkafigI3wn5GmXCIsXG4gIFwi8J+RqOKAjfCfkafigI3wn5GnXCIsXG4gIFwi8J+RqOKAjfCfkadcIixcbiAgXCLwn5Go4oCN8J+RqOKAjfCfkabigI3wn5GmXCIsXG4gIFwi8J+RqOKAjfCfkajigI3wn5GmXCIsXG4gIFwi8J+RqOKAjfCfkajigI3wn5Gn4oCN8J+RplwiLFxuICBcIvCfkajigI3wn5Go4oCN8J+Rp+KAjfCfkadcIixcbiAgXCLwn5Go4oCN8J+RqOKAjfCfkadcIixcbiAgXCLwn5Go4oCN8J+RqeKAjfCfkabigI3wn5GmXCIsXG4gIFwi8J+RqOKAjfCfkanigI3wn5GmXCIsXG4gIFwi8J+RqOKAjfCfkanigI3wn5Gn4oCN8J+RplwiLFxuICBcIvCfkajigI3wn5Gp4oCN8J+Rp+KAjfCfkadcIixcbiAgXCLwn5Go4oCN8J+RqeKAjfCfkadcIixcbiAgXCLwn5Go4oCN8J+Su1wiLFxuICBcIvCfkajigI3wn5K8XCIsXG4gIFwi8J+RqOKAjfCflKdcIixcbiAgXCLwn5Go4oCN8J+UrFwiLFxuICBcIvCfkajigI3wn5qAXCIsXG4gIFwi8J+RqOKAjfCfmpJcIixcbiAgXCLwn5Go4oCN4pqV77iPXCIsXG4gIFwi8J+RqOKAjeKalu+4j1wiLFxuICBcIvCfkajigI3inIjvuI9cIixcbiAgXCLwn5Go4oCN4p2k77iP4oCN8J+RqFwiLFxuICBcIvCfkajigI3inaTvuI/igI3wn5KL4oCN8J+RqFwiLFxuICBcIvCfkahcIixcbiAgXCLwn5Gp8J+Pu+KAjfCfjL5cIixcbiAgXCLwn5Gp8J+Pu+KAjfCfjbNcIixcbiAgXCLwn5Gp8J+Pu+KAjfCfjpNcIixcbiAgXCLwn5Gp8J+Pu+KAjfCfjqRcIixcbiAgXCLwn5Gp8J+Pu+KAjfCfjqhcIixcbiAgXCLwn5Gp8J+Pu+KAjfCfj6tcIixcbiAgXCLwn5Gp8J+Pu+KAjfCfj61cIixcbiAgXCLwn5Gp8J+Pu+KAjfCfkrtcIixcbiAgXCLwn5Gp8J+Pu+KAjfCfkrxcIixcbiAgXCLwn5Gp8J+Pu+KAjfCflKdcIixcbiAgXCLwn5Gp8J+Pu+KAjfCflKxcIixcbiAgXCLwn5Gp8J+Pu+KAjfCfmoBcIixcbiAgXCLwn5Gp8J+Pu+KAjfCfmpJcIixcbiAgXCLwn5Gp8J+Pu+KAjeKale+4j1wiLFxuICBcIvCfkanwn4+74oCN4pqW77iPXCIsXG4gIFwi8J+RqfCfj7vigI3inIjvuI9cIixcbiAgXCLwn5Gp8J+Pu1wiLFxuICBcIvCfkanwn4+84oCN8J+MvlwiLFxuICBcIvCfkanwn4+84oCN8J+Ns1wiLFxuICBcIvCfkanwn4+84oCN8J+Ok1wiLFxuICBcIvCfkanwn4+84oCN8J+OpFwiLFxuICBcIvCfkanwn4+84oCN8J+OqFwiLFxuICBcIvCfkanwn4+84oCN8J+Pq1wiLFxuICBcIvCfkanwn4+84oCN8J+PrVwiLFxuICBcIvCfkanwn4+84oCN8J+Su1wiLFxuICBcIvCfkanwn4+84oCN8J+SvFwiLFxuICBcIvCfkanwn4+84oCN8J+Up1wiLFxuICBcIvCfkanwn4+84oCN8J+UrFwiLFxuICBcIvCfkanwn4+84oCN8J+agFwiLFxuICBcIvCfkanwn4+84oCN8J+aklwiLFxuICBcIvCfkanwn4+84oCN4pqV77iPXCIsXG4gIFwi8J+RqfCfj7zigI3impbvuI9cIixcbiAgXCLwn5Gp8J+PvOKAjeKciO+4j1wiLFxuICBcIvCfkanwn4+8XCIsXG4gIFwi8J+RqfCfj73igI3wn4y+XCIsXG4gIFwi8J+RqfCfj73igI3wn42zXCIsXG4gIFwi8J+RqfCfj73igI3wn46TXCIsXG4gIFwi8J+RqfCfj73igI3wn46kXCIsXG4gIFwi8J+RqfCfj73igI3wn46oXCIsXG4gIFwi8J+RqfCfj73igI3wn4+rXCIsXG4gIFwi8J+RqfCfj73igI3wn4+tXCIsXG4gIFwi8J+RqfCfj73igI3wn5K7XCIsXG4gIFwi8J+RqfCfj73igI3wn5K8XCIsXG4gIFwi8J+RqfCfj73igI3wn5SnXCIsXG4gIFwi8J+RqfCfj73igI3wn5SsXCIsXG4gIFwi8J+RqfCfj73igI3wn5qAXCIsXG4gIFwi8J+RqfCfj73igI3wn5qSXCIsXG4gIFwi8J+RqfCfj73igI3impXvuI9cIixcbiAgXCLwn5Gp8J+PveKAjeKalu+4j1wiLFxuICBcIvCfkanwn4+94oCN4pyI77iPXCIsXG4gIFwi8J+RqfCfj71cIixcbiAgXCLwn5Gp8J+PvuKAjfCfjL5cIixcbiAgXCLwn5Gp8J+PvuKAjfCfjbNcIixcbiAgXCLwn5Gp8J+PvuKAjfCfjpNcIixcbiAgXCLwn5Gp8J+PvuKAjfCfjqRcIixcbiAgXCLwn5Gp8J+PvuKAjfCfjqhcIixcbiAgXCLwn5Gp8J+PvuKAjfCfj6tcIixcbiAgXCLwn5Gp8J+PvuKAjfCfj61cIixcbiAgXCLwn5Gp8J+PvuKAjfCfkrtcIixcbiAgXCLwn5Gp8J+PvuKAjfCfkrxcIixcbiAgXCLwn5Gp8J+PvuKAjfCflKdcIixcbiAgXCLwn5Gp8J+PvuKAjfCflKxcIixcbiAgXCLwn5Gp8J+PvuKAjfCfmoBcIixcbiAgXCLwn5Gp8J+PvuKAjfCfmpJcIixcbiAgXCLwn5Gp8J+PvuKAjeKale+4j1wiLFxuICBcIvCfkanwn4++4oCN4pqW77iPXCIsXG4gIFwi8J+RqfCfj77igI3inIjvuI9cIixcbiAgXCLwn5Gp8J+PvlwiLFxuICBcIvCfkanwn4+/4oCN8J+MvlwiLFxuICBcIvCfkanwn4+/4oCN8J+Ns1wiLFxuICBcIvCfkanwn4+/4oCN8J+Ok1wiLFxuICBcIvCfkanwn4+/4oCN8J+OpFwiLFxuICBcIvCfkanwn4+/4oCN8J+OqFwiLFxuICBcIvCfkanwn4+/4oCN8J+Pq1wiLFxuICBcIvCfkanwn4+/4oCN8J+PrVwiLFxuICBcIvCfkanwn4+/4oCN8J+Su1wiLFxuICBcIvCfkanwn4+/4oCN8J+SvFwiLFxuICBcIvCfkanwn4+/4oCN8J+Up1wiLFxuICBcIvCfkanwn4+/4oCN8J+UrFwiLFxuICBcIvCfkanwn4+/4oCN8J+agFwiLFxuICBcIvCfkanwn4+/4oCN8J+aklwiLFxuICBcIvCfkanwn4+/4oCN4pqV77iPXCIsXG4gIFwi8J+RqfCfj7/igI3impbvuI9cIixcbiAgXCLwn5Gp8J+Pv+KAjeKciO+4j1wiLFxuICBcIvCfkanwn4+/XCIsXG4gIFwi8J+RqeKAjfCfjL5cIixcbiAgXCLwn5Gp4oCN8J+Ns1wiLFxuICBcIvCfkanigI3wn46TXCIsXG4gIFwi8J+RqeKAjfCfjqRcIixcbiAgXCLwn5Gp4oCN8J+OqFwiLFxuICBcIvCfkanigI3wn4+rXCIsXG4gIFwi8J+RqeKAjfCfj61cIixcbiAgXCLwn5Gp4oCN8J+RpuKAjfCfkaZcIixcbiAgXCLwn5Gp4oCN8J+RplwiLFxuICBcIvCfkanigI3wn5Gn4oCN8J+RplwiLFxuICBcIvCfkanigI3wn5Gn4oCN8J+Rp1wiLFxuICBcIvCfkanigI3wn5GnXCIsXG4gIFwi8J+RqeKAjfCfkanigI3wn5Gm4oCN8J+RplwiLFxuICBcIvCfkanigI3wn5Gp4oCN8J+RplwiLFxuICBcIvCfkanigI3wn5Gp4oCN8J+Rp+KAjfCfkaZcIixcbiAgXCLwn5Gp4oCN8J+RqeKAjfCfkafigI3wn5GnXCIsXG4gIFwi8J+RqeKAjfCfkanigI3wn5GnXCIsXG4gIFwi8J+RqeKAjfCfkrtcIixcbiAgXCLwn5Gp4oCN8J+SvFwiLFxuICBcIvCfkanigI3wn5SnXCIsXG4gIFwi8J+RqeKAjfCflKxcIixcbiAgXCLwn5Gp4oCN8J+agFwiLFxuICBcIvCfkanigI3wn5qSXCIsXG4gIFwi8J+RqeKAjeKale+4j1wiLFxuICBcIvCfkanigI3impbvuI9cIixcbiAgXCLwn5Gp4oCN4pyI77iPXCIsXG4gIFwi8J+RqeKAjeKdpO+4j+KAjfCfkahcIixcbiAgXCLwn5Gp4oCN4p2k77iP4oCN8J+RqVwiLFxuICBcIvCfkanigI3inaTvuI/igI3wn5KL4oCN8J+RqFwiLFxuICBcIvCfkanigI3inaTvuI/igI3wn5KL4oCN8J+RqVwiLFxuICBcIvCfkalcIixcbiAgXCLwn5Gq8J+Pu1wiLFxuICBcIvCfkarwn4+8XCIsXG4gIFwi8J+RqvCfj71cIixcbiAgXCLwn5Gq8J+PvlwiLFxuICBcIvCfkarwn4+/XCIsXG4gIFwi8J+RqlwiLFxuICBcIvCfkavwn4+7XCIsXG4gIFwi8J+Rq/Cfj7xcIixcbiAgXCLwn5Gr8J+PvVwiLFxuICBcIvCfkavwn4++XCIsXG4gIFwi8J+Rq/Cfj79cIixcbiAgXCLwn5GrXCIsXG4gIFwi8J+RrPCfj7tcIixcbiAgXCLwn5Gs8J+PvFwiLFxuICBcIvCfkazwn4+9XCIsXG4gIFwi8J+RrPCfj75cIixcbiAgXCLwn5Gs8J+Pv1wiLFxuICBcIvCfkaxcIixcbiAgXCLwn5Gt8J+Pu1wiLFxuICBcIvCfka3wn4+8XCIsXG4gIFwi8J+RrfCfj71cIixcbiAgXCLwn5Gt8J+PvlwiLFxuICBcIvCfka3wn4+/XCIsXG4gIFwi8J+RrVwiLFxuICBcIvCfka7wn4+74oCN4pmA77iPXCIsXG4gIFwi8J+RrvCfj7vigI3imYLvuI9cIixcbiAgXCLwn5Gu8J+Pu1wiLFxuICBcIvCfka7wn4+84oCN4pmA77iPXCIsXG4gIFwi8J+RrvCfj7zigI3imYLvuI9cIixcbiAgXCLwn5Gu8J+PvFwiLFxuICBcIvCfka7wn4+94oCN4pmA77iPXCIsXG4gIFwi8J+RrvCfj73igI3imYLvuI9cIixcbiAgXCLwn5Gu8J+PvVwiLFxuICBcIvCfka7wn4++4oCN4pmA77iPXCIsXG4gIFwi8J+RrvCfj77igI3imYLvuI9cIixcbiAgXCLwn5Gu8J+PvlwiLFxuICBcIvCfka7wn4+/4oCN4pmA77iPXCIsXG4gIFwi8J+RrvCfj7/igI3imYLvuI9cIixcbiAgXCLwn5Gu8J+Pv1wiLFxuICBcIvCfka7igI3imYDvuI9cIixcbiAgXCLwn5Gu4oCN4pmC77iPXCIsXG4gIFwi8J+RrlwiLFxuICBcIvCfka/wn4+74oCN4pmA77iPXCIsXG4gIFwi8J+Rr/Cfj7vigI3imYLvuI9cIixcbiAgXCLwn5Gv8J+Pu1wiLFxuICBcIvCfka/wn4+84oCN4pmA77iPXCIsXG4gIFwi8J+Rr/Cfj7zigI3imYLvuI9cIixcbiAgXCLwn5Gv8J+PvFwiLFxuICBcIvCfka/wn4+94oCN4pmA77iPXCIsXG4gIFwi8J+Rr/Cfj73igI3imYLvuI9cIixcbiAgXCLwn5Gv8J+PvVwiLFxuICBcIvCfka/wn4++4oCN4pmA77iPXCIsXG4gIFwi8J+Rr/Cfj77igI3imYLvuI9cIixcbiAgXCLwn5Gv8J+PvlwiLFxuICBcIvCfka/wn4+/4oCN4pmA77iPXCIsXG4gIFwi8J+Rr/Cfj7/igI3imYLvuI9cIixcbiAgXCLwn5Gv8J+Pv1wiLFxuICBcIvCfka/igI3imYDvuI9cIixcbiAgXCLwn5Gv4oCN4pmC77iPXCIsXG4gIFwi8J+Rr1wiLFxuICBcIvCfkbDwn4+7XCIsXG4gIFwi8J+RsPCfj7xcIixcbiAgXCLwn5Gw8J+PvVwiLFxuICBcIvCfkbDwn4++XCIsXG4gIFwi8J+RsPCfj79cIixcbiAgXCLwn5GwXCIsXG4gIFwi8J+RsfCfj7vigI3imYDvuI9cIixcbiAgXCLwn5Gx8J+Pu+KAjeKZgu+4j1wiLFxuICBcIvCfkbHwn4+7XCIsXG4gIFwi8J+RsfCfj7zigI3imYDvuI9cIixcbiAgXCLwn5Gx8J+PvOKAjeKZgu+4j1wiLFxuICBcIvCfkbHwn4+8XCIsXG4gIFwi8J+RsfCfj73igI3imYDvuI9cIixcbiAgXCLwn5Gx8J+PveKAjeKZgu+4j1wiLFxuICBcIvCfkbHwn4+9XCIsXG4gIFwi8J+RsfCfj77igI3imYDvuI9cIixcbiAgXCLwn5Gx8J+PvuKAjeKZgu+4j1wiLFxuICBcIvCfkbHwn4++XCIsXG4gIFwi8J+RsfCfj7/igI3imYDvuI9cIixcbiAgXCLwn5Gx8J+Pv+KAjeKZgu+4j1wiLFxuICBcIvCfkbHwn4+/XCIsXG4gIFwi8J+RseKAjeKZgO+4j1wiLFxuICBcIvCfkbHigI3imYLvuI9cIixcbiAgXCLwn5GxXCIsXG4gIFwi8J+RsvCfj7tcIixcbiAgXCLwn5Gy8J+PvFwiLFxuICBcIvCfkbLwn4+9XCIsXG4gIFwi8J+RsvCfj75cIixcbiAgXCLwn5Gy8J+Pv1wiLFxuICBcIvCfkbJcIixcbiAgXCLwn5Gz8J+Pu+KAjeKZgO+4j1wiLFxuICBcIvCfkbPwn4+74oCN4pmC77iPXCIsXG4gIFwi8J+Rs/Cfj7tcIixcbiAgXCLwn5Gz8J+PvOKAjeKZgO+4j1wiLFxuICBcIvCfkbPwn4+84oCN4pmC77iPXCIsXG4gIFwi8J+Rs/Cfj7xcIixcbiAgXCLwn5Gz8J+PveKAjeKZgO+4j1wiLFxuICBcIvCfkbPwn4+94oCN4pmC77iPXCIsXG4gIFwi8J+Rs/Cfj71cIixcbiAgXCLwn5Gz8J+PvuKAjeKZgO+4j1wiLFxuICBcIvCfkbPwn4++4oCN4pmC77iPXCIsXG4gIFwi8J+Rs/Cfj75cIixcbiAgXCLwn5Gz8J+Pv+KAjeKZgO+4j1wiLFxuICBcIvCfkbPwn4+/4oCN4pmC77iPXCIsXG4gIFwi8J+Rs/Cfj79cIixcbiAgXCLwn5Gz4oCN4pmA77iPXCIsXG4gIFwi8J+Rs+KAjeKZgu+4j1wiLFxuICBcIvCfkbNcIixcbiAgXCLwn5G08J+Pu1wiLFxuICBcIvCfkbTwn4+8XCIsXG4gIFwi8J+RtPCfj71cIixcbiAgXCLwn5G08J+PvlwiLFxuICBcIvCfkbTwn4+/XCIsXG4gIFwi8J+RtFwiLFxuICBcIvCfkbXwn4+7XCIsXG4gIFwi8J+RtfCfj7xcIixcbiAgXCLwn5G18J+PvVwiLFxuICBcIvCfkbXwn4++XCIsXG4gIFwi8J+RtfCfj79cIixcbiAgXCLwn5G1XCIsXG4gIFwi8J+RtvCfj7tcIixcbiAgXCLwn5G28J+PvFwiLFxuICBcIvCfkbbwn4+9XCIsXG4gIFwi8J+RtvCfj75cIixcbiAgXCLwn5G28J+Pv1wiLFxuICBcIvCfkbZcIixcbiAgXCLwn5G38J+Pu+KAjeKZgO+4j1wiLFxuICBcIvCfkbfwn4+74oCN4pmC77iPXCIsXG4gIFwi8J+Rt/Cfj7tcIixcbiAgXCLwn5G38J+PvOKAjeKZgO+4j1wiLFxuICBcIvCfkbfwn4+84oCN4pmC77iPXCIsXG4gIFwi8J+Rt/Cfj7xcIixcbiAgXCLwn5G38J+PveKAjeKZgO+4j1wiLFxuICBcIvCfkbfwn4+94oCN4pmC77iPXCIsXG4gIFwi8J+Rt/Cfj71cIixcbiAgXCLwn5G38J+PvuKAjeKZgO+4j1wiLFxuICBcIvCfkbfwn4++4oCN4pmC77iPXCIsXG4gIFwi8J+Rt/Cfj75cIixcbiAgXCLwn5G38J+Pv+KAjeKZgO+4j1wiLFxuICBcIvCfkbfwn4+/4oCN4pmC77iPXCIsXG4gIFwi8J+Rt/Cfj79cIixcbiAgXCLwn5G34oCN4pmA77iPXCIsXG4gIFwi8J+Rt+KAjeKZgu+4j1wiLFxuICBcIvCfkbdcIixcbiAgXCLwn5G48J+Pu1wiLFxuICBcIvCfkbjwn4+8XCIsXG4gIFwi8J+RuPCfj71cIixcbiAgXCLwn5G48J+PvlwiLFxuICBcIvCfkbjwn4+/XCIsXG4gIFwi8J+RuFwiLFxuICBcIvCfkblcIixcbiAgXCLwn5G6XCIsXG4gIFwi8J+Ru1wiLFxuICBcIvCfkbzwn4+7XCIsXG4gIFwi8J+RvPCfj7xcIixcbiAgXCLwn5G88J+PvVwiLFxuICBcIvCfkbzwn4++XCIsXG4gIFwi8J+RvPCfj79cIixcbiAgXCLwn5G8XCIsXG4gIFwi8J+RvVwiLFxuICBcIvCfkb5cIixcbiAgXCLwn5G/XCIsXG4gIFwi8J+SgFwiLFxuICBcIvCfkoHwn4+74oCN4pmA77iPXCIsXG4gIFwi8J+SgfCfj7vigI3imYLvuI9cIixcbiAgXCLwn5KB8J+Pu1wiLFxuICBcIvCfkoHwn4+84oCN4pmA77iPXCIsXG4gIFwi8J+SgfCfj7zigI3imYLvuI9cIixcbiAgXCLwn5KB8J+PvFwiLFxuICBcIvCfkoHwn4+94oCN4pmA77iPXCIsXG4gIFwi8J+SgfCfj73igI3imYLvuI9cIixcbiAgXCLwn5KB8J+PvVwiLFxuICBcIvCfkoHwn4++4oCN4pmA77iPXCIsXG4gIFwi8J+SgfCfj77igI3imYLvuI9cIixcbiAgXCLwn5KB8J+PvlwiLFxuICBcIvCfkoHwn4+/4oCN4pmA77iPXCIsXG4gIFwi8J+SgfCfj7/igI3imYLvuI9cIixcbiAgXCLwn5KB8J+Pv1wiLFxuICBcIvCfkoHigI3imYDvuI9cIixcbiAgXCLwn5KB4oCN4pmC77iPXCIsXG4gIFwi8J+SgVwiLFxuICBcIvCfkoLwn4+74oCN4pmA77iPXCIsXG4gIFwi8J+SgvCfj7vigI3imYLvuI9cIixcbiAgXCLwn5KC8J+Pu1wiLFxuICBcIvCfkoLwn4+84oCN4pmA77iPXCIsXG4gIFwi8J+SgvCfj7zigI3imYLvuI9cIixcbiAgXCLwn5KC8J+PvFwiLFxuICBcIvCfkoLwn4+94oCN4pmA77iPXCIsXG4gIFwi8J+SgvCfj73igI3imYLvuI9cIixcbiAgXCLwn5KC8J+PvVwiLFxuICBcIvCfkoLwn4++4oCN4pmA77iPXCIsXG4gIFwi8J+SgvCfj77igI3imYLvuI9cIixcbiAgXCLwn5KC8J+PvlwiLFxuICBcIvCfkoLwn4+/4oCN4pmA77iPXCIsXG4gIFwi8J+SgvCfj7/igI3imYLvuI9cIixcbiAgXCLwn5KC8J+Pv1wiLFxuICBcIvCfkoLigI3imYDvuI9cIixcbiAgXCLwn5KC4oCN4pmC77iPXCIsXG4gIFwi8J+SglwiLFxuICBcIvCfkoPwn4+7XCIsXG4gIFwi8J+Sg/Cfj7xcIixcbiAgXCLwn5KD8J+PvVwiLFxuICBcIvCfkoPwn4++XCIsXG4gIFwi8J+Sg/Cfj79cIixcbiAgXCLwn5KDXCIsXG4gIFwi8J+ShFwiLFxuICBcIvCfkoXwn4+7XCIsXG4gIFwi8J+ShfCfj7xcIixcbiAgXCLwn5KF8J+PvVwiLFxuICBcIvCfkoXwn4++XCIsXG4gIFwi8J+ShfCfj79cIixcbiAgXCLwn5KFXCIsXG4gIFwi8J+ShvCfj7vigI3imYDvuI9cIixcbiAgXCLwn5KG8J+Pu+KAjeKZgu+4j1wiLFxuICBcIvCfkobwn4+7XCIsXG4gIFwi8J+ShvCfj7zigI3imYDvuI9cIixcbiAgXCLwn5KG8J+PvOKAjeKZgu+4j1wiLFxuICBcIvCfkobwn4+8XCIsXG4gIFwi8J+ShvCfj73igI3imYDvuI9cIixcbiAgXCLwn5KG8J+PveKAjeKZgu+4j1wiLFxuICBcIvCfkobwn4+9XCIsXG4gIFwi8J+ShvCfj77igI3imYDvuI9cIixcbiAgXCLwn5KG8J+PvuKAjeKZgu+4j1wiLFxuICBcIvCfkobwn4++XCIsXG4gIFwi8J+ShvCfj7/igI3imYDvuI9cIixcbiAgXCLwn5KG8J+Pv+KAjeKZgu+4j1wiLFxuICBcIvCfkobwn4+/XCIsXG4gIFwi8J+ShuKAjeKZgO+4j1wiLFxuICBcIvCfkobigI3imYLvuI9cIixcbiAgXCLwn5KGXCIsXG4gIFwi8J+Sh/Cfj7vigI3imYDvuI9cIixcbiAgXCLwn5KH8J+Pu+KAjeKZgu+4j1wiLFxuICBcIvCfkofwn4+7XCIsXG4gIFwi8J+Sh/Cfj7zigI3imYDvuI9cIixcbiAgXCLwn5KH8J+PvOKAjeKZgu+4j1wiLFxuICBcIvCfkofwn4+8XCIsXG4gIFwi8J+Sh/Cfj73igI3imYDvuI9cIixcbiAgXCLwn5KH8J+PveKAjeKZgu+4j1wiLFxuICBcIvCfkofwn4+9XCIsXG4gIFwi8J+Sh/Cfj77igI3imYDvuI9cIixcbiAgXCLwn5KH8J+PvuKAjeKZgu+4j1wiLFxuICBcIvCfkofwn4++XCIsXG4gIFwi8J+Sh/Cfj7/igI3imYDvuI9cIixcbiAgXCLwn5KH8J+Pv+KAjeKZgu+4j1wiLFxuICBcIvCfkofwn4+/XCIsXG4gIFwi8J+Sh+KAjeKZgO+4j1wiLFxuICBcIvCfkofigI3imYLvuI9cIixcbiAgXCLwn5KHXCIsXG4gIFwi8J+SiFwiLFxuICBcIvCfkolcIixcbiAgXCLwn5KKXCIsXG4gIFwi8J+Si1wiLFxuICBcIvCfkoxcIixcbiAgXCLwn5KNXCIsXG4gIFwi8J+SjlwiLFxuICBcIvCfko9cIixcbiAgXCLwn5KQXCIsXG4gIFwi8J+SkVwiLFxuICBcIvCfkpJcIixcbiAgXCLwn5KTXCIsXG4gIFwi8J+SlFwiLFxuICBcIvCfkpVcIixcbiAgXCLwn5KWXCIsXG4gIFwi8J+Sl1wiLFxuICBcIvCfkphcIixcbiAgXCLwn5KZXCIsXG4gIFwi8J+SmlwiLFxuICBcIvCfkptcIixcbiAgXCLwn5KcXCIsXG4gIFwi8J+SnVwiLFxuICBcIvCfkp5cIixcbiAgXCLwn5KfXCIsXG4gIFwi8J+SoFwiLFxuICBcIvCfkqFcIixcbiAgXCLwn5KiXCIsXG4gIFwi8J+So1wiLFxuICBcIvCfkqRcIixcbiAgXCLwn5KlXCIsXG4gIFwi8J+SplwiLFxuICBcIvCfkqdcIixcbiAgXCLwn5KoXCIsXG4gIFwi8J+SqVwiLFxuICBcIvCfkqrwn4+7XCIsXG4gIFwi8J+SqvCfj7xcIixcbiAgXCLwn5Kq8J+PvVwiLFxuICBcIvCfkqrwn4++XCIsXG4gIFwi8J+SqvCfj79cIixcbiAgXCLwn5KqXCIsXG4gIFwi8J+Sq1wiLFxuICBcIvCfkqxcIixcbiAgXCLwn5KtXCIsXG4gIFwi8J+SrlwiLFxuICBcIvCfkq9cIixcbiAgXCLwn5KwXCIsXG4gIFwi8J+SsVwiLFxuICBcIvCfkrJcIixcbiAgXCLwn5KzXCIsXG4gIFwi8J+StFwiLFxuICBcIvCfkrVcIixcbiAgXCLwn5K2XCIsXG4gIFwi8J+St1wiLFxuICBcIvCfkrhcIixcbiAgXCLwn5K5XCIsXG4gIFwi8J+SulwiLFxuICBcIvCfkrtcIixcbiAgXCLwn5K8XCIsXG4gIFwi8J+SvVwiLFxuICBcIvCfkr5cIixcbiAgXCLwn5K/XCIsXG4gIFwi8J+TgFwiLFxuICBcIvCfk4FcIixcbiAgXCLwn5OCXCIsXG4gIFwi8J+Tg1wiLFxuICBcIvCfk4RcIixcbiAgXCLwn5OFXCIsXG4gIFwi8J+ThlwiLFxuICBcIvCfk4dcIixcbiAgXCLwn5OIXCIsXG4gIFwi8J+TiVwiLFxuICBcIvCfk4pcIixcbiAgXCLwn5OLXCIsXG4gIFwi8J+TjFwiLFxuICBcIvCfk41cIixcbiAgXCLwn5OOXCIsXG4gIFwi8J+Tj1wiLFxuICBcIvCfk5BcIixcbiAgXCLwn5ORXCIsXG4gIFwi8J+TklwiLFxuICBcIvCfk5NcIixcbiAgXCLwn5OUXCIsXG4gIFwi8J+TlVwiLFxuICBcIvCfk5ZcIixcbiAgXCLwn5OXXCIsXG4gIFwi8J+TmFwiLFxuICBcIvCfk5lcIixcbiAgXCLwn5OaXCIsXG4gIFwi8J+Tm1wiLFxuICBcIvCfk5xcIixcbiAgXCLwn5OdXCIsXG4gIFwi8J+TnlwiLFxuICBcIvCfk59cIixcbiAgXCLwn5OgXCIsXG4gIFwi8J+ToVwiLFxuICBcIvCfk6JcIixcbiAgXCLwn5OjXCIsXG4gIFwi8J+TpFwiLFxuICBcIvCfk6VcIixcbiAgXCLwn5OmXCIsXG4gIFwi8J+Tp1wiLFxuICBcIvCfk6hcIixcbiAgXCLwn5OpXCIsXG4gIFwi8J+TqlwiLFxuICBcIvCfk6tcIixcbiAgXCLwn5OsXCIsXG4gIFwi8J+TrVwiLFxuICBcIvCfk65cIixcbiAgXCLwn5OvXCIsXG4gIFwi8J+TsFwiLFxuICBcIvCfk7FcIixcbiAgXCLwn5OyXCIsXG4gIFwi8J+Ts1wiLFxuICBcIvCfk7RcIixcbiAgXCLwn5O1XCIsXG4gIFwi8J+TtlwiLFxuICBcIvCfk7dcIixcbiAgXCLwn5O4XCIsXG4gIFwi8J+TuVwiLFxuICBcIvCfk7pcIixcbiAgXCLwn5O7XCIsXG4gIFwi8J+TvFwiLFxuICBcIvCfk71cIixcbiAgXCLwn5O/XCIsXG4gIFwi8J+UgFwiLFxuICBcIvCflIFcIixcbiAgXCLwn5SCXCIsXG4gIFwi8J+Ug1wiLFxuICBcIvCflIRcIixcbiAgXCLwn5SFXCIsXG4gIFwi8J+UhlwiLFxuICBcIvCflIdcIixcbiAgXCLwn5SIXCIsXG4gIFwi8J+UiVwiLFxuICBcIvCflIpcIixcbiAgXCLwn5SLXCIsXG4gIFwi8J+UjFwiLFxuICBcIvCflI1cIixcbiAgXCLwn5SOXCIsXG4gIFwi8J+Uj1wiLFxuICBcIvCflJBcIixcbiAgXCLwn5SRXCIsXG4gIFwi8J+UklwiLFxuICBcIvCflJNcIixcbiAgXCLwn5SUXCIsXG4gIFwi8J+UlVwiLFxuICBcIvCflJZcIixcbiAgXCLwn5SXXCIsXG4gIFwi8J+UmFwiLFxuICBcIvCflJlcIixcbiAgXCLwn5SaXCIsXG4gIFwi8J+Um1wiLFxuICBcIvCflJxcIixcbiAgXCLwn5SdXCIsXG4gIFwi8J+UnlwiLFxuICBcIvCflJ9cIixcbiAgXCLwn5SgXCIsXG4gIFwi8J+UoVwiLFxuICBcIvCflKJcIixcbiAgXCLwn5SjXCIsXG4gIFwi8J+UpFwiLFxuICBcIvCflKVcIixcbiAgXCLwn5SmXCIsXG4gIFwi8J+Up1wiLFxuICBcIvCflKhcIixcbiAgXCLwn5SpXCIsXG4gIFwi8J+UqlwiLFxuICBcIvCflKtcIixcbiAgXCLwn5SsXCIsXG4gIFwi8J+UrVwiLFxuICBcIvCflK5cIixcbiAgXCLwn5SvXCIsXG4gIFwi8J+UsFwiLFxuICBcIvCflLFcIixcbiAgXCLwn5SyXCIsXG4gIFwi8J+Us1wiLFxuICBcIvCflLRcIixcbiAgXCLwn5S1XCIsXG4gIFwi8J+UtlwiLFxuICBcIvCflLdcIixcbiAgXCLwn5S4XCIsXG4gIFwi8J+UuVwiLFxuICBcIvCflLpcIixcbiAgXCLwn5S7XCIsXG4gIFwi8J+UvFwiLFxuICBcIvCflL1cIixcbiAgXCLwn5WJXCIsXG4gIFwi8J+VilwiLFxuICBcIvCflYtcIixcbiAgXCLwn5WMXCIsXG4gIFwi8J+VjVwiLFxuICBcIvCflY5cIixcbiAgXCLwn5WQXCIsXG4gIFwi8J+VkVwiLFxuICBcIvCflZJcIixcbiAgXCLwn5WTXCIsXG4gIFwi8J+VlFwiLFxuICBcIvCflZVcIixcbiAgXCLwn5WWXCIsXG4gIFwi8J+Vl1wiLFxuICBcIvCflZhcIixcbiAgXCLwn5WZXCIsXG4gIFwi8J+VmlwiLFxuICBcIvCflZtcIixcbiAgXCLwn5WcXCIsXG4gIFwi8J+VnVwiLFxuICBcIvCflZ5cIixcbiAgXCLwn5WfXCIsXG4gIFwi8J+VoFwiLFxuICBcIvCflaFcIixcbiAgXCLwn5WiXCIsXG4gIFwi8J+Vo1wiLFxuICBcIvCflaRcIixcbiAgXCLwn5WlXCIsXG4gIFwi8J+VplwiLFxuICBcIvCfladcIixcbiAgXCLwn5WvXCIsXG4gIFwi8J+VsFwiLFxuICBcIvCflbNcIixcbiAgXCLwn5W08J+Pu1wiLFxuICBcIvCflbTwn4+8XCIsXG4gIFwi8J+VtPCfj71cIixcbiAgXCLwn5W08J+PvlwiLFxuICBcIvCflbTwn4+/XCIsXG4gIFwi8J+VtFwiLFxuICBcIvCflbXwn4+74oCN4pmA77iPXCIsXG4gIFwi8J+VtfCfj7vigI3imYLvuI9cIixcbiAgXCLwn5W18J+Pu1wiLFxuICBcIvCflbXwn4+84oCN4pmA77iPXCIsXG4gIFwi8J+VtfCfj7zigI3imYLvuI9cIixcbiAgXCLwn5W18J+PvFwiLFxuICBcIvCflbXwn4+94oCN4pmA77iPXCIsXG4gIFwi8J+VtfCfj73igI3imYLvuI9cIixcbiAgXCLwn5W18J+PvVwiLFxuICBcIvCflbXwn4++4oCN4pmA77iPXCIsXG4gIFwi8J+VtfCfj77igI3imYLvuI9cIixcbiAgXCLwn5W18J+PvlwiLFxuICBcIvCflbXwn4+/4oCN4pmA77iPXCIsXG4gIFwi8J+VtfCfj7/igI3imYLvuI9cIixcbiAgXCLwn5W18J+Pv1wiLFxuICBcIvCflbXvuI/igI3imYDvuI9cIixcbiAgXCLwn5W177iP4oCN4pmC77iPXCIsXG4gIFwi8J+VtVwiLFxuICBcIvCflbZcIixcbiAgXCLwn5W3XCIsXG4gIFwi8J+VuFwiLFxuICBcIvCflblcIixcbiAgXCLwn5W68J+Pu1wiLFxuICBcIvCflbrwn4+8XCIsXG4gIFwi8J+VuvCfj71cIixcbiAgXCLwn5W68J+PvlwiLFxuICBcIvCflbrwn4+/XCIsXG4gIFwi8J+VulwiLFxuICBcIvCflodcIixcbiAgXCLwn5aKXCIsXG4gIFwi8J+Wi1wiLFxuICBcIvCfloxcIixcbiAgXCLwn5aNXCIsXG4gIFwi8J+WkPCfj7tcIixcbiAgXCLwn5aQ8J+PvFwiLFxuICBcIvCflpDwn4+9XCIsXG4gIFwi8J+WkPCfj75cIixcbiAgXCLwn5aQ8J+Pv1wiLFxuICBcIvCflpBcIixcbiAgXCLwn5aV8J+Pu1wiLFxuICBcIvCflpXwn4+8XCIsXG4gIFwi8J+WlfCfj71cIixcbiAgXCLwn5aV8J+PvlwiLFxuICBcIvCflpXwn4+/XCIsXG4gIFwi8J+WlVwiLFxuICBcIvCflpbwn4+7XCIsXG4gIFwi8J+WlvCfj7xcIixcbiAgXCLwn5aW8J+PvVwiLFxuICBcIvCflpbwn4++XCIsXG4gIFwi8J+WlvCfj79cIixcbiAgXCLwn5aWXCIsXG4gIFwi8J+WpFwiLFxuICBcIvCflqVcIixcbiAgXCLwn5aoXCIsXG4gIFwi8J+WsVwiLFxuICBcIvCflrJcIixcbiAgXCLwn5a8XCIsXG4gIFwi8J+XglwiLFxuICBcIvCfl4NcIixcbiAgXCLwn5eEXCIsXG4gIFwi8J+XkVwiLFxuICBcIvCfl5JcIixcbiAgXCLwn5eTXCIsXG4gIFwi8J+XnFwiLFxuICBcIvCfl51cIixcbiAgXCLwn5eeXCIsXG4gIFwi8J+XoVwiLFxuICBcIvCfl6NcIixcbiAgXCLwn5eoXCIsXG4gIFwi8J+Xr1wiLFxuICBcIvCfl7NcIixcbiAgXCLwn5e6XCIsXG4gIFwi8J+Xu1wiLFxuICBcIvCfl7xcIixcbiAgXCLwn5e9XCIsXG4gIFwi8J+XvlwiLFxuICBcIvCfl79cIixcbiAgXCLwn5iAXCIsXG4gIFwi8J+YgVwiLFxuICBcIvCfmIJcIixcbiAgXCLwn5iDXCIsXG4gIFwi8J+YhFwiLFxuICBcIvCfmIVcIixcbiAgXCLwn5iGXCIsXG4gIFwi8J+Yh1wiLFxuICBcIvCfmIhcIixcbiAgXCLwn5iJXCIsXG4gIFwi8J+YilwiLFxuICBcIvCfmItcIixcbiAgXCLwn5iMXCIsXG4gIFwi8J+YjVwiLFxuICBcIvCfmI5cIixcbiAgXCLwn5iPXCIsXG4gIFwi8J+YkFwiLFxuICBcIvCfmJFcIixcbiAgXCLwn5iSXCIsXG4gIFwi8J+Yk1wiLFxuICBcIvCfmJRcIixcbiAgXCLwn5iVXCIsXG4gIFwi8J+YllwiLFxuICBcIvCfmJdcIixcbiAgXCLwn5iYXCIsXG4gIFwi8J+YmVwiLFxuICBcIvCfmJpcIixcbiAgXCLwn5ibXCIsXG4gIFwi8J+YnFwiLFxuICBcIvCfmJ1cIixcbiAgXCLwn5ieXCIsXG4gIFwi8J+Yn1wiLFxuICBcIvCfmKBcIixcbiAgXCLwn5ihXCIsXG4gIFwi8J+YolwiLFxuICBcIvCfmKNcIixcbiAgXCLwn5ikXCIsXG4gIFwi8J+YpVwiLFxuICBcIvCfmKZcIixcbiAgXCLwn5inXCIsXG4gIFwi8J+YqFwiLFxuICBcIvCfmKlcIixcbiAgXCLwn5iqXCIsXG4gIFwi8J+Yq1wiLFxuICBcIvCfmKxcIixcbiAgXCLwn5itXCIsXG4gIFwi8J+YrlwiLFxuICBcIvCfmK9cIixcbiAgXCLwn5iwXCIsXG4gIFwi8J+YsVwiLFxuICBcIvCfmLJcIixcbiAgXCLwn5izXCIsXG4gIFwi8J+YtFwiLFxuICBcIvCfmLVcIixcbiAgXCLwn5i2XCIsXG4gIFwi8J+Yt1wiLFxuICBcIvCfmLhcIixcbiAgXCLwn5i5XCIsXG4gIFwi8J+YulwiLFxuICBcIvCfmLtcIixcbiAgXCLwn5i8XCIsXG4gIFwi8J+YvVwiLFxuICBcIvCfmL5cIixcbiAgXCLwn5i/XCIsXG4gIFwi8J+ZgFwiLFxuICBcIvCfmYFcIixcbiAgXCLwn5mCXCIsXG4gIFwi8J+Zg1wiLFxuICBcIvCfmYRcIixcbiAgXCLwn5mF8J+Pu+KAjeKZgO+4j1wiLFxuICBcIvCfmYXwn4+74oCN4pmC77iPXCIsXG4gIFwi8J+ZhfCfj7tcIixcbiAgXCLwn5mF8J+PvOKAjeKZgO+4j1wiLFxuICBcIvCfmYXwn4+84oCN4pmC77iPXCIsXG4gIFwi8J+ZhfCfj7xcIixcbiAgXCLwn5mF8J+PveKAjeKZgO+4j1wiLFxuICBcIvCfmYXwn4+94oCN4pmC77iPXCIsXG4gIFwi8J+ZhfCfj71cIixcbiAgXCLwn5mF8J+PvuKAjeKZgO+4j1wiLFxuICBcIvCfmYXwn4++4oCN4pmC77iPXCIsXG4gIFwi8J+ZhfCfj75cIixcbiAgXCLwn5mF8J+Pv+KAjeKZgO+4j1wiLFxuICBcIvCfmYXwn4+/4oCN4pmC77iPXCIsXG4gIFwi8J+ZhfCfj79cIixcbiAgXCLwn5mF4oCN4pmA77iPXCIsXG4gIFwi8J+ZheKAjeKZgu+4j1wiLFxuICBcIvCfmYVcIixcbiAgXCLwn5mG8J+Pu+KAjeKZgO+4j1wiLFxuICBcIvCfmYbwn4+74oCN4pmC77iPXCIsXG4gIFwi8J+ZhvCfj7tcIixcbiAgXCLwn5mG8J+PvOKAjeKZgO+4j1wiLFxuICBcIvCfmYbwn4+84oCN4pmC77iPXCIsXG4gIFwi8J+ZhvCfj7xcIixcbiAgXCLwn5mG8J+PveKAjeKZgO+4j1wiLFxuICBcIvCfmYbwn4+94oCN4pmC77iPXCIsXG4gIFwi8J+ZhvCfj71cIixcbiAgXCLwn5mG8J+PvuKAjeKZgO+4j1wiLFxuICBcIvCfmYbwn4++4oCN4pmC77iPXCIsXG4gIFwi8J+ZhvCfj75cIixcbiAgXCLwn5mG8J+Pv+KAjeKZgO+4j1wiLFxuICBcIvCfmYbwn4+/4oCN4pmC77iPXCIsXG4gIFwi8J+ZhvCfj79cIixcbiAgXCLwn5mG4oCN4pmA77iPXCIsXG4gIFwi8J+ZhuKAjeKZgu+4j1wiLFxuICBcIvCfmYZcIixcbiAgXCLwn5mH8J+Pu+KAjeKZgO+4j1wiLFxuICBcIvCfmYfwn4+74oCN4pmC77iPXCIsXG4gIFwi8J+Zh/Cfj7tcIixcbiAgXCLwn5mH8J+PvOKAjeKZgO+4j1wiLFxuICBcIvCfmYfwn4+84oCN4pmC77iPXCIsXG4gIFwi8J+Zh/Cfj7xcIixcbiAgXCLwn5mH8J+PveKAjeKZgO+4j1wiLFxuICBcIvCfmYfwn4+94oCN4pmC77iPXCIsXG4gIFwi8J+Zh/Cfj71cIixcbiAgXCLwn5mH8J+PvuKAjeKZgO+4j1wiLFxuICBcIvCfmYfwn4++4oCN4pmC77iPXCIsXG4gIFwi8J+Zh/Cfj75cIixcbiAgXCLwn5mH8J+Pv+KAjeKZgO+4j1wiLFxuICBcIvCfmYfwn4+/4oCN4pmC77iPXCIsXG4gIFwi8J+Zh/Cfj79cIixcbiAgXCLwn5mH4oCN4pmA77iPXCIsXG4gIFwi8J+Zh+KAjeKZgu+4j1wiLFxuICBcIvCfmYdcIixcbiAgXCLwn5mIXCIsXG4gIFwi8J+ZiVwiLFxuICBcIvCfmYpcIixcbiAgXCLwn5mL8J+Pu+KAjeKZgO+4j1wiLFxuICBcIvCfmYvwn4+74oCN4pmC77iPXCIsXG4gIFwi8J+Zi/Cfj7tcIixcbiAgXCLwn5mL8J+PvOKAjeKZgO+4j1wiLFxuICBcIvCfmYvwn4+84oCN4pmC77iPXCIsXG4gIFwi8J+Zi/Cfj7xcIixcbiAgXCLwn5mL8J+PveKAjeKZgO+4j1wiLFxuICBcIvCfmYvwn4+94oCN4pmC77iPXCIsXG4gIFwi8J+Zi/Cfj71cIixcbiAgXCLwn5mL8J+PvuKAjeKZgO+4j1wiLFxuICBcIvCfmYvwn4++4oCN4pmC77iPXCIsXG4gIFwi8J+Zi/Cfj75cIixcbiAgXCLwn5mL8J+Pv+KAjeKZgO+4j1wiLFxuICBcIvCfmYvwn4+/4oCN4pmC77iPXCIsXG4gIFwi8J+Zi/Cfj79cIixcbiAgXCLwn5mL4oCN4pmA77iPXCIsXG4gIFwi8J+Zi+KAjeKZgu+4j1wiLFxuICBcIvCfmYtcIixcbiAgXCLwn5mM8J+Pu1wiLFxuICBcIvCfmYzwn4+8XCIsXG4gIFwi8J+ZjPCfj71cIixcbiAgXCLwn5mM8J+PvlwiLFxuICBcIvCfmYzwn4+/XCIsXG4gIFwi8J+ZjFwiLFxuICBcIvCfmY3wn4+74oCN4pmA77iPXCIsXG4gIFwi8J+ZjfCfj7vigI3imYLvuI9cIixcbiAgXCLwn5mN8J+Pu1wiLFxuICBcIvCfmY3wn4+84oCN4pmA77iPXCIsXG4gIFwi8J+ZjfCfj7zigI3imYLvuI9cIixcbiAgXCLwn5mN8J+PvFwiLFxuICBcIvCfmY3wn4+94oCN4pmA77iPXCIsXG4gIFwi8J+ZjfCfj73igI3imYLvuI9cIixcbiAgXCLwn5mN8J+PvVwiLFxuICBcIvCfmY3wn4++4oCN4pmA77iPXCIsXG4gIFwi8J+ZjfCfj77igI3imYLvuI9cIixcbiAgXCLwn5mN8J+PvlwiLFxuICBcIvCfmY3wn4+/4oCN4pmA77iPXCIsXG4gIFwi8J+ZjfCfj7/igI3imYLvuI9cIixcbiAgXCLwn5mN8J+Pv1wiLFxuICBcIvCfmY3igI3imYDvuI9cIixcbiAgXCLwn5mN4oCN4pmC77iPXCIsXG4gIFwi8J+ZjVwiLFxuICBcIvCfmY7wn4+74oCN4pmA77iPXCIsXG4gIFwi8J+ZjvCfj7vigI3imYLvuI9cIixcbiAgXCLwn5mO8J+Pu1wiLFxuICBcIvCfmY7wn4+84oCN4pmA77iPXCIsXG4gIFwi8J+ZjvCfj7zigI3imYLvuI9cIixcbiAgXCLwn5mO8J+PvFwiLFxuICBcIvCfmY7wn4+94oCN4pmA77iPXCIsXG4gIFwi8J+ZjvCfj73igI3imYLvuI9cIixcbiAgXCLwn5mO8J+PvVwiLFxuICBcIvCfmY7wn4++4oCN4pmA77iPXCIsXG4gIFwi8J+ZjvCfj77igI3imYLvuI9cIixcbiAgXCLwn5mO8J+PvlwiLFxuICBcIvCfmY7wn4+/4oCN4pmA77iPXCIsXG4gIFwi8J+ZjvCfj7/igI3imYLvuI9cIixcbiAgXCLwn5mO8J+Pv1wiLFxuICBcIvCfmY7igI3imYDvuI9cIixcbiAgXCLwn5mO4oCN4pmC77iPXCIsXG4gIFwi8J+ZjlwiLFxuICBcIvCfmY/wn4+7XCIsXG4gIFwi8J+Zj/Cfj7xcIixcbiAgXCLwn5mP8J+PvVwiLFxuICBcIvCfmY/wn4++XCIsXG4gIFwi8J+Zj/Cfj79cIixcbiAgXCLwn5mPXCIsXG4gIFwi8J+agFwiLFxuICBcIvCfmoFcIixcbiAgXCLwn5qCXCIsXG4gIFwi8J+ag1wiLFxuICBcIvCfmoRcIixcbiAgXCLwn5qFXCIsXG4gIFwi8J+ahlwiLFxuICBcIvCfmodcIixcbiAgXCLwn5qIXCIsXG4gIFwi8J+aiVwiLFxuICBcIvCfmopcIixcbiAgXCLwn5qLXCIsXG4gIFwi8J+ajFwiLFxuICBcIvCfmo1cIixcbiAgXCLwn5qOXCIsXG4gIFwi8J+aj1wiLFxuICBcIvCfmpBcIixcbiAgXCLwn5qRXCIsXG4gIFwi8J+aklwiLFxuICBcIvCfmpNcIixcbiAgXCLwn5qUXCIsXG4gIFwi8J+alVwiLFxuICBcIvCfmpZcIixcbiAgXCLwn5qXXCIsXG4gIFwi8J+amFwiLFxuICBcIvCfmplcIixcbiAgXCLwn5qaXCIsXG4gIFwi8J+am1wiLFxuICBcIvCfmpxcIixcbiAgXCLwn5qdXCIsXG4gIFwi8J+anlwiLFxuICBcIvCfmp9cIixcbiAgXCLwn5qgXCIsXG4gIFwi8J+aoVwiLFxuICBcIvCfmqJcIixcbiAgXCLwn5qj8J+Pu+KAjeKZgO+4j1wiLFxuICBcIvCfmqPwn4+74oCN4pmC77iPXCIsXG4gIFwi8J+ao/Cfj7tcIixcbiAgXCLwn5qj8J+PvOKAjeKZgO+4j1wiLFxuICBcIvCfmqPwn4+84oCN4pmC77iPXCIsXG4gIFwi8J+ao/Cfj7xcIixcbiAgXCLwn5qj8J+PveKAjeKZgO+4j1wiLFxuICBcIvCfmqPwn4+94oCN4pmC77iPXCIsXG4gIFwi8J+ao/Cfj71cIixcbiAgXCLwn5qj8J+PvuKAjeKZgO+4j1wiLFxuICBcIvCfmqPwn4++4oCN4pmC77iPXCIsXG4gIFwi8J+ao/Cfj75cIixcbiAgXCLwn5qj8J+Pv+KAjeKZgO+4j1wiLFxuICBcIvCfmqPwn4+/4oCN4pmC77iPXCIsXG4gIFwi8J+ao/Cfj79cIixcbiAgXCLwn5qj4oCN4pmA77iPXCIsXG4gIFwi8J+ao+KAjeKZgu+4j1wiLFxuICBcIvCfmqNcIixcbiAgXCLwn5qkXCIsXG4gIFwi8J+apVwiLFxuICBcIvCfmqZcIixcbiAgXCLwn5qnXCIsXG4gIFwi8J+aqFwiLFxuICBcIvCfmqlcIixcbiAgXCLwn5qqXCIsXG4gIFwi8J+aq1wiLFxuICBcIvCfmqxcIixcbiAgXCLwn5qtXCIsXG4gIFwi8J+arlwiLFxuICBcIvCfmq9cIixcbiAgXCLwn5qwXCIsXG4gIFwi8J+asVwiLFxuICBcIvCfmrJcIixcbiAgXCLwn5qzXCIsXG4gIFwi8J+atPCfj7vigI3imYDvuI9cIixcbiAgXCLwn5q08J+Pu+KAjeKZgu+4j1wiLFxuICBcIvCfmrTwn4+7XCIsXG4gIFwi8J+atPCfj7zigI3imYDvuI9cIixcbiAgXCLwn5q08J+PvOKAjeKZgu+4j1wiLFxuICBcIvCfmrTwn4+8XCIsXG4gIFwi8J+atPCfj73igI3imYDvuI9cIixcbiAgXCLwn5q08J+PveKAjeKZgu+4j1wiLFxuICBcIvCfmrTwn4+9XCIsXG4gIFwi8J+atPCfj77igI3imYDvuI9cIixcbiAgXCLwn5q08J+PvuKAjeKZgu+4j1wiLFxuICBcIvCfmrTwn4++XCIsXG4gIFwi8J+atPCfj7/igI3imYDvuI9cIixcbiAgXCLwn5q08J+Pv+KAjeKZgu+4j1wiLFxuICBcIvCfmrTwn4+/XCIsXG4gIFwi8J+atOKAjeKZgO+4j1wiLFxuICBcIvCfmrTigI3imYLvuI9cIixcbiAgXCLwn5q0XCIsXG4gIFwi8J+atfCfj7vigI3imYDvuI9cIixcbiAgXCLwn5q18J+Pu+KAjeKZgu+4j1wiLFxuICBcIvCfmrXwn4+7XCIsXG4gIFwi8J+atfCfj7zigI3imYDvuI9cIixcbiAgXCLwn5q18J+PvOKAjeKZgu+4j1wiLFxuICBcIvCfmrXwn4+8XCIsXG4gIFwi8J+atfCfj73igI3imYDvuI9cIixcbiAgXCLwn5q18J+PveKAjeKZgu+4j1wiLFxuICBcIvCfmrXwn4+9XCIsXG4gIFwi8J+atfCfj77igI3imYDvuI9cIixcbiAgXCLwn5q18J+PvuKAjeKZgu+4j1wiLFxuICBcIvCfmrXwn4++XCIsXG4gIFwi8J+atfCfj7/igI3imYDvuI9cIixcbiAgXCLwn5q18J+Pv+KAjeKZgu+4j1wiLFxuICBcIvCfmrXwn4+/XCIsXG4gIFwi8J+ateKAjeKZgO+4j1wiLFxuICBcIvCfmrXigI3imYLvuI9cIixcbiAgXCLwn5q1XCIsXG4gIFwi8J+atvCfj7vigI3imYDvuI9cIixcbiAgXCLwn5q28J+Pu+KAjeKZgu+4j1wiLFxuICBcIvCfmrbwn4+7XCIsXG4gIFwi8J+atvCfj7zigI3imYDvuI9cIixcbiAgXCLwn5q28J+PvOKAjeKZgu+4j1wiLFxuICBcIvCfmrbwn4+8XCIsXG4gIFwi8J+atvCfj73igI3imYDvuI9cIixcbiAgXCLwn5q28J+PveKAjeKZgu+4j1wiLFxuICBcIvCfmrbwn4+9XCIsXG4gIFwi8J+atvCfj77igI3imYDvuI9cIixcbiAgXCLwn5q28J+PvuKAjeKZgu+4j1wiLFxuICBcIvCfmrbwn4++XCIsXG4gIFwi8J+atvCfj7/igI3imYDvuI9cIixcbiAgXCLwn5q28J+Pv+KAjeKZgu+4j1wiLFxuICBcIvCfmrbwn4+/XCIsXG4gIFwi8J+atuKAjeKZgO+4j1wiLFxuICBcIvCfmrbigI3imYLvuI9cIixcbiAgXCLwn5q2XCIsXG4gIFwi8J+at1wiLFxuICBcIvCfmrhcIixcbiAgXCLwn5q5XCIsXG4gIFwi8J+aulwiLFxuICBcIvCfmrtcIixcbiAgXCLwn5q8XCIsXG4gIFwi8J+avVwiLFxuICBcIvCfmr5cIixcbiAgXCLwn5q/XCIsXG4gIFwi8J+bgPCfj7tcIixcbiAgXCLwn5uA8J+PvFwiLFxuICBcIvCfm4Dwn4+9XCIsXG4gIFwi8J+bgPCfj75cIixcbiAgXCLwn5uA8J+Pv1wiLFxuICBcIvCfm4BcIixcbiAgXCLwn5uBXCIsXG4gIFwi8J+bglwiLFxuICBcIvCfm4NcIixcbiAgXCLwn5uEXCIsXG4gIFwi8J+bhVwiLFxuICBcIvCfm4tcIixcbiAgXCLwn5uM8J+Pu1wiLFxuICBcIvCfm4zwn4+8XCIsXG4gIFwi8J+bjPCfj71cIixcbiAgXCLwn5uM8J+PvlwiLFxuICBcIvCfm4zwn4+/XCIsXG4gIFwi8J+bjFwiLFxuICBcIvCfm41cIixcbiAgXCLwn5uOXCIsXG4gIFwi8J+bj1wiLFxuICBcIvCfm5BcIixcbiAgXCLwn5uRXCIsXG4gIFwi8J+bklwiLFxuICBcIvCfm6BcIixcbiAgXCLwn5uhXCIsXG4gIFwi8J+bolwiLFxuICBcIvCfm6NcIixcbiAgXCLwn5ukXCIsXG4gIFwi8J+bpVwiLFxuICBcIvCfm6lcIixcbiAgXCLwn5urXCIsXG4gIFwi8J+brFwiLFxuICBcIvCfm7BcIixcbiAgXCLwn5uzXCIsXG4gIFwi8J+btFwiLFxuICBcIvCfm7VcIixcbiAgXCLwn5u2XCIsXG4gIFwi8J+kkFwiLFxuICBcIvCfpJFcIixcbiAgXCLwn6SSXCIsXG4gIFwi8J+kk1wiLFxuICBcIvCfpJRcIixcbiAgXCLwn6SVXCIsXG4gIFwi8J+kllwiLFxuICBcIvCfpJdcIixcbiAgXCLwn6SY8J+Pu1wiLFxuICBcIvCfpJjwn4+8XCIsXG4gIFwi8J+kmPCfj71cIixcbiAgXCLwn6SY8J+PvlwiLFxuICBcIvCfpJjwn4+/XCIsXG4gIFwi8J+kmFwiLFxuICBcIvCfpJnwn4+7XCIsXG4gIFwi8J+kmfCfj7xcIixcbiAgXCLwn6SZ8J+PvVwiLFxuICBcIvCfpJnwn4++XCIsXG4gIFwi8J+kmfCfj79cIixcbiAgXCLwn6SZXCIsXG4gIFwi8J+kmvCfj7tcIixcbiAgXCLwn6Sa8J+PvFwiLFxuICBcIvCfpJrwn4+9XCIsXG4gIFwi8J+kmvCfj75cIixcbiAgXCLwn6Sa8J+Pv1wiLFxuICBcIvCfpJpcIixcbiAgXCLwn6Sb8J+Pu1wiLFxuICBcIvCfpJvwn4+8XCIsXG4gIFwi8J+km/Cfj71cIixcbiAgXCLwn6Sb8J+PvlwiLFxuICBcIvCfpJvwn4+/XCIsXG4gIFwi8J+km1wiLFxuICBcIvCfpJzwn4+7XCIsXG4gIFwi8J+knPCfj7xcIixcbiAgXCLwn6Sc8J+PvVwiLFxuICBcIvCfpJzwn4++XCIsXG4gIFwi8J+knPCfj79cIixcbiAgXCLwn6ScXCIsXG4gIFwi8J+knfCfj7tcIixcbiAgXCLwn6Sd8J+PvFwiLFxuICBcIvCfpJ3wn4+9XCIsXG4gIFwi8J+knfCfj75cIixcbiAgXCLwn6Sd8J+Pv1wiLFxuICBcIvCfpJ1cIixcbiAgXCLwn6Se8J+Pu1wiLFxuICBcIvCfpJ7wn4+8XCIsXG4gIFwi8J+knvCfj71cIixcbiAgXCLwn6Se8J+PvlwiLFxuICBcIvCfpJ7wn4+/XCIsXG4gIFwi8J+knlwiLFxuICBcIvCfpKBcIixcbiAgXCLwn6ShXCIsXG4gIFwi8J+kolwiLFxuICBcIvCfpKNcIixcbiAgXCLwn6SkXCIsXG4gIFwi8J+kpVwiLFxuICBcIvCfpKbwn4+74oCN4pmA77iPXCIsXG4gIFwi8J+kpvCfj7vigI3imYLvuI9cIixcbiAgXCLwn6Sm8J+Pu1wiLFxuICBcIvCfpKbwn4+84oCN4pmA77iPXCIsXG4gIFwi8J+kpvCfj7zigI3imYLvuI9cIixcbiAgXCLwn6Sm8J+PvFwiLFxuICBcIvCfpKbwn4+94oCN4pmA77iPXCIsXG4gIFwi8J+kpvCfj73igI3imYLvuI9cIixcbiAgXCLwn6Sm8J+PvVwiLFxuICBcIvCfpKbwn4++4oCN4pmA77iPXCIsXG4gIFwi8J+kpvCfj77igI3imYLvuI9cIixcbiAgXCLwn6Sm8J+PvlwiLFxuICBcIvCfpKbwn4+/4oCN4pmA77iPXCIsXG4gIFwi8J+kpvCfj7/igI3imYLvuI9cIixcbiAgXCLwn6Sm8J+Pv1wiLFxuICBcIvCfpKbigI3imYDvuI9cIixcbiAgXCLwn6Sm4oCN4pmC77iPXCIsXG4gIFwi8J+kplwiLFxuICBcIvCfpKdcIixcbiAgXCLwn6Sw8J+Pu1wiLFxuICBcIvCfpLDwn4+8XCIsXG4gIFwi8J+ksPCfj71cIixcbiAgXCLwn6Sw8J+PvlwiLFxuICBcIvCfpLDwn4+/XCIsXG4gIFwi8J+ksFwiLFxuICBcIvCfpLPwn4+7XCIsXG4gIFwi8J+ks/Cfj7xcIixcbiAgXCLwn6Sz8J+PvVwiLFxuICBcIvCfpLPwn4++XCIsXG4gIFwi8J+ks/Cfj79cIixcbiAgXCLwn6SzXCIsXG4gIFwi8J+ktPCfj7tcIixcbiAgXCLwn6S08J+PvFwiLFxuICBcIvCfpLTwn4+9XCIsXG4gIFwi8J+ktPCfj75cIixcbiAgXCLwn6S08J+Pv1wiLFxuICBcIvCfpLRcIixcbiAgXCLwn6S18J+Pu1wiLFxuICBcIvCfpLXwn4+8XCIsXG4gIFwi8J+ktfCfj71cIixcbiAgXCLwn6S18J+PvlwiLFxuICBcIvCfpLXwn4+/XCIsXG4gIFwi8J+ktVwiLFxuICBcIvCfpLbwn4+7XCIsXG4gIFwi8J+ktvCfj7xcIixcbiAgXCLwn6S28J+PvVwiLFxuICBcIvCfpLbwn4++XCIsXG4gIFwi8J+ktvCfj79cIixcbiAgXCLwn6S2XCIsXG4gIFwi8J+kt/Cfj7vigI3imYDvuI9cIixcbiAgXCLwn6S38J+Pu+KAjeKZgu+4j1wiLFxuICBcIvCfpLfwn4+7XCIsXG4gIFwi8J+kt/Cfj7zigI3imYDvuI9cIixcbiAgXCLwn6S38J+PvOKAjeKZgu+4j1wiLFxuICBcIvCfpLfwn4+8XCIsXG4gIFwi8J+kt/Cfj73igI3imYDvuI9cIixcbiAgXCLwn6S38J+PveKAjeKZgu+4j1wiLFxuICBcIvCfpLfwn4+9XCIsXG4gIFwi8J+kt/Cfj77igI3imYDvuI9cIixcbiAgXCLwn6S38J+PvuKAjeKZgu+4j1wiLFxuICBcIvCfpLfwn4++XCIsXG4gIFwi8J+kt/Cfj7/igI3imYDvuI9cIixcbiAgXCLwn6S38J+Pv+KAjeKZgu+4j1wiLFxuICBcIvCfpLfwn4+/XCIsXG4gIFwi8J+kt+KAjeKZgO+4j1wiLFxuICBcIvCfpLfigI3imYLvuI9cIixcbiAgXCLwn6S3XCIsXG4gIFwi8J+kuPCfj7vigI3imYDvuI9cIixcbiAgXCLwn6S48J+Pu+KAjeKZgu+4j1wiLFxuICBcIvCfpLjwn4+7XCIsXG4gIFwi8J+kuPCfj7zigI3imYDvuI9cIixcbiAgXCLwn6S48J+PvOKAjeKZgu+4j1wiLFxuICBcIvCfpLjwn4+8XCIsXG4gIFwi8J+kuPCfj73igI3imYDvuI9cIixcbiAgXCLwn6S48J+PveKAjeKZgu+4j1wiLFxuICBcIvCfpLjwn4+9XCIsXG4gIFwi8J+kuPCfj77igI3imYDvuI9cIixcbiAgXCLwn6S48J+PvuKAjeKZgu+4j1wiLFxuICBcIvCfpLjwn4++XCIsXG4gIFwi8J+kuPCfj7/igI3imYDvuI9cIixcbiAgXCLwn6S48J+Pv+KAjeKZgu+4j1wiLFxuICBcIvCfpLjwn4+/XCIsXG4gIFwi8J+kuOKAjeKZgO+4j1wiLFxuICBcIvCfpLjigI3imYLvuI9cIixcbiAgXCLwn6S4XCIsXG4gIFwi8J+kufCfj7vigI3imYDvuI9cIixcbiAgXCLwn6S58J+Pu+KAjeKZgu+4j1wiLFxuICBcIvCfpLnwn4+7XCIsXG4gIFwi8J+kufCfj7zigI3imYDvuI9cIixcbiAgXCLwn6S58J+PvOKAjeKZgu+4j1wiLFxuICBcIvCfpLnwn4+8XCIsXG4gIFwi8J+kufCfj73igI3imYDvuI9cIixcbiAgXCLwn6S58J+PveKAjeKZgu+4j1wiLFxuICBcIvCfpLnwn4+9XCIsXG4gIFwi8J+kufCfj77igI3imYDvuI9cIixcbiAgXCLwn6S58J+PvuKAjeKZgu+4j1wiLFxuICBcIvCfpLnwn4++XCIsXG4gIFwi8J+kufCfj7/igI3imYDvuI9cIixcbiAgXCLwn6S58J+Pv+KAjeKZgu+4j1wiLFxuICBcIvCfpLnwn4+/XCIsXG4gIFwi8J+kueKAjeKZgO+4j1wiLFxuICBcIvCfpLnigI3imYLvuI9cIixcbiAgXCLwn6S5XCIsXG4gIFwi8J+kulwiLFxuICBcIvCfpLzwn4+74oCN4pmA77iPXCIsXG4gIFwi8J+kvPCfj7vigI3imYLvuI9cIixcbiAgXCLwn6S88J+Pu1wiLFxuICBcIvCfpLzwn4+84oCN4pmA77iPXCIsXG4gIFwi8J+kvPCfj7zigI3imYLvuI9cIixcbiAgXCLwn6S88J+PvFwiLFxuICBcIvCfpLzwn4+94oCN4pmA77iPXCIsXG4gIFwi8J+kvPCfj73igI3imYLvuI9cIixcbiAgXCLwn6S88J+PvVwiLFxuICBcIvCfpLzwn4++4oCN4pmA77iPXCIsXG4gIFwi8J+kvPCfj77igI3imYLvuI9cIixcbiAgXCLwn6S88J+PvlwiLFxuICBcIvCfpLzwn4+/4oCN4pmA77iPXCIsXG4gIFwi8J+kvPCfj7/igI3imYLvuI9cIixcbiAgXCLwn6S88J+Pv1wiLFxuICBcIvCfpLzigI3imYDvuI9cIixcbiAgXCLwn6S84oCN4pmC77iPXCIsXG4gIFwi8J+kvFwiLFxuICBcIvCfpL3wn4+74oCN4pmA77iPXCIsXG4gIFwi8J+kvfCfj7vigI3imYLvuI9cIixcbiAgXCLwn6S98J+Pu1wiLFxuICBcIvCfpL3wn4+84oCN4pmA77iPXCIsXG4gIFwi8J+kvfCfj7zigI3imYLvuI9cIixcbiAgXCLwn6S98J+PvFwiLFxuICBcIvCfpL3wn4+94oCN4pmA77iPXCIsXG4gIFwi8J+kvfCfj73igI3imYLvuI9cIixcbiAgXCLwn6S98J+PvVwiLFxuICBcIvCfpL3wn4++4oCN4pmA77iPXCIsXG4gIFwi8J+kvfCfj77igI3imYLvuI9cIixcbiAgXCLwn6S98J+PvlwiLFxuICBcIvCfpL3wn4+/4oCN4pmA77iPXCIsXG4gIFwi8J+kvfCfj7/igI3imYLvuI9cIixcbiAgXCLwn6S98J+Pv1wiLFxuICBcIvCfpL3igI3imYDvuI9cIixcbiAgXCLwn6S94oCN4pmC77iPXCIsXG4gIFwi8J+kvVwiLFxuICBcIvCfpL7wn4+74oCN4pmA77iPXCIsXG4gIFwi8J+kvvCfj7vigI3imYLvuI9cIixcbiAgXCLwn6S+8J+Pu1wiLFxuICBcIvCfpL7wn4+84oCN4pmA77iPXCIsXG4gIFwi8J+kvvCfj7zigI3imYLvuI9cIixcbiAgXCLwn6S+8J+PvFwiLFxuICBcIvCfpL7wn4+94oCN4pmA77iPXCIsXG4gIFwi8J+kvvCfj73igI3imYLvuI9cIixcbiAgXCLwn6S+8J+PvVwiLFxuICBcIvCfpL7wn4++4oCN4pmA77iPXCIsXG4gIFwi8J+kvvCfj77igI3imYLvuI9cIixcbiAgXCLwn6S+8J+PvlwiLFxuICBcIvCfpL7wn4+/4oCN4pmA77iPXCIsXG4gIFwi8J+kvvCfj7/igI3imYLvuI9cIixcbiAgXCLwn6S+8J+Pv1wiLFxuICBcIvCfpL7igI3imYDvuI9cIixcbiAgXCLwn6S+4oCN4pmC77iPXCIsXG4gIFwi8J+kvlwiLFxuICBcIvCfpYBcIixcbiAgXCLwn6WBXCIsXG4gIFwi8J+lglwiLFxuICBcIvCfpYNcIixcbiAgXCLwn6WEXCIsXG4gIFwi8J+lhVwiLFxuICBcIvCfpYdcIixcbiAgXCLwn6WIXCIsXG4gIFwi8J+liVwiLFxuICBcIvCfpYpcIixcbiAgXCLwn6WLXCIsXG4gIFwi8J+lkFwiLFxuICBcIvCfpZFcIixcbiAgXCLwn6WSXCIsXG4gIFwi8J+lk1wiLFxuICBcIvCfpZRcIixcbiAgXCLwn6WVXCIsXG4gIFwi8J+lllwiLFxuICBcIvCfpZdcIixcbiAgXCLwn6WYXCIsXG4gIFwi8J+lmVwiLFxuICBcIvCfpZpcIixcbiAgXCLwn6WbXCIsXG4gIFwi8J+lnFwiLFxuICBcIvCfpZ1cIixcbiAgXCLwn6WeXCIsXG4gIFwi8J+mgFwiLFxuICBcIvCfpoFcIixcbiAgXCLwn6aCXCIsXG4gIFwi8J+mg1wiLFxuICBcIvCfpoRcIixcbiAgXCLwn6aFXCIsXG4gIFwi8J+mhlwiLFxuICBcIvCfpodcIixcbiAgXCLwn6aIXCIsXG4gIFwi8J+miVwiLFxuICBcIvCfpopcIixcbiAgXCLwn6aLXCIsXG4gIFwi8J+mjFwiLFxuICBcIvCfpo1cIixcbiAgXCLwn6aOXCIsXG4gIFwi8J+mj1wiLFxuICBcIvCfppBcIixcbiAgXCLwn6aRXCIsXG4gIFwi8J+ngFwiLFxuICBcIuKAvFwiLFxuICBcIuKBiVwiLFxuICBcIuKEolwiLFxuICBcIuKEuVwiLFxuICBcIuKGlFwiLFxuICBcIuKGlVwiLFxuICBcIuKGllwiLFxuICBcIuKGl1wiLFxuICBcIuKGmFwiLFxuICBcIuKGmVwiLFxuICBcIuKGqVwiLFxuICBcIuKGqlwiLFxuICBcIiPig6NcIixcbiAgXCLijJpcIixcbiAgXCLijJtcIixcbiAgXCLijKhcIixcbiAgXCLij49cIixcbiAgXCLij6lcIixcbiAgXCLij6pcIixcbiAgXCLij6tcIixcbiAgXCLij6xcIixcbiAgXCLij61cIixcbiAgXCLij65cIixcbiAgXCLij69cIixcbiAgXCLij7BcIixcbiAgXCLij7FcIixcbiAgXCLij7JcIixcbiAgXCLij7NcIixcbiAgXCLij7hcIixcbiAgXCLij7lcIixcbiAgXCLij7pcIixcbiAgXCLik4JcIixcbiAgXCLilqpcIixcbiAgXCLilqtcIixcbiAgXCLilrZcIixcbiAgXCLil4BcIixcbiAgXCLil7tcIixcbiAgXCLil7xcIixcbiAgXCLil71cIixcbiAgXCLil75cIixcbiAgXCLimIBcIixcbiAgXCLimIFcIixcbiAgXCLimIJcIixcbiAgXCLimINcIixcbiAgXCLimIRcIixcbiAgXCLimI5cIixcbiAgXCLimJFcIixcbiAgXCLimJRcIixcbiAgXCLimJVcIixcbiAgXCLimJhcIixcbiAgXCLimJ3wn4+7XCIsXG4gIFwi4pid8J+PvFwiLFxuICBcIuKYnfCfj71cIixcbiAgXCLimJ3wn4++XCIsXG4gIFwi4pid8J+Pv1wiLFxuICBcIuKYnVwiLFxuICBcIuKYoFwiLFxuICBcIuKYolwiLFxuICBcIuKYo1wiLFxuICBcIuKYplwiLFxuICBcIuKYqlwiLFxuICBcIuKYrlwiLFxuICBcIuKYr1wiLFxuICBcIuKYuFwiLFxuICBcIuKYuVwiLFxuICBcIuKYulwiLFxuICBcIuKZgFwiLFxuICBcIuKZglwiLFxuICBcIuKZiFwiLFxuICBcIuKZiVwiLFxuICBcIuKZilwiLFxuICBcIuKZi1wiLFxuICBcIuKZjFwiLFxuICBcIuKZjVwiLFxuICBcIuKZjlwiLFxuICBcIuKZj1wiLFxuICBcIuKZkFwiLFxuICBcIuKZkVwiLFxuICBcIuKZklwiLFxuICBcIuKZk1wiLFxuICBcIuKZoFwiLFxuICBcIuKZo1wiLFxuICBcIuKZpVwiLFxuICBcIuKZplwiLFxuICBcIuKZqFwiLFxuICBcIuKZu1wiLFxuICBcIuKZv1wiLFxuICBcIuKaklwiLFxuICBcIuKak1wiLFxuICBcIuKalFwiLFxuICBcIuKalVwiLFxuICBcIuKallwiLFxuICBcIuKal1wiLFxuICBcIuKamVwiLFxuICBcIuKam1wiLFxuICBcIuKanFwiLFxuICBcIuKaoFwiLFxuICBcIuKaoVwiLFxuICBcIuKaqlwiLFxuICBcIuKaq1wiLFxuICBcIuKasFwiLFxuICBcIuKasVwiLFxuICBcIuKavVwiLFxuICBcIuKavlwiLFxuICBcIuKbhFwiLFxuICBcIuKbhVwiLFxuICBcIuKbiFwiLFxuICBcIuKbjlwiLFxuICBcIuKbj1wiLFxuICBcIuKbkVwiLFxuICBcIuKbk1wiLFxuICBcIuKblFwiLFxuICBcIuKbqVwiLFxuICBcIuKbqlwiLFxuICBcIuKbsFwiLFxuICBcIuKbsVwiLFxuICBcIuKbslwiLFxuICBcIuKbs1wiLFxuICBcIuKbtFwiLFxuICBcIuKbtVwiLFxuICBcIuKbt/Cfj7tcIixcbiAgXCLim7fwn4+8XCIsXG4gIFwi4pu38J+PvVwiLFxuICBcIuKbt/Cfj75cIixcbiAgXCLim7fwn4+/XCIsXG4gIFwi4pu3XCIsXG4gIFwi4pu4XCIsXG4gIFwi4pu58J+Pu+KAjeKZgO+4j1wiLFxuICBcIuKbufCfj7vigI3imYLvuI9cIixcbiAgXCLim7nwn4+7XCIsXG4gIFwi4pu58J+PvOKAjeKZgO+4j1wiLFxuICBcIuKbufCfj7zigI3imYLvuI9cIixcbiAgXCLim7nwn4+8XCIsXG4gIFwi4pu58J+PveKAjeKZgO+4j1wiLFxuICBcIuKbufCfj73igI3imYLvuI9cIixcbiAgXCLim7nwn4+9XCIsXG4gIFwi4pu58J+PvuKAjeKZgO+4j1wiLFxuICBcIuKbufCfj77igI3imYLvuI9cIixcbiAgXCLim7nwn4++XCIsXG4gIFwi4pu58J+Pv+KAjeKZgO+4j1wiLFxuICBcIuKbufCfj7/igI3imYLvuI9cIixcbiAgXCLim7nwn4+/XCIsXG4gIFwi4pu577iP4oCN4pmA77iPXCIsXG4gIFwi4pu577iP4oCN4pmC77iPXCIsXG4gIFwi4pu5XCIsXG4gIFwi4pu6XCIsXG4gIFwi4pu9XCIsXG4gIFwi4pyCXCIsXG4gIFwi4pyFXCIsXG4gIFwi4pyIXCIsXG4gIFwi4pyJXCIsXG4gIFwi4pyK8J+Pu1wiLFxuICBcIuKcivCfj7xcIixcbiAgXCLinIrwn4+9XCIsXG4gIFwi4pyK8J+PvlwiLFxuICBcIuKcivCfj79cIixcbiAgXCLinIpcIixcbiAgXCLinIvwn4+7XCIsXG4gIFwi4pyL8J+PvFwiLFxuICBcIuKci/Cfj71cIixcbiAgXCLinIvwn4++XCIsXG4gIFwi4pyL8J+Pv1wiLFxuICBcIuKci1wiLFxuICBcIuKcjPCfj7tcIixcbiAgXCLinIzwn4+8XCIsXG4gIFwi4pyM8J+PvVwiLFxuICBcIuKcjPCfj75cIixcbiAgXCLinIzwn4+/XCIsXG4gIFwi4pyMXCIsXG4gIFwi4pyN8J+Pu1wiLFxuICBcIuKcjfCfj7xcIixcbiAgXCLinI3wn4+9XCIsXG4gIFwi4pyN8J+PvlwiLFxuICBcIuKcjfCfj79cIixcbiAgXCLinI1cIixcbiAgXCLinI9cIixcbiAgXCLinJJcIixcbiAgXCLinJRcIixcbiAgXCLinJZcIixcbiAgXCLinJ1cIixcbiAgXCLinKFcIixcbiAgXCLinKhcIixcbiAgXCLinLNcIixcbiAgXCLinLRcIixcbiAgXCLinYRcIixcbiAgXCLinYdcIixcbiAgXCLinYxcIixcbiAgXCLinY5cIixcbiAgXCLinZNcIixcbiAgXCLinZRcIixcbiAgXCLinZVcIixcbiAgXCLinZdcIixcbiAgXCLinaNcIixcbiAgXCLinaRcIixcbiAgXCLinpVcIixcbiAgXCLinpZcIixcbiAgXCLinpdcIixcbiAgXCLinqFcIixcbiAgXCLinrBcIixcbiAgXCLinr9cIixcbiAgXCLipLRcIixcbiAgXCLipLVcIixcbiAgXCIq4oOjXCIsXG4gIFwi4qyFXCIsXG4gIFwi4qyGXCIsXG4gIFwi4qyHXCIsXG4gIFwi4qybXCIsXG4gIFwi4qycXCIsXG4gIFwi4q2QXCIsXG4gIFwi4q2VXCIsXG4gIFwiMOKDo1wiLFxuICBcIuOAsFwiLFxuICBcIuOAvVwiLFxuICBcIjHig6NcIixcbiAgXCIy4oOjXCIsXG4gIFwi44qXXCIsXG4gIFwi44qZXCIsXG4gIFwiM+KDo1wiLFxuICBcIjTig6NcIixcbiAgXCI14oOjXCIsXG4gIFwiNuKDo1wiLFxuICBcIjfig6NcIixcbiAgXCI44oOjXCIsXG4gIFwiOeKDo1wiLFxuICBcIsKpXCIsXG4gIFwiwq5cIixcbiAgXCLulIpcIlxuXVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9lbW9qaXMtbGlzdC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIGJpZy5qcyB2My4xLjMgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnLmpzL0xJQ0VOQ0UgKi9cclxuOyhmdW5jdGlvbiAoZ2xvYmFsKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4vKlxyXG4gIGJpZy5qcyB2My4xLjNcclxuICBBIHNtYWxsLCBmYXN0LCBlYXN5LXRvLXVzZSBsaWJyYXJ5IGZvciBhcmJpdHJhcnktcHJlY2lzaW9uIGRlY2ltYWwgYXJpdGhtZXRpYy5cclxuICBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWcuanMvXHJcbiAgQ29weXJpZ2h0IChjKSAyMDE0IE1pY2hhZWwgTWNsYXVnaGxpbiA8TThjaDg4bEBnbWFpbC5jb20+XHJcbiAgTUlUIEV4cGF0IExpY2VuY2VcclxuKi9cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBFRElUQUJMRSBERUZBVUxUUyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4gICAgLy8gVGhlIGRlZmF1bHQgdmFsdWVzIGJlbG93IG11c3QgYmUgaW50ZWdlcnMgd2l0aGluIHRoZSBzdGF0ZWQgcmFuZ2VzLlxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb2YgdGhlIHJlc3VsdHMgb2Ygb3BlcmF0aW9uc1xyXG4gICAgICogaW52b2x2aW5nIGRpdmlzaW9uOiBkaXYgYW5kIHNxcnQsIGFuZCBwb3cgd2l0aCBuZWdhdGl2ZSBleHBvbmVudHMuXHJcbiAgICAgKi9cclxuICAgIHZhciBEUCA9IDIwLCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYX0RQXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogVGhlIHJvdW5kaW5nIG1vZGUgdXNlZCB3aGVuIHJvdW5kaW5nIHRvIHRoZSBhYm92ZSBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIDAgVG93YXJkcyB6ZXJvIChpLmUuIHRydW5jYXRlLCBubyByb3VuZGluZykuICAgICAgIChST1VORF9ET1dOKVxyXG4gICAgICAgICAqIDEgVG8gbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCByb3VuZCB1cC4gIChST1VORF9IQUxGX1VQKVxyXG4gICAgICAgICAqIDIgVG8gbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0byBldmVuLiAgIChST1VORF9IQUxGX0VWRU4pXHJcbiAgICAgICAgICogMyBBd2F5IGZyb20gemVyby4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFJPVU5EX1VQKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJNID0gMSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCwgMSwgMiBvciAzXHJcblxyXG4gICAgICAgIC8vIFRoZSBtYXhpbXVtIHZhbHVlIG9mIERQIGFuZCBCaWcuRFAuXHJcbiAgICAgICAgTUFYX0RQID0gMUU2LCAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDEwMDAwMDBcclxuXHJcbiAgICAgICAgLy8gVGhlIG1heGltdW0gbWFnbml0dWRlIG9mIHRoZSBleHBvbmVudCBhcmd1bWVudCB0byB0aGUgcG93IG1ldGhvZC5cclxuICAgICAgICBNQVhfUE9XRVIgPSAxRTYsICAgICAgICAgICAgICAgICAgIC8vIDEgdG8gMTAwMDAwMFxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYmVuZWF0aCB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsXHJcbiAgICAgICAgICogbm90YXRpb24uXHJcbiAgICAgICAgICogSmF2YVNjcmlwdCdzIE51bWJlciB0eXBlOiAtN1xyXG4gICAgICAgICAqIC0xMDAwMDAwIGlzIHRoZSBtaW5pbXVtIHJlY29tbWVuZGVkIGV4cG9uZW50IHZhbHVlIG9mIGEgQmlnLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEVfTkVHID0gLTcsICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gLTEwMDAwMDBcclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGFib3ZlIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWxcclxuICAgICAgICAgKiBub3RhdGlvbi5cclxuICAgICAgICAgKiBKYXZhU2NyaXB0J3MgTnVtYmVyIHR5cGU6IDIxXHJcbiAgICAgICAgICogMTAwMDAwMCBpcyB0aGUgbWF4aW11bSByZWNvbW1lbmRlZCBleHBvbmVudCB2YWx1ZSBvZiBhIEJpZy5cclxuICAgICAgICAgKiAoVGhpcyBsaW1pdCBpcyBub3QgZW5mb3JjZWQgb3IgY2hlY2tlZC4pXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRV9QT1MgPSAyMSwgICAgICAgICAgICAgICAgICAgLy8gMCB0byAxMDAwMDAwXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuICAgICAgICAvLyBUaGUgc2hhcmVkIHByb3RvdHlwZSBvYmplY3QuXHJcbiAgICAgICAgUCA9IHt9LFxyXG4gICAgICAgIGlzVmFsaWQgPSAvXi0/KFxcZCsoXFwuXFxkKik/fFxcLlxcZCspKGVbKy1dP1xcZCspPyQvaSxcclxuICAgICAgICBCaWc7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIEJpZyBjb25zdHJ1Y3Rvci5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGJpZ0ZhY3RvcnkoKSB7XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogVGhlIEJpZyBjb25zdHJ1Y3RvciBhbmQgZXhwb3J0ZWQgZnVuY3Rpb24uXHJcbiAgICAgICAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBCaWcgbnVtYmVyIG9iamVjdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIG4ge251bWJlcnxzdHJpbmd8QmlnfSBBIG51bWVyaWMgdmFsdWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gQmlnKG4pIHtcclxuICAgICAgICAgICAgdmFyIHggPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgLy8gRW5hYmxlIGNvbnN0cnVjdG9yIHVzYWdlIHdpdGhvdXQgbmV3LlxyXG4gICAgICAgICAgICBpZiAoISh4IGluc3RhbmNlb2YgQmlnKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG4gPT09IHZvaWQgMCA/IGJpZ0ZhY3RvcnkoKSA6IG5ldyBCaWcobik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIER1cGxpY2F0ZS5cclxuICAgICAgICAgICAgaWYgKG4gaW5zdGFuY2VvZiBCaWcpIHtcclxuICAgICAgICAgICAgICAgIHgucyA9IG4ucztcclxuICAgICAgICAgICAgICAgIHguZSA9IG4uZTtcclxuICAgICAgICAgICAgICAgIHguYyA9IG4uYy5zbGljZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcGFyc2UoeCwgbik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAqIFJldGFpbiBhIHJlZmVyZW5jZSB0byB0aGlzIEJpZyBjb25zdHJ1Y3RvciwgYW5kIHNoYWRvd1xyXG4gICAgICAgICAgICAgKiBCaWcucHJvdG90eXBlLmNvbnN0cnVjdG9yIHdoaWNoIHBvaW50cyB0byBPYmplY3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB4LmNvbnN0cnVjdG9yID0gQmlnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgQmlnLnByb3RvdHlwZSA9IFA7XHJcbiAgICAgICAgQmlnLkRQID0gRFA7XHJcbiAgICAgICAgQmlnLlJNID0gUk07XHJcbiAgICAgICAgQmlnLkVfTkVHID0gRV9ORUc7XHJcbiAgICAgICAgQmlnLkVfUE9TID0gRV9QT1M7XHJcblxyXG4gICAgICAgIHJldHVybiBCaWc7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIFByaXZhdGUgZnVuY3Rpb25zXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiBCaWcgeCBpbiBub3JtYWwgb3IgZXhwb25lbnRpYWxcclxuICAgICAqIG5vdGF0aW9uIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzIG9yIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgICAqXHJcbiAgICAgKiB4IHtCaWd9IFRoZSBCaWcgdG8gZm9ybWF0LlxyXG4gICAgICogZHAge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVhfRFAgaW5jbHVzaXZlLlxyXG4gICAgICogdG9FIHtudW1iZXJ9IDEgKHRvRXhwb25lbnRpYWwpLCAyICh0b1ByZWNpc2lvbikgb3IgdW5kZWZpbmVkICh0b0ZpeGVkKS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZm9ybWF0KHgsIGRwLCB0b0UpIHtcclxuICAgICAgICB2YXIgQmlnID0geC5jb25zdHJ1Y3RvcixcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBpbmRleCAobm9ybWFsIG5vdGF0aW9uKSBvZiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgICAgICAgaSA9IGRwIC0gKHggPSBuZXcgQmlnKHgpKS5lLFxyXG4gICAgICAgICAgICBjID0geC5jO1xyXG5cclxuICAgICAgICAvLyBSb3VuZD9cclxuICAgICAgICBpZiAoYy5sZW5ndGggPiArK2RwKSB7XHJcbiAgICAgICAgICAgIHJuZCh4LCBpLCBCaWcuUk0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFjWzBdKSB7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRvRSkge1xyXG4gICAgICAgICAgICBpID0gZHA7XHJcblxyXG4gICAgICAgIC8vIHRvRml4ZWRcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjID0geC5jO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVjYWxjdWxhdGUgaSBhcyB4LmUgbWF5IGhhdmUgY2hhbmdlZCBpZiB2YWx1ZSByb3VuZGVkIHVwLlxyXG4gICAgICAgICAgICBpID0geC5lICsgaSArIDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgZm9yICg7IGMubGVuZ3RoIDwgaTsgYy5wdXNoKDApKSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkgPSB4LmU7XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogdG9QcmVjaXNpb24gcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbiBpZiB0aGUgbnVtYmVyIG9mXHJcbiAgICAgICAgICogc2lnbmlmaWNhbnQgZGlnaXRzIHNwZWNpZmllZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHNcclxuICAgICAgICAgKiBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlIHZhbHVlIGluIG5vcm1hbFxyXG4gICAgICAgICAqIG5vdGF0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJldHVybiB0b0UgPT09IDEgfHwgdG9FICYmIChkcCA8PSBpIHx8IGkgPD0gQmlnLkVfTkVHKSA/XHJcblxyXG4gICAgICAgICAgLy8gRXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgICAgICAoeC5zIDwgMCAmJiBjWzBdID8gJy0nIDogJycpICtcclxuICAgICAgICAgICAgKGMubGVuZ3RoID4gMSA/IGNbMF0gKyAnLicgKyBjLmpvaW4oJycpLnNsaWNlKDEpIDogY1swXSkgK1xyXG4gICAgICAgICAgICAgIChpIDwgMCA/ICdlJyA6ICdlKycpICsgaVxyXG5cclxuICAgICAgICAgIC8vIE5vcm1hbCBub3RhdGlvbi5cclxuICAgICAgICAgIDogeC50b1N0cmluZygpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUGFyc2UgdGhlIG51bWJlciBvciBzdHJpbmcgdmFsdWUgcGFzc2VkIHRvIGEgQmlnIGNvbnN0cnVjdG9yLlxyXG4gICAgICpcclxuICAgICAqIHgge0JpZ30gQSBCaWcgbnVtYmVyIGluc3RhbmNlLlxyXG4gICAgICogbiB7bnVtYmVyfHN0cmluZ30gQSBudW1lcmljIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBwYXJzZSh4LCBuKSB7XHJcbiAgICAgICAgdmFyIGUsIGksIG5MO1xyXG5cclxuICAgICAgICAvLyBNaW51cyB6ZXJvP1xyXG4gICAgICAgIGlmIChuID09PSAwICYmIDEgLyBuIDwgMCkge1xyXG4gICAgICAgICAgICBuID0gJy0wJztcclxuXHJcbiAgICAgICAgLy8gRW5zdXJlIG4gaXMgc3RyaW5nIGFuZCBjaGVjayB2YWxpZGl0eS5cclxuICAgICAgICB9IGVsc2UgaWYgKCFpc1ZhbGlkLnRlc3QobiArPSAnJykpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnIoTmFOKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSBzaWduLlxyXG4gICAgICAgIHgucyA9IG4uY2hhckF0KDApID09ICctJyA/IChuID0gbi5zbGljZSgxKSwgLTEpIDogMTtcclxuXHJcbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgICBpZiAoKGUgPSBuLmluZGV4T2YoJy4nKSkgPiAtMSkge1xyXG4gICAgICAgICAgICBuID0gbi5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRpYWwgZm9ybT9cclxuICAgICAgICBpZiAoKGkgPSBuLnNlYXJjaCgvZS9pKSkgPiAwKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgZXhwb25lbnQuXHJcbiAgICAgICAgICAgIGlmIChlIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgZSA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZSArPSArbi5zbGljZShpICsgMSk7XHJcbiAgICAgICAgICAgIG4gPSBuLnN1YnN0cmluZygwLCBpKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmIChlIDwgMCkge1xyXG5cclxuICAgICAgICAgICAgLy8gSW50ZWdlci5cclxuICAgICAgICAgICAgZSA9IG4ubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yIChpID0gMDsgbi5jaGFyQXQoaSkgPT0gJzAnOyBpKyspIHtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpID09IChuTCA9IG4ubGVuZ3RoKSkge1xyXG5cclxuICAgICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgICAgeC5jID0gWyB4LmUgPSAwIF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgZm9yICg7IG4uY2hhckF0KC0tbkwpID09ICcwJzspIHtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgeC5lID0gZSAtIGkgLSAxO1xyXG4gICAgICAgICAgICB4LmMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIGFycmF5IG9mIGRpZ2l0cyB3aXRob3V0IGxlYWRpbmcvdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICAgIGZvciAoZSA9IDA7IGkgPD0gbkw7IHguY1tlKytdID0gK24uY2hhckF0KGkrKykpIHtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSb3VuZCBCaWcgeCB0byBhIG1heGltdW0gb2YgZHAgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybS5cclxuICAgICAqIENhbGxlZCBieSBkaXYsIHNxcnQgYW5kIHJvdW5kLlxyXG4gICAgICpcclxuICAgICAqIHgge0JpZ30gVGhlIEJpZyB0byByb3VuZC5cclxuICAgICAqIGRwIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYX0RQIGluY2x1c2l2ZS5cclxuICAgICAqIHJtIHtudW1iZXJ9IDAsIDEsIDIgb3IgMyAoRE9XTiwgSEFMRl9VUCwgSEFMRl9FVkVOLCBVUClcclxuICAgICAqIFttb3JlXSB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcmVzdWx0IG9mIGRpdmlzaW9uIHdhcyB0cnVuY2F0ZWQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJuZCh4LCBkcCwgcm0sIG1vcmUpIHtcclxuICAgICAgICB2YXIgdSxcclxuICAgICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICAgIGkgPSB4LmUgKyBkcCArIDE7XHJcblxyXG4gICAgICAgIGlmIChybSA9PT0gMSkge1xyXG5cclxuICAgICAgICAgICAgLy8geGNbaV0gaXMgdGhlIGRpZ2l0IGFmdGVyIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgICAgICBtb3JlID0geGNbaV0gPj0gNTtcclxuICAgICAgICB9IGVsc2UgaWYgKHJtID09PSAyKSB7XHJcbiAgICAgICAgICAgIG1vcmUgPSB4Y1tpXSA+IDUgfHwgeGNbaV0gPT0gNSAmJlxyXG4gICAgICAgICAgICAgIChtb3JlIHx8IGkgPCAwIHx8IHhjW2kgKyAxXSAhPT0gdSB8fCB4Y1tpIC0gMV0gJiAxKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHJtID09PSAzKSB7XHJcbiAgICAgICAgICAgIG1vcmUgPSBtb3JlIHx8IHhjW2ldICE9PSB1IHx8IGkgPCAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1vcmUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGlmIChybSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3dFcnIoJyFCaWcuUk0hJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpIDwgMSB8fCAheGNbMF0pIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChtb3JlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMSwgMC4xLCAwLjAxLCAwLjAwMSwgMC4wMDAxIGV0Yy5cclxuICAgICAgICAgICAgICAgIHguZSA9IC1kcDtcclxuICAgICAgICAgICAgICAgIHguYyA9IFsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbnkgZGlnaXRzIGFmdGVyIHRoZSByZXF1aXJlZCBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gaS0tO1xyXG5cclxuICAgICAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgICAgIGlmIChtb3JlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUm91bmRpbmcgdXAgbWF5IG1lYW4gdGhlIHByZXZpb3VzIGRpZ2l0IGhhcyB0byBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgICAgICAgICAgZm9yICg7ICsreGNbaV0gPiA5Oykge1xyXG4gICAgICAgICAgICAgICAgICAgIHhjW2ldID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKyt4LmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhjLnVuc2hpZnQoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IHhjLmxlbmd0aDsgIXhjWy0taV07IHhjLnBvcCgpKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogVGhyb3cgYSBCaWdFcnJvci5cclxuICAgICAqXHJcbiAgICAgKiBtZXNzYWdlIHtzdHJpbmd9IFRoZSBlcnJvciBtZXNzYWdlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0aHJvd0VycihtZXNzYWdlKSB7XHJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgICAgICBlcnIubmFtZSA9ICdCaWdFcnJvcic7XHJcblxyXG4gICAgICAgIHRocm93IGVycjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gUHJvdG90eXBlL2luc3RhbmNlIG1ldGhvZHNcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWcgd2hvc2UgdmFsdWUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgQmlnLlxyXG4gICAgICovXHJcbiAgICBQLmFicyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgeCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpO1xyXG4gICAgICAgIHgucyA9IDE7XHJcblxyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVyblxyXG4gICAgICogMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWcgeSxcclxuICAgICAqIC0xIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZyB5LCBvclxyXG4gICAgICogMCBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgdmFsdWUuXHJcbiAgICAqL1xyXG4gICAgUC5jbXAgPSBmdW5jdGlvbiAoeSkge1xyXG4gICAgICAgIHZhciB4TmVnLFxyXG4gICAgICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICAgIHljID0gKHkgPSBuZXcgeC5jb25zdHJ1Y3Rvcih5KSkuYyxcclxuICAgICAgICAgICAgaSA9IHgucyxcclxuICAgICAgICAgICAgaiA9IHkucyxcclxuICAgICAgICAgICAgayA9IHguZSxcclxuICAgICAgICAgICAgbCA9IHkuZTtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuICF4Y1swXSA/ICF5Y1swXSA/IDAgOiAtaiA6IGk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgICAgaWYgKGkgIT0gaikge1xyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9XHJcbiAgICAgICAgeE5lZyA9IGkgPCAwO1xyXG5cclxuICAgICAgICAvLyBDb21wYXJlIGV4cG9uZW50cy5cclxuICAgICAgICBpZiAoayAhPSBsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBrID4gbCBeIHhOZWcgPyAxIDogLTE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpID0gLTE7XHJcbiAgICAgICAgaiA9IChrID0geGMubGVuZ3RoKSA8IChsID0geWMubGVuZ3RoKSA/IGsgOiBsO1xyXG5cclxuICAgICAgICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgICAgIGZvciAoOyArK2kgPCBqOykge1xyXG5cclxuICAgICAgICAgICAgaWYgKHhjW2ldICE9IHljW2ldKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geGNbaV0gPiB5Y1tpXSBeIHhOZWcgPyAxIDogLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbXBhcmUgbGVuZ3Rocy5cclxuICAgICAgICByZXR1cm4gayA9PSBsID8gMCA6IGsgPiBsIF4geE5lZyA/IDEgOiAtMTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBkaXZpZGVkIGJ5IHRoZVxyXG4gICAgICogdmFsdWUgb2YgQmlnIHksIHJvdW5kZWQsIGlmIG5lY2Vzc2FyeSwgdG8gYSBtYXhpbXVtIG9mIEJpZy5EUCBkZWNpbWFsXHJcbiAgICAgKiBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBCaWcuUk0uXHJcbiAgICAgKi9cclxuICAgIFAuZGl2ID0gZnVuY3Rpb24gKHkpIHtcclxuICAgICAgICB2YXIgeCA9IHRoaXMsXHJcbiAgICAgICAgICAgIEJpZyA9IHguY29uc3RydWN0b3IsXHJcbiAgICAgICAgICAgIC8vIGRpdmlkZW5kXHJcbiAgICAgICAgICAgIGR2ZCA9IHguYyxcclxuICAgICAgICAgICAgLy9kaXZpc29yXHJcbiAgICAgICAgICAgIGR2cyA9ICh5ID0gbmV3IEJpZyh5KSkuYyxcclxuICAgICAgICAgICAgcyA9IHgucyA9PSB5LnMgPyAxIDogLTEsXHJcbiAgICAgICAgICAgIGRwID0gQmlnLkRQO1xyXG5cclxuICAgICAgICBpZiAoZHAgIT09IH5+ZHAgfHwgZHAgPCAwIHx8IGRwID4gTUFYX0RQKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyKCchQmlnLkRQIScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIDA/XHJcbiAgICAgICAgaWYgKCFkdmRbMF0gfHwgIWR2c1swXSkge1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgYm90aCBhcmUgMCwgdGhyb3cgTmFOXHJcbiAgICAgICAgICAgIGlmIChkdmRbMF0gPT0gZHZzWzBdKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvd0VycihOYU4pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBkdnMgaXMgMCwgdGhyb3cgKy1JbmZpbml0eS5cclxuICAgICAgICAgICAgaWYgKCFkdnNbMF0pIHtcclxuICAgICAgICAgICAgICAgIHRocm93RXJyKHMgLyAwKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gZHZkIGlzIDAsIHJldHVybiArLTAuXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmlnKHMgKiAwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBkdnNMLCBkdnNULCBuZXh0LCBjbXAsIHJlbUksIHUsXHJcbiAgICAgICAgICAgIGR2c1ogPSBkdnMuc2xpY2UoKSxcclxuICAgICAgICAgICAgZHZkSSA9IGR2c0wgPSBkdnMubGVuZ3RoLFxyXG4gICAgICAgICAgICBkdmRMID0gZHZkLmxlbmd0aCxcclxuICAgICAgICAgICAgLy8gcmVtYWluZGVyXHJcbiAgICAgICAgICAgIHJlbSA9IGR2ZC5zbGljZSgwLCBkdnNMKSxcclxuICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGgsXHJcbiAgICAgICAgICAgIC8vIHF1b3RpZW50XHJcbiAgICAgICAgICAgIHEgPSB5LFxyXG4gICAgICAgICAgICBxYyA9IHEuYyA9IFtdLFxyXG4gICAgICAgICAgICBxaSA9IDAsXHJcbiAgICAgICAgICAgIGRpZ2l0cyA9IGRwICsgKHEuZSA9IHguZSAtIHkuZSkgKyAxO1xyXG5cclxuICAgICAgICBxLnMgPSBzO1xyXG4gICAgICAgIHMgPSBkaWdpdHMgPCAwID8gMCA6IGRpZ2l0cztcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIHZlcnNpb24gb2YgZGl2aXNvciB3aXRoIGxlYWRpbmcgemVyby5cclxuICAgICAgICBkdnNaLnVuc2hpZnQoMCk7XHJcblxyXG4gICAgICAgIC8vIEFkZCB6ZXJvcyB0byBtYWtlIHJlbWFpbmRlciBhcyBsb25nIGFzIGRpdmlzb3IuXHJcbiAgICAgICAgZm9yICg7IHJlbUwrKyA8IGR2c0w7IHJlbS5wdXNoKDApKSB7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBkbyB7XHJcblxyXG4gICAgICAgICAgICAvLyAnbmV4dCcgaXMgaG93IG1hbnkgdGltZXMgdGhlIGRpdmlzb3IgZ29lcyBpbnRvIGN1cnJlbnQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBmb3IgKG5leHQgPSAwOyBuZXh0IDwgMTA7IG5leHQrKykge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgaWYgKGR2c0wgIT0gKHJlbUwgPSByZW0ubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNtcCA9IGR2c0wgPiByZW1MID8gMSA6IC0xO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChyZW1JID0gLTEsIGNtcCA9IDA7ICsrcmVtSSA8IGR2c0w7KSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHZzW3JlbUldICE9IHJlbVtyZW1JXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY21wID0gZHZzW3JlbUldID4gcmVtW3JlbUldID8gMSA6IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IHJlbWFpbmRlciwgc3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIGlmIChjbXAgPCAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbWFpbmRlciBjYW4ndCBiZSBtb3JlIHRoYW4gMSBkaWdpdCBsb25nZXIgdGhhbiBkaXZpc29yLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVxdWFsaXNlIGxlbmd0aHMgdXNpbmcgZGl2aXNvciB3aXRoIGV4dHJhIGxlYWRpbmcgemVybz9cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGR2c1QgPSByZW1MID09IGR2c0wgPyBkdnMgOiBkdnNaOyByZW1MOykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbVstLXJlbUxdIDwgZHZzVFtyZW1MXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtSSA9IHJlbUw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IHJlbUkgJiYgIXJlbVstLXJlbUldOyByZW1bcmVtSV0gPSA5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLXJlbVtyZW1JXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbVtyZW1MXSArPSAxMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1bcmVtTF0gLT0gZHZzVFtyZW1MXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7ICFyZW1bMF07IHJlbS5zaGlmdCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHRoZSAnbmV4dCcgZGlnaXQgdG8gdGhlIHJlc3VsdCBhcnJheS5cclxuICAgICAgICAgICAgcWNbcWkrK10gPSBjbXAgPyBuZXh0IDogKytuZXh0O1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChyZW1bMF0gJiYgY21wKSB7XHJcbiAgICAgICAgICAgICAgICByZW1bcmVtTF0gPSBkdmRbZHZkSV0gfHwgMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlbSA9IFsgZHZkW2R2ZEldIF07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSB3aGlsZSAoKGR2ZEkrKyA8IGR2ZEwgfHwgcmVtWzBdICE9PSB1KSAmJiBzLS0pO1xyXG5cclxuICAgICAgICAvLyBMZWFkaW5nIHplcm8/IERvIG5vdCByZW1vdmUgaWYgcmVzdWx0IGlzIHNpbXBseSB6ZXJvIChxaSA9PSAxKS5cclxuICAgICAgICBpZiAoIXFjWzBdICYmIHFpICE9IDEpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZXJlIGNhbid0IGJlIG1vcmUgdGhhbiBvbmUgemVyby5cclxuICAgICAgICAgICAgcWMuc2hpZnQoKTtcclxuICAgICAgICAgICAgcS5lLS07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSb3VuZD9cclxuICAgICAgICBpZiAocWkgPiBkaWdpdHMpIHtcclxuICAgICAgICAgICAgcm5kKHEsIGRwLCBCaWcuUk0sIHJlbVswXSAhPT0gdSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgaXMgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIEJpZyB5LFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybnMgZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuZXEgPSBmdW5jdGlvbiAoeSkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5jbXAoeSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnIHksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5ndCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY21wKHkpID4gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZVxyXG4gICAgICogdmFsdWUgb2YgQmlnIHksIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmd0ZSA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY21wKHkpID4gLTE7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnIHksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5sdCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY21wKHkpIDwgMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZVxyXG4gICAgICogb2YgQmlnIHksIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmx0ZSA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgICAgICAgIHJldHVybiB0aGlzLmNtcCh5KSA8IDE7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZyB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgbWludXMgdGhlIHZhbHVlXHJcbiAgICAgKiBvZiBCaWcgeS5cclxuICAgICAqL1xyXG4gICAgUC5zdWIgPSBQLm1pbnVzID0gZnVuY3Rpb24gKHkpIHtcclxuICAgICAgICB2YXIgaSwgaiwgdCwgeExUeSxcclxuICAgICAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgICAgIEJpZyA9IHguY29uc3RydWN0b3IsXHJcbiAgICAgICAgICAgIGEgPSB4LnMsXHJcbiAgICAgICAgICAgIGIgPSAoeSA9IG5ldyBCaWcoeSkpLnM7XHJcblxyXG4gICAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgICAgICAgIHkucyA9IC1iO1xyXG4gICAgICAgICAgICByZXR1cm4geC5wbHVzKHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHhjID0geC5jLnNsaWNlKCksXHJcbiAgICAgICAgICAgIHhlID0geC5lLFxyXG4gICAgICAgICAgICB5YyA9IHkuYyxcclxuICAgICAgICAgICAgeWUgPSB5LmU7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgICAgICAvLyB5IGlzIG5vbi16ZXJvPyB4IGlzIG5vbi16ZXJvPyBPciBib3RoIGFyZSB6ZXJvLlxyXG4gICAgICAgICAgICByZXR1cm4geWNbMF0gPyAoeS5zID0gLWIsIHkpIDogbmV3IEJpZyh4Y1swXSA/IHggOiAwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSB3aGljaCBpcyB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy5cclxuICAgICAgICBpZiAoYSA9IHhlIC0geWUpIHtcclxuXHJcbiAgICAgICAgICAgIGlmICh4TFR5ID0gYSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICAgICAgICAgIHQgPSB4YztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHllID0geGU7XHJcbiAgICAgICAgICAgICAgICB0ID0geWM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICBmb3IgKGIgPSBhOyBiLS07IHQucHVzaCgwKSkge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAvLyBFeHBvbmVudHMgZXF1YWwuIENoZWNrIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgICAgICAgICBqID0gKCh4TFR5ID0geGMubGVuZ3RoIDwgeWMubGVuZ3RoKSA/IHhjIDogeWMpLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIGZvciAoYSA9IGIgPSAwOyBiIDwgajsgYisrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHhjW2JdICE9IHljW2JdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeExUeSA9IHhjW2JdIDwgeWNbYl07XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHggPCB5PyBQb2ludCB4YyB0byB0aGUgYXJyYXkgb2YgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICAgICAgaWYgKHhMVHkpIHtcclxuICAgICAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgICAgICB4YyA9IHljO1xyXG4gICAgICAgICAgICB5YyA9IHQ7XHJcbiAgICAgICAgICAgIHkucyA9IC15LnM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIEFwcGVuZCB6ZXJvcyB0byB4YyBpZiBzaG9ydGVyLiBObyBuZWVkIHRvIGFkZCB6ZXJvcyB0byB5YyBpZiBzaG9ydGVyXHJcbiAgICAgICAgICogYXMgc3VidHJhY3Rpb24gb25seSBuZWVkcyB0byBzdGFydCBhdCB5Yy5sZW5ndGguXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaWYgKCggYiA9IChqID0geWMubGVuZ3RoKSAtIChpID0geGMubGVuZ3RoKSApID4gMCkge1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IGItLTsgeGNbaSsrXSA9IDApIHtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3VidHJhY3QgeWMgZnJvbSB4Yy5cclxuICAgICAgICBmb3IgKGIgPSBpOyBqID4gYTspe1xyXG5cclxuICAgICAgICAgICAgaWYgKHhjWy0tal0gPCB5Y1tqXSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IGo7IGkgJiYgIXhjWy0taV07IHhjW2ldID0gOSkge1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLS14Y1tpXTtcclxuICAgICAgICAgICAgICAgIHhjW2pdICs9IDEwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHhjW2pdIC09IHljW2pdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoOyB4Y1stLWJdID09PSAwOyB4Yy5wb3AoKSkge1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MgYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICBmb3IgKDsgeGNbMF0gPT09IDA7KSB7XHJcbiAgICAgICAgICAgIHhjLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIC0teWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXhjWzBdKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBuIC0gbiA9ICswXHJcbiAgICAgICAgICAgIHkucyA9IDE7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXN1bHQgbXVzdCBiZSB6ZXJvLlxyXG4gICAgICAgICAgICB4YyA9IFt5ZSA9IDBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeS5jID0geGM7XHJcbiAgICAgICAgeS5lID0geWU7XHJcblxyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWcgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIG1vZHVsbyB0aGVcclxuICAgICAqIHZhbHVlIG9mIEJpZyB5LlxyXG4gICAgICovXHJcbiAgICBQLm1vZCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgICAgICAgdmFyIHlHVHgsXHJcbiAgICAgICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgICAgICBCaWcgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgICAgICAgICBhID0geC5zLFxyXG4gICAgICAgICAgICBiID0gKHkgPSBuZXcgQmlnKHkpKS5zO1xyXG5cclxuICAgICAgICBpZiAoIXkuY1swXSkge1xyXG4gICAgICAgICAgICB0aHJvd0VycihOYU4pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeC5zID0geS5zID0gMTtcclxuICAgICAgICB5R1R4ID0geS5jbXAoeCkgPT0gMTtcclxuICAgICAgICB4LnMgPSBhO1xyXG4gICAgICAgIHkucyA9IGI7XHJcblxyXG4gICAgICAgIGlmICh5R1R4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmlnKHgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYSA9IEJpZy5EUDtcclxuICAgICAgICBiID0gQmlnLlJNO1xyXG4gICAgICAgIEJpZy5EUCA9IEJpZy5STSA9IDA7XHJcbiAgICAgICAgeCA9IHguZGl2KHkpO1xyXG4gICAgICAgIEJpZy5EUCA9IGE7XHJcbiAgICAgICAgQmlnLlJNID0gYjtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWludXMoIHgudGltZXMoeSkgKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBwbHVzIHRoZSB2YWx1ZVxyXG4gICAgICogb2YgQmlnIHkuXHJcbiAgICAgKi9cclxuICAgIFAuYWRkID0gUC5wbHVzID0gZnVuY3Rpb24gKHkpIHtcclxuICAgICAgICB2YXIgdCxcclxuICAgICAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgICAgIEJpZyA9IHguY29uc3RydWN0b3IsXHJcbiAgICAgICAgICAgIGEgPSB4LnMsXHJcbiAgICAgICAgICAgIGIgPSAoeSA9IG5ldyBCaWcoeSkpLnM7XHJcblxyXG4gICAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgICAgICAgIHkucyA9IC1iO1xyXG4gICAgICAgICAgICByZXR1cm4geC5taW51cyh5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB4ZSA9IHguZSxcclxuICAgICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICAgIHllID0geS5lLFxyXG4gICAgICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgICAgIC8vIHkgaXMgbm9uLXplcm8/IHggaXMgbm9uLXplcm8/IE9yIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgICAgIHJldHVybiB5Y1swXSA/IHkgOiBuZXcgQmlnKHhjWzBdID8geCA6IGEgKiAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgeGMgPSB4Yy5zbGljZSgpO1xyXG5cclxuICAgICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy5cclxuICAgICAgICAvLyBOb3RlOiBGYXN0ZXIgdG8gdXNlIHJldmVyc2UgdGhlbiBkbyB1bnNoaWZ0cy5cclxuICAgICAgICBpZiAoYSA9IHhlIC0geWUpIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChhID4gMCkge1xyXG4gICAgICAgICAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICAgICAgICAgIHQgPSB5YztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICAgICAgICAgIHQgPSB4YztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgICAgICAgIGZvciAoOyBhLS07IHQucHVzaCgwKSkge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUG9pbnQgeGMgdG8gdGhlIGxvbmdlciBhcnJheS5cclxuICAgICAgICBpZiAoeGMubGVuZ3RoIC0geWMubGVuZ3RoIDwgMCkge1xyXG4gICAgICAgICAgICB0ID0geWM7XHJcbiAgICAgICAgICAgIHljID0geGM7XHJcbiAgICAgICAgICAgIHhjID0gdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgYSA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBPbmx5IHN0YXJ0IGFkZGluZyBhdCB5Yy5sZW5ndGggLSAxIGFzIHRoZSBmdXJ0aGVyIGRpZ2l0cyBvZiB4YyBjYW4gYmVcclxuICAgICAgICAgKiBsZWZ0IGFzIHRoZXkgYXJlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZvciAoYiA9IDA7IGE7KSB7XHJcbiAgICAgICAgICAgIGIgPSAoeGNbLS1hXSA9IHhjW2FdICsgeWNbYV0gKyBiKSAvIDEwIHwgMDtcclxuICAgICAgICAgICAgeGNbYV0gJT0gMTA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciB6ZXJvLCBhcyAreCArICt5ICE9IDAgJiYgLXggKyAteSAhPSAwXHJcblxyXG4gICAgICAgIGlmIChiKSB7XHJcbiAgICAgICAgICAgIHhjLnVuc2hpZnQoYik7XHJcbiAgICAgICAgICAgICsreWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoYSA9IHhjLmxlbmd0aDsgeGNbLS1hXSA9PT0gMDsgeGMucG9wKCkpIHtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHkuYyA9IHhjO1xyXG4gICAgICAgIHkuZSA9IHllO1xyXG5cclxuICAgICAgICByZXR1cm4geTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBCaWcgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIHJhaXNlZCB0byB0aGUgcG93ZXIgbi5cclxuICAgICAqIElmIG4gaXMgbmVnYXRpdmUsIHJvdW5kLCBpZiBuZWNlc3NhcnksIHRvIGEgbWF4aW11bSBvZiBCaWcuRFAgZGVjaW1hbFxyXG4gICAgICogcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgQmlnLlJNLlxyXG4gICAgICpcclxuICAgICAqIG4ge251bWJlcn0gSW50ZWdlciwgLU1BWF9QT1dFUiB0byBNQVhfUE9XRVIgaW5jbHVzaXZlLlxyXG4gICAgICovXHJcbiAgICBQLnBvdyA9IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAgICAgdmFyIHggPSB0aGlzLFxyXG4gICAgICAgICAgICBvbmUgPSBuZXcgeC5jb25zdHJ1Y3RvcigxKSxcclxuICAgICAgICAgICAgeSA9IG9uZSxcclxuICAgICAgICAgICAgaXNOZWcgPSBuIDwgMDtcclxuXHJcbiAgICAgICAgaWYgKG4gIT09IH5+biB8fCBuIDwgLU1BWF9QT1dFUiB8fCBuID4gTUFYX1BPV0VSKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyKCchcG93IScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbiA9IGlzTmVnID8gLW4gOiBuO1xyXG5cclxuICAgICAgICBmb3IgKDs7KSB7XHJcblxyXG4gICAgICAgICAgICBpZiAobiAmIDEpIHtcclxuICAgICAgICAgICAgICAgIHkgPSB5LnRpbWVzKHgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG4gPj49IDE7XHJcblxyXG4gICAgICAgICAgICBpZiAoIW4pIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHggPSB4LnRpbWVzKHgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGlzTmVnID8gb25lLmRpdih5KSA6IHk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZyB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgcm91bmRlZCB0byBhXHJcbiAgICAgKiBtYXhpbXVtIG9mIGRwIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0uXHJcbiAgICAgKiBJZiBkcCBpcyBub3Qgc3BlY2lmaWVkLCByb3VuZCB0byAwIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICogSWYgcm0gaXMgbm90IHNwZWNpZmllZCwgdXNlIEJpZy5STS5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYX0RQIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0gMCwgMSwgMiBvciAzIChST1VORF9ET1dOLCBST1VORF9IQUxGX1VQLCBST1VORF9IQUxGX0VWRU4sIFJPVU5EX1VQKVxyXG4gICAgICovXHJcbiAgICBQLnJvdW5kID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICAgIHZhciB4ID0gdGhpcyxcclxuICAgICAgICAgICAgQmlnID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICAgICAgaWYgKGRwID09IG51bGwpIHtcclxuICAgICAgICAgICAgZHAgPSAwO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZHAgIT09IH5+ZHAgfHwgZHAgPCAwIHx8IGRwID4gTUFYX0RQKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyKCchcm91bmQhJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJuZCh4ID0gbmV3IEJpZyh4KSwgZHAsIHJtID09IG51bGwgPyBCaWcuUk0gOiBybSk7XHJcblxyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWcgd2hvc2UgdmFsdWUgaXMgdGhlIHNxdWFyZSByb290IG9mIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyxcclxuICAgICAqIHJvdW5kZWQsIGlmIG5lY2Vzc2FyeSwgdG8gYSBtYXhpbXVtIG9mIEJpZy5EUCBkZWNpbWFsIHBsYWNlcyB1c2luZ1xyXG4gICAgICogcm91bmRpbmcgbW9kZSBCaWcuUk0uXHJcbiAgICAgKi9cclxuICAgIFAuc3FydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZXN0aW1hdGUsIHIsIGFwcHJveCxcclxuICAgICAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgICAgIEJpZyA9IHguY29uc3RydWN0b3IsXHJcbiAgICAgICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgICAgICBpID0geC5zLFxyXG4gICAgICAgICAgICBlID0geC5lLFxyXG4gICAgICAgICAgICBoYWxmID0gbmV3IEJpZygnMC41Jyk7XHJcblxyXG4gICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgaWYgKCF4Y1swXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpZyh4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIG5lZ2F0aXZlLCB0aHJvdyBOYU4uXHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyKE5hTik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFc3RpbWF0ZS5cclxuICAgICAgICBpID0gTWF0aC5zcXJ0KHgudG9TdHJpbmcoKSk7XHJcblxyXG4gICAgICAgIC8vIE1hdGguc3FydCB1bmRlcmZsb3cvb3ZlcmZsb3c/XHJcbiAgICAgICAgLy8gUGFzcyB4IHRvIE1hdGguc3FydCBhcyBpbnRlZ2VyLCB0aGVuIGFkanVzdCB0aGUgcmVzdWx0IGV4cG9uZW50LlxyXG4gICAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IDEgLyAwKSB7XHJcbiAgICAgICAgICAgIGVzdGltYXRlID0geGMuam9pbignJyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIShlc3RpbWF0ZS5sZW5ndGggKyBlICYgMSkpIHtcclxuICAgICAgICAgICAgICAgIGVzdGltYXRlICs9ICcwJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgciA9IG5ldyBCaWcoIE1hdGguc3FydChlc3RpbWF0ZSkudG9TdHJpbmcoKSApO1xyXG4gICAgICAgICAgICByLmUgPSAoKGUgKyAxKSAvIDIgfCAwKSAtIChlIDwgMCB8fCBlICYgMSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgciA9IG5ldyBCaWcoaS50b1N0cmluZygpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGkgPSByLmUgKyAoQmlnLkRQICs9IDQpO1xyXG5cclxuICAgICAgICAvLyBOZXd0b24tUmFwaHNvbiBpdGVyYXRpb24uXHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBhcHByb3ggPSByO1xyXG4gICAgICAgICAgICByID0gaGFsZi50aW1lcyggYXBwcm94LnBsdXMoIHguZGl2KGFwcHJveCkgKSApO1xyXG4gICAgICAgIH0gd2hpbGUgKCBhcHByb3guYy5zbGljZSgwLCBpKS5qb2luKCcnKSAhPT1cclxuICAgICAgICAgICAgICAgICAgICAgICByLmMuc2xpY2UoMCwgaSkuam9pbignJykgKTtcclxuXHJcbiAgICAgICAgcm5kKHIsIEJpZy5EUCAtPSA0LCBCaWcuUk0pO1xyXG5cclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyB0aW1lcyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZyB5LlxyXG4gICAgICovXHJcbiAgICBQLm11bCA9IFAudGltZXMgPSBmdW5jdGlvbiAoeSkge1xyXG4gICAgICAgIHZhciBjLFxyXG4gICAgICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICAgICAgQmlnID0geC5jb25zdHJ1Y3RvcixcclxuICAgICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICAgIHljID0gKHkgPSBuZXcgQmlnKHkpKS5jLFxyXG4gICAgICAgICAgICBhID0geGMubGVuZ3RoLFxyXG4gICAgICAgICAgICBiID0geWMubGVuZ3RoLFxyXG4gICAgICAgICAgICBpID0geC5lLFxyXG4gICAgICAgICAgICBqID0geS5lO1xyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgc2lnbiBvZiByZXN1bHQuXHJcbiAgICAgICAgeS5zID0geC5zID09IHkucyA/IDEgOiAtMTtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIHNpZ25lZCAwIGlmIGVpdGhlciAwLlxyXG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmlnKHkucyAqIDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGlzZSBleHBvbmVudCBvZiByZXN1bHQgYXMgeC5lICsgeS5lLlxyXG4gICAgICAgIHkuZSA9IGkgKyBqO1xyXG5cclxuICAgICAgICAvLyBJZiBhcnJheSB4YyBoYXMgZmV3ZXIgZGlnaXRzIHRoYW4geWMsIHN3YXAgeGMgYW5kIHljLCBhbmQgbGVuZ3Rocy5cclxuICAgICAgICBpZiAoYSA8IGIpIHtcclxuICAgICAgICAgICAgYyA9IHhjO1xyXG4gICAgICAgICAgICB4YyA9IHljO1xyXG4gICAgICAgICAgICB5YyA9IGM7XHJcbiAgICAgICAgICAgIGogPSBhO1xyXG4gICAgICAgICAgICBhID0gYjtcclxuICAgICAgICAgICAgYiA9IGo7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXNlIGNvZWZmaWNpZW50IGFycmF5IG9mIHJlc3VsdCB3aXRoIHplcm9zLlxyXG4gICAgICAgIGZvciAoYyA9IG5ldyBBcnJheShqID0gYSArIGIpOyBqLS07IGNbal0gPSAwKSB7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBNdWx0aXBseS5cclxuXHJcbiAgICAgICAgLy8gaSBpcyBpbml0aWFsbHkgeGMubGVuZ3RoLlxyXG4gICAgICAgIGZvciAoaSA9IGI7IGktLTspIHtcclxuICAgICAgICAgICAgYiA9IDA7XHJcblxyXG4gICAgICAgICAgICAvLyBhIGlzIHljLmxlbmd0aC5cclxuICAgICAgICAgICAgZm9yIChqID0gYSArIGk7IGogPiBpOykge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEN1cnJlbnQgc3VtIG9mIHByb2R1Y3RzIGF0IHRoaXMgZGlnaXQgcG9zaXRpb24sIHBsdXMgY2FycnkuXHJcbiAgICAgICAgICAgICAgICBiID0gY1tqXSArIHljW2ldICogeGNbaiAtIGkgLSAxXSArIGI7XHJcbiAgICAgICAgICAgICAgICBjW2otLV0gPSBiICUgMTA7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY2FycnlcclxuICAgICAgICAgICAgICAgIGIgPSBiIC8gMTAgfCAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNbal0gPSAoY1tqXSArIGIpICUgMTA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJbmNyZW1lbnQgcmVzdWx0IGV4cG9uZW50IGlmIHRoZXJlIGlzIGEgZmluYWwgY2FycnkuXHJcbiAgICAgICAgaWYgKGIpIHtcclxuICAgICAgICAgICAgKyt5LmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgYW55IGxlYWRpbmcgemVyby5cclxuICAgICAgICBpZiAoIWNbMF0pIHtcclxuICAgICAgICAgICAgYy5zaGlmdCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoaSA9IGMubGVuZ3RoOyAhY1stLWldOyBjLnBvcCgpKSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHkuYyA9IGM7XHJcblxyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnLlxyXG4gICAgICogUmV0dXJuIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIHRoaXMgQmlnIGhhcyBhIHBvc2l0aXZlIGV4cG9uZW50IGVxdWFsIHRvXHJcbiAgICAgKiBvciBncmVhdGVyIHRoYW4gQmlnLkVfUE9TLCBvciBhIG5lZ2F0aXZlIGV4cG9uZW50IGVxdWFsIHRvIG9yIGxlc3MgdGhhblxyXG4gICAgICogQmlnLkVfTkVHLlxyXG4gICAgICovXHJcbiAgICBQLnRvU3RyaW5nID0gUC52YWx1ZU9mID0gUC50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHggPSB0aGlzLFxyXG4gICAgICAgICAgICBCaWcgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgICAgICAgICBlID0geC5lLFxyXG4gICAgICAgICAgICBzdHIgPSB4LmMuam9pbignJyksXHJcbiAgICAgICAgICAgIHN0ckwgPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBFeHBvbmVudGlhbCBub3RhdGlvbj9cclxuICAgICAgICBpZiAoZSA8PSBCaWcuRV9ORUcgfHwgZSA+PSBCaWcuRV9QT1MpIHtcclxuICAgICAgICAgICAgc3RyID0gc3RyLmNoYXJBdCgwKSArIChzdHJMID4gMSA/ICcuJyArIHN0ci5zbGljZSgxKSA6ICcnKSArXHJcbiAgICAgICAgICAgICAgKGUgPCAwID8gJ2UnIDogJ2UrJykgKyBlO1xyXG5cclxuICAgICAgICAvLyBOZWdhdGl2ZSBleHBvbmVudD9cclxuICAgICAgICB9IGVsc2UgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBQcmVwZW5kIHplcm9zLlxyXG4gICAgICAgICAgICBmb3IgKDsgKytlOyBzdHIgPSAnMCcgKyBzdHIpIHtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdHIgPSAnMC4nICsgc3RyO1xyXG5cclxuICAgICAgICAvLyBQb3NpdGl2ZSBleHBvbmVudD9cclxuICAgICAgICB9IGVsc2UgaWYgKGUgPiAwKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoKytlID4gc3RyTCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcy5cclxuICAgICAgICAgICAgICAgIGZvciAoZSAtPSBzdHJMOyBlLS0gOyBzdHIgKz0gJzAnKSB7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZSA8IHN0ckwpIHtcclxuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCBlKSArICcuJyArIHN0ci5zbGljZShlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFeHBvbmVudCB6ZXJvLlxyXG4gICAgICAgIH0gZWxzZSBpZiAoc3RyTCA+IDEpIHtcclxuICAgICAgICAgICAgc3RyID0gc3RyLmNoYXJBdCgwKSArICcuJyArIHN0ci5zbGljZSgxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEF2b2lkICctMCdcclxuICAgICAgICByZXR1cm4geC5zIDwgMCAmJiB4LmNbMF0gPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAgICogSWYgdG9FeHBvbmVudGlhbCwgdG9GaXhlZCwgdG9QcmVjaXNpb24gYW5kIGZvcm1hdCBhcmUgbm90IHJlcXVpcmVkIHRoZXlcclxuICAgICAqIGNhbiBzYWZlbHkgYmUgY29tbWVudGVkLW91dCBvciBkZWxldGVkLiBObyByZWR1bmRhbnQgY29kZSB3aWxsIGJlIGxlZnQuXHJcbiAgICAgKiBmb3JtYXQgaXMgdXNlZCBvbmx5IGJ5IHRvRXhwb25lbnRpYWwsIHRvRml4ZWQgYW5kIHRvUHJlY2lzaW9uLlxyXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAgICovXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBpbiBleHBvbmVudGlhbFxyXG4gICAgICogbm90YXRpb24gdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMgYW5kIHJvdW5kZWQsIGlmIG5lY2Vzc2FyeSwgdXNpbmdcclxuICAgICAqIEJpZy5STS5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYX0RQIGluY2x1c2l2ZS5cclxuICAgICAqL1xyXG4gICAgUC50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24gKGRwKSB7XHJcblxyXG4gICAgICAgIGlmIChkcCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRwID0gdGhpcy5jLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkcCAhPT0gfn5kcCB8fCBkcCA8IDAgfHwgZHAgPiBNQVhfRFApIHtcclxuICAgICAgICAgICAgdGhyb3dFcnIoJyF0b0V4cCEnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmb3JtYXQodGhpcywgZHAsIDEpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIGluIG5vcm1hbCBub3RhdGlvblxyXG4gICAgICogdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMgYW5kIHJvdW5kZWQsIGlmIG5lY2Vzc2FyeSwgdXNpbmcgQmlnLlJNLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVhfRFAgaW5jbHVzaXZlLlxyXG4gICAgICovXHJcbiAgICBQLnRvRml4ZWQgPSBmdW5jdGlvbiAoZHApIHtcclxuICAgICAgICB2YXIgc3RyLFxyXG4gICAgICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICAgICAgQmlnID0geC5jb25zdHJ1Y3RvcixcclxuICAgICAgICAgICAgbmVnID0gQmlnLkVfTkVHLFxyXG4gICAgICAgICAgICBwb3MgPSBCaWcuRV9QT1M7XHJcblxyXG4gICAgICAgIC8vIFByZXZlbnQgdGhlIHBvc3NpYmlsaXR5IG9mIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAgIEJpZy5FX05FRyA9IC0oQmlnLkVfUE9TID0gMSAvIDApO1xyXG5cclxuICAgICAgICBpZiAoZHAgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzdHIgPSB4LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkcCA9PT0gfn5kcCAmJiBkcCA+PSAwICYmIGRwIDw9IE1BWF9EUCkge1xyXG4gICAgICAgICAgICBzdHIgPSBmb3JtYXQoeCwgeC5lICsgZHApO1xyXG5cclxuICAgICAgICAgICAgLy8gKC0wKS50b0ZpeGVkKCkgaXMgJzAnLCBidXQgKC0wLjEpLnRvRml4ZWQoKSBpcyAnLTAnLlxyXG4gICAgICAgICAgICAvLyAoLTApLnRvRml4ZWQoMSkgaXMgJzAuMCcsIGJ1dCAoLTAuMDEpLnRvRml4ZWQoMSkgaXMgJy0wLjAnLlxyXG4gICAgICAgICAgICBpZiAoeC5zIDwgMCAmJiB4LmNbMF0gJiYgc3RyLmluZGV4T2YoJy0nKSA8IDApIHtcclxuICAgICAgICAvL0UuZy4gLTAuNSBpZiByb3VuZGVkIHRvIC0wIHdpbGwgY2F1c2UgdG9TdHJpbmcgdG8gb21pdCB0aGUgbWludXMgc2lnbi5cclxuICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBCaWcuRV9ORUcgPSBuZWc7XHJcbiAgICAgICAgQmlnLkVfUE9TID0gcG9zO1xyXG5cclxuICAgICAgICBpZiAoIXN0cikge1xyXG4gICAgICAgICAgICB0aHJvd0VycignIXRvRml4IScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyByb3VuZGVkIHRvIHNkXHJcbiAgICAgKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgQmlnLlJNLiBVc2UgZXhwb25lbnRpYWwgbm90YXRpb24gaWYgc2QgaXMgbGVzc1xyXG4gICAgICogdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlXHJcbiAgICAgKiB2YWx1ZSBpbiBub3JtYWwgbm90YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogc2Qge251bWJlcn0gSW50ZWdlciwgMSB0byBNQVhfRFAgaW5jbHVzaXZlLlxyXG4gICAgICovXHJcbiAgICBQLnRvUHJlY2lzaW9uID0gZnVuY3Rpb24gKHNkKSB7XHJcblxyXG4gICAgICAgIGlmIChzZCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzZCAhPT0gfn5zZCB8fCBzZCA8IDEgfHwgc2QgPiBNQVhfRFApIHtcclxuICAgICAgICAgICAgdGhyb3dFcnIoJyF0b1ByZSEnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmb3JtYXQodGhpcywgc2QgLSAxLCAyKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8vIEV4cG9ydFxyXG5cclxuXHJcbiAgICBCaWcgPSBiaWdGYWN0b3J5KCk7XHJcblxyXG4gICAgLy9BTUQuXHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEJpZztcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAvLyBOb2RlIGFuZCBvdGhlciBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMuXHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBCaWc7XHJcblxyXG4gICAgLy9Ccm93c2VyLlxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBnbG9iYWwuQmlnID0gQmlnO1xyXG4gICAgfVxyXG59KSh0aGlzKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2JpZy5qcy9iaWcuanNcbi8vIG1vZHVsZSBpZCA9IDM2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgbG9hZGVyVXRpbHMgPSByZXF1aXJlKFwibG9hZGVyLXV0aWxzXCIpO1xyXG52YXIgTm9kZVRlbXBsYXRlUGx1Z2luID0gcmVxdWlyZShcIndlYnBhY2svbGliL25vZGUvTm9kZVRlbXBsYXRlUGx1Z2luXCIpO1xyXG52YXIgTm9kZVRhcmdldFBsdWdpbiA9IHJlcXVpcmUoXCJ3ZWJwYWNrL2xpYi9ub2RlL05vZGVUYXJnZXRQbHVnaW5cIik7XHJcbnZhciBMaWJyYXJ5VGVtcGxhdGVQbHVnaW4gPSByZXF1aXJlKFwid2VicGFjay9saWIvTGlicmFyeVRlbXBsYXRlUGx1Z2luXCIpO1xyXG52YXIgU2luZ2xlRW50cnlQbHVnaW4gPSByZXF1aXJlKFwid2VicGFjay9saWIvU2luZ2xlRW50cnlQbHVnaW5cIik7XHJcbnZhciBMaW1pdENodW5rQ291bnRQbHVnaW4gPSByZXF1aXJlKFwid2VicGFjay9saWIvb3B0aW1pemUvTGltaXRDaHVua0NvdW50UGx1Z2luXCIpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNvdXJjZSkge1xyXG5cdGlmKHRoaXMuY2FjaGVhYmxlKSB0aGlzLmNhY2hlYWJsZSgpO1xyXG5cdHJldHVybiBzb3VyY2U7XHJcbn07XHJcbm1vZHVsZS5leHBvcnRzLnBpdGNoID0gZnVuY3Rpb24ocmVxdWVzdCkge1xyXG5cdGlmKHRoaXMuY2FjaGVhYmxlKSB0aGlzLmNhY2hlYWJsZSgpO1xyXG5cdHZhciBxdWVyeSA9IGxvYWRlclV0aWxzLnBhcnNlUXVlcnkodGhpcy5xdWVyeSk7XHJcblx0dGhpcy5hZGREZXBlbmRlbmN5KHRoaXMucmVzb3VyY2VQYXRoKTtcclxuXHQvLyBXZSBhbHJlYWR5IGluIGNoaWxkIGNvbXBpbGVyLCByZXR1cm4gZW1wdHkgYnVuZGxlXHJcblx0aWYodGhpc1tfX2Rpcm5hbWVdID09PSB1bmRlZmluZWQpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcclxuXHRcdFx0J1wiZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXCIgbG9hZGVyIGlzIHVzZWQgd2l0aG91dCB0aGUgY29ycmVzcG9uZGluZyBwbHVnaW4sICcgK1xyXG5cdFx0XHQncmVmZXIgdG8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luIGZvciB0aGUgdXNhZ2UgZXhhbXBsZSdcclxuXHRcdCk7XHJcblx0fSBlbHNlIGlmKHRoaXNbX19kaXJuYW1lXSA9PT0gZmFsc2UpIHtcclxuXHRcdHJldHVybiBcIlwiO1xyXG5cdH0gZWxzZSBpZih0aGlzW19fZGlybmFtZV0obnVsbCwgcXVlcnkpKSB7XHJcblx0XHRpZihxdWVyeS5vbWl0KSB7XHJcblx0XHRcdHRoaXMubG9hZGVySW5kZXggKz0gK3F1ZXJ5Lm9taXQgKyAxO1xyXG5cdFx0XHRyZXF1ZXN0ID0gcmVxdWVzdC5zcGxpdChcIiFcIikuc2xpY2UoK3F1ZXJ5Lm9taXQpLmpvaW4oXCIhXCIpO1xyXG5cdFx0fVxyXG5cdFx0dmFyIHJlc3VsdFNvdXJjZTtcclxuXHRcdGlmKHF1ZXJ5LnJlbW92ZSkge1xyXG5cdFx0XHRyZXN1bHRTb3VyY2UgPSBcIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXCI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXN1bHRTb3VyY2UgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYocXVlcnkuZXh0cmFjdCAhPT0gZmFsc2UpIHtcclxuXHRcdFx0dmFyIGNoaWxkRmlsZW5hbWUgPSBcImV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbi1vdXRwdXQtZmlsZW5hbWVcIjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXRoLWNvbmNhdFxyXG5cdFx0XHR2YXIgcHVibGljUGF0aCA9IHR5cGVvZiBxdWVyeS5wdWJsaWNQYXRoID09PSBcInN0cmluZ1wiID8gcXVlcnkucHVibGljUGF0aCA6IHRoaXMuX2NvbXBpbGF0aW9uLm91dHB1dE9wdGlvbnMucHVibGljUGF0aDtcclxuXHRcdFx0dmFyIG91dHB1dE9wdGlvbnMgPSB7XHJcblx0XHRcdFx0ZmlsZW5hbWU6IGNoaWxkRmlsZW5hbWUsXHJcblx0XHRcdFx0cHVibGljUGF0aDogcHVibGljUGF0aFxyXG5cdFx0XHR9O1xyXG5cdFx0XHR2YXIgY2hpbGRDb21waWxlciA9IHRoaXMuX2NvbXBpbGF0aW9uLmNyZWF0ZUNoaWxkQ29tcGlsZXIoXCJleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cIiwgb3V0cHV0T3B0aW9ucyk7XHJcblx0XHRcdGNoaWxkQ29tcGlsZXIuYXBwbHkobmV3IE5vZGVUZW1wbGF0ZVBsdWdpbihvdXRwdXRPcHRpb25zKSk7XHJcblx0XHRcdGNoaWxkQ29tcGlsZXIuYXBwbHkobmV3IExpYnJhcnlUZW1wbGF0ZVBsdWdpbihudWxsLCBcImNvbW1vbmpzMlwiKSk7XHJcblx0XHRcdGNoaWxkQ29tcGlsZXIuYXBwbHkobmV3IE5vZGVUYXJnZXRQbHVnaW4oKSk7XHJcblx0XHRcdGNoaWxkQ29tcGlsZXIuYXBwbHkobmV3IFNpbmdsZUVudHJ5UGx1Z2luKHRoaXMuY29udGV4dCwgXCIhIVwiICsgcmVxdWVzdCkpO1xyXG5cdFx0XHRjaGlsZENvbXBpbGVyLmFwcGx5KG5ldyBMaW1pdENodW5rQ291bnRQbHVnaW4oeyBtYXhDaHVua3M6IDEgfSkpO1xyXG5cdFx0XHR2YXIgc3ViQ2FjaGUgPSBcInN1YmNhY2hlIFwiICsgX19kaXJuYW1lICsgXCIgXCIgKyByZXF1ZXN0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhdGgtY29uY2F0XHJcblx0XHRcdGNoaWxkQ29tcGlsZXIucGx1Z2luKFwiY29tcGlsYXRpb25cIiwgZnVuY3Rpb24oY29tcGlsYXRpb24pIHtcclxuXHRcdFx0XHRpZihjb21waWxhdGlvbi5jYWNoZSkge1xyXG5cdFx0XHRcdFx0aWYoIWNvbXBpbGF0aW9uLmNhY2hlW3N1YkNhY2hlXSlcclxuXHRcdFx0XHRcdFx0Y29tcGlsYXRpb24uY2FjaGVbc3ViQ2FjaGVdID0ge307XHJcblx0XHRcdFx0XHRjb21waWxhdGlvbi5jYWNoZSA9IGNvbXBpbGF0aW9uLmNhY2hlW3N1YkNhY2hlXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0XHQvLyBXZSBzZXQgbG9hZGVyQ29udGV4dFtfX2Rpcm5hbWVdID0gZmFsc2UgdG8gaW5kaWNhdGUgd2UgYWxyZWFkeSBpblxyXG5cdFx0XHQvLyBhIGNoaWxkIGNvbXBpbGVyIHNvIHdlIGRvbid0IHNwYXduIGFub3RoZXIgY2hpbGQgY29tcGlsZXJzIGZyb20gdGhlcmUuXHJcblx0XHRcdGNoaWxkQ29tcGlsZXIucGx1Z2luKFwidGhpcy1jb21waWxhdGlvblwiLCBmdW5jdGlvbihjb21waWxhdGlvbikge1xyXG5cdFx0XHRcdGNvbXBpbGF0aW9uLnBsdWdpbihcIm5vcm1hbC1tb2R1bGUtbG9hZGVyXCIsIGZ1bmN0aW9uKGxvYWRlckNvbnRleHQpIHtcclxuXHRcdFx0XHRcdGxvYWRlckNvbnRleHRbX19kaXJuYW1lXSA9IGZhbHNlO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0dmFyIHNvdXJjZTtcclxuXHRcdFx0Y2hpbGRDb21waWxlci5wbHVnaW4oXCJhZnRlci1jb21waWxlXCIsIGZ1bmN0aW9uKGNvbXBpbGF0aW9uLCBjYWxsYmFjaykge1xyXG5cdFx0XHRcdHNvdXJjZSA9IGNvbXBpbGF0aW9uLmFzc2V0c1tjaGlsZEZpbGVuYW1lXSAmJiBjb21waWxhdGlvbi5hc3NldHNbY2hpbGRGaWxlbmFtZV0uc291cmNlKCk7XHJcblxyXG5cdFx0XHRcdC8vIFJlbW92ZSBhbGwgY2h1bmsgYXNzZXRzXHJcblx0XHRcdFx0Y29tcGlsYXRpb24uY2h1bmtzLmZvckVhY2goZnVuY3Rpb24oY2h1bmspIHtcclxuXHRcdFx0XHRcdGNodW5rLmZpbGVzLmZvckVhY2goZnVuY3Rpb24oZmlsZSkge1xyXG5cdFx0XHRcdFx0XHRkZWxldGUgY29tcGlsYXRpb24uYXNzZXRzW2ZpbGVdO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHR2YXIgY2FsbGJhY2sgPSB0aGlzLmFzeW5jKCk7XHJcblx0XHRcdGNoaWxkQ29tcGlsZXIucnVuQXNDaGlsZChmdW5jdGlvbihlcnIsIGVudHJpZXMsIGNvbXBpbGF0aW9uKSB7XHJcblx0XHRcdFx0aWYoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuXHJcblx0XHRcdFx0aWYoY29tcGlsYXRpb24uZXJyb3JzLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRcdHJldHVybiBjYWxsYmFjayhjb21waWxhdGlvbi5lcnJvcnNbMF0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjb21waWxhdGlvbi5maWxlRGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24oZGVwKSB7XHJcblx0XHRcdFx0XHR0aGlzLmFkZERlcGVuZGVuY3koZGVwKTtcclxuXHRcdFx0XHR9LCB0aGlzKTtcclxuXHRcdFx0XHRjb21waWxhdGlvbi5jb250ZXh0RGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24oZGVwKSB7XHJcblx0XHRcdFx0XHR0aGlzLmFkZENvbnRleHREZXBlbmRlbmN5KGRlcCk7XHJcblx0XHRcdFx0fSwgdGhpcyk7XHJcblx0XHRcdFx0aWYoIXNvdXJjZSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcIkRpZG4ndCBnZXQgYSByZXN1bHQgZnJvbSBjaGlsZCBjb21waWxlclwiKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHR2YXIgdGV4dCA9IHRoaXMuZXhlYyhzb3VyY2UsIHJlcXVlc3QpO1xyXG5cdFx0XHRcdFx0aWYodHlwZW9mIHRleHQgPT09IFwic3RyaW5nXCIpXHJcblx0XHRcdFx0XHRcdHRleHQgPSBbWzAsIHRleHRdXTtcclxuXHRcdFx0XHRcdHRleHQuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRcdFx0XHRcdHZhciBpZCA9IGl0ZW1bMF07XHJcblx0XHRcdFx0XHRcdGNvbXBpbGF0aW9uLm1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRcdFx0XHRcdFx0XHRpZihtb2R1bGUuaWQgPT09IGlkKVxyXG5cdFx0XHRcdFx0XHRcdFx0aXRlbVswXSA9IG1vZHVsZS5pZGVudGlmaWVyKCk7XHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR0aGlzW19fZGlybmFtZV0odGV4dCwgcXVlcnkpO1xyXG5cdFx0XHRcdFx0aWYodGV4dC5sb2NhbHMgJiYgdHlwZW9mIHJlc3VsdFNvdXJjZSAhPT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0XHRcdFx0XHRyZXN1bHRTb3VyY2UgKz0gXCJcXG5tb2R1bGUuZXhwb3J0cyA9IFwiICsgSlNPTi5zdHJpbmdpZnkodGV4dC5sb2NhbHMpICsgXCI7XCI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBjYXRjaChlKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gY2FsbGJhY2soZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHJlc3VsdFNvdXJjZSlcclxuXHRcdFx0XHRcdGNhbGxiYWNrKG51bGwsIHJlc3VsdFNvdXJjZSk7XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdFx0fS5iaW5kKHRoaXMpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXNbX19kaXJuYW1lXShcIlwiLCBxdWVyeSk7XHJcblx0XHRcdHJldHVybiByZXN1bHRTb3VyY2U7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luL2xvYWRlci5qc1xuLy8gbW9kdWxlIGlkID0gMzcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=